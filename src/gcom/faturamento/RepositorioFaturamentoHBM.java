package gcom.faturamento;

import gcom.arrecadacao.debitoautomatico.DebitoAutomaticoMovimento;
import gcom.arrecadacao.pagamento.FiltroGuiaPagamento;
import gcom.arrecadacao.pagamento.PagamentoSituacao;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgoto;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.atendimentopublico.ordemservico.ServicoCobrancaValor;
import gcom.atendimentopublico.registroatendimento.RegistroAtendimento;
import gcom.cadastro.cliente.Cliente;
import gcom.cadastro.cliente.ClienteConta;
import gcom.cadastro.cliente.ClienteFone;
import gcom.cadastro.cliente.ClienteRelacaoTipo;
import gcom.cadastro.cliente.EsferaPoder;
import gcom.cadastro.cliente.IClienteConta;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.imovel.Categoria;
import gcom.cadastro.imovel.CategoriaTipo;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.imovel.ImovelContaEnvio;
import gcom.cadastro.imovel.ImovelPerfil;
import gcom.cadastro.imovel.Subcategoria;
import gcom.cadastro.imovel.bean.ImovelCobrarDoacaoHelper;
import gcom.cadastro.localidade.GerenciaRegional;
import gcom.cadastro.localidade.Localidade;
import gcom.cadastro.localidade.Quadra;
import gcom.cadastro.localidade.SetorComercial;
import gcom.cadastro.localidade.UnidadeNegocio;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cobranca.CobrancaSituacao;
import gcom.cobranca.ComandoEmpresaCobrancaConta;
import gcom.cobranca.ComandoEmpresaCobrancaContaHelper;
import gcom.cobranca.ParcelamentoGrupo;
import gcom.cobranca.bean.ContaValoresHelper;
import gcom.cobranca.parcelamento.ParcelamentoSituacao;
import gcom.faturamento.autoinfracao.AutosInfracao;
import gcom.faturamento.bean.ApagarDadosFaturamentoHelper;
import gcom.faturamento.bean.EmitirContaHelper;
import gcom.faturamento.bean.FiltrarEmitirHistogramaAguaEconomiaHelper;
import gcom.faturamento.bean.FiltrarEmitirHistogramaAguaHelper;
import gcom.faturamento.bean.FiltrarEmitirHistogramaEsgotoEconomiaHelper;
import gcom.faturamento.bean.FiltrarEmitirHistogramaEsgotoHelper;
import gcom.faturamento.bean.PrescreverDebitosImovelHelper;
import gcom.faturamento.bean.SituacaoEspecialFaturamentoHelper;
import gcom.faturamento.consumotarifa.ConsumoTarifa;
import gcom.faturamento.consumotarifa.ConsumoTarifaCategoria;
import gcom.faturamento.consumotarifa.ConsumoTarifaFaixa;
import gcom.faturamento.consumotarifa.ConsumoTarifaVigencia;
import gcom.faturamento.conta.Conta;
import gcom.faturamento.conta.ContaCategoria;
import gcom.faturamento.conta.ContaHistorico;
import gcom.faturamento.conta.ContaImpostosDeduzidos;
import gcom.faturamento.conta.ContaMotivoRevisao;
import gcom.faturamento.conta.Fatura;
import gcom.faturamento.conta.FaturaItem;
import gcom.faturamento.conta.IContaCategoria;
import gcom.faturamento.conta.IContaImpostosDeduzidos;
import gcom.faturamento.credito.CreditoARealizar;
import gcom.faturamento.credito.CreditoOrigem;
import gcom.faturamento.credito.CreditoRealizado;
import gcom.faturamento.credito.CreditoRealizadoHistorico;
import gcom.faturamento.credito.CreditoTipo;
import gcom.faturamento.credito.ICreditoRealizado;
import gcom.faturamento.credito.ICreditoRealizadoCategoria;
import gcom.faturamento.debito.DebitoACobrar;
import gcom.faturamento.debito.DebitoACobrarCategoria;
import gcom.faturamento.debito.DebitoACobrarGeral;
import gcom.faturamento.debito.DebitoCobrado;
import gcom.faturamento.debito.DebitoCreditoSituacao;
import gcom.faturamento.debito.DebitoTipo;
import gcom.faturamento.debito.DebitoTipoVigencia;
import gcom.faturamento.debito.IDebitoCobrado;
import gcom.faturamento.debito.IDebitoCobradoCategoria;
import gcom.financeiro.FinanciamentoTipo;
import gcom.financeiro.ResumoFaturamento;
import gcom.financeiro.lancamento.LancamentoTipo;
import gcom.gui.cobranca.cobrancaporresultado.MovimentarOrdemServicoEmitirOSHelper;
import gcom.micromedicao.MovimentoRoteiroEmpresa;
import gcom.micromedicao.Rota;
import gcom.micromedicao.ServicoTipoCelular;
import gcom.micromedicao.SituacaoTransmissaoLeitura;
import gcom.micromedicao.consumo.ConsumoHistorico;
import gcom.micromedicao.consumo.ConsumoTipo;
import gcom.micromedicao.consumo.LigacaoTipo;
import gcom.micromedicao.hidrometro.HidrometroInstalacaoHistorico;
import gcom.micromedicao.leitura.LeituraAnormalidade;
import gcom.micromedicao.medicao.FiltroMedicaoHistoricoSql;
import gcom.micromedicao.medicao.MedicaoHistorico;
import gcom.micromedicao.medicao.MedicaoTipo;
import gcom.relatorio.faturamento.DataLeituraAnteriorHelper;
import gcom.relatorio.faturamento.DataLeituraPrevistaHelper;
import gcom.relatorio.faturamento.FiltrarRelatorioDevolucaoPagamentosDuplicidadeHelper;
import gcom.relatorio.faturamento.FiltrarRelatorioJurosMultasDebitosCanceladosHelper;
import gcom.relatorio.faturamento.ValorAFaturarHelper;
import gcom.relatorio.faturamento.conta.RelatorioContasCanceladasRetificadasHelper;
import gcom.util.CollectionUtil;
import gcom.util.ConstantesSistema;
import gcom.util.ControladorException;
import gcom.util.ErroRepositorioException;
import gcom.util.HibernateUtil;
import gcom.util.RepositorioUtilHBM;
import gcom.util.Util;
import gcom.util.filtro.FiltroParametro;
import gcom.util.filtro.Intervalo;
import gcom.util.filtro.MaiorQue;
import gcom.util.filtro.MenorQue;
import gcom.util.filtro.ParametroNaoNulo;
import gcom.util.filtro.ParametroSimples;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.LazyInitializationException;
import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.StatelessSession;

/**
 * < <Descrição da Classe>>
 * 
 * @author Administrador 
 */
public class RepositorioFaturamentoHBM implements IRepositorioFaturamento {

	protected static IRepositorioFaturamento instancia;

	/**
	 * 
	 * Construtor da classe RepositorioFaturamentoHBM
	 */
	protected RepositorioFaturamentoHBM() {
	}

	/**
	 * Retorna o valor de instance
	 * 
	 * @return O valor de instance
	 */
	public static RepositorioFaturamentoHBM getInstancia() {
		String dialect = HibernateUtil.getDialect();
		
		if (dialect.toUpperCase().contains("ORACLE")){
			if (instancia == null) {
				instancia = new RepositorioFaturamentoHBM();
			}
		} else {
			if (instancia == null) {
				instancia = new RepositorioFaturamentoPostgresHBM();
			}
		}

		return (RepositorioFaturamentoHBM) instancia;
	}

	/**
	 * Método responsável por verificar se existe no banco um determinado ID na
	 * tabela de faturamento_grupo - caso exista o id passado como parâmetro na
	 * tabela, retorna true, caso contrário retorna false
	 * 
	 * @param Integer
	 *            id - id de um FaturamentoGrupo
	 * @return boolean - true para existir o id na tabela, false para não
	 *         existir
	 */
	public boolean verificarExistenciaIdGrupoFaturamento(Integer id)
			throws ErroRepositorioException {
		Integer retorno = null;
		boolean existe = false;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select fg.id from FaturamentoGrupo fg where fg.id = :id";

			retorno = (Integer) session.createQuery(consulta).setInteger("id",
					id.intValue()).setMaxResults(1).uniqueResult();

			if (retorno != null) {
				existe = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return existe;

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaConta(Imovel imovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct.id from Conta ct " + "inner join ct.imovel "
					+ "where ct.referencia = :referencia "
					+ "and ct.imovel.id = :imovel ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"referencia", imovel.getId().intValue()).setInteger(
					"imovel", anoMesReferencia).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param faturamentoGrupo
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @param faturamentoAtividade
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Object[] obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
			FaturamentoGrupo faturamentoGrupo, int anoMesReferencia,
			FaturamentoAtividade faturamentoAtividade)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select fac.dataPrevista,fac.dataRealizacao from FaturamentoAtividadeCronograma fac "
					+ "inner join fac.faturamentoGrupoCronogramaMensal fgcm "
					+ "inner join fgcm.faturamentoGrupo fg "
					+ "inner join fac.faturamentoAtividade fa "
					+ "where  fg.id = :id and fgcm.anoMesReferencia = :anoMesReferencia and fa.id = :fa ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("id",
					faturamentoGrupo.getId()).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("fa",
					faturamentoAtividade.getId()).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * 
	 * @param idFaturamentoAtividadeCronograma
	 * 
	 * @exception ErroRepositorioException
	 *                Erro no BD
	 */
	public void removerTodasRotasPorCronogramaFaturamento(
			Integer idFaturamentoAtividadeCronograma)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		try {
			Iterator iterator = session
					.createQuery(
							"from gcom.faturamento.FaturamentoAtivCronRota as CronogramaRota where CronogramaRota.comp_id.faturamentoAtividadeCronogramaId = :faturamentoAtividadeCronograma")
					.setInteger("faturamentoAtividadeCronograma",
							idFaturamentoAtividadeCronograma.intValue())
					.iterate();

			while (iterator.hasNext()) {
				iterator.next();
				iterator.remove();

			}

			session.flush();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Este caso de uso permite alterar ou excluir um comando de atividade de
	 * faturamento
	 * 
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * 
	 * buscarAtividadeComandadaNaoRealizada
	 * 
	 * @author Roberta Costa
	 * @date 18/07/2006
	 * 
	 * @return uma lista de atividades de faturamento comandadas e ainda não
	 *         realizadas
	 * @throws ErroRepositorioException
	 */
	public Collection buscarAtividadeComandadaNaoRealizada(Integer numeroPagina)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		/**
		 * 
		 * Mudança na ordenação das atividades de faturamento a serem exibidas na tela. 
		 * Ordenando por dataDeComando em ordem decrescente
		 * 
		 * @author Wellington Rocha
		 * @date 03/05/2012*/
		try {

			consulta = "SELECT ftac.id, ftac.faturamentoAtividade, ftac.comando, ftac.dataPrevista"
					+ ", ftcm, ftgr "
					+ "FROM FaturamentoAtividadeCronograma ftac "
					+ "INNER JOIN ftac.faturamentoAtividade ftat "
					+ "INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm "
					+ "INNER JOIN ftcm.faturamentoGrupo ftgr "
					+ "WHERE ftac.comando IS NOT NULL AND "
					+ "(ftac.dataRealizacao IS NULL OR ftac.dataRealizacao < ftac.comando)"
					+ " order by ftac.comando desc, ftgr.id, ftgr.anoMesReferencia, ftat.descricao,  ftac.dataPrevista ";

			retorno = session.createQuery(consulta).setFirstResult(
					10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite alterar ou excluir um comando de atividade de
	 * faturamento
	 * 
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * 
	 * Retorna o count do resultado da pesquisa de Faturamento Atividade
	 * Cronograma não realizadas
	 * 
	 * buscarAtividadeComandadaNaoRealizadaCount
	 * 
	 * @author Roberta Costa
	 * @date 18/07/2006
	 * 
	 * @param filtroFaturamentoAtividadeCronograma
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer buscarAtividadeComandadaNaoRealizadaCount()
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT count(ftac.id)"
					+ "FROM FaturamentoAtividadeCronograma ftac "
					+ "INNER JOIN ftac.faturamentoAtividade ftat "
					+ "INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm "
					+ "INNER JOIN ftcm.faturamentoGrupo ftgr "
					+ "WHERE ftac.comando IS NOT NULL AND "
					+ "(ftac.dataRealizacao IS NULL OR ftac.dataRealizacao < ftac.comando)";

			retorno = (Integer) session.createQuery(consulta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * 
	 * @return uma coleção de FATURAMENTO_ATIVIDADE_CRONOGRAMA
	 * @throws ErroRepositorioException
	 */
	public Collection buscarFaturamentoAtividadeCronograma(String ids)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			// String idsFormatados = ids

			consulta = "SELECT new FaturamentoAtividadeCronograma(ftac.id, ftac.dataPrevista, ftac.dataRealizacao"
					+ ", ftac.comando, ftac.ultimaAlteracao, ftac.faturamentoAtividade, ftac.faturamentoGrupoCronogramaMensal) "
					+ "FROM FaturamentoAtividadeCronograma ftac "
					+ "WHERE ftac.id IN (" + ids + ")";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 26/12/2005
	 * 
	 * @param conta
	 * @return uma coleção com os débitos cobrados de uma conta
	 * @throws ErroRepositorioException
	 */
	public Collection buscarDebitosCobradosConta(Conta conta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT dbcb.id, dbtp.id, dbtp.descricao, dbcb.anoMesReferenciaDebito, "
					+ "dbcb.anoMesCobrancaDebito, dbcb.numeroPrestacao, dbcb.numeroPrestacaoDebito, "
					+ "dbcb.valorPrestacao, dbcb.ultimaAlteracao, dbtp.descricaoAbreviada, fntp.id, "
					+ "lict.id, dbcb.numeroParcelaBonus "
					+ "FROM DebitoCobrado dbcb "
					+ "INNER JOIN dbcb.conta cnta "
					+ "INNER JOIN dbcb.debitoTipo dbtp "
					+ "INNER JOIN dbtp.financiamentoTipo fntp "
					+ "INNER JOIN dbtp.lancamentoItemContabil lict "
					+ "WHERE  cnta.id = :contaid ";

			retorno = session.createQuery(consulta).setInteger("contaid",
					conta.getId().intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection buscarDebitosCobradosEmitirContaCaern(Conta conta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT dbtp.id, dbtp.descricao, "
					+ "dbcb.numeroPrestacao, dbcb.numeroPrestacaoDebito, "
					+ "SUM(dbcb.valorPrestacao)"
					+ ""
					+ "FROM DebitoCobrado dbcb "
					+ "INNER JOIN dbcb.conta cnta "
					+ "INNER JOIN dbcb.debitoTipo dbtp "
					+ "INNER JOIN dbtp.financiamentoTipo fntp "
					+ "INNER JOIN dbtp.lancamentoItemContabil lict "
					+ "WHERE  cnta.id = :contaid "
					+ "GROUP BY  dbtp.id, dbtp.descricao, dbcb.numeroPrestacao, dbcb.numeroPrestacaoDebito";

			retorno = session.createQuery(consulta).setInteger("contaid",
					conta.getId().intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 28/12/2005
	 * 
	 * @param conta
	 * @return uma coleção com os créditos realizados de uma conta
	 * @throws ErroRepositorioException
	 */
	public Collection buscarCreditosRealizadosConta(Conta conta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT crrz.id, crtp.id, crtp.descricao, crtp.descricaoAbreviada, "
					+ "crrz.anoMesReferenciaCredito, crrz.anoMesCobrancaCredito, crrz.numeroPrestacao, "
					+ "crrz.numeroPrestacaoCredito, crrz.valorCredito, crrz.ultimaAlteracao, "
					+ "lict.id, crrz.creditoOrigem.id, crrz.numeroParcelaBonus, car.id "
					+ "FROM CreditoRealizado crrz "
					+ "INNER JOIN crrz.conta cnta "
					+ "INNER JOIN crrz.creditoTipo crtp "
					+ "INNER JOIN crtp.lancamentoItemContabil lict "
					+ "INNER JOIN crrz.creditoOrigem crOr "
					+ "LEFT JOIN crrz.creditoARealizarGeral car "
					+ "WHERE  cnta.id = :contaid ";

			retorno = session.createQuery(consulta).setInteger("contaid",
					conta.getId().intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarConsumoTarifaVigenciaEntreDataLeituraAnterioreDataLeituraAtual(
			ConsumoTarifa consumoTarifa, Date dataLeituraAnterior,
			Date dataLeituraAtual) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ctv from gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "where ctv.dataVigencia between :dataLeituraAnterior  and  :dataLeituraAtual  "
					+ "and ctv.consumoTarifa.id = :idConsumoTarifa "
					+ "order by ctv.dataVigencia ";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifa", consumoTarifa.getId().intValue())
					.setDate("dataLeituraAnterior", dataLeituraAnterior)
					.setDate("dataLeituraAtual", dataLeituraAtual).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * @author Raphael Rossiter
	 * @date 29/06/2007
	 * 
	 * @param consumoTarifa
	 * @param dataFaturamento
	 * @throws ErroRepositorioException
	 */
	public ConsumoTarifaVigencia pesquisarConsumoTarifaVigenciaMenorOUIgualDataFaturamento(
			Integer idConsumoTarifa, Date dataFaturamento)
			throws ErroRepositorioException {

		ConsumoTarifaVigencia retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ctv from gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "where ctv.dataVigencia <= :dataFaturamento and ctv.consumoTarifa.id = :idConsumoTarifa "
					+ "order by ctv.dataVigencia desc ";

			retorno = (ConsumoTarifaVigencia) session.createQuery(consulta)
					.setInteger("idConsumoTarifa", idConsumoTarifa).setDate(
							"dataFaturamento", dataFaturamento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarConsumoTarifaVigenciaMenorDataLeituraAnterior(
			ConsumoTarifa consumoTarifa, Date dataLeituraAnterior)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ctv.id, ctv.dataVigencia "
					+ "from gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "inner join ctv.consumoTarifa ct "
					+ "where ctv.dataVigencia < :dataLeituraAnterior and ct.id = :idConsumoTarifa "
					+ "order by ctv.dataVigencia desc ";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifa", consumoTarifa.getId().intValue())
					.setDate("dataLeituraAnterior", dataLeituraAnterior)
					.setMaxResults(1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarConsumoTarifaCategoria(
			ConsumoTarifaVigencia consumoTarifaVigencia, Categoria categoria)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ctc from ConsumoTarifaCategoria ctc "
					+ "where ctc.consumoTarifaVigencia.id = :idConsumoTarifaVigencia "
					+ "and ctc.categoria.id = :idCategoria "
					+ "and ctc.subCategoria.id = :idSubCategoria ";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifaVigencia", consumoTarifaVigencia.getId())
					.setInteger("idCategoria", categoria.getId()).setInteger(
							"idSubCategoria",
							Subcategoria.SUBCATEGORIA_ZERO.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarConsumoTarifaFaixa(
			ConsumoTarifaCategoria consumoTarifaCategoria)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ctf from ConsumoTarifaFaixa ctf "
					+ "where ctf.consumoTarifaCategoria.id = :idConsumoTarifaCategoria "
					+ "order by ctf.numeroConsumoFaixaInicio ";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifaCategoria",
					consumoTarifaCategoria.getId().intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * Retorna a faixa de consumo de acordo com a tarifa da categoria e o
	 * consumo
	 * 
	 * @author Rafael Corrêa
	 * @date 13/07/2009
	 * 
	 * @param consumoTarifaCategoria
	 * @param consumo
	 * @throws ErroRepositorioException
	 */
	public ConsumoTarifaFaixa pesquisarConsumoTarifaFaixa(
			ConsumoTarifaCategoria consumoTarifaCategoria, Integer consumo)
			throws ErroRepositorioException {

		ConsumoTarifaFaixa retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ctf from ConsumoTarifaFaixa ctf "
					+ "where ctf.consumoTarifaCategoria.id = :idConsumoTarifaCategoria "
					+ "and ctf.numeroConsumoFaixaInicio <= :consumo and ctf.numeroConsumoFaixaFim >= :consumo "
					+ "order by ctf.numeroConsumoFaixaInicio ";

			retorno = (ConsumoTarifaFaixa) session.createQuery(consulta)
					.setInteger("idConsumoTarifaCategoria",
							consumoTarifaCategoria.getId().intValue())
					.setInteger("consumo", consumo).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo Retorna a date de vigência em vigor
	 * de uma tarifa de consumo
	 * 
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConsumoTarifaVigenciaEmVigor(
			ConsumoTarifa consumoTarifa) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT ctv.dataVigencia "
					+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "INNER JOIN ctv.consumoTarifa ct "
					+ "where ct.id = :idConsumoTarifa "
					+ "ORDER BY ctv.dataVigencia DESC";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifa", consumoTarifa.getId().intValue())
					.setMaxResults(1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo Retorna a date de vigência em vigor
	 * de uma tarifa de consumo Pesquisa a Data de Vigencia da Consumo Tarifa e
	 * da Consumo Tarifa Vigencia
	 * 
	 * @author Rafael Santos
	 * @since 11/07/2006
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConsumoTarifaVigenciaEmVigor(
			ConsumoTarifa consumoTarifa, int idConsumoTarifaVigencia)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT ctv.dataVigencia "
					+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "INNER JOIN ctv.consumoTarifa ct "
					+ "where ct.id = :idConsumoTarifa "
					+ "and ctv.id = :idConsumoTarifaVigencia";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifa", consumoTarifa.getId().intValue())
					.setInteger("idConsumoTarifaVigencia",
							idConsumoTarifaVigencia).setMaxResults(1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo
	 * 
	 * Pesquisa a Menor Maior data da vigencia
	 * 
	 * @author Rafael Santos
	 * @since 12/07/2006
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarMenorDataConsumoTarifaVigenciaEmVigor(
			ConsumoTarifa consumoTarifa, int idConsumoTarifaVigencia)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT max(ctv.dataVigencia) "
					+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "INNER JOIN ctv.consumoTarifa ct "
					+ "where ct.id = :idConsumoTarifa "
					+ " and ctv.dataVigencia < (SELECT max(ctv.dataVigencia) "
					+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "INNER JOIN ctv.consumoTarifa ct "
					+ "where ct.id = :idConsumoTarifa "
					+ "and ctv.id = :idConsumoTarifaVigencia)";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifa", consumoTarifa.getId().intValue())
					.setInteger("idConsumoTarifaVigencia",
							idConsumoTarifaVigencia)

					.setMaxResults(1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo Retorna a date de vigência em vigor
	 * de uma tarifa de consumo Pesuisar a Maior Menor data de todas as
	 * vigências do Consumo Tarifa
	 * 
	 * @author Rafael Santos
	 * @since 12/07/2006
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarMaiorDataConsumoTarifaVigencia(
			ConsumoTarifa consumoTarifa) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT max(ctv.dataVigencia) "
					+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "INNER JOIN ctv.consumoTarifa ct "
					+ "where ct.id = :idConsumoTarifa ";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifa", consumoTarifa.getId().intValue())

			.setMaxResults(1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo Retorna a date de vigência em vigor
	 * de uma tarifa de consumo Pesquisa a Maior Menor data das vigencia
	 * 
	 * @author Rafael Santos
	 * @since 11/07/2006
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarMaiorDataConsumoTarifaVigenciaEmVigor(
			ConsumoTarifa consumoTarifa, int idConsumoTarifaVigencia)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT min(ctv.dataVigencia) "
					+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "INNER JOIN ctv.consumoTarifa ct "
					+ "where ct.id = :idConsumoTarifa "
					+ " and ctv.dataVigencia > (SELECT max(ctv.dataVigencia) "
					+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "INNER JOIN ctv.consumoTarifa ct "
					+ "where ct.id = :idConsumoTarifa "
					+ "and ctv.id = :idConsumoTarifaVigencia)";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifa", consumoTarifa.getId().intValue())
					.setInteger("idConsumoTarifaVigencia",
							idConsumoTarifaVigencia)

					.setMaxResults(1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Seleciona a partir da tabela CLIENTE_IMOVEL para IMOV_ID=Id do imóvel e
	 * CLIM_DTRELACAOFIM com o valor correspondente a nulo
	 * 
	 * @param IMOVEL
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteImovelDataRelacaoFimNull(Imovel imovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT clim.cliente, clim.clienteRelacaoTipo, clim.indicadorNomeConta "
					+ "FROM ClienteImovel clim "
					+ "INNER JOIN clim.imovel imov "
					+ "WHERE imov.id = :idImovel AND clim.dataFimRelacao IS NULL";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovel.getId().intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades Autor: Sávio Luiz Data:
	 * 18/01/2006
	 */

	public Integer pesquisarFaturamentoGrupoCronogramaMensal(
			Integer idFaturamentoGrupo, Integer anoMes)
			throws ErroRepositorioException {
		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select fgcm.id "
					+ "from FaturamentoGrupoCronogramaMensal fgcm "
					+ "left join fgcm.faturamentoGrupo faturamentoGrupo "
					+ "where fgcm.anoMesReferencia = :anoMes and "
					+ "faturamentoGrupo.id = :idFaturamentoGrupo ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idFaturamentoGrupo", idFaturamentoGrupo.intValue())
					.setInteger("anoMes", anoMes.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades Autor: Sávio Luiz Data:
	 * 18/01/2006
	 */

	public Integer pesquisarFaturamentoAtividadeCronograma(
			Integer idFaturamentoGrupoCronogramaMensal,
			Integer idFaturamentoAtividade) throws ErroRepositorioException {
		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select fac.id "
					+ "from FaturamentoAtividadeCronograma fac "
					+ "left join fac.faturamentoAtividade fa "
					+ "left join fac.faturamentoGrupoCronogramaMensal fgcm "
					+ "where fa.id = :idFaturamentoAtividade and "
					+ "fgcm.id = :idFaturamentoGrupoCronogramaMensal ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idFaturamentoGrupoCronogramaMensal",
					idFaturamentoGrupoCronogramaMensal.intValue()).setInteger(
					"idFaturamentoAtividade", idFaturamentoAtividade)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades Autor: Sávio Luiz Data:
	 * 18/01/2006
	 */

	// autor : Sávio Luiz atualiza a data de realização e a data de ultima
	// alteração
	// do faturamento atividade cronograma
	public void atualizarFaturamentoAtividadeCronograma(
			Integer idFaturamentoAtividadeCronograma, Date dataRealizada)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			atualizarImovel = "update gcom.faturamento.FaturamentoAtividadeCronograma "
					+ "set ftac_tmrealizacao = :dataRealizacao,ftac_tmultimaalteracao = :dataUltimaAlteracao where ftac_id = :idFaturamentoAtividadeCronograma";

			session.createQuery(atualizarImovel).setTimestamp("dataRealizacao",
					dataRealizada).setTimestamp("dataUltimaAlteracao",
					new Date()).setInteger("idFaturamentoAtividadeCronograma",
					idFaturamentoAtividadeCronograma.intValue())
					.executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Rhawi Dantas
	 * @created 18/01/2006
	 * 
	 */
	public void inserirFaturamentoSituacaoHistorico(
			Collection collectionFaturamentoSituacaoHistorico)
			throws ErroRepositorioException {
		StatelessSession session = HibernateUtil.getStatelessSession();
		Iterator iteratorFSH = collectionFaturamentoSituacaoHistorico
				.iterator();
		try {
			// int i = 1;
			while (iteratorFSH.hasNext()) {
				FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = (FaturamentoSituacaoHistorico) iteratorFSH
						.next();
				session.insert(faturamentoSituacaoHistorico);
				/*
				 * if (i % 50 == 0) { // 20, same as the JDBC batch size //
				 * flush a batch of inserts and release memory: session.flush();
				 * session.clear(); } i++;
				 */
			}
			// session.flush();
			// session.clear();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			// session.clear();
			HibernateUtil.closeSession(session);
			// session.close();
		}

	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Diogo Peixoto
	 * @created 18/01/2006, 27/04/2011
	 * @param anoMesReferencia
	 * @param opcaoRelatorio
	 * @param estadoMunicipio
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstado(
			int anoMesReferencia,String opcaoRelatorio, boolean estadoMunicipio) throws ErroRepositorioException{
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		String joinMunicipio = "";
		if(estadoMunicipio){
			joinMunicipio = " INNER JOIN rf.localidade loc INNER JOIN loc.municipio ";
		}
		try {

			consulta = "select sum(rf.valorItemFaturamento), " + // 0
					"lt.descricao, " + // 1
					"li.descricao, " + // 2
					"lic.descricao, " + // 3
					"lt.indicadorImpressao, " + // 4
					"lt.indicadorTotal, " + // 5
					"lt.id, " + // 6
					"lt.lancamentoTipo.id, " + // 7
					"rf.categoria.id, " + // 8
					"rf.sequenciaTipoLancamento, " + // 9
					"rf.sequenciaItemTipoLancamento " + // 10
					"from ResumoFaturamento rf "
					+ "left join rf.lancamentoTipo lt "
					+ "left join rf.lancamentoItem li "
					+ "left join rf.lancamentoItemContabil lic "
					+ joinMunicipio
					+ "where rf.anoMesReferencia = :anoMesReferencia and "
					+ "(rf.categoria.id = 1 or " + "rf.categoria.id = 2 or "
					+ "rf.categoria.id = 3 or " + "rf.categoria.id = 4) ";
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				consulta += "and lt.indicadorResumido = "
						+ LancamentoTipo.INDICADOR_RESUMIDO_ATIVO;
			}
			consulta += " group by lt.descricao,li.descricao,lic.descricao,lt.indicadorImpressao,lt.indicadorTotal,lt.id,lt.lancamentoTipo.id,rf.categoria.id,rf.sequenciaTipoLancamento,rf.sequenciaItemTipoLancamento  "
					+ "order by rf.sequenciaTipoLancamento,rf.sequenciaItemTipoLancamento,rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstadoPorGerenciaRegional(
			int anoMesReferencia, String opcaoRelatorio)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(rf.valorItemFaturamento), "
					+ // 0
					"lt.descricao, "
					+ // 1
					"li.descricao, "
					+ // 2
					"lic.descricao, "
					+ // 3
					"lt.indicadorImpressao, "
					+ // 4
					"lt.indicadorTotal, "
					+ // 5
					"lt.id, "
					+ // 6
					"lt.lancamentoTipo.id, "
					+ // 7
					"rf.categoria.id, "
					+ // 8
					"rf.gerenciaRegional.nome, "
					+ // 9
					"rf.gerenciaRegional.id, "
					+ // 10
					"rf.sequenciaTipoLancamento, "
					+ // 11
					"rf.sequenciaItemTipoLancamento "
					+ // 12
					"from ResumoFaturamento rf  "
					+ "left join rf.lancamentoTipo lt "
					+ "left join rf.lancamentoItem li "
					+ "left join rf.lancamentoItemContabil lic "
					+ "where rf.anoMesReferencia = :anoMesReferencia and  "
					+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) ";
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				consulta += "and lt.indicadorResumido = "
						+ LancamentoTipo.INDICADOR_RESUMIDO_ATIVO;
			}
			consulta += " group by rf.gerenciaRegional.nome, rf.gerenciaRegional.id, lt.descricao, li.descricao, "
					+ "lic.descricao, lt.indicadorImpressao,lt.indicadorTotal, lt.id,lt.lancamentoTipo.id,  "
					+ "rf.categoria.id, rf.sequenciaTipoLancamento,rf.sequenciaItemTipoLancamento "
					+ "order by rf.gerenciaRegional.id, rf.sequenciaTipoLancamento,  "
					+ "rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstadoPorLocalidade(
			int anoMesReferencia, String opcaoRelatorio)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(rf.valorItemFaturamento), "
					+ // 0
					"lt.descricao, "
					+ // 1
					"li.descricao, "
					+ // 2
					"lic.descricao, "
					+ // 3
					"lt.indicadorImpressao, "
					+ // 4
					"lt.indicadorTotal, "
					+ // 5
					"lt.id, "
					+ // 6
					"lt.lancamentoTipo.id, "
					+ // 7
					"rf.categoria.id, "
					+ // 8
					"rf.gerenciaRegional.nome, "
					+ // 9
					"rf.gerenciaRegional.id, "
					+ // 10
					"rf.localidade.descricao, "
					+ // 11
					"rf.localidade.id, "
					+ // 12
					"rf.sequenciaTipoLancamento, "
					+ // 13
					"rf.sequenciaItemTipoLancamento, "
					+ // 14
					" rf.unidadeNegocio.nome, "
					+ // 15
					" rf.unidadeNegocio.id, "
					+ // 16
					" rf.localidade.codigoCentroCusto "
					+ "from ResumoFaturamento rf "
					+ "left join rf.lancamentoTipo lt "
					+ "left join rf.lancamentoItem li "
					+ "left join rf.lancamentoItemContabil lic "
					+ "where rf.anoMesReferencia = :anoMesReferencia and "
					+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) ";
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				consulta += "and lt.indicadorResumido = "
						+ LancamentoTipo.INDICADOR_RESUMIDO_ATIVO;
			}
			consulta += " group by rf.gerenciaRegional.nome, rf.gerenciaRegional.id, rf.localidade.descricao, rf.localidade.id, "
					+ "lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, "
					+ "lt.lancamentoTipo.id, rf.categoria.id, rf.sequenciaTipoLancamento, "
					+ "rf.sequenciaItemTipoLancamento,rf.unidadeNegocio.nome, rf.unidadeNegocio.id, "
					+ " rf.localidade.codigoCentroCusto "
					+ " order by "
					+ " rf.localidade.id,"
					+ " rf.unidadeNegocio.id,"
					+ " rf.gerenciaRegional.id,"
					+ " rf.sequenciaTipoLancamento,"
					+ " rf.sequenciaItemTipoLancamento," + " rf.categoria.id";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Diogo Peixoto
	 * @created 25/04/2011
	 * 
	 * @param anoMesReferencia
	 * @param opcaoRelatorio
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstadoPorMunicipio(int anoMesReferencia, String opcaoRelatorio)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		
		try {
			sb.append("SELECT SUM(rf.valorItemFaturamento), "); //0
			sb.append("lt.descricao, "); //1
			sb.append("li.descricao, "); //2
			sb.append("lic.descricao, "); //3
			sb.append("lt.indicadorImpressao, "); //4
			sb.append("lt.indicadorTotal, "); //5
			sb.append("lt.id, "); //6
			sb.append("lt.lancamentoTipo.id, "); //7
			sb.append("rf.categoria.id, "); //8
			sb.append("loc.descricao, "); //9
			sb.append("loc.id, "); //10
			sb.append("muni.nome, "); //11
			sb.append("muni.id, "); //12
			sb.append("rf.sequenciaTipoLancamento, "); //13
			sb.append("rf.sequenciaItemTipoLancamento "); //14
			sb.append("FROM ResumoFaturamento rf LEFT JOIN rf.lancamentoTipo lt ");
			sb.append("LEFT JOIN rf.lancamentoItem li ");
			sb.append("LEFT JOIN rf.lancamentoItemContabil lic ");
			sb.append("INNER JOIN rf.localidade loc ");
			sb.append("INNER JOIN loc.municipio muni ");
			sb.append("WHERE rf.anoMesReferencia = :anoMesReferencia and ");
			sb.append("(rf.categoria.id = 1 or" + " rf.categoria.id = 2 or ");
			sb.append("rf.categoria.id = 3 or" + " rf.categoria.id = 4) ");
					
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				sb.append("and lt.indicadorResumido = ");
				sb.append(LancamentoTipo.INDICADOR_RESUMIDO_ATIVO);
			}
			
			sb.append(" GROUP BY ");
			sb.append("muni.nome, ");
			sb.append("muni.id, ");
			sb.append("loc.descricao, ");
			sb.append("loc.id, ");
			sb.append("lt.descricao, ");
			sb.append("li.descricao, ");
			sb.append("lic.descricao, ");
			sb.append("lt.indicadorImpressao, ");
			sb.append("lt.indicadorTotal, ");
			sb.append("lt.id, ");
			sb.append("lt.lancamentoTipo.id, ");
			sb.append("rf.categoria.id, ");
			sb.append("rf.sequenciaTipoLancamento, ");
			sb.append("rf.sequenciaItemTipoLancamento ");
			sb.append("ORDER BY ");
			sb.append("muni.id, ");
			sb.append("loc.id, ");
			sb.append("rf.sequenciaTipoLancamento, ");
			sb.append("rf.sequenciaItemTipoLancamento, ");
			sb.append("rf.categoria.id ");
			
			retorno = session.createQuery(sb.toString()).setInteger("anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorGerenciaRegional(
			int anoMesReferencia, Integer gerenciaRegional,
			String opcaoRelatorio) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(rf.valorItemFaturamento), "
					+ // 0
					"lt.descricao, "
					+ // 1
					"li.descricao, "
					+ // 2
					"lic.descricao, "
					+ // 3
					"lt.indicadorImpressao, "
					+ // 4
					"lt.indicadorTotal, "
					+ // 5
					"lt.id, "
					+ // 6
					"lt.lancamentoTipo.id, "
					+ // 7
					"rf.categoria.id, "
					+ // 8
					"rf.gerenciaRegional.nome, "
					+ // 9
					"rf.gerenciaRegional.id, "
					+ // 10
					"rf.sequenciaTipoLancamento, "
					+ // 11
					"rf.sequenciaItemTipoLancamento "
					+ // 12
					"from ResumoFaturamento rf "
					+ "left join rf.lancamentoTipo lt "
					+ "left join rf.lancamentoItem li "
					+ "left join rf.lancamentoItemContabil lic "
					+ "where rf.anoMesReferencia = :anoMesReferencia and rf.gerenciaRegional = :gerenciaRegional "
					+ "and (rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) ";
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				consulta += "and lt.indicadorResumido = "
						+ LancamentoTipo.INDICADOR_RESUMIDO_ATIVO;
			}
			consulta += " group by lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, "
					+ "lt.indicadorTotal, lt.id, lt.lancamentoTipo.id, rf.categoria.id, rf.gerenciaRegional.nome, "
					+ "rf.gerenciaRegional.id, rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento "
					+ "order by rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"gerenciaRegional", gerenciaRegional).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorGerenciaRegionalPorLocalidade(
			int anoMesReferencia, Integer gerenciaRegional,
			String opcaoRelatorio) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(rf.valorItemFaturamento), "
					+ // 0
					"lt.descricao, "
					+ // 1
					"li.descricao, "
					+ // 2
					"lic.descricao, "
					+ // 3
					"lt.indicadorImpressao, "
					+ // 4
					"lt.indicadorTotal, "
					+ // 5
					"lt.id, "
					+ // 6
					"lt.lancamentoTipo.id, "
					+ // 7
					"rf.categoria.id, "
					+ // 8
					"rf.gerenciaRegional.nome, "
					+ // 9
					"rf.gerenciaRegional.id, "
					+ // 10
					"rf.localidade.descricao, "
					+ // 11
					"rf.localidade.id, "
					+ // 12
					"rf.sequenciaTipoLancamento, "
					+ // 13
					"rf.sequenciaItemTipoLancamento, "
					+ // 14
					"rf.localidade.codigoCentroCusto "
					+ // 15
					"from ResumoFaturamento rf "
					+ "left join rf.lancamentoTipo lt left join rf.lancamentoItem li "
					+ "left join rf.lancamentoItemContabil lic "
					+ "where rf.anoMesReferencia = :anoMesReferencia and rf.gerenciaRegional = :gerenciaRegional and "
					+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) ";
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				consulta += "and lt.indicadorResumido = "
						+ LancamentoTipo.INDICADOR_RESUMIDO_ATIVO;
			}
			consulta += " group by rf.localidade.descricao, rf.localidade.codigoCentroCusto, rf.localidade.id,  lt.descricao, "
					+ "li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, "
					+ "lt.lancamentoTipo.id, rf.categoria.id, rf.gerenciaRegional.nome, rf.gerenciaRegional.id, "
					+ "rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento  "
					+ "order by rf.localidade.codigoCentroCusto, rf.localidade.id, rf.sequenciaTipoLancamento,  "
					+ "rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"gerenciaRegional", gerenciaRegional).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorLocalidade(
			int anoMesReferencia, Integer localidade, String opcaoRelatorio)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(rf.valorItemFaturamento), "
					+ // 0
					"lt.descricao, "
					+ // 1
					"li.descricao, "
					+ // 2
					"lic.descricao, "
					+ // 3
					"lt.indicadorImpressao, "
					+ // 4
					"lt.indicadorTotal, "
					+ // 5
					"lt.id, "
					+ // 6
					"lt.lancamentoTipo.id, "
					+ // 7
					"rf.categoria.id, "
					+ // 8
					"rf.localidade.descricao, "
					+ // 9
					"rf.localidade.id, "
					+ // 10
					"rf.sequenciaTipoLancamento, "
					+ // 11
					"rf.sequenciaItemTipoLancamento, "
					+ // 12
					"rf.localidade.codigoCentroCusto "
					+ // 13
					"from ResumoFaturamento rf "
					+ "left join rf.lancamentoTipo lt "
					+ "left join rf.lancamentoItem li "
					+ "left join rf.lancamentoItemContabil lic "
					+ "where rf.anoMesReferencia = :anoMesReferencia and "
					+ "rf.localidade = :localidade and "
					+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) ";
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				consulta += "and lt.indicadorResumido = "
						+ LancamentoTipo.INDICADOR_RESUMIDO_ATIVO;
			}
			consulta += " group by  lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, lt.lancamentoTipo.id, "
					+ "rf.categoria.id, rf.localidade.descricao, rf.localidade.codigoCentroCusto, rf.localidade.id, rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento "
					+ "order by rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"localidade", localidade).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Diogo Peixoto
	 * @created 25/04/2011
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorMunicipio(int anoMesReferencia, Integer municipio,String opcaoRelatorio)
			throws ErroRepositorioException{
		
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		try {

			sb.append("SELECT SUM(rf.valorItemFaturamento), "); //0
			sb.append("lt.descricao, "); //1
			sb.append("li.descricao, "); //2
			sb.append("lic.descricao, "); //3
			sb.append("lt.indicadorImpressao, "); //4
			sb.append("lt.indicadorTotal, "); //5
			sb.append("lt.id, "); //6
			sb.append("lt.lancamentoTipo.id, "); //7
			sb.append("rf.categoria.id, "); //8
			sb.append("muni.nome, "); //9
			sb.append("muni.id, "); //10
			sb.append("rf.sequenciaTipoLancamento, "); //11
			sb.append("rf.sequenciaItemTipoLancamento "); //12
			sb.append("FROM ResumoFaturamento rf LEFT JOIN rf.lancamentoTipo lt ");
			sb.append("LEFT JOIN rf.lancamentoItem li ");
			sb.append("LEFT JOIN rf.lancamentoItemContabil lic ");
			sb.append("INNER JOIN rf.localidade loc ");
			sb.append("INNER JOIN loc.municipio muni ");
			sb.append("WHERE rf.anoMesReferencia = :anoMesReferencia and ");
			sb.append(" muni.id = :municipio and");
			sb.append("(rf.categoria.id = 1 or" + " rf.categoria.id = 2 or ");
			sb.append("rf.categoria.id = 3 or" + " rf.categoria.id = 4) ");
			
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				sb.append("and lt.indicadorResumido = ");
				sb.append(LancamentoTipo.INDICADOR_RESUMIDO_ATIVO);
			}
		
			sb.append(" GROUP BY ");
			sb.append("lt.descricao, ");
			sb.append("li.descricao, ");
			sb.append("lic.descricao, ");
			sb.append("lt.indicadorImpressao, ");
			sb.append("lt.indicadorTotal, ");
			sb.append("lt.id, ");
			sb.append("lt.lancamentoTipo.id, ");
			sb.append("rf.categoria.id, ");
			sb.append("muni.nome, ");
			sb.append("muni.id, ");
			sb.append("rf.sequenciaTipoLancamento, ");
			sb.append("rf.sequenciaItemTipoLancamento ");
			sb.append("ORDER BY ");
			sb.append("rf.sequenciaTipoLancamento, ");
			sb.append("rf.sequenciaItemTipoLancamento, ");
			sb.append("rf.categoria.id ");

			retorno = session.createQuery(sb.toString()).setInteger("anoMesReferencia", anoMesReferencia).setInteger("municipio", municipio).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0146] - Manter Conta Author: Raphael Rossiter Data: 21/01/2006
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImovelManter(Imovel imovel,
			Integer situacaoNormal, Integer situacaoIncluida,
			Integer situacaoRetificada) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cnta.id, " + //0
					"cnta.referencia, " + //1
					"cnta.dataVencimentoConta, " + //2
					"cnta.valorAgua, " + //3
					"cnta.valorEsgoto, " + //4
					"cnta.debitos, " + //5
					"cnta.valorCreditos, " + //6
					"cnta.consumoAgua, " + //7
					"cnta.consumoEsgoto, " + //8
					"cnta.dataValidadeConta, " + //9
					"cnta.dataRevisao, " + //10
					"cnta.debitoCreditoSituacaoAtual, " + //11
					"cnta.referenciaContabil, " + //12
					"cnta.ultimaAlteracao, " + //13
					"cnta.percentualEsgoto, " + //14
					"cnta.consumoTarifa, " + //15
					"cnta.valorImposto " //16
					+ "FROM Conta cnta "
					// + "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE imov_id = :idImovel AND "
					+ "dcst_idatual IN(:normal, :incluida, :retificada)";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovel.getId()).setInteger("normal", situacaoNormal)
					.setInteger("incluida", situacaoIncluida).setInteger(
							"retificada", situacaoRetificada).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0147] - Cancelar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void cancelarContaReferenciaContabilMenorSistemaParametro(
			Conta conta, Integer debitoCreditoSituacaoAnterior)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			// Atualiza apenas os dados (data do cancelamento, motivo, situação
			// anterior, situação atual) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "cnta_dtcancelamento = :dataCancelamento, cmcn_id = :motivo, "
					+ "dcst_idanterior = " + debitoCreditoSituacaoAnterior
					+ ", dcst_idatual = :situacaoAtual, "
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao, "
					+ "cnta_amreferenciacontabil = :referenciaContabil, "
					+ "usur_id = :usuarioLogado " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setDate("dataCancelamento",
					conta.getDataCancelamento()).setInteger("motivo",
					conta.getContaMotivoCancelamento().getId()).setInteger(
					"situacaoAtual",
					conta.getDebitoCreditoSituacaoAtual().getId())
					.setTimestamp("dataUltimaAlteracao",
							conta.getUltimaAlteracao())
					.setInteger("referenciaContabil",
							conta.getReferenciaContabil()).setInteger(
							"idConta", conta.getId()).setInteger(
							"usuarioLogado", conta.getUsuario().getId())
					.executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0147] - Cancelar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void cancelarContaReferenciaContabilMaiorIgualSistemaParametro(
			Conta conta) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			// Atualiza apenas os dados (data do cancelamento,
			// motivoCancelamento, situação atual,
			// situação atual, dataRetificacao, motivoRetificacao,
			// referenciaContabil) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "cnta_dtcancelamento = :dataCancelamento, cmcn_id = :motivoCancelamento, "
					+ "dcst_idatual = :situacaoAtual, cnta_dtretificacao = null, "
					+ "cmrt_id = null, cnta_amreferenciacontabil = :referenciaContabil, "
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao, "
					+ "usur_id = :usuarioLogado " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setDate("dataCancelamento",
					conta.getDataCancelamento()).setInteger(
					"motivoCancelamento",
					conta.getContaMotivoCancelamento().getId()).setInteger(
					"situacaoAtual",
					conta.getDebitoCreditoSituacaoAtual().getId()).setInteger(
					"referenciaContabil", conta.getReferenciaContabil())
					.setTimestamp("dataUltimaAlteracao",
							conta.getUltimaAlteracao()).setInteger("idConta",
							conta.getId()).setInteger("usuarioLogado",
							conta.getUsuario().getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0147] - Colocar Revisão Conta Author: Raphael Rossiter Data:
	 * 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void colocarContaRevisao(Conta conta)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			// Atualiza apenas os dados (dataRevisao, motivoRevisao) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "cnta_dtrevisao = :dataRevisao, cmrv_id = :motivoRevisao, "
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao, "
					+ "usur_id = :usuarioLogado " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setDate("dataRevisao",
					conta.getDataRevisao()).setInteger("motivoRevisao",
					conta.getContaMotivoRevisao().getId()).setTimestamp(
					"dataUltimaAlteracao", conta.getUltimaAlteracao())
					.setInteger("idConta", conta.getId()).setInteger(
							"usuarioLogado", conta.getUsuario().getId())
					.executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0149] - Retirar Revisão Conta Author: Raphael Rossiter Data:
	 * 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void retirarContaRevisao(Conta conta)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			// Atualiza apenas os dados (dataRevisao, motivoRevisao) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "cnta_dtrevisao = null, cmrv_id = null, "
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE cnta_id = :idConta ";

			session.createQuery(update).setTimestamp("dataUltimaAlteracao",
					conta.getUltimaAlteracao()).setInteger("idConta",
					conta.getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0151] - Alterar Vencimento Conta Author: Raphael Rossiter Data:
	 * 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void alterarVencimentoConta(Conta conta)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();
		
		PreparedStatement st = null;

//		try {
			// Atualiza apenas os dados (dataRevisao, motivoRevisao) da
			// conta
		try {	
			Connection jdbcCon = session.connection();
			
			update = "UPDATE faturamento.conta SET "
					+ "cnta_dtvencimentoconta = ?, cnta_dtvalidadeconta = ?, "
					+ "cnta_icalteracaovencimento = ?, "
					+ "cnta_tmultimaalteracao = ?, "
					+ "cnta_nnalteracoesvencimento = ? "
					+ "WHERE cnta_id = ? ";
			
			
				st = jdbcCon.prepareStatement(update);
				
				st.setDate(1, Util.getSQLDate(conta.getDataVencimentoConta()));
				st.setDate(2, Util.getSQLDate(conta.getDataValidadeConta()));
				st.setShort(3, conta.getIndicadorAlteracaoVencimento());
				st.setTimestamp(4, Util.getSQLTimesTemp(conta.getUltimaAlteracao()));
				st.setInt(5, conta.getNumeroAlteracoesVencimento());
				st.setInt(6, conta.getId());
				
				st.executeUpdate();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				if (null != st)
					try {
						st.close();
					} catch (SQLException e) {
						throw new ErroRepositorioException(e, "Erro no Hibernate");
					}
				HibernateUtil.closeSession(session);
			}

//			session.createQuery(update).setDate("dataVencimento", conta.getDataVencimentoConta())
//					.setDate("dataValidade", conta.getDataValidadeConta())
//					.setShort("indicadorAlteracaoVencimento", conta.getIndicadorAlteracaoVencimento())
//					.setInteger("numeroAltVencimento", conta.getNumeroAlteracoesVencimento())
//					.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao()).setInteger("idConta", conta.getId()).executeUpdate();

			// erro no hibernate
//		} catch (HibernateException e) {
//			// levanta a exceção para a próxima camada
//			throw new ErroRepositorioException(e, "Erro no Hibernate");
//		} finally {
//			// fecha a sessão
//			HibernateUtil.closeSession(session);
//		}
	}

	public Collection<Integer> pesquisarQuadras(Integer rotaId)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select qd.id from Quadra qd "
					+ "inner join qd.rota rt where rt.id = :rotaId ";

			retorno = session.createQuery(consulta).setInteger("rotaId",
					rotaId.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113 - Faturar Grupo Faturamento] Author: Leonardo Vieira, Rafael
	 * Santos DAta: 17/02/2006 Remove o Resumo Faturamento Simulçao
	 * 
	 * @param idFaturamentoGrupo
	 *            Id do Faturamento Grupo
	 * @param anoMesReferencia
	 *            Ano Mes Referencia
	 * @exception ErroRepositorioException
	 *                Erro de Hibernate
	 */
	/*
	 * public void deletarResumoFaturamentoSimulacao(Integer idFaturamentoGrupo,
	 * Integer anoMesReferencia) throws ErroRepositorioException {
	 * 
	 * Session session = HibernateUtil.getSession(); try { Iterator iterator =
	 * session .createQuery( " select resumoFaturamentoSimulacao " + " from
	 * gcom.faturamento.ResumoFaturamentoSimulacao as resumoFaturamentoSimulacao " + "
	 * inner join resumoFaturamentoSimulacao.faturamentoGrupo as
	 * faturamentoGrupo" + " where resumoFaturamentoSimulacao.anoMesReferencia =
	 * :anoMesReferencia " + " and faturamentoGrupo.id = :idFaturamentoGrupo")
	 * .setInteger("idFaturamentoGrupo",
	 * idFaturamentoGrupo.intValue()).setInteger( "anoMesReferencia",
	 * anoMesReferencia.intValue()) .iterate();
	 * 
	 * while (iterator.hasNext()) { iterator.next(); iterator.remove(); }
	 * session.flush(); } catch (HibernateException e) { // levanta a exceção
	 * para a próxima camada throw new ErroRepositorioException(e, "Erro no
	 * Hibernate"); } finally { // fecha a sessão
	 * HibernateUtil.closeSession(session); } }
	 */

	/**
	 * [UC0113 - Faturar Grupo Faturamento] Author: Leonardo Vieira, Rafael
	 * Santos DAta: 17/02/2006 Remove o Resumo Faturamento Simulçao
	 * 
	 * @param idFaturamentoGrupo
	 *            Id do Faturamento Grupo
	 * @param anoMesReferencia
	 *            Ano Mes Referencia
	 * @exception ErroRepositorioException
	 *                Erro de Hibernate
	 */
	public void deletarResumoFaturamento(Integer anoMesReferencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			String delete = "delete ResumoFaturamento as resumoFaturamento "
					+ "where resumoFaturamento.anoMesReferencia = :anoMesReferencia ";

			session.createQuery(delete).
				setInteger("anoMesReferencia", anoMesReferencia).
				executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	
	/**
	 * [UC0113 - Faturar Grupo Faturamento] Author: Leonardo Vieira, Rafael
	 * Santos DAta: 17/02/2006 Remove o Resumo Faturamento Simulçao
	 * 
	 * @param idFaturamentoGrupo
	 *            Id do Faturamento Grupo
	 * @param anoMesReferencia
	 *            Ano Mes Referencia
	 * @exception ErroRepositorioException
	 *                Erro de Hibernate
	 */
	public void deletarResumoFaturamentoSimulacao(Integer idFaturamentoGrupo,
			Integer anoMesReferencia, Integer idRota)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			String delete = "delete ResumoFaturamentoSimulacao as resumoFaturamentoSimulacao "
					+ "where resumoFaturamentoSimulacao.anoMesReferencia = :anoMesReferencia "
					+ "and resumoFaturamentoSimulacao.faturamentoGrupo.id = :idFaturamentoGrupo "
					+ " and resumoFaturamentoSimulacao.rota.id = :idRota ";

			session.createQuery(delete).setInteger("idFaturamentoGrupo",
					idFaturamentoGrupo.intValue()).setInteger(
					"anoMesReferencia", anoMesReferencia.intValue())
					.setInteger("idRota", idRota.intValue()).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public Object pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
			Integer faturamentoGrupoId, Integer faturamentoAtividadeId)
			throws ErroRepositorioException {

		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select fac.dataRealizacao from FaturamentoAtividadeCronograma fac "
					+ "inner join fac.faturamentoAtividade fa "
					+ "inner join fac.faturamentoGrupoCronogramaMensal fcm "
					+ "inner join fcm.faturamentoGrupo fg "
					+ "where fg.id = :faturamentoGrupoId and fa.id = :faturamentoAtividadeId ";

			retorno = session.createQuery(consulta).setInteger(
					"faturamentoGrupoId", faturamentoGrupoId.intValue())
					.setInteger("faturamentoAtividadeId",
							faturamentoAtividadeId).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Leonardo Vieria, Rafael
	 * Santos Data:17/01/2006 Consultar os Debitos a Cobrar do Imovel
	 * 
	 * @param imovelId
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualId
	 *            Id do Debito Credito Situação
	 * @return Coleção de Debitos a Cobrar
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrar(Integer imovelId,
			Integer debitoCreditoSituacaoAtualId)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			// consulta = "select dc.id, ft.id,
			// ltc.id,dc.valorDebito,dc.numeroPrestacaoDebito,dc.numeroPrestacaoCobradas,
			// "
			// + " debitoTipo.id, localidade.id,quadra.id,
			// dc.codigoSetorComercial,dc.numeroQuadra,dc.numeroLote,dc.numeroSubLote,dc.anoMesReferenciaDebito,dc.anoMesCobrancaDebito,parcelamento.anoMesReferenciaFaturamento,parcelamento.id
			// "
			// + "from DebitoACobrar dc "
			// + "inner join dc.debitoCreditoSituacaoAtual dcs "
			// + "inner join dc.imovel im "
			// + "inner join dc.financiamentoTipo ft "
			// + "inner join dc.lancamentoItemContabil ltc "
			// + "inner join dc.debitoTipo debitoTipo "
			// + "inner join dc.localidade localidade "
			// + "inner join dc.quadra quadra "
			// + "left join dc.parcelamento parcelamento "
			// + "where im.id = :imovelId and dc.numeroPrestacaoCobradas <
			// dc.numeroPrestacaoDebito "
			// + "and dc.debitoCreditoSituacaoAtual.id =
			// :debitoCreditoSituacaoAtualId ";
			//
			// retorno = session.createQuery(consulta).setInteger("imovelId",
			// imovelId.intValue()).setInteger(
			// "debitoCreditoSituacaoAtualId",
			// debitoCreditoSituacaoAtualId).list();

			consulta = "select  "
					+ "  dbac.dbac_id as idDebitoACobrar,  "
					+ "  fntp.fntp_id as idFinaciamentoTipo,  "
					+ "  lict.lict_id as idLancamentoItemContabil,  "
					+ "  dbac.dbac_vldebito as valorDebito,  "
					+ "  dbac.dbac_nnprestacaodebito as numeroPrestacaoDebito,  "
					+ "  dbac.dbac_nnprestacaocobradas as numeroPrestacaoCobradas,  "
					+ "  dbtp.dbtp_id as idDebitoTipo,  "
					+ "  loca.loca_id as idLocalidade,  "
					+ "  qdra.qdra_id as idQuadra,  "
					+ "  dbac.dbac_cdsetorcomercial as codigoSetorComercial,  "
					+ "  dbac.dbac_nnquadra as numeroQuadra,  "
					+ "  dbac.dbac_nnlote as lote,  "
					+ "  dbac.dbac_nnsublote as sublote,  "
					+ "  dbac.dbac_amreferenciadebito as amReferenciaDebito,  "
					+ "  dbac.dbac_amcobrancadebito as amCobrancaDebito,  "
					+ "  parc.parc_amreferenciafaturamento as amReferenciaFaturamento,  "
					+ "  parc.parc_id as idParcelamento,  "
					+ "  dbac.dbac_nnparcelabonus as numeroParcelaBonus  "
					+ "from  "
					+ "  faturamento.debito_a_cobrar dbac   "
					+ " inner join faturamento.debito_credito_situacao dcst on dbac.dcst_idatual=dcst.dcst_id  "
					+ " inner join cadastro.imovel imov  on dbac.imov_id=imov.imov_id  "
					+ " inner join financeiro.financiamento_tipo fntp on dbac.fntp_id=fntp.fntp_id  "
					+ " inner join financeiro.lancamento_item_contabil lict on dbac.lict_id=lict.lict_id  "
					+ " inner join faturamento.debito_tipo dbtp on dbac.dbtp_id=dbtp.dbtp_id  "
					+ " inner join cadastro.localidade loca  on dbac.loca_id=loca.loca_id  "
					+ " inner join cadastro.quadra qdra on dbac.qdra_id=qdra.qdra_id  "
					+ " left outer join cobranca.parcelamento parc on dbac.parc_id=parc.parc_id  "
					+ "where imov.imov_id = :imovelId  "
					+ " and dbac.dbac_nnprestacaocobradas < (dbac.dbac_nnprestacaodebito - coalesce(dbac_nnparcelabonus,0))  "
					/*
					 * INÍCIO_ALTERAÇÃO
					 * Adicionado por: Mariana Victor - 03/08/2011
					 * RM 1887 - Retirar os débitos a cobra quando estiverem em revisão
					 * */
					+ " and (dbac.dbac_dtrevisao is null "
					+ "   and dbac.cmrv_id is null) "
					/* 
					 * FIM_ALTERAÇÃO
					 * */
					+ " and dbac.dcst_idatual = :debitoCreditoSituacaoAtualId";

			retorno = session.createSQLQuery(consulta).addScalar(
					"idDebitoACobrar", Hibernate.INTEGER).addScalar(
					"idFinaciamentoTipo", Hibernate.INTEGER).addScalar(
					"idLancamentoItemContabil", Hibernate.INTEGER).addScalar(
					"valorDebito", Hibernate.BIG_DECIMAL).addScalar(
					"numeroPrestacaoDebito", Hibernate.SHORT).addScalar(
					"numeroPrestacaoCobradas", Hibernate.SHORT).addScalar(
					"idDebitoTipo", Hibernate.INTEGER).addScalar(
					"idLocalidade", Hibernate.INTEGER).addScalar("idQuadra",
					Hibernate.INTEGER).addScalar("codigoSetorComercial",
					Hibernate.INTEGER).addScalar("numeroQuadra",
					Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
					.addScalar("sublote", Hibernate.SHORT).addScalar(
							"amReferenciaDebito", Hibernate.INTEGER).addScalar(
							"amCobrancaDebito", Hibernate.INTEGER).addScalar(
							"amReferenciaFaturamento", Hibernate.INTEGER)
					.addScalar("idParcelamento", Hibernate.INTEGER).addScalar(
							"numeroParcelaBonus", Hibernate.SHORT).setInteger(
							"imovelId", imovelId.intValue()).setInteger(
							"debitoCreditoSituacaoAtualId",
							debitoCreditoSituacaoAtualId).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Rafael Santos Data:
	 * 13/01/2006 Consultar os Debitos a Cobrar CAtegoria do Debito a Cobrar
	 * 
	 * @param debitoACobrarID
	 *            Id do Debito a Cobrar
	 * @return Coleção de Debitos a Cobrar Categoria
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarCategoria(Integer debitoACobrarID)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select categoria.id, dacc.quantidadeEconomia "
					+ "from DebitoACobrarCategoria dacc "
					+ "inner join dacc.categoria categoria "
					+ "inner join dacc.debitoACobrar debitoACobrar "
					+ "where debitoACobrar.id = :debitoACobrarID";

			retorno = session.createQuery(consulta).setInteger(
					"debitoACobrarID", debitoACobrarID).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Leonardo Vieria, Rafael
	 * Santos Data:17/01/2006 Consultar os Cre´ditos a Realizar do Imovel
	 * 
	 * @param imovelId
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualId
	 *            Id do Debito Credito Situação
	 * @return Coleção de Creditos a Realizar
	 * @exception ErroRepositorioException
	 */
	public Object[] pesquisarCreditoARealizar(
			Integer IdCreditoARealizar,Integer anoMesFaturamento)
			throws ErroRepositorioException {
		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = 
					  "select crar.crar_id as idCreditoARealizar,crar.crar_vlcredito as valorCredito "
					+ " from "
					+ "  faturamento.credito_a_realizar crar "
					+ " inner join faturamento.debito_credito_situacao dcst on crar.dcst_idatual=dcst.dcst_id "
					+ " inner join cadastro.imovel imov on crar.imov_id=imov.imov_id "
					+ " inner join faturamento.credito_tipo crti on crar.crti_id=crti.crti_id "
					+ " inner join financeiro.lancamento_item_contabil lict on crar.lict_id=lict.lict_id "
					+ " inner join cadastro.localidade loca on crar.loca_id=loca.loca_id "
					+ " inner join cadastro.quadra qdra on crar.qdra_id=qdra.qdra_id "
					+ " inner join faturamento.credito_origem crog on crar.crog_id=crog.crog_id "
					+ " left outer join cobranca.parcelamento parc on crar.parc_id=parc.parc_id "
					+ " where  crar.crar_id = :idCreditoARealizar "
					+ "  and (parc.parc_id is null or crar.crar_nnprestacaorealizadas>1 or (parc.parc_id is not null) "
					+ "       and crar.crar_nnprestacaorealizadas=1 and parc.parc_amreferenciafaturamento< :anoMesFaturamento) ";

			retorno = 
				(Object[])session.createSQLQuery(consulta).
				addScalar( "idCreditoARealizar", Hibernate.INTEGER ).
				addScalar("valorCredito",Hibernate.BIG_DECIMAL).
				setInteger("idCreditoARealizar", IdCreditoARealizar).
				setInteger("anoMesFaturamento",anoMesFaturamento).
				setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Leonardo Vieria, Rafael
	 * Santos Data:17/01/2006 Consultar os Cre´ditos a Realizar do Imovel
	 * 
	 * @param imovelId
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualId
	 *            Id do Debito Credito Situação
	 * @return Coleção de Creditos a Realizar
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizar(Integer imovelId,
			Integer debitoCreditoSituacaoAtualId, int anoMesFaturamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			// consulta = "select
			// cr.id,cr.numeroPrestacaoRealizada,cr.numeroPrestacaoRealizada,cr.valorCredito,cr.valorResidualMesAnterior,"
			// +
			// "creditoTipo.id,lancamentoItemContabil.id,localidade.id,quadra.id,cr.codigoSetorComercial,cr.numeroQuadra,cr.numeroLote,
			// "
			// +
			// "cr.numeroSubLote,cr.anoMesReferenciaCredito,cr.anoMesCobrancaCredito,cr.numeroPrestacaoRealizada,cr.numeroPrestacaoCredito,
			// "
			// + "creditoOrigem.id "
			// + "from CreditoARealizar cr "
			// + "inner join cr.debitoCreditoSituacaoAtual dcs "
			// + "inner join cr.imovel im "
			// + "inner join cr.creditoTipo creditoTipo "
			// + "inner join cr.lancamentoItemContabil lancamentoItemContabil "
			// + "inner join cr.localidade localidade "
			// + "inner join cr.quadra quadra "
			// + "inner join cr.creditoOrigem creditoOrigem "
			// + "left join cr.parcelamento parcelamento "
			// + "where im.id = :imovelId and cr.debitoCreditoSituacaoAtual.id =
			// :debitoCreditoSituacaoAtualId "
			// + "and (cr.numeroPrestacaoRealizada < cr.numeroPrestacaoCredito
			// or cr.valorResidualMesAnterior > 0) and "
			// + " ((parcelamento.id is null) "
			// + "or (cr.numeroPrestacaoRealizada > 0) "
			// + "or (parcelamento.id is not null and
			// cr.numeroPrestacaoRealizada = 0 and
			// parcelamento.anoMesReferenciaFaturamento < :anoMesFaturamento))
			// ";
			//
			// retorno = session.createQuery(consulta).setInteger("imovelId",
			// imovelId.intValue()).setInteger(
			// "debitoCreditoSituacaoAtualId",
			// debitoCreditoSituacaoAtualId).setInteger(
			// "anoMesFaturamento", anoMesFaturamento).list();

			consulta = "select "
					+ "  crar.crar_id as idCreditoARealizar, " //0
					+ "  crar.crar_nnprestacaorealizadas as numeroPrestacaoRealizada, "//1
					+ "  crar.crar_nnprestacaocredito as numeroPrestacaoCredito, "//2
					+ "  crar.crar_vlcredito as valorCredito, "//3
					+ "  crar.crar_vlresidualmesanterior as valorResidualMesAnterior, "//4
					+ "  crti.crti_id as idCreditoTipo, "//5
					+ "  lict.lict_id as idLancamentoItemContabil, "//6
					+ "  loca.loca_id as idLocalidade, "//7
					+ "  qdra.qdra_id as idQuadra, "//8
					+ "  crar.crar_cdsetorcomercial as codigoSetorComercial, "//9
					+ "  crar.crar_nnquadra as numeroQuadra, "//10
					+ "  crar.crar_nnlote as lote, "//11
					+ "  crar.crar_nnsublote as sublote, "//12
					+ "  crar.crar_amreferenciacredito as amReferenciaCredito, "//13
					+ "  crar.crar_amcobrancacredito as amCobrancaCredito, "//14
					+ "  crog.crog_id as idCreditoOrigem, "//15
					+ "  crar.crar_nnparcelabonus as numeroParcelaBonus, "//16
					+ "  crar.crar_tmatucredito as tmCredito "//17
					+ " from "
					+ "  faturamento.credito_a_realizar crar "
					+ " inner join faturamento.debito_credito_situacao dcst on crar.dcst_idatual=dcst.dcst_id "
					+ " inner join cadastro.imovel imov on crar.imov_id=imov.imov_id "
					+ " inner join faturamento.credito_tipo crti on crar.crti_id=crti.crti_id "
					+ " inner join financeiro.lancamento_item_contabil lict on crar.lict_id=lict.lict_id "
					+ " inner join cadastro.localidade loca on crar.loca_id=loca.loca_id "
					+ " inner join cadastro.quadra qdra on crar.qdra_id=qdra.qdra_id "
					+ " inner join faturamento.credito_origem crog on crar.crog_id=crog.crog_id "
					+ " left outer join cobranca.parcelamento parc on crar.parc_id=parc.parc_id "
					+ " where  imov.imov_id= :imovelId "
					+ "  and crar.dcst_idatual= :debitoCreditoSituacaoAtualId "
					+ "  and (crar.crar_nnprestacaorealizadas<"
					+ "      (crar.crar_nnprestacaocredito - coalesce(crar.crar_nnparcelabonus, 0)) "
					+ "      or crar.crar_vlresidualmesanterior>0) "
					+ "  and (parc.parc_id is null or crar.crar_nnprestacaorealizadas>0 or (parc.parc_id is not null "
					+ "       and crar.crar_nnprestacaorealizadas=0 and parc.parc_amreferenciafaturamento< :anoMesFaturamento) ) ";

			retorno = session.createSQLQuery(consulta).addScalar(
					"idCreditoARealizar", Hibernate.INTEGER).addScalar(
					"numeroPrestacaoRealizada", Hibernate.SHORT).addScalar(
					"numeroPrestacaoCredito", Hibernate.SHORT).addScalar(
					"valorCredito", Hibernate.BIG_DECIMAL).addScalar(
					"valorResidualMesAnterior", Hibernate.BIG_DECIMAL)
					.addScalar("idCreditoTipo", Hibernate.INTEGER).addScalar(
							"idLancamentoItemContabil", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar(
							"idQuadra", Hibernate.INTEGER).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("amReferenciaCredito",
							Hibernate.INTEGER).addScalar("amCobrancaCredito",
							Hibernate.INTEGER).addScalar("idCreditoOrigem",
							Hibernate.INTEGER).addScalar("numeroParcelaBonus",
							Hibernate.SHORT).addScalar("tmCredito",
							Hibernate.TIMESTAMP).setInteger("imovelId",
							imovelId.intValue()).setInteger(
							"debitoCreditoSituacaoAtualId",
							debitoCreditoSituacaoAtualId).setInteger(
							"anoMesFaturamento", anoMesFaturamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Rafael Santos Data:
	 * 14/01/2006 Consultar os Creditos Realizados Categoria do Credito A
	 * Realizar
	 * 
	 * @param creditoARealizarID
	 *            Id do Creditoa A Realizar
	 * @return Coleção de Creditoa a Realizar Categoria
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarCreditoRealizarCategoria(
			Integer creditoARealizarID) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select categoria.id,creditoARealizar.id, crc.quantidadeEconomia "
					+ "from "
					+ "CreditoARealizarCategoria crc "
					+ "inner join crc.categoria categoria "
					+ "inner join crc.creditoARealizar creditoARealizar "
					+ "where creditoARealizar.id = :creditoARealizarID";

			retorno = session.createQuery(consulta).setInteger(
					"creditoARealizarID", creditoARealizarID).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Metódo responsável por inserir um
	 * objeto de ResumoFaturamento no sistema
	 * 
	 * @param resumoFaturamento
	 *            Objeto de resumo de faturamento que vai ser inserido
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void inserirResumoFaturamentoAnoMesReferencia(
			ResumoFaturamento resumoFaturamento)
			throws ErroRepositorioException {
		// obtém uma instância com o hibernate
		Session session = HibernateUtil.getSession();
		try {
			// inseri o objeto na base de dados
			session.save(resumoFaturamento);

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 01 Retorna o valor de água
	 * acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual a normal
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no Hibernate
	 */
	public ResumoFaturamento acumularValorAguaSituacaoContaNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(ctcg.valorAgua),cnta.localidade,cnta.localidade.gerenciaRegional,ctcg.comp_id.categoria, cnta.localidade.unidadeNegocio ) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "left join cnta.localidade loca "
					+ "left join ctcg.comp_id.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "group by cnta.referencia,cnta.localidade,cnta.localidade.gerenciaRegional,ctcg.comp_id.categoria, cnta.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 02 Retorna o valor de esgoto
	 * acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual a normal
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no Hibernate
	 */
	public ResumoFaturamento acumularValorEsgotoSituacaoContaNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(ctcg.valorEsgoto),cnta.localidade,cnta.localidade.gerenciaRegional,ctcg.comp_id.categoria, cnta.localidade.unidadeNegocio ) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "left join cnta.localidade loca "
					+ "left join ctcg.comp_id.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "group by cnta.referencia,cnta.localidade,cnta.localidade.gerenciaRegional,ctcg.comp_id.categoria, cnta.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.uniqueResult();
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 03 e 04 Retorna uma coleção
	 * de débitos a cobrar por ano e mês de referência, por gerência regional,
	 * localidade e categoria
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @param idLancamentoItemContabil
	 *            Código do itemde lançamento contábil
	 * @return retorna a coleção pesquisada de acordo com os parâmetros
	 *         informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalFinanciamentoServico(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pesquisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.lancamentoItemContabil.id = :idLancamentoItemContabil "
					+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
					+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idLancamentoItemContabil",
					idLancamentoItemContabil).setInteger("idFinanciamentoTipo",
					FinanciamentoTipo.SERVICO_NORMAL).setInteger(
					"idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 07 Retorna o valor de guia
	 * de pagamento acumulado, de acordo com o ano/mês de referência, a situação
	 * da conta igual a normal e o tipo de financiamento igual a serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorGuiaPagamentoSituacaoNormalFinanciamentoServico(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar o resultado da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(gupg.anoMesReferenciaContabil,sum(gpct.valorCategoria),lcic.sequenciaImpressao,lcic,gupg.localidade,gupg.localidade.gerenciaRegional,gpct.categoria, gupg.localidade.unidadeNegocio ) "
					+ "from GuiaPagamentoCategoria gpct "
					+ "inner join gpct.guiaPagamento gupg "
					+ "inner join gupg.lancamentoItemContabil lcic "
					+ "where gupg.anoMesReferenciaContabil = :anoMesReferencia "
					+ "and gupg.localidade.id = :idLocalidade "
					+ "and gpct.categoria.id = :idCategoria "
					+ "and (gupg.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or gupg.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
					+ "and (gupg.financiamentoTipo = :idFinanciamentoTipo) "
					+ "group by gupg.anoMesReferenciaContabil,lcic.sequenciaImpressao,lcic,gupg.localidade,gupg.localidade.gerenciaRegional,gpct.categoria,gupg.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.NORMAL).setInteger(
					"idSituacaoAnterior", DebitoCreditoSituacao.NORMAL)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.SERVICO_NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 17 e 18 Retorna uma coleção
	 * de débitos a cobrar por ano e mês de referência, por gerência regional,
	 * localidade e categoria
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @param idLancamentoItemContabil
	 *            Código de lançamento de item contábil
	 * @return retorna a coleção pesquisada de acordo com os parâmetros
	 *         informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoFinanciamentoServico(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria a coleçãoque vai armazenar os débitos a cobrar pesquisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.lancamentoItemContabil.id = :idLancamentoItemContabil "
					+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
					+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idLancamentoItemContabil",
					idLancamentoItemContabil).setInteger("idFinanciamentoTipo",
					FinanciamentoTipo.SERVICO_NORMAL).setInteger(
					"idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 27 Retorna o valor de água
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorAguaSituacaoCancelada(int anoMesReferencia,
			int idLocalidade, int idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(ctcg.valorAgua) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and ctcg.comp_id.categoria.id = :idCategoria "
					+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.CANCELADA).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 28 Retorna o valor de esgoto
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorEsgotoSituacaoCancelada(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(ctcg.valorEsgoto) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and ctcg.comp_id.categoria.id = :idCategoria "
					+ "and cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA;

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 29 Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoServicoSituacaoCancelada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria a coleção que vai armazenar os resumos de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "inner join dbcb.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join dccg.categoria catg "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and lict.id = :idLancamentoItemContabil "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idLancamentoItemContabil",
					idLancamentoItemContabil).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.CANCELADA).setInteger(
					"idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 30 Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a parcelamento de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoParcelamentoAguaSituacaoCancelada(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join dccg.categoria catg "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.CANCELADA).setInteger(
					"idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_AGUA)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 31 Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a parcelamento de
	 * esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoParcelamentoEsgotoSituacaoCancelada(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join dccg.categoria catg "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.CANCELADA).setInteger(
					"idFinanciamentoTipo",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 32 Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a parcelamento de
	 * serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoParcelamentoServicoSituacaoCancelada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria a coleção que vai armazenar a coleção de resumo de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "inner join dbcb.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join dccg.categoria catg "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and lict.id = :idLancamentoItemContabil "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", DebitoCreditoSituacao.CANCELADA)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.PARCELAMENTO_SERVICO)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 33 Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a juros de parcelamento
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoJurosParcelamentoSituacaoCancelada(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objetode resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join dccg.categoria catg "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.CANCELADA)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.JUROS_PARCELAMENTO)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 08 Retorna o valor de água
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a incluída
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorAguaSituacaoIncluida(int anoMesReferencia,
			int idLocalidade, int idCategoria) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(ctcg.valorAgua) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ "or cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior )";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.INCLUIDA).setInteger(
					"idSituacaoAnterior", DebitoCreditoSituacao.INCLUIDA)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 09 Retorna o valor de esgoto
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a incluída
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorEsgotoSituacaoIncluida(int anoMesReferencia,
			int idLocalidade, int idCategoria) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(ctcg.valorEsgoto) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual or "
					+ "cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.INCLUIDA).setInteger(
					"idSituacaoAnterior", DebitoCreditoSituacao.INCLUIDA)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 10 Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a incluída e o tipo de financiamento igual a serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoTipoFinanciamentoServicoSituacaoIncluida( int
	 * anoMesReferencia, int idLocalidade, int idCategoria, Integer
	 * idLancamentoItemContabil) throws ErroRepositorioException {
	 *  // cria a coleção que vai armazenar a coleção de resumo de faturamento
	 * BigDecimal retorno = null;
	 *  // cria uma sessão com o hibernate Session session =
	 * HibernateUtil.getSession();
	 *  // cria a variável que vai conter o hql String consulta;
	 * 
	 * try { // constroi o hql consulta = "select sum(dccg.valorCategoria) " +
	 * "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb " +
	 * "inner join dbcb.lancamentoItemContabil lict " + "inner join dbcb.conta
	 * cnta " + "inner join cnta.localidade loca " + "inner join dccg.categoria
	 * catg " + "where cnta.referenciaContabil = :anoMesReferencia " + "and
	 * lict.id = :idLancamentoItemContabil " + "and loca.id = :idLocalidade " +
	 * "and catg.id = :idCategoria " + "and (cnta.debitoCreditoSituacaoAtual =
	 * :idSituacaoAtual or " + "cnta.debitoCreditoSituacaoAnterior =
	 * :idSituacaoAnterior) " + "and (dbcb.financiamentoTipo =
	 * :idFinanciamentoTipo) ";
	 *  // executa o hql retorno = (BigDecimal) session.createQuery(consulta)
	 * .setInteger("anoMesReferencia", anoMesReferencia)
	 * .setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
	 * .setInteger("idLocalidade", idLocalidade) .setInteger("idCategoria",
	 * idCategoria)
	 * .setInteger("idSituacaoAtual",DebitoCreditoSituacao.INCLUIDA)
	 * .setInteger("idSituacaoAnterior",DebitoCreditoSituacao.INCLUIDA)
	 * .setInteger("idFinanciamentoTipo",FinanciamentoTipo.SERVICO_NORMAL)
	 * .uniqueResult();
	 *  // erro no hibernate } catch (HibernateException e) { // levanta a
	 * exceção para a próxima camada throw new ErroRepositorioException(e, "Erro
	 * no Hibernate"); } finally { // fecha a sessão
	 * HibernateUtil.closeSession(session); }
	 *  // retorna a coleção de resumo de faturamento criada return retorno; }
	 */

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 62 Retorna o valor de
	 * categoria de débito acumulado, de acordo com o ano/mês de referência, a
	 * situação da conta igual a normal e o tipo de financiamento igual a
	 * serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoTipoFinanciamentoServicoSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "inner join dbcb.conta cnta "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacao",
					DebitoCreditoSituacao.NORMAL).setInteger(
					"idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 41 Retorna o valor de
	 * categoria de débito acumulado, de acordo com o ano/mês de referência, a
	 * situação da conta igual a normal e o tipo de financiamento igual a
	 * serviço, quando o número de prestações cobradas for maior que 11(onze)
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoTipoFinanciamentoServicoSituacaoNormalNumeroPrestacoesCobradasMaiorQue11(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "inner join dbcb.conta cnta "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and dbcb.localidade.id = :idLocalidade "
					+ "and dccg.categoria.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) "
					+ "and ((dbcb.numeroPrestacao - dbcb.numeroPrestacaoDebito) > 11) "
					+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.NORMAL).setInteger(
					"idSituacaoAnterior", DebitoCreditoSituacao.NORMAL)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.SERVICO_NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 43 e 44 Retorna uma coleção
	 * de débito a cobrar , de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a documentos emitidos
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoDocumentosEmitidos(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pesquisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
					+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idParcelamentoGrupo",
					ParcelamentoGrupo.DOCUMENTOS_EMITIDOS).setInteger(
					"idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 45 e 46 Retorna uma coleção
	 * de débito a cobrar , de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a financiamentos a cobrar
	 * de curto prazo
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
					+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferenciaContabil", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria)
					.setInteger(
							"idParcelamentoGrupo",
							ParcelamentoGrupo.FINANCIAMENTOS_A_COBRAR_CURTO_PRAZO)
					.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 47 e 48 Retorna uma coleção
	 * de débito a cobrar de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a financiamentos a cobrar
	 * de longo prazo
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
					+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferenciaContabil", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria)
					.setInteger(
							"idParcelamentoGrupo",
							ParcelamentoGrupo.FINANCIAMENTOS_A_COBRAR_LONGO_PRAZO)
					.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 49 e 50 Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a parcelamentos a cobrar
	 * de curto prazo
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
					+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferenciaContabil", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria)
					.setInteger(
							"idParcelamentoGrupo",
							ParcelamentoGrupo.PARCELAMENTOS_A_COBRAR_CURTO_PRAZO)
					.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 51 e 52 Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a parcelamentos a cobrar a
	 * longo prazo
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
					+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferenciaContabil", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria)
					.setInteger(
							"idParcelamentoGrupo",
							ParcelamentoGrupo.PARCELAMENTOS_A_COBRAR_LONGO_PRAZO)
					.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 05 e 06 Retorna uma coleção
	 * de débitos a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a juros cobrados
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoJurosCobrados(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
					+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idParcelamentoGrupo",
					ParcelamentoGrupo.JUROS_COBRADOS).setInteger(
					"idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 34 e 35 Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a cancelado por parcelamento e o grupo de parcelamento igual a
	 * juros cobrados
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoPorParcelamentoGrupoParcelamentoJurosCobrados(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = "
					+ idLocalidade
					+ " "
					+ "and catg.id = "
					+ idCategoria
					+ " "
					+ "and dbac.parcelamentoGrupo.id = "
					+ ParcelamentoGrupo.JUROS_COBRADOS
					+ " "
					+ "and dbac.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA;

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 53 Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação igual a
	 * normal e o tipo de financiamento igual a arrasto de água ou arrasto de
	 * esgoto ou arrasto de serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorDebitoSituacaoNormalTipoFinanciamentoArrastoAguaArrastoEsgotoArrastoServico(
			int anoMesReferenciaContabil, Integer idLocalidade)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select new ResumoFaturamento(dbac.anoMesReferenciaContabil,sum(dbcg.valorCategoria),loca,greg,catg, uneg ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "inner join dbac.financiamentoTipo fntp "
					+ "inner join dbac.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "where loca.id = :idLocalidade "
					+ "and dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
					+ "and (fntp.id = :arrastoAgua or "
					+ "fntp.id = :arrastoEsgoto or "
					+ "fntp.id = :arrastoServico) "
					+ "group by dbac.anoMesReferenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).setInteger(
							"arrastoAgua", FinanciamentoTipo.ARRASTO_AGUA)
					.setInteger("arrastoEsgoto",
							FinanciamentoTipo.ARRASTO_ESGOTO)
					.setInteger("arrastoServico",
							FinanciamentoTipo.ARRASTO_SERVICO).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 19 e 20 Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a cancelado e o tipo de financiamento igual a parcelamento de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoAgua(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
					+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idFinanciamentoTipo",
					FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger(
					"idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 21 e 22 Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a cancelado e o tipo de financiamento igual a parcelamento de
	 * esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
					+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idFinanciamentoTipo",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
					"idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 23 e 24 Retorna uma coleção
	 * de débito a cobrar acumulado, de acordo com o ano/mês de referência, a
	 * situação igual a cancelado e o tipo de financiamento igual a parcelamento
	 * de serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoServico(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.lancamentoItemContabil.id = :idLancamentoItemContabil "
					+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
					+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idLancamentoItemContabil",
					idLancamentoItemContabil).setInteger("idFinanciamentoTipo",
					FinanciamentoTipo.PARCELAMENTO_SERVICO).setInteger(
					"idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 25 e 26 Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a cancelado e o tipo de financiamento igual a juros de parcelamento
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoJurosParcelamento(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
					+ "from DebitoACobrarCategoria dbcg "
					+ "inner join dbcg.comp_id.debitoACobrar dbac "
					+ "inner join dbcg.comp_id.categoria catg "
					+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and dbac.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
					+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idFinanciamentoTipo",
					FinanciamentoTipo.JUROS_PARCELAMENTO).setInteger(
					"idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 64 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * parcelamento de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoAguaSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.PARCELAMENTO_AGUA).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 65 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * parcelamento de esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoEsgotoSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and dbcb.localidade.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 66 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * parcelamento de serviços
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoServicosSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacao",
					DebitoCreditoSituacao.NORMAL).setInteger(
					"idFinanciamentoTipo",
					FinanciamentoTipo.PARCELAMENTO_SERVICO).list();
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 67 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * juros de parcelamento
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoJurosParcelamentoSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.JUROS_PARCELAMENTO)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 42 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * juros de parcelamento e a diferença de prestações maior que 11(onze)
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoJurosParcelamentoSituacaoNormalDiferencaPrestacoesMaiorQue11(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and dbcb.localidade.id = :idLocalidade "
					+ "and dccg.categoria.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
					+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) "
					+ "and ((dbcb.numeroPrestacao - dbcb.numeroPrestacaoDebito) > 11) "
					+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).setInteger(
							"idFinanciamentoTipo",
							FinanciamentoTipo.JUROS_PARCELAMENTO)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 68 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * arrasto de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoAguaSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.ARRASTO_AGUA).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 69 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * arrasto de esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoEsgotoSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.ARRASTO_ESGOTO).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 70 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * arrasto de serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoServicoSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacao",
					DebitoCreditoSituacao.NORMAL).setInteger(
					"idFinanciamentoTipo", FinanciamentoTipo.ARRASTO_SERVICO)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 75 Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e a origem do crédito igual a
	 * contas pagas em duplicidade ou em excesso
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoContasPagasEmDuplicidadeEmExcessoSituacaoContaNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
					+ "from CreditoRealizadoCategoria crcg "
					+ "inner join crcg.creditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "left join crrz.localidade loca "
					+ "left join crcg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
					+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idCreditoOrigem",
							CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO)
					.uniqueResult();
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 80 Retorna o valor de
	 * categoria de crédito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação de conta igual a normal e a origem do crédito
	 * igual a devolução de tarifa de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoTarifaAguaSituacaoContaNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ) "
					+ "from CreditoRealizadoCategoria crcg "
					+ "inner join crcg.creditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "left join crrz.localidade loca "
					+ "left join crcg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id  = :idSituacao ) "
					+ "and crrz.creditoOrigem.id = :idCreditoOrigem "
					+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idCreditoOrigem",
							CreditoOrigem.DEVOLUCAO_TARIFA_AGUA).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 81 Retorna o valor de
	 * categoria de crédito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação de conta igual a normal e a origem do crédito
	 * igual a devolução de tarifa de esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoTarifaEsgotoSituacaoContaNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio) "
					+ "from CreditoRealizadoCategoria crcg "
					+ "inner join crcg.creditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "left join crrz.localidade loca "
					+ "left join crcg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
					+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idCreditoOrigem",
							CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 82 Retorna o valor de
	 * categoria de crédito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação de conta igual a normal e a origem do crédito
	 * igual a serviços indiretos pagos indevidamente
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoServicosIndiretosPagosIndevidamenteSituacaoContaNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),lict.sequenciaImpressao,lict,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ) "
					+ "from CreditoRealizadoCategoria crcg "
					+ "inner join crcg.creditoRealizado crrz "
					+ "inner join crrz.lancamentoItemContabil lict "
					+ "inner join crrz.conta cnta "
					+ "left join crrz.localidade loca "
					+ "left join crcg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ "or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
					+ "group by cnta.referencia,lict.sequenciaImpressao,lict,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacao",
					DebitoCreditoSituacao.NORMAL).setInteger("idCreditoOrigem",
					CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 83 Retorna o valor de
	 * categoria de crédito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação de conta igual a normal e a origem do crédito
	 * igual a devolução de juros de parcelamento
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoJurosParcelamentoSituacaoContaNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
					+ "from CreditoRealizadoCategoria crcg "
					+ "inner join crcg.creditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "left join crrz.localidade loca "
					+ "left join crcg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and crrz.localidade.id = :idLocalidade "
					+ "and crcg.categoria.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
					+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idCreditoOrigem",
							CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 71 Retorna o valor de
	 * imposto de renda acumulado, de acordo com o ano/mês de referência, a
	 * situação de conta igual a normal e a categoria igual a pública
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValor_IR_SituacaoContaNormalCategoriaPublica(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
					+ "from ContaImpostosDeduzidos cnid "
					+ "inner join cnid.impostoTipo imtp "
					+ "inner join cnid.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join cnta.contaCategorias ctcg "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where loca.id= :idLocalidade and "
					+ "catg.id = :idCategoria and "
					+ "cnta.referencia = :anoMesReferencia "
					+ "and imtp.id = :idTipoImposto "
					+ " and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "group by cnta.referencia,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idTipoImposto", ImpostoTipo.IR).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 72 Retorna o valor de cofins
	 * acumulado, de acordo com o ano/mês de referência, a situação de conta
	 * igual a normal e a categoria igual a pública
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValor_COFINS_SituacaoContaNormalCategoriaPublica(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(cnid.valorImposto),loca,greg,catg,uneg) "
					+ "from ContaImpostosDeduzidos cnid "
					+ "inner join cnid.impostoTipo imtp "
					+ "inner join cnid.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join cnta.contaCategorias ctcg "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where loca.id= :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and cnta.referencia = :anoMesReferencia "
					+ "and imtp.id = :idTipoImposto "
					+ " and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
					+ "group by cnta.referencia,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idTipoImposto", ImpostoTipo.COFINS)
					.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 73 Retorna o valor de csll
	 * acumulado, de acordo com o ano/mês de referência, a situação de conta
	 * igual a normal e a categoria igual a pública
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValor_CSLL_SituacaoContaNormalCategoriaPublica(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
					+ "from ContaImpostosDeduzidos cnid "
					+ "inner join cnid.impostoTipo imtp "
					+ "inner join cnid.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join cnta.contaCategorias ctcg "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where loca.id= :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and cnta.referencia = :anoMesReferencia "
					+ "and imtp.id = :idTipoImposto "
					+ " and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ "or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "group by cnta.referencia,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idTipoImposto", ImpostoTipo.CSLL).setInteger(
							"idSituacao", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 74 Retorna o valor de pis e
	 * pasep acumulado, de acordo com o ano/mês de referência, a situação de
	 * conta igual a normal e a categoria igual a pública
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValor_PIS_PASEP_SituacaoContaNormalCategoriaPublica(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
					+ "from ContaImpostosDeduzidos cnid "
					+ "inner join cnid.impostoTipo imtp "
					+ "inner join cnid.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join cnta.contaCategorias ctcg "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where loca.id= :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and cnta.referencia = :anoMesReferencia "
					+ "and imtp.id = :idTipoImposto "
					+ " and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "group by cnta.referencia,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idTipoImposto", ImpostoTipo.PIS_PASEP)
					.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
					.list();
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	

	



	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - acumula o valor de guia
	 * de pagamento para situação de conta igual a cancelada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @param tipoFinanciamento
	 *            Tipo de Financiamento
	 * @param itemContabil
	 *            Item Contábil
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorGuiaPagamentoSituacaoCancelada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer tipoFinanciamento, Integer itemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(gpcg.valorCategoria) "
					+ "from GuiaPagamentoCategoria gpcg  "
					+ "inner join gpcg.guiaPagamento gpag "
					+ "inner join gpag.lancamentoItemContabil lict "
					+ "where gpag.anoMesReferenciaContabil = :anoMesReferencia "
					+ "and gpag.localidade.id = :idLocalidade "
					+ "and gpcg.categoria.id = :idCategoria "
					+ "and gpag.financiamentoTipo.id = :idTipoFinanciamento "
					+ "and lict.id = :idItemContabil "
					+ "and gpag.debitoCreditoSituacaoAtual.id = :idSituacaoAtual ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idTipoFinanciamento",
					tipoFinanciamento).setInteger("idItemContabil",
					itemContabil).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.CANCELADA).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor de água para situação de conta igual a cancelada por retificação de
	 * acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorAguaSituacaoCanceladaPorRetificacao(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(ctcg.valorAgua) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and cnta.localidade.id = " + idLocalidade + " "
					+ "and ctcg.comp_id.categoria.id = " + idCategoria + " "
					+ "and cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor de água para situação de conta igual a retificada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorAguaSituacaoRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(ctcg.valorAgua) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and cnta.localidade.id = " + idLocalidade + " "
					+ "and ctcg.comp_id.categoria.id = " + idCategoria + " "
					+ "and (cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.RETIFICADA + " or "
					+ "cnta.debitoCreditoSituacaoAnterior = "
					+ DebitoCreditoSituacao.RETIFICADA + ")";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor débito cobrado para situação de conta igual a cancelada por
	 * retificação e parcelamento de água de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorDebitoCobradoParcelamentoAguaSituacaoCanceladaPorRetificacao(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.comp_id.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and cnta.localidade.id = " + idLocalidade + " "
					+ "and dccg.comp_id.categoria.id = " + idCategoria + " "
					+ "and dbcb.financiamentoTipo.id = "
					+ FinanciamentoTipo.PARCELAMENTO_AGUA + " "
					+ "and cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor débito cobrado para situação de conta igual a retificada e
	 * parcelamento de água de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorDebitoCobradoParcelamentoAguaSituacaoRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.comp_id.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and cnta.localidade.id = " + idLocalidade + " "
					+ "and dccg.comp_id.categoria.id = " + idCategoria + " "
					+ "and dbcb.financiamentoTipo.id = "
					+ FinanciamentoTipo.PARCELAMENTO_AGUA + " "
					+ "and (cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.RETIFICADA + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.RETIFICADA + ")";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor de esgoto para situação de conta igual a cancelada por retificação
	 * de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorEsgotoSituacaoCanceladaPorRetificacao(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(ctcg.valorEsgoto) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and cnta.localidade.id = " + idLocalidade + " "
					+ "and ctcg.comp_id.categoria.id = " + idCategoria + " "
					+ "and cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor de esgoto para situação de conta igual a retificada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorEsgotoSituacaoRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(ctcg.valorEsgoto) "
					+ "from ContaCategoria ctcg "
					+ "inner join ctcg.comp_id.conta cnta "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and cnta.localidade.id = " + idLocalidade + " "
					+ "and ctcg.comp_id.categoria.id = " + idCategoria + " "
					+ "and (cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.RETIFICADA + " or "
					+ "cnta.debitoCreditoSituacaoAnterior = "
					+ DebitoCreditoSituacao.RETIFICADA + ")";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// fim dos metódos para os sub-fluxos 01 e 02 do [UC0155]

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 08 - atualizar ano mÊs de
	 * referência do faturamento de acordo com o ano/mês de referência
	 * 
	 * @param anoMesFaturamentoAtual
	 *            Ano e mês de referência do faturamento atual
	 * @param anoMesFaturamentoNovo
	 *            Ano e mês de referência do faturamento anterior
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void atualizarAnoMesfaturamento(int anoMesFaturamentoAtual,
			int anoMesFaturamentoNovo) throws ErroRepositorioException {

		// obtém uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		String atualizarAnoMesFaturamento;

		try {
			// constroi o hql
			atualizarAnoMesFaturamento = "update SistemaParametro "
					+ "set parm_amreferenciafaturamento = "
					+ anoMesFaturamentoNovo
					+ " "
					+ "where parm_amreferenciafaturamento = :anoMesFaturamentoAtual";

			// executa o hql
			session.createQuery(atualizarAnoMesFaturamento).setInteger(
					"anoMesFaturamentoAtual", anoMesFaturamentoAtual)
					.executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês - Item 04
	 * 
	 * Atualiza a situação de imóvel com faturamento finalizado
	 * 
	 * @author Pedro Alexandre
	 * @date 07/10/2006
	 * 
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarImoveisSituacaoEspecialFaturamentoFinalizada(
			int anoMesFaturamento, Integer idSetorComercial)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoFaturamentoImovel;
		String atualizarAnoMesFaturamentoRetirada;

		try {
			// Atualiza situação do faturamento do imóvel *******
			atualizarSituacaoFaturamentoImovel = "update Imovel "
					+ "set faturamentoSituacaoTipo = null "
					+ "where setorComercial = :idSetorComercial and faturamentoSituacaoTipo is not null "
					+ "and id in "
					+ "(select distinct (ftsh.imovel.id) "
					+ "from FaturamentoSituacaoHistorico ftsh "
					+ "where ftsh.anoMesFaturamentoSituacaoFim <= :anoMesFaturamento and ftsh.anoMesFaturamentoRetirada is null"
					+ ")";

			session.createQuery(atualizarSituacaoFaturamentoImovel).setInteger(
					"idSetorComercial", idSetorComercial).setInteger(
					"anoMesFaturamento", anoMesFaturamento).executeUpdate();
			// ***************************************************

			// Atualizar o ano/mês de faturamento retirada *******
			atualizarAnoMesFaturamentoRetirada = "update FaturamentoSituacaoHistorico "
					+ "set anoMesFaturamentoRetirada = :anoMesFaturamento "
					+ "where anoMesFaturamentoSituacaoFim <= :anoMesFaturamento "
					+ "and anoMesFaturamentoRetirada is null and imovel in (select imov.id from Imovel imov where imov.setorComercial = :idSetorComercial)";
			// +"imovel.localidade.id = :idLocalidade";

			session.createQuery(atualizarAnoMesFaturamentoRetirada).setInteger(
					"idSetorComercial", idSetorComercial).setInteger(
					"anoMesFaturamento", anoMesFaturamento).executeUpdate();
			// *****************************************************

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 06 - pesquisar contas
	 * canceladas
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<Conta> pesquisarContasCanceladasPorMesAnoReferenciaContabil(
			int anoMesReferenciaContabil, Integer idLocalidade)
			throws ErroRepositorioException {
		Collection<Conta> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cnta "
					+ "from Conta cnta "
					+ "inner join cnta.localidade loca "
					+ "where loca.id=:idLocalidade and cnta.referenciaContabil <= :anoMesReferenciaContabil "
					+ "and (cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.PARCELADA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesReferenciaContabil",
					anoMesReferenciaContabil).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 05 - pesquisar debitos
	 * cobrados de contas canceladas
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoCobrado> pesquisarDebitosCobradosCanceladosPorMesAnoReferenciaContabil(
			int anoMesReferenciaContabil, Integer idConta)
			throws ErroRepositorioException {
		Collection<DebitoCobrado> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select dbcb "
					+ "from DebitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "where cnta.referenciaContabil <= :anoMesReferenciaContabil "
					+ "and cnta.id = " + idConta + " "
					+ "and (cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.PARCELADA + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.ARRASTADA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 05 - pesquisar créditos
	 * realizados de contas canceladas
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<CreditoRealizado> pesquisarCreditosRealizadosCanceladosPorMesAnoReferenciaContabil(
			int anoMesReferenciaContabil, Integer idConta)
			throws ErroRepositorioException {
		Collection<CreditoRealizado> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select crrz "
					+ "from CreditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "where cnta.referenciaContabil <= :anoMesReferenciaContabil "
					+ "and cnta.id = " + idConta + " "
					+ "and (cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.PARCELADA + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.ARRASTADA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 06 - pesquisar débitos a
	 * cobrar cancelados
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitosACobrarCanceladosPorMesAnoReferenciaContabil(
			int anoMesReferenciaContabil, Integer idSetorComercial)
			throws ErroRepositorioException {
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select dbac "
					+ "from DebitoACobrar dbac "
					+ "inner join dbac.imovel imo "
					+ "where imo.setorComercial = :idSetorComercial and dbac.anoMesReferenciaContabil <= :anoMesReferenciaContabil "
					+ "and ((dbac.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.CANCELADA
					+ " or "
					+ "dbac.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.PARCELADA
					+ ") "
					+ " or "
					+ "((dbac.numeroPrestacaoDebito - coalesce(dbac.numeroParcelaBonus,0)) = dbac.numeroPrestacaoCobradas) "

					/*
					 * Colocado por Raphael Rossiter em 30/11/2009 Analista:
					 * Aryed
					 */
					+ " and dbac.anoMesReferenciaPrestacao <= :anoMesReferenciaContabil)";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"idSetorComercial", idSetorComercial).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 07 - pesquisar créditos a
	 * realizar cancelados
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<CreditoARealizar> pesquisarCreditosARealizarCanceladosPorMesAnoReferenciaContabil(
			int anoMesReferenciaContabil, Integer idSetorComercial)
			throws ErroRepositorioException {
		Collection<CreditoARealizar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select crar "
					+ "from CreditoARealizar crar "
					+ "inner join crar.imovel imo "
					+ "where imo.setorComercial = :idSetorComercial and (crar.anoMesReferenciaContabil <= :anoMesReferenciaContabil "
					+ "and (crar.debitoCreditoSituacaoAtual =:idSituacaoCancelada "
					+ " or "
					+ "crar.debitoCreditoSituacaoAtual =:idSituacaoParcelada "
					+ ") ) "
					+ " or "
					+ "((crar.numeroPrestacaoCredito = (crar.numeroPrestacaoRealizada + coalesce(crar.numeroParcelaBonus,0))) "
					+ "and crar.valorResidualMesAnterior = 0 and (crar.valorResidualConcedidoMes = 0 or crar.valorResidualConcedidoMes is null) "

					/*
					 * Colocado por Raphael Rossiter em 30/11/2009 Analista:
					 * Aryed
					 */
					+ " and crar.anoMesReferenciaPrestacao <= :anoMesReferenciaContabil)";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"idSetorComercial", idSetorComercial).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idSituacaoCancelada",
							DebitoCreditoSituacao.CANCELADA).setInteger(
							"idSituacaoParcelada",
							DebitoCreditoSituacao.PARCELADA).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Pesquisa uma coleção de resumos
	 * defaturamento por ano e mês de referência
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ResumoFaturamento> pesquisarResumoFaturamentoPorAnoMes(
			int anoMesFaturameto, Integer idLocalidade)
			throws ErroRepositorioException {
		Collection<ResumoFaturamento> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select reft from ResumoFaturamento reft "
					+ "inner join reft.localidade loca "
					+ "where  loca.id =:idLocalidade and reft.anoMesReferencia = :anoMesFaturameto ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesFaturameto",
					anoMesFaturameto).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void retificarContaAtualizarSituacao(Conta conta,
			Integer situacaoAnterior) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "dcst_idanterior = " + situacaoAnterior
					+ ", dcst_idatual = :situacaoAtual, "
					+ "cnta_amreferenciacontabil = :referenciaContabil, "
					+ "usur_id = " + conta.getUsuario().getId()
					+ " , cnta_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE cnta_id = :idConta ";

			session.createQuery(update).setInteger("situacaoAtual",
					conta.getDebitoCreditoSituacaoAtual().getId()).setInteger(
					"referenciaContabil", conta.getReferenciaContabil())
					.setTimestamp("dataUltimaAlteracao",
							conta.getUltimaAlteracao()).setInteger("idConta",
							conta.getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void retificarContaAtualizarValores(Conta conta)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "last_id = :situacaoAgua, lest_id = :situacaoEsgoto, "
					+ "cnta_dtvencimentoconta = :dataVencimento, cnta_nnconsumoagua = :consumoAgua, "
					+ "cnta_nnconsumoesgoto = :consumoEsgoto, cnta_vlagua = :valorAgua, "
					+ "cnta_vlesgoto = :valorEsgoto, cnta_vldebitos = :valorDebitos, "
					+ "cnta_vlcreditos = :valorCreditos, cnta_pcesgoto = :percentualEsgoto, "
					+ "cnta_dtvalidadeconta = :dataValidade, cnta_amreferenciacontabil = :referenciaContabil, "
					+ "cnta_dtretificacao = :dataRetificacao, cmrt_id = :motivoRetificacao, "
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao, "
					+ "cnta_vlimpostos = :valorImpostos, usur_id = :usuarioLogado, "
					+ "cnta_nnretificacao = :numeroRetificacoes, "
					+ "cnta_nnleituraatual = " + conta.getNumeroLeituraAtual()  
					+ " ,cnta_nnleituraanterior = " + conta.getNumeroLeituraAnterior()
					+ " ,cnta_nnboleto = " + conta.getNumeroBoleto()
					+ " WHERE cnta_id = :idConta ";

			session.createQuery(update).setInteger("situacaoAgua",
					conta.getLigacaoAguaSituacao().getId()).setInteger(
					"situacaoEsgoto", conta.getLigacaoEsgotoSituacao().getId())
					.setDate("dataVencimento", conta.getDataVencimentoConta())
					.setInteger("consumoAgua", conta.getConsumoAgua())
					.setInteger("consumoEsgoto", conta.getConsumoEsgoto())
					.setBigDecimal("valorAgua", conta.getValorAgua())
					.setBigDecimal("valorEsgoto", conta.getValorEsgoto())
					.setBigDecimal("valorDebitos", conta.getDebitos())
					.setBigDecimal("valorCreditos", conta.getValorCreditos())
					.setBigDecimal("percentualEsgoto", conta.getPercentualEsgoto())
					.setDate("dataValidade", conta.getDataValidadeConta())
					.setInteger("referenciaContabil", conta.getReferenciaContabil())
					.setDate("dataRetificacao", conta.getDataRetificacao())
					.setInteger("motivoRetificacao",conta.getContaMotivoRetificacao().getId())
					.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao())
					.setInteger("idConta", conta.getId())
					.setBigDecimal("valorImpostos",	conta.getValorImposto())
					.setInteger("usuarioLogado", conta.getUsuario().getId())
					.setInteger("numeroRetificacoes",conta.getNumeroRetificacoes())
//					.setInteger("numeroLeituraAnterior",conta.getNumeroLeituraAnterior())
//					.setInteger("numeroLeituraAtual" ,conta.getNumeroLeituraAtual())
					.executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void removerContaCategoria(Conta conta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<ContaCategoria> categorias = new ArrayList();

		try {
			categorias = session
					.createQuery(
							"FROM gcom.faturamento.conta.ContaCategoria as ctcg WHERE ctcg.comp_id.conta.id = :idConta")
					.setInteger("idConta", conta.getId()).list();

			Iterator iterator = categorias.iterator();

			while (iterator.hasNext()) {

				ContaCategoria contaCateg = (ContaCategoria) iterator.next();

				session.delete(contaCateg);
				// iterator.remove();

			}

			session.flush();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void removerDebitoCobrado(Conta conta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection debitosBase = null;
		try {
			debitosBase = session
					.createQuery(
							"FROM gcom.faturamento.debito.DebitoCobrado as dbcb WHERE dbcb.conta.id = :idConta")
					.setInteger("idConta", conta.getId()).list();
			Iterator iterator = debitosBase.iterator();

			while (iterator.hasNext()) {
				DebitoCobrado debito = (DebitoCobrado) iterator.next();

				session.delete(debito);
				iterator.remove();
			}

			session.flush();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void removerCreditoRealizado(Conta conta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			Iterator iterator = session
					.createQuery(
							"FROM gcom.faturamento.credito.CreditoRealizado as crrz WHERE crrz.conta.id = :idConta")
					.setInteger("idConta", conta.getId()).iterate();

			while (iterator.hasNext()) {
				CreditoRealizado credito = (CreditoRealizado) iterator.next();

				session.delete(credito);
				iterator.remove();

			}

			session.flush();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Rafael Santos
	 * Data:03/02/2006
	 * 
	 * @param imovelID
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	/*
	 * public Collection<DebitoACobrar>
	 * pesquisarDebitosACobrarCanceladosPorMesAnoReferenciaContabil( int
	 * anoMesReferenciaContabil) throws ErroRepositorioException { Collection<DebitoACobrar>
	 * retorno = null; // cria uma sessão com o hibernate Session session =
	 * HibernateUtil.getSession(); // cria a variável que vai conter o hql
	 * String consulta;
	 * 
	 * try { // constroi o hql consulta = "select dbac " + "from DebitoACobrar
	 * dbac " + "where (dbac.anoMesReferenciaContabil <=
	 * :anoMesReferenciaContabil " + "and (dbac.debitoCreditoSituacaoAtual = " +
	 * DebitoCreditoSituacao.CANCELADA + " or " +
	 * "dbac.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + ") ) " + "
	 * or " + "(dbac.numeroPrestacaoDebito = dbac.numeroPrestacaoCobradas) "; //
	 * executa o hql retorno = session.createQuery(consulta).setInteger(
	 * "anoMesReferenciaContabil", anoMesReferenciaContabil) .list(); } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão HibernateUtil.closeSession(session); }
	 * 
	 * return retorno; }
	 */

	/**
	 * [UC0113] - Gerar Faturamento Grupo Author: Rafael Santos Data: 16/02/2006
	 * 
	 * retorna o objeto debito automatico movimento
	 * 
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public Object obterDebitoAutomatico(Integer idImovel) throws
	 * ErroRepositorioException {
	 * 
	 * Object retorno = null;
	 * 
	 * Session session = HibernateUtil.getSession(); String consulta;
	 * 
	 * try { consulta = "SELECT da " + "FROM DebitoAutomatico da " + "INNER JOIN
	 * cnta.imovel imov " + "WHERE imov.id = :idImovel AND " + "da.dataExclusao
	 * is null ";
	 * 
	 * retorno = session.createQuery(consulta).setInteger("idImovel",
	 * idImovel.intValue()).setMaxResults(1).uniqueResult(); } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão HibernateUtil.closeSession(session); }
	 * 
	 * return retorno; }
	 */

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * Retorna o código do débito automático.
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 16/02/2006,18/09/2006
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer obterDebitoAutomatico(Integer idImovel)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select da.id " + "from DebitoAutomatico da "
					+ "inner join da.imovel imov "
					+ "where imov.id = :idImovel and "
					+ "da.dataExclusao is null ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idImovel", idImovel.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados do imóvel que será faturado
	 * 
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * @author Rafael Santos, Raphael Rossiter, Raphael Rossiter
	 * @date 16/02/2006, 27/03/2009, 16/08/2011
	 * 
	 * @param idRota
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @param preFaturar
	 * @param resumo
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImovelFaturarGrupo(Integer idRota,
			int numeroPaginas, int quantidadeRegistros, boolean preFaturar, boolean resumo)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.ligacaoAguaSituacao.id," // 0
					+ "imovel.ligacaoEsgotoSituacao.id," // 1
					+ "consumoTarifa.id, " // 2
					+ "localidade.id," // 3
					+ "quadra.id," // 4
					+ "quadra.numeroQuadra," // 5
					+ "imovel.lote," // 6
					+ "setorComercial.codigo," // 7
					+ "faturamentoTipo.id, " // 8
					+ "imovel.imovelPerfil.id," // 9
					+ "imovel.indicadorDebitoConta," // 10
					+ "imovelContaEnvio.id," // 11
					+ "imovel.subLote, " // 12
					+ "imovel.indicadorEmissaoExtratoFaturamento, " // 13
					+ "localidade.gerenciaRegional.id," // 14
					+ "setorComercial.id," // 15
					+ "quadra.rota.id," // 16
					+ "esferaPoder.id, " // 17
					+ "imovel.id, " // 18
					+ "imovel.diaVencimento, " // 19
					+ "imovel.ligacaoAguaSituacao.indicadorFaturamentoSituacao, " // 20
					+ "imovel.ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, " // 21
					+ "imovel.ligacaoAguaSituacao.consumoMinimoFaturamento, " // 22
					+ "imovel.ligacaoEsgotoSituacao.volumeMinimoFaturamento, " // 23
					+ "faturamentoSituacaoTipo.id, " // 24
					+ "imovel.indicadorVencimentoMesSeguinte, " // 25
					+ "faturamentoSituacaoTipo.indicadorParalisacaoFaturamento, "// 26
					+ "faturamentoSituacaoTipo.indicadorValidoAgua, "// 27
					+ "unidadeNegocio.id, "// 28
					+ "hihAgua.id, "//29
					+ "hihPoco.id, "//30
					/** 
					 * 
					 * Adicionando parametro para verificar se o imóvel
					 * faz parte de um condomínio
					 */
					+ "imovel.imovelCondominio.id, " //31 
					+ "imovel.quantidadeEconomias, " // 32
					+ "imovel.indicadorImovelCondominio " //33
//					+ "imovel.imovelCondominio.ligacaoEsgotoSituacao.id, " //34
//					+ "imovel.imovelCondominio.ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, " //35
//					+ "imovel.imovelCondominio.ligacaoAguaSituacao.id, " //36
//					+ "imovel.imovelCondominio.ligacaoAguaSituacao.indicadorFaturamentoSituacao " //37
					+ "from Imovel imovel "
					+ "inner join imovel.consumoTarifa consumoTarifa "
					+ "inner join imovel.localidade localidade "
					+ "inner join localidade.unidadeNegocio unidadeNegocio "
					+ "inner join imovel.setorComercial setorComercial "
					+ "inner join imovel.quadra quadra "
					+ "inner join quadra.rota rota "
					+ "left join imovel.faturamentoTipo faturamentoTipo "
					+ "left join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ "left join imovel.imovelContaEnvio imovelContaEnvio "
					+ "left join imovel.clienteImoveis clienteImoveisReposanvel with (clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ ") and clienteImoveisReposanvel.dataFimRelacao is null "
					+ " left join clienteImoveisReposanvel.cliente clienteResposanvel "
					+ " left join clienteResposanvel.clienteTipo clienteTipo "
					+ " left join clienteTipo.esferaPoder esferaPoder "
					+ "left join imovel.imovelPerfil imovelPerfil "
					+ " left join imovel.ligacaoAgua la "
					+ " left join la.hidrometroInstalacaoHistorico hihAgua "
					+ " left join imovel.hidrometroInstalacaoHistorico hihPoco "
					
					+ " WHERE rota.id = :rotaId and imovel.rotaAlternativa IS NULL ";
			
				/*
				 * RM 1272 - A pedido de Eduardo Borges
				 * 
				 * Alterar para considerar as contas de imóveis excluídos ou condomínio que foram faturados antes de serem 
				 * colocados como excluídos/condomínio.
				 */
				if(!resumo){
					
					consulta += "AND imovel.indicadorImovelCondominio <> 1 ";
					
					//Não faturar imóveis com indicador de excluído - CRC1577
					consulta += "AND imovel.indicadorExclusao <> 1 ";
				}
				
				//Alterado por Sávio Luiz
				//Data: 23/02/2010
				//Qaundo for pré-faturamento não trazer os imóveis tele medidos
				if(preFaturar){
					consulta += "AND imovelPerfil.indicadorGerarDadosLeitura = 1 ";
				}

			retorno = session.createQuery(consulta).setInteger("rotaId",
					idRota.intValue()).setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Gerar Faturamento Grupo Author: Rafael Santos Data: 16/02/2006
	 * 
	 * Dados do Cliente Imovel
	 * 
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Cliente pesquisarClienteImovelGrupoFaturamento(Integer idImovel,
			Short relacaoTipo) throws ErroRepositorioException {

		Cliente retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select new Cliente(cliente.id, cliente.nome, cliente.dataVencimento, cliente.indicadorVencimentoMesSeguinte) "
					+ "from ClienteImovel clienteImovel  "
					+ "inner join clienteImovel.imovel imovel "
					+ "inner join clienteImovel.clienteRelacaoTipo clienteRelacaoTipo "
					+ "inner join clienteImovel.cliente cliente "
					+ "where imovel.id = :idImovel and "
					+ "clienteRelacaoTipo.id = :relacaoTipo and "
					+ "clienteImovel.dataFimRelacao is null";

			Object pesquisa = session.createQuery(consulta).setInteger(
					"idImovel", idImovel.intValue()).setShort("relacaoTipo",
					relacaoTipo.shortValue()).setMaxResults(1).uniqueResult();

			if (pesquisa != null) {
				retorno = (Cliente) pesquisa;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores Author: Sávio Luiz Data:
	 * 01/02/2006
	 * 
	 * retorna o objeto debito automatico movimento
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public DebitoAutomaticoMovimento obterDebitoAutomaticoMovimento(
			Integer idImovel, Integer anoMesReferencia)
			throws ErroRepositorioException {

		DebitoAutomaticoMovimento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT dam "
					+ "FROM DebitoAutomaticoMovimento dam "
					+ "INNER JOIN dam.contaGeral cntaGeral "
					+ "INNER JOIN cntaGeral.conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE imov.id = :idImovel AND "
					+ "cnta.referencia = :anoMesReferencia AND "
					+ "cnta.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (DebitoAutomaticoMovimento) session.createQuery(consulta)
					.setInteger("idImovel", idImovel.intValue()).setInteger(
							"normal", DebitoCreditoSituacao.NORMAL).setInteger(
							"incluida", DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores Author: Sávio Luiz Data:
	 * 01/02/2006
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaContaComSituacaoAtual(Imovel imovel,
			int anoMesReferencia) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct.id from Conta ct "
					+ "inner join ct.imovel "
					+ "inner join ct.debitoCreditoSituacaoAtual "
					+ "where ct.referencia = :referencia "
					+ "and ct.imovel.id = :imovel and "
					+ "ct.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"imovel", imovel.getId().intValue()).setInteger(
					"referencia", anoMesReferencia).setInteger("normal",
					DebitoCreditoSituacao.NORMAL).setInteger("incluida",
					DebitoCreditoSituacao.INCLUIDA).setInteger("retificada",
					DebitoCreditoSituacao.RETIFICADA).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras [SF0003] - Processar
	 * Pagamento de Documento de Cobrança Author: Sávio Luiz Data: 01/02/2006
	 * 
	 * retorna o objeto debito automatico movimento
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoAtualDebitoACobrar(Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "update gcom.faturamento.debito.DebitoACobrar "
					+ "set dcst_idatual = :idSituacaoAtual where dbac_id = :idDebitoACobrar";

			session.createQuery(consulta).setInteger("idDebitoACobrar",
					idDebitoACobrar.intValue()).setInteger("idSituacaoAtual",
					DebitoCreditoSituacao.PAGA).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @created 16/02/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarFaturaItem(Integer idCliente,
			Integer anoMesReferencia, Integer numeroSequencial,
			BigDecimal valordebito) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT fi.valorConta, conta.id, localidade.id, "
					+ "imovel.id, localidadeHistorico.id, imovelHistorico.id, fatura.id "
					+ "FROM FaturaItem fi "
					+ "LEFT JOIN fi.fatura fatura "
					+ "LEFT JOIN fi.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN conta.imovel imovel "
					+ "LEFT JOIN conta.localidade localidade "
					+ "LEFT JOIN contaHistorico.imovel imovelHistorico "
					+ "LEFT JOIN contaHistorico.localidade localidadeHistorico "
					+ "LEFT JOIN fatura.cliente cliente "
					+ "WHERE cliente.id = :idCliente AND "
					+ "fatura.anoMesReferencia = :anoMesReferencia AND "
					+ "fatura.sequencial = :numeroSequencial AND "
					+ "fi.indicadorUsoAtivo = :indicadorUsoAtivo";
					
			retorno = session.createQuery(consulta).setInteger("idCliente",
					idCliente.intValue()).setInteger("anoMesReferencia",
					anoMesReferencia.intValue()).setInteger("numeroSequencial",
					numeroSequencial.intValue()).setInteger("indicadorUsoAtivo",
					ConstantesSistema.SIM.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0971] Inserir Pagamentos para Faturas Especiais
	 * 
	 * @author Rafael Pinto
	 * @created 08/01/2010
	 * 
	 * @param idCliente
	 *            Id do Cliente
	 * @param anoMesReferencia
	 *            Ano Mes de Referencia
	 * @param numeroSequencial
	 *            Numero Sequencial
	 * @param valordebito
	 *            Valor do Debito
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarFaturaItem(Integer idCliente,
			Integer anoMesReferencia, Integer numeroSequencial,
			BigDecimal valordebito, int numeroPaginas, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT fi.valorConta, conta.id, localidade.id, "
					+ "imovel.id, localidadeHistorico.id, imovelHistorico.id, fatura.id "
					+ "FROM FaturaItem fi "
					+ "LEFT JOIN fi.fatura fatura "
					+ "LEFT JOIN fi.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN conta.imovel imovel "
					+ "LEFT JOIN conta.localidade localidade "
					+ "LEFT JOIN contaHistorico.imovel imovelHistorico "
					+ "LEFT JOIN contaHistorico.localidade localidadeHistorico "
					+ "LEFT JOIN fatura.cliente cliente "
					+ "WHERE cliente.id = :idCliente AND "
					+ "fatura.anoMesReferencia = :anoMesReferencia AND "
					+ "fatura.sequencial = :numeroSequencial AND "
					+ "fatura.debito = :valordebito AND"
					+ "fi.indicadorUsoAtivo = :indicadorUsoAtivo";

			retorno = session.createQuery(consulta).setInteger("idCliente",
					idCliente.intValue()).setInteger("anoMesReferencia",
					anoMesReferencia.intValue()).setInteger("numeroSequencial",
					numeroSequencial.intValue()).setBigDecimal("valordebito",
					valordebito).setInteger("indicadorUsoAtivo",
					ConstantesSistema.SIM.intValue())
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualiza o ano mes de faturamento de faturamento situação historico
	 * 
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Sávio Luiz, Raphael Rossiter
	 * @date 17/03/2006, 11/08/2008
	 * 
	 * @param situacaoEspecialFaturamentoHelper
	 * @throws ErroRepositorioException
	 */
	public void atualizarAnoMesFaturamentoSituacaoHistorico(
			SituacaoEspecialFaturamentoHelper situacaoEspecialFaturamentoHelper,
			Collection<Integer> colecaoIdsImoveisRetirar,
			Integer idFaturamentoSituacaoComando)
			throws ErroRepositorioException {

		String consulta = "";

		Session session = HibernateUtil.getSession();
		try {

			consulta = "update gcom.faturamento.FaturamentoSituacaoHistorico set "
					+ "ftsc_idretirada = :idFaturamentoSituacaoComando, "
					+ "ftsh_amfaturamentoretirada = :anoMesReferenciaFaturamentoGrupo,"
					+ "ftsh_tmultimaalteracao = :ultimaAlteracao, "
					+ "usur_id = null "
					+ "where imov_id in ( :imoveis )"
					+ " and ftsh_amfaturamentoretirada is null";

			session.createQuery(consulta).setParameterList("imoveis",
					colecaoIdsImoveisRetirar).setInteger(
					"idFaturamentoSituacaoComando",
					idFaturamentoSituacaoComando).setInteger(
					"anoMesReferenciaFaturamentoGrupo",
					situacaoEspecialFaturamentoHelper
							.getAnoMesReferenciaFaturamentoGrupo())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * O sistema seleciona as atividades que foram previamente comandadas e
	 * ainda não realizadas (a partir da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA
	 * com FTCM_ID = FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL e
	 * FTAC_TMCOMANDO preenchido e FTAC_TMREALIZACAO não preenchido ou com um
	 * valor anterior à FTAC_TMCOMANDO)
	 * 
	 * @author Roberta Costa
	 * @date 29/03/2006
	 * 
	 * @param FaturamentoGrupoCronogramaMensal
	 * @return Collection<FaturamentoAtividadeCronograma>
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoAtividadeCronograma> pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizada(
			Integer numeroPagina) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		// Collection retorno = new ArrayList();
		Collection colecaoAtividadeCronograma = new ArrayList();
		String consulta = null;

		try {

			/*
			 * consulta = " SELECT ftac FROM FaturamentoAtividadeCronograma as
			 * ftac " + " INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm " + "
			 * INNER JOIN ftac.faturamentoAtividade ftat " + " WHERE ftcm.id IN" + " ( " + "
			 * select fgcm.id " + " from FaturamentoGrupoCronogramaMensal fgcm " + " )" + "
			 * AND ftac.comando IS NOT NULL AND (ftac.dataRealizacao IS NULL " + "
			 * OR ftac.dataRealizacao < ftac.comando)";
			 */
			consulta = " SELECT ftac FROM FaturamentoAtividadeCronograma ftac "
					+ " INNER JOIN FETCH ftac.faturamentoGrupoCronogramaMensal ftcm "
					+ " INNER JOIN FETCH ftcm.faturamentoGrupo ftgr "
					+ " INNER JOIN FETCH ftac.faturamentoAtividade ftat "
					+ " WHERE ftcm.id IN"
					+ " ( "
					+ " select fgcm.id "
					+ " from FaturamentoGrupoCronogramaMensal fgcm "
					+ " )"
					+ " AND ftac.comando IS NOT NULL AND (ftac.dataRealizacao IS NULL  "
					+ " OR ftac.dataRealizacao < ftac.comando)";

			// Iterator<FaturamentoAtividadeCronograma> iterator = null;

			// Para paginação deve-se pegar o resultado da consulta
			// multiplicando o número de páginas por 10
			// com um máximo de 10 registros por vez
			colecaoAtividadeCronograma = new ArrayList(new CopyOnWriteArraySet(
					session.createQuery(consulta).setFirstResult(
							10 * numeroPagina).setMaxResults(10).list()));

			/**
			 * alterado por pedro alexandre dia 23/01/2007
			 */
			/*
			 * iterator = colecaoAtividadeCronograma.iterator(); while
			 * (iterator.hasNext()) {
			 * 
			 * FaturamentoAtividadeCronograma faturamentoAtividadeCronograma =
			 * iterator .next(); // carrega todos os objetos
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoAtividade());
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal());
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal().getFaturamentoGrupo());
			 * 
			 * retorno.add(faturamentoAtividadeCronograma); }
			 */
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// return retorno;
		return colecaoAtividadeCronograma;
	}

	/**
	 * Retorna o count do resultado da pesquisa de Faturamento Atividade
	 * Cronograma
	 * 
	 * pesquisarFaturamentoAtividadeCronogramaCount
	 * 
	 * @author Roberta Costa
	 * @date 05/05/2006
	 * 
	 * @param FaturamentoGrupoCronogramaMensal
	 *            faturamentoGrupoCronogramaMensal
	 * @param Integer
	 *            numeroPagina
	 * @return Integer retorno
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizadaCount()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT count(ftac.id) FROM FaturamentoAtividadeCronograma ftac "
					+ "INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm "
					+ "INNER JOIN ftac.faturamentoAtividade ftat "
					+ "WHERE ftcm.id IN ( "
					+ "select fgcm.id "
					+ "from FaturamentoGrupoCronogramaMensal fgcm "
					+ " ) AND "
					+ "ftac.comando IS NOT NULL AND (ftac.dataRealizacao IS NULL OR "
					+ "ftac.dataRealizacao < ftac.comando)";

			retorno = (Integer) session.createQuery(consulta).uniqueResult();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Método que retorna todos os imóveis que tenham cliente responsável e
	 * indicacao de conta a ser entregue em outro endereço e que estejam nas
	 * quadras pertencentes às rotas passadas
	 * 
	 * UC0209 Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Thiago Toscano, Raphael Rossiter
	 * @date 04/04/2006, 26/08/2009
	 * 
	 * @param rotas
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterImoveisPorRotasComContaEntregaEmOutroEndereco(
			Integer idRota) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select i.localidade.id, i.setorComercial.codigo, q.numeroQuadra, "
					+ "q.id , i.id ,i.lote, i.subLote, ip.id, last.id, last.indicadorFaturamentoSituacao, "
					+ "last.consumoMinimoFaturamento, lest.id, lest.indicadorFaturamentoSituacao, "
					+ "lest.volumeMinimoFaturamento "
					+ "from ClienteImovel ci "
					+ "inner join ci.imovel i "
					+ "inner join i.ligacaoAguaSituacao last "
					+ "inner join i.ligacaoEsgotoSituacao lest "
					+ "inner join ci.cliente clie "
					+ "inner join clie.clienteTipo cltp "
					+ "inner join cltp.esferaPoder epod "
					+ "inner join ci.clienteRelacaoTipo crt "
					+ "inner join i.quadra q "
					+ "inner join q.rota r "
					+ "inner join i.setorComercial sc "
					+ "inner join i.imovelPerfil ip "
					+ "WHERE q.rota.id = :idRota AND i.rotaAlternativa IS NULL "
					+ "AND i.indicadorImovelCondominio <> 1 "
					+ "AND i.imovelContaEnvio.id <> 4 "
					+ "AND i.indicadorExclusao <> 1 "

					+ "AND ci.dataFimRelacao IS NULL AND epod.id = :idEsferaPoder "
					+ "AND crt.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL
					+ " AND (i.imovelContaEnvio.id = "
					+ ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL
					+ " OR i.imovelContaEnvio = "
					+ ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL
					+ " )";

			retorno = session.createQuery(consulta).setInteger("idEsferaPoder",
					EsferaPoder.PARTICULAR).setInteger("idRota", idRota).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Metodo que retorno o debito Tipo do id passado
	 * 
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author thiago
	 * @date 05/04/2006
	 * 
	 * @param id
	 * @return
	 * @throws ErroRepositorioException
	 */
	public DebitoTipo getDebitoTipo(Integer id) throws ErroRepositorioException {
		DebitoTipo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select debitoTipo " + "from DebitoTipo debitoTipo "
					+ "left join fetch debitoTipo.financiamentoTipo "
					+ "left join fetch debitoTipo.lancamentoItemContabil "
					+ "where debitoTipo.id = :idDebitoTipo ";

			Object pesquisa = session.createQuery(consulta).setInteger(
					"idDebitoTipo", id.intValue()).setMaxResults(1)
					.uniqueResult();

			if (pesquisa != null) {
				retorno = (DebitoTipo) pesquisa;
				/**
				 * alterado por pedro alexandre dia 23/01/2007
				 */
				// Hibernate.initialize(retorno.getFinanciamentoTipo());
				// /Hibernate.initialize(retorno.getLancamentoItemContabil());
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metodo que retorno o debito Tipo do id passado
	 * 
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * Alteração feita por Tiago Moreno para retornar o valorSugerido do
	 * DebitoTipo
	 * 
	 * @author thiago toscano, Tiago Moreno
	 * @date 05/04/2006, 22/12/2009
	 * 
	 * @param id
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] getDebitoTipoHql(Integer id)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Object[] retorno = null;

		try {
			consulta = "select dt.id, dt.financiamentoTipo.id, dt.lancamentoItemContabil.id, dt.valorSugerido "
					+ "from DebitoTipo dt  " + "where dt.id = :idDebitoTipo ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idDebitoTipo", id.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metodo que retorna o id debito a cobrar, o id do imóvel, o id do debito
	 * tipo e o ano/mês de referência do débito
	 * 
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Rafael Corrêa e Leonardo Vieira
	 * @date 24/08/2006
	 * 
	 * @param idImovel,
	 *            idDebitoTipo, anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoACobrar(Integer idImovel,
			Integer idDebitoTipo, Integer anoMesReferenciaDebito)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Object[] retorno = null;

		try {
			consulta = "select dc.id, dc.imovel.id, dc.debitoTipo.id, dc.anoMesReferenciaDebito "
					+ "from DebitoACobrar dc "
					+ "where dc.imovel.id = :idImovel and "
					+ "dc.debitoTipo.id = :idDebitoTipo and "
					+ "dc.anoMesReferenciaDebito = :anoMesReferenciaDebito";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setInteger("idDebitoTipo",
					idDebitoTipo.intValue()).setInteger(
					"anoMesReferenciaDebito", anoMesReferenciaDebito)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metodo que deleta os débitos a cobrar categoria de um respectivo débito a
	 * cobrar
	 * 
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Rafael Corrêa e Leonardo Vieira
	 * @date 24/08/2006
	 * 
	 * @param idDebitoACobrar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDebitoACobrarCategoria (Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String delete = "delete DebitoACobrarCategoria dcc "
					+ "where dcc.debitoACobrar.id = :idDebitoACobrar ";

			session.createQuery(delete).setInteger("idDebitoACobrar",
					idDebitoACobrar).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Metodo que insere ou atualiza os débitos a cobrar
	 * 
	 * [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Rafael Corrêa, Leonardo Vieira, Pedro Alexandre
	 * @date 24/08/2006
	 * 
	 * @param colecaoDebitosACobrar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoACobrar> insereOuAtualizaDebitoACobrar(
			Collection colecaoDebitosACobrar) throws ErroRepositorioException {
		Collection<DebitoACobrar> retorno = new ArrayList();
		StatelessSession session = HibernateUtil.getStatelessSession();

		Iterator colecaoDebitosACobrarIterator = colecaoDebitosACobrar
				.iterator();

		try {
			// int i = 1;
			while (colecaoDebitosACobrarIterator.hasNext()) {

				DebitoACobrar debitoACobrar = (DebitoACobrar) colecaoDebitosACobrarIterator
						.next();

				if (debitoACobrar.getId() == null) {
					Integer idGerado = (Integer) session.insert(debitoACobrar);
					debitoACobrar.setId(idGerado);
				} else {
					session.update(debitoACobrar);
				}

				retorno.add(debitoACobrar);

				/*
				 * if (i % 50 == 0) { // 20, same as the JDBC batch size //
				 * flush a batch of inserts and release memory: session.flush();
				 * session.clear(); } i++;
				 */
			}
			// session.flush();
			// session.clear();

			return retorno;

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0209] Gerar Taxa de Entrega de Conta em Outro Endereço
	 * 
	 * @author Pedro Alexandre
	 * @date 29/08/2006
	 * 
	 * @param colecaoDebitosACobrarCategoria
	 * @throws ErroRepositorioException
	 */
	public void inserirDebitoACobrarCategoria(
			Collection colecaoDebitosACobrarCategoria)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		try {
			// int i = 1;
			Iterator colecaoDebitosACobrarCategoriaIterator = colecaoDebitosACobrarCategoria
					.iterator();

			while (colecaoDebitosACobrarCategoriaIterator.hasNext()) {

				DebitoACobrarCategoria debitoACobrarCategoria = (DebitoACobrarCategoria) colecaoDebitosACobrarCategoriaIterator
						.next();
				session.insert(debitoACobrarCategoria);

				/*
				 * if (i % 50 == 0) { session.flush(); session.clear(); } i++;
				 */
			}

			// session.flush();
			// session.clear();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * Metodo que retorno o valor da tarifa normal a ser cobrando no caso de uso
	 * [UC029]
	 * 
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author thiago
	 * @date 05/04/2006
	 * 
	 * @param anoMes
	 * @return
	 */
	// public BigDecimal obterValorTarifaSocial(Integer anoMes)
	// throws ErroRepositorioException {
	// BigDecimal retorno = null;
	//
	// Session session = HibernateUtil.getSession();
	// String consulta;
	//
	// try {
	// consulta = "select "
	// + " ctc.valorTarifaMinima "
	// + "from "
	// + " gcom.faturamento.consumotarifa.ConsumoTarifaCategoria ctc "
	// + " inner join ctc.categoria cat"
	// + " inner join ctc.consumoTarifaVigencia ctv"
	// + " "
	// + " "
	// + "where "
	// + " cat.id = "
	// + Categoria.RESIDENCIAL
	// + " and ctv.dataVigencia in "
	// + " ( select max(ctv.dataVigencia)"
	// + " from "
	// + " gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv"
	// + " inner join ctv.consumoTarifa ct"
	// + " where " + " ct.id = "
	// + ConsumoTarifa.CONSUMO_SOCIAL
	// + " and ctv.dataVigencia <= :dataVigencia " + ") "
	// + " ";
	//
	// Object pesquisa = session.createQuery(consulta).setDate(
	// "dataVigencia", new Date(System.currentTimeMillis()))
	// .setMaxResults(1).uniqueResult();
	//
	// if (pesquisa != null) {
	// retorno = (BigDecimal) pesquisa;
	// }
	//
	// } catch (HibernateException e) {
	// // levanta a exceção para a próxima camada
	// throw new ErroRepositorioException(e, "Erro no Hibernate");
	// } finally {
	// // fecha a sessão
	// HibernateUtil.closeSession(session);
	// }
	//
	// return retorno;
	// }
	/**
	 * 
	 * Metodo que retorno o valor da tarifa a ser cobrada
	 * 
	 * [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author thiago, pedro alexandre
	 * @date 05/04/2006, 30/08/2006
	 * 
	 * @return valor da tarifa
	 */
	public BigDecimal obterValorTarifa(Integer consumoTarifaId)
			throws ErroRepositorioException {
		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "		ctc.valorTarifaMinima "
					+ "from "
					+ "		gcom.faturamento.consumotarifa.ConsumoTarifaCategoria ctc  "
					+ "		inner join ctc.categoria cat"
					+ "		inner join ctc.consumoTarifaVigencia ctv"
					+ "     inner join ctv.consumoTarifa ct"
					+ "		"
					+ " "
					+ "where "
					+ " 	cat.id = "
					+ Categoria.RESIDENCIAL
					+ " 	and "
					+ "ct.id = "
					+ consumoTarifaId
					+ " and ctv.dataVigencia in "
					+ "						( 	select max(ctv.dataVigencia)"
					+ "							from gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "							where 	ctv.dataVigencia <= :dataVigencia "
					+ " and ctv.consumoTarifa.id=" + consumoTarifaId + ") "
					+ " ";

			Object pesquisa = session.createQuery(consulta).setDate(
					"dataVigencia", new Date(System.currentTimeMillis()))
					.setMaxResults(1).uniqueResult();

			if (pesquisa != null) {
				retorno = (BigDecimal) pesquisa;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Metodo que retorna os imóveis das quadras pertencentes às rotas
	 * 
	 * Utilizado pelo [UC0302] Gerar Débitos a Cobrar de Acréscimos por
	 * Impontualidade
	 * 
	 * @author Fernanda Paiva, Raphael Rossiter
	 * @date 20/04/2006, 26/08/2009
	 * 
	 * @param idRota
	 * @return Collection
	 */
	public Collection pesquisarImoveisDasQuadrasPorRota(Integer idRota)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select imovel.id,"
					+ // 0
					"localidade.id,"
					+ // 1
					"setorComercial.codigo,"
					+ // 2
					"quadra.numeroQuadra,"
					+ // 3
					"imovel.lote,"
					+ // 4
					"imovel.subLote,"
					+ // 5
					"rota.id, "
					+ // 6
					"quadra.id, "
					+ // 7
					"imovel.indicadorDebitoConta " // 8

					+ "from Imovel imovel "
					+ "left join imovel.localidade localidade "
					+ "left join imovel.setorComercial setorComercial "
					+ "left join imovel.quadra quadra "
					+ "left join quadra.rota rota "

					+ "WHERE rota.id = :idRota AND imovel.rotaAlternativa IS NULL "
					+ "AND imovel.indicadorImovelCondominio <> 1 "
					+ "AND imovel.indicadorExclusao <> 1 ";

			retorno = session.createQuery(consulta)
					.setInteger("idRota", idRota).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém as contas de um imóvel com ano/mes da data de vencimento menor ou
	 * igual ao ano/mes de referencia da arrecadacao corrente e com situacao
	 * atual correspondente a normal, retificada ou incluida.
	 * 
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Fernanda Paiva, Pedro Alexandre
	 * @date 24/04/2006,15/03/2007
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImovel(Integer imovel, Integer situacaoNormal,
			Integer situacaoIncluida, Integer situacaoRetificada,
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, "
					+ "cnta.valorEsgoto, cnta.debitos, cnta.valorCreditos, cnta.indicadorCobrancaMulta "
					+ "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE imov.id = :idImovel AND "
					+ "cnta.dataVencimentoConta <= :anoMesReferenciaArrecadacao AND "
					+ "cnta.dataRevisao is null AND "
					+ "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada)";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovel).setInteger("normal", situacaoNormal).setInteger(
					"incluida", situacaoIncluida).setInteger("retificada",
					situacaoRetificada).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection obterContasImovelIntervalo(Integer imovel,
			Integer situacaoNormal, Integer situacaoIncluida,
			Integer situacaoRetificada, Integer anoMesInicio, Integer anoMesFim)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, "
					+ "cnta.valorEsgoto, cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
					+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, "
					+ "cnta.referenciaContabil, cnta.ultimaAlteracao "
					+ "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE imov.id = :idImovel AND "
					+ "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada) AND "
					+ "cnta.referencia BETWEEN :inicio AND :fim";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovel).setInteger("normal", situacaoNormal).setInteger(
					"incluida", situacaoIncluida).setInteger("retificada",
					situacaoRetificada).setInteger("inicio", anoMesInicio)
					.setInteger("fim", anoMesFim).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection obterContasImovelIntervalo(Integer imovel,
			Integer situacaoNormal, Integer situacaoIncluida,
			Integer situacaoRetificada, Integer anoMesInicio,
			Integer anoMesFim, Integer idContaMotivoRevisao)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, "
					+ "cnta.valorEsgoto, cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
					+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, "
					+ "cnta.referenciaContabil, cnta.ultimaAlteracao "
					+ "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE imov.id = :idImovel AND "
					+ "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada) AND "
					+ "cnta.referencia BETWEEN :inicio AND :fim"
					+ " and cnta.contaMotivoRevisao.id = :idContaMotivoRevisao";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovel).setInteger("normal", situacaoNormal).setInteger(
					"incluida", situacaoIncluida).setInteger("retificada",
					situacaoRetificada).setInteger("inicio", anoMesInicio)
					.setInteger("fim", anoMesFim).setInteger(
							"idContaMotivoRevisao", idContaMotivoRevisao)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 24/04/2006
	 * 
	 * Obtém as guias de pagamento de um imóvel com ano/mes da data de
	 * vencimento menor ou igual ao ano/mes de referencia da arrecadacao
	 * corrente e com situacao atual correspondente a normal, retificada ou
	 * incluida.
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterGuiasPagamentoImovel(Integer imovel,
			Integer situacaoNormal, Integer situacaoIncluida,
			Integer situacaoRetificada, Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gpag.id, gpag.anoMesReferenciaContabil, gpag.dataVencimento, gpag.valorDebito, gpag.indicadoCobrancaMulta, dbtp.id "
					+ "FROM GuiaPagamento gpag "
					// + "INNER JOIN gpag.imovel imov "
					// + "INNER JOIN gpag.debitoCreditoSituacaoAtual dcst "
					+ "INNER JOIN gpag.debitoTipo dbtp "
					+ "WHERE dbtp.id <> :idDebitoTipo AND "
					+ "imov_id = :idImovel AND "
					+ "dcst_idatual IN(:normal, :incluida, :retificada) ";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovel).setInteger("normal", situacaoNormal).setInteger(
					"incluida", situacaoIncluida).setInteger("retificada",
					situacaoRetificada).setInteger("idDebitoTipo",
					DebitoTipo.ENTRADA_PARCELAMENTO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 25/04/2006
	 * 
	 * Obtém os pagamentos da conta que contem a menor data de pagamento
	 * 
	 * @param conta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date obterPagamentoContasMenorData(Integer conta, Integer idImovel,
			Integer anoMesReferenciaConta) throws ErroRepositorioException {

		Date retorno = null;

		Date data1 = null;
		Date data2 = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "

					+ "WHERE cnta_id = :idConta ";

			data1 = (Date) session.createQuery(consulta).setInteger("idConta",
					conta).uniqueResult();

			consulta = "SELECT MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "
					// + "INNER JOIN pgmt.conta cnta "
					// + "INNER JOIN cnta.imovel imov "
					+ "WHERE imov_id= :idImovel and pgmt.anoMesReferenciaPagamento = :anoMesReferenciaConta";

			data2 = (Date) session.createQuery(consulta).setInteger("idImovel",
					idImovel).setInteger("anoMesReferenciaConta",
					anoMesReferenciaConta).uniqueResult();

			if (data2 == null) {
				retorno = data1;
			} else {
				if (data1 == null) {
					retorno = data2;
				} else {
					if (data1.before(data2)) {
						retorno = data1;
					} else {
						retorno = data2;
					}
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0302] Gerar Débito a Cobrar de Acrescimos por Impontualidade [SB0001]
	 * Gerar Débito a Cobrar
	 * 
	 * @author Fernanda Paiva
	 * @created 25/04/2006
	 * 
	 * @param valor
	 *            da multa/juros/atualização monetaria
	 * @param ano/mes
	 *            referencia
	 * @param tipo
	 *            debito
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object gerarDebitoACobrar(DebitoACobrar debitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Object retorno;
		try {
			// Inclui o débito a cobrar
			retorno = session.save(debitoACobrar);
			session.flush();
			session.clear();
			return retorno;
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 26/04/2006
	 * 
	 * Obtém o tipo do debito
	 * 
	 * @param tipoDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterDebitoTipo(Integer debitoTipo)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT fntp.id, lict.id " + "FROM DebitoTipo dbtp "
					+ "INNER JOIN dbtp.financiamentoTipo fntp "
					+ "INNER JOIN dbtp.lancamentoItemContabil lict "
					+ "WHERE dbtp.id = :idDebitoTipo ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idDebitoTipo", debitoTipo).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os relacionamentos entre o cliente e os imóveis de acordo com o
	 * código do cliente responsável
	 * 
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 25/04/2006, 18/12/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarClienteImovelPorClienteResponsavel(
			Integer idCliente) throws ErroRepositorioException {

		// Cria a variável que vai armazenar a coleção de ClienteImovel
		// responsável
		Collection<Integer> retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Monta o hql
			consulta = "select imov.id "
					+ "from ClienteImovel clim "
					+ "inner join clim.imovel imov "
					+ "inner join clim.cliente clie "
					+ "where clim.cliente.id = :idCliente and "
					+ "clim.clienteRelacaoTipo.id = :idTipoRelacao and "
					+ "clim.dataFimRelacao is null and "
					+ "imov.indicadorEmissaoExtratoFaturamento = :indicadorFaturamento "
					+ "order by imov.id ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idCliente",
					idCliente).setInteger("idTipoRelacao",
					ClienteRelacaoTipo.RESPONSAVEL).setInteger(
					"indicadorFaturamento", ConstantesSistema.SIM).list();

			// Erro na consulta
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// Retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa todos os clientes responsáveis na tabela de ClienteImovel para
	 * tipo de relação igual a responsável e data de fim de relação iguala a
	 * nula
	 * 
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 25/04/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarClientesResponsaveis(
			SistemaParametro sistemaParametro, Integer numeroIndice,
			Integer quantidadeRegistros) throws ErroRepositorioException {

		// Cria a variável que vai armazenar a coleção de clientes responsáveis
		Collection<Integer> retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Monta o HQL
			consulta = "select distinct clim.cliente.id "
					+ "from ClienteImovel clim "
					+ "inner join clim.imovel imov "
					+ "inner join clim.cliente clie "
					+ "where clim.clienteRelacaoTipo.id = :idTipoRelacao "
					+ "and clim.dataFimRelacao is null "
					+ "and imov.indicadorEmissaoExtratoFaturamento = :indicadorEmissaoExtratoFaturamento "
					+ "and not exists(select f.id from Fatura f where f.cliente.id = clim.cliente.id and f.anoMesReferencia = :anoMesReferenciaFaturamento)";

			// Executa o HQL
			retorno = session.createQuery(consulta).setInteger("idTipoRelacao",
					ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("indicadorEmissaoExtratoFaturamento",
							ConstantesSistema.SIM).setInteger(
							"anoMesReferenciaFaturamento",
							sistemaParametro.getAnoMesFaturamento())
					.setMaxResults(quantidadeRegistros).setFirstResult(
							numeroIndice).list();

			// Erro na consulta
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de clientes responsáveis pesquisados
		return retorno;
	}

	/**
	 * Pesquisa todos os clientes responsáveis na tabela de ClienteImovel para
	 * tipo de relação igual a responsável e data de fim de relação igual a nula
	 * e com indicador faturas agrupadas igual a 1
	 * 
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Rafael Corrêa
	 * @date 04/02/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarClientesResponsaveisFaturamentoAntecipado(
			SistemaParametro sistemaParametro, Integer numeroIndice,
			Integer quantidadeRegistros) throws ErroRepositorioException {

		// Cria a variável que vai armazenar a coleção de clientes responsáveis
		Collection<Integer> retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Monta o HQL
			consulta = "select distinct clim.cliente.id "
					+ "from ClienteImovel clim "
					+ "inner join clim.imovel imov "
					+ "inner join clim.cliente clie "
					+ "where clim.clienteRelacaoTipo.id = :idTipoRelacao "
					+ "and clim.dataFimRelacao is null "
					+ "and imov.indicadorEmissaoExtratoFaturamento = :indicadorEmissaoExtratoFaturamento "
					+ "and clie.indicadorGeraFaturaAntecipada = :indicadorGeraFaturaAntecipada "
					+ "and not exists(select f.id from Fatura f where f.cliente.id = clim.cliente.id and f.anoMesReferencia = :anoMesReferenciaFaturamento)";

			// Executa o HQL
			retorno = session.createQuery(consulta).setInteger("idTipoRelacao",
					ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("indicadorEmissaoExtratoFaturamento",
							ConstantesSistema.SIM).setInteger(
							"indicadorGeraFaturaAntecipada",
							ConstantesSistema.SIM).setInteger(
							"anoMesReferenciaFaturamento",
							sistemaParametro.getAnoMesFaturamento())
					.setMaxResults(quantidadeRegistros).setFirstResult(
							numeroIndice).list();

			// Erro na consulta
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de clientes responsáveis pesquisados
		return retorno;
	}

	/**
	 * Pesquisa a coleção de contas para os imóveis do cliente responsável para
	 * o ano/mês de referÊncia igual ao ano/mês de referÊncia corrente e a
	 * situação da conta igual a Normal ou Retificada ou Incluída
	 * 
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 25/04/2006
	 * 
	 * @param idsConcatenadosImoveis
	 * @param anoMesReferenciaConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContaImovelResponsabilidadeCliente(
			Collection idsConcatenadosImoveis, Integer anoMesReferenciaConta)
			throws ErroRepositorioException {

		// Cria a variável que vai armazenar a coleção de contas
		Collection<Conta> retorno = null;
		Collection<Conta> retornoConsulta = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Monta o HQL
			consulta = "select cnta from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join fetch cnta.ligacaoAguaSituacao last "
					+ "where cnta.referencia = :referenciaConta and "
					+ "(cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.NORMAL
					+ " or cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.RETIFICADA
					+ " or cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.INCLUIDA + ") and "
					+ "cnta.imovel.id in ( :idsConcatenadosImoveis )";
					
			if (idsConcatenadosImoveis.size() > 999) {

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsConcatenadosImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsConcatenadosImoveis.size() / qtdQuebras;
				if (idsConcatenadosImoveis.size() % qtdQuebras != 0) {
					indice++;
				}
				
				retorno = new ArrayList<Conta>();
				
				for (int i = 0; i < indice; i++) {
					retornoConsulta = session.createQuery(consulta)
					.setInteger("referenciaConta", anoMesReferenciaConta)
					.setParameterList("idsConcatenadosImoveis", particoes.get(i))
					.list();
					retorno.addAll(retornoConsulta);
				}
				
			} else {
				retorno = session.createQuery(consulta)
				.setInteger("referenciaConta", anoMesReferenciaConta)
				.setParameterList("idsConcatenadosImoveis", idsConcatenadosImoveis)
				.list();
			}		
			

			// Erro na pesquisa
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de contas dos imóveis sobre responsabilidade do
		// cliente informado
		return retorno;
	}

	/**
	 * Retorna um Object contendo um array de object com três posições contendo
	 * na primeira posição a soma do valor total das contas na segunda posição a
	 * maior data de vencimento das contas e na terceira posiçãoa maior data de
	 * validade das contas esses dados são necessários para gerar a fatura
	 * 
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 25/04/2006
	 * 
	 * @param idsConcatenadosImoveis
	 * @param anoMesReferenciaConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object pesquisarResumoContasClienteResponsavel(
			Collection idsConcatenadosImoveis, Integer anoMesReferenciaConta)
			throws ErroRepositorioException {

		// Cria a variável que vai armazenar o array retornado
		Object retorno = null;
		Collection<Object[]> retornoConsulta = new ArrayList();

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Monta o HQL
			consulta = "select sum(((cnta.valorAgua + cnta.valorEsgoto + cnta.debitos) - cnta.valorCreditos) - cnta.valorImposto ), "
					+ "max(cnta.dataVencimentoConta), "
					+ "max(cnta.dataValidadeConta) "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "where cnta.referencia = :referenciaConta and "
					+ "(cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.NORMAL
					+ " or cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.RETIFICADA
					+ " or cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.INCLUIDA
					+ ") and "
					+ "cnta.imovel.id in ( :idsConcatenadosImoveis )";
			
			if (idsConcatenadosImoveis.size() > 999) {

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsConcatenadosImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsConcatenadosImoveis.size() / qtdQuebras;
				if (idsConcatenadosImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				for (int i = 0; i < indice; i++) {
					retorno = session.createQuery(consulta)
						.setInteger("referenciaConta", anoMesReferenciaConta)
						.setParameterList("idsConcatenadosImoveis", particoes.get(i))
						.uniqueResult();
					
					retornoConsulta.add((Object[]) retorno);
				}
				
				if(retornoConsulta!=null && !retornoConsulta.isEmpty()){
					Object[] arrayRetorno =  new Object[3];
					
					arrayRetorno[0] =  BigDecimal.ZERO;
					
					
					for (Object[] variavelSoma : retornoConsulta) {
						
						BigDecimal valor = (BigDecimal) variavelSoma[0];
						Date dataVencimentoConta = (Date) variavelSoma[1]; 
						Date dataValidadeConta = (Date) variavelSoma[2]; 
						
						if(valor !=null) {
						
							arrayRetorno[0] = ((BigDecimal)arrayRetorno[0]).add(valor);
						}
						if(arrayRetorno[1] == null && arrayRetorno[2] == null){
							arrayRetorno[1] = dataVencimentoConta;
							arrayRetorno[2] = dataValidadeConta;	
						}
						if(dataVencimentoConta != null && arrayRetorno[1] !=null){
							if(dataVencimentoConta.compareTo((Date) arrayRetorno[1])>0){
								arrayRetorno[1] = dataVencimentoConta;
							}
						}
						if(dataValidadeConta !=null && arrayRetorno[2] != null){
							if(dataValidadeConta.compareTo((Date) arrayRetorno[2])>0){
								arrayRetorno[2] = dataValidadeConta;
							}
						}
						
					}
					
					retorno  = arrayRetorno;
				}else{
					System.out.println("colecao Vazia");
				}
			} else {
				retorno = session.createQuery(consulta)
				.setInteger("referenciaConta", anoMesReferenciaConta)
				.setParameterList("idsConcatenadosImoveis", idsConcatenadosImoveis)
				.uniqueResult();
			}


			// Erro na consulta
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna o array contendo os dados do resumo das contas necessários
		// para gerar a fatura
		return retorno;
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 27/04/2006
	 * 
	 * Atualiza o indicador de cobranca de multa na tabela de conta
	 * 
	 * @param idMulta
	 * @return
	 * @throws ErroRepositorioException
	 */

	public void atualizarIndicadorMultaDeConta(
			Collection<Integer> colecaoIdsContas)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try {
			atualizarConta = "update Conta cnta "
					+ "set ultimaAlteracao = :dataUltimaAlteracao, indicadorCobrancaMulta = 1 "
					+ "where cnta.id in (:idsContas) ";

			session.createQuery(atualizarConta).setTimestamp(
					"dataUltimaAlteracao", new Date()).setParameterList(
					"idsContas", colecaoIdsContas).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 27/04/2006
	 * 
	 * Atualiza o indicador de cobranca de multa na tabela de Guia Pagamento
	 * 
	 * @param idMulta
	 * @return
	 * @throws ErroRepositorioException
	 */

	public void atualizarIndicadorMultaDeGuiaPagamento(
			Collection<Integer> colecaoIdsGuiasPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarGuia;

		try {
			atualizarGuia = "update GuiaPagamento gpag "
					+ "set ultimaAlteracao = :dataUltimaAlteracao, indicadoCobrancaMulta = 1 "
					+ "where gpag.id in (:idsGuiasPagamentos) ";

			session.createQuery(atualizarGuia).setTimestamp(
					"dataUltimaAlteracao", new Date()).setParameterList(
					"idsGuiasPagamentos", colecaoIdsGuiasPagamento)
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa os items da fatura informada com o código da fatura igua ao
	 * código da fatura dos items para emitir a fatura do cliente responsável
	 * 
	 * [UC0321] Emitir Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 28/04/2006
	 * 
	 * @param idFatura
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturaItem> pesquisarItemsFatura(Integer idFatura)
			throws ErroRepositorioException {

		// Cria a variável que vai armazenar a coleção de items de fatura
		Collection<FaturaItem> retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Monta o HQL
			consulta = "select fitm " + "from FaturaItem fitm "
					+ "inner join fitm.fatura fatu "
					+ "inner join fitm.imovel imov "
					+ "where fatu.id = :idFatura " + "order by imov.id";

			// Executa o HQL
			retorno = session.createQuery(consulta).setInteger("idFatura",
					idFatura).list();

			// Erro na consulta
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de itens da fatura da fatura informada
		return retorno;
	}

	/**
	 * [UC0329] - Restabelecer Situação Anterior da Conta Atualiza para null a
	 * data de cancelamento e o motivo do cancelamento Author: Fernanda Paiva
	 * Date: 05/05/2006
	 * 
	 * Atualiza a situacao anterior da conta de situacao atual cancelada
	 * 
	 * @param idConta
	 * @return
	 */

	public void restabelecerSituacaoAnteriorContaCancelada(String idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try {

			atualizarConta = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "cnta_dtcancelamento = null, cmcn_id = null, "
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE cnta_id = :idConta ";

			session.createQuery(atualizarConta).setTimestamp(
					"dataUltimaAlteracao", new Date()).setInteger("idConta",
					new Integer(idConta).intValue()).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0329] - Alterar as Situação Anterior e atual da Conta Author: Fernanda
	 * Paiva Date: 05/05/2006
	 * 
	 * Atualiza a situacao anterior da conta de situacao atual da conta
	 * 
	 * @param idConta
	 *            situacaoAnterior situacaoAtual
	 * @return
	 */

	public void alterarSituacaoAnteriorAtualConta(String idConta,
			Integer situacaoAnterior, Integer situacaoAtual)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try {

			atualizarConta = "UPDATE gcom.faturamento.conta.Conta SET ";

			if (situacaoAnterior != null) {
				atualizarConta = atualizarConta
						+ " dcst_idanterior = :situacaoAnterior, dcst_idatual = :situacaoAtual, "
						+ "cnta_tmultimaalteracao = :dataUltimaAlteracao "
						+ "WHERE cnta_id = :idConta ";
			} else {
				atualizarConta = atualizarConta
						+ " dcst_idanterior = null, dcst_idatual = :situacaoAtual, "
						+ "cnta_tmultimaalteracao = :dataUltimaAlteracao "
						+ "WHERE cnta_id = :idConta ";
			}

			if (situacaoAnterior != null) {
				session.createQuery(atualizarConta).setTimestamp(
						"dataUltimaAlteracao", new Date()).setInteger(
						"idConta", new Integer(idConta).intValue()).setInteger(
						"situacaoAnterior", situacaoAnterior.intValue())
						.setInteger("situacaoAtual", situacaoAtual.intValue())
						.executeUpdate();
			} else {
				session.createQuery(atualizarConta).setTimestamp(
						"dataUltimaAlteracao", new Date()).setInteger(
						"idConta", new Integer(idConta).intValue()).setInteger(
						"situacaoAtual", situacaoAtual.intValue())
						.executeUpdate();
			}

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0329] - Restabelecer Situação Anterior da Conta Author: Fernanda Paiva
	 * Date: 05/05/2006
	 * 
	 * Atualiza a situacao atual da conta
	 * 
	 * @param idConta
	 * @return
	 */

	public void alterarSituacaoConta(String idConta, Integer situacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try {

			atualizarConta = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "dcst_idatual = :situacao, cnta_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE cnta_id = :idConta ";

			session.createQuery(atualizarConta).setTimestamp(
					"dataUltimaAlteracao", new Date()).setInteger("idConta",
					new Integer(idConta).intValue()).setInteger("situacao",
					situacao.intValue()).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * Permite FAturar um conjunto de rotas de um grupo de faturamento
	 * 
	 * [UC0067] - Faturar Grupo de Faturaumetno
	 * 
	 * Determinar VAlores para Faturamento de Água e/ou Esgoto
	 * 
	 * [SF0002] - Determinar VAlores para Faturamento de Água e/ou Esgoto
	 * 
	 * @author Rafael Santos
	 * @date 26/04/2006
	 * 
	 * @param faturamentoGrupoId
	 * @param faturamentoAtividadeId
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
			Integer faturamentoGrupoId, Integer faturamentoAtividadeId,
			Integer anoMesReferencia) throws ErroRepositorioException {

		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select fac.dataRealizacao from FaturamentoAtividadeCronograma fac "
					+ "inner join fac.faturamentoAtividade fa "
					+ "inner join fac.faturamentoGrupoCronogramaMensal fcm "
					+ "inner join fcm.faturamentoGrupo fg "
					+ "where fg.id = :faturamentoGrupoId and fa.id = :faturamentoAtividadeId "
					+ "and fcm.anoMesReferencia = :anoMesReferencia";

			retorno = session.createQuery(consulta).setInteger(
					"faturamentoGrupoId", faturamentoGrupoId.intValue())
					.setInteger("faturamentoAtividadeId",
							faturamentoAtividadeId).setInteger(
							"anoMesReferencia", anoMesReferencia)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Atualizar Debito a Cobrar Campo numero de prestações cobradas
	 * 
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * @author Rafael Santos
	 * @date 03/05/2006
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void atualizarDebitoAcobrar(DebitoACobrar debitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			atualizarImovel = "update gcom.faturamento.debito.DebitoACobrar "
					+ "set dbac_amreferenciaprestacao = :anoMesPrestacao, dbac_nnprestacaocobradas = :numeroPrestacao, "
					+ "dbac_tmultimaalteracao = :dataAtual "
					+ " where dbac_id = :idDebitoAcobrar";

			session.createQuery(atualizarImovel).setShort("numeroPrestacao",
					debitoACobrar.getNumeroPrestacaoCobradas()).setInteger(
					"idDebitoAcobrar", debitoACobrar.getId().intValue())
					.setInteger("anoMesPrestacao",
							debitoACobrar.getAnoMesReferenciaPrestacao())
					.setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar Debito a Cobrar Campo numero de prestações cobradas
	 * 
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 15/09/2006
	 * 
	 * @param colecaoDebitosACobrar
	 * @throws ErroRepositorioException
	 */
	public void atualizarDebitoACobrar(List colecaoDebitosACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarDebitoACobrar = "update gcom.faturamento.debito.DebitoACobrar "
				+ "set dbac_nnprestacaocobradas = :numeroPrestacao "
				+ " where dbac_id = :idDebitoAcobrar";

		try {

			Iterator<DebitoACobrar> iteratorDebitosACobrar = colecaoDebitosACobrar
					.iterator();

			while (iteratorDebitosACobrar.hasNext()) {

				DebitoACobrar debitoACobrar = iteratorDebitosACobrar.next();

				session.createQuery(atualizarDebitoACobrar).setShort(
						"numeroPrestacao",
						debitoACobrar.getNumeroPrestacaoCobradas()).setInteger(
						"idDebitoAcobrar", debitoACobrar.getId())
						.executeUpdate();
			}

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar Credito a Realizar Campo numero de prestações realizadas e
	 * valor mes anterior
	 * 
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * @author Rafael Santos
	 * @date 03/05/2006
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void atualizarCreditoARealizar(CreditoARealizar creditoARealizar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {

			if (creditoARealizar.getAnoMesReferenciaPrestacao() != null) {

				if (creditoARealizar.getValorResidualConcedidoMes() == null){
					
					atualizarImovel = "update gcom.faturamento.credito.CreditoARealizar "
						+ "set crar_amreferenciaprestacao = :anoMesPrestacao, "
						+ "crar_nnprestacaorealizadas = :numeroPrestacao,crar_vlresidualmesanterior = :valorMesAnterior, "
						+ "crar_tmultimaalteracao = :dataAtual"
						+ " where crar_id = :idCreditoARelizar";

				session.createQuery(atualizarImovel).setShort(
						"numeroPrestacao",
						creditoARealizar.getNumeroPrestacaoRealizada())
						.setBigDecimal("valorMesAnterior",
								creditoARealizar.getValorResidualMesAnterior())
						.setInteger("idCreditoARelizar",
								creditoARealizar.getId().intValue())
						.setInteger(
								"anoMesPrestacao",
								creditoARealizar.getAnoMesReferenciaPrestacao()
										.intValue()).setTimestamp("dataAtual",
								new Date()).executeUpdate();
				}
				else{
					
					atualizarImovel = "update gcom.faturamento.credito.CreditoARealizar "
						+ "set crar_amreferenciaprestacao = :anoMesPrestacao, "
						+ "crar_nnprestacaorealizadas = :numeroPrestacao, crar_vlresidualmesanterior = :valorMesAnterior, "
						+ "crar_vlresidualconcedidomes = :valorConcedidoMes, "
						+ "crar_tmultimaalteracao = :dataAtual"
						+ " where crar_id = :idCreditoARelizar";

					session.createQuery(atualizarImovel).setShort(
						"numeroPrestacao",
						creditoARealizar.getNumeroPrestacaoRealizada())
						.setBigDecimal("valorMesAnterior",
								creditoARealizar.getValorResidualMesAnterior())
						.setInteger("idCreditoARelizar",
								creditoARealizar.getId().intValue())
						.setInteger(
								"anoMesPrestacao",
								creditoARealizar.getAnoMesReferenciaPrestacao()
										.intValue()).setTimestamp("dataAtual",
								new Date()).setBigDecimal("valorConcedidoMes", creditoARealizar.getValorResidualConcedidoMes())
								.executeUpdate();
				}
				
			} 
			else {

				if (creditoARealizar.getValorResidualConcedidoMes() == null){
					
					atualizarImovel = "update gcom.faturamento.credito.CreditoARealizar "
						+ "set crar_nnprestacaorealizadas = :numeroPrestacao, "
						+ "crar_vlresidualmesanterior = :valorMesAnterior, crar_tmultimaalteracao = :dataAtual "
						+ "where crar_id = :idCreditoARelizar";

					session.createQuery(atualizarImovel).setShort(
						"numeroPrestacao",
						creditoARealizar.getNumeroPrestacaoRealizada())
						.setBigDecimal("valorMesAnterior",
								creditoARealizar.getValorResidualMesAnterior())
						.setInteger("idCreditoARelizar",
								creditoARealizar.getId().intValue())
						.setTimestamp("dataAtual", new Date()).executeUpdate();
				}
				else{
					
					atualizarImovel = "update gcom.faturamento.credito.CreditoARealizar "
						+ "set crar_nnprestacaorealizadas = :numeroPrestacao, "
						+ "crar_vlresidualmesanterior = :valorMesAnterior, crar_vlresidualconcedidomes = :valorConcedidoMes, "
						+ "crar_tmultimaalteracao = :dataAtual "
						+ "where crar_id = :idCreditoARelizar";

					session.createQuery(atualizarImovel).setShort(
						"numeroPrestacao",
						creditoARealizar.getNumeroPrestacaoRealizada())
						.setBigDecimal("valorMesAnterior",
								creditoARealizar.getValorResidualMesAnterior())
						.setInteger("idCreditoARelizar",
								creditoARealizar.getId().intValue())
						.setTimestamp("dataAtual", new Date()).setBigDecimal("valorConcedidoMes", creditoARealizar.getValorResidualConcedidoMes())
						.executeUpdate();
				}
				
			}

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Obtem a Ligacao Esgoto do Imovel UC0113 - Faturar Grupo Faturamento
	 * 
	 * @author Rafael Santos
	 * @date 05/05/2006
	 * 
	 * @param idImovel
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public LigacaoEsgoto obterLigacaoEsgotoImovel(Integer idImovel)
			throws ErroRepositorioException {
		LigacaoEsgoto retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select le " + "from LigacaoEsgoto le "
					+ "inner join le.imovel imovel "
					+ "where imovel.id = :imovelId ";

			Object pesquisa = session.createQuery(consulta).setInteger(
					"imovelId", idImovel.intValue()).setMaxResults(1)
					.uniqueResult();

			if (pesquisa != null) {
				retorno = (LigacaoEsgoto) pesquisa;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * Recupera o percentual de esgoto para o imóvel informado.
	 * 
	 * @author Pedro Alexandre
	 * @date 18/09/2006
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterPercentualLigacaoEsgotoImovel(Integer idImovel)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select le.percentual " + "from LigacaoEsgoto le "
					+ "where le.id = :imovelId ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"imovelId", idImovel.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com estouro de consumo ou com baixo consumo [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasEmitir(Collection<Integer> idTipoConta,
			Integer idEmpresa, Integer numeroPaginas, Integer anoMesReferencia,
			Integer idFaturamentoGrupo,Integer anoMesReferenciaFaturamentoAntecipado,
			Integer imovelContaEnvio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega "// 41
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id in (:idTipoConta) AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND "
					+ "contaImpressao.empr_id = :idEmpresa AND ";
			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2 ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			
			consulta += " AND cliCnt.clct_icnomeconta = :indicadorNomeConta "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"tipoConta", Hibernate.INTEGER).addScalar(
							"rotaEntrega", Hibernate.INTEGER).addScalar(
							"seqRotaEntrega", Hibernate.INTEGER)
					.setParameterList("idTipoConta", idTipoConta).setInteger(
							"idEmpresa", idEmpresa).setInteger("indicadorNomeConta",
							ConstantesSistema.INDICADOR_USO_ATIVO).setInteger(
							"idFaturamentoGrupoParms", idFaturamentoGrupo)
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com estouro de consumo ou com baixo consumo [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasEmitirCAER(
			Collection<Integer> idTipoConta, Integer idEmpresa,
			Integer numeroPaginas, Integer anoMesReferencia,
			Integer idFaturamentoGrupo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega, "// 41
					+ "imovel.imov_nnquadraentrega as numeroQuadraEntrega "// 42
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "WHERE contaImpressao.cttp_id in (:idTipoConta) "
					+ "AND contaImpressao.ftgr_id = :idFaturamentoGrupoParms "
					+ "AND contaImpressao.empr_id = :idEmpresa "
					+ "AND contaImpressao.cnti_amreferenciaconta = :anoMesReferencia"
					//+ " AND cliCnt.crtp_id = :idUsuario "
					+ " AND cliCnt.clct_icnomeconta = :indicadorNomeConta "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"tipoConta", Hibernate.INTEGER).addScalar(
							"rotaEntrega", Hibernate.INTEGER).addScalar(
							"seqRotaEntrega", Hibernate.INTEGER).addScalar(
									"numeroQuadraEntrega", Hibernate.INTEGER)
					.setParameterList("idTipoConta", idTipoConta).setInteger(
							"idEmpresa", idEmpresa).setInteger("indicadorNomeConta",
							ConstantesSistema.INDICADOR_USO_ATIVO).setInteger(
							"idFaturamentoGrupoParms", idFaturamentoGrupo)
					.setInteger("anoMesReferencia", anoMesReferencia).

					setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna as contas para impressao
	 * 
	 * Pesquisar Contas Emitir Caern
	 * 
	 * @author Tiago Moreno
	 * @date 05/05/2007
	 * 
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasEmitirCAERN(Integer idTipoConta,
			Integer idEmpresa, Integer numeroPaginas, Integer anoMesReferencia,
			Integer idFaturamentoGrupo,BigDecimal valorContaFichaComp) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel "// 32
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "where "
					+ "contaImpressao.cnti_amreferenciaconta = :referencia AND "
					+ "cnt.cnta_tmultimaalteracao > :data AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND "
					// + "loc.loca_id = 312 AND cnt.cnta_cdsetorcomercial = 1
					// AND rota.rota_cdrota =3 AND " Alterado em 16/01/09 -
					// Emitir contas Extraviadas
					+ "cliCnt.clct_icnomeconta = :indicadorNomeConta AND imovel.icte_id <> 9 ";
					
					if(valorContaFichaComp != null && !valorContaFichaComp.equals(new BigDecimal("0.00"))){
						consulta = consulta + "AND contaImpressao.cnti_vlconta <= :valorLimite ";
					}
					consulta = consulta + "order by  cnt.cnta_amreferenciaconta, loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota, imovel.imov_nnsequencialrota";

					
					if(valorContaFichaComp != null && !valorContaFichaComp.equals(new BigDecimal("0.00"))){
						retorno = session.createSQLQuery(consulta).addScalar("idConta",
								Hibernate.INTEGER).addScalar("nomeCliente",
								Hibernate.STRING).addScalar("dataVencimentoConta",
								Hibernate.DATE)
								.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
										"digitoVerificador", Hibernate.SHORT).addScalar(
										"codigoSetorComercial", Hibernate.INTEGER)
								.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
										"lote", Hibernate.SHORT).addScalar("sublote",
										Hibernate.SHORT).addScalar("consumoAgua",
										Hibernate.INTEGER).addScalar("consumoEsgoto",
										Hibernate.INTEGER).addScalar("valorAgua",
										Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
										Hibernate.BIG_DECIMAL).addScalar("debitos",
										Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
										Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
										Hibernate.BIG_DECIMAL).addScalar("dataValidade",
										Hibernate.DATE).addScalar("idImovel",
										Hibernate.INTEGER).addScalar("idLocalidade",
										Hibernate.INTEGER).addScalar("idGerenciaRegional",
										Hibernate.INTEGER).addScalar("nomeGerencia",
										Hibernate.STRING).addScalar(
										"idLigacaoAguaSituacao", Hibernate.INTEGER)
								.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
								.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
										"idSetorComercial", Hibernate.INTEGER).addScalar(
										"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
										"idEmpresa", Hibernate.INTEGER).addScalar(
										"descricaoLocalidade", Hibernate.STRING).addScalar(
										"descricaoLigAguaSit", Hibernate.STRING).addScalar(
										"descricaoLigEsgotoSit", Hibernate.STRING)
								.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
								.addScalar("idClienteResponsavel", Hibernate.INTEGER)
								.addScalar("nomeImovel", Hibernate.STRING).setDate("data",
										Util.criarData(16, 05, 2007)).setInteger(
										"indicadorNomeConta", ConstantesSistema.INDICADOR_USO_ATIVO)
								.setInteger("referencia", anoMesReferencia).setInteger(
										"idFaturamentoGrupoParms", idFaturamentoGrupo)
											.setBigDecimal("valorLimite",valorContaFichaComp)
								.setMaxResults(1000).setFirstResult(numeroPaginas).list();
					}else{
						retorno = session.createSQLQuery(consulta).addScalar("idConta",
								Hibernate.INTEGER).addScalar("nomeCliente",
								Hibernate.STRING).addScalar("dataVencimentoConta",
								Hibernate.DATE)
								.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
										"digitoVerificador", Hibernate.SHORT).addScalar(
										"codigoSetorComercial", Hibernate.INTEGER)
								.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
										"lote", Hibernate.SHORT).addScalar("sublote",
										Hibernate.SHORT).addScalar("consumoAgua",
										Hibernate.INTEGER).addScalar("consumoEsgoto",
										Hibernate.INTEGER).addScalar("valorAgua",
										Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
										Hibernate.BIG_DECIMAL).addScalar("debitos",
										Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
										Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
										Hibernate.BIG_DECIMAL).addScalar("dataValidade",
										Hibernate.DATE).addScalar("idImovel",
										Hibernate.INTEGER).addScalar("idLocalidade",
										Hibernate.INTEGER).addScalar("idGerenciaRegional",
										Hibernate.INTEGER).addScalar("nomeGerencia",
										Hibernate.STRING).addScalar(
										"idLigacaoAguaSituacao", Hibernate.INTEGER)
								.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
								.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
										"idSetorComercial", Hibernate.INTEGER).addScalar(
										"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
										"idEmpresa", Hibernate.INTEGER).addScalar(
										"descricaoLocalidade", Hibernate.STRING).addScalar(
										"descricaoLigAguaSit", Hibernate.STRING).addScalar(
										"descricaoLigEsgotoSit", Hibernate.STRING)
								.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
								.addScalar("idClienteResponsavel", Hibernate.INTEGER)
								.addScalar("nomeImovel", Hibernate.STRING).setDate("data",
										Util.criarData(16, 05, 2007)).setInteger(
												"indicadorNomeConta", ConstantesSistema.INDICADOR_USO_ATIVO)
								.setInteger("referencia", anoMesReferencia).setInteger(
										"idFaturamentoGrupoParms", idFaturamentoGrupo)
								.setMaxResults(1000).setFirstResult(numeroPaginas).list();
					}
					
			

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarContasEmitirCOSANPA(Integer idTipoConta,
			Integer idEmpresa, Integer numeroPaginas, Integer anoMesReferencia,
			Integer idFaturamentoGrupo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega, "// 41
					+ "imovel.imov_nnquadraentrega as numeroQuadraEntrega, "// 42
					+ "cnt.cnta_vlrateioagua as valorRateioAgua, " //43
					+ "cnt.cnta_vlrateioesgoto as valorRateioEsgoto " //44
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "inner join cadastro.quadra_face quadraFace on imovel.qdfa_id=quadraFace.qdfa_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where "
					+ "contaImpressao.cnti_amreferenciaconta = :referencia AND "
					+ "cnt.cnta_tmultimaalteracao > :data AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND "
					+ "cliCnt.clct_icnomeconta = :indicadorNomeConta AND "
					+ "imovel.icte_id not in (4,9) "
					+ " AND cnt.dcst_idatual in (" + DebitoCreditoSituacao.NORMAL + "," + DebitoCreditoSituacao.RETIFICADA + ") "
					+ "order by  loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota, quadraFace.qdfa_nnfacequadra, imovel.imov_nnlote";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("nomeCliente",Hibernate.STRING)
					.addScalar("dataVencimentoConta",Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER)
					.addScalar("digitoVerificador", Hibernate.SHORT)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("lote", Hibernate.SHORT)
					.addScalar("sublote",Hibernate.SHORT)
					.addScalar("consumoAgua",Hibernate.INTEGER)
					.addScalar("consumoEsgoto",Hibernate.INTEGER)
					.addScalar("valorAgua",Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgoto",Hibernate.BIG_DECIMAL)
					.addScalar("debitos",Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditos",Hibernate.BIG_DECIMAL)
					.addScalar("valorImpostos",Hibernate.BIG_DECIMAL)
					.addScalar("dataValidade",Hibernate.DATE)
					.addScalar("idImovel",Hibernate.INTEGER)
					.addScalar("idLocalidade",Hibernate.INTEGER)
					.addScalar("idGerenciaRegional",Hibernate.INTEGER)
					.addScalar("nomeGerencia",Hibernate.STRING)
					.addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER)
					.addScalar("idSetorComercial", Hibernate.INTEGER)
					.addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("descricaoLocalidade", Hibernate.STRING)
					.addScalar("descricaoLigAguaSit", Hibernate.STRING)
					.addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING)
					.addScalar("codigoRota", Hibernate.SHORT)
					.addScalar("sequencialRota", Hibernate.INTEGER)
					.addScalar("origem", Hibernate.INTEGER)
					.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER)
					.addScalar("nomeFuncionario", Hibernate.STRING)
					.addScalar("tipoConta", Hibernate.INTEGER)
					.addScalar("rotaEntrega", Hibernate.INTEGER)
					.addScalar("seqRotaEntrega", Hibernate.INTEGER)
					.addScalar("numeroQuadraEntrega", Hibernate.INTEGER)
					.addScalar("valorRateioAgua",Hibernate.BIG_DECIMAL)
					.addScalar("valorRateioEsgoto",Hibernate.BIG_DECIMAL)
					.setDate("data",Util.criarData(16, 05, 2007))
					.setInteger("indicadorNomeConta", ConstantesSistema.SIM)
					.setInteger("referencia", anoMesReferencia)
					.setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo)
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection pesquisarContasEmitirOrgaoPublicoCAERN(
			Integer idTipoConta, Integer idEmpresa, Integer numeroPaginas,
			Integer anoMesReferencia, Integer idFaturamentoGrupo,BigDecimal valorContaFichaComp)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel "// 32
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "where "
					+ "contaImpressao.cnti_amreferenciaconta = :referencia AND "
					+ "contaImpressao.empr_id = :idEmpresa AND "
					+ "cliCnt.crtp_id = :idUsuario AND imovel.icte_id = 9 ";
					
					if(valorContaFichaComp != null && !valorContaFichaComp.equals(new BigDecimal("0.00"))){
						consulta = consulta + "AND contaImpressao.cnti_vlconta <= :valorLimite ";
					}
					
					consulta = consulta + "order by  cnt.cnta_amreferenciaconta,contaImpressao.clie_idresponsavel, loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota, imovel.imov_nnsequencialrota";
					
					
					
					if(valorContaFichaComp != null && !valorContaFichaComp.equals(new BigDecimal("0.00"))){
						retorno = session.createSQLQuery(consulta).addScalar("idConta",
								Hibernate.INTEGER).addScalar("nomeCliente",
								Hibernate.STRING).addScalar("dataVencimentoConta",
								Hibernate.DATE)
								.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
										"digitoVerificador", Hibernate.SHORT).addScalar(
										"codigoSetorComercial", Hibernate.INTEGER)
								.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
										"lote", Hibernate.SHORT).addScalar("sublote",
										Hibernate.SHORT).addScalar("consumoAgua",
										Hibernate.INTEGER).addScalar("consumoEsgoto",
										Hibernate.INTEGER).addScalar("valorAgua",
										Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
										Hibernate.BIG_DECIMAL).addScalar("debitos",
										Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
										Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
										Hibernate.BIG_DECIMAL).addScalar("dataValidade",
										Hibernate.DATE).addScalar("idImovel",
										Hibernate.INTEGER).addScalar("idLocalidade",
										Hibernate.INTEGER).addScalar("idGerenciaRegional",
										Hibernate.INTEGER).addScalar("nomeGerencia",
										Hibernate.STRING).addScalar(
										"idLigacaoAguaSituacao", Hibernate.INTEGER)
								.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
								.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
										"idSetorComercial", Hibernate.INTEGER).addScalar(
										"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
										"idEmpresa", Hibernate.INTEGER).addScalar(
										"descricaoLocalidade", Hibernate.STRING).addScalar(
										"descricaoLigAguaSit", Hibernate.STRING).addScalar(
										"descricaoLigEsgotoSit", Hibernate.STRING)
								.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
								.addScalar("idClienteResponsavel", Hibernate.INTEGER)
								.addScalar("nomeImovel", Hibernate.STRING).setInteger(
										"idEmpresa", idEmpresa).setInteger("idUsuario",
										ClienteRelacaoTipo.USUARIO).setInteger(
										"referencia", anoMesReferencia)
											.setBigDecimal("valorLimite",valorContaFichaComp)
										.setMaxResults(1000)
								.setFirstResult(numeroPaginas).list();
					}else{
						retorno = session.createSQLQuery(consulta).addScalar("idConta",
								Hibernate.INTEGER).addScalar("nomeCliente",
								Hibernate.STRING).addScalar("dataVencimentoConta",
								Hibernate.DATE)
								.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
										"digitoVerificador", Hibernate.SHORT).addScalar(
										"codigoSetorComercial", Hibernate.INTEGER)
								.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
										"lote", Hibernate.SHORT).addScalar("sublote",
										Hibernate.SHORT).addScalar("consumoAgua",
										Hibernate.INTEGER).addScalar("consumoEsgoto",
										Hibernate.INTEGER).addScalar("valorAgua",
										Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
										Hibernate.BIG_DECIMAL).addScalar("debitos",
										Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
										Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
										Hibernate.BIG_DECIMAL).addScalar("dataValidade",
										Hibernate.DATE).addScalar("idImovel",
										Hibernate.INTEGER).addScalar("idLocalidade",
										Hibernate.INTEGER).addScalar("idGerenciaRegional",
										Hibernate.INTEGER).addScalar("nomeGerencia",
										Hibernate.STRING).addScalar(
										"idLigacaoAguaSituacao", Hibernate.INTEGER)
								.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
								.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
										"idSetorComercial", Hibernate.INTEGER).addScalar(
										"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
										"idEmpresa", Hibernate.INTEGER).addScalar(
										"descricaoLocalidade", Hibernate.STRING).addScalar(
										"descricaoLigAguaSit", Hibernate.STRING).addScalar(
										"descricaoLigEsgotoSit", Hibernate.STRING)
								.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
								.addScalar("idClienteResponsavel", Hibernate.INTEGER)
								.addScalar("nomeImovel", Hibernate.STRING).setInteger(
										"idEmpresa", idEmpresa).setInteger("idUsuario",
										ClienteRelacaoTipo.USUARIO).setInteger(
										"referencia", anoMesReferencia)
										.setMaxResults(1000)
								.setFirstResult(numeroPaginas).list();
					}

			

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualiza os Clientes Responsáveis para de Conta Impressao Alteracao feita
	 * para a ordenacao das contas de clientes orgaos publicos Por Tiago Moreno -
	 * 25/08/2007 - Alterado: 17/10/2007 OBS: Nao estou usando o HQL e sim o
	 * próprio UPDATE do SQL.
	 * 
	 */

	public void atualizaClienteResponsavelOrgaoPublicoCAERN(
			Integer anoMesReferencia) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			// update
			update = "update faturamento.conta_impressao set "
					+ "clie_idresponsavel = (select cliImo.clie_id "
					+ "from   faturamento.conta conta, "
					+ "cadastro.imovel imov, "
					+ "cadastro.cliente_imovel cliImo "
					+ "where  faturamento.conta_impressao.cnta_id = conta.cnta_id and "
					+ "conta.imov_id = imov.imov_id and "
					+ "imov.icte_id = 9 and "
					+ "imov.imov_id = cliImo.imov_id and "
					+ "cliImo.crtp_id = 3 and "
					+ "cliImo.clim_dtrelacaofim is null) "
					+ "where cnti_amreferenciaconta = ? and "
					+ "cnti_nnsequencialimpressao is null";

			// abre a conexao
			st = jdbcCon.prepareStatement(update);
			// seta o parametro de ano mes
			st.setInt(1, anoMesReferencia.intValue());

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera as contas com debito automático [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasDebitoAutomatico(Collection idsContas)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " new "
					+ EmitirContaHelper.class.getName()
					+ " ( "
					+ "cnt.id, "
					+ "cli.nome, "
					+ "cnt.dataVencimentoConta, "
					+ "cnt.referencia, "
					+ "cnt.digitoVerificadorConta, "
					+ "cnt.codigoSetorComercial, "
					+ "cnt.quadra, "
					+ "cnt.lote, "
					+ "cnt.subLote, "
					+ "cnt.consumoAgua, "
					+ "cnt.consumoEsgoto, "
					+ "cnt.valorAgua, "
					+ "cnt.valorEsgoto, "
					+ "cnt.debitos, "
					+ "cnt.valorCreditos, "
					+ "cnt.valorImposto, "
					+ "cnt.dataValidadeConta, "
					+ "imovel.id, "
					+ "loc.id, "
					+ "gerenciaRegional.id, "
					+ "gerenciaRegional.nome, "
					+ "ligacaoAguaSituacao.id, "
					+ "ligacaoEsgotoSituacao.id, "
					+ "imovelPerfil.id, "
					+ "setorComercial.id, "
					+ "faturamentoGrupo.id, "
					+ "emp.id, "
					+ "loc.descricao, "
					+ "ligacaoAguaSituacao.descricao, "
					+ "ligacaoEsgotoSituacao.descricao, "
					+ "cnt.percentualEsgoto) "
					+ "from ClienteConta cliCnt "
					+ "inner join cliCnt.conta cnt "
					+ "inner join cliCnt.clienteRelacaoTipo crt "
					+ "inner join cliCnt.cliente cli "
					+ "inner join cnt.quadraConta quadraConta "
					+ "inner join cnt.localidade loc "
					+ "inner join loc.gerenciaRegional gerenciaRegional "
					+ "inner join cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "inner join cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "inner join cnt.imovelPerfil imovelPerfil "
					+ "inner join quadraConta.rota rota "
					+ "inner join rota.empresa emp "
					+ "inner join quadraConta.setorComercial setorComercial "
					+ "inner join rota.faturamentoGrupo faturamentoGrupo "
					+ "inner join cnt.imovel imovel "
					+ "where cnt.id in (:idsContas)  AND "
					+ "crt.id = :idUsuario AND "
					+ "cnt.indicadorDebitoConta = :indDebConta "
					+ "order by  cnt.referencia,emp.id,loc.id,cnt.codigoSetorComercial,"
					+ "cnt.quadra,cnt.lote,cnt.subLote";

			retorno = session.createQuery(consulta).setParameterList(
					"idsContas", idsContas).setShort("indDebConta",
					Conta.INDICADOR_DEBITO_CONTA_SIM).setInteger("idUsuario",
					ClienteRelacaoTipo.USUARIO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id do cliente responsável pela conta [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdClienteResponsavelConta(Integer idConta)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cli.id " + "from ClienteConta cliCnt "
					+ "inner join cliCnt.conta cnt "
					+ "inner join cliCnt.clienteRelacaoTipo crt "
					+ "inner join cliCnt.cliente cli "
					+ "where cnt.id = :idConta AND "
					+ "crt.id = :idResponsavel";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idConta", idConta).setInteger("idResponsavel",
					ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com entrega para o cliente responsável [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavel(
			Collection<Integer> idTipoConta, Integer numeroPaginas,
			Integer anoMesReferencia, Integer idFaturamentoGrupo,
			Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado,Integer imovelContaEnvio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega "// 41
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id in (:idTipoConta) AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupo AND "
					+ "contaImpressao.empr_id is null AND ";
			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2 ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"tipoConta", Hibernate.INTEGER).addScalar(
							"rotaEntrega", Hibernate.INTEGER).addScalar(
							"seqRotaEntrega", Hibernate.INTEGER)
					.setParameterList("idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setMaxResults(
							1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com entrega para o cliente responsável [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelCAER(
			Collection<Integer> idTipoConta, Integer numeroPaginas,
			Integer anoMesReferencia, Integer idFaturamentoGrupo,
			Short indicadorEmissaoExtratoFaturamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega, "// 41
					+ "imovel.imov_nnquadraentrega as numeroQuadraEntrega "// 42
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "WHERE contaImpressao.cttp_id in (:idTipoConta) "
					+ "AND contaImpressao.ftgr_id = :idFaturamentoGrupo "
					+ "AND contaImpressao.empr_id is null "
					+ "AND contaImpressao.cnti_amreferenciaconta = :anoMesReferencia"
					+ " AND cliCnt.crtp_id = :idResposavel "
					+ "AND imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"tipoConta", Hibernate.INTEGER).addScalar(
							"rotaEntrega", Hibernate.INTEGER).addScalar(
							"seqRotaEntrega", Hibernate.INTEGER).addScalar(
									"numeroQuadraEntrega", Hibernate.INTEGER)
					.setParameterList("idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setInteger(
							"anoMesReferencia", anoMesReferencia)
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas normais [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasNormais(Collection idsContas)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " new "
					+ EmitirContaHelper.class.getName()
					+ " ( "
					+ "cnt.id, "
					+ "cli.nome, "
					+ "cnt.dataVencimentoConta, "
					+ "cnt.referencia, "
					+ "cnt.digitoVerificadorConta, "
					+ "cnt.codigoSetorComercial, "
					+ "cnt.quadra, "
					+ "cnt.lote, "
					+ "cnt.subLote, "
					+ "cnt.consumoAgua, "
					+ "cnt.consumoEsgoto, "
					+ "cnt.valorAgua, "
					+ "cnt.valorEsgoto, "
					+ "cnt.debitos, "
					+ "cnt.valorCreditos, "
					+ "cnt.valorImposto, "
					+ "cnt.dataValidadeConta, "
					+ "imovel.id, "
					+ "loc.id, "
					+ "gerenciaRegional.id, "
					+ "gerenciaRegional.nome, "
					+ "ligacaoAguaSituacao.id, "
					+ "ligacaoEsgotoSituacao.id, "
					+ "imovelPerfil.id, "
					+ "setorComercial.id, "
					+ "faturamentoGrupo.id, "
					+ "emp.id, "
					+ "loc.descricao, "
					+ "ligacaoAguaSituacao.descricao, "
					+ "ligacaoEsgotoSituacao.descricao, "
					+ "cnt.percentualEsgoto) "
					+ "from ClienteConta cliCnt "
					+ "inner join cliCnt.conta cnt "
					+ "inner join cliCnt.clienteRelacaoTipo crt "
					+ "inner join cliCnt.cliente cli "
					+ "inner join cnt.quadraConta quadraConta "
					+ "inner join cnt.localidade loc "
					+ "inner join loc.gerenciaRegional gerenciaRegional "
					+ "inner join cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "inner join cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "inner join cnt.imovelPerfil imovelPerfil "
					+ "inner join quadraConta.rota rota "
					+ "inner join rota.empresa emp "
					+ "inner join quadraConta.setorComercial setorComercial "
					+ "inner join rota.faturamentoGrupo faturamentoGrupo "
					+ "inner join cnt.imovel imovel "
					+ "where cnt.id in (:idsContas) AND "
					+ "crt.id = :idUsuario "
					+ "order by  cnt.referencia,emp.id,loc.id,cnt.codigoSetorComercial,"
					+ "cnt.quadra,cnt.lote,cnt.subLote";

			retorno = session.createQuery(consulta).setParameterList(
					"idsContas", idsContas).setInteger("idUsuario",
					ClienteRelacaoTipo.USUARIO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o nome do cliente usuário pela conta [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String pesquisarNomeClienteUsuarioConta(Integer idConta)
			throws ErroRepositorioException {
		String retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cli.nome " + "from ClienteConta cliCnt "
					+ "inner join cliCnt.conta cnt "
					+ "inner join cliCnt.clienteRelacaoTipo crt "
					+ "inner join cliCnt.cliente cli "
					+ "where cnt.id = :idConta AND " + "crt.id = :idUsuario";

			retorno = (String) session.createQuery(consulta).setInteger(
					"idConta", idConta).setInteger("idUsuario",
					ClienteRelacaoTipo.USUARIO).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id do cliente responsável pela conta [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 05/12/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsClienteResponsavelConta(Integer idConta)
			throws ErroRepositorioException {
		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cli.id,cli.nome " + "from ClienteConta cliCnt "
					+ "inner join cliCnt.conta cnt "
					+ "inner join cliCnt.clienteRelacaoTipo crt "
					+ "inner join cliCnt.cliente cli "
					+ "where cnt.id = :idConta AND "
					+ "crt.id = :idResponsavel";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", idConta).setInteger("idResponsavel",
					ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna a soma de quantidade economia
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0007] Obter Quantidade de Economias da Conta
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Short obterQuantidadeEconomiasConta(Integer idConta)
			throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(contaCategoria.quantidadeEconomia) "
					+ "from ContaCategoria contaCategoria "
					+ "left join contaCategoria.comp_id.conta conta "
					+ "where conta.id = :idConta";

			retorno = (Short) session.createQuery(consulta).setInteger(
					"idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<IContaCategoria> pesquisarContaCategoria(Integer idConta)
			throws ErroRepositorioException {

		Collection<IContaCategoria> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaCategoria "
					+ "from ContaCategoria contaCategoria "
					+ "inner join contaCategoria.comp_id.conta conta "
					+ "inner join fetch contaCategoria.comp_id.categoria categoria "
					+ "inner join fetch contaCategoria.comp_id.subcategoria subcategoria "
					+ "where conta.id = :idConta ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).setInteger("idConta", idConta)
					.list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaFaixas(Integer idConta,
			Integer idCategoria) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaCategoriaConsumoFaixa "
					+ "from ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa "
					+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.conta conta "
					+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.categoria categoria "
					+ "where conta.id = :idConta AND "
					+ "categoria.id = :idCategoria "
					+ "order by contaCategoriaConsumoFaixa.consumoFaixaInicio";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("idCategoria",
					idCategoria.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna o tipo de cálculo da conta
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Rafael Corrêa
	 * @date 21/09/2009
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarTipoCalculoConta(Integer idConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select tipoCalculo.id " + "from Conta conta "
					+ "inner join conta.consumoTarifa consumoTarifa "
					+ "inner join consumoTarifa.tarifaTipoCalculo tipoCalculo "
					+ "where conta.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idConta", idConta.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna o tipo de cálculo da conta no histórico
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Rafael Corrêa
	 * @date 21/09/2009
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarTipoCalculoContaHistorico(Integer idConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select tipoCalculo.id " + "from ContaHistorico conta "
					+ "inner join conta.consumoTarifa consumoTarifa "
					+ "inner join consumoTarifa.tarifaTipoCalculo tipoCalculo "
					+ "where conta.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idConta", idConta.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object com a soma do valor dos debitos
	 * cobrados de parcelamento,o numero da prestacao e o numero total de
	 * prestações
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParmsDebitoAutomatico(Integer idConta)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobrado.valorPrestacao),debCobrado.numeroPrestacaoDebito,"
					+ "debCobrado.numeroPrestacao,debCobrado.numeroParcelaBonus "
					+ "from DebitoCobrado debCobrado "
					+ "inner join debCobrado.financiamentoTipo finTipo "
					+ "inner join debCobrado.conta conta "
					+ "where conta.id = :idConta AND "
					+ "(finTipo.id = :parcelamentoAgua OR finTipo.id = :parcelamentoEsgoto OR "
					+ "finTipo.id = :parcelamentoServicos) "
					+ "group by debCobrado.numeroPrestacaoDebito,debCobrado.numeroPrestacao,debCobrado.numeroParcelaBonus ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("parcelamentoAgua",
					FinanciamentoTipo.PARCELAMENTO_AGUA)
					.setInteger("parcelamentoEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
							"parcelamentoServicos",
							FinanciamentoTipo.PARCELAMENTO_SERVICO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * 
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 19/05/2006, 16/01/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsDebitoCobradoPorTipo(Integer idConta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobrado.valorPrestacao), "// 0
					+ "debCobrado.numeroPrestacaoDebito," // 1
					+ "debCobrado.numeroPrestacao, "// 2
					+ "debCobrado.anoMesReferenciaDebito, "// 3
					+ "debitoTipo.id, "// 4
					+ "debCobrado.debitoTipo.descricao, "// 5
					+ "debCobrado.numeroParcelaBonus " // 6
					+ "from DebitoCobrado debCobrado "
					+ "inner join debCobrado.financiamentoTipo finTipo "
					+ "inner join debCobrado.debitoTipo debitoTipo "
					+ "inner join debCobrado.conta conta "
					+ "where conta.id = :idConta AND "
					+ "( finTipo.id <> :parcelamentoAgua"
					+ " and finTipo.id <> :parcelamentoEsgoto"
					+ " and finTipo.id <> :parcelamentoServicos )"
					+ "group by "
					+ "debitoTipo.id, "
					+ "debCobrado.numeroPrestacaoDebito,"
					+ "debCobrado.numeroPrestacao, "
					+ "debCobrado.anoMesReferenciaDebito, "
					+ "debCobrado.debitoTipo.descricao, "
					+ "debCobrado.numeroParcelaBonus "
					+ "order by debitoTipo.id,debCobrado.anoMesReferenciaDebito desc";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("parcelamentoAgua",
					FinanciamentoTipo.PARCELAMENTO_AGUA)
					.setInteger("parcelamentoEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
							"parcelamentoServicos",
							FinanciamentoTipo.PARCELAMENTO_SERVICO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Rafael Corrêa
	 * @date 06/09/2009
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarDebitoCobradoConta(Integer idConta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobrado.valorPrestacao), "// 0
					+ "debCobrado.numeroPrestacaoDebito," // 1
					+ "debCobrado.numeroPrestacao, "// 2
					+ "debCobrado.anoMesReferenciaDebito, "// 3
					+ "debitoTipo.id, "// 4
					+ "debCobrado.debitoTipo.descricao, "// 5
					+ "debCobrado.numeroParcelaBonus, " // 6
					+ "debCobrado.anoMesCobrancaDebito "// 7
					+ "from DebitoCobrado debCobrado "
					+ "inner join debCobrado.financiamentoTipo finTipo "
					+ "inner join debCobrado.debitoTipo debitoTipo "
					+ "inner join debCobrado.conta conta "
					+ "where conta.id = :idConta "
					+ "group by "
					+ "debitoTipo.id, "
					+ "debCobrado.numeroPrestacaoDebito,"
					+ "debCobrado.numeroPrestacao, "
					+ "debCobrado.anoMesReferenciaDebito, "
					+ "debCobrado.debitoTipo.descricao, "
					+ "debCobrado.numeroParcelaBonus, "
					+ "debCobrado.anoMesCobrancaDebito "
					+ "order by debitoTipo.id,debCobrado.anoMesReferenciaDebito desc";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do crédito realizado ordenado pelo
	 * tipo de crédito
	 * 
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0014] Gerar Linhas dos Creditos Realizados
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsCreditoRealizadoPorTipo(Integer idConta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select credRealizado.valorCredito,"// 0
					+ "credRealizado.numeroPrestacaoCredito," // 1
					+ "credRealizado.numeroPrestacao, "// 2
					+ "credRealizado.anoMesReferenciaCredito, "// 3
					+ "creditoTipo.id, "// 4
					+ "creditoTipo.descricao, "// 5
					+ "credRealizado.numeroParcelaBonus "// 6
					+ "from CreditoRealizado credRealizado "
					+ "inner join credRealizado.creditoTipo creditoTipo "
					+ "inner join credRealizado.conta conta "
					+ "where conta.id = :idConta "
					+ "order by creditoTipo.id,credRealizado.anoMesReferenciaCredito desc";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do conta mensagem ordenado pelo
	 * tipo de crédito
	 * 
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0016] Obter Mensagem da Conta em 3 Partes
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsContaMensagem(
			EmitirContaHelper emitirContaHelper, Integer idFaturamentoGrupo,
			Integer idGerenciaRegional, Integer idLocalidade,
			Integer idSetorComercial) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaMensagem.descricaoContaMensagem01,"// 0
					+ "contaMensagem.descricaoContaMensagem02," // 1
					+ "contaMensagem.descricaoContaMensagem03 "// 2
					+ "from ContaMensagem contaMensagem "
					+ "left join contaMensagem.gerenciaRegional gerenciaRegional "
					+ "left join contaMensagem.localidade localidade "
					+ "left join contaMensagem.setorComercial setorComercial "
					+ "left join contaMensagem.faturamentoGrupo faturamentoGrupo "
					+ "where contaMensagem.anoMesRreferenciaFaturamento = :amReferenciaConta ";
			if (idFaturamentoGrupo != null) {
				consulta += " AND faturamentoGrupo.id =" + idFaturamentoGrupo;
			} else {
				consulta += " AND faturamentoGrupo.id is null";
			}
			if (idGerenciaRegional != null) {
				consulta += " AND gerenciaRegional.id =" + idGerenciaRegional;
			} else {
				consulta += " AND gerenciaRegional.id is null";
			}
			if (idLocalidade != null) {
				consulta += " AND localidade.id =" + idLocalidade;
			} else {
				consulta += " AND localidade.id is null";
			}
			if (idSetorComercial != null) {
				consulta += " AND setorComercial.id =" + idSetorComercial;
			} else {
				consulta += " AND setorComercial.id is null";
			}

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"amReferenciaConta", emitirContaHelper.getAmReferencia())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object de qualidade de agua
	 * 
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 25/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsQualidadeAgua(
			EmitirContaHelper emitirContaHelper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Integer anoMesFaturamentoSubtraido = Util.subtrairMesDoAnoMes(
				emitirContaHelper.getAmReferencia(), 1);

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select qualidadeAgua.numeroIndiceTurbidez, "// 0
					+ "qualidadeAgua.numeroCloroResidual, " // 1
					// informações para 2 via de conta para caern
					+ " qualidadeAgua.numeroNitrato, " // 2
					+ " qualidadeAgua.numeroIndiceColiformesTotais, " // 3
					+ " qualidadeAgua.numeroIndicePh " // 4
					+ "from QualidadeAgua qualidadeAgua "
					+ "inner join qualidadeAgua.localidade localidade "
					+ "inner join qualidadeAgua.setorComercial setorComercial "
					+ "where localidade.id = :idLocalidade AND "
					+ "setorComercial.id = :idSetorComercial AND "
					+ "qualidadeAgua.anoMesReferencia = :anoMesReferencia ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesFaturamentoSubtraido).setInteger(
					"idLocalidade", emitirContaHelper.getIdLocalidade()).setInteger(
					"idSetorComercial", emitirContaHelper.getIdSetorComercial())
					.setMaxResults(1).uniqueResult();
			
			if ( retorno == null || retorno.length <= 0 ) {
				
				consulta = "select qualidadeAgua.numeroIndiceTurbidez, "// 0
					+ "qualidadeAgua.numeroCloroResidual, " // 1
					// informações para 2 via de conta para caern
					+ " qualidadeAgua.numeroNitrato, " // 2
					+ " qualidadeAgua.numeroIndiceColiformesTotais, " // 3
					+ " qualidadeAgua.numeroIndicePh " // 4
					+ "from QualidadeAgua qualidadeAgua "
					+ "inner join qualidadeAgua.localidade localidade "
					
					+ "where localidade.id = :idLocalidade AND "
					+ "qualidadeAgua.setorComercial is null AND "
					+ "qualidadeAgua.anoMesReferencia = :anoMesReferencia ";

				retorno = (Object[]) session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesFaturamentoSubtraido).setInteger(
						"idLocalidade", emitirContaHelper.getIdLocalidade())
						.setMaxResults(1).uniqueResult();
			
			} 
			
			if ( retorno == null || retorno.length <= 0 ) {
				
				consulta = "select qualidadeAgua.numeroIndiceTurbidez, "// 0
					+ "qualidadeAgua.numeroCloroResidual, " // 1
					// informações para 2 via de conta para caern
					+ " qualidadeAgua.numeroNitrato, " // 2
					+ " qualidadeAgua.numeroIndiceColiformesTotais, " // 3
					+ " qualidadeAgua.numeroIndicePh " // 4
					+ "from QualidadeAgua qualidadeAgua "
					+ "where qualidadeAgua.localidade is null AND "
					+ "qualidadeAgua.setorComercial is null AND "
					+ "qualidadeAgua.anoMesReferencia = :anoMesReferencia ";

				retorno = (Object[]) session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesFaturamentoSubtraido)
						.setMaxResults(1).uniqueResult();
			
			} 

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do conta impostos deduzidos
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0015] Gerar Linhas dos Impostos Deduzidos
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParmsContaImpostosDeduzidos(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select impostoTipo.descricaoAbreviada,"// 0
					+ "contaImpostosDeduzidos.percentualAliquota," // 1
					+ "contaImpostosDeduzidos.valorImposto, " // 2
					+ "impostoTipo.id " // 3
					+ "from ContaImpostosDeduzidos contaImpostosDeduzidos "
					+ "inner join contaImpostosDeduzidos.conta conta "
					+ "inner join contaImpostosDeduzidos.impostoTipo impostoTipo "
					+ "where conta.id = :idConta";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa todas as contas para testar o batch
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 02/06/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsTodasConta() throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select conta.id " + "from Conta conta "
					+ "order by conta.id";

			retorno = session.createQuery(consulta).setMaxResults(115).list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Gerar Relacao Acompanhamento Faturamento
	 * 
	 * [UC0336] GerarRelacaoAcompanhamentoFaturamento
	 * 
	 * @author Fernanda Paiva
	 * @date 15/06/2006
	 * 
	 */
	public Collection gerarRelacaoAcompanhamentoFaturamento(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct "
					+ "gerenciaRegional.id,"
					+ "gerenciaRegional.nomeAbreviado,"
					+ "localidade.id,"
					+ "localidade.descricao,"
					+ "imovel.id,"
					+ "imovel.quantidadeEconomias,"
					+ "setorComercial.codigo,"
					+ "quadra.numeroQuadra,"
					+ "imovel.lote,"
					+ "imovel.subLote,"
					+ "ligacaoAguaSituacao.descricaoAbreviado,"
					+ "ligacaoEsgotoSituacao.descricaoAbreviado,"
					+ "ligacaoEsgoto.percentual,"
					+ "ligacaoAgua.dataCorte, "
					+ "gerenciaRegional.nome, "
					+ "ligacaoEsgoto.consumoMinimo, "
					+ "clienteUsuario.nome "
					+ // "consumosHistorico.consumoMedio "

					" from ImovelSubcategoria imovelSubcategoria "
					+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
					+ " left  join  imovelSubcategoria.comp_id.subcategoria subcategoria "
					+ " left join subcategoria.categoria categoria   "
					+ " inner join imovel.localidade localidade   "
					+ " inner join localidade.gerenciaRegional gerenciaRegional "
					+ " inner join imovel.setorComercial setorComercial   "
					+ " left  join imovel.logradouroBairro logradouroBairro  "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " left  join bairro.municipio municipio   "
					+ " left  join imovel.logradouroBairro logradouroBairro "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " inner join imovel.quadra quadra   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.cep cep   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.logradouro logradouro   "
					+ " left  join imovel.imovelCondominio imovelCondominio   "
					+ " left  join imovel.imovelPrincipal imovelPrincipal   "
					// + " left join imovel.nomeConta nomeConta "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua  "
					+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  "
					+ " left  join imovel.imovelPerfil imovelPerfil  "
					+ " left  join imovel.pocoTipo pocoTipo   "
					+ " left  join imovel.faturamentoTipo faturamentoTipo "
					+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
					+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ " left  join imovel.eloAnormalidade eloAnormalidade   "
					+ " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
					+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  "
					+ " left  join imovel.consumoTarifa consumoTarifa   "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left join imovel.consumosHistoricos consumosHistorico   "
					+ " left join imovel.medicaoHistoricos medicaoHistorico   "
					+ " left join imovel.clienteImoveis clienteImoveis "
					+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo "
					+ " left join clienteImoveis.cliente cliente "
					+ " left join cliente.clienteTipo clienteTipo "
					+ " left join imovel.consumosHistoricos consumosHistorico "
					+ " left outer join imovel.clienteImoveis clienteImoveisUsuario with (clienteImoveisUsuario.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ ") and clienteImoveisUsuario.dataFimRelacao is null "
					+ " left outer join clienteImoveisUsuario.cliente clienteUsuario ";

			consulta = consulta
					+ montarCondicaoWhereFiltrarImovelOutrosCriterio(
							idImovelCondominio, idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
							consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto,
							consumoMinimoFinalEsgoto,
							intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal,
							intervaloMediaMinimaImovelInicial,
							intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal,
							idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
							idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal,
							idCadastroOcorrencia, idConsumoTarifa,
							idGerenciaRegional, idLocalidadeInicial,
							idLocalidadeFinal, setorComercialInicial,
							setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro,
							municipio, idTipoMedicao, indicadorMedicao,
							idSubCategoria, idCategoria,
							quantidadeEconomiasInicial,
							quantidadeEconomiasFinal, diaVencimento, idCliente,
							idClienteTipo, idClienteRelacaoTipo,
							numeroPontosInicial, numeroPontosFinal,
							numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa);

			/*
			 * # COLOCANDO O VALOR NAS CONDIÇÕES#
			 */

			/*
			 * consulta = consulta + " consumosHistorico.referenciaFaturamento = " +
			 * "(select max(consumoHistorico.referenciaFaturamento) from
			 * ConsumoHistorico consumoHistorico " + " left join
			 * consumoHistorico.imovel imovelConsumoHistorico " + "where
			 * imovelConsumoHistorico.id = imovel.id) and ";
			 */

			Query query = session.createQuery(consulta.substring(0, (consulta
					.length() - 5)));

			informarDadosQueryFiltrarImovelOutrosCriterio(query,
					idImovelCondominio, idImovelPrincipal, idNomeConta,
					idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
					consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
					consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
					intervaloValorPercentualEsgotoInicial,
					intervaloValorPercentualEsgotoFinal,
					intervaloMediaMinimaImovelInicial,
					intervaloMediaMinimaImovelFinal,
					intervaloMediaMinimaHidrometroInicial,
					intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
					idPocoTipo, idFaturamentoSituacaoTipo,
					idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
					idEloAnormalidade, areaConstruidaInicial,
					areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa,
					idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal,
					setorComercialInicial, setorComercialFinal, quadraInicial,
					quadraFinal, loteOrigem, loteDestno, cep, logradouro,
					bairro, municipio, idTipoMedicao, indicadorMedicao,
					idSubCategoria, idCategoria, quantidadeEconomiasInicial,
					quantidadeEconomiasFinal, diaVencimento, idCliente,
					idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial,
					numeroPontosFinal, numeroMoradoresInicial,
					numeroMoradoresFinal, idAreaConstruidaFaixa);

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public String montarCondicaoWhereFiltrarImovelOutrosCriterio(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa) {

		String consulta = "";
		/*
		 * ## CONDIÇÕES ##
		 */
		consulta = consulta + " where ";

		// cliente
		if (idCliente != null
				&& !idCliente.equals("")
				&& !idCliente.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " cliente.id = :idCliente  and  ";
		}

		// cliente tipo
		if (idClienteTipo != null
				&& !idClienteTipo.equals("")
				&& !idClienteTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " clienteTipo.id = :idClienteTipo  and  ";
		}

		// cliente relacao tipo
		if (idClienteRelacaoTipo != null
				&& !idClienteRelacaoTipo.equals("")
				&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " clienteRelacaoTipo.id = :idClienteRelacaoTipo  and  ";
		}

		// gerencia regional
		if (idGerenciaRegional != null
				&& !idGerenciaRegional.equals("")
				&& !idGerenciaRegional.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " gerenciaRegional.id = :idGerenciaRegional and ";
		}
		// localidade inicial e final
		if (((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (idLocalidadeFinal != null
				&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())))) {
			consulta = consulta
					+ " localidade.id >= :idLocalidadeInicial and localidade.id <= :idLocalidadeFinal  and  ";
		}
		// setor comercial inicial e final
		if (((setorComercialInicial != null
				&& !setorComercialInicial.equals("") && !setorComercialInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (setorComercialFinal != null
				&& !setorComercialFinal.equals("") && !setorComercialFinal
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())))) {
			consulta = consulta
					+ " setorComercial.codigo >= :setorComercialInicial and setorComercial.codigo <= :setorComercialFinal  and  ";
		}
		// quadra
		if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " quadra.numeroQuadra >= :quadraInicial and quadra.numeroQuadra <= :quadraFinal and  ";
		}
		// lote
		if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (loteDestno != null && !loteDestno.equals("") && !loteDestno
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " imovel.lote >= :loteOrigem  and  imovel.lote <= :loteDestino";
		}

		// cep
		if (cep != null
				&& !cep.equals("")
				&& !cep.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " cep.codigo = :cep  and  ";
		}
		// logradouro
		if (logradouro != null
				&& !logradouro.equals("")
				&& !logradouro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " logradouro.id = :logradouro  and  ";
		}
		// bairro
		if (bairro != null
				&& !bairro.equals("")
				&& !bairro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " bairro.codigo = :bairro  and  ";
		}
		// municipio
		if (municipio != null
				&& !municipio.equals("")
				&& !municipio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " municipio.id = :municipio  and  ";
		}
		// consumo minimo agua inicial e final
		if ((consumoMinimoInicialAgua != null
				&& !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalAgua != null
						&& !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ "ligacaoAgua.numeroConsumoMinimoAgua >= :consumoMinimoInicialAgua and ligacaoAgua.numeroConsumoMinimoAgua <= :consumoMinimoFinalAgua  and  ";
		}
		// consumo minimo esgoto inicial e final
		if ((consumoMinimoInicialEsgoto != null
				&& !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalEsgoto != null
						&& !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ "ligacaoEsgoto.consumoMinimo >= :consumoMinimoInicialEsgoto and ligacaoEsgoto.consumoMinimo <= :consumoMinimoFinalEsgoto  and  ";
		}

		// percentual esgoto inicial e final
		if ((intervaloValorPercentualEsgotoInicial != null
				&& !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloValorPercentualEsgotoFinal != null
						&& !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {

			consulta = consulta
					+ "ligacaoEsgoto.percentual >= :intervaloValorPercentualEsgotoInicial and ligacaoEsgoto.percentual <= :intervaloValorPercentualEsgotoFinal  and  ";
		}
		// indicador medição
		if (indicadorMedicao != null && indicadorMedicao.equals("comMedicao")) {
			// tipo medicao
			if (idTipoMedicao != null
					&& idTipoMedicao
							.equals(MedicaoTipo.LIGACAO_AGUA.toString())) {
				consulta = consulta
						+ "hidrometroInstalacaoHistorico.id is not null  and  ";
			} else if (idTipoMedicao != null
					&& idTipoMedicao.equals(MedicaoTipo.POCO.toString())) {
				consulta = consulta
						+ "hidrometroInstalacaoHistoricoImovel.id is not null and  ";
			} else {
				consulta = consulta
						+ "(hidrometroInstalacaoHistorico.id is not null or ";
				consulta = consulta
						+ "hidrometroInstalacaoHistoricoImovel.id is not null) and  ";
			}
		} else if (indicadorMedicao != null
				&& indicadorMedicao.equals("semMedicao")) {
			consulta = consulta
					+ "(hidrometroInstalacaoHistorico.id is null and";
			consulta = consulta
					+ "hidrometroInstalacaoHistoricoImovel.id is null) and  ";
		}
		// imovel condominio
		if (idImovelCondominio != null
				&& !idImovelCondominio.equals("")
				&& !idImovelCondominio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " imovelCondominio.id = :idImovelCondominio ";
		}
		// imovel principal
		if (idImovelPrincipal != null
				&& !idImovelPrincipal.equals("")
				&& !idImovelPrincipal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " imovelPrincipal.id: = idImovelPrincipal ";
		}
		// nome conta
		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// consulta = consulta + " nomeConta.id = :idNomeConta and ";
		// }
		// situação da ligação de agua
		if (idSituacaoLigacaoAgua != null
				&& !idSituacaoLigacaoAgua.equals("")
				&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " ligacaoAguaSituacao.id = :idSituacaoLigacaoAgua  and  ";
		}
		// situação ligação de esgoto
		if (idSituacaoLigacaoEsgoto != null
				&& !idSituacaoLigacaoEsgoto.equals("")
				&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " ligacaoEsgotoSituacao.id = :idSituacaoLigacaoEsgoto  and  ";
		}
		// imovel Perfil
		if (idImovelPerfil != null
				&& !idImovelPerfil.equals("")
				&& !idImovelPerfil.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " imovelPerfil.id = :idImovelPerfil  and  ";
		}
		// poço tipo
		if (idPocoTipo != null
				&& !idPocoTipo.equals("")
				&& !idPocoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " pocoTipo.id = :idPocoTipo  and  ";
		}
		// faturamento situacao tipo
		if (idFaturamentoSituacaoTipo != null
				&& !idFaturamentoSituacaoTipo.equals("")
				&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " faturamentoTipo.id = :idFaturamentoSituacaoTipo  and  ";
		}
		// cobranca situacao tipo
		if (idCobrancaSituacaoTipo != null
				&& !idCobrancaSituacaoTipo.equals("")
				&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " cobrancaSituacaoTipo.id = :idCobrancaSituacaoTipo  and  ";
		}
		// Situacao Especial Cobranca
		if (idSituacaoEspecialCobranca != null
				&& !idSituacaoEspecialCobranca.equals("")
				&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " faturamentoSituacaoTipo.id = :idSituacaoEspecialCobranca ";
		}

		// elo anormalidade
		if (idEloAnormalidade != null
				&& !idEloAnormalidade.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ "eloAnormalidade.id = :idEloAnormalidade  and  ";
		}
		// cadastro ocorrencia
		if (idCadastroOcorrencia != null
				&& !idCadastroOcorrencia.equals("")
				&& !idCadastroOcorrencia.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " cadastroOcorrencia.id = :idCadastroOcorrencia  and  ";
		}
		// area construida inicial e final
		if ((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (areaConstruidaFinal != null
						&& !areaConstruidaFinal.equals("") && !areaConstruidaFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " imovel.areaConstruida >= :areaConstruidaInicial and imovel.areaConstruida <= :areaConstruidaFinal  and  ";
		}
		// consumo tarifa
		if (idConsumoTarifa != null
				&& !idConsumoTarifa.equals("")
				&& !idConsumoTarifa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " consumoTarifa.id = :idConsumoTarifa   and  ";
		}
		// intervalo Media Minima Imovel Inicial e Final
		if ((intervaloMediaMinimaImovelInicial != null
				&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaImovelFinal != null
						&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " consumosHistorico.consumoMedio >= :intervaloMediaMinimaImovelInicial and consumosHistorico.consumoMedio <= :intervaloMediaMinimaImovelFinal  and  ";
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if ((intervaloMediaMinimaHidrometroInicial != null
				&& !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaHidrometroFinal != null
						&& !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " medicaoHistorico.consumoMedioHidrometro >= :intervaloMediaMinimaHidrometroInicial and medicaoHistorico.consumoMedioHidrometro <= :intervaloMediaMinimaHidrometroFinal  and  ";
		}
		// categoria
		if (idCategoria != null
				&& !idCategoria.equals("")
				&& !idCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " categoria.id = :idCategoria  and  ";
		}
		// sub categoria
		if (idSubCategoria != null
				&& !idSubCategoria.equals("")
				&& !idSubCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " subCategoria.id = :idSubCategoria  and  ";
		}
		// quantidade economias inicial e final
		if ((quantidadeEconomiasInicial != null
				&& !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quantidadeEconomiasFinal != null
						&& !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ "imovelSubcategoria.quantidadeEconomias >= :quantidadeEconomiasInicial and imovelSubcategoria.quantidadeEconomias <= :quantidadeEconomiasFinal  and  ";
		}

		// dia Vencimento
		if (diaVencimento != null
				&& !diaVencimento.equals("")
				&& !diaVencimento.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			if (diaVencimento.equals("1")) {// sim
				consulta = consulta + " imovel.diaVencimento  is not null ";
			}
		}

		// numero prontos inicial e final
		if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " imove.numeroPontosUtilizacao >= :numeroPontosInicial and imovel.numeroPontosUtilizacao <= :numeroPontosFinal and ";
		}

		// numero moradores inicial e final
		if ((numeroMoradoresInicial != null
				&& !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroMoradoresFinal != null
						&& !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " imovel.numeroMorador >= :numeroMoradoresInicial and imovel.numeroMorador <= :numeroMoradoresFinal and ";
		}
		// area construida faixa
		if (idAreaConstruidaFaixa != null
				&& !idAreaConstruidaFaixa.equals("")
				&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " areaConstruidaFaixa.id = :idAreaConstruidaFaixa and ";
		}

		return consulta;
	}

	public void informarDadosQueryFiltrarImovelOutrosCriterio(Query query,
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa) {

		// gerencia regional
		if (idGerenciaRegional != null
				&& !idGerenciaRegional.equals("")
				&& !idGerenciaRegional.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idGerenciaRegional", new Integer(
					idGerenciaRegional).intValue());
		}
		// localidade inicial e final
		if (((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (idLocalidadeFinal != null
				&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())))) {
			query.setInteger("idLocalidadeInicial", new Integer(
					idLocalidadeInicial).intValue());
			query.setInteger("idLocalidadeFinal",
					new Integer(idLocalidadeFinal).intValue());
		}
		// setor comercial inicial e final
		if (((setorComercialInicial != null
				&& !setorComercialInicial.equals("") && !setorComercialInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (setorComercialFinal != null
				&& !setorComercialFinal.equals("") && !setorComercialFinal
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())))) {
			query.setInteger("setorComercialInicial", new Integer(
					setorComercialInicial).intValue());
			query.setInteger("setorComercialFinal", new Integer(
					setorComercialFinal).intValue());
		}
		// quadra inicial e final
		if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("quadraInicial", new Integer(quadraInicial)
					.intValue());
			query
					.setInteger("quadraFinal", new Integer(quadraFinal)
							.intValue());
		}
		// lote
		if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (loteDestno != null && !loteDestno.equals("") && !loteDestno
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("loteOrigem", new Integer(loteOrigem).intValue());
			query.setInteger("loteDestino", new Integer(loteDestno).intValue());
		}
		// cep
		if (cep != null
				&& !cep.equals("")
				&& !cep.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("cep", new Integer(cep).intValue());
		}
		// logradouro
		if (logradouro != null
				&& !logradouro.equals("")
				&& !logradouro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("logradouro", new Integer(logradouro).intValue());
		}
		// bairro
		if (bairro != null
				&& !bairro.equals("")
				&& !bairro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("bairro", new Integer(bairro).intValue());
		}
		// municipio
		if (municipio != null
				&& !municipio.equals("")
				&& !municipio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("municipio", new Integer(municipio).intValue());
		}
		// consumo minimo agua inicial e final
		if ((consumoMinimoInicialAgua != null
				&& !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalAgua != null
						&& !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("consumoMinimoInicialAgua", new Integer(
					consumoMinimoInicialAgua).intValue());
			query.setInteger("consumoMinimoFinalAgua", new Integer(
					consumoMinimoFinalAgua).intValue());
		}
		// consumo minimo esgoto inicial e final
		if ((consumoMinimoInicialEsgoto != null
				&& !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalEsgoto != null
						&& !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("consumoMinimoInicialEsgoto", new Integer(
					consumoMinimoInicialEsgoto).intValue());
			query.setInteger("consumoMinimoFinalEsgoto", new Integer(
					consumoMinimoFinalEsgoto).intValue());
		}
		// percentual esgoto inicial e final
		if ((intervaloValorPercentualEsgotoInicial != null
				&& !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloValorPercentualEsgotoFinal != null
						&& !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloValorPercentualEsgotoInicial",
					new BigDecimal(intervaloValorPercentualEsgotoInicial)
							.intValue());
			query.setInteger("intervaloValorPercentualEsgotoFinal",
					new BigDecimal(intervaloValorPercentualEsgotoFinal)
							.intValue());
		}
		// imovel condominio
		if (idImovelCondominio != null
				&& !idImovelCondominio.equals("")
				&& !idImovelCondominio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelCondominio", new Integer(
					idImovelCondominio).intValue());
		}
		// imovel principal
		if (idImovelPrincipal != null
				&& !idImovelPrincipal.equals("")
				&& !idImovelPrincipal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelPrincipal",
					new Integer(idImovelPrincipal).intValue());
		}

		// nome conta
		if (idNomeConta != null
				&& !idNomeConta.equals("")
				&& !idNomeConta.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query
					.setInteger("idNomeConta", new Integer(idNomeConta)
							.intValue());
		}
		// Situacao Ligacao Agua
		if (idSituacaoLigacaoAgua != null
				&& !idSituacaoLigacaoAgua.equals("")
				&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoLigacaoAgua", new Integer(
					idSituacaoLigacaoAgua).intValue());
		}

		// situação ligação de esgoto
		if (idSituacaoLigacaoEsgoto != null
				&& !idSituacaoLigacaoEsgoto.equals("")
				&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoLigacaoEsgoto", new Integer(
					idSituacaoLigacaoEsgoto).intValue());
		}
		// imovel Perfil
		if (idImovelPerfil != null
				&& !idImovelPerfil.equals("")
				&& !idImovelPerfil.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelPerfil", new Integer(idImovelPerfil)
					.intValue());
		}
		// poço tipo
		if (idPocoTipo != null
				&& !idPocoTipo.equals("")
				&& !idPocoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idPocoTipo", new Integer(idPocoTipo).intValue());
		}
		// faturamento situacao tipo
		if (idFaturamentoSituacaoTipo != null
				&& !idFaturamentoSituacaoTipo.equals("")
				&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idFaturamentoSituacaoTipo", new Integer(
					idFaturamentoSituacaoTipo).intValue());
		}
		// cobranca situacao tipo
		if (idCobrancaSituacaoTipo != null
				&& !idCobrancaSituacaoTipo.equals("")
				&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCobrancaSituacaoTipo", new Integer(
					idCobrancaSituacaoTipo).intValue());
		}
		// Situacao Especial Cobranca
		if (idSituacaoEspecialCobranca != null
				&& !idSituacaoEspecialCobranca.equals("")
				&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoEspecialCobranca", new Integer(
					idSituacaoEspecialCobranca).intValue());
		}
		// elo anormalidade
		if (idEloAnormalidade != null
				&& !idEloAnormalidade.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idEloAnormalidade",
					new Integer(idEloAnormalidade).intValue());
		}
		// cadastro ocorrencia
		if (idCadastroOcorrencia != null
				&& !idCadastroOcorrencia.equals("")
				&& !idCadastroOcorrencia.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCadastroOcorrencia", new Integer(
					idCadastroOcorrencia).intValue());
		}
		// area construida inicial e final
		if ((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (areaConstruidaFinal != null
						&& !areaConstruidaFinal.equals("") && !areaConstruidaFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setBigDecimal("areaConstruidaInicial", Util
					.formatarMoedaRealparaBigDecimal(areaConstruidaInicial));
			query.setBigDecimal("areaConstruidaFinal", Util
					.formatarMoedaRealparaBigDecimal(areaConstruidaFinal));
		}
		// consumo tarifa
		if (idConsumoTarifa != null
				&& !idConsumoTarifa.equals("")
				&& !idConsumoTarifa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idConsumoTarifa", new Integer(idConsumoTarifa)
					.intValue());
		}
		// intervalo Media Minima Imovel Inicial e Final
		if ((intervaloMediaMinimaImovelInicial != null
				&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaImovelFinal != null
						&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloMediaMinimaImovelInicial", new Integer(
					intervaloMediaMinimaImovelInicial).intValue());
			query.setInteger("intervaloMediaMinimaImovelFinal", new Integer(
					intervaloMediaMinimaImovelFinal).intValue());
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if ((intervaloMediaMinimaHidrometroInicial != null
				&& !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaHidrometroFinal != null
						&& !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloMediaMinimaHidrometroInicial",
					new Integer(intervaloMediaMinimaHidrometroInicial)
							.intValue());
			query
					.setInteger("intervaloMediaMinimaHidrometroFinal",
							new Integer(intervaloMediaMinimaHidrometroFinal)
									.intValue());
		}

		// quantidade economias inicial e final
		if ((quantidadeEconomiasInicial != null
				&& !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quantidadeEconomiasFinal != null
						&& !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("quantidadeEconomiasInicial", new Short(
					quantidadeEconomiasInicial).shortValue());
			query.setShort("quantidadeEconomiasFinal", new Short(
					quantidadeEconomiasFinal).shortValue());
		}

		// categoria
		if (idCategoria != null
				&& !idCategoria.equals("")
				&& !idCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query
					.setInteger("idCategoria", new Integer(idCategoria)
							.intValue());
		}

		// sub categoria
		if (idSubCategoria != null
				&& !idSubCategoria.equals("")
				&& !idSubCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSubCategoria", new Integer(idSubCategoria)
					.intValue());
		}

		// numero prontos inicial e final
		if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("numeroPontosInicial",
					new Short(numeroPontosInicial).shortValue());
			query.setShort("numeroPontosFinal", new Short(numeroPontosFinal)
					.shortValue());
		}

		// numero moradores inicial e final
		if ((numeroMoradoresInicial != null
				&& !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroMoradoresFinal != null
						&& !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("numeroMoradoresInicial", new Short(
					numeroMoradoresInicial).shortValue());
			query.setShort("numeroMoradoresFinal", new Short(
					numeroMoradoresFinal).shortValue());
		}
		// area construida faixa
		if (idAreaConstruidaFaixa != null
				&& !idAreaConstruidaFaixa.equals("")
				&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idAreaConstruidaFaixa", new Integer(
					idAreaConstruidaFaixa).intValue());
		}

		// cliente
		if (idCliente != null
				&& !idCliente.equals("")
				&& !idCliente.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCliente", new Integer(idCliente).intValue());
		}

		// cliente tipo
		if (idClienteTipo != null
				&& !idClienteTipo.equals("")
				&& !idClienteTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idClienteTipo", new Integer(idClienteTipo)
					.intValue());
		}

		// cliente relacao tipo
		if (idClienteRelacaoTipo != null
				&& !idClienteRelacaoTipo.equals("")
				&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idClienteRelacaoTipo", new Integer(
					idClienteRelacaoTipo).intValue());
		}
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<Conta> pesquisarContasDoImovelPorMesAnoReferencia(
			int anoMesReferencia, String idImovel)
			throws ErroRepositorioException {
		Collection<Conta> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cnta " + "from Conta cnta "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and cnta.imovel = :idImovel "
					+ "and (cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.NORMAL + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.RETIFICADA + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.INCLUIDA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idImovel", new Integer(idImovel)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoMedioLigacaoAgua(
			String idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cshi " + "from ConsumoHistorico cshi "
					+ " left join cshi.imovel imovel "
					+ " left join cshi.ligacaoTipo ligacaoTipo "
					+ "where imovel.id = :idImovel  and "
					+ "ligacaoTipo.id = :idLigacaoTipo and "
					+ "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLigacaoTipo",
					LigacaoTipo.LIGACAO_AGUA).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoMedioLigacaoEsgoto(
			String idImovel, int anoMesReferencia)
			throws ErroRepositorioException {
		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cshi " + "from ConsumoHistorico cshi "
					+ " left join cshi.imovel imovel "
					+ " left join cshi.ligacaoTipo ligacaoTipo "
					+ "where imovel.id = :idImovel  and "
					+ "ligacaoTipo.id = :idLigacaoTipo and "
					+ "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLigacaoTipo",
					LigacaoTipo.LIGACAO_ESGOTO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoMesLigacaoAgua(
			String idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cshi.numeroConsumoFaturadoMes, consumoAnormalidade.descricaoAbreviada "
					+ "from ConsumoHistorico cshi "
					+ " left join cshi.consumoAnormalidade consumoAnormalidade "
					+ " left join cshi.imovel imovel "
					+ " left join cshi.ligacaoTipo ligacaoTipo "
					+ "where imovel.id = :idImovel  and "
					+ "ligacaoTipo.id = :idLigacaoTipo and "
					+ "(imovel.ligacaoAguaSituacao = :idLigacaoAguaLigado or "
					+ "imovel.ligacaoAguaSituacao = :idLigacaoAguaCortado) and "
					+ "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLigacaoTipo",
					LigacaoTipo.LIGACAO_AGUA).setInteger("idLigacaoAguaLigado",
					LigacaoAguaSituacao.LIGADO).setInteger(
					"idLigacaoAguaCortado", LigacaoAguaSituacao.CORTADO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoMesLigacaoEsgoto(
			String idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cshi.numeroConsumoFaturadoMes, consumoAnormalidade.descricaoAbreviada "
					+ "from ConsumoHistorico cshi "
					+ " left join cshi.consumoAnormalidade consumoAnormalidade "
					+ " left join cshi.imovel imovel "
					+ " left join cshi.ligacaoTipo ligacaoTipo "
					+ "where imovel.id = :idImovel  and "
					+ "ligacaoTipo.id = :idLigacaoTipo and "
					+ "imovel.ligacaoEsgotoSituacao = :idLigacaoEsgotoLigado and "
					+ "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLigacaoTipo",
					LigacaoTipo.LIGACAO_ESGOTO).setInteger(
					"idLigacaoEsgotoLigado", LigacaoEsgotoSituacao.LIGADO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<MedicaoHistorico> pesquisarLeituraFaturadaLigacaoAgua(
			String idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Collection<MedicaoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select mdhi.leituraAtualFaturamento, leituraAnormalidadeFaturamento.id "
					+ "from MedicaoHistorico mdhi "
					+ " left join mdhi.ligacaoAgua ligacaoAgua "
					+ " left join ligacaoAgua.imovel imovel "
					+ " left join mdhi.leituraAnormalidadeFaturamento leituraAnormalidadeFaturamento "
					+ "where ligacaoAgua.id = :idImovel  and "
					+ "(imovel.ligacaoAguaSituacao.id = :idLigacaoAguaLigado or "
					+ "imovel.ligacaoAguaSituacao.id = :idLigacaoAguaCortado) and "
					+ "mdhi.anoMesReferencia = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLigacaoAguaLigado",
					LigacaoAguaSituacao.LIGADO).setInteger(
					"idLigacaoAguaCortado", LigacaoAguaSituacao.CORTADO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<MedicaoHistorico> pesquisarLeituraFaturadaLigacaoEsgoto(
			String idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Collection<MedicaoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select mdhi "
					+ "from MedicaoHistorico mdhi "
					+ " left join mdhi.imovel imovel "
					+ "where imovel.id = :idImovel  and "
					+ "imovel.ligacaoEsgotoSituacao = :idLigacaoEsgotoLigado and "
					+ "mdhi.anoMesReferencia = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLigacaoEsgotoLigado",
					LigacaoEsgotoSituacao.LIGADO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public String pesquisarAnormalidadeLeitura(Integer idAnormalidadeLeitura)
			throws ErroRepositorioException {

		String retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ltan.descricaoAbreviada from LeituraAnormalidade ltan "
					+ "where ltan.id = :idAnormalidadeLeitura ";

			retorno = (String) session.createQuery(consulta).setInteger(
					"idAnormalidadeLeitura", idAnormalidadeLeitura)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<HidrometroInstalacaoHistorico> pesquisarDataHidrometroLigacaoAgua(
			String idImovel) throws ErroRepositorioException {

		Collection<HidrometroInstalacaoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select hidi "
					+ "from HidrometroInstalacaoHistorico hidi "
					+ " left join hidi.ligacaoAgua ligacaoAgua "
					+ " left join ligacaoAgua.imovel imovel "
					+ "where ligacaoAgua.id = :idImovel  and "
					+ "(imovel.ligacaoAguaSituacao.id = :idLigacaoAguaLigado or "
					+ "imovel.ligacaoAguaSituacao.id = :idLigacaoAguaCortado) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("idLigacaoAguaLigado",
					LigacaoAguaSituacao.LIGADO).setInteger(
					"idLigacaoAguaCortado", LigacaoAguaSituacao.CORTADO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<HidrometroInstalacaoHistorico> pesquisarDataHidrometroLigacaoEsgoto(
			String idImovel) throws ErroRepositorioException {

		Collection<HidrometroInstalacaoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select hidi "
					+ "from HidrometroInstalacaoHistorico hidi "
					+ " left join hidi.imovel imovel "
					+ "where imovel.id = :idImovel  and "
					+ "imovel.ligacaoEsgotoSituacao = :idLigacaoEsgotoLigado ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("idLigacaoEsgotoLigado",
					LigacaoEsgotoSituacao.LIGADO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoFaturadoMes(
			String idImovel, int anoMesReferencia)
			throws ErroRepositorioException {
		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cshi " + "from ConsumoHistorico cshi "
					+ " left join cshi.imovel imovel "
					+ "where imovel.id = :idImovel  and "
					+ "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel",
					new Integer(idImovel)).setInteger("anoMesReferencia",
					anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<FaturamentoAtividadeCronograma> pesquisarRelacaoAtividadesGrupo(
			Integer faturamentoGrupoId, Integer anoMesReferencia)
			throws ErroRepositorioException {
		Collection<FaturamentoAtividadeCronograma> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Iterator iterator = null;

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select faturamentoAtividadeCronograma from FaturamentoAtividadeCronograma faturamentoAtividadeCronograma "
					+ " inner join fetch faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal fatGrupoCronMensal "
					+ " left join fetch fatGrupoCronMensal.usuario "
					+ " left join fetch faturamentoAtividadeCronograma.usuario "
					+ " left join fetch faturamentoAtividadeCronograma.faturamentoAtividade fatAtiv "
					+ " left join fetch fatAtiv.faturamentoAtividadePrecedente fatAtivPrec "
					+ " inner join fetch fatGrupoCronMensal.faturamentoGrupo fatGrupo "
					+ " where fatGrupo.id = :faturamentoGrupoId and "
					+ " fatGrupoCronMensal.anoMesReferencia = :anoMesReferencia order by faturamentoAtividadeCronograma.faturamentoAtividade.ordemRealizacao";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"faturamentoGrupoId", faturamentoGrupoId).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

			// while (iterator.hasNext()) {
			// FaturamentoAtividadeCronograma faturamentoAtividadeCronograma =
			// (FaturamentoAtividadeCronograma) iterator
			// .next();
			// faturamentoAtividadeCronograma.getFaturamentoAtividade();
			// faturamentoAtividadeCronograma.getUsuario();
			// faturamentoAtividadeCronograma
			// .getFaturamentoGrupoCronogramaMensal();
			// faturamentoAtividadeCronograma
			// .getFaturamentoGrupoCronogramaMensal()
			// .getFaturamentoGrupo();
			// faturamentoAtividadeCronograma
			// .getFaturamentoGrupoCronogramaMensal()
			// .getUsuario();
			//
			// retorno.add(faturamentoAtividadeCronograma);
			// }

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso calcula a tarifa miníma de água para um imóvel
	 * 
	 * [UC0451] Obter Tarifa Miníma de Água para um Imóvel
	 * 
	 * Para cada categoria e maior data de vigência retorna o valor da tarifa
	 * minima
	 * 
	 * pesquisarTarifaMinimaCategoriaVigencia
	 * 
	 * @author Roberta Costa
	 * @date 09/08/2006
	 * 
	 * @param dataCorrente
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object pesquisarTarifaMinimaCategoriaVigencia(Categoria categoria,
			ConsumoTarifaVigencia consumoTarifaVigencia, Integer idSubCategoria)
			throws ErroRepositorioException {

		Object retorno = null;

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select ct.valorTarifaMinima "
					+ "from ConsumoTarifaCategoria ct "
					+ "inner join ct.consumoTarifaVigencia ctv "
					+ "inner join ct.categoria ctg "
					+ "inner join ct.subCategoria sc "
					+ "where ctv.id = :consumoTarifaVigenciaId "
					+ "and ctg.id = :categoriaId "
					+ "and sc.id = :subcategoriaId";

			retorno = session.createQuery(consulta).setInteger(
					"consumoTarifaVigenciaId", consumoTarifaVigencia.getId())
					.setInteger("categoriaId", categoria.getId()).setInteger(
							"subcategoriaId", idSubCategoria).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso inicia um processo para o mecanismo batch
	 * 
	 * [UC0111] - Iniciar Processo
	 * 
	 * Este subfluxo tem o papel de iniciar um processo de faturamento
	 * comandado, neste método é feita uma busca para obter as atividades
	 * comandadas e não realizadas
	 * 
	 * [SB0001] - Iniciar Processo de Faturamento Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 14/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoAtividadeCronograma> pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadas(
			int numeroPagina) throws ErroRepositorioException {

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		Collection<FaturamentoAtividadeCronograma> retorno = new ArrayList();

		// Iterator iterator = null;

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select faturamentoAtividadeCronograma from FaturamentoAtividadeCronograma faturamentoAtividadeCronograma "
					+ " inner join fetch faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal "
					+ " left join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo faturamentoGrupo "
					+ " left join fetch faturamentoAtividadeCronograma.faturamentoAtividade faturamentoAtividade "
					+ " where faturamentoGrupo.anoMesReferencia = faturamentoGrupoCronogramaMensal.anoMesReferencia and "
					+ " faturamentoAtividadeCronograma.comando is not null and "
					+ "(faturamentoAtividadeCronograma.dataRealizacao is null and faturamentoAtividadeCronograma.dataPrevista <= :novaData)"
					+ " order by  faturamentoGrupoCronogramaMensal.anoMesReferencia, faturamentoGrupo.id, faturamentoAtividade.descricao";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).setTimestamp("novaData",new Date()).setFirstResult(10 * numeroPagina)
					.setMaxResults(10).list()));

			/**
			 * alterado por pedro alexandre dia 23/01/2007
			 */
			/*
			 * // constroi o hql consulta = "select
			 * faturamentoAtividadeCronograma from
			 * FaturamentoAtividadeCronograma faturamentoAtividadeCronograma " + "
			 * inner join
			 * faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal
			 * faturamentoGrupoCronogramaMensal " + " left join
			 * faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo
			 * faturamentoGrupo " + " where faturamentoGrupo.anoMesReferencia =
			 * faturamentoGrupoCronogramaMensal.anoMesReferencia and " + "
			 * faturamentoAtividadeCronograma.comando is not null and " +
			 * "(faturamentoAtividadeCronograma.dataRealizacao is null or
			 * (faturamentoAtividadeCronograma.dataRealizacao <
			 * faturamentoAtividadeCronograma.comando))"; // executa o hql
			 * iterator = session.createQuery(consulta).setFirstResult(10 *
			 * numeroPagina).setMaxResults(10).list().iterator();
			 * 
			 * while (iterator.hasNext()) { FaturamentoAtividadeCronograma
			 * faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma)
			 * iterator.next();
			 * 
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal());
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoAtividade());
			 * 
			 * retorno.add(faturamentoAtividadeCronograma); }
			 */
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de uso inicia um processo para o mecanismo batch
	 * 
	 * [UC0111] - Iniciar Processo
	 * 
	 * Este subfluxo tem o papel de iniciar um processo de faturamento
	 * comandado, neste método é feita uma busca para obter as atividades
	 * comandadas e não realizadas
	 * 
	 * [SB0001] - Iniciar Processo de Faturamento Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 14/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadasCount()
			throws ErroRepositorioException {

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		int retorno = 0;

		try {
			// constroi o hql
			consulta = "select count(faturamentoAtividadeCronograma.id) from FaturamentoAtividadeCronograma faturamentoAtividadeCronograma "
					+ " inner join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal "
					+ " left join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo faturamentoGrupo "
					+ " where faturamentoGrupo.anoMesReferencia = faturamentoGrupoCronogramaMensal.anoMesReferencia and "
					+ " faturamentoAtividadeCronograma.comando is not null and "
					+ "(faturamentoAtividadeCronograma.dataRealizacao is null and faturamentoAtividadeCronograma.dataPrevista <= :novaData )";
			
			
			

			// executa o hql
			retorno = (Integer) session.createQuery(consulta).setTimestamp("novaData", new Date()).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa a existencia de uma conta pelo id da conta e pela data da ultima
	 * alteracao
	 * 
	 * @param id
	 *            Descrição do parâmetro
	 * @param ultimaAlteracao
	 *            formato - 2006-08-25 Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaContaParaConcorrencia(String idConta,
			String ultimaAlteracao) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			/*
			 * Date ultimaAlteracaoInicio = Util.criarData() Date
			 * ultimaAlteracaoFim = ultimaAlteracao + ".999";
			 */

			/*
			 * consulta = "SELECT ct.id FROM Conta ct " + "WHERE ct.id =
			 * :idConta " + "AND ct.ultimaAlteracao >= :ultimaAlteracaoInicio " +
			 * "AND ct.ultimaAlteracao <= :ultimaAlteracaoFim ";
			 * 
			 * retorno = (Integer) session.createQuery(consulta).setString(
			 * "idConta", idConta).setString("ultimaAlteracaoInicio",
			 * ultimaAlteracaoInicio).setString("ultimaAlteracaoFim",
			 * ultimaAlteracaoFim).setMaxResults(1).uniqueResult();
			 */

			consulta = "SELECT ct.id FROM Conta ct "
					+ "WHERE ct.id = :idConta "
					+ "AND to_char(ct.ultimaAlteracao,'YYYY-MM-DD HH24:MI:SS') like :ultimaAlteracao ";

			retorno = (Integer) session.createQuery(consulta).setString(
					"ultimaAlteracao", ultimaAlteracao + "%").setInteger(
					"idConta", new Integer(idConta)).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer verificarExistenciaDebitoTipo(Integer idDebitoTipo)
			throws ErroRepositorioException {
		// cria a variável que vai armazenar a coleção pesquisada

		Integer retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select debitoTipo.id "
					+ "from DebitoTipo debitoTipo "
					+ "where debitoTipo.id = :idDebitoTipo";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idDebitoTipo", idDebitoTipo.intValue()).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Este caso de uso consultar os dados da conta
	 * 
	 * @param idConta
	 *            Id da Conta
	 * 
	 * @author Fernanda Paiva
	 * @date 04/09/2006
	 * 
	 * @return uma colecao de conta
	 * @throws ErroRepositorioException
	 */
	public Collection consultarConta(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT imov.id, " // 0
					+ "cnta.referencia, " // 1
					+ "cnta.debitoCreditoSituacaoAtual, "// 2
					+ "cnta.ligacaoAguaSituacao, "// 3
					+ "cnta.ligacaoEsgotoSituacao, " // 4
					+ "cnta.indicadorCobrancaMulta, "// 5
					+ "cnta.indicadorAlteracaoVencimento, "// 6
					+ "cnta.consumoAgua, "// 7
					+ "cnta.consumoEsgoto, " // 8
					+ "cnta.percentualEsgoto, "// 9
					+ "cnta.valorAgua, " // 10
					+ "cnta.valorEsgoto, " // 11
					+ "cnta.debitos, " // 12
					+ "cnta.valorCreditos, "// 13
					+ "cnta.indicadorDebitoConta, "// 14
					+ "cnta.id, " // 15
					+ "cnta.dataVencimentoConta, "// 16
					+ "cnta.dataValidadeConta, " // 17
					+ "cnta.dataInclusao, " // 18
					+ "cnta.dataRetificacao, "// 19
					+ "cnta.dataCancelamento, " // 20
					+ "cnta.dataRevisao, "// 21
					+ "mned.id, "// 22
					+ "mned.motivoNaoeEntregaDocumento, "// 23
					+ "mned.abreviado, "// 24
					+ "mned.indicadorUso, "// 25
					+ "mned.ultimaAlteracao, "// 26

					+ "cnmi.id, "// 27
					+ "cnmi.descricaoMotivoInclusaoConta, "// 28
					+ "cnmi.indicadorUso, "// 29
					+ "cnmi.ultimaAlteracao, "// 30

					+ "cnmr.id, "// 31
					+ "cnmr.descricao, "// 32
					+ "cnmr.indicadorUso, "// 33
					+ "cnmr.ultimaAlteracao, "// 34

					+ "cnmc.id, "// 35
					+ "cnmc.descricaoMotivoCancelamentoConta, "// 36
					+ "cnmc.indicadorUso, "// 37
					+ "cnmc.ultimaAlteracao, "// 38

					+ "cnmrv.id, "// 39
					+ "cnmrv.descricaoMotivoRevisaoConta, "// 40
					+ "cnmrv.indicadorUso, "// 41
					+ "cnmrv.ultimaAlteracao, "// 42

					+ "contaOrigem.id, "// 43
					+ "imovelOrigem.id, "// 44

					+ "cnta.referenciaContabil, "// 45
					+ "cnta.referenciaBaixaContabil, "// 46
					+ "contaOrigemHistorico.id, "// 47
					+ "imovelOrigemHistorico.id, "// 48
					+ "usuario.nomeUsuario, "// 49
					+ "cnta.valorImposto, " // 50
					/**
					 * 
					 * Adicionando campo na consulta
					 */
					+ "cnta.ultimaAlteracao " // 51
					+ "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "INNER JOIN cnta.ligacaoAguaSituacao last "
					+ "INNER JOIN cnta.ligacaoEsgotoSituacao lest "
					+ "LEFT JOIN cnta.motivoNaoEntregaDocumento mned "
					+ "LEFT JOIN cnta.contaMotivoInclusao cnmi "
					+ "LEFT JOIN cnta.contaMotivoRetificacao cnmr "
					+ "LEFT JOIN cnta.contaMotivoCancelamento cnmc "
					+ "LEFT JOIN cnta.contaMotivoRevisao cnmrv "
					+ "LEFT JOIN cnta.usuario usuario "

					+ "LEFT JOIN cnta.origem contaGeralOrigem "
					+ "LEFT JOIN contaGeralOrigem.conta contaOrigem "
					+ "LEFT JOIN contaOrigem.imovel imovelOrigem "
					+ "LEFT JOIN contaGeralOrigem.contaHistorico contaOrigemHistorico "
					+ "LEFT JOIN contaOrigemHistorico.imovel imovelOrigemHistorico "

					+ "WHERE  cnta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * 
	 * Este caso de uso permite a emissão de uma ou mais contas.
	 * 
	 * @author Pedro Alexandre
	 * @date 19/09/2006
	 * 
	 * @param anoMesReferencia
	 * @param faturamentoGrupo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpressao(Integer anoMesReferencia,
			FaturamentoGrupo faturamentoGrupo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaImpressao.id "
					+ "from ContaImpressao contaImpressao "
					+ "where contaImpressao.referenciaConta =:referencia "
					+ "and contaImpressao.faturamentoGrupo.id = :idFaturamentoGrupo "
					+ "and contaImpressao.indicadorImpressao ="
					+ ConstantesSistema.NAO + " order by contaImpressao.id";

			retorno = session.createQuery(consulta).setInteger("referencia",
					anoMesReferencia).setInteger("idFaturamentoGrupo",
					faturamentoGrupo.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * 
	 * Este caso de uso permite a emissão de uma ou mais contas.
	 * 
	 * @author Pedro Alexandre
	 * @date 24/10/2006
	 * 
	 * @param anoMesReferencia
	 * @param faturamentoGrupo
	 * @param numeroPaginas
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpressao(Integer anoMesReferencia,
			FaturamentoGrupo faturamentoGrupo, Integer numeroPaginas)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaImpressao.cnta_id as idContaImpressao "
					+ "from faturamento.conta_impressao contaImpressao "
					+ "inner join faturamento.conta cnt on cnt.cnta_id=contaImpressao.cnta_id "
					+ "inner join cadastro.quadra qdraConta on qdraConta.qdra_id = cnt.qdra_id "
					+ "inner join micromedicao.rota rot on rot.rota_id = qdraConta.rota_id "
					+ "inner join cadastro.empresa emp on emp.empr_id = rot.empr_id "
					+ "where contaImpressao.cnti_amreferenciaconta =:referencia "
					+ "and contaImpressao.ftgr_id = :idFaturamentoGrupo "
					+ "and contaImpressao.cnti_icimpressao ="
					+ ConstantesSistema.NAO
					+ " order by cnta_amreferenciaconta,contaImpressao.clie_idresponsavel,emp.empr_id,cnt.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar(
					"idContaImpressao", Hibernate.INTEGER).setInteger(
					"referencia", anoMesReferencia).setInteger(
					"idFaturamentoGrupo", faturamentoGrupo.getId())
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Pedro Alexandre
	 * @date 19/09/2006
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorMultasCobradas(int idConta)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dbcb.valorPrestacao) "
					+ "from DebitoCobrado dbcb "
					// + "inner join dbcb.conta cnta "
					+ "inner join dbcb.debitoTipo dbtp "
					+ "where cnta_id = :idConta "
					+ "and dbtp.id = :debitoTipo ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idConta", idConta).setInteger("debitoTipo",
					DebitoTipo.MULTA_IMPONTUALIDADE).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os dados da conta p emitir a 2ª via [UC0482]Emitir 2ª Via de
	 * Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 15/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConta(Integer idConta)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT "
					+ " new "
					+ EmitirContaHelper.class.getName()
					+ " ( "
					+ "cnt.id, "
					+ "cli.nome, "
					+ "cli.cpf, "
					+ "cli.cnpj, "
					+ "cnt.dataVencimentoConta, "
					+ "cnt.referencia, "
					+ "cnt.digitoVerificadorConta, "
					+ "cnt.codigoSetorComercial, "
					+ "cnt.quadra, "
					+ "cnt.lote, "
					+ "cnt.subLote, "
					+ "cnt.consumoAgua, "
					+ "cnt.consumoEsgoto, "
					+ "cnt.valorAgua, "
					+ "cnt.valorEsgoto, "
					+ "cnt.debitos, "
					+ "cnt.valorCreditos, "
					+ "cnt.valorImposto, "
					+ "cnt.dataValidadeConta, "
					+ "imovel.id, "
					+ "loc.id, "
					+ "gerenciaRegional.id, "
					+ "gerenciaRegional.nome, "
					+ "ligacaoAguaSituacao.id, "
					+ "ligacaoEsgotoSituacao.id, "
					+ "imovelPerfil.id, "
					+ "setorComercial.id, "
					+ "faturamentoGrupo.id, "
					+ "emp.id, "
					+ "loc.descricao, "
					+ "ligacaoAguaSituacao.descricao, "
					+ "ligacaoEsgotoSituacao.descricao, "
					+ "imovelContaEnvio.id, "
					+ "cnt.percentualEsgoto, "
					+ "imovel.nomeImovel, "
					+ "imovel.codigoDebitoAutomatico, " 
					+ "faturamentoGrupo.anoMesReferencia, "
					+ " cnt.valorRateioAgua, " 
					+ " cnt.valorRateioEsgoto ) "
					+ "from ClienteConta cliCnt "
					+ "RIGHT JOIN cliCnt.conta cnt "
					+ "LEFT JOIN cliCnt.clienteRelacaoTipo crt "
					+ "LEFT JOIN cliCnt.cliente cli "
					+ "LEFT JOIN cnt.contaMotivoRevisao cmr "
					+ "LEFT JOIN cnt.quadraConta quadraConta "
					+ "LEFT JOIN cnt.localidade loc "
					+ "LEFT JOIN loc.gerenciaRegional gerenciaRegional "
					+ "LEFT JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "LEFT JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "LEFT JOIN cnt.imovelPerfil imovelPerfil "
					+ "LEFT JOIN quadraConta.rota rota "
					+ "LEFT JOIN rota.empresa emp "
					+ "LEFT JOIN quadraConta.setorComercial setorComercial "
					+ "LEFT JOIN rota.faturamentoGrupo faturamentoGrupo "
					+ "LEFT JOIN cnt.imovel imovel "
					+ "LEFT JOIN imovel.imovelContaEnvio imovelContaEnvio "
					+ "WHERE  cnt.id = :idConta "
//					+ "AND crt.id = :usuario "
					
					/*
					 * Felipe Santos
					 * 
					 * Imprimir segunda via de conta com o cliente responsável pela conta
					 */
					+ "and clct_icnomeconta = :indicadorNomeConta "
			
					+ "ORDER BY cnt.referencia,emp.id,loc.id,cnt.codigoSetorComercial,"
					+ "cnt.quadra,cnt.lote,cnt.subLote";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
						.setInteger("indicadorNomeConta", ConstantesSistema.SIM).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0209] Gerar Taxa de Entrega de Conta em Outro Endereço
	 * 
	 * Atualiza os dados do débito a cobrar e a data de última atualização do
	 * débito a cobrar geral.
	 * 
	 * @author Pedro Alexandre
	 * @date 20/09/2006
	 * 
	 * @param colecaoDebitosACobrar
	 * @throws ErroRepositorioException
	 */
	public void atualizaDebitoACobrar(Collection colecaoDebitosACobrar)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Iterator colecaoDebitosACobrarIterator = colecaoDebitosACobrar
				.iterator();

		String sqlAtualizar = "";
		try {
			// Laço para atualizar todos os débitos a cobrar informados
			while (colecaoDebitosACobrarIterator.hasNext()) {
				// Atualiza o débito a cobrar
				DebitoACobrar debitoACobrar = (DebitoACobrar) colecaoDebitosACobrarIterator
						.next();
				session.merge(debitoACobrar);

				// Atualiza a data de última alteração do débito a cobrar geral.
				sqlAtualizar = "update DebitoACobrarGeral dage "
						+ "set dage.ultimaAlteracao = :dataUltimaAlteracao "
						+ "where dage.id = :idDebitoACobrarCategoria";

				session.createQuery(sqlAtualizar).setTimestamp(
						"dataUltimaAlteracao", new Date()).setInteger(
						"idDebitoACobrarCategoria", debitoACobrar.getId())
						.executeUpdate();

				session.flush();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0351 - Calcular Impostos Deduzidos da Conta] Author: Fernanda Paiva
	 * Data: 21/09/2006
	 * 
	 * @param idImovel
	 *            Id do Imóvel
	 * @return cliente responsavel pelo imovel marcado como esferaPoder =
	 *         federal
	 */
	public Integer pesquisarClienteResponsavelImovel(Integer idImovel)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select cli.id from ClienteImovel cliImo "
					+ "inner join cliImo.clienteRelacaoTipo crt "
					+ "inner join cliImo.cliente cli "
					+ "inner join cliImo.imovel imo "
					+ "inner join cli.clienteTipo cltp "
					+ "where imo.id = :idImovel AND "
					+ "crt.id = :idResponsavel AND "
					+ "cltp.esferaPoder.id = :esferaPoder AND "
					+ "cliImo.dataFimRelacao is null ";
			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setInteger("idResponsavel",
					ClienteRelacaoTipo.RESPONSAVEL).setInteger("esferaPoder",
					EsferaPoder.FEDERAL).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0351 - Calcular Impostos Deduzidos da Conta] Author: Fernanda Paiva
	 * Data: 22/09/2006
	 * 
	 * @param idImpostoTipo
	 *            Id do ImpostoTipo
	 * @param anoMesReferencia
	 *            Ano Mês de Referência
	 * @return aliquotas do imposto
	 */
	public ImpostoTipoAliquota pesquisarAliquotaImposto(Integer idImpostoTipo,
			Integer anoMesReferencia) throws ErroRepositorioException {

		ImpostoTipoAliquota retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select itpa from ImpostoTipoAliquota itpa "
					+ "where itpa.impostoTipoAliquota.id = :idImpostoTipo AND "
					+ "(itpa.anoMesReferencia = :anoMesReferencia OR "
					+ "itpa.anoMesReferencia < :anoMesReferencia) "
					+ " order by itpa.anoMesReferencia ";
			retorno = (ImpostoTipoAliquota) session.createQuery(consulta)
					.setInteger("idImpostoTipo", idImpostoTipo).setInteger(
							"anoMesReferencia", anoMesReferencia)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Fernanda Paiva Data: 25/09/2006
	 * 
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public void removerClientesConta(Integer idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<ClienteConta> clienteConta = new ArrayList();

		try {
			clienteConta = session
					.createQuery(
							"FROM gcom.cadastro.cliente.ClienteConta as clct WHERE clct.conta = :idConta")
					.setInteger("idConta", idConta).list();

			Iterator iterator = clienteConta.iterator();

			while (iterator.hasNext()) {
				session.delete(iterator.next());
				// iterator.remove();

			}

			session.flush();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0150] - Retificar Conta Author: Fernanda Paiva Data: 25/09/2006
	 * 
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public void removerImpostosDeduzidosConta(Integer idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<ContaImpostosDeduzidos> contaImpostosDeduzidos = new ArrayList();

		try {
			contaImpostosDeduzidos = session
					.createQuery(
							"FROM gcom.faturamento.conta.ContaImpostosDeduzidos as clid WHERE clid.conta = :idConta")
					.setInteger("idConta", idConta).list();

			Iterator iterator = contaImpostosDeduzidos.iterator();

			while (iterator.hasNext()) {
				session.delete(iterator.next());
				// iterator.remove();

			}

			session.flush();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * Atualiza a data e hora da realização da atividade.
	 * 
	 * @author Pedro Alexandre
	 * @date 27/09/2006
	 * 
	 * @param idAtividade
	 * @param anoMesReferencia
	 * @param idFaturamentoGrupo
	 * @throws ErroRepositorioException
	 */
	public void atualizarDataHoraRealizacaoAtividade(Integer idAtividade,
			Integer anoMesReferencia, Integer idFaturamentoGrupo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String atualizar;

		try {

			atualizar = "update FaturamentoAtividadeCronograma ftcr "
					+ "set ftcr.dataRealizacao = :dataRealizacao, ftcr.ultimaAlteracao = :dataUltimaAlteracao "
					+ "where ftcr.faturamentoAtividade.id = :idAtividade and ftcr.faturamentoGrupoCronogramaMensal.id in "
					+ "(select fgcm.id from FaturamentoGrupoCronogramaMensal fgcm "
					// + "inner join fgcm.faturamentoGrupo fagr "
					+ "where fgcm.anoMesReferencia = :anoMesReferencia and fgcm.faturamentoGrupo.id = :idFaturamentoGrupo)";

			session.createQuery(atualizar).setTimestamp("dataRealizacao",
					new Date()).setTimestamp("dataUltimaAlteracao", new Date())
					.setInteger("idAtividade", idAtividade).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idFaturamentoGrupo", idFaturamentoGrupo)
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * Atualiza o ano/mês de referência do faturamento para o mês seguinte.
	 * 
	 * @author Pedro Alexandre
	 * @date 27/09/2006
	 * 
	 * @param idFaturamentoGrupo
	 * @param anoMesReferencia
	 * @throws ErroRepositorioException
	 */
	public void atualizarAnoMesReferenciaFaturamentoGrupo(
			Integer idFaturamentoGrupo, Integer anoMesReferencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String atualizar;

		Integer anoMesReferenciaAtualizado = Util
				.somaUmMesAnoMesReferencia(anoMesReferencia);

		try {

			atualizar = "update FaturamentoGrupo fagr "
					+ "set fagr.anoMesReferencia = :anoMesReferencia ,fagr.ultimaAlteracao = :dataUltimaAlteracao "
					+ "where fagr.id = :idFaturamentoGrupo ";

			session.createQuery(atualizar).setTimestamp("dataUltimaAlteracao",
					new Date()).setInteger("anoMesReferencia",
					anoMesReferenciaAtualizado).setInteger(
					"idFaturamentoGrupo", idFaturamentoGrupo).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);

		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Verifica se todos os grupos já foram faturados
	 * 
	 * @author Pedro Alexandre
	 * @date 07/10/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarFaturamentoGrupoNaoFaturados(
			Integer anoMesReferenciaFaturamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "from FaturamentoGrupo fatGrupo "
					+ "where fatGrupo.anoMesReferencia <= :anoMesReferenciaFaturamento " 
					+ "and fatGrupo.indicadorUso = " + ConstantesSistema.SIM;

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaFaturamento", anoMesReferenciaFaturamento)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Permite inserir DebitoACobrarGeral contidos numa coleção [UC0394] Gerar
	 * Débitos a Cobrar de Doações
	 * 
	 * @author César Araújo
	 * @date 05/08/2006
	 * @param Collection
	 *            <DebitoACobrarGeral> colecaoDebitosACobrarGeral - Coleção de
	 *            DebitoACobrarGeral
	 * @throws ErroRepositorioException
	 */
	public Integer inserirDebitoACobrarGeral(
			DebitoACobrarGeral debitoACobrarGeral)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer retorno = null;

		try {
			retorno = (Integer) session.save(debitoACobrarGeral);
			session.flush();
			session.clear();
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Permite inserir DebitoACobrar contidos numa coleção [UC0394] Gerar
	 * Débitos a Cobrar de Doações
	 * 
	 * @author César Araújo
	 * @date 05/08/2006
	 * @param Collection
	 *            <DebitoACobrarGeral> colecaoDebitosACobrarGeral - Coleção de
	 *            DebitoACobrarGeral
	 * @throws ErroRepositorioException
	 */
	public void inserirDebitoACobrar(DebitoACobrar debitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			session.save(debitoACobrar);
			session.flush();
			session.clear();
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês - Item 05
	 * 
	 * Atualiza a situação de imóvel com cobrança finalizada
	 * 
	 * @author Pedro Alexandre
	 * @date 07/10/2006
	 * 
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarImoveisSituacaoEspecialCobrancaFinalizada(
			int anoMesFaturamento, Integer idSetorComercial)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoCobrancaImovel;
		String atualizarAnoMesCobrancaRetirada;

		try {
			// Atualiza situação de cobrança do imóvel *******
			atualizarSituacaoCobrancaImovel = "update Imovel imov "
					+ "set imov.cobrancaSituacaoTipo.id = null "
					+ "where imov.setorComercial = :idSetorComercial and imov.cobrancaSituacaoTipo.id is not null "
					+ "and imov.id in "
					+ "(select distinct (cbsh.imovel.id) "
					+ "from CobrancaSituacaoHistorico cbsh "
					+ "where cbsh.anoMesCobrancaSituacaoFim <= :anoMesFaturamento and cbsh.anoMesCobrancaRetirada is null"
					+ ")";

			session.createQuery(atualizarSituacaoCobrancaImovel).setInteger(
					"idSetorComercial", idSetorComercial).setInteger(
					"anoMesFaturamento", anoMesFaturamento).executeUpdate();
			// ***************************************************

			// Atualizar o ano/mês de cobrança retirada *******
			atualizarAnoMesCobrancaRetirada = "update CobrancaSituacaoHistorico "
					+ "set anoMesCobrancaRetirada = :anoMesFaturamento "
					+ "where anoMesCobrancaSituacaoFim <= :anoMesFaturamento "
					+ "and anoMesCobrancaRetirada is null and imovel in (select imovel.id from Imovel imovel where imovel.setorComercial =:idSetorComercial)";

			session.createQuery(atualizarAnoMesCobrancaRetirada).setInteger(
					"idSetorComercial", idSetorComercial).setInteger(
					"anoMesFaturamento", anoMesFaturamento).executeUpdate();
			// *****************************************************

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public Collection pesquisarDebitoCobradoCategoria(Integer idDebitoCobrado)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "from DebitoCobradoCategoria dccg "
					+ "where dccg.debitoCobrado.id = :idDebitoCobrado ";

			retorno = session.createQuery(consulta).setInteger(
					"idDebitoCobrado", idDebitoCobrado).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarCreditoRealizadoCategoria(Integer idCreditoRealizado) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "from CreditoRealizadoCategoria crcg where crcg.creditoRealizado.id = :idCreditoRealizado ";

			retorno = session.createQuery(consulta).setInteger("idCreditoRealizado", idCreditoRealizado).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Pesquisa os débitos a cobrar por categoria.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/10/2006
	 * 
	 * @param debitoACobrar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarCategoria(
			DebitoACobrar debitoACobrar) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select dacc " + "from DebitoACobrarCategoria dacc "
					+ "where dacc.debitoACobrar.id = :idDebitoACobrar";

			retorno = session.createQuery(consulta).setInteger(
					"idDebitoACobrar", debitoACobrar.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Pesquisa os créditos a realizar por categoria.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/10/2006
	 * 
	 * @param creditoARealizar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizarCategoria(
			CreditoARealizar creditoARealizar) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select cacg " + "from "
					+ "CreditoARealizarCategoria cacg "
					+ "where cacg.creditoARealizar.id = :idCreditoARealizar";

			retorno = session.createQuery(consulta).setInteger(
					"idCreditoARealizar", creditoARealizar.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection<IContaImpostosDeduzidos> pesquisarContaImpostosDeduzidos(Integer idConta)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select cnid from " + "ContaImpostosDeduzidos cnid where cnid.conta.id = :idConta";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Pesquisa as conta categoria consumo de faixa.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/10/2005
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaConsumoFaixa(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaCategoriaConsumoFaixa "
					+ "from ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa "
					+ "inner join fetch contaCategoriaConsumoFaixa.contaCategoria cC "
					+ "inner join cC.comp_id.conta conta "
					+ "where conta.id = :idConta "
					+ "order by contaCategoriaConsumoFaixa.id ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection pesquisarContaCategoriaConsumoFaixaHistorico(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaCategoriaConsumoFaixaHistorico "
					+ "from ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistorico "
					+ "inner join fetch contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico cC "
					+ "inner join fetch contaCategoriaConsumoFaixaHistorico.categoria categoria "
					+ "inner join fetch contaCategoriaConsumoFaixaHistorico.subcategoria subcategoria "
					+ "inner join fetch cC.comp_id.contaHistorico contaHistorico "
					+ "inner join fetch cC.comp_id.categoria catg "
					+ "inner join fetch cC.comp_id.subcategoria subcatg "
					+ "where contaHistorico.id = :idContaHistorico "
					+ "order by contaCategoriaConsumoFaixaHistorico.id ";

			retorno = session.createQuery(consulta).setInteger("idContaHistorico", idConta.intValue()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Para cada conta transferida para o histórico, atualiza o indicador de que
	 * a conta está no histórico na tabela ContaGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * 
	 * @param idsContas
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorContaNoHistorico(Collection idsContas)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarContaGeral;

		try {
			atualizarContaGeral = "update ContaGeral cntg "
					+ "set cntg.indicadorHistorico = :indicadorHistorico, cntg.ultimaAlteracao= :dataUltimaAlteracao where cntg.id in (:idsContas)";

			session.createQuery(atualizarContaGeral).setInteger(
					"indicadorHistorico", ConstantesSistema.SIM).setDate(
					"dataUltimaAlteracao", new Date()).setParameterList(
					"idsContas", idsContas).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Para cada débito a cobrar transferido para o histórico, atualiza o
	 * indicador de que o débito a cobrar está no histórico na tabela
	 * DebitoACobrarGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * 
	 * @param idsDebitosACobrar
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorDebitoACobrarNoHistorico(
			Collection idsDebitosACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarDebitoACobrarGeral;

		try {
			atualizarDebitoACobrarGeral = "update DebitoACobrarGeral dage "
					+ "set dage.indicadorHistorico = :indicadorHistorico, dage.ultimaAlteracao = :dataUltimaAlteracao where dage.id in (:idsDebitosACobrar)";

			session.createQuery(atualizarDebitoACobrarGeral).setInteger(
					"indicadorHistorico", ConstantesSistema.SIM).setDate(
					"dataUltimaAlteracao", new Date()).setParameterList(
					"idsDebitosACobrar", idsDebitosACobrar).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Para cada crédito a realizar transferido para o histórico, atualiza o
	 * indicador de que o crédito a realizar está no histórico na tabela
	 * CreditoARealizarGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * 
	 * @param idsCreditoARealizar
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorCreditoARealizarNoHistorico(
			Collection idsCreditoARealizar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarCreditoARealizarGeral;

		try {
			atualizarCreditoARealizarGeral = "update CreditoARealizarGeral cage "
					+ "set cage.indicadorHistorico = :indicadorHistorico, cage.ultimaAlteracao = :dataUltimaAlteracao where cage.id in (:idsCreditoARealizar)";

			session.createQuery(atualizarCreditoARealizarGeral).setInteger(
					"indicadorHistorico", ConstantesSistema.SIM).setDate(
					"dataUltimaAlteracao", new Date()).setParameterList(
					"idsCreditoARealizar", idsCreditoARealizar).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public Collection<IClienteConta> pesquisarClienteConta(Integer idConta) throws ErroRepositorioException {

		Collection<IClienteConta> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select clienteConta from ClienteConta clienteConta inner join clienteConta.conta conta "
					+ "where conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void inserirDebitoAutomaticoMovimento(
			DebitoAutomaticoMovimento debitoAutomaticoMovimento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		try {
			session.save(debitoAutomaticoMovimento);
			session.flush();
			session.clear();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * 
	 * @author Raphael Rossiter
	 * @date 30/10/2006
	 * 
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaRetificacao(Integer idConta)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT "
					+ "cnt.id, " // 0
					+ "cnt.dataVencimentoConta, " // 1
					+ "cnt.referencia, " // 2
					+ "cnt.referenciaContabil, " // 3
					+ "cnt.consumoAgua, " // 4
					+ "cnt.consumoEsgoto, " // 5
					+ "cnt.valorAgua, " // 6
					+ "cnt.valorEsgoto, " // 7
					+ "cnt.debitos, " // 8
					+ "cnt.valorCreditos, " // 9
					+ "cnt.valorImposto, " // 10
					+ "cnt.dataValidadeConta, " // 11
					+ "cnt.lote, " // 12
					+ "cnt.subLote, " // 13
					+ "debitoCreditoSituacaoAtual.id, " // 14
					+ "localidadeConta.id, " // 15
					+ "quadraConta.id, " // 16
					+ "quadraConta.numeroQuadra, " // 17
					+ "setorComercialConta.id, " // 18
					+ "setorComercialConta.codigo, " // 19
					+ "cnt.indicadorCobrancaMulta, " // 20
					+ "consumoTarifa.id, " // 21
					+ "imovelPerfilConta.id, " // 22
					+ "ligacaoAguaSituacaoConta.id, " // 23
					+ "ligacaoEsgotoSituacaoConta.id, " // 24
					+ "imovel.id, " // 25
					+ "imovelPerfilImovel.id, " // 26
					+ "localidadeImovel.id, " // 27
					+ "quadraImovel.id, " // 28
					+ "quadraImovel.numeroQuadra, " // 29
					+ "setorComercialImovel.id, " // 30
					+ "setorComercialImovel.codigo, " // 31
					+ "ligacaoAguaSituacaoImovel.id, " // 32
					+ "ligacaoAguaSituacaoImovel.descricao, " // 33
					+ "ligacaoEsgotoSituacaoImovel.id, " // 34
					+ "ligacaoEsgotoSituacaoImovel.descricao, " // 35
					+ "consumoTarifaImovel.id, " // 36
					+ "cnt.dataVencimentoOriginal, " // 37
					+ "cnt.percentualEsgoto, " // 38
					+ "imovel.indicadorDebitoConta, " // 39
					+ "imovel.imovelCondominio.id, " // 40
					+ "cnt.numeroRetificacoes, " // 41
					+ "cnt.indicadorDebitoConta, " // 42
					+ "cnt.faturamentoGrupo.id, " // 43
					+ "cnt.rota.id, " // 44
					+ "cnt.numeroLeituraAnterior, " // 45
					+ "cnt.numeroLeituraAtual, " // 46
					+ "cnt.percentualColeta, " //47
					+ "cnt.numeroVolumePoco, "//48
					+ "ligacaoAguaSituacaoConta.indicadorFaturamentoSituacao, "//49
					+ "ligacaoEsgotoSituacaoConta.indicadorFaturamentoSituacao "//50
					+ "FROM Conta cnt "
					+ "INNER JOIN cnt.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "INNER JOIN cnt.localidade localidadeConta "
					+ "INNER JOIN cnt.quadraConta quadraConta "
					+ "INNER JOIN quadraConta.setorComercial setorComercialConta "
					+ "INNER JOIN cnt.consumoTarifa consumoTarifa "
					+ "LEFT JOIN cnt.imovelPerfil imovelPerfilConta "
					+ "INNER JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacaoConta "
					+ "INNER JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacaoConta "
					+ "INNER JOIN cnt.imovel imovel "
					+ "INNER JOIN imovel.imovelPerfil imovelPerfilImovel "
					+ "INNER JOIN imovel.localidade localidadeImovel "
					+ "INNER JOIN imovel.setorComercial setorComercialImovel "
					+ "INNER JOIN imovel.quadra quadraImovel "
					+ "INNER JOIN imovel.ligacaoAguaSituacao ligacaoAguaSituacaoImovel "
					+ "INNER JOIN imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacaoImovel "
					+ "INNER JOIN imovel.consumoTarifa consumoTarifaImovel "
					+ "WHERE  cnt.id = :idConta ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", idConta.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de debito a cobrar a partir da tabela
	 * DEBITO_A_COBRAR com tipo de financiamento (FNTP) com o valor
	 * correspondente a parcelamento (PARCELAMENTO_AGUA ,PARCELAMENTO_ESGOTO
	 * ,PARCELAMENTO_SERVICO)
	 * 
	 * Utilizado pelo [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 02/11/2006
	 * 
	 * @param idImovel
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarDebitoACobrarParcelamento(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT dbac "
					+ "FROM DebitoACobrar as dbac "
					+ "INNER JOIN dbac.financiamentoTipo as fntp "
					+ "WHERE dbac.imovel.id = :idImovel "
					+ "AND (fntp.id = :parcAgua OR fntp.id = :parcEsgoto OR fntp.id = :parcServico) ";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					idImovel.intValue()).setInteger("parcAgua",
					FinanciamentoTipo.PARCELAMENTO_AGUA.intValue()).setInteger(
					"parcEsgoto",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO.intValue())
					.setInteger("parcServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO.intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Método que retorna uma colecao de debitos cobrados referente a pareclas
	 * do parcelamento a partir da tabela DEBITO_COBRADO com tipo de
	 * financiamento (FNTP) com o valor correspondente a parcelamento
	 * (PARCELAMENTO_AGUA ,PARCELAMENTO_ESGOTO ,PARCELAMENTO_SERVICO)
	 * 
	 * Utilizado pelo [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 02/11/2006
	 * 
	 * @param idConta
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarDebitoCobradoParcelamento(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT dbcb "
					+ "FROM DebitoCobrado as dbcb "
					+ "INNER JOIN dbcb.financiamentoTipo as fntp "
					+ "WHERE dbcb.conta.id = :idConta "
					+ "AND (fntp.id = :parcAgua OR fntp.id = :parcEsgoto OR fntp.id = :parcServico) ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("parcAgua",
					FinanciamentoTipo.PARCELAMENTO_AGUA.intValue()).setInteger(
					"parcEsgoto",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO.intValue())
					.setInteger("parcServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO.intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Seleciona as contas agrupando por imóvel
	 * 
	 * [UC0485] - Gerar Resumo dos Devedores Duvidosos
	 * 
	 * @author Rafael Pinto, Pedro Alexandre,Vivianne Sousa
	 * @date 22/11/2006, 21/07/2007,07/06/2010
	 * 
	 * @param anoMesReferenciaContabil
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> obterContaAgrupadasPorImovel(
			int anoMesReferenciaContabil, int idLocalidade, int idQuadra)
			throws ErroRepositorioException {

		Collection<Object[]> retornoConsulta = null;
		Collection<Conta> retorno = null;

		StatelessSession session = HibernateUtil.getStatelessSession();
		String consulta;

		try {
//			consulta = "select "
//					+ "cnta.cnta_id as col_0, "
//					+ "cnta.cnta_amreferenciaconta as col_1, "
//					+ "cnta.cnta_dtvencimentoconta as col_2, "
//					+ "cnta.cnta_vlagua as col_3, "
//					+ "cnta.cnta_vlesgoto as col_4, "
//					+ "cnta.cnta_vldebitos as col_5, "
//					+ "cnta.cnta_vlcreditos as col_6, "
//					+ "cnta.cnta_vlimpostos as col_7, "
//					+ "cnta.cnta_nnconsumoagua as col_8, "
//					+ "cnta.cnta_nnconsumoesgoto as col_9, "
//					+ "cnta.cnta_dtvalidadeconta as col_10, "
//					+ "cnta.cnta_dtrevisao as col_11, "
//					+ "cnta.cnta_amreferenciacontabil as col_12, "
//					+ "imov.imov_id as col_13, "
//					+ "imov.cbst_id as col_14, "
//					+ "cnta.cnta_amreferenciabaixacontabil as col_15 "
//					+ "from "
//					+ "faturamento.conta cnta "
//					+ "inner join cadastro.imovel imov on cnta.imov_id=imov.imov_id and imov.loca_id = :idLocalidade "
//					+ "where cnta.cnta_id in (select "
//					+ "distinct (cnta.cnta_id) "
//					+ "from "
//					+ "faturamento.conta_categoria ctcg "
//					+ "inner join faturamento.conta cnta on ctcg.catg_id<> :idCategoria and ctcg.cnta_id=cnta.cnta_id "
//					+ "inner join cadastro.imovel imov on cnta.imov_id=imov.imov_id and imov.loca_id = :idLocalidade "
//					+ "where cnta.loca_id=:idLocalidade and cnta.qdra_id = :idQuadra "
//					+ "and cnta.dcst_idatual in ( :normal , :incluida , :retificada) "
//					+ "and cnta.cnta_amreferenciaconta< :anoMesReferencia "
//					+ "and cnta.cnta_amreferenciabaixacontabil is null )";
//
//			retornoConsulta = session.createSQLQuery(consulta).addScalar(
//					"col_0", Hibernate.INTEGER).addScalar("col_1",
//					Hibernate.INTEGER).addScalar("col_2", Hibernate.DATE)
//					.addScalar("col_3", Hibernate.BIG_DECIMAL).addScalar(
//							"col_4", Hibernate.BIG_DECIMAL).addScalar("col_5",
//							Hibernate.BIG_DECIMAL).addScalar("col_6",
//							Hibernate.BIG_DECIMAL).addScalar("col_7",
//							Hibernate.BIG_DECIMAL).addScalar("col_8",
//							Hibernate.INTEGER).addScalar("col_9",
//							Hibernate.INTEGER).addScalar("col_10",
//							Hibernate.DATE).addScalar("col_11", Hibernate.DATE)
//					.addScalar("col_12", Hibernate.INTEGER).addScalar("col_13",
//							Hibernate.INTEGER).addScalar("col_14",
//							Hibernate.INTEGER).addScalar("col_15",
//							Hibernate.INTEGER).setInteger("idCategoria",
//							Categoria.PUBLICO).setInteger("idLocalidade",
//							idLocalidade).setInteger("idQuadra", idQuadra)
//					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
//					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
//					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
//					.setInteger("anoMesReferencia", anoMesReferenciaContabil)
//					// .setFirstResult(numeroPagina)
//					// .setMaxResults(25000)
//					.list();

			consulta = " select " 
			+ " distinct(cnta.cnta_id) as idConta, " //0
			+ " cnta.cnta_amreferenciaconta as referenciaConta," //1
			+ " cnta.cnta_dtvencimentoconta as dataVencimentoConta," //2
			+ " cnta.cnta_vlagua as valorAgua, " //3
			+ " cnta.cnta_vlesgoto as valorEsgoto," //4
			+ " cnta.cnta_vldebitos as valorDebitos," //5
			+ " cnta.cnta_vlcreditos as valorCreditos," //6
			+ " cnta.cnta_vlimpostos as valorImpostos," //7
			+ " cnta.cnta_nnconsumoagua as consumoAgua, " //8
			+ " cnta.cnta_nnconsumoesgoto as consumoEsgoto," //9
			+ " cnta.cnta_dtvalidadeconta as dadaValidadeConta," //10
			+ " cnta.cnta_dtrevisao as dataRevisao," //11
			+ " cnta.cnta_amreferenciacontabil as referenciaContabil," //12
			+ " cnta.imov_id as idImovel," //13
			+ " cnta.cnta_amreferenciabaixacontabil as referenciaBaixaContabil" //14
			+ " from faturamento.conta_categoria ctcg" 
			+ " inner join faturamento.conta cnta on ctcg.catg_id<> :idCategoria and ctcg.cnta_id=cnta.cnta_id" 
			+ " where" 
			+ " cnta.loca_id = :idLocalidade " 
			+ " and cnta.qdra_id = :idQuadra " 
			+ " and cnta.dcst_idatual in ( :normal , :incluida , :retificada) " 
			+ " and cnta.cnta_amreferenciaconta< :anoMesReferencia " 
			+ " and cnta.cnta_amreferenciabaixacontabil is null";
//			long t1 = System.currentTimeMillis();
			retornoConsulta = session.createSQLQuery(consulta)
			.addScalar("idConta", Hibernate.INTEGER)
			.addScalar("referenciaConta",	Hibernate.INTEGER)
			.addScalar("dataVencimentoConta", Hibernate.DATE)
			.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
			.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
			.addScalar("valorDebitos",	Hibernate.BIG_DECIMAL)
			.addScalar("valorCreditos",	Hibernate.BIG_DECIMAL)
			.addScalar("valorImpostos",	Hibernate.BIG_DECIMAL)
			.addScalar("consumoAgua",	Hibernate.INTEGER)
			.addScalar("consumoEsgoto",	Hibernate.INTEGER)
			.addScalar("dadaValidadeConta", Hibernate.DATE)
			.addScalar("dataRevisao", Hibernate.DATE)
			.addScalar("referenciaContabil", Hibernate.INTEGER)
			.addScalar("idImovel", Hibernate.INTEGER)
			.addScalar("referenciaBaixaContabil",Hibernate.INTEGER)
			.setInteger("idCategoria", Categoria.PUBLICO)
			.setInteger("idLocalidade", idLocalidade)
			.setInteger("idQuadra", idQuadra)
			.setInteger("normal", DebitoCreditoSituacao.NORMAL)
			.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
			.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
			.setInteger("anoMesReferencia", anoMesReferenciaContabil)
			.list();
			
//			long t2 = System.currentTimeMillis();
//			System.out.println("[tempo]obterContaAgrupadasPorImovel " + ( t2 - t1));
			if (retornoConsulta.size() > 0) {

				retorno = new ArrayList();

				Conta conta = null;
				Imovel imovel = null;

				for (Iterator iter = retornoConsulta.iterator(); iter.hasNext();) {

					Object[] element = (Object[]) iter.next();

					Integer idImovel = (Integer) element[13];

					conta = new Conta();
					conta.setId((Integer) element[0]);
					conta.setReferencia((Integer) element[1]);
					conta.setDataVencimentoConta((Date) element[2]);
					conta.setValorAgua((BigDecimal) element[3]);
					conta.setValorEsgoto((BigDecimal) element[4]);
					conta.setDebitos((BigDecimal) element[5]);
					conta.setValorCreditos((BigDecimal) element[6]);
					// conta.setValorImposto((BigDecimal) element[7]);
					conta.setConsumoAgua((Integer) element[8]);
					conta.setConsumoEsgoto((Integer) element[9]);
					conta.setDataValidadeConta((Date) element[10]);
					conta.setDataRevisao((Date) element[11]);
					conta.setReferenciaContabil((Integer) element[12]);
					conta.setReferenciaBaixaContabil((Integer) element[14]);

					imovel = new Imovel();
					imovel.setId(idImovel);
					conta.setImovel(imovel);

					retorno.add(conta);
					element = null;
				}
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * 
	 * 
	 * Utilizado pelo [UC0] Manter Conta
	 * 
	 * @author Rafael Santos
	 * @date 23/11/2006
	 * 
	 * @param idConta
	 * @param dataUltimaAlteracao
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Object pesquisarDataUltimaAlteracaoConta(Integer idConta)
			throws ErroRepositorioException {

		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT conta.ultimaAlteracao " + "FROM Conta conta "
					+ "WHERE conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * [SB0004] - Calcular Valor de Água e/ou Esgoto
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 04/12/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */
	public Object[] pesquisarParmsFaturamentoGrupo(Integer idImovel)
			throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT fatGrupo.id, fatGrupo.anoMesReferencia "
					+ "FROM Imovel imov " + "INNER JOIN imov.quadra qdr "
					+ "INNER JOIN qdr.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo fatGrupo "
					+ "WHERE imov.id = :idImovel ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * [SB0004] - Calcular Valor de Água e/ou Esgoto
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 04/12/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Date pesquisarDataRealizacaoFaturamentoAtividadeCronograma(
			Integer idFaturamentoGrupo, Integer idFaturamentoAtividade,
			Integer amReferencia) throws ErroRepositorioException {
		Date retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT ftac.dataRealizacao "
					+ "FROM FaturamentoAtividadeCronograma ftac "
					+ "LEFT JOIN ftac.faturamentoAtividade ftat "
					+ "LEFT JOIN ftac.faturamentoGrupoCronogramaMensal ftcm "
					+ "LEFT JOIN ftcm.faturamentoGrupo ftgr "
					+ "WHERE ftat.id = :idFaturamentoAtividade AND "
					+ "ftgr.id = :idFaturamentoGrupo AND "
					+ "ftcm.anoMesReferencia = :amReferencia ";

			retorno = (Date) session.createQuery(consulta).setInteger(
					"idFaturamentoAtividade", idFaturamentoAtividade)
					.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
					.setInteger("amReferencia", amReferencia).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Inserir Pagamentos
	 * 
	 * Pesquisa a conta digitada
	 * 
	 * @author Rafael Corrêa
	 * @date 07/12/2006
	 * 
	 * @param idImovel
	 * @param referenciaConta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarContaDigitada(String idImovel,
			String referenciaConta) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = " SELECT conta.id, conta.referencia, conta.valorAgua, "
					+ " conta.valorEsgoto, conta.debitos, conta.valorCreditos,conta.valorImposto, "
					+ " conta.localidade.id, dcsa.id, dcsa.descricaoAbreviada, conta.dataVencimentoConta "
					+ " FROM Conta conta " + " INNER JOIN conta.imovel imov "
					+ " INNER JOIN conta.debitoCreditoSituacaoAtual dcsa "
					+ " WHERE imov.id = :idImovel and "
					+ " conta.referencia = " + referenciaConta
					+ " and ( dcsa.id = " + DebitoCreditoSituacao.NORMAL
					+ " or dcsa.id = " + DebitoCreditoSituacao.RETIFICADA
					+ " or dcsa.id = " + DebitoCreditoSituacao.INCLUIDA + ")";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", new Integer(idImovel)).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0194] Inserir Credito a Realizar
	 * 
	 * Pesquisa a quantidade de contas e contas histórico para um imóvel em uma
	 * referência
	 * 
	 * @author Rafael Corrêa
	 * @date 14/08/2008
	 * 
	 * @param idImovel
	 * @param referenciaConta
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasEContasHistorico(Integer idImovel,
			Integer referenciaConta) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT "
					+ "  count(*) as qtd "
					+ " FROM "
					+ " ( "
					+ " SELECT "
					+ "  imov_id, "
					+ "  cnta_amreferenciaconta "
					+ " FROM "
					+ "  faturamento.conta "
					+ " UNION "
					+ " SELECT "
					+ "  imov_id, "
					+ "  cnhi_amreferenciaconta "
					+ " FROM "
					+ "  faturamento.conta_historico "
					+ " ) temp "
					+ " WHERE "
					+ "  temp.imov_id = :idImovel and temp.cnta_amreferenciaconta = :referenciaConta ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar(
					"qtd", Hibernate.INTEGER).setInteger("idImovel",
					new Integer(idImovel)).setInteger("referenciaConta",
					referenciaConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 12/12/2006
	 * 
	 * @param idImovel
	 *            Id do Imóvel
	 * @return cliente responsavel
	 */
	public Object pesquisarClienteResponsavel(Integer idImovel)
			throws ErroRepositorioException {

		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select cli.id from ClienteImovel cliImo "
					+ "inner join cliImo.clienteRelacaoTipo crt "
					+ "inner join cliImo.cliente cli "
					+ "inner join cliImo.imovel imo "
					+ "where imo.id = :idImovel AND "
					+ "crt.id = :idResponsavel AND "
					+ "cliImo.dataFimRelacao is null ";
			retorno = session.createQuery(consulta).setInteger("idImovel",
					idImovel).setInteger("idResponsavel",
					ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 27/12/2006
	 * 
	 * Pesquisar o Resumo Faturamento Simulação
	 * 
	 */
	public ResumoFaturamentoSimulacao pesquisarResumoFaturamentoSimulacao(
			ResumoFaturamentoSimulacao resumoFaturamentoSimulacao)
			throws ErroRepositorioException {

		ResumoFaturamentoSimulacao retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select resumoFaturamentoSimulacao from ResumoFaturamentoSimulacao resumoFaturamentoSimulacao "
					+ "where resumoFaturamentoSimulacao.anoMesReferencia = :anoMesReferencia and "
					+ "resumoFaturamentoSimulacao.faturamentoGrupo.id = :idFaturamentoGrupo and "
					+ "resumoFaturamentoSimulacao.localidade.id = :idLocalidade and "
					+ "resumoFaturamentoSimulacao.quadra.id = :idQuadra and "
					+ "resumoFaturamentoSimulacao.ligacaoAguaSituacao.id = :idLigacaoAguaSituacao and "
					+ "resumoFaturamentoSimulacao.ligacaoEsgotoSituacao.id = :idLigacaoEsgotoSituacao and "
					+ "resumoFaturamentoSimulacao.categoria.id = :idCategoria and "
					+ "resumoFaturamentoSimulacao.imovelPerfil.id = :idImovelPerfil and "
					+ "resumoFaturamentoSimulacao.indicadorDebitoConta = :indicadorDebitoConta and "
					+ "resumoFaturamentoSimulacao.gerenciaRegional.id = :idGerenciaRegional and "
					+ "resumoFaturamentoSimulacao.setorComercial.id = :idSetorComercial and "
					+ "resumoFaturamentoSimulacao.rota.id = :idRota and "
					+ "(resumoFaturamentoSimulacao.esferaPoder.id = :idEsferaPoder or (resumoFaturamentoSimulacao.esferaPoder.id is null and :idEsferaPoder is null)) ";

			retorno = (ResumoFaturamentoSimulacao) session
					.createQuery(consulta)
					.setInteger(
							"anoMesReferencia",
							resumoFaturamentoSimulacao.getAnoMesReferencia()
									.intValue())
					.setInteger(
							"idFaturamentoGrupo",
							resumoFaturamentoSimulacao.getFaturamentoGrupo()
									.getId().intValue())
					.setInteger(
							"idLocalidade",
							resumoFaturamentoSimulacao.getLocalidade().getId()
									.intValue())
					.setInteger(
							"idQuadra",
							resumoFaturamentoSimulacao.getQuadra().getId()
									.intValue())
					.setInteger(
							"idLigacaoAguaSituacao",
							resumoFaturamentoSimulacao.getLigacaoAguaSituacao()
									.getId().intValue())
					.setInteger(
							"idLigacaoEsgotoSituacao",
							resumoFaturamentoSimulacao
									.getLigacaoEsgotoSituacao().getId()
									.intValue())
					.setInteger(
							"idCategoria",
							resumoFaturamentoSimulacao.getCategoria().getId()
									.intValue())
					.setInteger(
							"idImovelPerfil",
							resumoFaturamentoSimulacao.getImovelPerfil()
									.getId().intValue())
					.setInteger(
							"indicadorDebitoConta",
							resumoFaturamentoSimulacao
									.getIndicadorDebitoConta().shortValue())
					.setInteger(
							"idGerenciaRegional",
							resumoFaturamentoSimulacao.getGerenciaRegional()
									.getId().intValue())
					.setInteger(
							"idSetorComercial",
							resumoFaturamentoSimulacao.getSetorComercial()
									.getId().intValue())
					.setInteger(
							"idRota",
							resumoFaturamentoSimulacao.getRota().getId()
									.intValue())
					.setInteger(
							"idEsferaPoder",
							(resumoFaturamentoSimulacao.getEsferaPoder() != null) ? resumoFaturamentoSimulacao
									.getEsferaPoder().getId().intValue()
									: -1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 24/03/2008
	 * 
	 * Deleta CONTA_CATEGORIA_CONSUMO_FAIXA
	 */
	public void apagarContaCategoriaConsumoFaixa(
			ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.conta_catg_cons_fx where cnta_id in ";
			
			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 24/03/2008
	 * 
	 * Deleta CONTA_CATEGORIA
	 */
	public void apagarContaCategoria(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.conta_categoria where cnta_id in  ";

			
			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 24/03/2008
	 * 
	 * Deleta CONTA_IMPRESSAO
	 */
	public void apagarContaImpressao(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		
		
		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.conta_impressao where cnta_id in ";
			
			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
					
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 24/03/2008
	 * 
	 * Deleta CLIENTE_CONTA
	 */
	public void apagarClienteConta(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = " delete from cadastro.cliente_conta where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
				
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Deleta CONTA_IMPOSTOS_DEDUZIDOS
	 */
	public void apagarContaImpostosDeduzidos(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.conta_impostos_deduzidos where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Deleta DEBITO_AUTOMATICO_MOVIMENTO
	 * 
	 */
	public void apagarDebitoAutomaticoMovimento(
			ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = " delete from arrecadacao.debito_auto_movimento where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Deleta DEBITO_COBRADO_CATEGORIA
	 */
	public void apagarDebitoCobradoCategoria(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = " delete from faturamento.debito_cobrado_categoria where dbcb_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select dbcb.dbcb_id "
							+ " from faturamento.debito_cobrado dbcb "
							+ " inner join faturamento.conta cnta on ( cnta.cnta_id = dbcb.cnta_id ) "
							+ " inner join cadastro.imovel imov on ( imov.imov_id = cnta.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select dbcb.dbcb_id "
							+ " from faturamento.debito_cobrado dbcb "
							+ " inner join faturamento.conta cnta on ( cnta.cnta_id = dbcb.cnta_id ) "
							+ " inner join cadastro.imovel imov on ( imov.imov_id = cnta.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							/**
							 * @autor Adriana Muniz
							 * 19/07/2012
							 * 
							 * Acréscimo da parametro cnta.dcst_idatual na query.
							 * */
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS PARA FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS PARA PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS PARA FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS PARA PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select dbcb.dbcb_id "
						+ " from faturamento.debito_cobrado dbcb "
						+ " inner join faturamento.conta cnta on ( cnta.cnta_id = dbcb.cnta_id ) "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Deleta DEBITO_COBRADO
	 */
	public void apagarDebitoCobrado(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.debito_cobrado where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS PARA FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS PARA PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS PARA FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS PARA PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Deleta CREDITO_REALIZADO_CATEGORIA
	 */
	public void apagarCreditoRealizadoCategoria(
			ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.cred_realizado_catg where crrz_id in ";

			
			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select crrz.crrz_id "
							+ " from faturamento.credito_realizado crrz "
							+ " inner join faturamento.conta cnta on ( cnta.cnta_id = crrz.cnta_id ) "
							+ " inner join cadastro.imovel imov on ( imov.imov_id = cnta.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select crrz.crrz_id "
							+ " from faturamento.credito_realizado crrz "
							+ " inner join faturamento.conta cnta on ( cnta.cnta_id = crrz.cnta_id ) "
							+ " inner join cadastro.imovel imov on ( imov.imov_id = cnta.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select crrz.crrz_id "
						+ " from faturamento.credito_realizado crrz "
						+ " inner join faturamento.conta cnta on ( cnta.cnta_id = crrz.cnta_id ) "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Deleta CREDITO_REALIZADO
	 */
	public void apagarCreditoRealizado(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.credito_realizado where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS PARA FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS PARA PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS PARA FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS PARA PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Update DEBITO_A_COBRAR
	 */
	public void atualizarDebitoACobrar(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		String atualizar = null;
		try {

			Connection jdbcCon = session.connection();

			atualizar = " update faturamento.debito_a_cobrar set dbac_nnprestacaocobradas=dbac_nnprestacaocobradas - 1 "
					+ " where dbac_amreferenciaprestacao >= ? and dbac_nnprestacaocobradas > 0 and imov_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					atualizar = atualizar
							+ " (select imov.imov_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					atualizar = atualizar
							+ " (select imov.imov_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(atualizar);
				st.setInt(1, helper.getAnoMesFaturamento());
				st.setInt(2, helper.getRota().getId().intValue());
				st.setInt(3, helper.getAnoMesFaturamento());
				st.setInt(4, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(6, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(5, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				atualizar = atualizar
						+ " (select cnta.imov_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
				
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(atualizar);
				st.setInt(1, helper.getAnoMesFaturamento());
				st.setInt(2, helper.getIdImovel().intValue());
				st.setInt(3, helper.getAnoMesFaturamento());
				st.setInt(4, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(6, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Update CREDITO_A_REALIZAR
	 */
	public void atualizarCreditoARealizar(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement stUpdateParcelas = null;
		PreparedStatement stUpdateResidual = null;
		String atualizar = "";
		String updateParcelas = "";
		String updateResidual = "";

		try {

			Connection jdbcCon = session.connection();

			updateParcelas = "update faturamento.credito_a_realizar set crar_nnprestacaorealizadas=crar_nnprestacaorealizadas - 1, "
					+ " crar_tmultimaalteracao = ? "
					+ " where crar_amreferenciaprestacao >= ? and crar_nnprestacaorealizadas > 0 "
					+ " and (crar_nnprestacaocredito > 1 or (crar_nnprestacaocredito = 1 and crar_vlresidualmesanterior = 0.00)) "
					+ " and imov_id in ";
			
			updateResidual = "update faturamento.credito_a_realizar set crar_vlresidualmesanterior = coalesce(crar_vlresidualconcedidomes,0), "
				+ "crar_vlresidualconcedidomes = null, crar_tmultimaalteracao = ? "
				+ " where crar_nnprestacaorealizadas > 0 and imov_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					atualizar = atualizar
							+ " (select imov.imov_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					atualizar = atualizar
							+ " (select imov.imov_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				//UPDATE DAS PARCELAS
				updateParcelas = updateParcelas + atualizar;
				
				stUpdateParcelas = jdbcCon.prepareStatement(updateParcelas);
				stUpdateParcelas.setTimestamp(1, Util.getSQLTimesTemp(new Date()));
				stUpdateParcelas.setInt(2, helper.getAnoMesFaturamento());
				stUpdateParcelas.setInt(3, helper.getRota().getId().intValue());
				stUpdateParcelas.setInt(4, helper.getAnoMesFaturamento());
				stUpdateParcelas.setInt(5, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					stUpdateParcelas.setDate(6, Util.getSQLDate(helper.getDataEmissaoInicial()));
					stUpdateParcelas.setDate(7, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					stUpdateParcelas.setInt(6, helper.getFaturamentoGrupo().getId());
				}
				
				
				//UPDATE VALOR RESIDUAL
				updateResidual = updateResidual + atualizar;
				
				stUpdateResidual = jdbcCon.prepareStatement(updateResidual);
				stUpdateResidual.setTimestamp(1, Util.getSQLTimesTemp(new Date()));
				stUpdateResidual.setInt(2, helper.getRota().getId().intValue());
				stUpdateResidual.setInt(3, helper.getAnoMesFaturamento());
				stUpdateResidual.setInt(4, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					stUpdateResidual.setDate(5, Util.getSQLDate(helper.getDataEmissaoInicial()));
					stUpdateResidual.setDate(6, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					stUpdateResidual.setInt(5, helper.getFaturamentoGrupo().getId());
				}
				
			}
			else{
				
				atualizar = atualizar
						+ " (select cnta.imov_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
				
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				
				//UPDATE DAS PARCELAS
				updateParcelas = updateParcelas + atualizar;
				
				stUpdateParcelas = jdbcCon.prepareStatement(updateParcelas);
				stUpdateParcelas.setTimestamp(1, Util.getSQLTimesTemp(new Date()));
				stUpdateParcelas.setInt(2, helper.getAnoMesFaturamento());
				stUpdateParcelas.setInt(3, helper.getIdImovel().intValue());
				stUpdateParcelas.setInt(4, helper.getAnoMesFaturamento());
				stUpdateParcelas.setInt(5, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					stUpdateParcelas.setDate(6, Util.getSQLDate(helper.getDataEmissaoInicial()));
					stUpdateParcelas.setDate(7, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UPDATE VALOR RESIDUAL
				updateResidual = updateResidual + atualizar;
				
				stUpdateResidual = jdbcCon.prepareStatement(updateResidual);
				stUpdateResidual.setTimestamp(1, Util.getSQLTimesTemp(new Date()));
				stUpdateResidual.setInt(2, helper.getIdImovel().intValue());
				stUpdateResidual.setInt(3, helper.getAnoMesFaturamento());
				stUpdateResidual.setInt(4, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					stUpdateResidual.setDate(5, Util.getSQLDate(helper.getDataEmissaoInicial()));
					stUpdateResidual.setDate(6, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			stUpdateParcelas.executeUpdate();
			
			stUpdateResidual.executeUpdate();
			
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != stUpdateParcelas){
				try {
					stUpdateParcelas.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			}
			
			if (null != stUpdateResidual){
				try {
					stUpdateResidual.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Update CONTA_GERAL
	 */
	public void atualizarContaGeral(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		String atualizar = null;

		try {

			Connection jdbcCon = session.connection();

			atualizar = "update faturamento.conta_geral set cntg_ichistorico=3 where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					atualizar = atualizar
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					atualizar = atualizar
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(atualizar);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				atualizar = atualizar
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(atualizar);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Deleta CONTA
	 */
	public void apagarConta(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String atualizar = null;

		PreparedStatement st = null;
		try {

			Connection jdbcCon = session.connection();

			atualizar = "update arrecadacao.pagamento set cnta_id=null where cnta_id in ";

			
			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					atualizar = atualizar
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					atualizar = atualizar
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(atualizar);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				atualizar = atualizar
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(atualizar);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}
			st.executeUpdate();

			st = null;

			String delete = "delete from faturamento.conta where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ?  ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						delete = delete + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					delete = delete + ")";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Rafael Santos, Raphael Rossiter Data: 02/01/2007, 25/03/2008
	 * 
	 * Delete CONTA_GERAL
	 */
	public void apagarContaGeral(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String atualizar = null;

		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			atualizar = "update cobranca.parcelamento_item set cnta_id=null where cnta_id in "
					+ "(select cnta_id from faturamento.conta_geral where cntg_ichistorico=3) ";

			st = jdbcCon.prepareStatement(atualizar);
			st.executeUpdate();

			// Colocado por Raphael Rossiter em 01/03/2007
			st = null;

			String delete = "delete from cobranca.cobranca_documento_item where cnta_id in "
					+ " (select cnta_id from faturamento.conta_geral where cntg_ichistorico=3) ";

			st = jdbcCon.prepareStatement(delete);

			st.executeUpdate();

			// =========================================================================================

			/*
			 * Comentado por Raphael Rossiter em 20/02/2008 - Analista: Aryed
			 * Lins
			 */
			/*
			 * st = null;
			 * 
			 * delete = "delete from faturamento.conta_geral where
			 * cntg_ichistorico=3 ";
			 * 
			 * st = jdbcCon.prepareStatement(delete);
			 * 
			 * st.executeUpdate();
			 */

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC113] Faturar Grupo Faturamento
	 * 
	 * Retorna a quantidade de contas existentes para uma rota em um determinado
	 * anoMês de referência e de acordo com a situação atual recebida.
	 * 
	 * @author Rafael Santos, Raphael Rossiter
	 * @date 02/01/2007, 24/03/2008
	 * 
	 * @param Integer
	 *            anoMesFaturamento
	 * @param Integer
	 *            idRota
	 * @param Integer
	 *            debitoCreditoSituacaoAtual
	 */
	public Integer quantidadeContasRota(Integer anoMesFaturamento, Rota rota,
			Integer debitoCreditoSituacaoAtual, Integer idImovel) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String consulta = null;

		Integer retorno = null;

		try {
			consulta = "SELECT count(conta.id) FROM Conta conta ";

			/*
			 * Caso a rota não esteja com o indicador de rota alternativa ativo;
			 * a pesquisa dos imóveis será feita a partir de sua quadra.
			 */
			if(idImovel == null || idImovel.equals("")){
				if (!rota.getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					consulta = consulta
							+ "INNER JOIN conta.quadraConta quadra "
							+ "INNER JOIN quadra.rota rota "
							+ "INNER JOIN conta.debitoCreditoSituacaoAtual situacaoAtual "
							+ "WHERE rota.id = :idRota AND conta.referencia = :anoMesFaturamento "
							+ "AND situacaoAtual.id = :debitoCreditoSituacaoAtual ";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					consulta = consulta
							+ "INNER JOIN conta.imovel imovel "
							+ "INNER JOIN imovel.rotaAlternativa rotaAlternativa "
							+ "INNER JOIN conta.debitoCreditoSituacaoAtual situacaoAtual "
							+ "WHERE rotaAlternativa.id = :idRota AND conta.referencia = :anoMesFaturamento "
							+ "AND situacaoAtual.id = :debitoCreditoSituacaoAtual ";
				}
				

			    retorno = (Integer) session.createQuery(consulta).setInteger(
					"anoMesFaturamento", anoMesFaturamento).setInteger(
					"idRota", rota.getId().intValue()).setInteger(
					"debitoCreditoSituacaoAtual", debitoCreditoSituacaoAtual)
					.uniqueResult();
			}else{
				consulta = consulta
				+ "INNER JOIN conta.debitoCreditoSituacaoAtual situacaoAtual "
				+ "INNER JOIN conta.imovel imovel "
				+ "WHERE conta.imovel = :idImovel AND conta.referencia = :anoMesFaturamento "
				+ "AND situacaoAtual.id = :debitoCreditoSituacaoAtual ";
				
				retorno = (Integer) session.createQuery(consulta).setInteger(
						"anoMesFaturamento", anoMesFaturamento).setInteger(
						"idImovel", idImovel).setInteger(
						"debitoCreditoSituacaoAtual", debitoCreditoSituacaoAtual)
						.uniqueResult();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Collection pesquisarConsumoTarifaCategoriaPorSubCategoria(
			ConsumoTarifaVigencia consumoTarifaVigencia, Categoria categoria,
			Subcategoria subCategoria) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ctc from ConsumoTarifaCategoria ctc "
					+ "where ctc.consumoTarifaVigencia.id = :idConsumoTarifaVigencia "
					+ "and ctc.categoria.id = :idCategoria "
					+ "and ctc.subCategoria.id = :idSubCategoria ";

			retorno = session.createQuery(consulta).setInteger(
					"idConsumoTarifaVigencia",
					consumoTarifaVigencia.getId().intValue()).setInteger(
					"idCategoria", categoria.getId()).setInteger(
					"idSubCategoria", subCategoria.getId()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * 
	 * @author Rafael Pinto
	 * @date 20/05/2011
	 * 
	 * @param idImovel Integer
	 * @param dataFaturamento Date
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarConsumoTarifaVigenciaImovel(
		Integer idImovel, Date dataFaturamento) 
		throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			
			consulta = "select cstv_id,max(cstv_dtvigencia) as dataVigencia "
				+ "from faturamento.consumo_tarifa_vigencia consumoTarifaVigencia "
				+ "inner join faturamento.consumo_tarifa consumoTarifa on consumoTarifa.cstf_id = consumoTarifaVigencia.cstf_id "
				+ "inner join cadastro.imovel imovel on  imovel.cstf_id = consumoTarifa.cstf_id "
				+ "where imovel.imov_id = :idImovel  "
				+ "and consumoTarifaVigencia.cstv_dtvigencia < :dataFaturamento "
				+ "group by cstv_id "
				+ "order by 2 desc ";
			
			retorno = session.createSQLQuery(consulta).
				addScalar("cstv_id", Hibernate.INTEGER).
				addScalar("dataVigencia", Hibernate.DATE).
				setInteger("idImovel", idImovel).
				setDate("dataFaturamento",dataFaturamento).
				setMaxResults(1).
				list();			

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * Deleta as faturas e os items da fatura por cliente responsável e ano/mês
	 * de referência.
	 * 
	 * @author Pedro Alexandre,Sávio Luiz
	 * @date 04/01/2007,19/11/2007
	 * 
	 * @param idCliente
	 * @param anoMesReferenciaFatura
	 * @throws ErroRepositorioException
	 */
	public void deletarFaturaClienteResponsavel(Integer idCliente,
			Integer anoMesReferenciaFatura,
			Integer anoMesReferenciaFaturaAntecipada)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			String deleteFaturaItem = "delete FaturaItem as fitm "
					+ "where fitm.fatura.id in " + "(select fatu.id "
					+ "from Fatura fatu " + "where ";
			if (anoMesReferenciaFaturaAntecipada != null) {
				deleteFaturaItem += "fatu.anoMesReferencia ="
						+ anoMesReferenciaFatura
						+ " AND fatu.anoMesReferencia ="
						+ anoMesReferenciaFaturaAntecipada;
			} else {
				deleteFaturaItem += "fatu.anoMesReferencia ="
						+ anoMesReferenciaFatura;
			}

			deleteFaturaItem += " and fatu.cliente.id =:idCliente)";

			session.createQuery(deleteFaturaItem).setInteger("idCliente",
					idCliente).executeUpdate();

			String deleteFatura = "delete from Fatura fatu " + "where ";
			if (anoMesReferenciaFaturaAntecipada != null) {
				deleteFatura += "fatu.anoMesReferencia ="
						+ anoMesReferenciaFatura
						+ " AND fatu.anoMesReferencia ="
						+ anoMesReferenciaFaturaAntecipada;
			} else {
				deleteFatura += "fatu.anoMesReferencia ="
						+ anoMesReferenciaFatura;
			}

			deleteFatura += " and fatu.cliente.id =:idCliente";

			session.createQuery(deleteFatura)
					.setInteger("idCliente", idCliente).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	public void removerFaturamentoGrupoAtividades(
			Integer idFaturamentoGrupoMensal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;
		try {

			Connection jdbcCon = session.connection();

			st = null;

			String deleteFatRota = "delete from faturamento.fatur_ativ_cron_rota "
					+ " where ftac_id in ("
					+ " select distinct(facr.ftac_id)"
					+ " from faturamento.fatur_ativ_cron_rota facr"
					+ " inner join faturamento.fatur_ativ_cronograma ftac on ftac.ftac_id = facr.ftac_id"
					+ " inner join faturamento.fatur_grupo_crg_mensal fgcm on fgcm.ftcm_id = ftac.ftcm_id"
					+ " where fgcm.ftcm_id = " + idFaturamentoGrupoMensal + ")";

			st = jdbcCon.prepareStatement(deleteFatRota);

			st.executeUpdate();

			st = null;

			String deleteFatAti = "delete from faturamento.fatur_ativ_cronograma"
					+ " where ftcm_id = " + idFaturamentoGrupoMensal;

			st = jdbcCon.prepareStatement(deleteFatAti);

			st.executeUpdate();

			st = null;

			String deleteGruMen = "delete from faturamento.fatur_grupo_crg_mensal"
					+ " where ftcm_id = " + idFaturamentoGrupoMensal;

			st = jdbcCon.prepareStatement(deleteGruMen);

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Pesquisar os ids das localidades para encerrar o faturamento do ano/mês
	 * de referência corrente.
	 * 
	 * @author Pedro Alexandre
	 * @date 05/01/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsLocalidadeParaEncerrarFaturamento()
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select loca_id as localidade from faturamento.conta "
					+ "union "
					+ "select loca_id as localidade from faturamento.debito_a_cobrar "
					+ "union "
					+ "select loca_id as localidade from faturamento.credito_a_realizar "
					+ "union "
					+ "select loca_id as localidade from faturamento.guia_pagamento ";
			// + "order by localidade";

			retorno = session.createSQLQuery(consulta).addScalar("localidade",
					Hibernate.INTEGER).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar os ids das localidades para gerar o resumo das
	 * ligações/economias.
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/01/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarIdsLocalidadeParaGerarResumoLigacoesEconomias()
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select distinct (imovel.localidade.id) from Imovel imovel";

			retorno = session.createQuery(consulta).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Recupera os dados da conta p emitir a 2ª via [UC0482]Emitir 2ª Via de
	 * Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 08/01/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaERota(Integer idConta)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT "
					+ " new "
					+ EmitirContaHelper.class.getName()
					+ " ( "
					+ "cnt.id, "
					+ "cli.nome, "
					+ "cli.cpf, "
					+ "cli.cnpj, "
					+ "cnt.dataVencimentoConta, "
					+ "cnt.referencia, "
					+ "cnt.digitoVerificadorConta, "
					+ "cnt.codigoSetorComercial, "
					+ "cnt.quadra, "
					+ "cnt.lote, "
					+ "cnt.subLote, "
					+ "cnt.consumoAgua, "
					+ "cnt.consumoEsgoto, "
					+ "cnt.valorAgua, "
					+ "cnt.valorEsgoto, "
					+ "cnt.debitos, "
					+ "cnt.valorCreditos, "
					+ "cnt.valorImposto, "
					+ "cnt.dataValidadeConta, "
					+ "imovel.id, "
					+ "loc.id, "
					+ "gerenciaRegional.id, "
					+ "gerenciaRegional.nome, "
					+ "ligacaoAguaSituacao.id, "
					+ "ligacaoEsgotoSituacao.id, "
					+ "imovelPerfil.id, "
					+ "setorComercial.id, "
					+ "faturamentoGrupo.id, "
					+ "emp.id, "
					+ "loc.descricao, "
					+ "ligacaoAguaSituacao.descricao, "
					+ "ligacaoEsgotoSituacao.descricao, "
					+ "cnt.percentualEsgoto, "
					+ "rota.codigo, "
					+ "imovel.numeroSequencialRota, "
					+ "hidrometro.numero, "
					+ "debitoCreditoSituacaoAtual.id, "
					+ "imovel.nomeImovel ) "
					+ "from ClienteConta cliCnt "
					+ "RIGHT JOIN cliCnt.conta cnt "
					+ "LEFT JOIN cliCnt.clienteRelacaoTipo crt "
					+ "LEFT JOIN cliCnt.cliente cli "
					+ "LEFT JOIN cnt.contaMotivoRevisao cmr "
					+ "LEFT JOIN cnt.quadraConta quadraConta "
					+ "LEFT JOIN cnt.localidade loc "
					+ "LEFT JOIN loc.gerenciaRegional gerenciaRegional "
					+ "LEFT JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "LEFT JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "LEFT JOIN cnt.imovelPerfil imovelPerfil "
					+ "LEFT JOIN quadraConta.rota rota "
					+ "LEFT JOIN rota.empresa emp "
					+ "LEFT JOIN quadraConta.setorComercial setorComercial "
					+ "LEFT JOIN rota.faturamentoGrupo faturamentoGrupo "
					+ "LEFT JOIN cnt.imovel imovel "
					+ "LEFT JOIN imovel.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN hih.hidrometro hidrometro "
					+ "LEFT JOIN cnt.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "WHERE  cnt.id = :idConta "
					+ "AND  cliCnt.indicadorNomeConta = 1 "
					+ "ORDER BY cnt.referencia,emp.id,loc.id,cnt.codigoSetorComercial,"
					+ "cnt.quadra,cnt.lote,cnt.subLote";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição
	 * Individualizada
	 * 
	 * @author Vivianne Sousa
	 * @date 09/01/2007
	 * 
	 * @param filtroMedicaoHistoricoSql
	 * @param anoMesfaturamentoGrupo
	 * @throws ControladorException
	 */

	public Collection pesquisarIdImovelCondominioLigacoesMedicaoIndividualizada(
			FiltroMedicaoHistoricoSql filtroMedicaoHistoricoSql,
			String anoMesfaturamentoGrupo) throws ErroRepositorioException {

		Collection retorno = null;

		Collection medicaohistoricoParametros = filtroMedicaoHistoricoSql
				.getParametros();

		Session session = HibernateUtil.getSession();

		String sql = "";

		if (!medicaohistoricoParametros.isEmpty()
				&& medicaohistoricoParametros.size() >= 1) {

			sql = "select imovel.imov_id as idImovel,"// 0
					+ " imovel.loca_id as idLocalidade," // 01
					+ " localidade.loca_nmlocalidade as nomeLocalidade," // 02
					+ " imovel.poco_id as idPoco" // 03
					+ " from cadastro.imovel imovel"
					+ " inner join cadastro.localidade localidade on imovel.loca_id = localidade.loca_id"
					+ " inner join micromedicao.consumo_historico consumoHistorico on imovel.imov_id=consumoHistorico.imov_id and consumoHistorico.cshi_amfaturamento = "
					+ anoMesfaturamentoGrupo
					+ " and consumoHistorico.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA
					+ " inner join micromedicao.medicao_historico medicaoHistorico on  consumoHistorico.imov_id=medicaoHistorico.lagu_id and medicaoHistorico.mdhi_amleitura = "
					+ anoMesfaturamentoGrupo
					+ " and medicaoHistorico.medt_id = "
					+ LigacaoTipo.LIGACAO_AGUA
					+ " left outer join cadastro.imovel_subcategoria imovelSubcategoria on imovel.imov_id=imovelSubcategoria.imov_id  left outer join cadastro.quadra quadra on imovel.qdra_id=quadra.qdra_id"
					+ " left outer join cadastro.setor_comercial setorComercial on imovel.stcm_id=setorComercial.stcm_id  left outer join micromedicao.rota rota on quadra.rota_id=rota.rota_id"
					+ " left outer join faturamento.faturamento_grupo faturamentoGrupo on rota.ftgr_id=faturamentoGrupo.ftgr_id  left outer join cadastro.empresa empresa on rota.empr_id=empresa.empr_id"
					+ " left outer join cadastro.imovel_perfil imovelPerfil on imovel.iper_id=imovelPerfil.iper_id"
					+ " left outer join cadastro.subcategoria subcategoria on imovelSubcategoria.scat_id=subcategoria.scat_id"
					+ " left outer join micromedicao.consumo_anormalidade consumoAnormalidade on consumoHistorico.csan_id=consumoAnormalidade.csan_id"
					+ " left outer join cadastro.categoria categoria on subcategoria.catg_id=categoria.catg_id"
					+ " left outer join micromedicao.medicao_tipo medicaoTipo on medicaoHistorico.medt_id=medicaoTipo.medt_id"
					+ " left outer join micromedicao.leitura_anormalidade leituraAnormalidadeFaturamento on medicaohistorico.ltan_idleitanormfatmt=leituraAnormalidadeFaturamento.ltan_id"
					+ " where ";

			String sqlSegundaParte = " select  imovel.imov_id as idImovel," // 0
					+ " imovel.loca_id as idLocalidade," // 01
					+ " localidade.loca_nmlocalidade as nomeLocalidade," // 02
					+ " imovel.poco_id as idPoco" // 03
					+ " from cadastro.imovel imovel"
					+ " inner join cadastro.localidade localidade on imovel.loca_id = localidade.loca_id"
					+ " inner join micromedicao.consumo_historico consumoHistorico on imovel.imov_id=consumoHistorico.imov_id and consumoHistorico.cshi_amfaturamento =  "
					+ anoMesfaturamentoGrupo
					+ "  and consumoHistorico.lgti_id = "
					+ LigacaoTipo.LIGACAO_ESGOTO
					+ " inner join micromedicao.medicao_historico medicaoHistorico on  consumoHistorico.imov_id=medicaoHistorico.imov_id and medicaoHistorico.mdhi_amleitura =  "
					+ anoMesfaturamentoGrupo
					+ " and medicaoHistorico.medt_id = "
					+ LigacaoTipo.LIGACAO_ESGOTO
					+ " left outer join cadastro.imovel_subcategoria imovelSubcategoria on imovel.imov_id=imovelSubcategoria.imov_id  left outer join cadastro.quadra quadra on imovel.qdra_id=quadra.qdra_id "
					+ " left outer join cadastro.setor_comercial setorComercial on imovel.stcm_id=setorComercial.stcm_id  left outer join micromedicao.rota rota on quadra.rota_id=rota.rota_id"
					+ " left outer join faturamento.faturamento_grupo faturamentoGrupo on rota.ftgr_id=faturamentoGrupo.ftgr_id  left outer join cadastro.empresa empresa on rota.empr_id=empresa.empr_id"
					+ " left outer join cadastro.imovel_perfil imovelPerfil on imovel.iper_id=imovelPerfil.iper_id"
					+ " left outer join cadastro.subcategoria subcategoria on imovelSubcategoria.scat_id=subcategoria.scat_id"
					+ " left outer join micromedicao.consumo_anormalidade consumoAnormalidade on consumoHistorico.csan_id=consumoAnormalidade.csan_id"
					+ " left outer join cadastro.categoria categoria on subcategoria.catg_id=categoria.catg_id"
					+ " left outer join micromedicao.medicao_tipo medicaoTipo on medicaoHistorico.medt_id=medicaoTipo.medt_id"
					+ " left outer join micromedicao.leitura_anormalidade leituraAnormalidadeFaturamento on medicaohistorico.ltan_idleitanormfatmt=leituraAnormalidadeFaturamento.ltan_id"
					+ " where ";

			Iterator iteratorImovelSub = medicaohistoricoParametros.iterator();
			while (iteratorImovelSub.hasNext()) {
				FiltroParametro filtroParametro = (FiltroParametro) iteratorImovelSub
						.next();

				if (filtroParametro instanceof Intervalo) {

					Intervalo intervalo = ((Intervalo) filtroParametro);

					sql = sql + " (quadra.qdra_nnquadra between "
							+ intervalo.getIntervaloInicial() + " and "
							+ intervalo.getIntervaloFinal() + ") and ";

					sqlSegundaParte = sqlSegundaParte
							+ " (quadra.qdra_nnquadra between "
							+ intervalo.getIntervaloInicial() + " and "
							+ intervalo.getIntervaloFinal() + ") and ";

				}

				if (filtroParametro instanceof ParametroSimples) {
					ParametroSimples parametroSimples = ((ParametroSimples) filtroParametro);

					if (parametroSimples
							.getNomeAtributo()
							.trim()
							.equalsIgnoreCase(
									FiltroMedicaoHistoricoSql.IMOVEL_CONDOMINIO_ID)) {

						sql = sql + " (" + parametroSimples.getNomeAtributo()
								+ " = " + parametroSimples.getValor() + " and ";

						sql = Util.removerUltimosCaracteres(sql, 4);
						sql = sql + " or imovel.imov_id " + " = "
								+ parametroSimples.getValor() + ") and ";

						sqlSegundaParte = sqlSegundaParte + " ("
								+ parametroSimples.getNomeAtributo() + " = "
								+ parametroSimples.getValor() + " and ";

						sqlSegundaParte = Util.removerUltimosCaracteres(
								sqlSegundaParte, 4);
						sqlSegundaParte = sqlSegundaParte
								+ " or imovel.imov_id " + " = "
								+ parametroSimples.getValor() + ") and ";

					} else if (parametroSimples
							.getNomeAtributo()
							.trim()
							.equalsIgnoreCase(
									FiltroMedicaoHistoricoSql.MH_INDICADOR_ANALISADO)) {

						if (parametroSimples.getValor().equals(
								"" + ConstantesSistema.INDICADOR_USO_ATIVO)) {
							sql = sql
									+ " ("
									+ parametroSimples.getNomeAtributo()
									+ " = "
									+ MedicaoHistorico.INDICADOR_ANALISADO_SIM
									+ " or "
									+ parametroSimples.getNomeAtributo()
									+ " = "
									+ MedicaoHistorico.INDICADOR_ANALISADO_ATUALIZADO
									+ ")" + " and ";

							sqlSegundaParte = sqlSegundaParte
									+ " ("
									+ parametroSimples.getNomeAtributo()
									+ " = "
									+ MedicaoHistorico.INDICADOR_ANALISADO_SIM
									+ " or "
									+ parametroSimples.getNomeAtributo()
									+ " = "
									+ MedicaoHistorico.INDICADOR_ANALISADO_ATUALIZADO
									+ ") " + " and ";
						} else {
							sql = sql + parametroSimples.getNomeAtributo()
									+ " = "
									+ MedicaoHistorico.INDICADOR_ANALISADO_NAO
									+ " and ";

							sqlSegundaParte = sqlSegundaParte
									+ parametroSimples.getNomeAtributo()
									+ " = "
									+ MedicaoHistorico.INDICADOR_ANALISADO_NAO
									+ " and ";
						}

					} else if (parametroSimples.getNomeAtributo().trim()
							.equalsIgnoreCase(
									FiltroMedicaoHistoricoSql.PERFIL_IMOVEL)) {
						sql = sql + parametroSimples.getNomeAtributo()
								+ " in( " + parametroSimples.getValor()
								+ " ) and ";

						sqlSegundaParte = sqlSegundaParte
								+ parametroSimples.getNomeAtributo() + " in( "
								+ parametroSimples.getValor() + " ) and ";
					} else {
						sql = sql + parametroSimples.getNomeAtributo() + " = "
								+ parametroSimples.getValor() + " and ";

						sqlSegundaParte = sqlSegundaParte
								+ parametroSimples.getNomeAtributo() + " = "
								+ parametroSimples.getValor() + " and ";
					}
				}

				if (filtroParametro instanceof ParametroNaoNulo) {
					ParametroNaoNulo parametroSimples = ((ParametroNaoNulo) filtroParametro);

					sql = sql + " (" + parametroSimples.getNomeAtributo()
							+ " is not null) and ";

					sqlSegundaParte = sqlSegundaParte + " ("
							+ parametroSimples.getNomeAtributo()
							+ " is not null) and ";

				}

				if (filtroParametro instanceof MaiorQue) {
					MaiorQue parametroSimples = ((MaiorQue) filtroParametro);

					sql = sql + " (" + parametroSimples.getNomeAtributo()
							+ " >= " + parametroSimples.getNumero() + ") and ";

					sqlSegundaParte = sqlSegundaParte + " ("
							+ parametroSimples.getNomeAtributo() + " >= "
							+ parametroSimples.getNumero() + ") and ";
				}

				if (filtroParametro instanceof MenorQue) {
					MenorQue parametroSimples = ((MenorQue) filtroParametro);

					sql = sql + " (" + parametroSimples.getNomeAtributo()
							+ " <= " + parametroSimples.getNumero() + ") and ";

					sqlSegundaParte = sqlSegundaParte + " ("
							+ parametroSimples.getNomeAtributo() + " <= "
							+ parametroSimples.getNumero() + ") and ";
				}

			}

			sql = Util.removerUltimosCaracteres(sql, 4);

			sqlSegundaParte = Util.removerUltimosCaracteres(sqlSegundaParte, 4);

			sql = sql + " UNION " + sqlSegundaParte;
			sql = sql + " order by idLocalidade";
		}
		try {

			retorno = session.createSQLQuery(sql).addScalar("idImovel",
					Hibernate.INTEGER).addScalar("idLocalidade",
					Hibernate.INTEGER).addScalar("nomeLocalidade",
					Hibernate.STRING).addScalar("idPoco", Hibernate.INTEGER)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição
	 * Individualizada
	 * 
	 * @author Vivianne Sousa
	 * @date 09/01/2007
	 * 
	 * @param idImovel
	 * @param anoMesfaturamentoGrupo
	 * @throws ControladorException
	 */
	public Collection pesquisarLigacoesMedicaoIndividualizadaRelatorio(
			Integer idImovel, String anoMesfaturamentoGrupo)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.imov_id as idImovel, " // 0
					+ " imovel.imov_qteconomia as qtdEconomias, "// 1
					// + " medicaoHistorico.mdhi_id as idMedicaoHistorico,"//2
					+ " medicaoHistorico.mdhi_dtleitantfatmt as dataLeituraAnterior,"// 3
					+ " medicaoHistorico.mdhi_nnleitantfatmt as leituraAnterior,"// 4
					+ " medicaoHistorico.mdhi_dtleituraatualfaturamento as dataLeituraAtualFaturamento,"// 5
					+ " medicaoHistorico.mdhi_nnleituraatualfaturamento as leituraAtualFaturamento,"// 6
					// + " medicaoHistorico.mdhi_nnconsumomedidomes as
					// consumoMedido,"// 7
					+ " consumoHistorico.cshi_nnconsimoveisvinculados as consumoImoveisVinculados,"// 7
					+ " medicaoHistorico.ltan_idleitanormfatmt as idAnormalidadeLeitura,"// 8
					// + " consumoHistorico.cshi_id as idConsumoHistorico,"//9
					+ " consumoHistorico.cshi_nnconsumomedio as consumoMedio,"// 10
					+ " consumoHistorico.cshi_nnconsumofaturadomes as consumoFaturado,"// 11
					+ " consumoHistorico.cshi_nnconsumorateio as rateio,"// 12
					+ " consumoAnormalidade.csan_dsabrvconsanormalidade as dsAbreviadaAnormalidadeConsumo,"// 13
					+ " consumoTipo.cstp_dsabreviadaconsumotipo as dsAbreviadaTipoConsumo,"// 14
					// + " medicaoTipo.medt_id as tipoMedicao,"//15

					// 16 Consumo Esgoto
					+ " (select consumo.cshi_nnconsumofaturadomes"
					+ " from micromedicao.consumo_historico consumo"
					+ " where consumo.imov_id = imovel.imov_id"
					+ " and consumo.cshi_amfaturamento = "
					+ anoMesfaturamentoGrupo
					+ " and consumo.lgti_id = "
					+ LigacaoTipo.LIGACAO_ESGOTO
					+ ") as consumoEsgoto,"

					// + " medicaoHistorico.mdhi_nnconsumoinformado as
					// consumoInformado"//17
					+ " setorComercial.stcm_cdsetorcomercial as codigoSetorComercial,"// 18
					+ " quadra.qdra_nnquadra as numeroQuadra,"// 19
					+ " imovel.imov_nnlote as numeroLote,"// 20
					+ " imovel.imov_nnsublote as numeroSubLote,"// 21

					+ " (select cliente.clie_nmcliente from cadastro.cliente_imovel clienteImovel"
					+ " left outer join cadastro.cliente cliente on clienteImovel.clie_id = cliente.clie_id"
					+ " where imovel.imov_id = clienteImovel.imov_id and clienteImovel.clim_dtrelacaofim is null"
					+ " and clienteImovel.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO
					+ " ) as nomeCliente" // 22

					+ " from cadastro.imovel imovel"
					+ " inner join micromedicao.consumo_historico consumoHistorico on imovel.imov_id=consumoHistorico.imov_id and consumoHistorico.cshi_amfaturamento = "
					+ anoMesfaturamentoGrupo
					+ " inner join micromedicao.medicao_historico medicaoHistorico on  consumoHistorico.imov_id=medicaoHistorico.lagu_id and medicaoHistorico.mdhi_amleitura = "
					+ anoMesfaturamentoGrupo
					+ " left outer join micromedicao.consumo_anormalidade consumoAnormalidade on consumoHistorico.csan_id=consumoAnormalidade.csan_id"
					+ " left outer join micromedicao.medicao_tipo medicaoTipo on medicaoHistorico.medt_id=medicaoTipo.medt_id"
					+ " left outer join micromedicao.consumo_tipo consumoTipo on consumoHistorico.cstp_id=consumoTipo.cstp_id"
					+ " left outer join cadastro.quadra quadra on imovel.qdra_id=quadra.qdra_id"
					+ " left outer join cadastro.setor_comercial setorComercial on imovel.stcm_id=setorComercial.stcm_id"

					+ " where (medicaoHistorico.medt_id = "
					+ LigacaoTipo.LIGACAO_AGUA
					+ " and consumoHistorico.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA + ")"
					+ " and (imovel.imov_idimovelcondominio = " + idImovel
					+ " or imovel.imov_id = " + idImovel + ")"
					+ " order by imovel.imov_icimovelcondominio";

			retorno = (Collection) session.createSQLQuery(consulta).addScalar(
					"idImovel", Hibernate.INTEGER).addScalar("qtdEconomias",
					Hibernate.SHORT)
			// .addScalar("idMedicaoHistorico", Hibernate.INTEGER)
					.addScalar("dataLeituraAnterior", Hibernate.DATE)
					.addScalar("leituraAnterior", Hibernate.INTEGER).addScalar(
							"dataLeituraAtualFaturamento", Hibernate.DATE)
					.addScalar("leituraAtualFaturamento", Hibernate.INTEGER)
					.addScalar("consumoImoveisVinculados", Hibernate.INTEGER)
					.addScalar("idAnormalidadeLeitura", Hibernate.INTEGER)
					// .addScalar("idConsumoHistorico", Hibernate.INTEGER)
					.addScalar("consumoMedio", Hibernate.INTEGER).addScalar(
							"consumoFaturado", Hibernate.INTEGER).addScalar(
							"rateio", Hibernate.INTEGER).addScalar(
							"dsAbreviadaAnormalidadeConsumo", Hibernate.STRING)
					.addScalar("dsAbreviadaTipoConsumo", Hibernate.STRING)
					// .addScalar("tipoMedicao", Hibernate.INTEGER)
					.addScalar("consumoEsgoto", Hibernate.INTEGER)
					// .addScalar("consumoInformado", Hibernate.INTEGER)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"numeroLote", Hibernate.SHORT).addScalar(
							"numeroSubLote", Hibernate.SHORT).addScalar(
							"nomeCliente", Hibernate.STRING).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0493] Emitir de Extrato de Consumo de Imóvel Condomínio
	 * 
	 * Flávio Cordeiro 08/01/2007
	 * 
	 * @throws ErroRepositorioException
	 *             idsRotas string formatada com valores separados por virgula.
	 *             Ex: 1,2,5,6 anoMesFaturamento
	 */

	public Collection pesquisarEmitirExtratoConsumoImovelCondominio(
			Collection idsRotas, String anoMesFaturamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String sql;
		try {

			sql = "select distinct(imovel.imov_id) as idImovel, "// 0
					+ " localidade.loca_id as idLocalidade,"// 1
					+ " localidade.loca_nmlocalidade as nomeLocalidade, "// 2
					+ " medicaoHistorico.mdhi_dtleituraatualfaturamento as dataLeituraAtualFat,"// 3
					+ " medicaoHistorico.mdhi_nnleituraatualfaturamento as numeroLeituraAtualFat,"// 4
					+ " consumoHistorico.cshi_nnconsumofaturadomes as consumoFaturadoMes,"// 5
					+ " leituraSituacao.ltst_dsleiturasituacao as descricaoLeituraSituacao,"// 6
					+ " consumoTipo.cstp_dsconsumotipo as descricaoConsumoTipo,"// 7
					+ " consumoAnormalidade.csan_dsconsumoanormalidade as descricaoAnormalidadeConsumo,"// 8
					+ " imovel.imov_qteconomia as qtdEconomias,"// 9
					+ " imovel.last_id as situacaoAgua,"// 10
					+ " imovel.lest_id as situacaoEsgoto,"// 11
					+ " consumoTipo.cstp_dsabreviadaconsumotipo as abreviadaConsumoTipo,"// 12
					+ " medicaoHistorico.ltan_idleitanormfatmt as anormalidadeLeituraFat,"// 13
					+ " consumoAnormalidade.csan_dsabrvconsanormalidade as abreviadaConsumoAnormalidade,"// 14
					+ " imovel.iper_id as perfilImovel,"// 15
					+ " medicaoHistorico.mdhi_dtleitantfatmt as dataLeituraAnteriorFat,"// 16
					+ " consumoHistorico.cshi_nnconsumomedio as consumoMedio,"// 17
					+ " consumoHistorico.cshi_nnconsumorateio as rateio,"// 18
					+ " rota.empr_id as idEmpresa,"// 19
					+ " leituraSituacao.ltst_id as idLeituraSituacao,"// 20
					+ " setorComercial.stcm_cdsetorcomercial as codigoSetorComercial,"// 21
					+ " imovel.qdra_id as idQuadra,"// 22
					+ " imovel.imov_nnlote as lote,"// 23
					+ " imovel.imov_nnsublote as subLote,"// 24
					+ " consumoHistorico.cshi_nnconsimoveisvinculados as consumovinculados"// 25
					+ " from cadastro.imovel imovel"
					+ " left outer join faturamento.mov_conta_prefaturada mcpf on mcpf.imov_id = imovel.imov_id  "
					+ " and mcpf.mcpf_ammovimento = " + anoMesFaturamento + " "
					+ " inner join micromedicao.consumo_historico consumoHistorico on imovel.imov_id = consumoHistorico.imov_id"
					+ " inner join micromedicao.medicao_historico medicaoHistorico on imovel.imov_id = medicaoHistorico.lagu_id"
					+ " left join cadastro.quadra quadra on imovel.qdra_id = quadra.qdra_id"
					+ " left join micromedicao.rota rota on rota.rota_id = quadra.rota_id"
					+ " left join faturamento.fatur_ativ_cron_rota fatAtivCronRota on fatAtivCronRota.rota_id = rota.rota_id"
					+ " left join cadastro.setor_comercial setorComercial on setorComercial.stcm_id = imovel.stcm_id"
					+ " left join cadastro.localidade localidade on localidade.loca_id = imovel.loca_id"
					+ " left join micromedicao.leitura_situacao leituraSituacao on leituraSituacao.ltst_id = medicaoHistorico.ltst_idleiturasituacaoatual"
					+ " left join micromedicao.consumo_tipo consumoTipo on consumoTipo.cstp_id = consumoHistorico.cstp_id"
					+ " left join micromedicao.consumo_anormalidade consumoAnormalidade on consumoAnormalidade.csan_id = consumoHistorico.csan_id"
					+ " where rota.rota_id in (:idsRotas)"
					+ " and consumoHistorico.cshi_icimovelcondominio = 1"
					+ " and consumoHistorico.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA
					+ " and consumoHistorico.cshi_amfaturamento = "
					+ anoMesFaturamento + " and medicaoHistorico.medt_id = "
					+ LigacaoTipo.LIGACAO_AGUA
					+ " and medicaoHistorico.mdhi_amleitura = "
					+ anoMesFaturamento 
					+ " and (mcpf.mcpf_icemissaoconta = 2 or mcpf.imov_id is null) " 
					+ " order by idEmpresa, idLocalidade,"
					+ " codigoSetorComercial, idQuadra,"
					+ " imovel.imov_nnlote";

			retorno = session.createSQLQuery(sql).addScalar("idImovel",
					Hibernate.INTEGER).addScalar("idLocalidade",
					Hibernate.INTEGER).addScalar("nomeLocalidade",
					Hibernate.STRING).addScalar("dataLeituraAtualFat",
					Hibernate.DATE).addScalar("numeroLeituraAtualFat",
					Hibernate.INTEGER).addScalar("consumoFaturadoMes",
					Hibernate.INTEGER).addScalar("descricaoLeituraSituacao",
					Hibernate.STRING).addScalar("descricaoConsumoTipo",
					Hibernate.STRING).addScalar("descricaoAnormalidadeConsumo",
					Hibernate.STRING).addScalar("qtdEconomias",
					Hibernate.INTEGER).addScalar("situacaoAgua",
					Hibernate.INTEGER).addScalar("situacaoEsgoto",
					Hibernate.INTEGER).addScalar("abreviadaConsumoTipo",
					Hibernate.STRING).addScalar("anormalidadeLeituraFat",
					Hibernate.INTEGER).addScalar(
					"abreviadaConsumoAnormalidade", Hibernate.STRING)
					.addScalar("perfilImovel", Hibernate.INTEGER).addScalar(
							"dataLeituraAnteriorFat", Hibernate.DATE)
					.addScalar("consumoMedio", Hibernate.INTEGER).addScalar(
							"rateio", Hibernate.INTEGER).addScalar("idEmpresa",
							Hibernate.INTEGER).addScalar("idLeituraSituacao",
							Hibernate.INTEGER).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER).addScalar("lote",
							Hibernate.INTEGER).addScalar("subLote",
							Hibernate.INTEGER).addScalar("consumovinculados",
							Hibernate.INTEGER).setParameterList("idsRotas",
							idsRotas).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * soma dos consumos dos imoveis associados [UC0493] Emitir de Extrato de
	 * Consumo de Imóvel Condomínio
	 * 
	 * Flávio Cordeiro 12/01/2007
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer somaConsumosImoveisAssociados(Integer idImovel, String anoMes)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String sql;

		try {
			sql = "select sum(consumoHistorico.cshi_nnconsumofaturadomes) as consumos"
					+ " from micromedicao.consumo_historico consumoHistorico"
					+ " inner join cadastro.imovel imovel on consumoHistorico.imov_id = imovel.imov_id"
					+ " where consumoHistorico.cshi_amfaturamento = "
					+ anoMes
					+ " and imovel.imov_idimovelcondominio = "
					+ idImovel
					+ " and consumoHistorico.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA;

			retorno = (Integer) session.createSQLQuery(sql).addScalar(
					"consumos", Hibernate.INTEGER).uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * quantidade de imoveis associados [UC0493] Emitir de Extrato de Consumo de
	 * Imóvel Condomínio
	 * 
	 * Flávio Cordeiro 12/01/2007
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer quantidadeImoveisAssociados(Integer idImovel, String anoMes)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String sql;

		try {
			sql = "select count(consumoHistorico.cshi_nnconsumofaturadomes) as qtd"
					+ " from micromedicao.consumo_historico consumoHistorico"
					+ " inner join cadastro.imovel imovel on consumoHistorico.imov_id = imovel.imov_id"
					+ " where consumoHistorico.cshi_amfaturamento = "
					+ anoMes
					+ " and imovel.imov_idimovelcondominio = "
					+ idImovel
					+ " and consumoHistorico.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA;

			retorno = (Integer) session.createSQLQuery(sql).addScalar("qtd",
					Hibernate.INTEGER).uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0173] Gerar Relatório de Resumo do Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @created 24/01/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQtdeRegistrosResumoFaturamentoRelatorio(int anoMesReferencia, Integer localidade, 
			Integer municipio, Integer gerenciaRegional, String opcaoTotalizacao) throws ErroRepositorioException {
		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			if(opcaoTotalizacao.equals("municipio")){
				consulta = "select count(rf.id)" + " from ResumoFaturamento rf "
					+ "INNER JOIN rf.localidade loc "
					+ " where rf.anoMesReferencia = :anoMesReferencia and "
					+ " loc.municipio = :municipio and "
					+ " (rf.categoria.id = 1 or" + " rf.categoria.id = 2 or"
					+ " rf.categoria.id = 3 or" + " rf.categoria.id = 4)";
				
			}else{
				consulta = "select count(rf.id)" + " from ResumoFaturamento rf "
					+ " where rf.anoMesReferencia = :anoMesReferencia and"
					+ " (rf.categoria.id = 1 or" + " rf.categoria.id = 2 or"
					+ " rf.categoria.id = 3 or" + " rf.categoria.id = 4)";
			}
			
			if (opcaoTotalizacao.equals("localidade") && localidade != null) {

				consulta = consulta + " and rf.localidade = :localidade";

				retorno = (Integer) session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger(
						"localidade", localidade).uniqueResult();

			} else if (opcaoTotalizacao.equals("municipio") && municipio != null) {
				retorno = (Integer) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
				 .setInteger("municipio", municipio).uniqueResult();

			} else if ((opcaoTotalizacao.equals("gerenciaRegionalLocalidade") || opcaoTotalizacao
					.equals("gerenciaRegional"))
					&& gerenciaRegional != null) {

				consulta = consulta
						+ " and rf.gerenciaRegional = :gerenciaRegional";

				retorno = (Integer) session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger(
						"gerenciaRegional", gerenciaRegional).uniqueResult();
			} else {
				retorno = (Integer) session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).uniqueResult();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * @author Ana Maria
	 * @date 26/01/2007
	 * 
	 * @param idConta
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection obterConta(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT conta "
				+ "FROM Conta conta "
				+ "INNER JOIN conta.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
				+ "INNER JOIN FETCH conta.imovel imov "
	            + "INNER JOIN FETCH imov.localidade loc "
	            + "INNER JOIN FETCH conta.quadraConta "
				+ "WHERE conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0335] Gerar Resumo de Pendência
	 * 
	 * Pesquisar os ids das localidade
	 * 
	 * @author Ana Maria
	 * @date 29/01/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsLocalidade()
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select loca_id as localidade from faturamento.conta "
					+ "union "
					+ "select loca_id localidade from faturamento.guia_pagamento "
					+ "order by localidade";

			retorno = session.createSQLQuery(consulta).addScalar("localidade",
					Hibernate.INTEGER).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualiza o sequencial de conta impressão
	 * 
	 * @author Sávio Luiz
	 * @date 29/01/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSequencialContaImpressao(
			Map<Integer, Integer> mapAtualizaSequencial)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = "update gcom.faturamento.conta.ContaImpressao "
				+ "set cnti_nnsequencialimpressao =:sequencialConta, "
				+ "cnti_tmultimaalteracao = :dataAtual, "
				+ "cnti_icimpressao = :indicador "
				+ "where cnta_id = :idConta ";

		if (mapAtualizaSequencial != null && !mapAtualizaSequencial.isEmpty()) {

			Iterator iteMapAtualizaSequencia = mapAtualizaSequencial.keySet()
					.iterator();

			try {
				while (iteMapAtualizaSequencia.hasNext()) {
					Integer idConta = (Integer) iteMapAtualizaSequencia.next();

					Integer sequencialConta = mapAtualizaSequencial
							.get(idConta);

					session.createQuery(consulta)
							.setInteger("idConta", idConta).setShort(
									"indicador",
									ConstantesSistema.INDICADOR_USO_ATIVO)
							.setInteger("sequencialConta", sequencialConta)
							.setDate("dataAtual", new Date()).executeUpdate();
				}
			} catch (HibernateException e) {
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				HibernateUtil.closeSession(session);

			}
		}

	}

	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Vivianne Sousa
	 * @created 30/01/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarContasEmitidasRelatorio(int anoMesReferencia,
			Integer grupoFaturamento, Collection esferaPoder)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select contaImpressao.id, "
					+ // 0
					"clienteResponsavel.id, "
					+ // 1
					"clienteResponsavel.nome, "
					+ // 2
					"imovel.localidade.id, "
					+ // 3
					"imovel.localidade.descricao, "
					+ // 4
					"conta.dataVencimentoConta, "
					+ // 5
					"imovel.id, "
					+ // 6
					"imovel.setorComercial.codigo, "
					+ // 7
					"imovel.quadra.numeroQuadra, "
					+ // 8
					"imovel.lote, "
					+ // 9
					"imovel.subLote, "
					+ // 10
					"(select clienteImovel.cliente.nome "
					+ "from ClienteImovel clienteImovel "
					+ "where clienteImovel.imovel.id = imovel.id "
					+ "and clienteImovel.clienteRelacaoTipo.id = 2 "
					+ "and clienteImovel.dataFimRelacao is null), "
					+ // 11
					"conta.valorAgua, "
					+ // 12
					"conta.valorEsgoto, "
					+ // 13
					"conta.debitos, "
					+ // 14
					"conta.valorCreditos, "
					+ // 15
					"esferaPoder.id, "
					+ // 16
					"esferaPoder.descricao "
					+ // 17
					"from ContaImpressao contaImpressao "
					+ "inner join contaImpressao.faturamentoGrupo faturamentoGrupo "
					+ "left join contaImpressao.clienteResponsavel clienteResponsavel "
					+ "left join contaImpressao.contaGeral contaGeral "
					+ "left join contaGeral.conta conta "
					+ "left join conta.clienteContas cliCon "
					+ "left join cliCon.cliente cliente "
					+ "left join cliente.clienteTipo clienteTipo "
					+ "left join clienteTipo.esferaPoder esferaPoder "
					+ "left join conta.imovel imovel "
					+ "where contaImpressao.faturamentoGrupo.id = :grupoFaturamento "
					+ "and esferaPoder.id in (:esferaPoder) "
					+ "and contaImpressao.referenciaConta = :anoMesReferencia "
					+ "and cliCon.clienteRelacaoTipo = :clienteRelacaoTipo ";
			
					SistemaParametro sistemaParametro = 
						RepositorioUtilHBM.getInstancia().pesquisarParametrosDoSistema();

					if (sistemaParametro.getIndicadorUsaRota().shortValue() == ConstantesSistema.NAO){
						
						consulta = consulta + "order by imovel.localidade.id, imovel.setorComercial.codigo, imovel.quadra.numeroQuadra, imovel.lote, imovel.subLote ";
					} else {
						
						consulta = consulta + "order by imovel.localidade.id, imovel.setorComercial.codigo, imovel.quadra.numeroQuadra, imovel.quadra.rota.codigo, imovel.numeroSequencialRota ,imovel.lote, imovel.subLote ";
					}
					

			retorno = session.createQuery(consulta).setInteger(
					"grupoFaturamento", grupoFaturamento).setParameterList(
					"esferaPoder", esferaPoder).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("clienteRelacaoTipo",
					ClienteRelacaoTipo.USUARIO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Vivianne Sousa
	 * @created 02/02/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQtdeContasEmitidasRelatorio(int anoMesReferencia,
			Integer grupoFaturamento, Collection esferaPoder)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select count(contaImpressao.id) "
					+ "from ContaImpressao contaImpressao "
					+ "inner join contaImpressao.faturamentoGrupo faturamentoGrupo "
					+ "left join contaImpressao.clienteResponsavel clienteResponsavel "
					+ "left join clienteResponsavel.clienteTipo clienteTipo "
					+ "left join clienteTipo.esferaPoder esferaPoder "
					+ "where contaImpressao.faturamentoGrupo.id = :grupoFaturamento "
					+ "and clienteResponsavel is not null "
					+ "and esferaPoder.id in (:esferaPoder) "
					+ "and contaImpressao.referenciaConta = :anoMesReferencia ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"grupoFaturamento", grupoFaturamento).setParameterList(
					"esferaPoder", esferaPoder).setInteger("anoMesReferencia",
					anoMesReferencia).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	// retorna o anoMes do faturamento grupo do imóvel passado
	public Integer retornaAnoMesFaturamentoGrupo(Integer idImovel)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer anoMesFaturamento = null;

		try {

			// Pesquisa para saber qual o anoMes de faturamento do grupo q akele
			// imovel pertence
			String sqlMesFaturamentoGrupo = "select fg.ftgr_amreferencia as anoMes "
					+ " from faturamento.faturamento_grupo fg,"
					+ "	cadastro.imovel im, "
					+ "	cadastro.quadra qd, "
					+ " micromedicao.rota rota "
					+ " where im.qdra_id = qd.qdra_id "
					+ " and qd.rota_id = rota.rota_id "
					+ " and rota.ftgr_id = fg.ftgr_id "
					+ " and im.imov_id =:idImovel ";

			anoMesFaturamento = (Integer) session.createSQLQuery(
					sqlMesFaturamentoGrupo).addScalar("anoMes",
					Hibernate.INTEGER).setInteger("idImovel",
					idImovel.intValue()).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return anoMesFaturamento;
	}

	/**
	 * Monta a colecao de resultdos apartir da tbela conta impressao para
	 * geracao do relatorio de MAPA DE CONTROLE DAS CONTAS EMITIDAS
	 * 
	 * @author Flávio Cordeiro
	 * @date 13/02/2007
	 * 
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarMapaControleContaRelatorio(
			Integer idGrupoFaturamento, String anoMes,
			String indicadorFichaCompensacao) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String sql = "select "
					+ " contaImpressao.empr_id as idEmpresa,"// 0
					+ " empresa.empr_nmempresa as nomeEmpresa,"// 1
					+ " contaImpressao.cttp_id as idTipoConta,"// 2
					+ " tipoConta.cttp_dstipoconta as descricaoTipoConta,"// 3
					+ " localidade.loca_id as idLocalidade,"// 4
					+ " setor.stcm_cdsetorcomercial as codigoSetor,"// 5
					+ " contaImpressao.ftgr_id as idFaturamentoGrupo, "// 6
					+ " min(contaImpressao.cnti_nnsequencialimpressao) as sequencialInicial,"// 7
					+ " max(contaImpressao.cnti_nnsequencialimpressao) as sequencialFinal,"// 8
					+ " sum(conta.cnta_vlagua) as somaValorAgua,"// 9
					+ " sum(conta.cnta_vlesgoto) as somaValorEsgoto,"// 10
					+ " sum(conta.cnta_vldebitos) as somaValordebito,"// 11
					+ " sum(conta.cnta_vlcreditos) as somaValorCredito"// 12
					+ " from faturamento.conta_impressao contaImpressao"
					+ " inner join faturamento.conta conta on contaImpressao.cnta_id = conta.cnta_id"
					+ " inner join faturamento.faturamento_grupo grupoFaturamento on contaImpressao.ftgr_id = grupoFaturamento.ftgr_id"
					+ " left join cadastro.empresa empresa on empresa.empr_id = contaImpressao.empr_id"
					+ " left join faturamento.conta_tipo tipoConta on contaImpressao.cttp_id = tipoConta.cttp_id"
					+ " inner join cadastro.imovel imovel on conta.imov_id = imovel.imov_id"
					+ " inner join cadastro.localidade localidade on imovel.loca_id = localidade.loca_id"
					+ " inner join cadastro.setor_comercial setor on imovel.stcm_id = setor.stcm_id"
					+ " where contaImpressao.ftgr_id = :idGrupoFaturamento"
					+ " and contaImpressao.cnti_amreferenciaconta = :anoMes";

			if (indicadorFichaCompensacao.equals("1")) {
				sql = sql
						+ " and contaImpressao.cnti_icfichacompensacao is null";
			} else {
				sql = sql + " and contaImpressao.cnti_icfichacompensacao = 1";
			}

			sql = sql
					+ " group by contaimpressao.ftgr_id, contaimpressao.empr_id, empresa.empr_nmempresa,"
					+ " contaimpressao.cttp_id, tipoconta.cttp_dstipoconta, localidade.loca_id, setor.stcm_cdsetorcomercial"
					+ " order by nomeEmpresa, idTipoConta, idLocalidade, codigoSetor";

			retorno = (Collection) session.createSQLQuery(sql).addScalar(
					"idEmpresa", Hibernate.INTEGER)// 0
					.addScalar("nomeEmpresa", Hibernate.STRING)// 1
					.addScalar("idTipoConta", Hibernate.INTEGER)// 2
					.addScalar("descricaoTipoConta", Hibernate.STRING)// 3
					.addScalar("idLocalidade", Hibernate.INTEGER)// 4
					.addScalar("codigoSetor", Hibernate.INTEGER)// 5
					.addScalar("idFaturamentoGrupo", Hibernate.INTEGER)// 6
					.addScalar("sequencialInicial", Hibernate.INTEGER)// 7
					.addScalar("sequencialFinal", Hibernate.INTEGER)// 8
					.addScalar("somaValorAgua", Hibernate.BIG_DECIMAL)// 9
					.addScalar("somaValorEsgoto", Hibernate.BIG_DECIMAL)// 10
					.addScalar("somaValordebito", Hibernate.BIG_DECIMAL)// 11
					.addScalar("somaValorCredito", Hibernate.BIG_DECIMAL)// 12
					.setInteger("idGrupoFaturamento", idGrupoFaturamento)
					.setInteger("anoMes", new Integer(anoMes)).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Monta a colecao de resultdos apartir da tabela conta impressao para
	 * geracao do relatorio de RESUMO CONTAS EMITIDAS POR LOCALIDADE NO GRUPO
	 * 
	 * @author Flávio Cordeiro
	 * @date 13/02/2007
	 * 
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarResumoContasLocalidade(Integer idGrupoFaturamento,
			String anoMes, Integer idFirma) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String sql = "select "
					+ " localidade.loca_id as idLocalidade,"
					+ " contaImpressao.empr_id as idEmpresa,"
					+ " clienteTipo.epod_id as esferaPoder,"
					+ " min(contaImpressao.cnti_nnsequencialimpressao) as sequencialInicial,"
					+ " max(contaImpressao.cnti_nnsequencialimpressao) as sequencialFinal,"
					+ " count(contaImpressao.cnta_id) as qtdeContas, "
					+ " sum ( case when (imovel.imov_icimovelcondominio = 1) "
					+ " then 1 else 0 end ) as extratoMacro " //6
					+ " from faturamento.conta_impressao contaImpressao"
					+ " inner join faturamento.conta conta on contaImpressao.cnta_id = conta.cnta_id"
					+ " inner join faturamento.faturamento_grupo grupoFaturamento on contaImpressao.ftgr_id = grupoFaturamento.ftgr_id"
					+ " left join cadastro.empresa empresa on empresa.empr_id = contaImpressao.empr_id"
					+ " inner join cadastro.imovel imovel on conta.imov_id = imovel.imov_id"
					+ " inner join cadastro.localidade localidade on imovel.loca_id = localidade.loca_id"
					+ " left join cadastro.cliente clienteResponsavel on clienteResponsavel.clie_id = contaImpressao.clie_idresponsavel"
					+ " left join cadastro.cliente_tipo clienteTipo on clienteResponsavel.cltp_id = clienteTipo.cltp_id"
					+ " where contaImpressao.ftgr_id = :idGrupoFaturamento"
					+ " and contaImpressao.cnti_amreferenciaconta = :anoMes";
			if (idFirma != null) {
				sql = sql + " and empresa.empr_id = :idEmpresa ";
			}
			sql = sql + " group by  " + " localidade.loca_id," + " contaimpressao.empr_id,"
					+ " clientetipo.epod_id"
					+ " order by idLocalidade, idEmpresa, esferaPoder";

			if (idFirma != null) {
				retorno = (Collection) session.createSQLQuery(sql).addScalar(
						"idLocalidade", Hibernate.INTEGER)// 0
						.addScalar("idEmpresa", Hibernate.INTEGER)// 1
						.addScalar("esferaPoder", Hibernate.INTEGER)// 2
						.addScalar("sequencialInicial", Hibernate.INTEGER)// 3
						.addScalar("sequencialFinal", Hibernate.INTEGER)// 4
						.addScalar("qtdeContas", Hibernate.INTEGER) // 5
						.addScalar("extratoMacro", Hibernate.INTEGER) // 6
						.setInteger("idGrupoFaturamento", idGrupoFaturamento)
						.setInteger("anoMes", new Integer(anoMes)).setInteger(
								"idEmpresa", idFirma).list();
			} else {
				retorno = (Collection) session.createSQLQuery(sql).addScalar(
						"idLocalidade", Hibernate.INTEGER)// 0
						.addScalar("idEmpresa", Hibernate.INTEGER)// 1
						.addScalar("esferaPoder", Hibernate.INTEGER)// 2
						.addScalar("sequencialInicial", Hibernate.INTEGER)// 3
						.addScalar("sequencialFinal", Hibernate.INTEGER)// 4
						.addScalar("qtdeContas", Hibernate.INTEGER) // 5
						.addScalar("extratoMacro", Hibernate.INTEGER) // 6
						.setInteger("idGrupoFaturamento", idGrupoFaturamento)
						.setInteger("anoMes", new Integer(anoMes)).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Author: Vivianne Sousa Data: 06/03/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterGuiasPagamentoPagamento(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gpag.id " + "FROM Pagamento pgto "
					+ "LEFT JOIN pgto.guiaPagamento gpag "
					+ "WHERE gpag.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Author: Vivianne Sousa Data: 06/03/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterGuiasPagamentoCobrancaDocumentoItem(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gpag.id " + "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.guiaPagamentoGeral gpag "
					+ "WHERE gpag.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Author: Vivianne Sousa Data: 06/03/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterGuiasPagamentoParcelamentoItem(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gpag.id " + "FROM ParcelamentoItem parcItem "
					+ "LEFT JOIN parcItem.guiaPagamentoGeral gpag "
					+ "WHERE gpag.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 17/03/2007, 08/05/2008
	 * 
	 * @param conta
	 * @param idImovel
	 * @param anoMesReferenciaConta
	 * @param anoMesReferenciaAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean obterIndicadorPagamentosClassificadosContaReferenciaMenorIgualAtual(
			Integer conta, Integer idImovel, Integer anoMesReferenciaConta,
			Integer anoMesReferenciaAtual) throws ErroRepositorioException {

		boolean retorno;

		Collection colecaoRetorno1;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT pgmt.id "
					+ "FROM Pagamento pgmt "
					+ "WHERE (cnta_id = :idConta "
					+ "AND pgmt.pagamentoSituacaoAtual.id = :idSituacaoAtual "
					+ "AND pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaAtual) ";

			colecaoRetorno1 = session.createQuery(consulta).setInteger(
					"idConta", conta).setInteger("idSituacaoAtual",
					PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
					"anoMesReferenciaAtual", anoMesReferenciaAtual).list();

			if (colecaoRetorno1 != null && !colecaoRetorno1.isEmpty()) {
				retorno = true;
			} else {
				retorno = false;
				/*
				 * if(colecaoRetorno2 != null && !colecaoRetorno2.isEmpty()){
				 * retorno = true; }else{ retorno = false; }
				 */
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 19/03/2007
	 * 
	 * @param idGuiaPagamento
	 * @param idImovel
	 * @param idDebitoTipo
	 * @param anoMesReferenciaAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean obterIndicadorPagamentosClassificadosGuiaPagamentoReferenciaMenorIgualAtual(
			Integer idGuiaPagamento, Integer idImovel, Integer idDebitoTipo,
			Integer anoMesReferenciaAtual) throws ErroRepositorioException {

		boolean retorno;

		Collection colecaoRetorno1;
		// Collection colecaoRetorno2;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "
					// + "INNER JOIN pgmt.guiaPagamento gpag "
					+ "WHERE (gpag_id = :idGuiaPagamento "
					+ "AND pgmt.pagamentoSituacaoAtual.id = :idSituacaoAtual "
					+ "AND pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaAtual) ";

			colecaoRetorno1 = session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento)
					.setInteger("idSituacaoAtual",
							PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("anoMesReferenciaAtual", anoMesReferenciaAtual)
					.list();

			// consulta = "SELECT MIN(pgmt.dataPagamento) "
			// + "FROM Pagamento pgmt "
			// + "INNER JOIN pgmt.guiaPagamento gpag "
			// + "INNER JOIN gpag.imovel imov "
			// + "WHERE pgmt.imovel.id= :idImovel and pgmt.debitoTipo.id =
			// :idDebitoTipo";
			//			
			//			
			// colecaoRetorno2 = session.createQuery(consulta)
			// .setInteger("idImovel", idImovel)
			// .setInteger("idDebitoTipo", idDebitoTipo)
			// .list();

			if (colecaoRetorno1 != null && !colecaoRetorno1.isEmpty()) {
				retorno = true;
			} else {
				retorno = false;
				/*
				 * if(colecaoRetorno2 != null && !colecaoRetorno2.isEmpty()){
				 * retorno = true; }else{ retorno = false; }
				 */
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém as contas de um imóvel com ano/mes da data de vencimento menor ou
	 * igual ao ano/mes de referencia da arrecadacao corrente e com situacao
	 * atual correspondente a normal, retificada ou incluida.
	 * 
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Fernanda Paiva, Pedro Alexandre, Pedro Alexandre
	 * @date 24/04/2006,15/03/2007,08/05/2008
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImovel(Integer imovel, Integer situacaoNormal,
			Integer situacaoIncluida, Integer situacaoRetificada,
			Date dataAnoMesReferenciaUltimoDia) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select "
					+ " conta.cnta_id as col_0, "
					+ " conta.cnta_amreferenciaconta as col_1, "
					+ "  conta.cnta_dtvencimentoconta as col_2, "
					+ "  conta.cnta_vlagua as col_3, "
					+ "  conta.cnta_vlesgoto as col_4, "
					+ "  conta.cnta_vldebitos as col_5, "
					+ "  conta.cnta_vlcreditos as col_6, "
					+ "  conta.cnta_iccobrancamulta as col_7  "
					+ " from "
					+ "  faturamento.conta conta  "
					+ " where "
					+ "  conta.imov_id= :idImovel "
					+ "  and conta.cnta_dtvencimentoconta<= :dataAnoMesReferenciaUltimoDia  "
					+ "  and (conta.cnta_dtrevisao is null)  "
					+ "  and (conta.dcst_idatual in (:normal, :incluida, :retificada)) "
					+ "  and conta.cnta_iccobrancamulta= :indicadorMulta ";

			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.INTEGER).addScalar("col_1", Hibernate.INTEGER)
					.addScalar("col_2", Hibernate.DATE).addScalar("col_3",
							Hibernate.BIG_DECIMAL).addScalar("col_4",
							Hibernate.BIG_DECIMAL).addScalar("col_5",
							Hibernate.BIG_DECIMAL).addScalar("col_6",
							Hibernate.BIG_DECIMAL).addScalar("col_7",
							Hibernate.SHORT).setInteger("idImovel", imovel)
					.setInteger("normal", situacaoNormal).setInteger(
							"incluida", situacaoIncluida).setInteger(
							"retificada", situacaoRetificada).setDate(
							"dataAnoMesReferenciaUltimoDia",
							dataAnoMesReferenciaUltimoDia).setShort(
							"indicadorMulta", ConstantesSistema.NAO).list();

			/*
			 * consulta = "SELECT cnta.id, cnta.referencia,
			 * cnta.dataVencimentoConta, cnta.valorAgua, " + "cnta.valorEsgoto,
			 * cnta.debitos, cnta.valorCreditos, cnta.indicadorCobrancaMulta " +
			 * "FROM Conta cnta " + "INNER JOIN cnta.imovel imov " + "INNER JOIN
			 * cnta.debitoCreditoSituacaoAtual dcst " + "WHERE imov.id =
			 * :idImovel AND " + "cnta.dataVencimentoConta <=
			 * :dataAnoMesReferenciaUltimoDia AND " + "cnta.dataRevisao is null
			 * AND " + "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida,
			 * :retificada) AND " + "cnta.indicadorCobrancaMulta =
			 * :indicadorMulta ";
			 * 
			 * retorno = session.createQuery(consulta)
			 * .setInteger("idImovel",imovel)
			 * .setInteger("normal",situacaoNormal)
			 * .setInteger("incluida",situacaoIncluida)
			 * .setInteger("retificada",situacaoRetificada)
			 * .setDate("dataAnoMesReferenciaUltimoDia",dataAnoMesReferenciaUltimoDia)
			 * .setShort("indicadorMulta",ConstantesSistema.NAO) .list();
			 */

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 63 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * doações.
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoDoacoesSituacaoNormal(
			int anoMesReferencia, int idLocalidade, int idCategoria)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
					+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
					+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacao",
					DebitoCreditoSituacao.NORMAL).setInteger(
					"idFinanciamentoTipo", FinanciamentoTipo.DOACOES).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * Recupera as contas do Conjunto de Imóveis
	 * 
	 * @author Ana Maria, Mariana Victor
	 * @date 19/03/2007, 14/07/2011
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasImoveis(Integer anoMes,
			Collection idsImovel, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim,
			String indicadorContaPaga, Integer somenteDebitoAutomatico) throws ErroRepositorioException {

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;
		boolean indicadorBloqueioContasContratoParcelManterConta = false;
		
		try {
			RepositorioUtilHBM repositorioUtilHBM = RepositorioUtilHBM.getInstancia();
			SistemaParametro sistemaParametro = 
				repositorioUtilHBM.pesquisarParametrosDoSistema();

			/**
			 * [UC0407] Filtrar Imóveis para Inserir ou Manter Conta
			 * 3. Caso o indicador de bloqueio de contas vinculadas a contrato de parcelamento no manter contas esteja ativo
			 *   retirar da lista de contas selecionadas as contas vinculadas a algum contrato de parcelamento ativo
			 *    
			 * RM 1887 - Contrato Parcelamento por Cliente
			 * Adicionado por: Mariana Victor
			 * Data: 14/07/2011
			 *  
			 * */
			if (sistemaParametro.getIndicadorBloqueioContasContratoParcelManterConta() != null
					&& sistemaParametro.getIndicadorBloqueioContasContratoParcelManterConta().equals(ConstantesSistema.SIM)) {
				indicadorBloqueioContasContratoParcelManterConta = true;
			}
			
			List colecaoAuxiliar = new ArrayList();

			colecaoAuxiliar.addAll(idsImovel);

			int i = 0;
			int cont = 500;

			Collection colecao = new ArrayList();
			while (i <= idsImovel.size()) {

				if (idsImovel.size() - i >= cont) {
					colecao = colecaoAuxiliar.subList(i, i + cont);
				} else {
					colecao = colecaoAuxiliar.subList(i, idsImovel.size());
				}
				i = i + cont;
				
				if (colecao.size() == ConstantesSistema.ZERO.intValue() ) {
					break;
				}

				consulta = "select count(cnta.id) "
						+ "from Conta cnta "
						+ "inner join cnta.imovel imov "
						+ "inner join cnta.debitoCreditoSituacaoAtual dcst ";
				
				if (indicadorBloqueioContasContratoParcelManterConta) {
						consulta += "left join cnta.contaMotivoRevisao cmrv "
						+ "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
						+ "and imov.id in (:idsImovel) "
						+ "and dcst.id in(:normal, :incluida, :retificada) "
						+ "and (cmrv.id is null or cmrv.id <> :codigoContratoParcelamento ) ";
				} else {
					consulta += "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
						+ "and imov.id in (:idsImovel) "
						+ "and dcst.id in(:normal, :incluida, :retificada) ";
				}
				
				if (somenteDebitoAutomatico != null && somenteDebitoAutomatico == 1) {
					consulta += " and cnta.indicadorDebitoConta = 1 ";
				}
				
				if (dataVencimentoContaInicio != null) {

					if (dataVencimentoContaFim != null) {
						consulta += "and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";
					} else {
						consulta += "and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaInicio ";

					}
				}

				if (!indicadorContaPaga.equals("3")) {
					if (indicadorContaPaga.equals("1")) {
						consulta += "and exists ";
					} else {
						consulta += "and not exists ";
					}
					consulta += "(select conta.id " + "from Pagamento pgmt "
							+ "inner join pgmt.contaGeral contaGeral "
							+ "inner join contaGeral.conta conta "
							+ "where conta.id = cnta.id) ";
				}

				if (dataVencimentoContaInicio != null) {

					Query query = session.createQuery(consulta)
						.setInteger("anoMes", anoMes).setInteger(
								"anoMesFim", anoMesFim)
						.setParameterList("idsImovel", colecao)
						.setInteger("normal",
								DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida",
								DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA)
						.setDate("dataVencimentoContaInicio",
								dataVencimentoContaInicio).setDate(
								"dataVencimentoContaFim",
								dataVencimentoContaFim);

					if (indicadorBloqueioContasContratoParcelManterConta) {
						query.setInteger("codigoContratoParcelamento", 
								ContaMotivoRevisao.CONTA_EM_CONTRATO_PARCELAMENTO);
					}
					
					retorno = retorno
							+ (Integer) query.uniqueResult();
				} else {
					Query query = session.createQuery(consulta)
						.setInteger("anoMes", anoMes).setInteger(
								"anoMesFim", anoMesFim)
						.setParameterList("idsImovel", colecao)
						.setInteger("normal",
								DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida",
								DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA);
					
					if (indicadorBloqueioContasContratoParcelManterConta) {
						query.setInteger("codigoContratoParcelamento", 
								ContaMotivoRevisao.CONTA_EM_CONTRATO_PARCELAMENTO);
					}
					
					retorno = retorno
							+ (Integer) query.uniqueResult();

				}

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas em revisão do Conjunto de Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasRevisaoImoveis(Integer anoMes,
			Collection idsImovel, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim,
			String indicadorContaPaga) throws ErroRepositorioException {

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		
		String consulta;

		try {
			List colecaoAuxiliar = new ArrayList();

			colecaoAuxiliar.addAll(idsImovel);

			int i = 0;
			int cont = 500;

			Collection colecao = new ArrayList();
			while (i <= idsImovel.size()) {

				if (idsImovel.size() - i >= cont) {
					colecao = colecaoAuxiliar.subList(i, i + cont);
				} else {
					colecao = colecaoAuxiliar.subList(i, idsImovel.size());
				}
				i = i + cont;

				consulta = "select count(cnta.id) "
						+ "from Conta cnta "
						+ "inner join cnta.imovel imov "
						+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
						+ "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
						+ "and imov.id in (:idsImovel) "
						+ "and dcst.id in(:normal, :incluida, :retificada) "
						+ "and cnta.dataRevisao is null ";

				if (dataVencimentoContaInicio != null) {

					if (dataVencimentoContaFim != null) {
						consulta += "and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";
					} else {
						consulta += "and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaInicio ";

					}
				}

				if (!indicadorContaPaga.equals("3")) {
					if (indicadorContaPaga.equals("1")) {
						consulta += "and exists ";
					} else {
						consulta += "and not exists ";
					}
					consulta += "(select conta.id " + "from Pagamento pgmt "
							+ "inner join pgmt.contaGeral contaGeral "
							+ "inner join contaGeral.conta conta "
							+ "where conta.id = cnta.id "
							+ "and cnta.dataRevisao is null) ";
				}

				if (dataVencimentoContaInicio != null) {

					retorno = retorno
							+ (Integer) session.createQuery(consulta)
									.setInteger("anoMes", anoMes).setInteger(
											"anoMesFim", anoMesFim)
									.setParameterList("idsImovel", colecao)
									.setInteger("normal",
											DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida",
											DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada",
											DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio",
											dataVencimentoContaInicio).setDate(
											"dataVencimentoContaFim",
											dataVencimentoContaFim)
									.uniqueResult();
				} else {

					retorno = retorno
							+ (Integer) session.createQuery(consulta)
									.setInteger("anoMes", anoMes).setInteger(
											"anoMesFim", anoMesFim)
									.setParameterList("idsImovel", colecao)
									.setInteger("normal",
											DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida",
											DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada",
											DebitoCreditoSituacao.RETIFICADA)
									.uniqueResult();

				}

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarContasImoveisDebitoAutomatico(Integer anoMes,
			Collection idsImovel, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim,
			String indicadorContaPaga, String[] bancos)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, cnta.valorEsgoto, "
					+ "cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
					+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, cnta.referenciaContabil, "
					+ "cnta.ultimaAlteracao, imov, dcsan "
					+ "from DebitoAutomaticoMovimento dam "
					+ " inner join dam.debitoAutomatico da "
					+ " inner join dam.contaGeral.conta cnta "
					+ " inner join da.agencia ag"
					+ " inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ " left  join cnta.debitoCreditoSituacaoAnterior dcsan "
					+ " inner join cnta.imovel imov "
					+ " where ag.banco.id in (:idBanco) "
					+ " and dcst.id in(:normal, :retificada) "
					+ " and cnta.referencia between :anoMes and :anoMesFim "
					+ " and da.dataExclusao is null "
					+ " and dam.numeroSequenciaArquivoEnviado is null";

			if (dataVencimentoContaInicio != null) {
				if (dataVencimentoContaFim != null) {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";
				} else {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaInicio ";
				}
			}

			if (!indicadorContaPaga.equals("3")) {
				if (indicadorContaPaga.equals("1")) {
					consulta += " and exists ";
				} else {
					consulta += " and not exists ";
				}
				consulta += " (select conta.id " + " from Pagamento pgmt "
						+ " inner join pgmt.contaGeral contaGeral "
						+ " inner join contaGeral.conta conta "
						+ " where conta.id = cnta.id) ";
			}

			if (dataVencimentoContaInicio != null) {
				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim).setInteger(
						"normal", DebitoCreditoSituacao.NORMAL).setInteger(
						"retificada", DebitoCreditoSituacao.RETIFICADA)
						.setDate("dataVencimentoContaInicio",
								dataVencimentoContaInicio).setDate(
								"dataVencimentoContaFim",
								dataVencimentoContaFim).setParameterList(
								"idBanco", bancos).list();

			} else {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim).setInteger(
						"normal", DebitoCreditoSituacao.NORMAL).setInteger(
						"retificada", DebitoCreditoSituacao.RETIFICADA)
						.setParameterList("idBanco", bancos).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas do Conjunto de Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImoveis(Integer anoMes,
			Collection idsImovel, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim,
			String indicadorContaPaga) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, cnta.valorEsgoto, "
					+ "cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
					+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, cnta.referenciaContabil, "
					+ "cnta.ultimaAlteracao, imov, dcsan "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "left join cnta.debitoCreditoSituacaoAnterior dcsan "
					+ "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and imov.id in (:idsImovel) "
					+ "and cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if (dataVencimentoContaInicio != null) {
				if (dataVencimentoContaFim != null) {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";
				} else {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaInicio ";
				}
			}

			if (!indicadorContaPaga.equals("3")) {
				if (indicadorContaPaga.equals("1")) {
					consulta += "and exists ";
				} else {
					consulta += "and not exists ";
				}
				consulta += "(select conta.id " + "from Pagamento pgmt "
						+ "inner join pgmt.contaGeral contaGeral "
						+ "inner join contaGeral.conta conta "
						+ "where conta.id = cnta.id) ";
			}

			if (dataVencimentoContaInicio != null) {
				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim)
						.setParameterList("idsImovel", idsImovel).setInteger(
								"normal", DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA).setDate(
								"dataVencimentoContaInicio",
								dataVencimentoContaInicio).setDate(
								"dataVencimentoContaFim",
								dataVencimentoContaFim).list();

			} else {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim)
						.setParameterList("idsImovel", idsImovel).setInteger(
								"normal", DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	public Collection pesquisarContasImoveis(Collection idsImovel, Integer anoMes, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim, String indicadorContaPaga, Date dataVencimentoInformada,
			boolean isDebitoEmConta) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, cnta.valorEsgoto, "
					+ "cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
					+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, cnta.referenciaContabil, "
					+ "cnta.ultimaAlteracao, imov, dcsan "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "left join cnta.debitoCreditoSituacaoAnterior dcsan "
					+ "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and imov.id in (:idsImovel) "
					+ "and cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada) "
					+ "and cnta.dataVencimentoConta < :dataVencimentoInformada";

			if (dataVencimentoContaInicio != null) {
				if (dataVencimentoContaFim != null) {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";
				} else {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaInicio ";
				}
			}
			
			if(isDebitoEmConta)
				consulta += " and cnta.indicadorDebitoConta = 1 ";

			if (!indicadorContaPaga.equals("3")) {
				if (indicadorContaPaga.equals("1")) {
					consulta += "and exists ";
				} else {
					consulta += "and not exists ";
				}
				consulta += "(select conta.id " + "from Pagamento pgmt "
						+ "inner join pgmt.contaGeral contaGeral "
						+ "inner join contaGeral.conta conta "
						+ "where conta.id = cnta.id) ";
			}

			if (dataVencimentoContaInicio != null) {
				retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
						.setParameterList("idsImovel", idsImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA).setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
						.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
						.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
						.setDate("dataVencimentoInformada", dataVencimentoInformada).list();

			} else {

				retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
						.setParameterList("idsImovel", idsImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA).setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
						.setDate("dataVencimentoInformada", dataVencimentoInformada).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	
	}
	
	public Collection pesquisarContasImoveis(Collection idsImovel, Integer anoMes, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim, String indicadorContaPaga, Date dataVencimentoInformada)
					throws ErroRepositorioException {
		
		Collection retorno = this.pesquisarContasImoveis(idsImovel, anoMes, dataVencimentoContaInicio, dataVencimentoContaFim, anoMesFim,
				indicadorContaPaga, dataVencimentoInformada, false);
		
		return retorno;
	}

	/**
	 * 
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * 
	 * @param anoMes
	 * @param idCliente
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection gerarArquivoTextoFaturamento(int anoMes, Integer idCliente)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String sql = "select conta.imov_id as idImovel," // 0
					+ " conta.cnta_amreferenciaconta as amReferencia," // 1
					+ " conta.cnta_vlagua as valorAgua," // 2
					+ " conta.cnta_vlesgoto as valorEsgoto," // 3
					+ " conta.cnta_vldebitos as valorDebitos," // 4
					+ " conta.cnta_vlcreditos as valorCreditos," // 5
					+ " medicao.mdhi_dtleituraatualfaturamento as dataLeituraAtualFaturamento," // 6
					+ " medicao.mdhi_nnleituraatualfaturamento as leituraAtualFaturamento," // 7
					+ " conta.cnta_id as idConta," // 8
					+ " municipio.muni_nmmunicipio as nomeMunicipio," // 9
					+ " conta.cnta_nnconsumoagua as consumoAgua," // 10
					+ " conta.cnta_nnconsumoesgoto as consumoEsgoto," // 11
					+ " conta.cnta_dtvencimentoconta as vencimentoConta"// 12

					+ " from faturamento.conta conta"

					+ " left join micromedicao.medicao_historico medicao on medicao.lagu_id = conta.imov_id and medicao.mdhi_amleitura = :anoMes"
					+ " inner join cadastro.cliente_imovel clienteImovel on clienteImovel.imov_id = conta.imov_id and crtp_id = :relacaoTipo and clim_dtrelacaofim is null"
					+ " inner join cadastro.cliente cliente on cliente.clie_id = clienteImovel.clie_id"
					+ " inner join cadastro.setor_comercial setor on setor.loca_id = conta.loca_id and setor.stcm_cdsetorcomercial = conta.cnta_cdsetorcomercial"
					+ " left join cadastro.municipio municipio on municipio.muni_id = setor.muni_id"

					+ " where conta.cnta_amreferenciaconta = :anoMes and  "
					+ " conta.dcst_idatual in (0,1,2) "
					+ " and cliente.clie_id = :idCliente"
					+ " and cliente.clie_icgeraarquivotexto = 1";

			retorno = session.createSQLQuery(sql).addScalar("idImovel",
					Hibernate.INTEGER)// 0
					.addScalar("amReferencia", Hibernate.INTEGER)// 1
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)// 2
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)// 3
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)// 4
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)// 5
					.addScalar("dataLeituraAtualFaturamento", Hibernate.DATE)// 6
					.addScalar("leituraAtualFaturamento", Hibernate.INTEGER)// 7
					.addScalar("idConta", Hibernate.INTEGER)// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)// 9
					.addScalar("consumoAgua", Hibernate.INTEGER)// 10
					.addScalar("consumoEsgoto", Hibernate.INTEGER)// 11
					.addScalar("vencimentoConta", Hibernate.DATE)// 12
					.setInteger("anoMes", anoMes).setInteger("idCliente",
							idCliente).setInteger("relacaoTipo",
							ClienteRelacaoTipo.RESPONSAVEL).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * 
	 * @param anoMes
	 * @param idCliente
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection gerarArquivoTextoFaturamentoCreditos(int anoMes,
			Integer idCliente, Integer imovelId)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String sql = "select conta.imov_id as idImovel," // 0
					+ " conta.cnta_amreferenciaconta as amReferencia," // 1
					+ " cnta_vlcreditos as valorCreditos," // 2
					+ " medicao.mdhi_dtleituraatualfaturamento as dataLeituraAtualFaturamento," // 3
					+ " medicao.mdhi_nnleituraatualfaturamento as leituraAtualFaturamento," // 4
					+ " conta.cnta_id as idConta," // 5
					+ " conta.cnta_nnconsumoesgoto as consumoEsgoto," // 6
					+ " creditoRealizado.crti_id as idCreditoTipo," // 7
					+ " creditoRealizado.crrz_vlcredito as valorCredito" // 8

					+ " from faturamento.conta conta"

					+ "  left join micromedicao.medicao_historico medicao on medicao.lagu_id = conta.imov_id and medicao.mdhi_amleitura = :anoMes"
					+ " inner join cadastro.cliente_imovel clienteImovel on clienteImovel.imov_id = conta.imov_id and crtp_id = :relacaoTipo and clim_dtrelacaofim is null"
					+ " inner join cadastro.cliente cliente on cliente.clie_id = clienteImovel.clie_id"
					+ " inner join faturamento.credito_realizado creditoRealizado on creditoRealizado.cnta_id = conta.cnta_id"

					+ " where conta.cnta_amreferenciaconta = :anoMes and  "
					+ " conta.dcst_idatual in (0,1,2) "
					+ " and cliente.clie_id = :idCliente"
					+ " and cliente.clie_icgeraarquivotexto = 1"
					+ " and conta.imov_id = :imovelId";

			retorno = session.createSQLQuery(sql).addScalar("idImovel",
					Hibernate.INTEGER)// 0
					.addScalar("amReferencia", Hibernate.INTEGER)// 1
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)// 2
					.addScalar("dataLeituraAtualFaturamento", Hibernate.DATE)// 3
					.addScalar("leituraAtualFaturamento", Hibernate.INTEGER)// 4
					.addScalar("idConta", Hibernate.INTEGER)// 5
					.addScalar("consumoEsgoto", Hibernate.INTEGER)// 6
					.addScalar("idCreditoTipo", Hibernate.INTEGER)// 7
					.addScalar("valorCredito", Hibernate.BIG_DECIMAL)// 8
					.setInteger("anoMes", anoMes).setInteger("idCliente",
							idCliente).setInteger("relacaoTipo",
							ClienteRelacaoTipo.RESPONSAVEL).setInteger(
							"imovelId", imovelId).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * 
	 * @param anoMes
	 * @param idCliente
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection gerarArquivoTextoFaturamentoServicos(int anoMes,
			Integer idCliente, Integer imovelId)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String sql = "select conta.imov_id as idImovel," // 0
					+ " conta.cnta_amreferenciaconta as amReferencia," // 1
					+ " conta.cnta_vldebitos as valorDebitos," // 2
					+ " medicao.mdhi_dtleituraatualfaturamento as dataLeituraAtualFaturamento," // 3
					+ " medicao.mdhi_nnleituraatualfaturamento as leituraAtualFaturamento," // 4
					+ " conta.cnta_id as idConta," // 5
					+ " conta.cnta_nnconsumoesgoto as consumoEsgoto," // 6
					+ " debitoCobrado.dbtp_id as idDebitoTipo," // 7
					+ " debitoCobrado.dbcb_vlprestacao as valorPrestacao" // 8

					+ " from faturamento.conta conta"

					+ "  left join micromedicao.medicao_historico medicao on medicao.lagu_id = conta.imov_id and medicao.mdhi_amleitura = :anoMes"
					+ " inner join cadastro.cliente_imovel clienteImovel on clienteImovel.imov_id = conta.imov_id and crtp_id = :relacaoTipo and clim_dtrelacaofim is null"
					+ " inner join cadastro.cliente cliente on cliente.clie_id = clienteImovel.clie_id"
					+ " inner join faturamento.debito_cobrado debitoCobrado on debitoCobrado.cnta_id = conta.cnta_id"

					+ " where conta.cnta_amreferenciaconta = :anoMes and  "
					+ " conta.dcst_idatual in (0,1,2) "
					+ " and cliente.clie_id = :idCliente"
					+ " and cliente.clie_icgeraarquivotexto = 1"
					+ " and conta.imov_id = :imovelId";

			retorno = session.createSQLQuery(sql).addScalar("idImovel",
					Hibernate.INTEGER)// 0
					.addScalar("amReferencia", Hibernate.INTEGER)// 1
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)// 2
					.addScalar("dataLeituraAtualFaturamento", Hibernate.DATE)// 3
					.addScalar("leituraAtualFaturamento", Hibernate.INTEGER)// 4
					.addScalar("idConta", Hibernate.INTEGER)// 5
					.addScalar("consumoEsgoto", Hibernate.INTEGER)// 6
					.addScalar("idDebitoTipo", Hibernate.INTEGER)// 7
					.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL)// 8
					.setInteger("anoMes", anoMes).setInteger("idCliente",
							idCliente).setInteger("relacaoTipo",
							ClienteRelacaoTipo.RESPONSAVEL).setInteger(
							"imovelId", imovelId).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * 
	 * @param anoMes
	 * @param idCliente
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection gerarArquivoTextoFaturamentoImpostos(int anoMes,
			Integer idCliente, Integer imovelId)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String sql = "select conta.imov_id as idImovel," // 0
					+ " conta.cnta_amreferenciaconta as amReferencia," // 1
					+ " medicao.mdhi_dtleituraatualfaturamento as dataLeituraAtualFaturamento," // 2
					+ " medicao.mdhi_nnleituraatualfaturamento as leituraAtualFaturamento," // 3
					+ " conta.cnta_id as idConta," // 4
					+ " (select sum(cnid_vlimposto) from faturamento.conta_impostos_deduzidos contaImposto "
					+ " where contaImposto.cnta_id = conta.cnta_id) somaImpostos" // 5

					+ " from faturamento.conta conta"

					+ "  left join micromedicao.medicao_historico medicao on medicao.lagu_id = conta.imov_id and medicao.mdhi_amleitura = :anoMes"
					+ " inner join cadastro.cliente_imovel clienteImovel on clienteImovel.imov_id = conta.imov_id and crtp_id = :relacaoTipo and clim_dtrelacaofim is null"
					+ " inner join cadastro.cliente cliente on cliente.clie_id = clienteImovel.clie_id"

					+ " where conta.cnta_amreferenciaconta = :anoMes and  "
					+ " conta.dcst_idatual in (0,1,2) "
					+ " and cliente.clie_id = :idCliente"
					+ " and cliente.clie_icgeraarquivotexto = 1"
					+ " and conta.imov_id = :imovelId";

			retorno = session.createSQLQuery(sql).addScalar("idImovel",
					Hibernate.INTEGER)// 0
					.addScalar("amReferencia", Hibernate.INTEGER)// 1
					.addScalar("dataLeituraAtualFaturamento", Hibernate.DATE)// 2
					.addScalar("leituraAtualFaturamento", Hibernate.INTEGER)// 3
					.addScalar("idConta", Hibernate.INTEGER)// 4
					.addScalar("somaImpostos", Hibernate.BIG_DECIMAL)// 5
					.setInteger("anoMes", anoMes).setInteger("idCliente",
							idCliente).setInteger("relacaoTipo",
							ClienteRelacaoTipo.RESPONSAVEL).setInteger(
							"imovelId", imovelId).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas do Conjunto de Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImoveis(Integer anoMes, Collection idsImovel,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim, String indicadorContaPaga)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try { // 0 ,1
			consulta = "select cnta, imov "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join fetch cnta.consumoTarifa cstf "
					+ "inner join fetch cnta.quadraConta quad "
					+ "inner join fetch quad.setorComercial strc "
					+ "inner join fetch imov.consumoTarifa cstfImovel "
					+ "inner join fetch imov.quadra quadImovel "
					+ "inner join fetch quadImovel.setorComercial strcImovel "
					+ "left join fetch cnta.ligacaoEsgotoSituacao "
					+ "left join fetch cnta.ligacaoAguaSituacao "
					+ "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and imov.id in (:idsImovel) "
					+ "and cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if (dataVencimentoContaInicio != null) {
				if (dataVencimentoContaFim != null) {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";
				} else {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaInicio ";
				}
			}

			if (!indicadorContaPaga.equals("3")) {
				if (indicadorContaPaga.equals("1")) {
					consulta += "and exists ";
				} else {
					consulta += "and not exists ";
				}
				consulta += "(select conta.id " + "from Pagamento pgmt "
						+ "inner join pgmt.contaGeral contaGeral "
						+ "inner join contaGeral.conta conta "
						+ "where conta.id = cnta.id) ";
			}

			if (dataVencimentoContaFim != null) {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim)
						.setParameterList("idsImovel", idsImovel).setInteger(
								"normal", DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA).setDate(
								"dataVencimentoContaInicio",
								dataVencimentoContaInicio).setDate(
								"dataVencimentoContaFim",
								dataVencimentoContaFim).list();

			} else {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim)
						.setParameterList("idsImovel", idsImovel).setInteger(
								"normal", DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o maior valor do sequêncial de impressão e soma 10 ao valor
	 * maximo retornado
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro
	 * @date 27/03/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Short recuperarValorMaximoSequencialImpressaoMais10()
			throws ErroRepositorioException {

		Short retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select max(lict.sequenciaImpressao)+10 "
					+ "from LancamentoItemContabil lict ";

			// executa o hql
			retorno = ((Integer) session.createQuery(consulta).uniqueResult())
					.shortValue();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Remove o id da conta dos pagamentos referentes a conta para poder mandar
	 * a conta para o histórico.
	 * 
	 * [UC0000] Gerar Histórco para encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 01/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void apagarIdContaPagamentos(Integer idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "UPDATE Pagamento "
					+ "SET contaGeral = null "
					+ "WHERE id in (select pgmt.id from Pagamento pgmt where pgmt.contaGeral.id = :idConta) ";

			session.createQuery(consulta).setInteger("idConta", idConta)
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Remove o id do débito a cobrar dos pagamentos referentes a conta para
	 * poder mandar o débito a cobrar para o histórico.
	 * 
	 * [UC0000] Gerar Histórco para encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 01/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void apagarIdDebitoACobrarPagamentos(Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "UPDATE Pagamento "
					+ "SET debitoACobrarGeral = null "
					+ "WHERE id in (select pgmt.id from Pagamento pgmt where pgmt.debitoACobrarGeral.id = :idDebitoACobrar) ";

			session.createQuery(consulta).setInteger("idDebitoACobrar",
					idDebitoACobrar).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisa as contas canceladas por localidade com paginação
	 * 
	 * [UC0000] Gerar Historico para Encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 03/04/2007
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param numeroIndice
	 * @param quantidadeRegistros
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContasCanceladasPorMesAnoReferenciaContabil(
			int anoMesReferenciaContabil, Integer idSetorComercial,
			Integer numeroIndice, Integer quantidadeRegistros)
			throws ErroRepositorioException {
		Collection<Conta> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cnta "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imo "
					+ "where imo.setorComercial =:idSetorComercial "
					+ "and cnta.referenciaContabil <= :anoMesReferenciaContabil "
					+ "and ((cnta.debitoCreditoSituacaoAtual = :situacaoCancelada or cnta.debitoCreditoSituacaoAtual = :situacaoRetificacao or cnta.debitoCreditoSituacaoAtual = :situacaoParcelada or cnta.debitoCreditoSituacaoAtual = :situacaoDebitoPrescrito or cnta.debitoCreditoSituacaoAtual = :situacaoDebitoPrescritoContasIncluidas) "
					+ "or (cnta.valorAgua + cnta.valorEsgoto + cnta.debitos - cnta.valorCreditos - cnta.valorImposto = 0) )";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"idSetorComercial", idSetorComercial).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("situacaoCancelada",
							DebitoCreditoSituacao.CANCELADA).setInteger(
							"situacaoRetificacao",
							DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)
					.setInteger("situacaoParcelada",
							DebitoCreditoSituacao.PARCELADA).setInteger(
							"situacaoDebitoPrescrito",
							DebitoCreditoSituacao.DEBITO_PRESCRITO)
					/**
					 * Alteração necessária para as contas incluidas canceladas 
					 * por débito prescrito também possm ir pra histórico*/
					.setInteger("situacaoDebitoPrescritoContasIncluidas",
							DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS)
					.setMaxResults(quantidadeRegistros).setFirstResult(
							numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] Emitir Aviso de Cobrança
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/04/2007
	 * 
	 */
	public Object[] pesquisarAnoMesEDiaVencimentoFaturamentoGrupo(
			Integer idImovel) throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT fatGrupo.anoMesReferencia,fatGrupo.diaVencimento "
					+ "FROM Imovel imov "
					+ "INNER JOIN imov.quadra qdr "
					+ "INNER JOIN qdr.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo fatGrupo "
					+ "WHERE imov.id = :idImovel ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * retorna o nome do cliente usuario da conta
	 * 
	 * @author Flávio Cordeiro
	 * @date 09/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String pesquisarClienteUsuarioConta(Integer idConta)
			throws ErroRepositorioException {
		String retorno = "";

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cliente.clie_nmcliente nome "
					+ "from cadastro.cliente_conta clienteConta "
					+ "inner join cadastro.cliente cliente on cliente.clie_id = clienteConta.clie_id "
					+ "where clienteConta.cnta_id =:idConta "
					+ "and clienteConta.crtp_id =:relacaoTipo ";

			// executa o hql
			retorno = (String) session.createSQLQuery(consulta).addScalar(
					"nome", Hibernate.STRING).setInteger("idConta", idConta)
					.setInteger("relacaoTipo", ClienteRelacaoTipo.USUARIO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorMultasCobradasPorFinanciamnetoTipo(
			int idConta) throws ErroRepositorioException {

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(dbcb.valorPrestacao) "
					+ "from DebitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join dbcb.financiamentoTipo fntp "
					+ "where cnta.id = :idConta "
					+ "and (fntp.id = :parcAgua or "
					+ "fntp.id = :parcEsgoto or fntp.id = :parcServico or "
					+ "fntp.id = :jurosParc)";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idConta", idConta).setInteger("parcAgua",
					FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger(
					"parcEsgoto", FinanciamentoTipo.PARCELAMENTO_ESGOTO)
					.setInteger("parcServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO).setInteger(
							"jurosParc", FinanciamentoTipo.JUROS_PARCELAMENTO)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso calcula a tarifa miníma de água para um imóvel
	 * (SUBCATEGORIA)
	 * 
	 * [UC0451] Obter Tarifa Miníma de Água para um Imóvel
	 * 
	 * @author Raphael Rossiter
	 * @date 14/04/2007
	 * 
	 * @param consumoTarifaVigencia
	 * @param subcategoria
	 * @return Object
	 * @throws ErroRepositorioException
	 */
	public Object pesquisarTarifaMinimaCategoriaVigenciaPorSubcategoria(
			ConsumoTarifaVigencia consumoTarifaVigencia,
			Subcategoria subcategoria) throws ErroRepositorioException {

		Object retorno = null;

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select ct.valorTarifaMinima "
					+ "from ConsumoTarifaCategoria ct "
					+ "inner join ct.consumoTarifaVigencia ctv "
					+ "inner join ct.subCategoria sc "
					+ "where ctv.id = :consumoTarifaVigenciaId "
					+ "and sc.id = :subcategoriaId";

			retorno = session.createQuery(consulta).setInteger(
					"consumoTarifaVigenciaId", consumoTarifaVigencia.getId())
					.setInteger("subcategoriaId", subcategoria.getId())
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<IDebitoCobrado> pesquisarDebitosCobrados(Integer idConta) throws ErroRepositorioException {

		Collection<IDebitoCobrado> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "select dbcb " + "from DebitoCobrado dbcb inner join dbcb.conta cnta where cnta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection<IDebitoCobrado> pesquisarDebitosCobradosHistorico(Integer idConta) throws ErroRepositorioException {

		Collection<IDebitoCobrado> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "select debito " + "from DebitoCobradoHistorico debito inner join debito.contaHistorico conta where conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<ICreditoRealizado> pesquisarCreditosRealizados(Integer idConta) throws ErroRepositorioException {

		Collection<ICreditoRealizado> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "select crrz from CreditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "INNER JOIN FETCH crrz.creditoTipo crtp "
					+ "LEFT JOIN FETCH crrz.creditoARealizarGeral crgr "
					+ "where cnta.id = :idConta "
					+ "ORDER BY crtp.id, crrz.anoMesReferenciaCredito ";
			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();
			

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0004] Verificar Critério
	 * de Cobrança para Imóvel Pesquisa a soma dos imoveis com parcelamento.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarQuantidadeDebitosCobradosComParcelamento(
			Collection<ContaValoresHelper> colecaoContasValores)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar o valor pesquisado
		int retorno = 0;

		if (colecaoContasValores != null && !colecaoContasValores.isEmpty()) {
			Collection idsContas = new ArrayList();
			Iterator iteContaValoresHelper = colecaoContasValores.iterator();
			while (iteContaValoresHelper.hasNext()) {
				ContaValoresHelper contaValoresHelper = (ContaValoresHelper) iteContaValoresHelper
						.next();
				if (contaValoresHelper.getConta() != null) {
					idsContas.add(contaValoresHelper.getConta().getId());
				}
			}

			// cria uma sessão com o hibernate
			Session session = HibernateUtil.getSession();

			// cria a variável que vai conter o hql
			String consulta;

			try {
				// constroi o hql
				consulta = "select count(distinct cnta.id) "
						+ "from DebitoCobrado dbcb "
						+ "inner join dbcb.conta cnta "
						+ "inner join dbcb.financiamentoTipo fntp "
						+ "where cnta.id in (:idsConta) "
						+ "and (fntp.id = :parcAgua or "
						+ "fntp.id = :parcEsgoto or fntp.id = :parcServico or "
						+ "fntp.id = :jurosParc)";

				// executa o hql
				retorno = (Integer) session.createQuery(consulta)
						.setParameterList("idsConta", idsContas)
						.setInteger("parcAgua",
								FinanciamentoTipo.PARCELAMENTO_AGUA)
						.setInteger("parcEsgoto",
								FinanciamentoTipo.PARCELAMENTO_ESGOTO)
						.setInteger("parcServico",
								FinanciamentoTipo.PARCELAMENTO_SERVICO)
						.setInteger("jurosParc",
								FinanciamentoTipo.JUROS_PARCELAMENTO)
						.uniqueResult();

			} catch (HibernateException e) {
				// levanta a exceção para a próxima camada
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				// fecha a sessão
				HibernateUtil.closeSession(session);
			}
		}

		return retorno;
	}

	/**
	 * Recupera os ids das contas do Conjunto de Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/04/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdContasImoveis(Integer anoMes,
			Collection idsImovel, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim,
			String indicadorContaPaga) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta.id "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and imov.id in (:idsImovel) "
					+ "and cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if (dataVencimentoContaInicio != null) {
				if (dataVencimentoContaFim != null) {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";
				} else {
					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaInicio ";
				}
			}

			if (!indicadorContaPaga.equals("3")) {
				if (indicadorContaPaga.equals("1")) {
					consulta += "and exists ";
				} else {
					consulta += "and not exists ";
				}
				consulta += "(select conta.id " + "from Pagamento pgmt "
						+ "inner join pgmt.contaGeral contaGeral "
						+ "inner join contaGeral.conta conta "
						+ "where conta.id = cnta.id) ";
			}

			if (dataVencimentoContaInicio != null) {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim)
						.setParameterList("idsImovel", idsImovel).setInteger(
								"normal", DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA).setDate(
								"dataVencimentoContaInicio",
								dataVencimentoContaInicio).setDate(
								"dataVencimentoContaFim",
								dataVencimentoContaFim).list();

			} else {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim)
						.setParameterList("idsImovel", idsImovel).setInteger(
								"normal", DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 25/04/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualConta(Integer idConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dcst.id " + "from Conta cnta "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "where cnta.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idConta", idConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 10/08/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualConta(Integer idImovel,
			Integer anoMesReferencia) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dcst.id "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "where imov.id = :idImovel AND cnta.referencia = :anoMesReferencia AND dcst.id <> "
					+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setInteger("anoMesReferencia",
					anoMesReferencia).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 28/04/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaFaixas(Integer idConta,
			Integer idCategoria, Integer idSubCategoria)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaCategoriaConsumoFaixa "
					+ "from ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa "
					+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.conta conta "
					+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.categoria categoria "
					+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.subcategoria subCategoria "
					+ "where conta.id = :idConta AND "
					+ "categoria.id = :idCategoria AND "
					+ "subCategoria.id = :idSubCategoria "
					+ "order by contaCategoriaConsumoFaixa.consumoFaixaInicio";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("idCategoria",
					idCategoria.intValue()).setInteger("idSubCategoria",
					idSubCategoria).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 02/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaSubCategoria(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select contaCategoria "
					+ "from ContaCategoria contaCategoria "
					+ "inner join contaCategoria.comp_id.conta conta "
					+ "inner join fetch contaCategoria.comp_id.categoria categoria "
					+ "inner join fetch contaCategoria.comp_id.subcategoria subCategoria "
					+ "where conta.id = :idConta ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).setInteger("idConta", idConta)
					.list()));

			/**
			 * alterado por pedro alexandre dia 23/01/2007
			 */
			/*
			 * consulta = "select contaCategoria " + "from ContaCategoria
			 * contaCategoria " + "inner join contaCategoria.comp_id.conta conta " +
			 * "inner join contaCategoria.comp_id.categoria categoria " + "where
			 * conta.id = :idConta " + "order by categoria.id";
			 * 
			 * Iterator iterator = session.createQuery(consulta).setInteger(
			 * "idConta", idConta.intValue()).iterate();
			 * 
			 * while (iterator.hasNext()) { ContaCategoria contaCategoria =
			 * (ContaCategoria) iterator .next(); // carrega todos os objetos
			 * Hibernate
			 * .initialize(contaCategoria.getComp_id().getCategoria());
			 * 
			 * retorno.add(contaCategoria); }
			 */
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id da Conta Retificada
	 * 
	 * @author Vivianne Sousa
	 * @date 27/04/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarContaRetificada(Integer idImovel,
			int anoMesReferenciaConta) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta.id " + "from Conta cnta "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "where cnta.imovel.id = :idImovel  "
					+ "and cnta.referencia = :anoMesReferenciaConta "
					+ "and dcst.id = :debitoCreditoSituacao ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setInteger("anoMesReferenciaConta",
					anoMesReferenciaConta).setInteger("debitoCreditoSituacao",
					DebitoCreditoSituacao.RETIFICADA).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gera credito a realizar para os imóveis de determinados grupos
	 * 
	 * BATCH PARA CORREÇÃO DA BASE
	 * 
	 * @author Sávio Luiz
	 * @date 02/05/2007
	 * 
	 */
	public Collection pesquisarDadosImoveisParaGerarCreditoARealizar(
			Collection idsGrupos, Integer anoMesReferenciaConta,
			Integer anoMesReferenciaDebito) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imov.id,"// 0 - Integer
					+ "loc.id,"// 1 - Integer
					+ "qdrImovel.id,"// 2 - Integer
					+ "qdrImovel.numeroQuadra,"// 3 - Integer
					+ "setComercial.codigo,"// 4 - Integer
					+ "imov.lote,"// 5 - Short
					+ "imov.subLote,"// 6 - Short
					+ "debCobrado.valorPrestacao "// 7 - BigDecimal
					+ "from DebitoCobrado debCobrado "
					+ "inner join debCobrado.conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join imov.localidade loc "
					+ "inner join imov.quadra qdrImovel "
					+ "inner join imov.setorComercial setComercial "
					+ "inner join cnta.quadraConta qdrConta "
					+ "inner join qdrConta.rota rot "
					+ "inner join rot.faturamentoGrupo ftgr "
					+ "inner join debCobrado.debitoTipo debTipo "
					+ "inner join cnta.debitoCreditoSituacaoAtual debCerdSitAtual "
					+ "where cnta.referencia = :anoMesReferenciaConta  "
					+ "and ftgr.id = 29"// in (:idsGrupos) "
					+ "and debTipo.id = :idDebitoTipo "
					+ "and debCobrado.anoMesReferenciaDebito = :anoMesReferenciaDebito "
					+ "and debCerdSitAtual.id = :idDebCerdSitAtual and "
					+ "cnta.id in (select pag.contaGeral.id "
					+ "from Pagamento pag "
					+ "where pag.contaGeral.id = cnta.id and "
					+ "pag.dataPagamento <= (cnta.dataVencimentoConta + 3))";

			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferenciaConta", anoMesReferenciaConta)
					// .setParameterList("idsGrupos", idsGrupos)
					.setInteger("idDebitoTipo", DebitoTipo.MULTA_IMPONTUALIDADE)
					.setInteger("anoMesReferenciaDebito",
							anoMesReferenciaDebito).setInteger(
							"idDebCerdSitAtual", DebitoCreditoSituacao.NORMAL)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id da Conta Retificada
	 * 
	 * @author Vivianne Sousa
	 * @date 08/05/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarAnoMesReferenciaFaturamentoGrupo(Integer idImovel)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select faturamentoGrupo.anoMesReferencia "
					+ "from Imovel imovel " + "left join imovel.quadra quadra "
					+ "left join quadra.rota rota "
					+ "left join rota.faturamentoGrupo faturamentoGrupo "
					+ "where imovel.id = :idImovel ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * Pesquisas os debitos para serem removidos
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas,
	 *            Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarParaRemocao(Rota rota,
			Integer anoMesReferenciaContabil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;

		try {
			consulta = "select dc.id "
					+ "from DebitoACobrar dc,ImovelDoacao imovDoacao "
					+ "inner join dc.imovel imov "
					+ "inner join imovDoacao.imovel imovD "
					+ "inner join imovDoacao.entidadeBeneficente entBenef "
					+ "inner join entBenef.debitoTipo debTipoEntBef "
					+ "inner join dc.debitoTipo debTipoACob ";

			/*
			 * Caso a rota não esteja com o indicador de rota alternativa ativo;
			 * a pesquisa dos imóveis será feita a partir de sua quadra.
			 */
			if (!rota.getIndicadorRotaAlternativa().equals(
					ConstantesSistema.SIM)) {

				consulta = consulta + "inner join imov.quadra qdr "
						+ "inner join qdr.rota rot ";
			}
			/*
			 * Caso contrário; a pesquisa dos imóveis será feita a partir da
			 * rota alternativa que estará associada ao mesmo.
			 */
			else {

				consulta = consulta + "inner join imov.rotaAlternativa rot ";
			}

			consulta = consulta
					+ "where rot.id = :idRota and "
					+ "dc.anoMesReferenciaContabil = :anoMesReferenciaContabil and "
					+ "dc.numeroPrestacaoCobradas = 0 and "
					+ "debTipoEntBef.id = debTipoACob.id and imov.id = imovD.id ";

			retorno = session.createQuery(consulta).setInteger("idRota",
					rota.getId().intValue()).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] - Gerar Relatório de Tarifa de Consumo
	 * 
	 * Pesquisas a data final de validade de uma tarifa de consumo
	 * 
	 * @author Rafael Corrêa
	 * @date 11/05/2007
	 * 
	 * @param Integer
	 *            idConsumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarDataFinalValidadeConsumoTarifa(
			Integer idConsumoTarifa, Date dataInicioVigencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Date retorno = null;
		try {
			consulta = "select ctv.dataVigencia "
					+ " from ConsumoTarifaVigencia ctv "
					+ " where ctv.consumoTarifa.id = :idConsumoTarifa "
					+ " and ctv.dataVigencia > :dataInicioVigencia "
					+ " order by ctv.dataVigencia";

			retorno = (Date) session.createQuery(consulta).setInteger(
					"idConsumoTarifa", idConsumoTarifa).setDate(
					"dataInicioVigencia", dataInicioVigencia).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] - Gerar Relatório Tarifa de Consumo
	 * 
	 * Pesquisas as tarifas de consumo para o relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 11/05/2007
	 * 
	 * @param descricao,
	 *            dataVigenciaInicial, dataVigenciaFinal
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConsumoTarifaRelatorio(String descricao,
			Date dataVigenciaInicial, Date dataVigenciaFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;

		try {

			consulta = "SELECT ct.cstf_id as idConsumoTarifa, ct.cstf_dsconsumotarifa as descricaoConsumoTarifa, " // 0, 1
					+ " ctg.catg_dscategoria as categoria, ctf.ctfx_nncosumofaixainicio as faixaInicial, " // 2, 3
					+ " ctf.ctfx_nnconsumofaixafim as faixaFinal, ctf.ctfx_vlconsumotarifa as custo, " // 4, 5
					+ " ctc.cstc_vltarifaminima as tarifaMinima, ctv.cstv_dtvigencia as dataVigencia, " // 6, 7
					+ " ctc.cstc_nnconsumominimo as consumoMinimo " // 8
					+ " FROM faturamento.consumo_tarifa ct "
					+ " INNER JOIN faturamento.consumo_tarifa_vigencia ctv on ctv.cstf_id = ct.cstf_id "
					+ " INNER JOIN faturamento.consumo_tarifa_categoria ctc on ctc.cstv_id = ctv.cstv_id "
					+ " INNER JOIN cadastro.categoria ctg on ctc.catg_id = ctg.catg_id "
					+ " INNER JOIN faturamento.consumo_tarifa_faixa ctf on ctf.cstc_id = ctc.cstc_id "
					+ " WHERE ";

			if (descricao != null && !descricao.trim().equals("")) {
				consulta = consulta + "ct.cstf_dsconsumotarifa LIKE '"
						+ descricao + "%' and ";
			}

			if (dataVigenciaInicial != null) {
				consulta = consulta
						+ " ctf.ctfx_nncosumofaixainicio between :dataVigenciaInicial and :dataVigenciaFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY ct.cstf_dsconsumotarifa, ctv.cstv_dtvigencia, ctc.cstc_id, ctf.ctfx_nncosumofaixainicio ";

			if (dataVigenciaInicial != null) {

				retorno = session.createSQLQuery(consulta).addScalar(
						"idConsumoTarifa", Hibernate.INTEGER).addScalar(
						"descricaoConsumoTarifa", Hibernate.STRING).addScalar(
						"categoria", Hibernate.STRING).addScalar(
						"faixaInicial", Hibernate.INTEGER).addScalar(
						"faixaFinal", Hibernate.INTEGER).addScalar("custo",
						Hibernate.BIG_DECIMAL).addScalar("tarifaMinima",
						Hibernate.BIG_DECIMAL).addScalar("dataVigencia",
						Hibernate.DATE).addScalar("consumoMinimo",
						Hibernate.INTEGER).setDate("dataVigenciaInicial",
						dataVigenciaInicial).setDate("dataVigenciaFinal",
						dataVigenciaFinal).list();

			} else {

				retorno = session.createSQLQuery(consulta).addScalar(
						"idConsumoTarifa", Hibernate.INTEGER).addScalar(
						"descricaoConsumoTarifa", Hibernate.STRING).addScalar(
						"categoria", Hibernate.STRING).addScalar(
						"faixaInicial", Hibernate.INTEGER).addScalar(
						"faixaFinal", Hibernate.INTEGER).addScalar("custo",
						Hibernate.BIG_DECIMAL).addScalar("tarifaMinima",
						Hibernate.BIG_DECIMAL).addScalar("dataVigencia",
						Hibernate.DATE).addScalar("consumoMinimo",
						Hibernate.INTEGER).list();

			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * Deleta as categorias do débito a cobrar
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas,
	 *            Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDebitosACobrarCategoria(Collection idsDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String delete = "delete DebitoACobrarCategoria dcc "
					+ "where dcc.debitoACobrar.id in (:idsDebitoACobrar) ";

			session.createQuery(delete).setParameterList("idsDebitoACobrar",
					idsDebitoACobrar).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * Deleta os debitos a cobrar e os debitos a cobrar geral para o ano e mes
	 * de faturamento. Esse caso é quando um faturamento é rodado mais de 1 vez.
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas,
	 *            Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDebitosACobrar(Collection idsDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String delete = "delete DebitoACobrar dc "
					+ "where dc.id in (:idsDebitoACobrar) ";

			session.createQuery(delete).setParameterList("idsDebitoACobrar",
					idsDebitoACobrar).executeUpdate();

			delete = "delete DebitoACobrarGeral dcg "
					+ "where dcg.id in (:idsDebitoACobrar) ";

			session.createQuery(delete).setParameterList("idsDebitoACobrar",
					idsDebitoACobrar).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera id de contas que estão em revisão por acão do usuario
	 * 
	 * @author Vivianne Sousa
	 * @date 14/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasEmRevisaoPorAcaoUsuario(Collection idsConta)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta.id "
					+ "from Conta cnta "
					+ "left join cnta.contaMotivoRevisao contaMotivoRevisao "
					+ "where cnta.id in (:idsConta) "
					+ "and contaMotivoRevisao.id <> :revisaoAutomaticaEstouroConsumo "
					+ "and contaMotivoRevisao.id <> :revisaoAutomaticaBaixoConsumo ";

			retorno = session
					.createQuery(consulta)
					.setParameterList("idsConta", idsConta)
					.setInteger(
							"revisaoAutomaticaEstouroConsumo",
							ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO)
					.setInteger("revisaoAutomaticaBaixoConsumo",
							ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas do Cliente
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasCliente(Integer codigoCliente,
			Short relacaoTipo, Integer anoMes, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select count(conta.id) from ClienteConta clienteConta "
					+ "inner join clienteConta.cliente cliente "
					+ "inner join clienteConta.conta conta "
					+ "inner join conta.debitoCreditoSituacaoAtual dcst ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo "
					+ "and conta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and dcst.id in(:normal, :incluida, :retificada) ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Integer) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao",
										new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaFim).uniqueResult();
					} else {

						retorno = (Integer) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao",
										new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaInicio)
								.uniqueResult();
					}
				} else {

					retorno = (Integer) session.createQuery(consulta)
							.setInteger("codigo", codigoCliente).setInteger(
									"anoMes", anoMes).setInteger("anoMesFim",
									anoMesFim).setInteger("normal",
									DebitoCreditoSituacao.NORMAL).setInteger(
									"incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada",
									DebitoCreditoSituacao.RETIFICADA).setShort(
									"relacao",
									new Short(relacaoTipo).shortValue())
							.uniqueResult();
				}

			}

			if (relacaoTipo == null) {

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Integer) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaFim).uniqueResult();
					} else {

						retorno = (Integer) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaInicio)
								.uniqueResult();

					}
				} else {

					retorno = (Integer) session.createQuery(consulta)
							.setInteger("codigo", codigoCliente).setInteger(
									"anoMes", anoMes).setInteger("anoMesFim",
									anoMesFim).setInteger("normal",
									DebitoCreditoSituacao.NORMAL).setInteger(
									"incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada",
									DebitoCreditoSituacao.RETIFICADA)
							.uniqueResult();
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Recupera as contas do Cliente
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasCliente(Integer codigoCliente,
			Short relacaoTipo, Integer anoMes, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim,
			Integer codigoClienteSuperior) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select conta.id, conta.referencia, conta.dataVencimentoConta, conta.valorAgua, conta.valorEsgoto, "
					+ "conta.debitos, conta.valorCreditos, conta.consumoAgua, conta.consumoEsgoto, "
					+ "conta.dataValidadeConta, conta.dataRevisao, conta.debitoCreditoSituacaoAtual, conta.referenciaContabil, "
					+ "conta.ultimaAlteracao, imov, dcsan "
					+ "from ClienteConta clienteConta "
					+ "inner join clienteConta.cliente cliente "
					+ "inner join clienteConta.conta conta "
					+ "inner join conta.imovel imov "
					+ "inner join conta.debitoCreditoSituacaoAtual dcst "
					+ "left join conta.debitoCreditoSituacaoAnterior dcsan ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where "
					+ "conta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and dcst.id in(:normal, :incluida, :retificada) ";

			Integer codigo = null;

			if (codigoClienteSuperior != null) {
				consulta += " and cliente.cliente.id = :codigo ";
				codigo = codigoClienteSuperior;
			} else {
				consulta += " and cliente.id = :codigo ";
				codigo = codigoCliente;
			}

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigo).setInteger(
										"anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao",
										new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaFim).list();
					} else {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigo).setInteger(
										"anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao",
										new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaInicio).list();
					}
				} else {

					retorno = (Collection) session.createQuery(consulta)
							.setInteger("codigo", codigo).setInteger("anoMes",
									anoMes).setInteger("anoMesFim", anoMesFim)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida",
									DebitoCreditoSituacao.INCLUIDA).setInteger(
									"retificada",
									DebitoCreditoSituacao.RETIFICADA).setShort(
									"relacao",
									new Short(relacaoTipo).shortValue()).list();
				}

			}

			if (relacaoTipo == null) {

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigo).setInteger(
										"anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaFim).list();

					}

					else {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigo).setInteger(
										"anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaInicio).list();
					}
				} else {

					retorno = (Collection) session.createQuery(consulta)
							.setInteger("codigo", codigo).setInteger("anoMes",
									anoMes).setInteger("anoMesFim", anoMesFim)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida",
									DebitoCreditoSituacao.INCLUIDA).setInteger(
									"retificada",
									DebitoCreditoSituacao.RETIFICADA).list();
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	public Collection pesquisarContasCliente(Integer codigoCliente, Short relacaoTipo, Integer anoMes, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim, Integer codigoClienteSuperior, Date dataVencimentoInformada,
			boolean isDebitoAutomatico) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select conta.id, conta.referencia, conta.dataVencimentoConta, conta.valorAgua, conta.valorEsgoto, "
					+ "conta.debitos, conta.valorCreditos, conta.consumoAgua, conta.consumoEsgoto, "
					+ "conta.dataValidadeConta, conta.dataRevisao, conta.debitoCreditoSituacaoAtual, conta.referenciaContabil, "
					+ "conta.ultimaAlteracao, imov, dcsan " + "from ClienteConta clienteConta "
					+ "inner join clienteConta.cliente cliente " + "inner join clienteConta.conta conta " + "inner join conta.imovel imov "
					+ "inner join conta.debitoCreditoSituacaoAtual dcst " + "left join conta.debitoCreditoSituacaoAnterior dcsan ";

			if (relacaoTipo != null) {
				consulta = consulta + " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where " + "conta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and dcst.id in(:normal, :incluida, :retificada) " + "and conta.dataVencimentoConta < :dataVencimentoInformada ";
			
			if(isDebitoAutomatico)
				consulta += " and cnta.indicadorDebitoConta = 1 ";

			Integer codigo = null;

			if (codigoClienteSuperior != null) {
				consulta += " and cliente.cliente.id = :codigo ";
				codigo = codigoClienteSuperior;
			} else {
				consulta += " and cliente.id = :codigo ";
				codigo = codigoCliente;
			}

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigo).setInteger("anoMes", anoMes)
								.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao", new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
								.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
								.setDate("dataVencimentoInformada", dataVencimentoInformada).list();
					} else {

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigo).setInteger("anoMes", anoMes)
								.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao", new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
								.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
								.setDate("dataVencimentoInformada", dataVencimentoInformada).list();
					}
				} else {

					retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigo).setInteger("anoMes", anoMes)
							.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
							.setShort("relacao", new Short(relacaoTipo).shortValue())
							.setDate("dataVencimentoInformada", dataVencimentoInformada).list();
				}

			}

			if (relacaoTipo == null) {

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigo).setInteger("anoMes", anoMes)
								.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
								.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
								.setDate("dataVencimentoInformada", dataVencimentoInformada).list();

					}

					else {

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigo).setInteger("anoMes", anoMes)
								.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
								.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
								.setDate("dataVencimentoInformada", dataVencimentoInformada).list();
					}
				} else {

					retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigo).setInteger("anoMes", anoMes)
							.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
							.setDate("dataVencimentoInformada", dataVencimentoInformada).list();
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Recupera as contas do Cliente
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasCliente(Integer codigoCliente,
			Short relacaoTipo, Integer anoMes, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select conta, imov "
					+ "from ClienteConta clienteConta "
					+ "inner join clienteConta.cliente cliente "
					+ "inner join clienteConta.conta conta "
					+ "inner join fetch conta.consumoTarifa cstf "
					+ "inner join fetch conta.quadraConta quad "
					+ "inner join fetch quad.setorComercial strc "
					+ "inner join conta.imovel imov "
					+ "inner join conta.debitoCreditoSituacaoAtual dcst "
					+ "left join conta.debitoCreditoSituacaoAnterior dcsan ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo "
					+ "and conta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and dcst.id in(:normal, :incluida, :retificada) ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao",
										new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaFim).list();

					} else {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao",
										new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaInicio).list();

					}
				} else {

					retorno = (Collection) session.createQuery(consulta)
							.setInteger("codigo", codigoCliente).setInteger(
									"anoMes", anoMes).setInteger("anoMesFim",
									anoMesFim).setInteger("normal",
									DebitoCreditoSituacao.NORMAL).setInteger(
									"incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada",
									DebitoCreditoSituacao.RETIFICADA).setShort(
									"relacao",
									new Short(relacaoTipo).shortValue()).list();
				}
			}

			if (relacaoTipo == null) {

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaFim).list();

					} else {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaInicio).list();

					}
				} else {

					retorno = (Collection) session.createQuery(consulta)
							.setInteger("codigo", codigoCliente).setInteger(
									"anoMes", anoMes).setInteger("anoMesFim",
									anoMesFim).setInteger("normal",
									DebitoCreditoSituacao.NORMAL).setInteger(
									"incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada",
									DebitoCreditoSituacao.RETIFICADA).list();
				}

			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas do Cliente
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdContasCliente(Integer codigoCliente,
			Short relacaoTipo, Integer anoMes, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select conta.id from ClienteConta clienteConta "
					+ "inner join clienteConta.cliente cliente "
					+ "inner join clienteConta.conta conta "
					+ "inner join conta.debitoCreditoSituacaoAtual dcst ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo "
					+ "and conta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "and dcst.id in(:normal, :incluida, :retificada) ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao",
										new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaFim).list();

					} else {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setShort("relacao",
										new Short(relacaoTipo).shortValue())
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaInicio).list();

					}
				} else {

					retorno = (Collection) session.createQuery(consulta)
							.setInteger("codigo", codigoCliente).setInteger(
									"anoMes", anoMes).setInteger("anoMesFim",
									anoMesFim).setInteger("normal",
									DebitoCreditoSituacao.NORMAL).setInteger(
									"incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada",
									DebitoCreditoSituacao.RETIFICADA).setShort(
									"relacao",
									new Short(relacaoTipo).shortValue()).list();
				}

			}
			if (relacaoTipo == null) {

				if (dataVencimentoContaInicio != null) {
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if (dataVencimentoContaFim != null) {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaFim).list();

					} else {

						retorno = (Collection) session.createQuery(consulta)
								.setInteger("codigo", codigoCliente)
								.setInteger("anoMes", anoMes).setInteger(
										"anoMesFim", anoMesFim).setInteger(
										"normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida",
										DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.setDate("dataVencimentoContaInicio",
										dataVencimentoContaInicio).setDate(
										"dataVencimentoContaFim",
										dataVencimentoContaInicio).list();

					}
				} else {

					retorno = (Collection) session.createQuery(consulta)
							.setInteger("codigo", codigoCliente).setInteger(
									"anoMes", anoMes).setInteger("anoMesFim",
									anoMesFim).setInteger("normal",
									DebitoCreditoSituacao.NORMAL).setInteger(
									"incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada",
									DebitoCreditoSituacao.RETIFICADA).list();
				}

			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Recupera id de conta(s) sem revisão ou em revisão por ação do usuário
	 * 
	 * @author Vivianne Sousa
	 * @date 14/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasNaoEmRevisaoOuEmRevisaoPorAcaoUsuario(
			Collection idsConta) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta.id "
					+ "from Conta cnta "
					+ "left join cnta.contaMotivoRevisao contaMotivoRevisao "
					+ "where cnta.id in (:idsConta) "
					+ "and (cnta.dataRevisao is not null "
					+ "or(contaMotivoRevisao.id <> :revisaoAutomaticaEstouroConsumo "
					+ "and contaMotivoRevisao.id <> :revisaoAutomaticaBaixoConsumo)) ";

			retorno = session
					.createQuery(consulta)
					.setParameterList("idsConta", idsConta)
					.setInteger(
							"revisaoAutomaticaEstouroConsumo",
							ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO)
					.setInteger("revisaoAutomaticaBaixoConsumo",
							ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os dados da conta historico p emitir a 2ª via [UC0482]Emitir 2ª
	 * Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaHistorico(Integer idConta)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT "
					+ " new "
					+ EmitirContaHelper.class.getName()
					+ " ( "
					+ "cntHist.id, "
					+ "cli.nome, "
					+ "cntHist.dataVencimentoConta, "
					+ "cntHist.anoMesReferenciaConta, "
					+ "cntHist.verificadorConta, "
					+ "cntHist.setorComercial, "
					+ "cntHist.numeroQuadra, "
					+ "cntHist.lote, "
					+ "cntHist.subLote, "
					+ "cntHist.consumoAgua, "
					+ "cntHist.consumoEsgoto, "
					+ "cntHist.valorAgua, "
					+ "cntHist.valorEsgoto, "
					+ "cntHist.valorDebitos, "
					+ "cntHist.valorCreditos, "
					+ "cntHist.valorImposto, "
					+ "cntHist.dataValidadeConta, "
					+ "cntHist.valorRateioAgua, "
					+ "cntHist.valorRateioEsgoto, "
					+ "imovel.id, "
					+ "loc.id, "
					+ "gerenciaRegional.id, "
					+ "gerenciaRegional.nome, "
					+ "ligacaoAguaSituacao.id, "
					+ "ligacaoEsgotoSituacao.id, "
					+ "imovelPerfil.id, "
					+ "setorComercial.id, "
					+ "faturamentoGrupo.id, "
					+ "emp.id, "
					+ "loc.descricao, "
					+ "ligacaoAguaSituacao.descricao, "
					+ "ligacaoEsgotoSituacao.descricao, "
					+ "imovelContaEnvio.id, "
					+ "cntHist.percentualEsgoto, "
					+ "imovel.nomeImovel, "
					+ "imovel.codigoDebitoAutomatico, " 
					+ "faturamentoGrupo.anoMesReferencia) "
					+ "from ClienteContaHistorico cliCntHist "
					+ "RIGHT JOIN cliCntHist.contaHistorico cntHist "
					+ "LEFT JOIN cliCntHist.clienteRelacaoTipo crt "
					+ "LEFT JOIN cliCntHist.cliente cli "
					+ "LEFT JOIN cntHist.contaMotivoRevisao cmr "
					+ "LEFT JOIN cntHist.quadra quadraConta "
					+ "LEFT JOIN cntHist.localidade loc "
					+ "LEFT JOIN loc.gerenciaRegional gerenciaRegional "
					+ "LEFT JOIN cntHist.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "LEFT JOIN cntHist.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "LEFT JOIN cntHist.imovelPerfil imovelPerfil "
					+ "LEFT JOIN quadraConta.rota rota "
					+ "LEFT JOIN rota.empresa emp "
					+ "LEFT JOIN quadraConta.setorComercial setorComercial "
					+ "LEFT JOIN rota.faturamentoGrupo faturamentoGrupo "
					+ "LEFT JOIN cntHist.imovel imovel "
					+ "LEFT JOIN imovel.imovelContaEnvio imovelContaEnvio "
					+ "WHERE  cntHist.id = :idConta "
					+ "AND crt.id = :usuario "
					+ "ORDER BY cntHist.anoMesReferenciaConta,emp.id,loc.id,cntHist.setorComercial,"
					+ "cntHist.numeroQuadra,cntHist.lote,cntHist.subLote";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("usuario",
					ClienteRelacaoTipo.USUARIO.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id do cliente responsável pela conta historico [UC0482]Emitir
	 * 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdClienteResponsavelContaHistorico(Integer idConta)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cli.id "
					+ "from ClienteContaHistorico cliCntHist "
					+ "inner join cliCntHist.contaHistorico cntHist "
					+ "inner join cliCntHist.clienteRelacaoTipo crt "
					+ "inner join cliCntHist.cliente cli "
					+ "where cntHist.id = :idConta AND "
					+ "crt.id = :idResponsavel";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idConta", idConta).setInteger("idResponsavel",
					ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna a soma de quantidade economia
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0007] Obter Quantidade de Economias da Conta Historico
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Short obterQuantidadeEconomiasContaHistorico(Integer idConta)
			throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(contaCategoriaHist.quantidadeEconomia) "
					+ "from ContaCategoriaHistorico contaCategoriaHist "
					+ "left join contaCategoriaHist.comp_id.contaHistorico contaHist "
					+ "where contaHist.id = :idConta";

			retorno = (Short) session.createQuery(consulta).setInteger(
					"idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * Pesquisa as contas do cliente responsável para todos os grupos de
	 * faturamento.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Pedro Alexandre
	 * @date 17/05/2007
	 * 
	 * @param idTipoConta
	 * @param numeroPaginas
	 * @param anoMesReferencia
	 * @param indicadorEmissaoExtratoFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavel(
			Collection<Integer> idTipoConta, Integer numeroPaginas,
			Integer anoMesReferencia, Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado,Integer imovelContaEnvio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega "// 41
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id in (:idTipoConta) AND "
					+ "contaImpressao.empr_id is null AND ";
			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2 ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"tipoConta", Hibernate.INTEGER).addScalar(
							"rotaEntrega", Hibernate.INTEGER).addScalar(
							"seqRotaEntrega", Hibernate.INTEGER)
					.setParameterList("idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setMaxResults(
							1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa as contas do cliente responsável para todos os grupos de
	 * faturamento.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Pedro Alexandre
	 * @date 17/05/2007
	 * 
	 * @param idTipoConta
	 * @param numeroPaginas
	 * @param anoMesReferencia
	 * @param indicadorEmissaoExtratoFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelCAER(
			Collection<Integer> idTipoConta, Integer numeroPaginas,
			Integer anoMesReferencia, Short indicadorEmissaoExtratoFaturamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega, "// 41
					+ "imovel.imov_nnquadraEntrega as numeroQuadraEntrega "// 42
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "WHERE contaImpressao.cttp_id in (:idTipoConta) "
					+ "AND contaImpressao.empr_id is null "
					+ "AND contaImpressao.cnti_amreferenciaconta = :anoMesReferencia"
					+ " AND cliCnt.crtp_id = :idResposavel "
					+ "AND imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"tipoConta", Hibernate.INTEGER).addScalar(
							"rotaEntrega", Hibernate.INTEGER).addScalar(
							"seqRotaEntrega", Hibernate.INTEGER).addScalar(
									"numeroQuadraEntrega", Hibernate.INTEGER)
					.setParameterList("idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setInteger(
							"anoMesReferencia", anoMesReferencia)
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaHistorico(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select contaCategoriaHist "
					+ "from ContaCategoriaHistorico contaCategoriaHist "
					+ " inner join fetch contaCategoriaHist.comp_id.categoria categoria "
					+ " inner join fetch contaCategoriaHist.comp_id.subcategoria subcategoria "
					+ " inner join fetch contaCategoriaHist.comp_id.contaHistorico conta "
					+ "where contaCategoriaHist.comp_id.contaHistorico.id = :idConta ";

			retorno = new ArrayList(session.createQuery(consulta).setInteger("idConta", idConta).list());

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * @param idConta
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaHistoricoFaixas(Integer idConta,
			Integer idCategoria) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaCategoriaConsumoFaixaHistorico "
					+ "from ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistorico "
					+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.contaHistorico contaHist "
					+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.categoria categoria "
					+ "where contaHist.id = :idConta AND "
					+ "categoria.id = :idCategoria "
					+ "order by contaCategoriaConsumoFaixaHistorico.consumoFaixaInicio";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("idCategoria",
					idCategoria.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do conta impostos deduzidos
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0015] Gerar Linhas dos Impostos Deduzidos
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParmsContaImpostosDeduzidosHistorico(
			Integer idConta) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select impostoTipo.descricaoAbreviada,"// 0
					+ "contaImpostosDeduzidosHist.percentualAliquota," // 1
					+ "contaImpostosDeduzidosHist.valorImposto " // 1
					+ "from ContaImpostosDeduzidosHistorico contaImpostosDeduzidosHist "
					+ "inner join contaImpostosDeduzidosHist.contaHistorico contaHist "
					+ "inner join contaImpostosDeduzidosHist.impostoTipo impostoTipo "
					+ "where contaHist.id = :idConta";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object com a soma do valor dos debitos
	 * cobrados de parcelamento,o numero da prestacao e o numero total de
	 * prestações
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParmsDebitoAutomaticoHistorico(
			Integer idConta) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobradoHist.valorPrestacao),debCobradoHist.numeroPrestacaoDebito,"
					+ "debCobradoHist.numeroPrestacao,debCobradoHist.numeroParcelaBonus "
					+ "from DebitoCobradoHistorico debCobradoHist "
					+ "inner join debCobradoHist.financiamentoTipo finTipo "
					+ "inner join debCobradoHist.contaHistorico contaHist "
					+ "where contaHist.id = :idConta AND "
					+ "(finTipo.id = :parcelamentoAgua OR finTipo.id = :parcelamentoEsgoto OR "
					+ "finTipo.id = :parcelamentoServicos) "
					+ "group by debCobradoHist.numeroPrestacaoDebito,debCobradoHist.numeroPrestacao,debCobradoHist.numeroParcelaBonus ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("parcelamentoAgua",
					FinanciamentoTipo.PARCELAMENTO_AGUA)
					.setInteger("parcelamentoEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
							"parcelamentoServicos",
							FinanciamentoTipo.PARCELAMENTO_SERVICO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * 
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsDebitoCobradoHistoricoPorTipo(Integer idConta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobradoHist.valorPrestacao), "// 0
					+ "debCobradoHist.numeroPrestacaoDebito," // 1
					+ "debCobradoHist.numeroPrestacao, "// 2
					+ "debCobradoHist.anoMesReferenciaDebito, "// 3
					+ "debitoTipo.id, "// 4
					+ "debCobradoHist.debitoTipo.descricao, "// 5
					+ "debCobradoHist.numeroParcelaBonus " // 6
					+ "from DebitoCobradoHistorico debCobradoHist "
					+ "inner join debCobradoHist.financiamentoTipo finTipo "
					+ "inner join debCobradoHist.debitoTipo debitoTipo "
					+ "inner join debCobradoHist.contaHistorico contaHist "
					+ "where contaHist.id = :idConta AND "
					+ "( finTipo.id <> :parcelamentoAgua"
					+ " and finTipo.id <> :parcelamentoEsgoto"
					+ " and finTipo.id <> :parcelamentoServicos )"
					+ "group by "
					+ "debitoTipo.id, "
					+ "debCobradoHist.numeroPrestacaoDebito,"
					+ "debCobradoHist.numeroPrestacao, "
					+ "debCobradoHist.anoMesReferenciaDebito, "
					+ "debCobradoHist.debitoTipo.descricao, "
					+ "debCobradoHist.numeroParcelaBonus "
					+ "order by debitoTipo.id,debCobradoHist.anoMesReferenciaDebito desc";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("parcelamentoAgua",
					FinanciamentoTipo.PARCELAMENTO_AGUA)
					.setInteger("parcelamentoEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
							"parcelamentoServicos",
							FinanciamentoTipo.PARCELAMENTO_SERVICO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do crédito realizado ordenado pelo
	 * tipo de crédito
	 * 
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0014] Gerar Linhas dos Creditos Realizados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsCreditoRealizadoHistoricoPorTipo(Integer idConta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select credRealizadoHist.valorCredito,"// 0
					+ "credRealizadoHist.numeroPrestacaoCredito," // 1
					+ "credRealizadoHist.numeroPrestacao, "// 2
					+ "credRealizadoHist.anoMesReferenciaCredito, "// 3
					+ "creditoTipo.id, "// 4
					+ "creditoTipo.descricao, "// 5
					+ "credRealizadoHist.numeroParcelaBonus "// 6
					+ "from CreditoRealizadoHistorico credRealizadoHist "
					+ "inner join credRealizadoHist.creditoTipo creditoTipo "
					+ "inner join credRealizadoHist.contaHistorico contaHist "
					+ "where contaHist.id = :idConta "
					+ "order by creditoTipo.id,credRealizadoHist.anoMesReferenciaCredito desc";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Este caso de uso permite gerar um ralatorio analitico do faturamento
	 * 
	 * [UC0xxx]Gerar Relatório Analítico do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 18/05/2007
	 * 
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @param indicadorLocalidadeInformatizada
	 * @param idLocalidades
	 * @param idSetores
	 * @param idQuadras
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosRelatorioAnaliticoFaturamento(
			int anoMesFaturamento, Integer idFaturamentoGrupo,
			int indicadorLocalidadeInformatizada, Collection idLocalidades,
			Collection idSetores, Collection idQuadras)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		try {
			consulta = "select conta.imovel.id,"// 0
					+ " conta.consumoAgua,"// 1
					+ " conta.consumoRateioAgua,"// 2
					+ " conta.valorAgua,"// 3
					+ " conta.consumoEsgoto,"// 4
					+ " conta.consumoRateioEsgoto,"// 5
					+ " conta.valorEsgoto,"// 6
					+ " conta.debitos,"// 7
					+ " conta.valorCreditos,"// 8
					+ " conta.codigoSetorComercial,"// 9
					+ " localidade.id,"// 10
					+ " conta.digitoVerificadorConta,"// 11
					+ " conta.valorImposto, " // 12
					+ " localidade.descricao, " // 13
					+ " unidadeNegocio.id, " // 14
					+ " unidadeNegocio.nome, " // 15
					+ " clie.nome " // 16
					+ " from ClienteConta clieConta"
					+ " right join clieConta.conta conta "
					+ " left join clieConta.clienteRelacaoTipo crtp "
					+ " left join clieConta.cliente clie "
					+ " inner join conta.quadraConta quadra"
					+ " inner join quadra.rota rota"
					+ " inner join rota.faturamentoGrupo faturamentoGrupo"
					+ " inner join conta.localidade localidade"
					+ " inner join localidade.unidadeNegocio unidadeNegocio"
					+ " where conta.referencia =:anoMes"
					+ " and faturamentoGrupo.id = :idFaturamentoGrupo"
					+ " and localidade.indicadorLocalidadeInformatizada =:indicadorInformatizada"
					+ " and crtp.id = :usuario";

			if (idLocalidades != null && !idLocalidades.isEmpty()) {
				consulta = consulta + " and conta.localidade in (";
				Iterator iterator = idLocalidades.iterator();
				while (iterator.hasNext()) {
					Localidade localidade = (Localidade) iterator.next();
					consulta = consulta + localidade.getId().toString() + ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			if (idSetores != null && !idSetores.isEmpty()) {
				consulta = consulta
						+ " and conta.codigoSetorComercial in (:setores)";
				Iterator iterator = idSetores.iterator();
				while (iterator.hasNext()) {
					SetorComercial setorComercial = (SetorComercial) iterator
							.next();
					consulta = consulta + setorComercial.getId().toString()
							+ ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			if (idQuadras != null && !idQuadras.isEmpty()) {
				consulta = consulta + " and codigo.quadraConta in (:quadras)";
				Iterator iterator = idQuadras.iterator();
				while (iterator.hasNext()) {
					Quadra quadra = (Quadra) iterator.next();
					consulta = consulta + quadra.getId().toString() + ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			consulta = consulta
					+ " order by localidade.id, conta.codigoSetorComercial";

			retorno = session.createQuery(consulta).setInteger("anoMes",
					anoMesFaturamento).setInteger("idFaturamentoGrupo",
					idFaturamentoGrupo).setShort("indicadorInformatizada",
					new Short(indicadorLocalidadeInformatizada + "")).setShort(
					"usuario", ClienteRelacaoTipo.USUARIO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorno o id do imvel com FNTP_ID da tabela DEBITO_A_COBRAR com o valor
	 * correspondente a parcelamento de água (2), parcelamento de esgoto (3), ou
	 * parcelamento de serviço(4)
	 * 
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0012] - Verifica Pagamento de Debito a Cobrar de Parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @date 30/05/2007
	 * 
	 * @param idDebitoACobrar
	 * @return retorna o id do imovel do debito
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Integer pesquisarImovelDebitoACobrar(Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select imov.id " + "from DebitoACobrar dbac "
					+ "left join dbac.financiamentoTipo fntp "
					+ "left join dbac.imovel imov "
					+ "where dbac.id = :idDebitoACobrar "
					+ "and (fntp.id = :parcelamentoAgua "
					+ "or fntp.id = :parcelamentoEsgoto or "
					+ "fntp.id = :parcelamentoServico)";

			// executa o hql
			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idDebitoACobrar", idDebitoACobrar).setInteger(
					"parcelamentoAgua", FinanciamentoTipo.PARCELAMENTO_AGUA)
					.setInteger("parcelamentoEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
							"parcelamentoServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar
		return retorno;
	}

	/**
	 * atualiza DSCT_IDATUAL com o valor correspondente a cancelado (3), na
	 * tabela DEBITO_A_COBRAR com IMOV_ID do debito a cobrar que foi pago,
	 * DCST_IDATUAL com o valor correspondente a normal (0) e FNTP_ID com o
	 * valor correspondente a juros de parcelamento (8)
	 * 
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0012] - Verifica Pagamento de Debito a Cobrar de Parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @date 30/05/2007
	 * 
	 * @param idimovel
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void atualizarDebitoCreditoSituacaoAtualDoDebitoACobrar(
			Integer idImovel) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			update = "UPDATE gcom.faturamento.debito.DebitoACobrar SET "
					+ "dcst_idatual = :situacaoAtual "
					+ "WHERE imov_id = :idImovel and "
					+ "fntp_id = :financiamentoTipo and "
					+ "dcst_idatual = :debitoCreditoSituacaoNormal ";

			session.createQuery(update).setInteger("situacaoAtual",
					DebitoCreditoSituacao.CANCELADA).setInteger("idImovel",
					idImovel).setInteger("debitoCreditoSituacaoNormal",
					DebitoCreditoSituacao.NORMAL).setInteger(
					"financiamentoTipo", FinanciamentoTipo.JUROS_PARCELAMENTO)
					.executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Raphael Rossiter Data: 31/05/2007
	 * 
	 * Obtém os pagamentos da conta que contem a menor data de pagamento
	 * 
	 * @param Integer
	 *            conta, Integer idImovel, Integer anoMesReferenciaConta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] obterArrecadacaoFormaPagamentoContasMenorData(
			Integer conta, Integer idImovel, Integer anoMesReferenciaConta)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Object[] pesquisa1 = null;
		Object[] pesquisa2 = null;

		Date data1 = null;
		Date data2 = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT pgmt.arrecadacaoForma.id , MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.contaGeral contaGeral "
					+ "INNER JOIN contaGeral.conta cnta "
					+ "WHERE cnta.id = :idConta "
					+ "GROUP BY pgmt.arrecadacaoForma.id " + "ORDER BY 2 ";

			pesquisa1 = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", conta).setMaxResults(1).uniqueResult();

			consulta = "SELECT pgmt.arrecadacaoForma.id , MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.contaGeral contaGeral "
					+ "INNER JOIN contaGeral.conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "WHERE pgmt.imovel.id= :idImovel and pgmt.anoMesReferenciaPagamento = :anoMesReferenciaConta "
					+ "GROUP BY pgmt.arrecadacaoForma.id " + "ORDER BY 2 ";

			pesquisa2 = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setInteger("anoMesReferenciaConta",
					anoMesReferenciaConta).setMaxResults(1).uniqueResult();

			if (pesquisa1 != null) {
				data1 = (Date) pesquisa1[1];
			}

			if (pesquisa2 != null) {
				data2 = (Date) pesquisa2[1];
			}

			if (data2 == null) {
				retorno = pesquisa1;
			} else {
				if (data1 == null) {
					retorno = pesquisa2;
				} else {
					if (data1.before(data2)) {
						retorno = pesquisa1;
					} else {
						retorno = pesquisa2;
					}
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 31/05/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioEstadoPorUnidadeNegocio(
			int anoMesReferencia, String opcaoRelatorio)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(rf.valorItemFaturamento), "
					+ // 0
					"lt.descricao, "
					+ // 1
					"li.descricao, "
					+ // 2
					"lic.descricao, "
					+ // 3
					"lt.indicadorImpressao, "
					+ // 4
					"lt.indicadorTotal, "
					+ // 5
					"lt.id, "
					+ // 6
					"lt.lancamentoTipo.id, "
					+ // 7
					"rf.categoria.id, "
					+ // 8
					"rf.unidadeNegocio.nome, "
					+ // 9
					"rf.unidadeNegocio.id, "
					+ // 10
					"rf.sequenciaTipoLancamento, "
					+ // 11
					"rf.sequenciaItemTipoLancamento, "
					+ // 12
					"rf.gerenciaRegional.nome, "
					+ // 13
					"rf.gerenciaRegional.id "

					// + // 10
					// "rf.localidade.descricao, "
					// + // 11
					// "rf.localidade.id, "

					+ "from ResumoFaturamento rf "
					+ "left join rf.lancamentoTipo lt "
					+ "left join rf.lancamentoItem li "
					+ "left join rf.lancamentoItemContabil lic "
					+ "where rf.anoMesReferencia = :anoMesReferencia and "
					+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) ";
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				consulta += "and lt.indicadorResumido = "
						+ LancamentoTipo.INDICADOR_RESUMIDO_ATIVO;
			}
			consulta += " group by rf.unidadeNegocio.nome,rf.unidadeNegocio.id,"
					+ "lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, "
					+ "lt.lancamentoTipo.id, rf.categoria.id, rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, "
					+ "rf.gerenciaRegional.nome, rf.gerenciaRegional.id "
					+ "order by rf.gerenciaRegional.nome, rf.unidadeNegocio.nome, rf.sequenciaTipoLancamento, "
					+ "rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 31/05/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorUnidadeNegocio(
			int anoMesReferencia, Integer unidadeNegocio, String opcaoRelatorio)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(rf.valorItemFaturamento), "
					+ // 0
					"lt.descricao, "
					+ // 1
					"li.descricao, "
					+ // 2
					"lic.descricao, "
					+ // 3
					"lt.indicadorImpressao, "
					+ // 4
					"lt.indicadorTotal, "
					+ // 5
					"lt.id, "
					+ // 6
					"lt.lancamentoTipo.id, "
					+ // 7
					"rf.categoria.id, "
					+ // 8
					"rf.unidadeNegocio.nome, "
					+ // 9
					"rf.unidadeNegocio.id, "
					+ // 10
					"rf.sequenciaTipoLancamento, "
					+ // 11
					"rf.sequenciaItemTipoLancamento, "
					+ // 12
					" rf.gerenciaRegional.nome," // 13
					+ " rf.gerenciaRegional.id " // 14
					+ "from ResumoFaturamento rf "
					+ "left join rf.lancamentoTipo lt "
					+ "left join rf.lancamentoItem li "
					+ "left join rf.lancamentoItemContabil lic "
					+ "where rf.anoMesReferencia = :anoMesReferencia and "
					+ "rf.unidadeNegocio = :unidadeNegocio and "
					+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) ";
			if (opcaoRelatorio != null && opcaoRelatorio.equals("2")) {
				consulta += "and lt.indicadorResumido = "
						+ LancamentoTipo.INDICADOR_RESUMIDO_ATIVO;
			}
			consulta += " group by  lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, lt.lancamentoTipo.id, "
					+ "rf.categoria.id, rf.unidadeNegocio.nome, rf.unidadeNegocio.id, rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, rf.gerenciaRegional.nome, rf.gerenciaRegional.id  "
					+ "order by rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"unidadeNegocio", unidadeNegocio).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * [SB0014] Selecionar por Indicador de Consumo [SB0015] Selecionar por
	 * Indicador de Medido [SB0016] Selecionar por Indicador de Poço [SB0017]
	 * Selecionar por Indicador de Volume Fixo de Água
	 * 
	 * @author Rafael Pinto
	 * @date 01/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Collection<Object[]> pesquisarEmitirHistogramaAgua(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoSubcategoria = filtro.getColecaoSubcategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoAgua = filtro
				.getColecaoSituacaoLigacaoAgua();

		Categoria categoria = filtro.getCategoria();
		Subcategoria subcategoria = filtro.getSubcategoria();
		ConsumoTarifa tarifa = filtro.getTarifa();
		ImovelPerfil perfilImovel = filtro.getPerfilImovel();
		EsferaPoder esferaPoder = filtro.getEsferaPoder();
		LigacaoAguaSituacao situacaoLigacaoAgua = filtro
				.getSituacaoLigacaoAgua();

		Short consumo = filtro.getConsumo();
		Short medicao = filtro.getMedicao();
		Short poco = filtro.getPoco();
		Short volumoFixoAgua = filtro.getVolumoFixoAgua();

		ConsumoFaixaLigacao consumoFaixaLigacao = filtro
				.getConsumoFaixaLigacao();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro
				.getConsumoFaixaLigacaoIntervaloMedido();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro
				.getConsumoFaixaLigacaoIntervaloNaoMedido();

		String clausulaGroup = filtro.getTipoGroupBy();
		
		int indicadorTarifaCategoria = filtro.getIndicadorTarifaCategoria().intValue();

		Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
		Integer numeroQuadra = filtro.getNumeroQuadra();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT categoria.id," // 0
					+ "categoria.descricao," // 1
					+ "sum(histograma.quantidadeLigacao)," // 2
					+ "sum(histograma.quantidadeEconomiaLigacao)," // 3
					+ "sum(histograma.valorFaturadoLigacao) "; // 4
			
			String consultaFrom = "";
			
			if ( indicadorTarifaCategoria == 1 ){
				
				if (clausulaGroup != null) {
					consulta += "," + clausulaGroup;
				}
				
				consultaFrom = "FROM HistogramaAguaLigacao histograma "
					+ "INNER JOIN histograma.categoria categoria ";
			} else {
				
				consulta += ",subcategoria.id, subcategoria.descricao ";
				
				if (clausulaGroup != null) {
					consulta += "," + clausulaGroup;
				}
				
				//clausulaGroup += " ,subcategoria.id, subcategoria.descricao ";				
				
				consultaFrom = "FROM HistogramaAguaLigacaoSemQuadra histograma "
					+ "INNER JOIN histograma.subcategoria subcategoria "				
					+ "INNER JOIN histograma.categoria categoria ";
			}			

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if (consumoFaixaLigacao != null) {
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao
						.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao
						.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if (consumoFaixaLigacaoIntervaloMedido != null
					&& consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeEelo localidadeEelo ";

				consultaWhere += "AND localidadeEelo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if (codigoSetorComercial != null) {
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);
			}

			// Quadra
			if (quadra != null ) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if (numeroQuadra != null) {
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if (categoria != null) {
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			} else if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}
			
			// Subcategoria
			if (subcategoria != null) {
				consultaWhere += "AND subcategoria.id = (:scate) AND categoria.id = :catg_id ";
				parameters.put("scate", subcategoria.getId());
				parameters.put("catg_id", subcategoria.getCategoria().getId() );
			} else if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {
				consultaWhere += "AND subcategoria.id in (:scate) ";
				parameters.put("scate", colecaoSubcategoria);
			}			

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (perfilImovel != null) {
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			} else if (colecaoPerfilImovel != null
					&& !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (esferaPoder != null) {
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			} else if (colecaoEsferaPoder != null
					&& !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if (situacaoLigacaoAgua != null) {
				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id = (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", situacaoLigacaoAgua
						.getId());

			} else if (colecaoSituacaoLigacaoAgua != null
					&& !colecaoSituacaoLigacaoAgua.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua",
						colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoAgua != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			String groupBy = " GROUP BY  categoria.id,  categoria.descricao ";
			String orderBy = "";
			if (clausulaGroup != null) {
				groupBy += "," + clausulaGroup;
				orderBy = " ORDER BY " + clausulaGroup + ",categoria.id";
			} else {
				orderBy = " ORDER BY 1,2";
			}
			
			if ( indicadorTarifaCategoria == 2 ){
				orderBy += " ,subcategoria.id, subcategoria.descricao ";
				groupBy += " ,subcategoria.id, subcategoria.descricao ";
			}

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0600] Emitir Histograma de Água - Volume Faturado Ligacao Estimado ou
	 * Real
	 * 
	 * 
	 * @author Rafael Pinto
	 * @date 01/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Integer pesquisarEmitirHistogramaAguaVolumeConsumo(
			FiltrarEmitirHistogramaAguaHelper filtro, Short consumo,
			Categoria categoria, Short medicao) throws ErroRepositorioException {

		Integer retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();

		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();
		Subcategoria subcategoria = filtro.getSubcategoria();
		
		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoSubcategoria = filtro.getColecaoSubcategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoAgua = filtro
				.getColecaoSituacaoLigacaoAgua();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
		ConsumoTarifa tarifa = filtro.getTarifa();
		ImovelPerfil perfilImovel = filtro.getPerfilImovel();
		EsferaPoder esferaPoder = filtro.getEsferaPoder();
		LigacaoAguaSituacao situacaoLigacaoAgua = filtro
				.getSituacaoLigacaoAgua();

		Short poco = filtro.getPoco();
		Short volumoFixoAgua = filtro.getVolumoFixoAgua();

		ConsumoFaixaLigacao consumoFaixaLigacao = filtro
				.getConsumoFaixaLigacao();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro
				.getConsumoFaixaLigacaoIntervaloMedido();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro
				.getConsumoFaixaLigacaoIntervaloNaoMedido();

		Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
		Integer numeroQuadra = filtro.getNumeroQuadra();

		Session session = HibernateUtil.getSession();
		
		int indicadorTarifaCategoria = filtro.getIndicadorTarifaCategoria().intValue();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum( histograma.quantidadeConsumo * histograma.quantidadeEconomiaLigacao ) "; // 0
		
			String consultaFrom = "";
		
			if ( indicadorTarifaCategoria == 1 ){
				consultaFrom = "FROM HistogramaAguaLigacao histograma "
					+ "INNER JOIN histograma.categoria categoria ";
			} else {
				consultaFrom = "FROM HistogramaAguaLigacaoSemQuadra histograma "
					+ "INNER JOIN histograma.subcategoria subcategoria "				
					+ "INNER JOIN histograma.categoria categoria ";
			}

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if (consumoFaixaLigacao != null) {
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao
						.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao
						.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if (consumoFaixaLigacaoIntervaloMedido != null
					&& consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeEelo localidadeEelo ";

				consultaWhere += "AND localidadeEelo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if (codigoSetorComercial != null) {
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if (numeroQuadra != null) {
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if (categoria != null) {
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			} else if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}
			
			// Subcategoria
			if (subcategoria != null) {
				consultaWhere += "AND subcategoria.id = (:scate) AND categoria.id = :catg_id ";
				parameters.put("scate", subcategoria.getId());
				parameters.put("catg_id", subcategoria.getCategoria().getId() );
			} else if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {
				consultaWhere += "AND subcategoria.id in (:scate) ";
				parameters.put("scate", colecaoSubcategoria);
			}				

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (perfilImovel != null) {
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			} else if (colecaoPerfilImovel != null
					&& !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (esferaPoder != null) {
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			} else if (colecaoEsferaPoder != null
					&& !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if (situacaoLigacaoAgua != null) {
				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id = (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", situacaoLigacaoAgua
						.getId());
			} else if (colecaoSituacaoLigacaoAgua != null
					&& !colecaoSituacaoLigacaoAgua.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua",
						colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoAgua != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retornoConsulta = (Integer) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0600] Emitir Histograma de Água - Volume Faturado Ligacao Estimado ou
	 * Real
	 * 
	 * 
	 * @author Rafael Pinto
	 * @date 01/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Integer pesquisarEmitirHistogramaAguaVolumeConsumo(
			FiltrarEmitirHistogramaAguaHelper filtro, Short consumo,
			Subcategoria subcategoria, Short medicao) throws ErroRepositorioException {

		Integer retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();

		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();		
		
		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoSubcategoria = filtro.getColecaoSubcategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoAgua = filtro
				.getColecaoSituacaoLigacaoAgua();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
		ConsumoTarifa tarifa = filtro.getTarifa();
		ImovelPerfil perfilImovel = filtro.getPerfilImovel();
		EsferaPoder esferaPoder = filtro.getEsferaPoder();
		LigacaoAguaSituacao situacaoLigacaoAgua = filtro
				.getSituacaoLigacaoAgua();

		Short poco = filtro.getPoco();
		Short volumoFixoAgua = filtro.getVolumoFixoAgua();

		ConsumoFaixaLigacao consumoFaixaLigacao = filtro
				.getConsumoFaixaLigacao();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro
				.getConsumoFaixaLigacaoIntervaloMedido();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro
				.getConsumoFaixaLigacaoIntervaloNaoMedido();

		Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
		Integer numeroQuadra = filtro.getNumeroQuadra();

		Session session = HibernateUtil.getSession();
		
		int indicadorTarifaCategoria = filtro.getIndicadorTarifaCategoria().intValue();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum( histograma.quantidadeConsumo * histograma.quantidadeEconomiaLigacao ) "; // 0
		
			String consultaFrom = "";
		
			if ( indicadorTarifaCategoria == 1 ){
				consultaFrom = "FROM HistogramaAguaLigacao histograma "
					+ "INNER JOIN histograma.categoria categoria ";
			} else {
				consultaFrom = "FROM HistogramaAguaLigacaoSemQuadra histograma "
					+ "INNER JOIN histograma.subcategoria subcategoria "				
					+ "INNER JOIN histograma.categoria categoria ";
			}

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if (consumoFaixaLigacao != null) {
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao
						.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao
						.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if (consumoFaixaLigacaoIntervaloMedido != null
					&& consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeEelo localidadeEelo ";

				consultaWhere += "AND localidadeEelo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if (codigoSetorComercial != null) {
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if (numeroQuadra != null) {
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}
			
			// Subcategoria
			if (subcategoria != null) {
				consultaWhere += "AND subcategoria.id = (:scate) AND categoria.id = :catg_id ";
				parameters.put("scate", subcategoria.getId());
				parameters.put("catg_id", subcategoria.getCategoria().getId() );
			} else if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {
				consultaWhere += "AND subcategoria.id in (:scate) ";
				parameters.put("scate", colecaoSubcategoria);
			}				

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (perfilImovel != null) {
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			} else if (colecaoPerfilImovel != null
					&& !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (esferaPoder != null) {
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			} else if (colecaoEsferaPoder != null
					&& !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if (situacaoLigacaoAgua != null) {
				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id = (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", situacaoLigacaoAgua
						.getId());
			} else if (colecaoSituacaoLigacaoAgua != null
					&& !colecaoSituacaoLigacaoAgua.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua",
						colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoAgua != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retornoConsulta = (Integer) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}


	/**
	 * [UC0600] Emitir Histograma de Água - Total Geral
	 * 
	 * [SB0014] Selecionar por Indicador de Consumo [SB0015] Selecionar por
	 * Indicador de Medido [SB0016] Selecionar por Indicador de Poço [SB0017]
	 * Selecionar por Indicador de Volume Fixo de Água
	 * 
	 * @author Rafael Pinto
	 * @date 18/06/2007
	 * 
	* @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<Object[]>
	 * @throws ControladorException
	 */
	public Object[] pesquisarEmitirHistogramaAguaTotalGeral(
			FiltrarEmitirHistogramaAguaHelper filtro, Categoria categoria)
			throws ErroRepositorioException {

		Object[] retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();

		Subcategoria subcategoria = filtro.getSubcategoria();
		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoSubcategoria = filtro.getColecaoSubcategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoAgua = filtro
				.getColecaoSituacaoLigacaoAgua();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
		ConsumoTarifa tarifa = filtro.getTarifa();
		ImovelPerfil perfilImovel = filtro.getPerfilImovel();
		EsferaPoder esferaPoder = filtro.getEsferaPoder();
		LigacaoAguaSituacao situacaoLigacaoAgua = filtro
				.getSituacaoLigacaoAgua();
		
		Short consumo = filtro.getConsumo();
		Short medicao = filtro.getMedicao();
		Short poco = filtro.getPoco();
		Short volumoFixoAgua = filtro.getVolumoFixoAgua();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro
		.getConsumoFaixaLigacaoIntervaloMedido();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro
				.getConsumoFaixaLigacaoIntervaloNaoMedido();
		
		Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
		Integer numeroQuadra = filtro.getNumeroQuadra();
		
		int indicadorTarifaCategoria = filtro.getIndicadorTarifaCategoria().intValue();


		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum(histograma.quantidadeLigacao)," // 0
				+ "sum(histograma.volumeFaturadoLigacao)," // 1
				+ "sum(histograma.valorFaturadoLigacao) "; // 2
		
			String consultaFrom = "";


			if ( indicadorTarifaCategoria == 1 ){
				consultaFrom = "FROM HistogramaAguaLigacao histograma "
					+ "INNER JOIN histograma.categoria categoria ";
			} else {
				consultaFrom = "FROM HistogramaAguaLigacaoSemQuadra histograma "
					+ "INNER JOIN histograma.subcategoria subcategoria "				
					+ "INNER JOIN histograma.categoria categoria ";
			}	

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if (consumoFaixaLigacaoIntervaloMedido != null
					&& consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());
			}
			
			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeEelo localidadeEelo ";

				consultaWhere += "AND localidadeEelo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if (codigoSetorComercial != null) {
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if (numeroQuadra != null) {
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if (categoria != null) {
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			} else if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Subcategoria
			if (subcategoria != null) {
				consultaWhere += "AND subcategoria.id = (:scate) AND categoria.id = :catg_id ";
				parameters.put("scate", subcategoria.getId());
				parameters.put("catg_id", subcategoria.getCategoria().getId() );
			} else if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {
				consultaWhere += "AND subcategoria.id in (:scate) ";
				parameters.put("scate", colecaoSubcategoria);
			}
			
			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (perfilImovel != null) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			} else if (colecaoPerfilImovel != null
					&& !colecaoPerfilImovel.isEmpty()) {
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (esferaPoder != null) {
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			} else if (colecaoEsferaPoder != null
					&& !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if (situacaoLigacaoAgua != null) {
				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id = (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", situacaoLigacaoAgua
						.getId());

			} else if (colecaoSituacaoLigacaoAgua != null
					&& !colecaoSituacaoLigacaoAgua.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua",
						colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoAgua != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}
	
	/**
	 * [UC0605] Emitir Histograma de Água por Economia
	 * 
	 * @author Rafael Pinto
	 * @date 14/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaEconomiaHelper
	 * 
	 * @return Object[]
	 * @throws ControladorException
	 */
	public Object[] pesquisarEmitirHistogramaAguaEconomia(
			FiltrarEmitirHistogramaAguaEconomiaHelper filtro)
			throws ErroRepositorioException {

		Object[] retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();
		Integer tarifa = filtro.getTarifa();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoSubcategoria = filtro.getColecaoSubcategoria();
		
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoAgua = filtro
				.getColecaoSituacaoLigacaoAgua();

		Short consumo = filtro.getConsumo();
		Short medicao = filtro.getMedicao();
		Short poco = filtro.getPoco();
		Short volumoFixoAgua = filtro.getVolumoFixoAgua();
		
		int indicadorTarifaCategoria = filtro.getIndicadorTarifaCategoria().intValue();

		ConsumoFaixaCategoria consumoFaixaCategoria = filtro
				.getConsumoFaixaCategoria();
		Categoria categoria = filtro.getCategoria();
		Subcategoria subcategoria = filtro.getSubcategoria();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT categoria.id," // 0
					+ "categoria.descricao," // 1
					+ "sum(histograma.quantidadeEconomia)," // 2
					+ "sum(histograma.quantidadeConsumo * histograma.quantidadeEconomia)," // 3
					+ "sum(histograma.volumeFaturadoEconomia)," // 4
					+ "sum(histograma.valorFaturadoEconomia), " // 5
					+ "sum(histograma.quantidadeLigacao) ";// 6
			
			String consultaFrom = "";

			if ( indicadorTarifaCategoria == 1 ){
				consultaFrom = "FROM HistogramaAguaEconomia histograma "
					+ "INNER JOIN histograma.categoria categoria ";
			} else {				
				consulta += ",subcategoria.id, subcategoria.descricao ";
				
				consultaFrom = " FROM HistogramaAguaEconomiaSemQuadra histograma "
					+ "INNER JOIN histograma.subcategoria subcategoria "				
					+ "INNER JOIN histograma.categoria categoria ";
			}

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Categoria
			if (consumoFaixaCategoria != null) {
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaCategoria
						.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaCategoria
						.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Quadra
			if (quadra != null && indicadorTarifaCategoria == 1) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if ( indicadorTarifaCategoria == 1 ){
				if (categoria != null) {
					consultaWhere += "AND categoria.id = (:cate) ";
					parameters.put("cate", categoria.getId());
				} else if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
					consultaWhere += "AND categoria.id in (:cate) ";
					parameters.put("cate", colecaoCategoria);
				}
			}
			
			// Subcategoria  
			if (subcategoria != null) {  
				consultaWhere += "AND subcategoria.id = (:scate) AND categoria.id = :catg_id ";
				parameters.put("scate", subcategoria.getId());
				parameters.put("catg_id", subcategoria.getCategoria().getId() );
			} else if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {
				consultaWhere += "AND subcategoria.id in (:scate) ";
				parameters.put("scate", colecaoSubcategoria);
			}				


			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa);

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if (colecaoSituacaoLigacaoAgua != null
					&& !colecaoSituacaoLigacaoAgua.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua",
						colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoAgua != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}
			
			String groupBy = " GROUP BY  categoria.id,  categoria.descricao ";
			String orderBy = "ORDER BY 1,2";
			
			if ( indicadorTarifaCategoria == 2 ){			
				groupBy += ",8,9";
				orderBy += ",9 ";
			}			

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}
			retornoConsulta = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0605] Emitir Histograma de Água por Economia
	 * 
	 * Monta as quebras que serão necessarias para o relatorio
	 * 
	 * @author Rafael Pinto
	 * @date 18/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaEconomiaHelper
	 * 
	 * @return Collection<Object[]>
	 * @throws ControladorException
	 */
	public Collection<Object[]> pesquisarEmitirHistogramaAguaEconomiaChavesAgrupadas(
			FiltrarEmitirHistogramaAguaEconomiaHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();
		Integer tarifa = filtro.getTarifa();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoAgua = filtro
				.getColecaoSituacaoLigacaoAgua();

		Short consumo = filtro.getConsumo();
		Short medicao = filtro.getMedicao();
		Short poco = filtro.getPoco();
		Short volumoFixoAgua = filtro.getVolumoFixoAgua();

		String clausulaGroup = filtro.getTipoGroupBy();
		String clausulaOrder = filtro.getTipoOrderBy();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT " + clausulaGroup; // 0

			String consultaFrom = " FROM HistogramaAguaEconomia histograma "
					+ "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa);

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if (colecaoSituacaoLigacaoAgua != null
					&& !colecaoSituacaoLigacaoAgua.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua",
						colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoAgua != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			String groupBy = "GROUP BY " + clausulaGroup;
			String orderBy = " ORDER BY " + clausulaOrder;

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	// ///////////////////////////////////////////////////////////////////////////////////
	/**
	 * Recupera os dados da conta p emitir a 2ª via [UC0482]Emitir 2ª Via de
	 * Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/06/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaHistoricoERota(Integer idConta)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT "
					+ " new "
					+ EmitirContaHelper.class.getName()
					+ " ( "
					+ "cntHist.id, "
					+ "cli.nome, "
					+ "cntHist.dataVencimentoConta, "
					+ "cntHist.anoMesReferenciaConta, "
					+ "cntHist.verificadorConta, "
					+ "cntHist.setorComercial, "
					+ "cntHist.numeroQuadra, "
					+ "cntHist.lote, "
					+ "cntHist.subLote, "
					+ "cntHist.consumoAgua, "
					+ "cntHist.consumoEsgoto, "
					+ "cntHist.valorAgua, "
					+ "cntHist.valorEsgoto, "
					+ "cntHist.valorDebitos, "
					+ "cntHist.valorCreditos, "
					+ "cntHist.valorImposto, "
					+ "cntHist.dataValidadeConta, "
					+ "imovel.id, "
					+ "loc.id, "
					+ "gerenciaRegional.id, "
					+ "gerenciaRegional.nome, "
					+ "ligacaoAguaSituacao.id, "
					+ "ligacaoEsgotoSituacao.id, "
					+ "imovelPerfil.id, "
					+ "setorComercial.id, "
					+ "faturamentoGrupo.id, "
					+ "emp.id, "
					+ "loc.descricao, "
					+ "ligacaoAguaSituacao.descricao, "
					+ "ligacaoEsgotoSituacao.descricao, "
					+ "cntHist.percentualEsgoto, "
					+ "rota.codigo, "
					+ "imovel.numeroSequencialRota, "
					+ "hidrometro.numero, "
					+ "debitoCreditoSituacaoAtual.id, "
					+ "imovel.nomeImovel ) "
					+ "from ClienteContaHistorico cliCntHist "
					+ "RIGHT JOIN cliCntHist.contaHistorico cntHist "
					+ "LEFT JOIN cliCntHist.clienteRelacaoTipo crt "
					+ "LEFT JOIN cliCntHist.cliente cli "
					+ "LEFT JOIN cntHist.contaMotivoRevisao cmr "
					+ "LEFT JOIN cntHist.quadra quadraConta "
					+ "LEFT JOIN cntHist.localidade loc "
					+ "LEFT JOIN loc.gerenciaRegional gerenciaRegional "
					+ "LEFT JOIN cntHist.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "LEFT JOIN cntHist.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "LEFT JOIN cntHist.imovelPerfil imovelPerfil "
					+ "LEFT JOIN quadraConta.rota rota "
					+ "LEFT JOIN rota.empresa emp "
					+ "LEFT JOIN quadraConta.setorComercial setorComercial "
					+ "LEFT JOIN rota.faturamentoGrupo faturamentoGrupo "
					+ "LEFT JOIN cntHist.imovel imovel "
					+ "LEFT JOIN imovel.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN hih.hidrometro hidrometro "
					+ "LEFT JOIN cntHist.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "WHERE  cntHist.id = :idConta  and cliCntHist.indicadorNomeConta = 1 "
					+ "ORDER BY cntHist.anoMesReferenciaConta,emp.id,loc.id,cntHist.setorComercial,"
					+ "cntHist.numeroQuadra,cntHist.lote,cntHist.subLote";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/06/2007
	 * 
	 * @param idConta
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaHistoricoFaixas(Integer idConta,
			Integer idCategoria, Integer idSubCategoria)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select contaCategoriaConsumoFaixaHistorico "
					+ "from ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistorico "
					+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.contaHistorico contaHist "
					+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.categoria categoria "
					+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.subcategoria subCategoria "
					+ "where contaHist.id = :idConta AND "
					+ "categoria.id = :idCategoria AND "
					+ "subCategoria.id = :idSubCategoria "
					+ "order by contaCategoriaConsumoFaixaHistorico.consumoFaixaInicio";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta).setInteger("idCategoria", idCategoria).setInteger(
					"idSubCategoria", idSubCategoria).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/06/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualContaHistorico(
			Integer idConta) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dcst.id " + "from ContaHistorico cnta "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "where cnta.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idConta", idConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/06/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaHistoricoCategoriaSubCategoria(
			Integer idConta) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select contaCategoriaHist.comp_id.categoria "
					+ "from ContaCategoriaHistorico contaCategoriaHist "
					+ "inner join contaCategoriaHist.comp_id.contaHistorico contaHist "
					+ "inner join fetch contaCategoriaHist.comp_id.categoria categoria "
					+ "inner join fetch contaCategoriaHist.comp_id.subcategoria subCategoria "
					+ "where contaHist.id = :idConta ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).setInteger("idConta", idConta)
					.list()));

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta
	 * 
	 * Author: Raphael Rossiter Data: 03/07/2007
	 * 
	 * @param idContaRetificada
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoAutomaticoMovimentoContaRetificada(
			Integer idContaRetificada) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT damv.id "
					+ "FROM DebitoAutomaticoMovimento damv "
					+ "INNER JOIN damv.contaGeral cntaGeral "
					+ "INNER JOIN cntaGeral.conta cnta "
					+ "WHERE cnta.id = :idConta AND damv.numeroSequenciaArquivoEnviado IS NULL ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idContaRetificada).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta
	 * 
	 * Author: Raphael Rossiter Data: 03/07/2007
	 * 
	 * @param colecaoDebitoAutomaticoMovimento
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public void atualizarDebitoAutomaticoMovimentoContaRetificada(
			Collection colecaoDebitoAutomaticoMovimento, Integer idConta)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			update = "UPDATE gcom.arrecadacao.debitoautomatico.DebitoAutomaticoMovimento SET "
					+ "cnta_id = :idConta, damv_tmultimaalteracao = :dataAtual "
					+ "WHERE damv_id IN (:idsDebitoAutomaticoMovimento) ";

			session.createQuery(update).setInteger("idConta", idConta)
					.setTimestamp("dataAtual", new Date()).setParameterList(
							"idsDebitoAutomaticoMovimento",
							colecaoDebitoAutomaticoMovimento).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * Metodo que retorna a data de revisão da conta
	 * 
	 * @author Vivianne Sousa
	 * @date 06/07/2007
	 * 
	 * @param idsConta
	 * @return
	 */
	public Collection pesquisarDataRevisaoConta(Collection idsConta)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select conta.id, conta.dataRevisao, conta.parcelamento.id, conta.contaMotivoRevisao.id  " // 8
					+ "from Conta conta "
					+ "where conta.id IN (:ids) and "
					+ "conta.dataRevisao is not null ";
			
			if(idsConta.size()>999){
				
				System.out.println("## TAMANHO TOTAL = " + idsConta.size());
				
				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsConta, 999);
				
				int qtdQuebras = 999;
				int indice = idsConta.size() / qtdQuebras;                                   
				if (idsConta.size() % qtdQuebras !=0){
					indice ++;
				}
				
				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);
				
				for (int i = 0; i < indice; i++) {

						System.out.println("## TAMANHO PARTIÇÃO DE INDICE  " + indice +" = " + particoes.get(i).size());
						
						Collection retornoPart = null;
						
						retornoPart = session.createQuery(consulta).setParameterList("ids",
								particoes.get(i)).list();
						
						retorno.addAll(retornoPart);
				}					
			}else{
				retorno = session.createQuery(consulta).setParameterList("ids",
						idsConta).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * atualiza DSCT_IDATUAL com o valor correspondente a cancelado (3), na
	 * tabela CREDITO_A_REALIZAR com IMOV_ID do debito a cobrar que foi pago,
	 * DCST_IDATUAL com o valor correspondente a normal (0) e CROG_ID com o
	 * valor correspondente a descontos concedidos no parcelamento (6)
	 * 
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0012] - Verifica Pagamento de Debito a Cobrar de Parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @date 18/07/2007
	 * 
	 * @param idimovel
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void atualizarDebitoCreditoSituacaoAtualDoCreditoARealizar(
			Integer idImovel) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			update = "UPDATE gcom.faturamento.credito.CreditoARealizar SET "
					+ "dcst_idatual = :situacaoAtual "
					+ "WHERE imov_id = :idImovel and "
					+ "crog_id = :creditoOrigem and "
					+ "dcst_idatual = :debitoCreditoSituacaoNormal ";

			session.createQuery(update).setInteger("situacaoAtual",
					DebitoCreditoSituacao.CANCELADA).setInteger("idImovel",
					idImovel).setInteger("debitoCreditoSituacaoNormal",
					DebitoCreditoSituacao.NORMAL).setInteger("creditoOrigem",
					CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO)
					.executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterIdsContasImovel(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cnta.id "
					+ "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE imov.id = :idImovel AND "
					+ "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada)";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					idImovel)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int obterPagamentosContas(Collection idsContas)
			throws ErroRepositorioException {

		int retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT count(distinct conta.id) "
					+ "FROM Pagamento pagamento "
					+ "INNER JOIN pagamento.contaGeral conta "
					+ "WHERE conta.id in (:idsContas)";

			retorno = (Integer) session.createQuery(consulta).setParameterList(
					"idsContas", idsContas).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0485] Gerar Resumo dos Devedores Duvidosos
	 * 
	 * verifica se a conta informada possui cliente responsável com esfera de
	 * poder de tipo de cliente igual a municipal, estadual ou federal.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/07/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean verificarExistenciaClienteResponsavelConta(int idConta)
			throws ErroRepositorioException {

		boolean retorno = false;

		Collection retornoPesquisa = null;
		Collection<Short> colecaoIdsEsferasPoder = new ArrayList();
		colecaoIdsEsferasPoder.add(EsferaPoder.MUNICIPAL);
		colecaoIdsEsferasPoder.add(EsferaPoder.ESTADUAL);
		colecaoIdsEsferasPoder.add(EsferaPoder.FEDERAL);

		StatelessSession session = HibernateUtil.getStatelessSession();
		String consulta;

		try {
			consulta = "select clct.id " + "from ClienteConta clct "
					+ "inner join clct.conta cnta "
					+ "inner join clct.cliente clie "
					+ "inner join clct.clienteRelacaoTipo crtp "
					+ "inner join clie.clienteTipo cltp "
					+ "inner join cltp.esferaPoder epod "
					+ "where cnta.id = :idConta and crtp.id = :idRelacaoTipo "
					+ "and epod.id in (:idsEsferasPoder) ";

			retornoPesquisa = session.createQuery(consulta).setInteger(
					"idConta", idConta).setInteger("idRelacaoTipo",
					ClienteRelacaoTipo.RESPONSAVEL).setParameterList(
					"idsEsferasPoder", colecaoIdsEsferasPoder).list();

			if (retornoPesquisa != null && !retornoPesquisa.isEmpty()) {
				retorno = true;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoMetas(Integer anoMesReferencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSessionGerencial();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select unResumoMetas.id "
					+ "from UnResumoMeta unResumoMetas "
					+ "where unResumoMetas.anoMesReferencia = :anoMesReferencia ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoMetasAcumulado(Integer anoMesReferencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSessionGerencial();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select unResumoMetasAcumulado.id "
					+ "from UnResumoMetasAcumulado unResumoMetasAcumulado "
					+ "where unResumoMetasAcumulado.anoMesReferencia = :anoMesReferencia ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter, Mariana Victor
	 * @date 20/08/2007, 14/07/2011
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasGrupoFaturamento(Integer anoMes,
			Integer idGrupoFaturamento, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim, Integer somenteDebitoAutomatico)
			throws ErroRepositorioException {

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;
		boolean indicadorBloqueioContasContratoParcelManterConta = false;
		
		try {
			RepositorioUtilHBM repositorioUtilHBM = RepositorioUtilHBM.getInstancia();
			SistemaParametro sistemaParametro = 
				repositorioUtilHBM.pesquisarParametrosDoSistema();

			/**
			 * [UC0407] Filtrar Imóveis para Inserir ou Manter Conta
			 * 3. Caso o indicador de bloqueio de contas vinculadas a contrato de parcelamento no manter contas esteja ativo
			 *   retirar da lista de contas selecionadas as contas vinculadas a algum contrato de parcelamento ativo
			 *    
			 * RM 1887 - Contrato Parcelamento por Cliente
			 * Adicionado por: Mariana Victor
			 * Data: 14/07/2011
			 *  
			 * */
			if (sistemaParametro.getIndicadorBloqueioContasContratoParcelManterConta() != null
					&& sistemaParametro.getIndicadorBloqueioContasContratoParcelManterConta().equals(ConstantesSistema.SIM)) {
				indicadorBloqueioContasContratoParcelManterConta = true;
			}
			
			consulta = "SELECT COUNT(cnta.id) " + "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN imov.quadra quadra "
					+ "INNER JOIN quadra.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo ftgr "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst ";
			
			if (indicadorBloqueioContasContratoParcelManterConta) {
				consulta += "LEFT JOIN cnta.contaMotivoRevisao cmrv "
					+ "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "AND ftgr.id = :idGrupoFaturamento "
					+ "AND dcst.id IN(:normal, :incluida, :retificada) "
					+ "AND (cmrv.id IS NULL OR cmrv.id <> :codigoContratoParcelamento )";
			} else {
				consulta += "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "AND ftgr.id = :idGrupoFaturamento "
					+ "AND dcst.id IN(:normal, :incluida, :retificada) ";
			}
			
			if (somenteDebitoAutomatico != null && somenteDebitoAutomatico == 1) {
				consulta += " and cnta.indicadorDebitoConta = 1 ";
			}
			
			if (dataVencimentoContaInicio != null) {

				consulta += " AND cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if (dataVencimentoContaFim != null) {
					Query query = session.createQuery(consulta)
						.setInteger("anoMes", anoMes).setInteger(
								"anoMesFim", anoMesFim).setInteger(
								"idGrupoFaturamento",
								idGrupoFaturamento).setInteger(
								"normal",
								DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida",
								DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA)
						.setDate("dataVencimentoContaInicio",
								dataVencimentoContaInicio).setDate(
								"dataVencimentoContaFim",
								dataVencimentoContaFim);

					if (indicadorBloqueioContasContratoParcelManterConta) {
						query.setInteger("codigoContratoParcelamento", 
								ContaMotivoRevisao.CONTA_EM_CONTRATO_PARCELAMENTO);
					}
					
					retorno = retorno
							+ (Integer) query.uniqueResult();
					
				} else {
					Query query = session.createQuery(consulta)
						.setInteger("anoMes", anoMes).setInteger(
								"anoMesFim", anoMesFim).setInteger(
								"idGrupoFaturamento",
								idGrupoFaturamento).setInteger(
								"normal",
								DebitoCreditoSituacao.NORMAL)
						.setInteger("incluida",
								DebitoCreditoSituacao.INCLUIDA)
						.setInteger("retificada",
								DebitoCreditoSituacao.RETIFICADA)
						.setDate("dataVencimentoContaInicio",
								dataVencimentoContaInicio).setDate(
								"dataVencimentoContaFim",
								dataVencimentoContaInicio);
					
					if (indicadorBloqueioContasContratoParcelManterConta) {
						query.setInteger("codigoContratoParcelamento", 
								ContaMotivoRevisao.CONTA_EM_CONTRATO_PARCELAMENTO);
					}
					
					retorno = retorno
							+ (Integer) query.uniqueResult();

				}
			} else {
				Query query = session.createQuery(consulta).setInteger(
								"anoMes", anoMes).setInteger("anoMesFim",
								anoMesFim).setInteger("idGrupoFaturamento",
								idGrupoFaturamento).setInteger("normal",
								DebitoCreditoSituacao.NORMAL).setInteger(
								"incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA);
				
				if (indicadorBloqueioContasContratoParcelManterConta) {
					query.setInteger("codigoContratoParcelamento", 
							ContaMotivoRevisao.CONTA_EM_CONTRATO_PARCELAMENTO);
				}
				
				retorno = retorno
						+ (Integer) query.uniqueResult();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas em revisão de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 20/08/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasRevisaoGrupoFaturamento(
			Integer anoMes, Integer idGrupoFaturamento,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim) throws ErroRepositorioException {

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT COUNT(cnta.id) " + "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN imov.quadra quadra "
					+ "INNER JOIN quadra.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo ftgr "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "AND ftgr.id = :idGrupoFaturamento "
					+ "AND dcst.id IN(:normal, :incluida, :retificada) "
					+ "AND cnta.dataRevisao is null ";

			if (dataVencimentoContaInicio != null) {

				consulta += " AND cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if (dataVencimentoContaFim != null) {

					retorno = retorno
							+ (Integer) session.createQuery(consulta)
									.setInteger("anoMes", anoMes).setInteger(
											"anoMesFim", anoMesFim).setInteger(
											"idGrupoFaturamento",
											idGrupoFaturamento).setInteger(
											"normal",
											DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida",
											DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada",
											DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio",
											dataVencimentoContaInicio).setDate(
											"dataVencimentoContaFim",
											dataVencimentoContaFim)
									.uniqueResult();
				} else {

					retorno = retorno
							+ (Integer) session.createQuery(consulta)
									.setInteger("anoMes", anoMes).setInteger(
											"anoMesFim", anoMesFim).setInteger(
											"idGrupoFaturamento",
											idGrupoFaturamento).setInteger(
											"normal",
											DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida",
											DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada",
											DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio",
											dataVencimentoContaInicio).setDate(
											"dataVencimentoContaFim",
											dataVencimentoContaInicio)
									.uniqueResult();

				}
			} else {

				retorno = retorno
						+ (Integer) session.createQuery(consulta).setInteger(
								"anoMes", anoMes).setInteger("anoMesFim",
								anoMesFim).setInteger("idGrupoFaturamento",
								idGrupoFaturamento).setInteger("normal",
								DebitoCreditoSituacao.NORMAL).setInteger(
								"incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada",
										DebitoCreditoSituacao.RETIFICADA)
								.uniqueResult();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 20/08/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasGrupoFaturamento(Integer anoMes,
			Integer idGrupoFaturamento, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		

		try {
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, cnta.valorEsgoto, "
					+ "cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
					+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, cnta.referenciaContabil, "
					+ "cnta.ultimaAlteracao, imov, dcsan "
					+ "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN imov.quadra quadra "
					+ "INNER JOIN quadra.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo ftgr "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "LEFT JOIN cnta.debitoCreditoSituacaoAnterior dcsan "
					+ "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "AND ftgr.id = :idGrupoFaturamento "
					+ "AND cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada)";

			if (dataVencimentoContaInicio != null) {

				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if (dataVencimentoContaFim != null) {

					retorno = session.createQuery(consulta).setInteger(
							"anoMes", anoMes)
							.setInteger("anoMesFim", anoMesFim).setInteger(
									"idGrupoFaturamento", idGrupoFaturamento)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida",
									DebitoCreditoSituacao.INCLUIDA).setInteger(
									"retificada",
									DebitoCreditoSituacao.RETIFICADA).setDate(
									"dataVencimentoContaInicio",
									dataVencimentoContaInicio).setDate(
									"dataVencimentoContaFim",
									dataVencimentoContaFim).list();
				} else {

					retorno = session.createQuery(consulta).setInteger(
							"anoMes", anoMes)
							.setInteger("anoMesFim", anoMesFim).setInteger(
									"idGrupoFaturamento", idGrupoFaturamento)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida",
									DebitoCreditoSituacao.INCLUIDA).setInteger(
									"retificada",
									DebitoCreditoSituacao.RETIFICADA).setDate(
									"dataVencimentoContaInicio",
									dataVencimentoContaInicio).setDate(
									"dataVencimentoContaFim",
									dataVencimentoContaInicio).list();
				}
			} else {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim).setInteger(
						"idGrupoFaturamento", idGrupoFaturamento).setInteger(
						"normal", DebitoCreditoSituacao.NORMAL).setInteger(
						"incluida", DebitoCreditoSituacao.INCLUIDA).setInteger(
						"retificada", DebitoCreditoSituacao.RETIFICADA).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasGrupoFaturamento(Integer anoMes,
			Integer idGrupoFaturamento, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try { // 0 ,1
			consulta = "SELECT cnta, imov "
					+ "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN imov.quadra quadra "
					+ "INNER JOIN quadra.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo ftgr "
					+ "INNER JOIN FETCH cnta.consumoTarifa cstf "
					+ "INNER JOIN FETCH cnta.quadraConta quad "
					+ "INNER JOIN FETCH quad.setorComercial strc "
					+ "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "AND ftgr.id = :idGrupoFaturamento "
					+ "AND cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if (dataVencimentoContaInicio != null) {
				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if (dataVencimentoContaFim != null) {

					retorno = session.createQuery(consulta).setInteger(
							"anoMes", anoMes)
							.setInteger("anoMesFim", anoMesFim).setInteger(
									"idGrupoFaturamento", idGrupoFaturamento)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida",
									DebitoCreditoSituacao.INCLUIDA).setInteger(
									"retificada",
									DebitoCreditoSituacao.RETIFICADA).setDate(
									"dataVencimentoContaInicio",
									dataVencimentoContaInicio).setDate(
									"dataVencimentoContaFim",
									dataVencimentoContaFim).list();

				} else {

					retorno = session.createQuery(consulta).setInteger(
							"anoMes", anoMes)
							.setInteger("anoMesFim", anoMesFim).setInteger(
									"idGrupoFaturamento", idGrupoFaturamento)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida",
									DebitoCreditoSituacao.INCLUIDA).setInteger(
									"retificada",
									DebitoCreditoSituacao.RETIFICADA).setDate(
									"dataVencimentoContaInicio",
									dataVencimentoContaInicio).setDate(
									"dataVencimentoContaFim",
									dataVencimentoContaInicio).list();

				}
			} else {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim).setInteger(
						"idGrupoFaturamento", idGrupoFaturamento).setInteger(
						"normal", DebitoCreditoSituacao.NORMAL).setInteger(
						"incluida", DebitoCreditoSituacao.INCLUIDA).setInteger(
						"retificada", DebitoCreditoSituacao.RETIFICADA).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os ids das contas de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdContasGrupoFaturamento(Integer anoMes,
			Integer idGrupoFaturamento, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cnta.id "
					+ "FROM Conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN imov.quadra quadra "
					+ "INNER JOIN quadra.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo ftgr "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim "
					+ "AND ftgr.id = :idGrupoFaturamento "
					+ "AND cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if (dataVencimentoContaInicio != null) {
				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if (dataVencimentoContaFim != null) {

					retorno = session.createQuery(consulta).setInteger(
							"anoMes", anoMes)
							.setInteger("anoMesFim", anoMesFim).setInteger(
									"idGrupoFaturamento", idGrupoFaturamento)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida",
									DebitoCreditoSituacao.INCLUIDA).setInteger(
									"retificada",
									DebitoCreditoSituacao.RETIFICADA).setDate(
									"dataVencimentoContaInicio",
									dataVencimentoContaInicio).setDate(
									"dataVencimentoContaFim",
									dataVencimentoContaFim).list();

				} else {

					retorno = session.createQuery(consulta).setInteger(
							"anoMes", anoMes)
							.setInteger("anoMesFim", anoMesFim).setInteger(
									"idGrupoFaturamento", idGrupoFaturamento)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida",
									DebitoCreditoSituacao.INCLUIDA).setInteger(
									"retificada",
									DebitoCreditoSituacao.RETIFICADA).setDate(
									"dataVencimentoContaInicio",
									dataVencimentoContaInicio).setDate(
									"dataVencimentoContaFim",
									dataVencimentoContaInicio).list();

				}
			} else {

				retorno = session.createQuery(consulta).setInteger("anoMes",
						anoMes).setInteger("anoMesFim", anoMesFim).setInteger(
						"idGrupoFaturamento", idGrupoFaturamento).setInteger(
						"normal", DebitoCreditoSituacao.NORMAL).setInteger(
						"incluida", DebitoCreditoSituacao.INCLUIDA).setInteger(
						"retificada", DebitoCreditoSituacao.RETIFICADA).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0151] Alterar Vencimento Conta Author: Raphael Rossiter Data:
	 * 
	 * @autor Raphael Rossiter
	 * @data 22/08/2007
	 * 
	 * @throws ErroRepositorioException
	 */
	public void alterarVencimentoContaGrupoFaturamento(Date dataVencimento,
			Date dataValidade, Short indicadorAlteracaoVencimento,
			Integer idGrupoFaturamento, Integer anoMes, Integer anoMesFim,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			boolean somenteDebitoAutomatico) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			RepositorioUtilHBM repositorioUtilHBM = RepositorioUtilHBM.getInstancia();
			SistemaParametro sistemaParametro = repositorioUtilHBM.pesquisarParametrosDoSistema();

			/**
			 * [UC0407] Filtrar Imóveis para Inserir ou Manter Conta
			 * 
			 * 3. Caso o indicador de bloqueio de contas vinculadas a 
			 * contrato de parcelamento no manter contas esteja ativo
			 * retirar da lista de contas selecionadas as contas vinculadas
			 * a algum contrato de parcelamento ativo
			 * */
			boolean indicadorBloqueioContasContratoParcelManterConta = false;
			if (sistemaParametro.getIndicadorBloqueioContasContratoParcelManterConta() != null
					&& sistemaParametro.getIndicadorBloqueioContasContratoParcelManterConta().equals(ConstantesSistema.SIM)) {
				indicadorBloqueioContasContratoParcelManterConta = true;
			}
			
			Connection jdbcCon = session.connection();

			update = "UPDATE faturamento.conta SET "
					+ "cnta_dtvencimentoconta = ?, cnta_dtvalidadeconta = ?, "//1, 2
					+ "cnta_icalteracaovencimento = ?, cnta_tmultimaalteracao = ? "//3, 4
					+ "WHERE cnta_id IN( "
					+ "SELECT cnta.cnta_id "
					+ "FROM faturamento.conta cnta "
					+ "INNER JOIN cadastro.imovel imov on cnta.imov_id = imov.imov_id "
					+ "INNER JOIN cadastro.quadra qdra on imov.qdra_id = qdra.qdra_id "
					+ "INNER JOIN micromedicao.rota rota on qdra.rota_id = rota.rota_id "
					+ "INNER JOIN faturamento.faturamento_grupo ftgr on rota.ftgr_id = ftgr.ftgr_id "
					+ "INNER JOIN faturamento.debito_credito_situacao dcst on cnta.dcst_idatual = dcst.dcst_id "
					+ "WHERE cnta.cnta_amreferenciaconta BETWEEN ? AND ? "//5, 6
					+ "AND ftgr.ftgr_id = ? " + "AND dcst.dcst_id IN(?, ?, ?) "//7, 8, 9, 10
					+ "AND cnta_dtvencimentoconta < ? ";//11

			if (dataVencimentoContaInicio != null) {
				update += " AND cnta.cnta_dtvencimentoconta BETWEEN ? AND ? ";//12, 13

				if (indicadorBloqueioContasContratoParcelManterConta) 
					update += " AND (cnta.cmrv_id is null or cnta.cmrv_id <> ? ) ";//14
				
				if (somenteDebitoAutomatico)
					update += " AND cnta.cnta_icdebitoconta = ? "; // 15

				update += ")";
				
				if (dataVencimentoContaFim != null) {

					st = jdbcCon.prepareStatement(update);

					st.setDate(1, Util.getSQLDate(dataVencimento));
					st.setDate(2, Util.getSQLDate(dataValidade));
					st.setShort(3, indicadorAlteracaoVencimento.shortValue());
					st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
					st.setInt(5, anoMes.intValue());
					st.setInt(6, anoMesFim.intValue());
					st.setInt(7, idGrupoFaturamento.intValue());
					st.setInt(8, DebitoCreditoSituacao.NORMAL.intValue());
					st.setInt(9, DebitoCreditoSituacao.INCLUIDA.intValue());
					st.setInt(10, DebitoCreditoSituacao.RETIFICADA.intValue());
					st.setDate(11, Util.getSQLDate(dataVencimento));
					st.setDate(12, Util.getSQLDate(dataVencimentoContaInicio));
					st.setDate(13, Util.getSQLDate(dataVencimentoContaFim));
					
					if (indicadorBloqueioContasContratoParcelManterConta) 
						st.setInt(14, ContaMotivoRevisao.CONTA_EM_CONTRATO_PARCELAMENTO.intValue());
					
					if (somenteDebitoAutomatico)
						st.setShort(15, ConstantesSistema.SIM);
				
				} else {

					st = jdbcCon.prepareStatement(update);

					st.setDate(1, Util.getSQLDate(dataVencimento));
					st.setDate(2, Util.getSQLDate(dataValidade));
					st.setShort(3, indicadorAlteracaoVencimento.shortValue());
					st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
					st.setInt(5, anoMes.intValue());
					st.setInt(6, anoMesFim.intValue());
					st.setInt(7, idGrupoFaturamento.intValue());
					st.setInt(8, DebitoCreditoSituacao.NORMAL.intValue());
					st.setInt(9, DebitoCreditoSituacao.INCLUIDA.intValue());
					st.setInt(10, DebitoCreditoSituacao.RETIFICADA.intValue());
					st.setDate(11, Util.getSQLDate(dataVencimento));
					st.setDate(12, Util.getSQLDate(dataVencimentoContaInicio));
					st.setDate(13, Util.getSQLDate(dataVencimentoContaInicio));
					
					if (indicadorBloqueioContasContratoParcelManterConta) {
						st.setInt(14, ContaMotivoRevisao.CONTA_EM_CONTRATO_PARCELAMENTO.intValue());
					}
					
					if (somenteDebitoAutomatico)
						st.setShort(15, ConstantesSistema.SIM);
					
					st.executeUpdate();

				}
			} else {

				if (indicadorBloqueioContasContratoParcelManterConta) 
					update += " AND (cnta.cmrv_id is null or cnta.cmrv_id <> ? ) "; // 12
				
				if (somenteDebitoAutomatico)
					update += " AND cnta.cnta_icdebitoconta = ? "; // 13
				
				update += ")";

				st = jdbcCon.prepareStatement(update);

				st.setDate(1, Util.getSQLDate(dataVencimento));
				st.setDate(2, Util.getSQLDate(dataValidade));
				st.setShort(3, indicadorAlteracaoVencimento.shortValue());
				st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
				st.setInt(5, anoMes.intValue());
				st.setInt(6, anoMesFim.intValue());
				st.setInt(7, idGrupoFaturamento.intValue());
				st.setInt(8, DebitoCreditoSituacao.NORMAL.intValue());
				st.setInt(9, DebitoCreditoSituacao.INCLUIDA.intValue());
				st.setInt(10, DebitoCreditoSituacao.RETIFICADA.intValue());
				st.setDate(11, Util.getSQLDate(dataVencimento));

				if (indicadorBloqueioContasContratoParcelManterConta)
					st.setInt(12, ContaMotivoRevisao.CONTA_EM_CONTRATO_PARCELAMENTO.intValue());
				
				if (somenteDebitoAutomatico)
					st.setShort(13, ConstantesSistema.SIM);
				
				st.executeUpdate();

			}
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Metodo temporario para correção da base de dados
	 * 
	 * Gerar Crédito a Realizar para os imóveis com contas com vencimento em
	 * 14/08/2007 com multa da conta 06/2007 cobrada na conta 07/2007 e que
	 * pagaram em 17/07/2007
	 * 
	 * @author Pedro Alexandre
	 * @date 20/08/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosImoveisParaGerarCreditoARealizarPorImoveisComContasComVencimento14_08_2007()
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imov.imov_id as imovid, "
					+ "dbcb.dbcb_vlprestacao as prestacao, "
					+ "loca.loca_id as locaid, "
					+ "qdra.qdra_id as qdraid,  "
					+ "stcm.stcm_cdsetorcomercial as codsetor,  "
					+ "qdra.qdra_nnquadra as numeroqdra,  "
					+ "imov.imov_nnlote as numerolote,  "
					+ "imov.imov_nnsublote as numerosublote, "
					+ "dbcb.dbcb_amreferenciadebito as anomesreferenciadebito "
					+ "from faturamento.conta cnta "
					+ "left join faturamento.debito_cobrado dbcb on cnta.cnta_id=dbcb.cnta_id "
					+ "inner join cadastro.imovel imov on cnta.imov_id=imov.imov_id "
					+ "inner join cadastro.localidade loca on imov.loca_id = loca.loca_id "
					+ "inner join cadastro.setor_comercial stcm on imov.stcm_id=stcm.stcm_id "
					+ "inner join cadastro.quadra qdra on imov.qdra_id=qdra.qdra_id  "
					+ "where cnta.cnta_amreferenciaconta = 200707 "
					+ "and cnta.cnta_id = dbcb.cnta_id "
					+ "and cnta.cnta_dtvencimentoconta = '2007-08-14' "
					+ "and dbcb.dbtp_id=80 "
					+ "and dbcb.dbcb_amreferenciadebito=200706 "
					+ "and cnta.dcst_idatual = 0 "
					+ "and exists (select pghi_id "
					+ "from arrecadacao.pagamento_historico pghi "
					+ "where pghi.imov_id = cnta.imov_id "
					+ "and pghi.pghi_amreferenciapagamento=200706 "
					+ "and pghi_dtpagamento < '2007-07-18') ";

			retorno = session.createSQLQuery(consulta).addScalar("imovid",
					Hibernate.INTEGER).addScalar("prestacao",
					Hibernate.BIG_DECIMAL).addScalar("locaid",
					Hibernate.INTEGER).addScalar("qdraid", Hibernate.INTEGER)
					.addScalar("codsetor", Hibernate.INTEGER).addScalar(
							"numeroqdra", Hibernate.INTEGER).addScalar(
							"numerolote", Hibernate.INTEGER).addScalar(
							"numerosublote", Hibernate.INTEGER).addScalar(
							"anomesreferenciadebito", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 20/08/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarTipoConta(Integer idConta)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select contaTipo.id "
					+ "from ContaImpressao contaImpressao "
					+ "inner join contaImpressao.contaGeral contaGeral "
					+ "inner join contaImpressao.contaTipo contaTipo "
					+ "where contaGeral.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idConta", idConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Date pesquisarFaturamentoAtividadeCronogramaDataPrevista(
			Integer faturamentoGrupoId, Integer faturamentoAtividadeId,
			Integer anoMesReferencia) throws ErroRepositorioException {

		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select fac.dataPrevista from FaturamentoAtividadeCronograma fac "
					+ "inner join fac.faturamentoAtividade fa "
					+ "inner join fac.faturamentoGrupoCronogramaMensal fcm "
					+ "inner join fcm.faturamentoGrupo fg "
					+ "where fg.id = :faturamentoGrupoId and fa.id = :faturamentoAtividadeId and "
					+ "fcm.anoMesReferencia = :anoMesReferencia";

			retorno = (Date) session.createQuery(consulta).setInteger(
					"faturamentoGrupoId", faturamentoGrupoId.intValue())
					.setInteger("faturamentoAtividadeId",
							faturamentoAtividadeId).setInteger(
							"anoMesReferencia", anoMesReferencia)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0216] Calcular Acrescimo por Impontualidade
	 * 
	 * @author Raphael Rossiter
	 * @date 28/08/2007
	 * 
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaAtualizacaoTarifaria(Integer idConta)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT "
					+ "cnt.id, " // 0
					+ "cnt.consumoAgua, " // 1
					+ "cnt.consumoEsgoto, " // 2
					+ "ligacaoAguaSituacao.id, " // 3
					+ "ligacaoEsgotoSituacao.id, " // 4
					+ "consumoTarifa.id, " // 5
					+ "cnt.percentualEsgoto, " // 6
					+ "imovel.id, " // 7
					+ "qdra.id, " // 8
					+ "rota.id, " // 9
					+ "ftgr.id, " // 10
					+ "cnt.valorAgua, " // 11
					+ "cnt.valorEsgoto, " // 12
					+ "cnt.referencia " // 13
					+ "FROM Conta cnt "
					+ "INNER JOIN cnt.consumoTarifa consumoTarifa "
					+ "INNER JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "INNER JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "INNER JOIN cnt.imovel imovel "
					+ "INNER JOIN imovel.quadra qdra "
					+ "INNER JOIN qdra.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo ftgr "
					+ "WHERE  cnt.id = :idConta ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", idConta.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/09/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeFaturaPorQualificador(
			Short codigoQualificador) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT COUNT(fatu.id)" + "FROM Fatura fatu "
					+ "WHERE fatu.codigoQualifica = :codigoQualifica ";

			retorno = (Integer) session.createQuery(consulta).setShort(
					"codigoQualifica", codigoQualificador).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/09/2007
	 * 
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarFaturaPorQualificador(Short codigoQualificador,
			Integer anoMesReferencia, BigDecimal valorDebito)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT fatu.id, clie.id " + "FROM Fatura fatu "
					+ "INNER JOIN fatu.cliente clie "
					+ "WHERE fatu.codigoQualifica = :codigoQualifica "
					+ "AND fatu.anoMesReferencia = :anoMesReferencia "
					+ "AND fatu.debito = :valorDebito ";

			retorno = (Object[]) session.createQuery(consulta).setShort(
					"codigoQualifica", codigoQualificador).setInteger(
					"anoMesReferencia", anoMesReferencia).setBigDecimal(
					"valorDebito", valorDebito).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @created 16/02/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarFaturaItem(Integer idFatura)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT fi.valorConta, conta.id, localidade.id, "
					+ "imovel.id, localidadeHistorico.id, imovelHistorico.id "
					+ "FROM FaturaItem fi "
					+ "LEFT JOIN fi.fatura fatura "
					+ "LEFT JOIN fi.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN conta.imovel imovel "
					+ "LEFT JOIN conta.localidade localidade "
					+ "LEFT JOIN contaHistorico.imovel imovelHistorico "
					+ "LEFT JOIN contaHistorico.localidade localidadeHistorico "
					+ "WHERE fatura.id = :idFatura ";

			retorno = session.createQuery(consulta).setInteger("idFatura",
					idFatura).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * 
	 * [UC0637] - Gerar Relatórios Volumes Faturados
	 * 
	 * @author Rafael Corrêa
	 * @created 11/09/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioVolumesFaturados(
			Integer idLocalidade, Integer anoMes, Integer anoMes1,
			Integer anoMes2, Integer anoMes3, Integer anoMes4, Integer anoMes5,
			Integer anoMes6) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT DISTINCT imov.imov_id as idImovel, loc.loca_id as idLocalidade, "
					+ " loc.loca_nmlocalidade as nomeLocalidade, stcm.stcm_id as idSetor, "
					+ " stcm.stcm_cdsetorcomercial as codSetor, stcm.stcm_nmsetorcomercial as nomeSetor, "
					+ " quadra.qdra_id as idQuadra, quadra.qdra_nnquadra as numeroQuadra, "
					+ " clieUsuario.clie_nmcliente as nomeUsuario, "
					+ " imov.last_id as situacaoAgua, imov.lest_id as situacaoEsgoto, "
					// + " CASE WHEN (consHistMes.cshi_nnconsumomedio is not
					// null and consHistMes.cshi_nnconsumomedio <> 0) THEN "
					+ " consHistMes.cshi_nnconsumomedio "
					// + " ELSE "
					// + " 10 END "
					+ " as consumoMedio, "
					+ " consHistMes1.cshi_nnconsumofaturadomes as consumoMes1, "
					+ " consHistMes2.cshi_nnconsumofaturadomes as consumoMes2, "
					+ " consHistMes3.cshi_nnconsumofaturadomes as consumoMes3, "
					+ " consHistMes4.cshi_nnconsumofaturadomes as consumoMes4, "
					+ " consHistMes5.cshi_nnconsumofaturadomes as consumoMes5, "
					+ " consHistMes6.cshi_nnconsumofaturadomes as consumoMes6 "
					+ " FROM cadastro.imovel imov "
					+ " INNER JOIN atendimentopublico.ligacao_agua ligAgua "
					+ " on imov.imov_id = ligAgua.lagu_id "
					+ " INNER JOIN cadastro.localidade loc "
					+ " on imov.loca_id = loc.loca_id "
					+ " INNER JOIN cadastro.setor_comercial stcm "
					+ " on imov.stcm_id = stcm.stcm_id "
					+ " INNER JOIN cadastro.quadra quadra "
					+ " on imov.qdra_id = quadra.qdra_id "
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id "
					+ " and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO
					+ " and clieImovUsuario.clim_dtrelacaofim is null "
					+ " INNER JOIN cadastro.cliente clieUsuario "
					+ " on clieImovUsuario.clie_id = clieUsuario.clie_id "
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes "
					+ " on imov.imov_id = consHistMes.imov_id and consHistMes.cshi_amfaturamento = :anoMes "
					+ " and consHistMes.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes1 "
					+ " on imov.imov_id = consHistMes1.imov_id and consHistMes1.cshi_amfaturamento = :anoMes1 "
					+ " and consHistMes1.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes2 "
					+ " on imov.imov_id = consHistMes2.imov_id and consHistMes2.cshi_amfaturamento = :anoMes2 "
					+ " and consHistMes2.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes3 "
					+ " on imov.imov_id = consHistMes3.imov_id and consHistMes3.cshi_amfaturamento = :anoMes3 "
					+ " and consHistMes3.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes4 "
					+ " on imov.imov_id = consHistMes4.imov_id and consHistMes4.cshi_amfaturamento = :anoMes4 "
					+ " and consHistMes4.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes5 "
					+ " on imov.imov_id = consHistMes5.imov_id and consHistMes5.cshi_amfaturamento = :anoMes5 "
					+ " and consHistMes5.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes6 "
					+ " on imov.imov_id = consHistMes6.imov_id and consHistMes6.cshi_amfaturamento = :anoMes6 "
					+ " and consHistMes6.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " WHERE imov.loca_id = :idLocalidade "
					+ " and ligAgua.hidi_id is not null "
					+ " ORDER BY loc.loca_id, stcm.stcm_cdsetorcomercial, quadra.qdra_nnquadra, imov.imov_id ";

			retorno = session.createSQLQuery(consulta).addScalar("idImovel",
					Hibernate.INTEGER).addScalar("idLocalidade",
					Hibernate.INTEGER).addScalar("nomeLocalidade",
					Hibernate.STRING).addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("codSetor", Hibernate.INTEGER).addScalar(
							"nomeSetor", Hibernate.STRING).addScalar(
							"idQuadra", Hibernate.INTEGER).addScalar(
							"numeroQuadra", Hibernate.INTEGER).addScalar(
							"nomeUsuario", Hibernate.STRING).addScalar(
							"situacaoAgua", Hibernate.INTEGER).addScalar(
							"situacaoEsgoto", Hibernate.INTEGER).addScalar(
							"consumoMedio", Hibernate.INTEGER).addScalar(
							"consumoMes1", Hibernate.INTEGER).addScalar(
							"consumoMes2", Hibernate.INTEGER).addScalar(
							"consumoMes3", Hibernate.INTEGER).addScalar(
							"consumoMes4", Hibernate.INTEGER).addScalar(
							"consumoMes5", Hibernate.INTEGER).addScalar(
							"consumoMes6", Hibernate.INTEGER).setInteger(
							"anoMes", anoMes).setInteger("anoMes1", anoMes1)
					.setInteger("anoMes2", anoMes2).setInteger("anoMes3",
							anoMes3).setInteger("anoMes4", anoMes4).setInteger(
							"anoMes5", anoMes5).setInteger("anoMes6", anoMes6)
					.setInteger("idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório resumido
	 * 
	 * [UC0637] - Gerar Relatórios Volumes Faturados
	 * 
	 * @author Rafael Corrêa
	 * @created 13/09/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioVolumesFaturadosResumido(
			Integer idLocalidade, Integer anoMes, Integer anoMes1,
			Integer anoMes2, Integer anoMes3, Integer anoMes4, Integer anoMes5,
			Integer anoMes6) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT DISTINCT loc.loca_id as idLocalidade, "
					+ " loc.loca_nmlocalidade as nomeLocalidade, stcm.stcm_id as idSetor, "
					+ " stcm.stcm_cdsetorcomercial as codSetor, stcm.stcm_nmsetorcomercial as nomeSetor, "
					+ " quadra.qdra_nnquadra as numeroQuadra, "
					+ " sum(consHistMes.cshi_nnconsumomedio) as consumoMedio, "
					+ " sum(consHistMes1.cshi_nnconsumofaturadomes) as consumoMes1, "
					+ " sum(consHistMes2.cshi_nnconsumofaturadomes) as consumoMes2, "
					+ " sum(consHistMes3.cshi_nnconsumofaturadomes) as consumoMes3, "
					+ " sum(consHistMes4.cshi_nnconsumofaturadomes) as consumoMes4, "
					+ " sum(consHistMes5.cshi_nnconsumofaturadomes) as consumoMes5, "
					+ " sum(consHistMes6.cshi_nnconsumofaturadomes) as consumoMes6 "
					+ " FROM cadastro.imovel imov "
					+ " INNER JOIN atendimentopublico.ligacao_agua ligAgua "
					+ " on imov.imov_id = ligAgua.lagu_id "
					+ " INNER JOIN cadastro.localidade loc "
					+ " on imov.loca_id = loc.loca_id "
					+ " INNER JOIN cadastro.setor_comercial stcm "
					+ " on imov.stcm_id = stcm.stcm_id "
					+ " INNER JOIN cadastro.quadra quadra "
					+ " on imov.qdra_id = quadra.qdra_id "
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes "
					+ " on imov.imov_id = consHistMes.imov_id and consHistMes.cshi_amfaturamento = :anoMes "
					+ " and consHistMes.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes1 "
					+ " on imov.imov_id = consHistMes1.imov_id and consHistMes1.cshi_amfaturamento = :anoMes1 "
					+ " and consHistMes1.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes2 "
					+ " on imov.imov_id = consHistMes2.imov_id and consHistMes2.cshi_amfaturamento = :anoMes2 "
					+ " and consHistMes2.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes3 "
					+ " on imov.imov_id = consHistMes3.imov_id and consHistMes3.cshi_amfaturamento = :anoMes3 "
					+ " and consHistMes3.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes4 "
					+ " on imov.imov_id = consHistMes4.imov_id and consHistMes4.cshi_amfaturamento = :anoMes4 "
					+ " and consHistMes4.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes5 "
					+ " on imov.imov_id = consHistMes5.imov_id and consHistMes5.cshi_amfaturamento = :anoMes5 "
					+ " and consHistMes5.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " LEFT OUTER JOIN micromedicao.consumo_historico consHistMes6 "
					+ " on imov.imov_id = consHistMes6.imov_id and consHistMes6.cshi_amfaturamento = :anoMes6 "
					+ " and consHistMes6.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA.toString()
					+ " WHERE imov.loca_id = :idLocalidade "
					+ " and ligAgua.hidi_id is not null "
					+ " GROUP BY loc.loca_id, loc.loca_nmlocalidade, stcm.stcm_id, stcm.stcm_cdsetorcomercial, "
					+ " stcm.stcm_nmsetorcomercial, quadra.qdra_nnquadra "
					+ " ORDER BY loc.loca_id, stcm.stcm_cdsetorcomercial, quadra.qdra_nnquadra ";

			retorno = session.createSQLQuery(consulta).addScalar(
					"idLocalidade", Hibernate.INTEGER).addScalar(
					"nomeLocalidade", Hibernate.STRING).addScalar("idSetor",
					Hibernate.INTEGER).addScalar("codSetor", Hibernate.INTEGER)
					.addScalar("nomeSetor", Hibernate.STRING).addScalar(
							"numeroQuadra", Hibernate.INTEGER).addScalar(
							"consumoMedio", Hibernate.INTEGER).addScalar(
							"consumoMes1", Hibernate.INTEGER).addScalar(
							"consumoMes2", Hibernate.INTEGER).addScalar(
							"consumoMes3", Hibernate.INTEGER).addScalar(
							"consumoMes4", Hibernate.INTEGER).addScalar(
							"consumoMes5", Hibernate.INTEGER).addScalar(
							"consumoMes6", Hibernate.INTEGER).setInteger(
							"anoMes", anoMes).setInteger("anoMes1", anoMes1)
					.setInteger("anoMes2", anoMes2).setInteger("anoMes3",
							anoMes3).setInteger("anoMes4", anoMes4).setInteger(
							"anoMes5", anoMes5).setInteger("anoMes6", anoMes6)
					.setInteger("idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * 
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioContasRevisao(
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer codigoSetorComercialInicial,
			Integer codigoSetorComercialFinal,
			Collection colecaoIdsMotivoRevisao, Integer idImovelPerfil,
			Integer referenciaInicial, Integer referenciaFinal,
			Integer idCategoria, Integer idEsferaPoder)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT imov.imov_id as idImovel, "
					+ " gerReg.greg_id as idGerencia, "
					+ " gerReg.greg_nmabreviado as nomeGerencia, "
					+ " elo.loca_id as idElo, "
					+ " elo.loca_nmlocalidade as nomeElo, "
					+ " uneg.uneg_id as idUnidadeNegocio, "
					+ " uneg.uneg_nmunidadenegocio as nomeUnidadeNegocio, "
					+ " loc.loca_id as idLocalidade, "
					+ " loc.loca_nmlocalidade as nomeLocalidade, "
					+ " setor.stcm_cdsetorcomercial as codigoSetor, "
					+ " setor.stcm_nmsetorcomercial as nomeSetor, "
					+ " quadra.qdra_nnquadra as numeroQuadra, "
					+ " imov.imov_nnlote as lote, "
					+ " imov.imov_nnsublote as sublote, "
					+ " clieUsuario.clie_nmcliente as nomeClienteUsuario, "
					+ " clieUsuarioFone.cfon_cdddd as dddFoneUsuario, "
					+ " clieUsuarioFone.cfon_nnfone as numeroFoneUsuario, "
					+ " clieUsuarioFone.cfon_nnfoneramal as ramalFoneUsuario, "
					+ " conta.cnta_amreferenciaconta as anoMesReferencia, "
					+ " (conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - coalesce( conta.cnta_vlimpostos, 0 ) ) as valorConta, "
					+ " conta.cnta_dtrevisao as dataRevisao, "
					+ " contaMotRev.cmrv_id as idMotivoRevisao, "
					+ " contaMotRev.cmrv_dsmotivorevisaoconta as descricaoMotivoRevisao "
					+ " FROM cadastro.imovel imov "
					+ " INNER JOIN faturamento.conta conta "
					+ " on conta.imov_id = imov.imov_id and conta.cnta_dtrevisao is not null "
					+ " and conta.dcst_idatual in ("
					+ DebitoCreditoSituacao.NORMAL
					+ ", "
					+ DebitoCreditoSituacao.RETIFICADA
					+ ", "
					+ DebitoCreditoSituacao.INCLUIDA
					+ ", "
					+ DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO
					+ ") "
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario "
					+ " on clieImovUsuario.imov_id = imov.imov_id "
					+ " and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO
					+ " and clieImovUsuario.clim_dtrelacaofim is null "
					+ " INNER JOIN cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " INNER JOIN cadastro.cliente_tipo clieUsuarioTipo "
					+ " on clieUsuarioTipo.cltp_id = clieUsuario.cltp_id "
					+ " INNER JOIN cadastro.setor_comercial setor "
					+ " on setor.stcm_id = imov.stcm_id "
					+ " INNER JOIN cadastro.quadra quadra "
					+ " on quadra.qdra_id = imov.qdra_id "
					+ " INNER JOIN cadastro.localidade loc "
					+ " on loc.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.localidade elo "
					+ " on elo.loca_id = loc.loca_cdelo "
					+ " INNER JOIN cadastro.gerencia_regional gerReg "
					+ " on gerReg.greg_id = loc.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio uneg "
					+ " on loc.uneg_id = uneg.uneg_id "
					+ " LEFT OUTER JOIN cadastro.cliente_fone clieUsuarioFone "
					+ " on clieUsuarioFone.clie_id = clieUsuario.clie_id "
					+ " and clieUsuarioFone.cfon_icfonepadrao = "
					+ ClienteFone.INDICADOR_FONE_PADRAO
					+ " LEFT OUTER JOIN faturamento.conta_motivo_revisao contaMotRev "
					+ " on contaMotRev.cmrv_id = conta.cmrv_id "
					+ " LEFT OUTER JOIN arrecadacao.pagamento pagto "
					+ " on pagto.cnta_id = conta.cnta_id ";

			consulta = consulta
					+ criarCondicionaisRelatorioContasRevisao(
							idGerenciaRegional, idUnidadeNegocio,
							idLocalidadeInicial, idLocalidadeFinal,
							codigoSetorComercialInicial,
							codigoSetorComercialFinal, colecaoIdsMotivoRevisao,
							idImovelPerfil, referenciaInicial, referenciaFinal,
							idCategoria, idEsferaPoder);

			consulta = consulta + " ORDER BY gerReg.greg_id, uneg.uneg_id,  "
					+ " loc.loca_id, setor.stcm_cdsetorcomercial, "
					+ " quadra.qdra_nnquadra, imov.imov_nnlote, "
					+ " imov.imov_nnsublote, conta.cnta_amreferenciaconta ";

			SQLQuery query = session.createSQLQuery(consulta);

			if (colecaoIdsMotivoRevisao != null
					&& colecaoIdsMotivoRevisao.size() > 0) {
				query.setParameterList("colecaoIdsMotivoRevisao",
						colecaoIdsMotivoRevisao);
			}

			retorno = query.addScalar("idImovel", Hibernate.INTEGER).addScalar(
					"idGerencia", Hibernate.INTEGER).addScalar("nomeGerencia",
					Hibernate.STRING).addScalar("idElo", Hibernate.INTEGER)
					.addScalar("nomeElo", Hibernate.STRING).addScalar(
							"idUnidadeNegocio", Hibernate.INTEGER).addScalar(
							"nomeUnidadeNegocio", Hibernate.STRING).addScalar(
							"idLocalidade", Hibernate.INTEGER).addScalar(
							"nomeLocalidade", Hibernate.STRING).addScalar(
							"codigoSetor", Hibernate.INTEGER).addScalar(
							"nomeSetor", Hibernate.STRING).addScalar(
							"numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("nomeClienteUsuario",
							Hibernate.STRING).addScalar("dddFoneUsuario",
							Hibernate.STRING).addScalar("numeroFoneUsuario",
							Hibernate.STRING).addScalar("ramalFoneUsuario",
							Hibernate.STRING).addScalar("anoMesReferencia",
							Hibernate.INTEGER).addScalar("valorConta",
							Hibernate.BIG_DECIMAL).addScalar("dataRevisao",
							Hibernate.DATE).addScalar("idMotivoRevisao",
							Hibernate.INTEGER).addScalar(
							"descricaoMotivoRevisao", Hibernate.STRING).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório resumido
	 * 
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioContasRevisaoResumido(
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer codigoSetorComercialInicial,
			Integer codigoSetorComercialFinal,
			Collection colecaoIdsMotivoRevisao, Integer idImovelPerfil,
			Integer referenciaInicial, Integer referenciaFinal,
			Integer idCategoria, Integer idEsferaPoder)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT gerReg.greg_id as idGerencia, "
					+ " gerReg.greg_nmabreviado as nomeGerencia, "
					+ " elo.loca_id as idElo, "
					+ " elo.loca_nmlocalidade as nomeElo, "
					+ " loc.loca_id as idLocalidade, "
					+ " loc.loca_nmlocalidade as nomeLocalidade, "
					+ " conta.cnta_amreferenciaconta as anoMesReferencia, "
					+ " contaMotRev.cmrv_id as idMotivoRevisao, "
					+ " contaMotRev.cmrv_dsmotivorevisaoconta as descricaoMotivoRevisao, "
					+ " count( conta.cnta_id ) as qtdeContas, "
					+ " sum( conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - coalesce( conta.cnta_vlimpostos, 0 ) ) as valorContas "
					+ " FROM cadastro.imovel imov ";

			if (idEsferaPoder != null) {
				consulta = consulta
						+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario "
						+ " on clieImovUsuario.imov_id = imov.imov_id "
						+ " and clieImovUsuario.crtp_id = "
						+ ClienteRelacaoTipo.USUARIO
						+ " and clieImovUsuario.clim_dtrelacaofim is null "
						+ " INNER JOIN cadastro.cliente clieUsuario "
						+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
						+ " INNER JOIN cadastro.cliente_tipo clieUsuarioTipo "
						+ " on clieUsuarioTipo.cltp_id = clieUsuario.cltp_id ";
			}

			consulta = consulta
					+ " INNER JOIN faturamento.conta conta "
					+ " on conta.imov_id = imov.imov_id and conta.cnta_dtrevisao is not null "
					+ " and conta.dcst_idatual in ("
					+ DebitoCreditoSituacao.NORMAL
					+ ", "
					+ DebitoCreditoSituacao.RETIFICADA
					+ ", "
					+ DebitoCreditoSituacao.INCLUIDA
					+ ", "
					+ DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO
					+ ") "
					+ " INNER JOIN cadastro.localidade loc "
					+ " on loc.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.localidade elo "
					+ " on elo.loca_id = loc.loca_cdelo "
					+ " INNER JOIN cadastro.unidade_negocio uneg "
					+ " on uneg.uneg_id = loc.uneg_id "
					+ " INNER JOIN cadastro.setor_comercial setor "
					+ " on setor.stcm_id = imov.stcm_id "
					+ " INNER JOIN cadastro.gerencia_regional gerReg "
					+ " on gerReg.greg_id = loc.greg_id "
					+ " LEFT OUTER JOIN faturamento.conta_motivo_revisao contaMotRev "
					+ " on contaMotRev.cmrv_id = conta.cmrv_id "
					+ " LEFT OUTER JOIN arrecadacao.pagamento pagto "
					+ " on pagto.cnta_id = conta.cnta_id ";

			consulta = consulta
					+ criarCondicionaisRelatorioContasRevisao(
							idGerenciaRegional, idUnidadeNegocio,
							idLocalidadeInicial, idLocalidadeFinal,
							codigoSetorComercialInicial,
							codigoSetorComercialFinal, colecaoIdsMotivoRevisao,
							idImovelPerfil, referenciaInicial, referenciaFinal,
							idCategoria, idEsferaPoder);

			consulta = consulta
					+ " GROUP BY gerReg.greg_id, gerReg.greg_nmabreviado, "
					+ " elo.loca_id, elo.loca_nmlocalidade, "
					+ " contaMotRev.cmrv_id, contaMotRev.cmrv_dsmotivorevisaoconta, "
					+ " loc.loca_id, loc.loca_nmlocalidade, "
					+ " conta.cnta_amreferenciaconta "
					+ " ORDER BY gerReg.greg_id, gerReg.greg_nmabreviado, "
					+ " elo.loca_id, elo.loca_nmlocalidade, "
					+ " contaMotRev.cmrv_id, contaMotRev.cmrv_dsmotivorevisaoconta, "
					+ " loc.loca_id, loc.loca_nmlocalidade, "
					+ " conta.cnta_amreferenciaconta ";

			SQLQuery query = session.createSQLQuery(consulta);

			if (colecaoIdsMotivoRevisao != null
					&& colecaoIdsMotivoRevisao.size() > 0) {
				query.setParameterList("colecaoIdsMotivoRevisao",
						colecaoIdsMotivoRevisao);
			}

			retorno = query.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("nomeGerencia", Hibernate.STRING).addScalar(
							"idElo", Hibernate.INTEGER).addScalar("nomeElo",
							Hibernate.STRING).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("nomeLocalidade",
							Hibernate.STRING).addScalar("anoMesReferencia",
							Hibernate.INTEGER).addScalar("idMotivoRevisao",
							Hibernate.INTEGER).addScalar(
							"descricaoMotivoRevisao", Hibernate.STRING)
					.addScalar("qtdeContas", Hibernate.INTEGER).addScalar(
							"valorContas", Hibernate.BIG_DECIMAL).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Cria as condiçoes da query que os dados necessário para a geração do
	 * relatório
	 * 
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String criarCondicionaisRelatorioContasRevisao(
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer codigoSetorComercialInicial,
			Integer codigoSetorComercialFinal,
			Collection colecaoIdsMotivoRevisao, Integer idImovelPerfil,
			Integer referenciaInicial, Integer referenciaFinal,
			Integer idCategoria, Integer idEsferaPoder) {

		String sql = " WHERE pagto.pgmt_id is null and ";

		if (idGerenciaRegional != null) {
			sql = sql + " gerReg.greg_id = " + idGerenciaRegional.toString()
					+ " and ";
		}

		if (idUnidadeNegocio != null) {
			sql = sql + " uneg.uneg_id = " + idUnidadeNegocio.toString()
					+ " and ";
		}

		if (idLocalidadeInicial != null) {
			sql = sql + " loc.loca_id between "
					+ idLocalidadeInicial.toString() + " and "
					+ idLocalidadeFinal.toString() + " and ";
		}

		if (codigoSetorComercialInicial != null) {
			sql = sql + " setor.stcm_cdsetorcomercial between "
					+ codigoSetorComercialInicial.toString() + " and "
					+ codigoSetorComercialFinal.toString() + " and ";
		}

		if (colecaoIdsMotivoRevisao != null
				&& !colecaoIdsMotivoRevisao.isEmpty()) {
			sql = sql
					+ " contaMotRev.cmrv_id IN (:colecaoIdsMotivoRevisao) and ";
		}

		if (idImovelPerfil != null) {
			sql = sql + " imov.iper_id = " + idImovelPerfil.toString()
					+ " and ";
		}

		if (referenciaInicial != null) {
			sql = sql + " conta.cnta_amreferenciaconta between "
					+ referenciaInicial.toString() + " and "
					+ referenciaFinal.toString() + " and ";
		}

		if (idCategoria != null) {
			sql = sql
					+ " EXISTS ( SELECT imov_id FROM cadastro.imovel_subcategoria imovSub "
					+ " INNER JOIN cadastro.subcategoria sub "
					+ " on sub.scat_id = imovSub.scat_id "
					+ " WHERE imovSub.imov_id = imov.imov_id and sub.catg_id = "
					+ idCategoria.toString() + " ) and ";
		}

		if (idEsferaPoder != null) {
			sql = sql + " clieUsuarioTipo.epod_id = "
					+ idEsferaPoder.toString() + " and ";
		}

		sql = Util.removerUltimosCaracteres(sql, 4);

		return sql;

	}

	/**
	 * @author Vivianne Sousa
	 * @date 18/09/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasAtualizacaoTarifaria(Integer idImovel,
			Integer inicialReferencia, Integer finalReferencia,
			Date inicialVencimento, Date finalVencimento,
			Integer indicadorContasRevisao) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT "
					+ "cnt.id, " // 0
					+ "cnt.consumoAgua, " // 1
					+ "cnt.consumoEsgoto, " // 2
					+ "ligacaoAguaSituacao.id, " // 3
					+ "ligacaoEsgotoSituacao.id, " // 4
					+ "consumoTarifa.id, " // 5
					+ "cnt.percentualEsgoto, " // 6
					+ "imovel.id, " // 7
					+ "qdra.id, " // 8
					+ "rota.id, " // 9
					+ "ftgr.id, " // 10
					+ "cnt.valorAgua, " // 11
					+ "cnt.valorEsgoto, " // 12
					+ "cnt.referencia " // 13
					+ "FROM Conta cnt "
					+ "INNER JOIN cnt.consumoTarifa consumoTarifa "
					+ "INNER JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "INNER JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "inner join cnt.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "INNER JOIN cnt.imovel imovel "
					+ "INNER JOIN imovel.quadra qdra "
					+ "INNER JOIN qdra.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo ftgr "
					+ "WHERE imovel.id = :idImovel "
					+ " and cnt.consumoTarifa <> :tarifaSocial "
					+ " and (debitoCreditoSituacaoAtual.id = :situacaoNormal "
					+ " or debitoCreditoSituacaoAtual.id = :situacaoRetificada "
					+ " or debitoCreditoSituacaoAtual.id = :situacaoIncluida "
					+ " or debitoCreditoSituacaoAtual.id = :situacaoParcelada)"
					+ " and (cnt.referencia >= :inicialReferencia "
					+ " and cnt.referencia <= :finalReferencia) "
					+ " and (cnt.dataVencimentoConta >=  :inicialVencimento "
					+ " and cnt.dataVencimentoConta <= :finalVencimento) ";

			if (indicadorContasRevisao.intValue() == ConstantesSistema.NAO
					.intValue()) {
				consulta = consulta + " and cnt.dataRevisao is null ";
			}

			consulta = consulta + " order by cnt.referencia ";

			retorno = session.createQuery(consulta).setInteger(
					"situacaoNormal", DebitoCreditoSituacao.NORMAL).setInteger(
					"situacaoRetificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida",
							DebitoCreditoSituacao.INCLUIDA).setInteger(
							"situacaoParcelada",
							DebitoCreditoSituacao.PARCELADA).setInteger(
							"inicialReferencia", inicialReferencia).setInteger(
							"finalReferencia", finalReferencia).setDate(
							"inicialVencimento", inicialVencimento).setDate(
							"finalVencimento", finalVencimento).setInteger(
							"tarifaSocial", ConsumoTarifa.CONSUMO_SOCIAL)
					.setInteger("idImovel", idImovel).list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os Valores das Faixas de Débitos
	 * 
	 * @author Ivan Sérgio
	 * @created 14/09/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDebitoFaixaValores(Integer idFaixaValor,
			Double valorFaixa) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;
		boolean finaliza = false;

		try {

			consulta = "select " + "	id, valorFaixaInicio, valorFaixaFim "
					+ "from" + "	gcom.faturamento.debito.DebitoFaixaValore "
					+ "where ";

			if (!idFaixaValor.equals(0)) {
				consulta += "id = " + idFaixaValor + " and ";
				finaliza = true;
			}

			if (valorFaixa != null) {
				consulta += "valorFaixaInicio <= " + valorFaixa + " and ";
				consulta += "valorFaixaFim >= " + valorFaixa + " and ";
				finaliza = true;
			}

			// Finaliza a instrucao
			if (finaliza) {
				consulta = consulta.substring(0, consulta.length() - 5);
			} else {
				consulta = consulta.substring(0, consulta.length() - 6);
			}

			// Ordena pelo ID
			consulta += " ORDER BY id";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * 
	 * [UC0638] - Gerar Relatórios Anormalidade Consumo
	 * 
	 * @author Rafael Corrêa
	 * @created 15/10/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioAnormalidadeConsumo(
			Integer idGrupoFaturamento, Short codigoRota,
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorComercialInicial, Integer idSetorComercialFinal,
			Integer referencia, Integer idImovelPerfil,
			Integer numOcorConsecutivas, String indicadorOcorrenciasIguais,
			Integer mediaConsumoInicial, Integer mediaConsumoFinal,
			Collection<Integer> colecaoIdsAnormalidadeConsumo,
			Collection<Integer> colecaoIdsAnormalidadeLeitura,
			Collection<Integer> colecaoIdsAnormalidadeLeituraInformada,
			Integer tipoMedicao, Collection<Integer> colecaoIdsEmpresa,
			Integer numeroQuadraInicial, Integer numeroQuadraFinal,Integer idCategoria)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			
			consulta = "SELECT "
				+ " grupoFat.ftgr_id as idGrupoFaturamento," 
				+ " grupoFat.ftgr_dsfaturamentogrupo as descricaoGrupoFaturamento," 
				+ " greg.greg_id as idGerencia," 
				+ " greg.greg_nmabreviado as nomeGerencia," 
				+ " unidNeg.uneg_id as idUnidadeNegocio," 
				+ " unidNeg.uneg_nmabreviado as nomeUnidadeNegocio," 
				+ " elo.loca_id as idElo," 
				+ " elo.loca_nmlocalidade as nomeElo," 
				+ " loc.loca_id as idLocalidade," 
				+ " loc.loca_nmlocalidade as nomeLocalidade," 
				+ " mrem.imov_id as idImovel," 
				+ " clieUsuario.clie_nmcliente as nomeUsuario,"
				+ " mrem.last_id as sitLigAgua," 
				+ " mrem.lest_id as sitLigEsgoto," 
				+ " imov.imov_icdebitoconta as indicadorDebito, "   //--3.7 sai
				+ " mrem.mrem_nnconsumomedio as consumoMedio, "
				+ " consHist.cshi_nnconsumofaturadomes as consumoMes," 
				+ " consAnor.csan_dsabrvconsanormalidade as anormalidadeConsumo," 
				+ " mrem.ltan_id as anormalidadeLeitura," 
				+ " mrem.mrem_qteconomias as qtdeEconomias," 
				+ " mrem.medt_id as tipoMedicao,";

		if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			consulta = consulta
					+ " hidrCapAgua.hicp_dsabreviadahidrcapacidade as capHidAgua, "
					+ " hidrLocInstAgua.hili_dshidmtlocalinstalacao as locInstHidAgua, ";
		} else {
			consulta = consulta
					+ " hidrCapPoco.hicp_dsabreviadahidrcapacidade as capHidPoco, "
					+ " hidrLocInstPoco.hili_dshidmtlocalinstalacao as locInstHidPoco, ";
		}

		consulta = consulta
				+ " setor.stcm_id as idSetorComercial, "
				+ " setor.stcm_cdsetorcomercial as codigoSetorComercial,"
				+ " medHist.mdhi_nnleituraatualinformada as nnLeituraInformada,"
				+ " empr.empr_id as idEmpresa," 
				+ " empr.empr_nmempresa as nomeEmpresa, "
				
				+ " mrem.mrem_inscricaoimovel as inscricaoImovel,"
				+ " mrem_enderecoimovel as enderecoImovel"

				+ " FROM micromedicao.movimento_roteiro_empr     mrem"
				+ " INNER JOIN faturamento.faturamento_grupo        grupoFat 		on grupoFat.ftgr_id = mrem.ftgr_id"
				+ " INNER JOIN cadastro.gerencia_regional 			greg 			on greg.greg_id = mrem.greg_id"
				+ " INNER JOIN cadastro.localidade 					loc 			on loc.loca_id  = mrem.loca_id"
				+ " INNER JOIN cadastro.localidade 					elo 			on elo.loca_id = loc.loca_cdelo" 
				+ " INNER JOIN cadastro.unidade_negocio 			unidNeg 		on unidNeg.uneg_id = loc.uneg_id" 
				+ " INNER JOIN cadastro.imovel 					    imov 			on imov.imov_id = mrem.imov_id"
				+ " INNER JOIN cadastro.setor_comercial 			setor 			on setor.stcm_id = imov.stcm_id" 
				+ " INNER JOIN cadastro.cliente_imovel 				clieImovUsuario on clieImovUsuario.imov_id = imov.imov_id" 
				+ " and clieImovUsuario.crtp_id = " + ClienteRelacaoTipo.USUARIO 
				+ " and clieImovUsuario.clim_dtrelacaofim is null "
				+ " INNER JOIN cadastro.cliente 					clieUsuario 	on clieUsuario.clie_id = clieImovUsuario.clie_id" 
				+ " INNER JOIN cadastro.empresa 					empr 			on empr.empr_id = mrem.empr_id";

		
		if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			consulta = consulta
			+ " INNER JOIN micromedicao.consumo_historico 		consHist 		on consHist.imov_id = imov.imov_id" 
			+ " and consHist.lgti_id =  " + LigacaoTipo.LIGACAO_AGUA
			+ " and consHist.cshi_amfaturamento = :referencia "
			+ " INNER JOIN micromedicao.medicao_historico 		medHist 		on medHist.lagu_id = imov.imov_id" 
			+ " and medHist.medt_id =  " + MedicaoTipo.LIGACAO_AGUA
			+ " and medHist.mdhi_amleitura = :referencia ";

		} else {
			consulta = consulta
			+ " INNER JOIN micromedicao.consumo_historico 		consHist 		on consHist.imov_id = imov.imov_id" 
			+ " and consHist.lgti_id =  " + LigacaoTipo.LIGACAO_ESGOTO
			+ " and consHist.cshi_amfaturamento = :referencia "
			+ " INNER JOIN micromedicao.medicao_historico 		medHist 		on medHist.imov_id = imov.imov_id" 
			+ " and medHist.medt_id =  " + MedicaoTipo.POCO
			+ " and medHist.mdhi_amleitura = :referencia ";
		}

		consulta = consulta
			+ " LEFT OUTER JOIN micromedicao.consumo_anormalidade 	consAnor 		on consAnor.csan_id = consHist.csan_id"
			+ " LEFT OUTER JOIN micromedicao.leitura_anormalidade 	leitAnor 		on leitAnor.ltan_id = medhist.ltan_idleitanormfatmt"; 
 

		if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			consulta = consulta
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua 				lagu" 
					+ "     on lagu.lagu_id = imov.imov_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist 	hidrInstHistAgua" 
					+ " 	on hidrInstHistAgua.hidi_id = lagu.hidi_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro 						hidrAgua" 
					+ " 	on hidrAgua.hidr_id = hidrInstHistAgua.hidr_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_capacidade 				hidrCapAgua" 
					+ " 	on hidrCapAgua.hicp_id = hidrAgua.hicp_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_local_inst 		hidrLocInstAgua" 
					+ " 	on hidrLocInstAgua.hili_id = hidrInstHistAgua.hili_id ";
		} else {
			consulta = consulta
					+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist 	hidrInstHistPoco " 
					+ "		on hidrInstHistPoco.hidi_id = imov.hidi_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro 						hidrPoco" 
					+ " 	on hidrPoco.hidr_id = hidrInstHistPoco.hidr_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_capacidade 				hidrCapPoco " 
					+ "		on hidrCapPoco.hicp_id = hidrPoco.hicp_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_local_inst 		hidrLocInstPoco " 
					+ "		on hidrLocInstPoco.hili_id = hidrInstHistPoco.hili_id ";
		}

		consulta = consulta
				+ criarCondicionaisRelatorioAnormalidadesConsumo(
						idGrupoFaturamento, codigoRota, idGerenciaRegional,
						idUnidadeNegocio, idLocalidadeInicial,
						idLocalidadeFinal, idSetorComercialInicial,
						idSetorComercialFinal, referencia, idImovelPerfil,
						numOcorConsecutivas, indicadorOcorrenciasIguais,
						mediaConsumoInicial, mediaConsumoFinal,
						colecaoIdsAnormalidadeConsumo,
						colecaoIdsAnormalidadeLeitura,
						colecaoIdsAnormalidadeLeituraInformada,
						colecaoIdsEmpresa, numeroQuadraInicial,  
						numeroQuadraFinal, idCategoria);

		consulta = consulta
				+ " ORDER BY grupoFat.ftgr_id, greg.greg_id, unidNeg.uneg_id, elo.loca_id, "
				+ " loc.loca_id, setor.stcm_cdsetorcomercial, empr.empr_id, imov.imov_id ";

		SQLQuery query = session.createSQLQuery(consulta);

		if (colecaoIdsAnormalidadeConsumo != null
				&& colecaoIdsAnormalidadeConsumo.size() > 0) {
			query.setParameterList("colecaoIdsAnormalidadeConsumo",
					colecaoIdsAnormalidadeConsumo);
		}

		if (colecaoIdsAnormalidadeLeitura != null
				&& colecaoIdsAnormalidadeLeitura.size() > 0) {
			query.setParameterList("colecaoIdsAnormalidadeLeitura",
					colecaoIdsAnormalidadeLeitura);
		}

		if (colecaoIdsAnormalidadeLeituraInformada != null
				&& colecaoIdsAnormalidadeLeituraInformada.size() > 0) {
			query.setParameterList(
					"colecaoIdsAnormalidadeLeituraInformada",
					colecaoIdsAnormalidadeLeituraInformada);
		}

		if (colecaoIdsEmpresa != null && colecaoIdsEmpresa.size() > 0) {
			query.setParameterList("colecaoIdsEmpresa", colecaoIdsEmpresa);
		}

		if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			retorno = query.addScalar("idGrupoFaturamento",	Hibernate.INTEGER)
					.addScalar("descricaoGrupoFaturamento", Hibernate.STRING)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("nomeGerencia", Hibernate.STRING)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idElo", Hibernate.INTEGER)
					.addScalar("nomeElo", Hibernate.STRING)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeUsuario", Hibernate.STRING)
					.addScalar("sitLigAgua", Hibernate.INTEGER)
					.addScalar("sitLigEsgoto", Hibernate.INTEGER)
					.addScalar("indicadorDebito", Hibernate.SHORT)
					.addScalar("consumoMedio", Hibernate.INTEGER)
					.addScalar("consumoMes", Hibernate.INTEGER)
					.addScalar("anormalidadeConsumo", Hibernate.STRING)
					.addScalar("anormalidadeLeitura", Hibernate.INTEGER)
					.addScalar("qtdeEconomias", Hibernate.SHORT)
					.addScalar("tipoMedicao", Hibernate.INTEGER)
					.addScalar("capHidAgua", Hibernate.STRING)
					.addScalar("locInstHidAgua", Hibernate.STRING)
					.addScalar("idSetorComercial", Hibernate.INTEGER)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("nnLeituraInformada", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("nomeEmpresa", Hibernate.STRING)
					.addScalar("inscricaoImovel", Hibernate.STRING)
					.addScalar("enderecoImovel", Hibernate.STRING)
					.setInteger("referencia", referencia)
					.list();
		} else {
			retorno = query.addScalar("idGrupoFaturamento",
					Hibernate.INTEGER).addScalar(
					"descricaoGrupoFaturamento", Hibernate.STRING)
					.addScalar("idGerencia", Hibernate.INTEGER).addScalar(
							"nomeGerencia", Hibernate.STRING).addScalar(
							"idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idElo", Hibernate.INTEGER).addScalar(
							"nomeElo", Hibernate.STRING).addScalar(
							"idLocalidade", Hibernate.INTEGER).addScalar(
							"nomeLocalidade", Hibernate.STRING).addScalar(
							"idImovel", Hibernate.INTEGER).addScalar(
							"nomeUsuario", Hibernate.STRING).addScalar(
							"sitLigAgua", Hibernate.INTEGER).addScalar(
							"sitLigEsgoto", Hibernate.INTEGER).addScalar(
							"indicadorDebito", Hibernate.SHORT).addScalar(
							"consumoMedio", Hibernate.INTEGER).addScalar(
							"consumoMes", Hibernate.INTEGER).addScalar(
							"anormalidadeConsumo", Hibernate.STRING)
					.addScalar("anormalidadeLeitura", Hibernate.INTEGER)
					.addScalar("qtdeEconomias", Hibernate.SHORT).addScalar(
							"tipoMedicao", Hibernate.INTEGER).addScalar(
							"capHidPoco", Hibernate.STRING).addScalar(
							"locInstHidPoco", Hibernate.STRING).addScalar(
							"idSetorComercial", Hibernate.INTEGER)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("nnLeituraInformada", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER).addScalar(
							"nomeEmpresa", Hibernate.STRING)
							.addScalar("inscricaoImovel", Hibernate.STRING)
						.addScalar("enderecoImovel", Hibernate.STRING)
							.setInteger("referencia", referencia)
							.list();
		}


//			consulta = "SELECT grupoFat.ftgr_id as idGrupoFaturamento, "
//					+ " grupoFat.ftgr_dsfaturamentogrupo as descricaoGrupoFaturamento, "
//					+ " greg.greg_id as idGerencia, greg.greg_nmabreviado as nomeGerencia, "
//					+ " unidNeg.uneg_id as idUnidadeNegocio, unidNeg.uneg_nmabreviado as nomeUnidadeNegocio, "
//					+ " elo.loca_id as idElo, elo.loca_nmlocalidade as nomeElo, "
//					+ " loc.loca_id as idLocalidade, loc.loca_nmlocalidade as nomeLocalidade, "
//					+ " imov.imov_id as idImovel, clieUsuario.clie_nmcliente as nomeUsuario, "
//					+ " imov.last_id as sitLigAgua, imov.lest_id as sitLigEsgoto, "
//					+ " imov.imov_icdebitoconta as indicadorDebito, "
//					+ " consHist.cshi_nnconsumomedio as consumoMedio, consHist.cshi_nnconsumofaturadomes as consumoMes, "
//					+ " consAnor.csan_dsabreviadaconsumoanormalidade as anormalidadeConsumo, "
//					+ " leitAnorInformada.ltan_id as anormalidadeLeitura, "
//					+ " imov.imov_qteconomia as qtdeEconomias, "
//					+ " medHist.medt_id as tipoMedicao,";
//
//			if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
//				consulta = consulta
//						+ " hidrCapAgua.hicp_dsabreviadahidrometrocapacidade as capHidAgua, "
//						+ " hidrLocInstAgua.hili_dsabreviadahidrometrolocalinstalacao as locInstHidAgua, ";
//			} else {
//				consulta = consulta
//						+ " hidrCapPoco.hicp_dsabreviadahidrometrocapacidade as capHidPoco, "
//						+ " hidrLocInstPoco.hili_dsabreviadahidrometrolocalinstalacao as locInstHidPoco, ";
//			}
//
//			consulta = consulta
//					+ " setor.stcm_id as idSetorComercial, "
//					+ " setor.stcm_cdsetorcomercial as codigoSetorComercial,"
//					+ " medHist.mdhi_nnleituraatualinformada as nnLeituraInformada,"
//					+ " empr.empr_id as idEmpresa, "
//					+ " empr.empr_nmempresa as nomeEmpresa"
//					+ " FROM cadastro.imovel imov "
//					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario "
//					+ " on clieImovUsuario.imov_id = imov.imov_id "
//					+ " and clieImovUsuario.crtp_id = "
//					+ ClienteRelacaoTipo.USUARIO
//					+ " and clieImovUsuario.clim_dtrelacaofim is null "
//					+ " INNER JOIN cadastro.cliente clieUsuario "
//					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id ";
//
//			if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
//				consulta = consulta
//						+ " LEFT OUTER JOIN micromedicao.consumo_historico consHist "
//						+ " on consHist.imov_id = imov.imov_id and consHist.lgti_id = "
//						+ LigacaoTipo.LIGACAO_AGUA.toString();
//			} else {
//				consulta = consulta
//						+ " LEFT OUTER JOIN micromedicao.consumo_historico consHist "
//						+ " on consHist.imov_id = imov.imov_id and consHist.lgti_id = "
//						+ LigacaoTipo.LIGACAO_ESGOTO.toString();
//			}
//
//			consulta = consulta
//					+ " and consHist.cshi_amfaturamento = :referencia "
//					+ " INNER JOIN cadastro.setor_comercial setor "
//					+ " on setor.stcm_id = imov.stcm_id "
//					+ " INNER JOIN cadastro.localidade loc "
//					+ " on loc.loca_id = imov.loca_id "
//					+ " INNER JOIN cadastro.localidade elo "
//					+ " on elo.loca_id = loc.loca_cdelo "
//					+ " INNER JOIN cadastro.unidade_negocio unidNeg "
//					+ " on unidNeg.uneg_id = loc.uneg_id "
//					+ " INNER JOIN cadastro.gerencia_regional greg "
//					+ " on greg.greg_id = unidNeg.greg_id "
//					+ " INNER JOIN cadastro.quadra quadra "
//					+ " on quadra.qdra_id = imov.qdra_id "
//					+ " INNER JOIN micromedicao.rota rota "
//					+ " on rota.rota_id = quadra.rota_id "
//					+ " INNER JOIN cadastro.empresa empr "
//					+ " on rota.empr_id = empr.empr_id"
//					+ " INNER JOIN faturamento.faturamento_grupo grupoFat "
//					+ " on grupoFat.ftgr_id = rota.ftgr_id "
//					+ " LEFT OUTER JOIN micromedicao.consumo_anormalidade consAnor "
//					+ " on consAnor.csan_id = consHist.csan_id ";
//
//			if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
//				consulta = consulta
//						+ " LEFT OUTER JOIN micromedicao.medicao_historico medHist "
//						+ " on medHist.lagu_id = imov.imov_id "
//						+ " and medHist.medt_id = "
//						+ MedicaoTipo.LIGACAO_AGUA.toString()
//						+ " and medHist.mdhi_amleitura = :referencia ";
//			} else {
//				consulta = consulta
//						+ " LEFT OUTER JOIN micromedicao.medicao_historico medHist "
//						+ " on medHist.imov_id = imov.imov_id "
//						+ " and medHist.medt_id = "
//						+ MedicaoTipo.POCO.toString()
//						+ " and medHist.mdhi_amleitura = :referencia ";
//			}
//
//			consulta = consulta
//					+ " LEFT OUTER JOIN micromedicao.leitura_anormalidade leitAnor "
//					+ " on leitAnor.ltan_id = medHist.ltan_idleituraanormalidadefaturamento "
//					+ " LEFT OUTER JOIN micromedicao.leitura_anormalidade leitAnorInformada "
//					+ " on leitAnorInformada.ltan_id = medHist.ltan_idleituraanormalidadeinformada ";
//
//			if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
//				consulta = consulta
//						+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua lagu "
//						+ " on lagu.lagu_id = imov.imov_id "
//						+ " LEFT OUTER JOIN micromedicao.hidrometro_instalacao_historico hidrInstHistAgua "
//						+ " on hidrInstHistAgua.hidi_id = lagu.hidi_id "
//						+ " LEFT OUTER JOIN micromedicao.hidrometro hidrAgua "
//						+ " on hidrAgua.hidr_id = hidrInstHistAgua.hidr_id "
//						+ " LEFT OUTER JOIN micromedicao.hidrometro_capacidade hidrCapAgua "
//						+ " on hidrCapAgua.hicp_id = hidrAgua.hicp_id "
//						+ " LEFT OUTER JOIN micromedicao.hidrometro_local_instalacao hidrLocInstAgua "
//						+ " on hidrLocInstAgua.hili_id = hidrInstHistAgua.hili_id ";
//			} else {
//				consulta = consulta
//						+ " LEFT OUTER JOIN micromedicao.hidrometro_instalacao_historico hidrInstHistPoco "
//						+ " on hidrInstHistPoco.hidi_id = imov.hidi_id "
//						+ " LEFT OUTER JOIN micromedicao.hidrometro hidrPoco "
//						+ " on hidrPoco.hidr_id = hidrInstHistPoco.hidr_id "
//						+ " LEFT OUTER JOIN micromedicao.hidrometro_capacidade hidrCapPoco "
//						+ " on hidrCapPoco.hicp_id = hidrPoco.hicp_id "
//						+ " LEFT OUTER JOIN micromedicao.hidrometro_local_instalacao hidrLocInstPoco "
//						+ " on hidrLocInstPoco.hili_id = hidrInstHistPoco.hili_id ";
//			}
//
//			consulta = consulta
//					+ criarCondicionaisRelatorioAnormalidadesConsumo(
//							idGrupoFaturamento, codigoRota, idGerenciaRegional,
//							idUnidadeNegocio, idLocalidadeInicial,
//							idLocalidadeFinal, idSetorComercialInicial,
//							idSetorComercialFinal, referencia, idImovelPerfil,
//							numOcorConsecutivas, indicadorOcorrenciasIguais,
//							mediaConsumoInicial, mediaConsumoFinal,
//							colecaoIdsAnormalidadeConsumo,
//							colecaoIdsAnormalidadeLeitura,
//							colecaoIdsAnormalidadeLeituraInformada,
//							colecaoIdsEmpresa);
//
//			consulta = consulta
//					+ " ORDER BY grupoFat.ftgr_id, greg.greg_id, unidNeg.uneg_id, elo.loca_id, "
//					+ " loc.loca_id, setor.stcm_cdsetorcomercial, empr.empr_id, imov.imov_id ";
//
//			SQLQuery query = session.createSQLQuery(consulta);
//
//			if (colecaoIdsAnormalidadeConsumo != null
//					&& colecaoIdsAnormalidadeConsumo.size() > 0) {
//				query.setParameterList("colecaoIdsAnormalidadeConsumo",
//						colecaoIdsAnormalidadeConsumo);
//			}
//
//			if (colecaoIdsAnormalidadeLeitura != null
//					&& colecaoIdsAnormalidadeLeitura.size() > 0) {
//				query.setParameterList("colecaoIdsAnormalidadeLeitura",
//						colecaoIdsAnormalidadeLeitura);
//			}
//
//			if (colecaoIdsAnormalidadeLeituraInformada != null
//					&& colecaoIdsAnormalidadeLeituraInformada.size() > 0) {
//				query.setParameterList(
//						"colecaoIdsAnormalidadeLeituraInformada",
//						colecaoIdsAnormalidadeLeituraInformada);
//			}
//
//			if (colecaoIdsEmpresa != null && colecaoIdsEmpresa.size() > 0) {
//				query.setParameterList("colecaoIdsEmpresa", colecaoIdsEmpresa);
//			}
//
//			if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
//				retorno = query.addScalar("idGrupoFaturamento",
//						Hibernate.INTEGER).addScalar(
//						"descricaoGrupoFaturamento", Hibernate.STRING)
//						.addScalar("idGerencia", Hibernate.INTEGER).addScalar(
//								"nomeGerencia", Hibernate.STRING).addScalar(
//								"idUnidadeNegocio", Hibernate.INTEGER)
//						.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
//						.addScalar("idElo", Hibernate.INTEGER).addScalar(
//								"nomeElo", Hibernate.STRING).addScalar(
//								"idLocalidade", Hibernate.INTEGER).addScalar(
//								"nomeLocalidade", Hibernate.STRING).addScalar(
//								"idImovel", Hibernate.INTEGER).addScalar(
//								"nomeUsuario", Hibernate.STRING).addScalar(
//								"sitLigAgua", Hibernate.INTEGER).addScalar(
//								"sitLigEsgoto", Hibernate.INTEGER).addScalar(
//								"indicadorDebito", Hibernate.SHORT).addScalar(
//								"consumoMedio", Hibernate.INTEGER).addScalar(
//								"consumoMes", Hibernate.INTEGER).addScalar(
//								"anormalidadeConsumo", Hibernate.STRING)
//						.addScalar("anormalidadeLeitura", Hibernate.INTEGER)
//						.addScalar("qtdeEconomias", Hibernate.SHORT).addScalar(
//								"tipoMedicao", Hibernate.INTEGER).addScalar(
//								"capHidAgua", Hibernate.STRING).addScalar(
//								"locInstHidAgua", Hibernate.STRING).addScalar(
//								"idSetorComercial", Hibernate.INTEGER)
//						.addScalar("codigoSetorComercial", Hibernate.INTEGER)
//						.addScalar("nnLeituraInformada", Hibernate.INTEGER)
//						.addScalar("idEmpresa", Hibernate.INTEGER).addScalar(
//								"nomeEmpresa", Hibernate.STRING).setInteger(
//								"referencia", referencia).list();
//			} else {
//				retorno = query.addScalar("idGrupoFaturamento",
//						Hibernate.INTEGER).addScalar(
//						"descricaoGrupoFaturamento", Hibernate.STRING)
//						.addScalar("idGerencia", Hibernate.INTEGER).addScalar(
//								"nomeGerencia", Hibernate.STRING).addScalar(
//								"idUnidadeNegocio", Hibernate.INTEGER)
//						.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
//						.addScalar("idElo", Hibernate.INTEGER).addScalar(
//								"nomeElo", Hibernate.STRING).addScalar(
//								"idLocalidade", Hibernate.INTEGER).addScalar(
//								"nomeLocalidade", Hibernate.STRING).addScalar(
//								"idImovel", Hibernate.INTEGER).addScalar(
//								"nomeUsuario", Hibernate.STRING).addScalar(
//								"sitLigAgua", Hibernate.INTEGER).addScalar(
//								"sitLigEsgoto", Hibernate.INTEGER).addScalar(
//								"indicadorDebito", Hibernate.SHORT).addScalar(
//								"consumoMedio", Hibernate.INTEGER).addScalar(
//								"consumoMes", Hibernate.INTEGER).addScalar(
//								"anormalidadeConsumo", Hibernate.STRING)
//						.addScalar("anormalidadeLeitura", Hibernate.INTEGER)
//						.addScalar("qtdeEconomias", Hibernate.SHORT).addScalar(
//								"tipoMedicao", Hibernate.INTEGER).addScalar(
//								"capHidPoco", Hibernate.STRING).addScalar(
//								"locInstHidPoco", Hibernate.STRING).addScalar(
//								"idSetorComercial", Hibernate.INTEGER)
//						.addScalar("codigoSetorComercial", Hibernate.INTEGER)
//						.addScalar("nnLeituraInformada", Hibernate.INTEGER)
//						.addScalar("idEmpresa", Hibernate.INTEGER).addScalar(
//								"nomeEmpresa", Hibernate.STRING).setInteger(
//								"referencia", referencia).list();
//			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Cria as condiçoes da query que os dados necessário para a geração do
	 * relatório
	 * 
	 * [UC0638] - Gerar Relatórios Anormalidade Consumo
	 * 
	 * @author Rafael Corrêa
	 * @created 15/10/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String criarCondicionaisRelatorioAnormalidadesConsumo(
			Integer idGrupoFaturamento, Short codigoRota,
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorComercialInicial, Integer idSetorComercialFinal,
			Integer referencia, Integer idImovelPerfil,
			Integer numOcorConsecutivas, String indicadorOcorrenciasIguais,
			Integer mediaConsumoInicial, Integer mediaConsumoFinal,
			Collection<Integer> colecaoIdsAnormalidadeConsumo,
			Collection<Integer> colecaoIdsAnormalidadeLeitura,
			Collection<Integer> colecaoIdsAnormalidadeLeituraInformada,
			Collection<Integer> colecaoIdsEmpresa,
			Integer numeroQuadraInicial, Integer numeroQuadraFinal,Integer idCategoria) {

		String sql = "WHERE mrem.mrem_ammovimento = :referencia and " +
				"(consAnor.csan_id is not null or leitAnor.ltan_id is not null or mrem.ltan_id is not null) and ";
//			" WHERE (consAnor.csan_id is not null or leitAnor.ltan_id is not null or leitAnorInformada.ltan_id is not null) and ";

		if (idGerenciaRegional != null) {
			sql = sql + " greg.greg_id = " + idGerenciaRegional.toString() + " and ";
		}

		if (idLocalidadeInicial != null) {
			sql = sql + " loc.loca_id between "
					+ idLocalidadeInicial.toString() + " and "
					+ idLocalidadeFinal.toString() + " and ";
		}

		if (idSetorComercialInicial != null) {
			sql = sql + " setor.stcm_cdsetorcomercial between "
					+ idSetorComercialInicial.toString() + " and "
					+ idSetorComercialFinal.toString() + " and ";
		}

		if (idUnidadeNegocio != null) {
			sql = sql + " unidNeg.uneg_id = " + idUnidadeNegocio.toString()	+ " and ";
		}

		if (idGrupoFaturamento != null) {
			sql = sql + " grupoFat.ftgr_id = " + idGrupoFaturamento.toString()
					+ " and ";
		}

		if (codigoRota != null) {
			sql = sql + " mrem.mrem_cdrota = " + codigoRota.toString()
			+ " and ";
//			sql = sql + " rota.rota_cdrota = " + codigoRota.toString()
//					+ " and ";
		}

		if (idImovelPerfil != null) {
			sql = sql + " imov.iper_id = " + idImovelPerfil.toString()
					+ " and ";
		}

		if (mediaConsumoInicial != null) {
			sql = sql + " consHist.cshi_nnconsumofaturadomes between "
					+ mediaConsumoInicial + " and " + mediaConsumoFinal
					+ " and ";
		}

//		if (colecaoIdsAnormalidadeConsumo != null
//				&& colecaoIdsAnormalidadeConsumo.size() > 0) {
//			sql = sql
//					+ " consAnor.csan_id IN (:colecaoIdsAnormalidadeConsumo) and ";
//		}
//
//		if (colecaoIdsAnormalidadeLeitura != null
//				&& colecaoIdsAnormalidadeLeitura.size() > 0) {
//			sql = sql
//					+ " leitAnor.ltan_id IN (:colecaoIdsAnormalidadeLeitura) and ";
//		}

		if (colecaoIdsAnormalidadeLeituraInformada != null
				&& colecaoIdsAnormalidadeLeituraInformada.size() > 0) {
			sql = sql
					//+ " leitAnorInformada.ltan_id IN (:colecaoIdsAnormalidadeLeituraInformada) and ";
					+ " mrem.ltan_id IN (:colecaoIdsAnormalidadeLeituraInformada) and ";
		}

		if (colecaoIdsEmpresa != null && colecaoIdsEmpresa.size() > 0) {
			sql = sql + " empr.empr_id IN (:colecaoIdsEmpresa) and ";
		}

		
		if(numeroQuadraInicial != null && numeroQuadraFinal != null){
			sql = sql + " mrem.mrem_nnquadra between "
			+ numeroQuadraInicial + " and "
			+ numeroQuadraFinal + " and ";
		}
		
		if (idCategoria != null) {
			sql = sql + " mrem.catg_idprincipal = " + idCategoria
					+ " and ";
		}
		
		sql = Util.removerUltimosCaracteres(sql, 4);
		
		return sql;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de crédito a
	 * realizar acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer idOrigemCredito, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),loca,greg,catg,uneg) "
					+ "from CreditoARealizarCategoria cacg "
					+ "inner join cacg.creditoARealizar crar "
					+ "inner join cacg.categoria catg "
					+ "inner join crar.creditoOrigem crog "
					+ "inner join crar.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "where loca.id = :idLocalidade "
					+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ "and crog.id = :idOrigemCredito "
					+ "group by crar.anoMesReferenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idOrigemCredito", idOrigemCredito).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, situação anterior e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idCreditoOrigem, Integer idSituacaoAtual,
			Integer idSituacaoAnterior) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
					+ "from CreditoRealizadoCategoria crcg "
					+ "inner join crcg.creditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "left join crrz.localidade loca "
					+ "left join crcg.categoria catg "
					+ "where cnta.referencia = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual "
					+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacaoAnterior) "
					+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
					+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idCreditoOrigem", idCreditoOrigem)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, tipo de financiamento e pelo lançamento item contábil com
	 * o ano/mês de referência da baixa contábil da conta preenchido
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResumoFaturamento> acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idFinanciamentoTipo, Integer idSituacaoAtual,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Collection<ResumoFaturamento> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "left join dbcb.financiamentoTipo fntp "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and lict.id = :idLancamentoItemContabil "
					+ "and cnta.debitoCreditoSituacaoAtual.id  = :idSituacaoAtual "
					+ "and fntp.id = :idFinanciamentoTipo "
					+ "and cnta.referenciaBaixaContabil is not null "
					+ "group by cnta.referenciaContabil,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.setInteger("idLancamentoItemContabil",
							idLancamentoItemContabil).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, tipo de financiamento e pelo lançamento item contábil com
	 * o ano/mês de referência da baixa contábil da conta não preenchido
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idFinanciamentoTipo, Integer idSituacaoAtual,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
					+ "from DebitoCobradoCategoria dccg "
					+ "inner join dccg.debitoCobrado dbcb "
					+ "inner join dbcb.conta cnta "
					+ "inner join dbcb.lancamentoItemContabil lict "
					+ "left join dbcb.localidade loca "
					+ "left join dccg.categoria catg "
					+ "left join dbcb.financiamentoTipo fntp "
					+ "where cnta.referenciaContabil = :anoMesReferencia "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and lict.id = :idLancamentoItemContabil "
					+ "and cnta.debitoCreditoSituacaoAtual.id  = :idSituacaoAtual "
					+ "and fntp.id = :idFinanciamentoTipo "
					+ "and cnta.referenciaBaixaContabil is null "
					+ "group by cnta.referenciaContabil,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idFinanciamentoTipo", idFinanciamentoTipo)
					.setInteger("idLancamentoItemContabil",
							idLancamentoItemContabil).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor do imposto
	 * acumulado de acordo com o ano/mês de referência cntábil da conta, as
	 * situações atuais da conta e o tipo de imposto.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idsSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 * 
	 */
	public ResumoFaturamento acumularValorImpostoPorTipoImpostoESituacaoConta(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria,
			Integer idImpostoTipo, Integer[] idsSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
					+ "from ContaImpostosDeduzidos cnid "
					+ "inner join cnid.impostoTipo imtp "
					+ "inner join cnid.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join cnta.contaCategorias ctcg "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where loca.id= :idLocalidade and "
					+ "catg.id = :idCategoria and "
					+ "cnta.referenciaContabil = :anoMesReferencia "
					+ "and imtp.id = :idTipoImposto "
					+ "and cnta.debitoCreditoSituacaoAtual in (:idsSituacaoAtual) "
					+ "group by cnta.referenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"referenciaContabil", anoMesReferencia).setInteger(
							"idTipoImposto", idImpostoTipo).setParameterList(
							"idsSituacaoAtual", idsSituacaoAtual)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor do imposto
	 * acumulado de acordo com o ano/mês de referência contábil da conta, a
	 * situação atual da conta e o tipo de imposto.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 * 
	 */
	public BigDecimal acumularValorImpostoPorTipoImpostoESituacaoAtualConta(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria,
			Integer idImpostoTipo, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select sum(cnid.valorImposto) "
					+ "from ContaImpostosDeduzidos cnid "
					+ "inner join cnid.impostoTipo imtp "
					+ "inner join cnid.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join cnta.contaCategorias ctcg "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where loca.id= :idLocalidade and "
					+ "catg.id = :idCategoria and "
					+ "cnta.referenciaContabil = :anoMesReferencia "
					+ "and imtp.id = :idTipoImposto "
					+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("anoMesReferencia",
					anoMesReferencia)
					.setInteger("idTipoImposto", idImpostoTipo).setInteger(
							"idSituacaoAtual", idSituacaoAtual).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor do imposto
	 * acumulado de acordo com o ano/mês de referência contábil da conta, a
	 * situação atual e anterior da conta e o tipo de imposto.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 * 
	 */
	public BigDecimal acumularValorImpostoPorTipoImpostoESituacaoAtualConta(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria,
			Integer idImpostoTipo, Integer idSituacaoAtual,
			Integer idSituacaoAnterior) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			// constroi o hql
			consulta = "select sum(cnid.valorImposto) "
					+ "from ContaImpostosDeduzidos cnid "
					+ "inner join cnid.impostoTipo imtp "
					+ "inner join cnid.conta cnta "
					+ "inner join cnta.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join cnta.contaCategorias ctcg "
					+ "inner join ctcg.comp_id.categoria catg "
					+ "where loca.id= :idLocalidade and "
					+ "catg.id = :idCategoria and "
					+ "cnta.referenciaContabil = :anoMesReferencia "
					+ "and imtp.id = :idTipoImposto "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual or cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("anoMesReferencia",
					anoMesReferencia)
					.setInteger("idTipoImposto", idImpostoTipo).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de crédito a
	 * realizar acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer[] idsOrigemCredito, Integer idSituacaoAtual,
			Integer idSituacaoAnterior) throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),lict.sequenciaImpressao,lict,loca,greg,catg,uneg) "
					+ "from CreditoARealizarCategoria cacg "
					+ "inner join cacg.creditoARealizar crar "
					+ "inner join crar.lancamentoItemContabil lict "
					+ "inner join cacg.categoria catg "
					+ "inner join crar.creditoOrigem crog "
					+ "inner join crar.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "where loca.id = :idLocalidade "
					+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and (crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or crar.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
					+ "and (crog.id in (:idsOrigemCredito)) "
					+ "group by crar.anoMesReferenciaContabil,lict.sequenciaImpressao,lict,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setParameterList("idsOrigemCredito", idsOrigemCredito)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de crédito a
	 * realizar acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer[] idsOrigemCredito, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),lict.sequenciaImpressao,lict,loca,greg,catg,uneg) "
					+ "from CreditoARealizarCategoria cacg "
					+ "inner join cacg.creditoARealizar crar "
					+ "inner join crar.lancamentoItemContabil lict "
					+ "inner join cacg.categoria catg "
					+ "inner join crar.creditoOrigem crog "
					+ "inner join crar.localidade loca "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join loca.unidadeNegocio uneg "
					+ "where loca.id = :idLocalidade "
					+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ "and crog.id in (:idsOrigemCredito) "
					+ "group by crar.anoMesReferenciaContabil,lict.sequenciaImpressao,lict,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsOrigemCredito", idsOrigemCredito)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna uma coleção de crédito a
	 * realizar, de acordo com o ano/mês de referência, a situação atual, a
	 * situação anterior e origem de crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizarPorOrigemCredito(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsOrigemCredito, Integer idSituacaoAtual,
			Integer idSituacaoAnterior) throws ErroRepositorioException {

		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cacg.valorCategoria,crar.numeroPrestacaoCredito "
					+ "from CreditoARealizarCategoria cacg "
					+ "inner join cacg.creditoARealizar crar "
					+ "inner join cacg.categoria catg "
					+ "inner join crar.localidade loca "
					+ "inner join crar.creditoOrigem crog "
					+ "where crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
					+ "and loca.id = :idLocalidade "
					+ "and catg.id = :idCategoria "
					+ "and crog.id in (:idsOrigemCredito) "
					+ "and (crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
					+ " or crar.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaContabil", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setParameterList("idsOrigemCredito",
					idsOrigemCredito).setInteger("idSituacaoAtual",
					idSituacaoAtual).setInteger("idSituacaoAnterior",
					idSituacaoAnterior).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0600] Emitir Histograma de Esgoto
	 * 
	 * [SB0014] Selecionar por Indicador de Consumo [SB0015] Selecionar por
	 * Indicador de Medido [SB0016] Selecionar por Indicador de Poço [SB0017]
	 * Selecionar por Indicador de Volume Fixo de Água
	 * 
	 * @author Rafael Pinto
	 * @date 05/11/2007
	 * 
	 * @param FiltrarEmitirHistogramaEsgotoHelper
	 * 
	 * @return Collection<Object[]>
	 * @throws ControladorException
	 */
	public Collection<Object[]> pesquisarEmitirHistogramaEsgoto(
			FiltrarEmitirHistogramaEsgotoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoSubCategoria = filtro.getColecaoSubcategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro
				.getColecaoSituacaoLigacaoEsgoto();
		Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro
				.getColecaoPercentualLigacaoEsgoto();

		Categoria categoria = filtro.getCategoria();
		ConsumoTarifa tarifa = filtro.getTarifa();
		ImovelPerfil perfilImovel = filtro.getPerfilImovel();
		EsferaPoder esferaPoder = filtro.getEsferaPoder();
		LigacaoEsgotoSituacao situacaoLigacaoEsgoto = filtro
				.getSituacaoLigacaoEsgoto();
		BigDecimal percentualLigacaoEsgoto = filtro
				.getPercentualLigacaoEsgoto();

		Short consumo = filtro.getConsumo();
		Short medicao = filtro.getMedicao();
		Short poco = filtro.getPoco();
		Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

		ConsumoFaixaLigacao consumoFaixaLigacao = filtro
				.getConsumoFaixaLigacao();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro
				.getConsumoFaixaLigacaoIntervaloMedido();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro
				.getConsumoFaixaLigacaoIntervaloNaoMedido();

		String clausulaGroup = filtro.getTipoGroupBy();

		Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
		Integer numeroQuadra = filtro.getNumeroQuadra();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT categoria.id," // 0
					+ "categoria.descricao," // 1
					+ "sum(histograma.quantidadeLigacao)," // 2
					+ "sum(histograma.quantidadeEconomiaLigacao)," // 3
					+ "sum(histograma.valorFaturadoLigacao) "; // 4

			if (clausulaGroup != null) {
				consulta += "," + clausulaGroup;
			}

			String consultaFrom = "FROM HistogramaEsgotoLigacao histograma "
					+ "INNER JOIN histograma.categoria categoria ";

			if ( filtro.getIndicadorTarifaCategoria() != null && filtro.getIndicadorTarifaCategoria().intValue() == ConstantesSistema.NAO ){
				 consultaFrom = "FROM HistogramaEsgotoLigacaoSemQuadra histograma "
					+ " INNER JOIN histograma.categoria categoria "
					+ " INNER JOIN histograma.subcategoria subcategoria ";
			}
			
			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			
			
			// Faixa Consumo Ligacao
			if (consumoFaixaLigacao != null) {
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao
						.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao
						.getNumeroFaixaFim());
			}
			
			

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if (consumoFaixaLigacaoIntervaloMedido != null
					&& consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				if ( filtro.getIndicadorTarifaCategoria() != null && filtro.getIndicadorTarifaCategoria().intValue() == ConstantesSistema.NAO ) {
					consultaFrom += "INNER JOIN histograma.localidadeEelo localidadeElo ";
				} else {
					consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";
				}
				
				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if (codigoSetorComercial != null) {
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);
			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if (numeroQuadra != null) {
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if (categoria != null) {
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			} else if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}
			
			// SubCategoria
			if (colecaoSubCategoria != null && !colecaoSubCategoria.isEmpty()) {
				consultaWhere += "AND subcategoria.id in (:subcate) ";
				parameters.put("subcate", colecaoSubCategoria);
			}

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (perfilImovel != null) {
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			} else if (colecaoPerfilImovel != null
					&& !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (esferaPoder != null) {
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			} else if (colecaoEsferaPoder != null
					&& !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if (situacaoLigacaoEsgoto != null) {
				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id = (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", situacaoLigacaoEsgoto
						.getId());

			} else if (colecaoSituacaoLigacaoEsgoto != null
					&& !colecaoSituacaoLigacaoEsgoto.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto",
						colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if (percentualLigacaoEsgoto != null) {

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						percentualLigacaoEsgoto);

			} else if (colecaoPercentualLigacaoEsgoto != null
					&& !colecaoPercentualLigacaoEsgoto.isEmpty()) {

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoEsgoto != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			String groupBy = " GROUP BY  categoria.id,  categoria.descricao ";
			String orderBy = "";
			if (clausulaGroup != null) {
				if ( filtro.getIndicadorTarifaCategoria().intValue() == ConstantesSistema.NAO ){
					groupBy = " GROUP BY   categoria.id , categoria.descricao, " + clausulaGroup;
					orderBy = " ORDER BY   categoria.id , categoria.descricao,  " + clausulaGroup;
				} else {
					groupBy += "," + clausulaGroup;	
					orderBy = " ORDER BY " + clausulaGroup + ",categoria.id";
				}
				
				
			} else {
				orderBy = " ORDER BY 1,2";
			}

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0600] Emitir Histograma de Esgoto - Total Geral
	 * 
	 * [SB0014] Selecionar por Indicador de Consumo [SB0015] Selecionar por
	 * Indicador de Medido [SB0016] Selecionar por Indicador de Poço [SB0017]
	 * Selecionar por Indicador de Volume Fixo de Água
	 * 
	 * @author Rafael Pinto
	 * @date 05/11/2007
	 * 
	 * @param FiltrarEmitirHistogramaEsgotoHelper
	 * 
	 * @return Object[]
	 * @throws ControladorException
	 */
	public Object[] pesquisarEmitirHistogramaEsgotoTotalGeral(
			FiltrarEmitirHistogramaEsgotoHelper filtro, Categoria categoria)
			throws ErroRepositorioException {

		Object[] retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();

		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro
				.getColecaoSituacaoLigacaoEsgoto();
		Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro
				.getColecaoPercentualLigacaoEsgoto();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
		ConsumoTarifa tarifa = filtro.getTarifa();
		ImovelPerfil perfilImovel = filtro.getPerfilImovel();
		EsferaPoder esferaPoder = filtro.getEsferaPoder();
		LigacaoEsgotoSituacao situacaoLigacaoEsgoto = filtro
				.getSituacaoLigacaoEsgoto();
		BigDecimal percentualLigacaoEsgoto = filtro
				.getPercentualLigacaoEsgoto();

		Short consumo = filtro.getConsumo();
		Short medicao = filtro.getMedicao();
		Short poco = filtro.getPoco();
		Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro
				.getConsumoFaixaLigacaoIntervaloMedido();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro
				.getConsumoFaixaLigacaoIntervaloNaoMedido();

		Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
		Integer numeroQuadra = filtro.getNumeroQuadra();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum(histograma.quantidadeLigacao)," // 0
					+ "sum(histograma.volumeFaturadoLigacao)," // 1
					+ "sum(histograma.valorFaturadoLigacao) "; // 2

			String consultaFrom = "FROM HistogramaEsgotoLigacao histograma "
					+ "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if (consumoFaixaLigacaoIntervaloMedido != null
					&& consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if (codigoSetorComercial != null) {
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if (numeroQuadra != null) {
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if (categoria != null) {
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			} else if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (perfilImovel != null) {
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			} else if (colecaoPerfilImovel != null
					&& !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (esferaPoder != null) {
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			} else if (colecaoEsferaPoder != null
					&& !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if (situacaoLigacaoEsgoto != null) {
				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id = (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", situacaoLigacaoEsgoto
						.getId());

			} else if (colecaoSituacaoLigacaoEsgoto != null
					&& !colecaoSituacaoLigacaoEsgoto.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto",
						colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if (percentualLigacaoEsgoto != null) {

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						percentualLigacaoEsgoto);

			} else if (colecaoPercentualLigacaoEsgoto != null
					&& !colecaoPercentualLigacaoEsgoto.isEmpty()) {

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoEsgoto != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0600] Emitir Histograma de Esgoto - Volume Faturado Ligacao Estimado
	 * ou Real
	 * 
	 * 
	 * @author Rafael Pinto
	 * @date 05/11/2007
	 * 
	 * @param FiltrarEmitirHistogramaEsgotoHelper
	 * 
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Integer pesquisarEmitirHistogramaEsgotoVolumeConsumo(
			FiltrarEmitirHistogramaEsgotoHelper filtro, Short consumo,
			Categoria categoria, Short medicao) throws ErroRepositorioException {

		Integer retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();

		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();

		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro
				.getColecaoSituacaoLigacaoEsgoto();
		Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro
				.getColecaoPercentualLigacaoEsgoto();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
		ConsumoTarifa tarifa = filtro.getTarifa();
		ImovelPerfil perfilImovel = filtro.getPerfilImovel();
		EsferaPoder esferaPoder = filtro.getEsferaPoder();
		LigacaoEsgotoSituacao situacaoLigacaoEsgoto = filtro
				.getSituacaoLigacaoEsgoto();
		BigDecimal percentualLigacaoEsgoto = filtro
				.getPercentualLigacaoEsgoto();

		Short poco = filtro.getPoco();
		Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

		ConsumoFaixaLigacao consumoFaixaLigacao = filtro
				.getConsumoFaixaLigacao();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro
				.getConsumoFaixaLigacaoIntervaloMedido();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro
				.getConsumoFaixaLigacaoIntervaloNaoMedido();

		Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
		Integer numeroQuadra = filtro.getNumeroQuadra();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum(histograma.volumeFaturadoLigacao) "; // 0

			String consultaFrom = "FROM HistogramaEsgotoLigacao histograma "
					+ "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if (consumoFaixaLigacao != null) {
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao
						.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao
						.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if (consumoFaixaLigacaoIntervaloMedido != null
					&& consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if (codigoSetorComercial != null) {
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if (numeroQuadra != null) {
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if (categoria != null) {
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			} else if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (perfilImovel != null) {
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			} else if (colecaoPerfilImovel != null
					&& !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (esferaPoder != null) {
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			} else if (colecaoEsferaPoder != null
					&& !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if (situacaoLigacaoEsgoto != null) {
				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id = (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", situacaoLigacaoEsgoto
						.getId());
			} else if (colecaoSituacaoLigacaoEsgoto != null
					&& !colecaoSituacaoLigacaoEsgoto.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto",
						colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if (percentualLigacaoEsgoto != null) {

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						percentualLigacaoEsgoto);

			} else if (colecaoPercentualLigacaoEsgoto != null
					&& !colecaoPercentualLigacaoEsgoto.isEmpty()) {

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoEsgoto != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retornoConsulta = (Integer) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0606] Emitir Histograma de Esgoto por Economia
	 * 
	 * @author Rafael Pinto
	 * @date 07/11/2007
	 * 
	 * @param FiltrarEmitirHistogramaEsgotoEconomiaHelper
	 * 
	 * @return Object[]
	 * @throws ControladorException
	 */
	public Object[] pesquisarEmitirHistogramaEsgotoEconomia(
			FiltrarEmitirHistogramaEsgotoEconomiaHelper filtro)
			throws ErroRepositorioException {

		Object[] retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();
		Integer tarifa = filtro.getTarifa();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
		Integer categoria = null;
		if (filtro.getCategoria() != null){
			categoria = filtro.getCategoria().getId();	
		}
//		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro
				.getColecaoSituacaoLigacaoEsgoto();
		Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro
				.getColecaoPercentualLigacaoEsgoto();

		BigDecimal percentualLigacaoEsgoto = filtro
				.getPercentualLigacaoEsgoto();

		Short consumo = filtro.getConsumo();
		Short medicao = filtro.getMedicao();
		Short poco = filtro.getPoco();
		Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

		ConsumoFaixaCategoria consumoFaixaCategoria = filtro
				.getConsumoFaixaCategoria();
		//Categoria categoria = filtro.getCategoria();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT categoria.id," // 0
					+ "categoria.descricao," // 1
					+ "sum(histograma.quantidadeEconomia)," // 2
					+ "sum(histograma.quantidadeConsumo * histograma.quantidadeEconomia)," // 3
					+ "sum(histograma.volumeFaturadoEconomia)," // 4
					+ "sum(histograma.valorFaturadoEconomia), " // 5
					+ "sum(histograma.quantidadeLigacao) ";// 6

			String consultaFrom = "FROM HistogramaEsgotoEconomia histograma "
					+ "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Categoria
			if (consumoFaixaCategoria != null) {
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaCategoria
						.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaCategoria
						.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if (categoria != null) {
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria);
			}
			
			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa);

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if (colecaoSituacaoLigacaoEsgoto != null
					&& !colecaoSituacaoLigacaoEsgoto.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto",
						colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if (percentualLigacaoEsgoto != null) {

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						percentualLigacaoEsgoto);

			} else if (colecaoPercentualLigacaoEsgoto != null
					&& !colecaoPercentualLigacaoEsgoto.isEmpty()) {

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoEsgoto != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			String groupBy = " GROUP BY  categoria.id,  categoria.descricao ";
			String orderBy = "ORDER BY 1,2";

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}
			retornoConsulta = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0606] Emitir Histograma de Esgoto por Economia
	 * 
	 * Monta as quebras que serão necessarias para o relatorio
	 * 
	 * @author Rafael Pinto
	 * @date 07/11/2007
	 * 
	 * @param FiltrarEmitirHistogramaEsgotoEconomiaHelper
	 * 
	 * @return Collection<Object[]>
	 * @throws ControladorException
	 */
	public Collection<Object[]> pesquisarEmitirHistogramaEsgotoEconomiaChavesAgrupadas(
			FiltrarEmitirHistogramaEsgotoEconomiaHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();
		Integer tarifa = filtro.getTarifa();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro
				.getColecaoSituacaoLigacaoEsgoto();

		Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro
				.getColecaoPercentualLigacaoEsgoto();

		BigDecimal percentualLigacaoEsgoto = filtro
				.getPercentualLigacaoEsgoto();

		Short consumo = filtro.getConsumo();
		Short medicao = filtro.getMedicao();
		Short poco = filtro.getPoco();
		Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

		String clausulaGroup = filtro.getTipoGroupBy();
		String clausulaOrder = filtro.getTipoOrderBy();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT " + clausulaGroup; // 0

			String consultaFrom = " FROM HistogramaEsgotoEconomia histograma "
					+ "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa);

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if (colecaoSituacaoLigacaoEsgoto != null
					&& !colecaoSituacaoLigacaoEsgoto.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto",
						colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if (percentualLigacaoEsgoto != null) {

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						percentualLigacaoEsgoto);

			} else if (colecaoPercentualLigacaoEsgoto != null
					&& !colecaoPercentualLigacaoEsgoto.isEmpty()) {

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoEsgoto != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			String groupBy = "GROUP BY " + clausulaGroup;
			String orderBy = " ORDER BY " + clausulaOrder;

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	// **********************************************************************

	/**
	 * Recupera as contas com estouro de consumo ou com baixo consumo [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006, 20/11/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasNaoFichaCompensacao(Integer idTipoConta,
			Integer idEmpresa, Integer numeroPaginas, Integer anoMesReferencia,
			Integer idFaturamentoGrupo,Integer anoMesReferenciaFaturamentoAntecipado,
			Integer imovelContaEnvio)throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta, " // 39
					+ "cli.clie_nncpf as cpf " // 40
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND "
					+ "contaImpressao.empr_id = :idEmpresa AND "

					+ "contaImpressao.cnti_vlconta <= :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			consulta += " AND cliCnt.clct_icnomeconta = :indicadorNomeConta "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).
							addScalar("cpf", Hibernate.STRING).							
							setInteger(
							"idTipoConta", idTipoConta).setInteger("idEmpresa",
							idEmpresa).setInteger("indicadorNomeConta",
							ConstantesSistema.INDICADOR_USO_ATIVO).setInteger(
							"idFaturamentoGrupoParms", idFaturamentoGrupo)
					.setBigDecimal("valorLimite",
							EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com estouro de consumo ou com baixo consumo [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006, 20/11/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasFichaCompensacao(Integer idTipoConta,
			Integer idEmpresa, Integer numeroPaginas, Integer anoMesReferencia,
			Integer idFaturamentoGrupo,
			Integer anoMesReferenciaFaturamentoAntecipado,
			Integer imovelContaEnvio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta " // 39
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND "
					+ "contaImpressao.empr_id = :idEmpresa AND "

					+ "contaImpressao.cnti_vlconta > :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			consulta += " AND cliCnt.clct_icnomeconta = :indicadorNomeConta "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).setInteger(
							"idTipoConta", idTipoConta).setInteger("idEmpresa",
							idEmpresa)
					.setInteger("indicadorNomeConta",ConstantesSistema.INDICADOR_USO_ATIVO)
					.setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo)
					.setBigDecimal("valorLimite",EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com entrega para o cliente responsável [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006, 20/11/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelNaoFichaCompensacao(
			Integer idTipoConta, Integer numeroPaginas,
			Integer anoMesReferencia, Integer idFaturamentoGrupo,
			Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado,
			Integer imovelContaEnvio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta " // 39
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupo AND "
					+ "contaImpressao.empr_id is null AND "

					+ "contaImpressao.cnti_vlconta <= :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// +"AND contaImpressao.cnti_icimpressao = 2 ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).setInteger(
							"idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setBigDecimal(
							"valorLimite",
							EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com entrega para o cliente responsável [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006, 20/11/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelFichaCompensacao(
			Integer idTipoConta, Integer numeroPaginas,
			Integer anoMesReferencia, Integer idFaturamentoGrupo,
			Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado,Integer imovelContaEnvio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta " // 39
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupo AND "
					+ "contaImpressao.empr_id is null AND "

					+ "contaImpressao.cnti_vlconta > :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).setInteger(
							"idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setBigDecimal(
							"valorLimite",
							EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa as contas do cliente responsável para todos os grupos de
	 * faturamento.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Pedro Alexandre,Vivianne Sousa
	 * @date 17/05/2007, 20/11/2007
	 * 
	 * @param idTipoConta
	 * @param numeroPaginas
	 * @param anoMesReferencia
	 * @param indicadorEmissaoExtratoFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelNaoFichaCompensacao(
			Integer idTipoConta, Integer numeroPaginas,
			Integer anoMesReferencia, Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado,Integer imovelContaEnvio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta " // 39
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "contaImpressao.empr_id is null AND "

					+ "contaImpressao.cnti_vlconta <= :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2 ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).setInteger(
							"idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setBigDecimal(
							"valorLimite",
							EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa as contas do cliente responsável para todos os grupos de
	 * faturamento.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Pedro Alexandre,Vivianne Sousa
	 * @date 17/05/2007, 20/11/2007
	 * 
	 * @param idTipoConta
	 * @param numeroPaginas
	 * @param anoMesReferencia
	 * @param indicadorEmissaoExtratoFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelFichaCompensacao(
			Integer idTipoConta, Integer numeroPaginas,
			Integer anoMesReferencia, Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado,Integer imovelContaEnvio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta " // 39
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "contaImpressao.empr_id is null AND "

					+ "contaImpressao.cnti_vlconta > :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ")";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			if(imovelContaEnvio != null){
				consulta += " AND imovel.icte_id <> " + imovelContaEnvio ;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).setInteger(
							"idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setBigDecimal(
							"valorLimite",
							EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0626] Gerar Resumo de Metas Acumulado no Mês (CAERN)
	 * 
	 * @author Sávio Luiz
	 * @data 28/11/2007
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarIdsContasDoImovelPorMesAnoReferencia(
			int anoMesReferencia, Integer idImovel)
			throws ErroRepositorioException {
		Collection<Conta> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cnta.id " + "from Conta cnta "
					+ "where cnta.referencia < :anoMesReferencia "
					+ "and cnta.imovel = :idImovel "
					+ "and (cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.NORMAL + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.RETIFICADA + " or "
					+ "cnta.debitoCreditoSituacaoAtual = "
					+ DebitoCreditoSituacao.INCLUIDA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * atualiza o sequencial de conta impressão e o indicador de
	 * fichaCompensação
	 * 
	 * @author Vivianne Sousa
	 * @date 02/12/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSequencialContaImpressaoFichaCompensacao(
			Map<Integer, Integer> mapAtualizaSequencial)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = "update gcom.faturamento.conta.ContaImpressao "
				+ "set cnti_nnsequencialimpressao =:sequencialConta ,cnti_tmultimaalteracao = :dataAtual, "
				+ "cnti_icfichacompensacao = :indicadorFichaCompensacao "
				+ "where cnta_id = :idConta ";
		if (mapAtualizaSequencial != null && !mapAtualizaSequencial.isEmpty()) {
			Iterator iteMapAtualizaSequencia = mapAtualizaSequencial.keySet()
					.iterator();

			try {
				while (iteMapAtualizaSequencia.hasNext()) {
					Integer idConta = (Integer) iteMapAtualizaSequencia.next();
					Integer sequencialConta = mapAtualizaSequencial
							.get(idConta);
					session.createQuery(consulta)
							.setInteger("idConta", idConta).setInteger(
									"sequencialConta", sequencialConta)
							.setShort("indicadorFichaCompensacao",
									ConstantesSistema.SIM).setDate("dataAtual",
									new Date()).executeUpdate();
				}
			} catch (HibernateException e) {
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				HibernateUtil.closeSession(session);

			}
		}

	}

	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação Author: Vivianne
	 * Sousa Data: 26/11/2007
	 * 
	 * @param idConta
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Conta pesquisarExistenciaContaComSituacaoAtual(Integer idConta)
			throws ErroRepositorioException {

		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct " + "from Conta ct "
					+ "inner join fetch ct.imovel imov "
					+ "inner join fetch imov.localidade loc "
					+ "inner join fetch ct.debitoCreditoSituacaoAtual "
					+ "where ct.id = :idConta ";
			// + "and ct.debitoCreditoSituacaoAtual.id IN(:normal, :incluida,
			// :retificada)";

			retorno = (Conta) session.createQuery(consulta).setInteger(
					"idConta", idConta)
			// .setInteger("normal",DebitoCreditoSituacao.NORMAL)
					// .setInteger("incluida",DebitoCreditoSituacao.INCLUIDA)
					// .setInteger("retificada",DebitoCreditoSituacao.RETIFICADA)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Boolean pesquisarExisteciaParcelamentoConta(Integer idConta)
			throws ErroRepositorioException {

		Boolean retorno = false;
		Collection pesquisa = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT dbcb " + "FROM DebitoCobrado as dbcb "
					+ "INNER JOIN dbcb.financiamentoTipo as fntp "
					+ "WHERE dbcb.conta.id = :idConta "
					+ "and (fntp.id = :parcAgua or "
					+ "fntp.id = :parcEsgoto or fntp.id = :parcServico or "
					+ "fntp.id = :jurosParc)";

			pesquisa = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).setInteger("parcAgua",
					FinanciamentoTipo.PARCELAMENTO_AGUA.intValue()).setInteger(
					"parcEsgoto",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO.intValue())
					.setInteger("parcServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO.intValue())
					.setInteger("jurosParc",
							FinanciamentoTipo.JUROS_PARCELAMENTO.intValue())
					.list();

			if (pesquisa != null && !pesquisa.isEmpty()) {
				retorno = true;
			} else {
				retorno = false;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto CAER
	 * 
	 * @author Raphael Rossiter
	 * 
	 * @param idConsumoTarifa
	 * @return ConsumoTarifaVigencia
	 * @throws ErroRepositorioException
	 */
	public ConsumoTarifaVigencia pesquisarConsumoTarifaVigenciaEmVigor(
			Integer idConsumoTarifa) throws ErroRepositorioException {

		ConsumoTarifaVigencia retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT ctv "
					+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
					+ "INNER JOIN ctv.consumoTarifa ct "
					+ "where ct.id = :idConsumoTarifa "
					+ "ORDER BY ctv.dataVigencia DESC";

			retorno = (ConsumoTarifaVigencia) session.createQuery(consulta)
					.setInteger("idConsumoTarifa", idConsumoTarifa)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00730] Gerar Relatório de Imóveis com Faturas Recentes em Dia e
	 * Faturas Antigas em Atraso
	 * 
	 * @author Rafael Pinto
	 * @date 10/01/2008
	 * 
	 * @param idImovel
	 * 
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarQuantidadeFaturasValorFaturas(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT count(*) as quantidade,sum(cnta_vlagua + cnta_vlesgoto + cnta_vldebitos - cnta_vlcreditos) as valor "
					+ "FROM faturamento.conta contaAtual "
					+ "WHERE contaAtual.dcst_idatual IN ( 0,1,2 ) "
					+ "AND contaAtual.imov_id = :idImovel "
					+ "AND NOT EXISTS ( "
					+ "SELECT pgto.cnta_id FROM arrecadacao.pagamento pgto "
					+ "WHERE contaAtual.cnta_id = pgto.cnta_id )";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"quantidade", Hibernate.INTEGER).addScalar("valor",
					Hibernate.BIG_DECIMAL).setInteger("idImovel", idImovel)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00730] Gerar Relatório de Imóveis com Faturas Recentes em Dia e
	 * Faturas Antigas em Atraso
	 * 
	 * @author Rafael Pinto
	 * @date 10/01/2008
	 * 
	 * @param idImovel
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarReferenciaAntigaContaSemPagamento(Integer idImovel)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT min(contaAntigo.cnta_amreferenciaconta) as referencia "
					+ "FROM faturamento.conta contaAntigo "
					+ "WHERE contaAntigo.dcst_idatual IN ( 0,1,2 ) "
					+ "AND contaAntigo.imov_id = :idImovel "
					+ "AND NOT EXISTS ( "
					+ "SELECT pgto.cnta_id FROM arrecadacao.pagamento pgto "
					+ "WHERE contaAntigo.cnta_id = pgto.cnta_id ) "
					+ "ORDER BY 1";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar(
					"referencia", Hibernate.INTEGER).setInteger("idImovel",
					idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00730] Gerar Relatório de Imóveis com Faturas Recentes em Dia e
	 * Faturas Antigas em Atraso
	 * 
	 * @author Rafael Pinto
	 * @date 10/01/2008
	 * 
	 * @param idImovel
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarReferenciaAtualContaSemPagamento(Integer idImovel)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT max(contaAtual.cnta_amreferenciaconta) as referencia "
					+ "FROM faturamento.conta contaAtual "
					+ "WHERE contaAtual.dcst_idatual IN ( 0,1,2 ) "
					+ "AND contaAtual.imov_id = :idImovel "
					+ "AND NOT EXISTS ( "
					+ "SELECT pgto.cnta_id FROM arrecadacao.pagamento pgto "
					+ "WHERE contaAtual.cnta_id = pgto.cnta_id ) "
					+ "ORDER BY 1";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar(
					"referencia", Hibernate.INTEGER).setInteger("idImovel",
					idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela Bônus
	 * 
	 * Retorna id e data vencimento da conta que tem serviço de parcelamento
	 * cobrado DEBITO_COBRADO com CNTA_ID da tabela CONTA e FNTP_ID com valor
	 * correspodente a parcelamento de agua, esgoto ou serviços da tabela
	 * FINANCIAMENTO_TIPO
	 * 
	 * @author Vivianne Sousa
	 * @date 28/12/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaImovel(Integer idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT distinct(cnta.cnta_id) as idConta, "
					+ " cnta.cnta_dtvencimentoconta as dtVencimentoConta "
					+ "FROM faturamento.debito_cobrado dbco "
					+ "INNER JOIN faturamento.conta cnta on dbco.cnta_id= cnta.cnta_id "
					+ "WHERE cnta.imov_id = :idImovel "
					+ " AND cnta.cnta_amreferenciaconta = :anoMesReferencia "
					+ " AND(dbco.fntp_id = :parcelamentoAgua "
					+ "     OR dbco.fntp_id = :parcelamentoEsgoto "
					+ "     OR dbco.fntp_id = :parcelamentoServico) "
					+ " AND cnta.dcst_idatual IN(:normal, :incluida, :retificada) ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"idConta", Hibernate.INTEGER).addScalar(
					"dtVencimentoConta", Hibernate.DATE).setInteger("idImovel",
					idImovel).setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("parcelamentoAgua",
							FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger(
							"parcelamentoEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
							"parcelamentoServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO).setInteger(
							"normal", DebitoCreditoSituacao.NORMAL).setInteger(
							"incluida", DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * Recupera o percentual alternativo e o numero de consumo do percentual
	 * alternativo para o imóvel informado.
	 * 
	 * @author Vivianne Sousa
	 * @date 24/01/2008
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterPercentualAlternativoLigacaoEsgotoImovel(
			Integer idImovel) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select le.percentualAlternativo, le.numeroConsumoPercentualAlternativo "
					+ "from LigacaoEsgoto le " + "where le.id = :imovelId ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"imovelId", idImovel.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação Author: Vivianne
	 * Sousa Data: 28/01/2008
	 * 
	 * @param idConta
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public ContaHistorico pesquisarExistenciaContaHistorico(Integer idConta)
			throws ErroRepositorioException {

		ContaHistorico retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct " + "from ContaHistorico ct "
					+ "inner join fetch ct.imovel imov "
					+ "inner join fetch imov.localidade loc "
					+ "inner join fetch ct.debitoCreditoSituacaoAtual "
					+ "where ct.id = :idConta ";

			retorno = (ContaHistorico) session.createQuery(consulta)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * 
	 * obtem imovel, localidade e conta atraves do id da conta
	 * 
	 * @author Vivianne Sousa
	 * @date 29/01/2008
	 * 
	 * @param idConta
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Conta obterImovelLocalidadeConta(Integer idConta)
			throws ErroRepositorioException {

		Conta retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT conta " + "FROM Conta conta "
					+ "INNER JOIN fetch conta.imovel imov "
					+ "INNER JOIN fetch conta.localidade loc "
					+ "WHERE conta.id = :idConta ";

			retorno = (Conta) session.createQuery(consulta).setInteger(
					"idConta", idConta.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * 
	 * obtem imovel, localidade e contaHistorico atraves do id da conta
	 * historico
	 * 
	 * @author Vivianne Sousa
	 * @date 29/01/2008
	 * 
	 * @param idConta
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public ContaHistorico obterImovelLocalidadeContaHistorico(Integer idConta)
			throws ErroRepositorioException {

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT conta " + "FROM ContaHistorico conta "
					+ "INNER JOIN fetch conta.imovel imov "
					+ "INNER JOIN fetch conta.localidade loc "
					+ "WHERE conta.id = :idConta ";

			retorno = (ContaHistorico) session.createQuery(consulta)
					.setInteger("idConta", idConta.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0737] - Atualiza Quantidade de Parcela Paga Consecutiva e Parcela
	 * Bônus
	 * 
	 * @author Vivianne Sousa
	 * @date 07/02/2008
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void adicionaUmNNParcelaBonusDebitoAcobrar(Integer idParcelamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarDebitoAcobrar;

		try {
			atualizarDebitoAcobrar = "update gcom.faturamento.debito.DebitoACobrar "
					+ " set dbac_tmultimaalteracao = :dataAtual, "
					+ "    dbac_nnparcelabonus = "
					+ "       CASE WHEN (dbac_nnparcelabonus is not null) THEN "
					+ "         (dbac_nnparcelabonus + 1) "
					+ "       ELSE "
					+ "         1 "
					+ "       END "
					+ " where parc_id = :idParcelamento";

			session.createQuery(atualizarDebitoAcobrar).setInteger(
					"idParcelamento", idParcelamento.intValue()).setTimestamp(
					"dataAtual", new Date()).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0737] - Atualiza Quantidade de Parcela Paga Consecutiva e Parcela
	 * Bônus
	 * 
	 * @author Vivianne Sousa
	 * @date 07/02/2008
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void adicionaUmNNParcelaBonusCreditoARealizar(Integer idParcelamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarCreditoARealizar;

		try {
			atualizarCreditoARealizar = "update gcom.faturamento.credito.CreditoARealizar "
					+ " set crar_tmultimaalteracao = :dataAtual, "
					+ "    crar_nnparcelabonus = "
					+ "       CASE WHEN (crar_nnparcelabonus is not null) THEN "
					+ "         (crar_nnparcelabonus + 1) "
					+ "       ELSE "
					+ "         1 "
					+ "       END "
					+ " where parc_id = :idParcelamento";

			session.createQuery(atualizarCreditoARealizar).setInteger(
					"idParcelamento", idParcelamento.intValue()).setTimestamp(
					"dataAtual", new Date()).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0216] - Calcular Acréscimos por Impontualidade
	 * 
	 * @author Raphael Rossiter
	 * @date 12/02/2008
	 * 
	 * @param idConta
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaParaAcrescimoPorImpontualidade(Integer idConta)
			throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT imov.indicadorDebitoConta, muni.id "
					+ "FROM Conta cnta " + "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN imov.logradouroBairro lgbr "
					+ "INNER JOIN lgbr.bairro bair "
					+ "INNER JOIN bair.municipio muni "
					+ "WHERE cnta.id = :idConta ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", idConta.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	// linha 15

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de guia de
	 * devolução acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual e lançamento item contábil.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorGuiaDevolucaoPorLancamentoItemContabil(
			int anoMesReferencia, Integer idLocalidade,
			Integer idSituacaoAtual, Integer idLancamentoItemContabil)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select "
					+ "     gdev.imov_id as col_0, "
					+ "	  sum(gdev.gdev_vldevolucao) as col_1 "
					+ "   from "
					+ "	  arrecadacao.guia_devolucao gdev "
					+ "   where "
					+ "	  gdev.loca_id= :idLocalidade "
					+ "	  and gdev.gdev_amreferenciacontabil= :anoMesReferencia "
					+ "	  and gdev.dcst_idatual= :idSituacaoAtual "
					+ "	  and gdev.lict_id=:idLancamentoItemContabil "
					+ "   group by " + "	  gdev.imov_id ";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.INTEGER)
					.addScalar("col_1", Hibernate.BIG_DECIMAL).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idLancamentoItemContabil",
							idLancamentoItemContabil).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	// linha 38
	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de guia de
	 * devolução acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual, a situação anterior e lançamento item contábil.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorGuiaDevolucaoPorLancamentoItemContabil(
			int anoMesReferencia, Integer idLocalidade,
			Integer idSituacaoAtual, Integer idSituacaoAnterior,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  gdev.imov_id as col_0, "
					+ "  sum(gdev.gdev_vldevolucao) as col_1 "
					+ " from "
					+ "  arrecadacao.guia_devolucao gdev "
					+ " where "
					+ "  gdev.loca_id= :idLocalidade "
					+ "  and gdev.gdev_amreferenciacontabil= :anoMesReferencia "
					+ "  and ( " + "   gdev.dcst_idatual= :idSituacaoAtual "
					+ "   or gdev.dcst_idanterior= :idSituacaoAnterior ) "
					+ "  and gdev.lict_id= :idLancamentoItemContabil "
					+ " group by " + "  gdev.imov_id";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.INTEGER)
					.addScalar("col_1", Hibernate.BIG_DECIMAL).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idLancamentoItemContabil",
							idLancamentoItemContabil).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	// linha 01 e 02
	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 01 Retorna o valor de água
	 * acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual a normal
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no Hibernate
	 */
	public Object[] acumularValorAguaEsgotoPorSituacaoConta(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idSituacaoAtual, int idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select " + "  sum(ctcg.ctcg_vlagua) as col_0, "
					+ "  sum(ctcg.ctcg_vlesgoto) as col_1  " + "  from "
					+ "   faturamento.conta_categoria ctcg " + "  inner join "
					+ "   faturamento.conta cnta on ctcg.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciaconta= :anoMesReferencia "
					+ "   and cnta.loca_id= :idLocalidade "
					+ "   and ctcg.catg_id= :idCategoria " + "   and ( "
					+ "    cnta.dcst_idatual= :idSituacaoAtual  "
					+ "    or cnta.dcst_idanterior= :idSituacaoAnterior "
					+ "   ) ";

			// executa o hql
			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).addScalar("col_1",
					Hibernate.BIG_DECIMAL).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * Pesquisa os valores de curto e longo prazo dos débitos a cobrar da
	 * localidade informada por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 06/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoFinanciamento
	 * @param idSituacaoAnterior
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamento(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoFinanciamento, int idLancamentoItemContabil,
			int idSituacaoAtual, int idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "SELECT  "
					+ "SUM( "
					+ "CASE WHEN ( dbac.dbac_nnprestacaodebito < 13 ) "
					+ "THEN dbacCat.dbcg_vlcategoria "
					+ "ELSE "
					+ "trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * 12 "
					+ "END "
					+ ") as valorCurtoPrazo, "
					+ "SUM( "
					+ "CASE WHEN ( dbac.dbac_nnprestacaodebito  < 13 ) "
					+ "THEN 0.00 "
					+ "ELSE "
					+ "dbacCat.dbcg_vlcategoria - ( trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito ), 2 ) * ( 12 ) ) "
					+ "END "
					+ ") as valorLongoPrazo "
					+ "FROM cadastro.localidade loca "
					+ "INNER JOIN faturamento.debito_a_cobrar dbac on dbac.loca_id = loca.loca_id "
					+ "INNER JOIN faturamento.deb_a_cobrar_catg dbacCat on dbacCat.dbac_id = dbac.dbac_id "
					+ "WHERE loca.loca_id = :idLocalidade "
					+ "and dbac.dbac_amreferenciacontabil = :anoMesReferencia "
					+ "and (dbac.dcst_idatual = :idSituacaoAtual or dbac.dcst_idanterior = :idSituacaoAnterior) "
					+ "and dbacCat.catg_id = :idCategoria "
					+ "and dbac.fntp_id = :idTipoFinanciamento "
					+ "and dbac.lict_id = :idLancamentoItemContabil";

			// executa o hql
			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"valorCurtoPrazo", Hibernate.BIG_DECIMAL).addScalar(
					"valorLongoPrazo", Hibernate.BIG_DECIMAL).setInteger(
					"idLocalidade", idLocalidade).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idSituacaoAtual", idSituacaoAtual).setInteger(
					"idSituacaoAnterior", idSituacaoAnterior).setInteger(
					"idCategoria", idCategoria).setInteger(
					"idTipoFinanciamento", idTipoFinanciamento).setInteger(
					"idLancamentoItemContabil", idLancamentoItemContabil)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 10 Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a incluída e o tipo de financiamento igual a serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoServicoSituacaoIncluida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria a coleção que vai armazenar a coleção de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum(dccg.dccg_vlcategoria) as col_0 "
					+ " from faturamento.debito_cobrado_categoria dccg "
					+ " inner join faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " where  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ " and cnta.loca_id= :idLocalidade "
					+ " and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior) "
					+ " and dbcb.lict_id= :idLancamentoItemContabil "
					+ " and dccg.catg_id= :idCategoria "
					+ " and dbcb.fntp_id in (:idFinanciamentoTipo) ";
			
			Collection<Integer> colecaoFinanciamentoTipos = new ArrayList<Integer>();
			
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.SERVICO_NORMAL);
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.PARCELAMENTO_AGUA);
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.PARCELAMENTO_ESGOTO);
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.PARCELAMENTO_SERVICO);
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_AGUA);
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_ESGOTO);
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_SERVICO);
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.JUROS_PARCELAMENTO);
			colecaoFinanciamentoTipos.add(FinanciamentoTipo.ENTRADA_PARCELAMENTO);
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("col_0", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLancamentoItemContabil", idLancamentoItemContabil).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria", idCategoria).
				setInteger("idSituacaoAtual", DebitoCreditoSituacao.INCLUIDA).
				setInteger("idSituacaoAnterior",DebitoCreditoSituacao.INCLUIDA).
				setParameterList("idFinanciamentoTipo",colecaoFinanciamentoTipos).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabilRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem,Integer idLancamentoItemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(crcg1.crcg_vlcategoria,0) - coalesce(crcg4.crcg_vlcategoria,0)) as valorIncluidoCreditoRealizado"
				+ " from faturamento.conta cnta1 "
				+ " inner join faturamento.credito_realizado crrz1 on crrz1.cnta_id = cnta1.cnta_id and crrz1.lict_id = :idLancamentoItemContabil and crrz1.crog_id in (:idsCreditoOrigem)"
				+ " inner join faturamento.cred_realizado_catg crcg1  on crcg1.crrz_id = crrz1.crrz_id and crcg1.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta4 on (cnta4.imov_id = cnta1.imov_id and cnta4.cnta_amreferenciacontabil = :anoMesReferencia " 
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao )" 
				+ " left join faturamento.credito_realizado crrz4 on crrz4.cnta_id = cnta4.cnta_id and crrz4.lict_id = crrz1.lict_id and crrz4.crog_id = crrz1.crog_id "
				+ " and crrz4.crti_id = crrz1.crti_id and crrz4.crrz_amcobrancacredito = crrz1.crrz_amcobrancacredito "
				+ " left join faturamento.cred_realizado_catg crcg4 on crcg4.crrz_id = crrz4.crrz_id and crcg4.catg_id= crcg1.catg_id "
				+ " where cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta" 
				+ " and cnta1.loca_id = :idLocalidade "
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada)" 
				+ " and coalesce(crcg1.crcg_vlcategoria,0) > coalesce(crcg4.crcg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorIncluidoCreditoRealizado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setInteger("idLancamentoItemContabil",idLancamentoItemContabil).
				setParameterList("idsCreditoOrigem", idsCreditoOrigem).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	// linha 34
	/**
	 * Retorna o valor de categoria de credito realizado acumulado, de acordo
	 * com o ano/mês de referência, a situação atual, o item de lançamento
	 * contábil e a origem do crédito informados.
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Rafael Pinto
	 * @date 21/07/2011
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabilCanceladoPorRetificacao(
			int anoMesReferencia, 
			int idLocalidade, 
			int idCategoria,
			Integer[] idsCreditoOrigem,
			Integer idLancamentoItemContabil) 
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		String consulta;
		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select sum( coalesce(crcg4.crcg_vlcategoria,0) - coalesce(crcg1.crcg_vlcategoria,0)) as valorCanceladoCreditoRealizado"
				+ " from faturamento.conta cnta4 "
				+ " inner join faturamento.credito_realizado crrz4 on crrz4.cnta_id = cnta4.cnta_id and crrz4.lict_id = :idLancamentoItemContabil and crrz4.crog_id in (:idsCreditoOrigem)"
				+ " inner join faturamento.cred_realizado_catg crcg4  on crcg4.crrz_id = crrz4.crrz_id and crcg4.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta1 on (cnta1.imov_id = cnta4.imov_id and cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta " 
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada) )" 
				+ " left join faturamento.credito_realizado crrz1 on crrz1.cnta_id = cnta1.cnta_id and crrz1.lict_id = crrz4.lict_id and crrz1.crog_id = crrz4.crog_id "
				+ " and crrz1.crti_id = crrz4.crti_id and crrz1.crrz_amcobrancacredito = crrz4.crrz_amcobrancacredito "				
				+ " left join faturamento.cred_realizado_catg crcg1  on crcg1.crrz_id = crrz1.crrz_id and crcg1.catg_id= crcg4.catg_id "
				+ " where cnta4.cnta_amreferenciacontabil = :anoMesReferencia "
				+ " and cnta4.loca_id = :idLocalidade "
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao" 
				+ " and coalesce(crcg4.crcg_vlcategoria,0) > coalesce(crcg1.crcg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorCanceladoCreditoRealizado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setInteger("idLancamentoItemContabil",idLancamentoItemContabil).
				setParameterList("idsCreditoOrigem", idsCreditoOrigem).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * Pesquisa os valores de curto e longo prazo dos débitos a cobrar da
	 * localidade informada por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 06/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoFinanciamento
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamento(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoFinanciamento, int idLancamentoItemContabil,
			int idSituacaoAtual) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "SELECT  "
					+ "SUM( "
					+ "CASE WHEN ( ( dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas ) < 13 ) "
					+ "THEN dbacCat.dbcg_vlcategoria - (trunc( (dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * dbac.dbac_nnprestacaocobradas) "
					+ "ELSE "
					+ "trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * 12 "
					+ "END "
					+ ") as valorCurtoPrazo, "
					+ "SUM( "
					+ "CASE WHEN ( ( dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas ) < 13 ) "
					+ "THEN 0.00 "
					+ "ELSE "
					+ "dbacCat.dbcg_vlcategoria - ( trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito ), 2 ) * ( 12 + dbac.dbac_nnprestacaocobradas ) ) "
					+ "END "
					+ ") as valorLongoPrazo "
					+ "FROM cadastro.localidade loca "
					+ "INNER JOIN faturamento.debito_a_cobrar dbac	on dbac.loca_id = loca.loca_id "
					+ "INNER JOIN faturamento.deb_a_cobrar_catg dbacCat on dbacCat.dbac_id = dbac.dbac_id "
					+ "WHERE loca.loca_id = :idLocalidade "
					+ "and dbac.dbac_amreferenciacontabil = :anoMesReferencia "
					+ "and dbac.dcst_idatual = :idSituacaoAtual "
					+ "and dbacCat.catg_id = :idCategoria "
					+ "and dbac.fntp_id = :idTipoFinanciamento "
					+ "and dbac.lict_id = :idLancamentoItemContabil";

			// executa o hql
			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"valorCurtoPrazo", Hibernate.BIG_DECIMAL).addScalar(
					"valorLongoPrazo", Hibernate.BIG_DECIMAL).setInteger(
					"idLocalidade", idLocalidade).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idSituacaoAtual", idSituacaoAtual).setInteger(
					"idCategoria", idCategoria).setInteger(
					"idTipoFinanciamento", idTipoFinanciamento).setInteger(
					"idLancamentoItemContabil", idLancamentoItemContabil)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Acumula o valor das guias de pagamento por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 07/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoFinanciamento
	 * @param idItemContabil
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorGuiaPagamentoPorTipoFinanciamento(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int[] idTipoFinanciamento, int idItemContabil, int idSituacaoAtual)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ " sum(gpcg.gpcg_vlcategoria) as col_0 "
					+ " from "
					+ " faturamento.guia_pagamento_categoria gpcg  "
					+ " inner join faturamento.guia_pagamento gpag on gpcg.gpag_id=gpag.gpag_id "
					+ " where "
					+ " gpag.gpag_amreferenciacontabil= :anoMesReferencia "
					+ " and gpag.loca_id= :idLocalidade "
					+ " and gpcg.catg_id= :idCategoria "
					+ " and gpag.fntp_id = :idTipoFinanciamento "
					+ " and gpag.lict_id= :idItemContabil "
					+ " and gpag.dcst_idatual= :idSituacaoAtual ";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("col_0", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("idTipoFinanciamento",idTipoFinanciamento[0]).
				setInteger("idItemContabil",idItemContabil).
				setInteger("idSituacaoAtual",idSituacaoAtual).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - acumula o valor de
	 * débito cobrado para situação de conta igual a cancelada por retificação
	 * de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaCanceladaPorRetificacao(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Collection<Integer> tipoFinanciamento, Integer itemContabil)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			
			consulta = "select sum( coalesce(dccg4.dccg_vlcategoria,0) - coalesce(dccg1.dccg_vlcategoria,0)) as valorCanceladoDebitoCobrado"
				+ " from faturamento.conta cnta4 "
				+ " inner join faturamento.debito_cobrado dbcb4 on dbcb4.cnta_id = cnta4.cnta_id and dbcb4.fntp_id in (:tipoFinanciamento) and dbcb4.lict_id= :itemContabil" 
				+ " inner join faturamento.debito_cobrado_categoria dccg4 on dccg4.dbcb_id = dbcb4.dbcb_id and dccg4.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta1 on (cnta1.imov_id = cnta4.imov_id and cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta " 
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada) )" 
				+ " left join faturamento.debito_cobrado dbcb1 on dbcb1.cnta_id = cnta1.cnta_id and dbcb1.fntp_id = dbcb4.fntp_id and dbcb1.lict_id= dbcb4.lict_id "
				+ " and dbcb1.dbcb_amcobrancadebito = dbcb4.dbcb_amcobrancadebito and dbcb1.dbcb_amreferenciadebito = dbcb4.dbcb_amreferenciadebito and dbcb1.dbtp_id = dbcb4.dbtp_id "
				+ " left join faturamento.debito_cobrado_categoria dccg1 on dccg1.dbcb_id = dbcb1.dbcb_id and dccg1.catg_id= dccg4.catg_id "
				+ " where cnta4.cnta_amreferenciacontabil = :anoMesReferencia " 
				+ " and cnta4.loca_id = :idLocalidade "
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao " 
				+ " and coalesce(dccg4.dccg_vlcategoria,0) > coalesce(dccg1.dccg_vlcategoria,0) " ;

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorCanceladoDebitoCobrado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setParameterList("tipoFinanciamento",tipoFinanciamento).
				setInteger("itemContabil", itemContabil).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao",DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setInteger("debitoCreditoSituacaoRetificada",DebitoCreditoSituacao.RETIFICADA).
				uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - acumula o valor de
	 * débito cobrado para situação de conta igual a retificada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Collection<Integer> tipoFinanciamento, Integer itemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			
			consulta = "select sum( coalesce(dccg1.dccg_vlcategoria,0) - coalesce(dccg4.dccg_vlcategoria,0)) as valorIncluidoDebitoCobrado"
				+ " from faturamento.conta cnta1"
				+ " inner join faturamento.debito_cobrado dbcb1 on dbcb1.cnta_id = cnta1.cnta_id and dbcb1.fntp_id in (:tipoFinanciamento) and dbcb1.lict_id= :itemContabil" 
				+ " inner join faturamento.debito_cobrado_categoria dccg1 on dccg1.dbcb_id = dbcb1.dbcb_id and dccg1.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta4 on (cnta4.imov_id = cnta1.imov_id and cnta4.cnta_amreferenciacontabil = :anoMesReferencia " 
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao )" 
				+ " left join faturamento.debito_cobrado dbcb4 on dbcb4.cnta_id = cnta4.cnta_id and dbcb4.fntp_id = dbcb1.fntp_id and dbcb4.lict_id= dbcb1.lict_id " 
				+ " and dbcb4.dbcb_amcobrancadebito = dbcb1.dbcb_amcobrancadebito and dbcb4.dbcb_amreferenciadebito = dbcb1.dbcb_amreferenciadebito and dbcb4.dbtp_id = dbcb1.dbtp_id "
				+ " left join faturamento.debito_cobrado_categoria dccg4 on dccg4.dbcb_id = dbcb4.dbcb_id and dccg4.catg_id= dccg1.catg_id"
				+ " where cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta "
				+ " and cnta1.loca_id = :idLocalidade "
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada) "
				+ " and coalesce(dccg1.dccg_vlcategoria,0) > coalesce(dccg4.dccg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorIncluidoDebitoCobrado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setParameterList("tipoFinanciamento",tipoFinanciamento).
				setInteger("itemContabil", itemContabil).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao",DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setInteger("debitoCreditoSituacaoRetificada",DebitoCreditoSituacao.RETIFICADA).
				uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, tipo de financiamento e pelo lançamento item contábil com
	 * o ano/mês de referência da baixa contábil da conta preenchido
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsFinanciamentoTipo, Integer idSituacaoAtual,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1, "
					+ "  lict.lict_nnsequenciaimpressao as col_2 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on dbcb.lict_id=lict.lict_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  "
					+ "  and dccg .catg_id= :idCategoria  "
					+ "  and dbcb.lict_id= :idLancamentoItemContabil  "
					+ "  and cnta.dcst_idatual= :idSituacaoAtual "
					+ "  and (dbcb.fntp_id in (:idsFinanciamentoTipo))  "
					+ "  and (cnta.cnta_amreferenciabaixacontabil is not null) "
					+ " group by " + "  lict.lict_nnsequenciaimpressao ";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL).addScalar("col_2", Hibernate.SHORT)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsFinanciamentoTipo",
							idsFinanciamentoTipo).setInteger(
							"idLancamentoItemContabil",
							idLancamentoItemContabil).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, o item de financiamento contábil e a origem do crédito
	 * informados e com o ano/mês da baixa contábil preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoAtual,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_1 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg  "
					+ "  inner join  faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
					+ "  inner join  faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciaconta=:anoMesReferencia "
					+ "   and crrz.loca_id=:idLocalidade  "
					+ "   and cnta.dcst_idatual=:idSituacaoAtual "
					+ "   and crcg.catg_id=:idCategoria  "
					+ "   and crrz.lict_id=:idLancamentoItemContabil "
					+ "   and (crrz.crog_id in (:idsCreditoOrigem)) "
					+ "   and (cnta.cnta_amreferenciabaixacontabil is not null) ";

			BigDecimal valor = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_1", Hibernate.BIG_DECIMAL).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.setInteger("idLancamentoItemContabil",
							idLancamentoItemContabil).uniqueResult();

			if (valor != null && valor.compareTo(BigDecimal.ZERO) == 1) {
				retorno = new ResumoFaturamento();
				retorno.setValorItemFaturamento(valor);
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, tipo de financiamento e pelo lançamento item contábil com
	 * o ano/mês de referência da baixa contábil da conta não preenchido
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsFinanciamentoTipo, Integer idSituacaoAtual,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1, "
					+ "  lict.lict_nnsequenciaimpressao as col_2 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on dbcb.lict_id=lict.lict_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  "
					+ "  and cnta.dcst_idatual= :idSituacaoAtual "
					+ "  and dccg.catg_id= :idCategoria  "
					+ "  and dbcb.lict_id= :idLancamentoItemContabil  "
					+ "  and (dbcb.fntp_id in (:idsFinanciamentoTipo))  "
					+ "  and (cnta.cnta_amreferenciabaixacontabil is null) "
					+ " group by " + "  lict.lict_nnsequenciaimpressao ";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL).addScalar("col_2", Hibernate.SHORT)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsFinanciamentoTipo",
							idsFinanciamentoTipo).setInteger(
							"idLancamentoItemContabil",
							idLancamentoItemContabil).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, o item de financiamento contábil e a origem do crédito
	 * informados e com o ano/mês da baixa contábil não preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoAtual,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_1 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg  "
					+ "  inner join  faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
					+ "  inner join  faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciaconta=:anoMesReferencia "
					+ "   and crrz.loca_id=:idLocalidade  "
					+ "   and crcg.catg_id=:idCategoria  "
					+ "   and crrz.lict_id=:idLancamentoItemContabil "
					+ "   and cnta.dcst_idatual=:idSituacaoAtual "
					+ "   and (crrz.crog_id in (:idsCreditoOrigem)) "
					+ "   and (cnta.cnta_amreferenciabaixacontabil is null) ";

			// executa o hql
			BigDecimal valor = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_1", Hibernate.BIG_DECIMAL).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.setInteger("idLancamentoItemContabil",
							idLancamentoItemContabil).uniqueResult();

			// caso o valor não esteja nulo e seja maior que zero
			if (valor != null && valor.compareTo(BigDecimal.ZERO) == 1) {
				retorno = new ResumoFaturamento();
				retorno.setValorItemFaturamento(valor);
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * Acumula o valor das guias de pagamentos por tipo de financiamento
	 * agrupando por lançamento item contábil.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 11/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorGuiaPagamentoPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idSituacaoAtual, int idSituacaoAnterior, int idFinanciamentoTipo)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar o resultado da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select "
					+ "  sum(gpcg.gpcg_vlcategoria) as col_1, "
					+ "  lict.lict_nnsequenciaimpressao as col_2, "
					+ "  lict.lict_id as col_3 "
					+ " from "
					+ "  faturamento.guia_pagamento_categoria gpcg "
					+ " inner join "
					+ "  faturamento.guia_pagamento gpag on gpcg.gpag_id=gpag.gpag_id "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on gpag.lict_id=lict.lict_id "
					+ " where "
					+ "  gpag.gpag_amreferenciacontabil= :anoMesReferencia "
					+ "  and gpag.loca_id= :idLocalidade  "
					+ "  and gpcg.catg_id= :idCategoria  "
					+ "  and (gpag.dcst_idatual= :idSituacaoAtual or gpag.dcst_idanterior= :idSituacaoAnterior) "
					+ "  and gpag.fntp_id= :idFinanciamentoTipo "
					+ " group by " + "  lict.lict_nnsequenciaimpressao , "
					+ "  lict.lict_id ";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL).addScalar("col_2", Hibernate.SHORT)
					.addScalar("col_3", Hibernate.INTEGER).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento pesquisada
		return retorno;
	}

	// linha 27
	/**
	 * Acumula o valor de água por situação da conta
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 11/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorAguaPorSituacaoConta(int anoMesReferencia,
			int idLocalidade, int idCategoria, int idSituacaoAtual)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select " + "  sum(ctcg.ctcg_vlagua) as col_0 "
					+ "  from " + "   faturamento.conta_categoria ctcg "
					+ "  inner join "
					+ "   faturamento.conta cnta on ctcg.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnta.loca_id= :idLocalidade "
					+ "   and ctcg.catg_id= :idCategoria "
					+ "   and cnta.dcst_idatual= :idSituacaoAtual  ";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Acumula o valor de água por situação da conta
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 11/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorAguaPorSituacaoConta(int anoMesReferencia,
			int idLocalidade, int idCategoria, int idSituacaoAtual,
			int idSituacaoAnterior) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(ctcg.ctcg_vlagua) as col_0 "
					+ "  from "
					+ "   faturamento.conta_categoria ctcg "
					+ "  inner join "
					+ "   faturamento.conta cnta on ctcg.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnta.loca_id= :idLocalidade "
					+ "   and ctcg.catg_id= :idCategoria "
					+ "   and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior = :idSituacaoAnterior)  ";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idSituacaoAnterior", idSituacaoAnterior)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// linha 28
	/**
	 * Acumula o valor de esgoto por situação da conta
	 * 
	 * [UC0155 Encerrar Faturamentodo Mês]
	 * 
	 * @author Pedro Alexandre
	 * @date 11/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEsgotoPorSituacaoConta(int anoMesReferencia,
			int idLocalidade, int idCategoria, int idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql

			consulta = "select " + "  sum(ctcg.ctcg_vlesgoto) as col_0 "
					+ "  from " + "   faturamento.conta_categoria ctcg "
					+ "  inner join "
					+ "   faturamento.conta cnta on ctcg.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnta.loca_id= :idLocalidade "
					+ "   and ctcg.catg_id= :idCategoria "
					+ "   and cnta.dcst_idatual= :idSituacaoAtual  ";

			// executa o sql
			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * Acumula o valor de esgoto por situação da conta
	 * 
	 * [UC0155 Encerrar Faturamentodo Mês]
	 * 
	 * @author Pedro Alexandre
	 * @date 11/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEsgotoPorSituacaoConta(int anoMesReferencia,
			int idLocalidade, int idCategoria, int idSituacaoAtual,
			int idSituacaoAnterior) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql

			consulta = "select "
					+ "  sum(ctcg.ctcg_vlesgoto) as col_0 "
					+ "  from "
					+ "   faturamento.conta_categoria ctcg "
					+ "  inner join "
					+ "   faturamento.conta cnta on ctcg.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnta.loca_id= :idLocalidade "
					+ "   and ctcg.catg_id= :idCategoria "
					+ "   and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior) ";

			// executa o sql
			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idSituacaoAnterior", idSituacaoAnterior)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(crcg1.crcg_vlcategoria,0) - coalesce(crcg4.crcg_vlcategoria,0)) as valorIncluidoCreditoRealizado"
				+ " from faturamento.conta cnta1 "
				+ " inner join faturamento.credito_realizado crrz1 on crrz1.cnta_id = cnta1.cnta_id and crrz1.crog_id in (:idsCreditoOrigem)"
				+ " inner join faturamento.cred_realizado_catg crcg1  on crcg1.crrz_id = crrz1.crrz_id and crcg1.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta4 on (cnta4.imov_id = cnta1.imov_id and cnta4.cnta_amreferenciacontabil = :anoMesReferencia " 
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao )" 
				+ " left join faturamento.credito_realizado crrz4 on crrz4.cnta_id = cnta4.cnta_id and crrz4.crog_id = crrz1.crog_id"
				+ " and crrz4.crti_id = crrz1.crti_id and crrz4.crrz_amcobrancacredito = crrz1.crrz_amcobrancacredito "
				+ " left join faturamento.cred_realizado_catg crcg4 on crcg4.crrz_id = crrz4.crrz_id and crcg4.catg_id= crcg1.catg_id "
				+ " where cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta" 
				+ " and cnta1.loca_id = :idLocalidade "
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada)" 
				+ " and coalesce(crcg1.crcg_vlcategoria,0) > coalesce(crcg4.crcg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorIncluidoCreditoRealizado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setParameterList("idsCreditoOrigem", idsCreditoOrigem).
				uniqueResult();			
	
			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, a situação anterior e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoCanceladoPorRetificacao(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(crcg4.crcg_vlcategoria,0) - coalesce(crcg1.crcg_vlcategoria,0)) as valorCanceladoCreditoRealizado"
				+ " from faturamento.conta cnta4 "
				+ " inner join faturamento.credito_realizado crrz4 on crrz4.cnta_id = cnta4.cnta_id and crrz4.crog_id in (:idsCreditoOrigem)"
				+ " inner join faturamento.cred_realizado_catg crcg4  on crcg4.crrz_id = crrz4.crrz_id and crcg4.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta1 on (cnta1.imov_id = cnta4.imov_id and cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta " 
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada) )" 
				+ " left join faturamento.credito_realizado crrz1 on crrz1.cnta_id = cnta1.cnta_id and crrz1.crog_id = crrz4.crog_id"
				+ " and crrz1.crti_id = crrz4.crti_id and crrz1.crrz_amcobrancacredito = crrz4.crrz_amcobrancacredito "
				+ " left join faturamento.cred_realizado_catg crcg1  on crcg1.crrz_id = crrz1.crrz_id and crcg1.catg_id= crcg4.catg_id "
				+ " where cnta4.cnta_amreferenciacontabil = :anoMesReferencia "
				+ " and cnta4.loca_id = :idLocalidade "
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao" 
				+ " and coalesce(crcg4.crcg_vlcategoria,0) > coalesce(crcg1.crcg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorCanceladoCreditoRealizado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setParameterList("idsCreditoOrigem", idsCreditoOrigem).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}
	
	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_0 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg "
					+ "  inner join "
					+ "   faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
					+ "  inner join "
					+ "   faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnta.loca_id= :idLocalidade  "
					+ "   and crcg.catg_id= :idCategoria  "
					+ "   and cnta.dcst_idatual=:idSituacaoAtual "
					+ "   and (crrz.crog_id in (:idsCreditoOrigem)) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * Pesquisa os valores de curto e longo prazo dos débitos a cobrar da
	 * localidade informada por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 06/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoFinanciamento
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamento(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoFinanciamento, int idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "SELECT  "
					+ "SUM( "
					+ "CASE WHEN ( ( dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas ) < 13 ) "
					+ "THEN dbacCat.dbcg_vlcategoria - (trunc( (dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * dbac.dbac_nnprestacaocobradas) "
					+ "ELSE "
					+ "trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * 12 "
					+ "END "
					+ ") as valorCurtoPrazo, "
					+ "SUM( "
					+ "CASE WHEN ( ( dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas ) < 13 ) "
					+ "THEN 0.00 "
					+ "ELSE "
					+ "dbacCat.dbcg_vlcategoria - ( trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito ), 2 ) * ( 12 + dbac.dbac_nnprestacaocobradas ) ) "
					+ "END "
					+ ") as valorLongoPrazo "
					+ "FROM cadastro.localidade loca "
					+ "INNER JOIN faturamento.debito_a_cobrar dbac	on dbac.loca_id = loca.loca_id "
					+ "INNER JOIN faturamento.deb_a_cobrar_catg dbacCat on dbacCat.dbac_id = dbac.dbac_id "
					+ "WHERE loca.loca_id = :idLocalidade "
					+ "and dbac.dbac_amreferenciacontabil = :anoMesReferencia "
					+ "and dbac.dcst_idatual = :idSituacaoAtual "
					+ "and dbacCat.catg_id = :idCategoria "
					+ "and dbac.fntp_id = :idTipoFinanciamento ";

			// executa o hql
			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"valorCurtoPrazo", Hibernate.BIG_DECIMAL).addScalar(
					"valorLongoPrazo", Hibernate.BIG_DECIMAL).setInteger(
					"idLocalidade", idLocalidade).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idSituacaoAtual", idSituacaoAtual).setInteger(
					"idCategoria", idCategoria).setInteger(
					"idTipoFinanciamento", idTipoFinanciamento).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	// linha 30
	/**
	 * Acumula o valor de débito cobrado por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 07/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoCanceladaPorRetificacao(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idFinanciamentoTipo)throws ErroRepositorioException {

		// cria a coleção que vai armazenar os resumos de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			
			consulta = "select sum( coalesce(dccg4.dccg_vlcategoria,0) - coalesce(dccg1.dccg_vlcategoria,0)) as valorCanceladoDebitoCobrado"
				+ " from faturamento.conta cnta4 "
				+ " inner join faturamento.debito_cobrado dbcb4 on dbcb4.cnta_id = cnta4.cnta_id and dbcb4.fntp_id= :tipoFinanciamento " 
				+ " inner join faturamento.debito_cobrado_categoria dccg4 on dccg4.dbcb_id = dbcb4.dbcb_id and dccg4.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta1 on (cnta1.imov_id = cnta4.imov_id and cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta " 
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada) )" 
				+ " left join faturamento.debito_cobrado dbcb1 on dbcb1.cnta_id = cnta1.cnta_id and dbcb1.fntp_id = dbcb4.fntp_id  " 
				+ " and dbcb1.dbtp_id = dbcb4.dbtp_id and dbcb1.dbcb_amcobrancadebito = dbcb4.dbcb_amcobrancadebito and dbcb1.dbcb_amreferenciadebito = dbcb4.dbcb_amreferenciadebito "
				+ " left join faturamento.debito_cobrado_categoria dccg1 on dccg1.dbcb_id = dbcb1.dbcb_id and dccg1.catg_id= dccg4.catg_id "
				+ " where cnta4.cnta_amreferenciacontabil = :anoMesReferencia " 
				+ " and cnta4.loca_id = :idLocalidade "
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao " 
				+ " and coalesce(dccg4.dccg_vlcategoria,0) > coalesce(dccg1.dccg_vlcategoria,0) " ;			
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorCanceladoDebitoCobrado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("tipoFinanciamento", idFinanciamentoTipo).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * Acumula o valor de débito cobrado por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 07/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @param idSituacaoAtual
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamento(
			int anoMesReferencia, 
			int idLocalidade, 
			int idCategoria,
			int idLancamentoItemContabil, 
			int idSituacaoAtual,
			Collection<Integer> idFinanciamentoTipo) throws ErroRepositorioException {

		// cria a coleção que vai armazenar os resumos de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum(dccg.dccg_vlcategoria) as col_0 "
					+ " from faturamento.debito_cobrado_categoria dccg "
					+ " inner join faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " where cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ " and cnta.loca_id= :idLocalidade "
					+ " and cnta.dcst_idatual= :idSituacaoAtual "
					+ " and dccg.catg_id= :idCategoria "
					+ " and dbcb.lict_id= :idLancamentoItemContabil "
					+ " and dbcb.fntp_id in (:idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("col_0", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("idLancamentoItemContabil",idLancamentoItemContabil).
				setInteger("idSituacaoAtual",idSituacaoAtual).
				setParameterList("idFinanciamentoTipo",idFinanciamentoTipo).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}
	
	/**
	 * Acumula o valor de débito cobrado por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 07/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamento(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idSituacaoAtual, int idFinanciamentoTipo)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os resumos de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_0 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and cnta.loca_id= :idLocalidade "
					+ "  and cnta.dcst_idatual= :idSituacaoAtual "
					+ "  and dccg.catg_id= :idCategoria "
					+ "  and dbcb.fntp_id= :idFinanciamentoTipo ";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}
	
	/**
	 * Retorna o valor de categoria de credito realizado acumulado, de acordo
	 * com o ano/mês de referência, a situação atual, o item de lançamento
	 * contábil e a origem do crédito informados.
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 06/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoAtual,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		BigDecimal retorno = null;

		String consulta;
		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_0 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg  "
					+ "  inner join faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id  "
					+ "  inner join faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id  "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil= :anoMesReferencia  "
					+ "   and cnta.loca_id= :idLocalidade  "
					+ "   and crcg.catg_id= :idCategoria  "
					+ "   and cnta.dcst_idatual= :idSituacaoAtual "
					+ "   and crrz.lict_id= :idLancamentoItemContabil "
					+ "   and crrz.crog_id in (:idsCreditoOrigem) ";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idLancamentoItemContabil",
							idLancamentoItemContabil).setParameterList(
							"idsCreditoOrigem", idsCreditoOrigem)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}	


	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 41 Retorna o valor de
	 * categoria de débito acumulado, de acordo com o ano/mês de referência, a
	 * situação da conta igual a normal e o tipo de financiamento igual a
	 * serviço, quando o número de prestações cobradas for maior que 11(onze)
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorCategoriaDebitoTipoFinanciamentoServicoSituacaoNormalNumeroPrestacoesCobradasMaiorQue11(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idSituacaoAtual, int idSituacaoAnterior, int idFinanciamentoTipo)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on dbcb.lict_id=lict.lict_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " where "
					+ "  cnta.cnta_amreferenciaconta= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  "
					+ "  and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior) "
					+ "  and dccg.catg_id= :idCategoria  "
					+ "  and dbcb.fntp_id= :idFinanciamentoTipo  "
					+ "  and (dbcb.dbcb_nnprestacao-dbcb.dbcb_nnprestacaodebito) > 11 ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 42 Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * juros de parcelamento e a diferença de prestações maior que 11(onze)
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoJurosParcelamentoSituacaoNormalDiferencaPrestacoesMaiorQue11(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idFinanciamentoTipo, int idSituacaoAtual, int idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on dbcb.lict_id=lict.lict_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " where "
					+ "  cnta.cnta_amreferenciaconta= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  "
					+ "  and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior) "
					+ "  and dccg.catg_id= :idCategoria  "
					+
					// " and dbcb.fntp_id= :idFinanciamentoTipo " +
					" and dbcb.fntp_id in ( :idFinanciamentoTipo, :parcelamentoAgua, :parcelamentoEsgoto, :parcelamentoServico) "
					+ "  and (dbcb.dbcb_nnprestacao - dbcb.dbcb_nnprestacaodebito) > 11 ";

			BigDecimal valor = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_1", Hibernate.BIG_DECIMAL).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.setInteger("parcelamentoAgua",
							FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger(
							"parcelamentoEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
							"parcelamentoServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO)
					.uniqueResult();

			if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
				retorno = new ResumoFaturamento();
				retorno.setValorItemFaturamento(valor);
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * Pesquisa os valores de curto e longo prazo dos débitos a cobrar da
	 * localidade informada por grupo de parcelamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 06/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idGrupoParcelamento
	 * @param idSituacaoAnterior
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarValorLongoECurtoPrazoDebitoACobrarPorGrupoParcelamento(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idGrupoParcelamento, int idSituacaoAtual,
			int idSituacaoAnterior, boolean flagNPrestacaoCobradaIgualAZero)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			if (flagNPrestacaoCobradaIgualAZero) {
				consulta = "SELECT  "
						+ "SUM( "
						+ "CASE WHEN ( dbac.dbac_nnprestacaodebito < 13 ) "
						+ "THEN dbacCat.dbcg_vlcategoria "
						+ "ELSE "
						+ "trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * 12 "
						+ "END "
						+ ") as valorCurtoPrazo, "
						+ "SUM( "
						+ "CASE WHEN ( dbac.dbac_nnprestacaodebito < 13 ) "
						+ "THEN 0.00 "
						+ "ELSE "
						+ "dbacCat.dbcg_vlcategoria - ( trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito ), 2 ) * ( 12 ) ) "
						+ "END "
						+ ") as valorLongoPrazo "
						+ "FROM cadastro.localidade loca "
						+ "INNER JOIN faturamento.debito_a_cobrar dbac	on dbac.loca_id = loca.loca_id "
						+ "INNER JOIN faturamento.deb_a_cobrar_catg dbacCat on dbacCat.dbac_id = dbac.dbac_id "
						+ "WHERE loca.loca_id = :idLocalidade "
						+ "and dbac.dbac_amreferenciacontabil = :anoMesReferencia "
						+ "and (dbac.dcst_idatual = :idSituacaoAtual or dbac.dcst_idanterior = :idSituacaoAnterior) "
						+ "and dbacCat.catg_id = :idCategoria "
						+ "and dbac.pcgr_id = :idGrupoParcelamento ";

			} else {
				consulta = "SELECT  "
						+ "SUM( "
						+ "CASE WHEN ( ( dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas ) < 13 ) "
						+ "THEN dbacCat.dbcg_vlcategoria - (trunc( (dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * dbac.dbac_nnprestacaocobradas) "
						+ "ELSE "
						+ "trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * 12 "
						+ "END "
						+ ") as valorCurtoPrazo, "
						+ "SUM( "
						+ "CASE WHEN ( ( dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas ) < 13 ) "
						+ "THEN 0.00 "
						+ "ELSE "
						+ "dbacCat.dbcg_vlcategoria - ( trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito ), 2 ) * ( 12 + dbac.dbac_nnprestacaocobradas ) ) "
						+ "END "
						+ ") as valorLongoPrazo "
						+ "FROM cadastro.localidade loca "
						+ "INNER JOIN faturamento.debito_a_cobrar dbac	on dbac.loca_id = loca.loca_id "
						+ "INNER JOIN faturamento.deb_a_cobrar_catg dbacCat on dbacCat.dbac_id = dbac.dbac_id "
						+ "WHERE loca.loca_id = :idLocalidade "
						+ "and dbac.dbac_amreferenciacontabil = :anoMesReferencia "
						+ "and (dbac.dcst_idatual = :idSituacaoAtual or dbac.dcst_idanterior = :idSituacaoAnterior) "
						+ "and dbacCat.catg_id = :idCategoria "
						+ "and dbac.pcgr_id = :idGrupoParcelamento ";
			}
			// executa o hql
			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"valorCurtoPrazo", Hibernate.BIG_DECIMAL).addScalar(
					"valorLongoPrazo", Hibernate.BIG_DECIMAL).setInteger(
					"idLocalidade", idLocalidade).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idSituacaoAtual", idSituacaoAtual).setInteger(
					"idSituacaoAnterior", idSituacaoAnterior).setInteger(
					"idCategoria", idCategoria).setInteger(
					"idGrupoParcelamento", idGrupoParcelamento).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Acumula o valor de curto e longo prazo para creditos a realizar por
	 * origem de crédito.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 13/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditosOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarValorLongoECurtoPrazoCreditoARealizarPorOrigemCredito(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditosOrigem, int idSituacaoAtual,
			int idSituacaoAnterior) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "SELECT "
					+ "	SUM(  "
					+ "	CASE WHEN ( crar.crar_nnprestacaocredito < 13 ) "
					+ "	THEN crarCat.cacg_vlcategoria "
					+ "	ELSE  "
					+ "	round( ( crarCat.cacg_vlcategoria / crar.crar_nnprestacaocredito), 2 ) * 12 "
					+ "	END  "
					+ "	) as valorCurtoPrazo, "
					+ "	SUM(  "
					+ "	CASE WHEN ( crar.crar_nnprestacaocredito < 13 ) "
					+ "	THEN 0.00 "
					+ "	ELSE  "
					+ "	cacg_vlcategoria - ( round( ( cacg_vlcategoria / crar.crar_nnprestacaocredito ), 2 ) * ( 12 ) ) "
					+ "	END  "
					+ "	) as valorLongoPrazo  "
					+ "	FROM cadastro.localidade loca  "
					+ "	INNER JOIN faturamento.credito_a_realizar crar on crar.loca_id = loca.loca_id  "
					+ "	INNER JOIN faturamento.cred_a_realiz_catg crarCat on crarCat.crar_id = crar.crar_id "
					+ "	WHERE loca.loca_id = :idLocalidade "
					+ "	and crar_amreferenciacontabil = :anoMesReferencia "
					+ "	and (crar.dcst_idatual = :idSituacaoAtual or crar.dcst_idanterior = :idSituacaoAnterior) "
					+ "	and crarCat.catg_id = :idCategoria "
					+ "	and crar.crog_id in(:idsCreditosOrigem) ";

			// executa o hql
			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"valorCurtoPrazo", Hibernate.BIG_DECIMAL).addScalar(
					"valorLongoPrazo", Hibernate.BIG_DECIMAL).setInteger(
					"idLocalidade", idLocalidade).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idSituacaoAtual", idSituacaoAtual).setInteger(
					"idSituacaoAnterior", idSituacaoAnterior).setInteger(
					"idCategoria", idCategoria).setParameterList(
					"idsCreditosOrigem", idsCreditosOrigem).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Acumula o valor do débito cobrado por tipo de financiamento agrupando por
	 * lançamento item contábil.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 13/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param idTipoFinanciamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorDebitoCobradoPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idSituacaoAtual, int idSituacaoAnterior, int idTipoFinanciamento)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select  "
					+ " sum(dccg.dccg_vlcategoria) as col_0 , "
					+ " lict.lict_nnsequenciaimpressao as col_1, "
					+ " lict.lict_id as col_2 "
					+ " from  "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join  "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join  "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " inner join  "
					+ "  financeiro.lancamento_item_contabil lict on dbcb.lict_id=lict.lict_id "
					+ "  where  "
					+ " cnta.cnta_amreferenciaconta= :anoMesReferencia "
					+ " and cnta.loca_id= :idLocalidade "
					+ " and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior) "
					+ " and dccg.catg_id= :idCategoria "
					+ " and dbcb.fntp_id= :idTipoFinanciamento "
					+ " group by lict.lict_nnsequenciaimpressao, lict.lict_id ";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.BIG_DECIMAL).addScalar("col_1", Hibernate.SHORT)
					.addScalar("col_2", Hibernate.INTEGER).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idTipoFinanciamento", idTipoFinanciamento)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Acumula o valor de débito cobrado por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 07/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param localidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoPorReferenciaConta(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idSituacaoAtual, int idSituacaoAnterior, int idFinanciamentoTipo)
			throws ErroRepositorioException {

		// cria a coleção que vai armazenar os resumos de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_0 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "  cnta.cnta_amreferenciaconta= :anoMesReferencia "
					+ "  and cnta.loca_id= :idLocalidade "
					+ "  and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior)"
					+ "  and dccg.catg_id= :idCategoria "
					+ "  and dbcb.fntp_id= :idFinanciamentoTipo ";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * Acumula valor do imposto por tipo de imposto.
	 * 
	 * [UC155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 14/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoImposto
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorContaCategoriaPorTipoImposto(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoImposto, int idSituacaoAtual, int idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
		
			consulta = " select sum(cnid.cnid_vlimposto) as col_1 "
				+ " from faturamento.conta cnta "
				+ " inner join faturamento.conta_impostos_deduzidos cnid on cnid.cnta_id = cnta.cnta_id and cnid.imtp_id = :idTipoImposto "
				+ " inner join cadastro.imovel imov on imov.imov_id  = cnta.imov_id and imov.imov_idcategoriaprincipal = :idCategoria "
				+ " where cnta.cnta_amreferenciaconta = :anoMesReferencia "
				+ " and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior) " 
				+ " and cnta.loca_id = :idLocalidade ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("col_1", Hibernate.BIG_DECIMAL).
				setInteger("idLocalidade",idLocalidade).
				setInteger("idCategoria", idCategoria).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idTipoImposto", idTipoImposto).
				setInteger("idSituacaoAtual", idSituacaoAtual).
				setInteger("idSituacaoAnterior", idSituacaoAnterior).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * Acumula o valor de crédito realizado por origem de crédito e pela
	 * referência da conta.
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 14/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, int idSituacaoAtual,
			int idSituacaoAnterior) throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select "
					+ " sum(crrz.crrz_vlcredito) as col_0 "
					+ " from "
					+ "  faturamento.credito_realizado crrz "
					+ " inner join "
					+ " faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ " where "
					+ " cnta.cnta_amreferenciaconta= :anoMesReferencia "
					+ " and cnta.loca_id= :idLocalidade "
					+ " and (cnta.dcst_idatual=:idSituacaoAtual or cnta.dcst_idanterior=:idSituacaoAnterior) "
					+ " and (crrz.crog_id in (:idsCreditoOrigem)) "
					+ " and :idCategoria = (SELECT idCategoria "
					+ "                   	from (SELECT sc.catg_id as idCategoria, count(isc.imsb_qteconomia) as quantidade "
					+ "                            FROM "
					+ "                             cadastro.subcategoria sc, "
					+ "                             cadastro.categoria c , "
					+ "                             cadastro.imovel_subcategoria isc "
					+ "                              where sc.catg_id = c.catg_id and isc.scat_id = sc.scat_id "
					+ "                              and isc.imov_id = cnta.imov_id group by sc.catg_id "
					+ "                               order by quantidade DESC, idCategoria) as x "
					+ "                               limit 1) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idSituacaoAnterior", idSituacaoAnterior)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * Acumula o valor de crédito realizado po origem de crédito agrupando por
	 * lançamento item contábil.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 17/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoRealizadoCategoriaPorOrigemCreditoAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, int idSituacaoAtual,
			int idSituacaoAnterior) throws ErroRepositorioException {

		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_0,"
					+ "  lict.lict_id as col_1, "
					+ "  lict.lict_nnsequenciaimpressao as col_2 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg  "
					+ "  inner join faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id  "
					+ "  inner join faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id  "
					+ "  inner join financeiro.lancamento_item_contabil lict on crrz.lict_id=lict.lict_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciaconta= :anoMesReferencia  "
					+ "   and cnta.loca_id= :idLocalidade  "
					+ "   and crcg.catg_id= :idCategoria  "
					+ "   and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior) "
					+ "   and crrz.crog_id in (:idsCreditoOrigem) "
					+ "  group by lict.lict_id, lict.lict_nnsequenciaimpressao  ";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.BIG_DECIMAL)
					.addScalar("col_1", Hibernate.INTEGER).addScalar("col_2",
							Hibernate.SHORT).setInteger("anoMesReferencia",
							anoMesReferencia).setInteger("idLocalidade",
							idLocalidade)
					.setInteger("idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * Acumula o valor de imposto por tipo de imposto.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 17/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoImposto
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorContaCategoriaPorTipoImposto(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoImposto, int idSituacaoAtual)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(cnid.cnid_vlimposto) as col_1 "
					+ "  from "
					+ "   faturamento.conta_impostos_deduzidos cnid "
					+ "  inner join "
					+ "   faturamento.conta cnta on cnid.cnta_id=cnta.cnta_id "
					+ "  inner join "
					+ "   faturamento.conta_categoria catg on cnta.cnta_id=catg.cnta_id "
					+ "  where "
					+ "   cnta.loca_id= :idLocalidade "
					+ "   and catg.catg_id= :idCategoria "
					+ "   and cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnid.imtp_id= :idTipoImposto "
					+ "   and cnta.dcst_idatual= :idSituacaoAtual ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idTipoImposto", idTipoImposto).setInteger(
							"idSituacaoAtual", idSituacaoAtual).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * Acumula o valor do imposto por tipo de imposto por referência contábil.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 17/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoImposto
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorContaCategoriaPorTipoImpostoReferenciaContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoImposto, int idSituacaoAtual, int idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(cnid.cnid_vlimposto) as col_1 "
					+ "  from "
					+ "   faturamento.conta_impostos_deduzidos cnid "
					+ "  inner join "
					+ "   faturamento.conta cnta on cnid.cnta_id=cnta.cnta_id "
					+ "  inner join "
					+ "   faturamento.conta_categoria catg on cnta.cnta_id=catg.cnta_id "
					+ "  where "
					+ "   cnta.loca_id= :idLocalidade "
					+ "   and catg.catg_id= :idCategoria "
					+ "   and cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnid.imtp_id= :idTipoImposto "
					+ "   and (cnta.dcst_idatual= :idSituacaoAtual or cnta.dcst_idanterior= :idSituacaoAnterior) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idTipoImposto", idTipoImposto).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de águae o de
	 * esgoto acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual aos ids informados com ano/mês da
	 * baixa contábil preenchida
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsSituacaoAtual) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(ctcg.ctcg_vlagua) as col_0, "
					+ "  sum(ctcg.ctcg_vlesgoto) as col_1 "
					+ " from "
					+ "  faturamento.conta_categoria ctcg "
					+ " inner join "
					+ "  faturamento.conta cnta on ctcg.cnta_id=cnta.cnta_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and cnta.loca_id= :idLocalidade  "
					+ "  and ctcg.catg_id= :idCategoria  "
					+ "  and (cnta.cnta_amreferenciabaixacontabil is not null) "
					+ "  and (cnta.dcst_idatual in (:idsSituacaoAtual)) ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).addScalar("col_1",
					Hibernate.BIG_DECIMAL).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria).setParameterList(
							"idsSituacaoAtual", idsSituacaoAtual)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a(s)
	 * situação(ões) atual(ais) com o ano/mês de referência da baixa contábil da
	 * conta preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaDebitoCobradoCategoriaComBaixaContabilPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsSituacaoAtual) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  "
					+ "  and cnta.dcst_idatual in(:idsSituacaoAtual) "
					+ "  and dccg .catg_id= :idCategoria  "
					+ "  and (cnta.cnta_amreferenciabaixacontabil is not null) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setParameterList("idsSituacaoAtual",
					idsSituacaoAtual).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de águae o de
	 * esgoto acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual aos ids informados com ano/mês da
	 * baixa contábil não preenchida
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilNaoPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsSituacaoAtual) throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select " + "  sum(ctcg.ctcg_vlagua) as col_0, "
					+ "  sum(ctcg.ctcg_vlesgoto) as col_1 " + " from "
					+ "  faturamento.conta_categoria ctcg " + " inner join "
					+ "  faturamento.conta cnta on ctcg.cnta_id=cnta.cnta_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and cnta.loca_id= :idLocalidade  "
					+ "  and ctcg.catg_id= :idCategoria  "
					+ "  and (cnta.cnta_amreferenciabaixacontabil is null) "
					+ "  and (cnta.dcst_idatual in (:idsSituacaoAtual)) ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).addScalar("col_1",
					Hibernate.BIG_DECIMAL).setInteger("anoMesReferencia",
					anoMesReferencia).setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria).setParameterList(
							"idsSituacaoAtual", idsSituacaoAtual)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual e o tipo de financiamento com o ano/mês de referência da
	 * baixa contábil da conta preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idFinanciamentoTipo, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}					
			consulta = consulta	+ "  and dccg .catg_id= :idCategoria  "
								+ "  and dbcb.fntp_id= :idFinanciamentoTipo  "
								+ "  and cnta.cnta_amreferenciabaixacontabil is not null ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual e a origem do crédito informados e com o ano/mês da baixa
	 * contábil preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idCreditoOrigem, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_1 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg  "
					+ "  inner join  faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
					+ "  inner join  faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciaconta=:anoMesReferencia "
					+ "   and crrz.loca_id=:idLocalidade  "
					+ "   and crcg.catg_id=:idCategoria  ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}
					
			consulta = consulta	+ "   and crrz.crog_id = :idCreditoOrigem "
								+ "   and cnta.cnta_amreferenciabaixacontabil is not null ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idCreditoOrigem", idCreditoOrigem)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor do imposto
	 * acumulado de acordo com o ano/mês de referência da conta, a situação
	 * atual da conta e o tipo de imposto e com o ano/mês da baixa contábil da
	 * conta preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 * 
	 */
	public BigDecimal acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria,
			Integer idImpostoTipo, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(cnid.cnid_vlimposto) as col_1 "
					+ "  from "
					+ "   faturamento.conta_impostos_deduzidos cnid "
					+ "  inner join "
					+ "   faturamento.conta cnta on cnid.cnta_id=cnta.cnta_id "
					+ "  inner join "
					+ "   faturamento.conta_categoria catg on cnta.cnta_id=catg.cnta_id "
					+ "  where "
					+ "   cnta.loca_id= :idLocalidade "
					+ "   and catg.catg_id= :idCategoria "
					+ "   and cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnid.imtp_id= :idTipoImposto ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}
			consulta = consulta	+ "   and cnta.cnta_amreferenciabaixacontabil is not null ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idTipoImposto", idImpostoTipo).setInteger(
							"idSituacaoAtual", idSituacaoAtual).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual e o tipo de financiamento com o ano/mês de referência da
	 * baixa contábil da conta não preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idFinanciamentoTipo, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  "
					+ "  and dccg .catg_id= :idCategoria  ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}
			consulta = consulta + "  and dbcb.fntp_id = :idFinanciamentoTipo  "
								+ "  and cnta.cnta_amreferenciabaixacontabil is null ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual e a origem do crédito informados e com o ano/mês da baixa
	 * contábil não preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idCreditoOrigem, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_1 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg  "
					+ "  inner join  faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
					+ "  inner join  faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil=:anoMesReferencia "
					+ "   and crrz.loca_id=:idLocalidade  "
					+ "   and crcg.catg_id=:idCategoria  ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}
			consulta = consulta + "   and crrz.crog_id=:idCreditoOrigem "
								+ "   and cnta.cnta_amreferenciabaixacontabil is null ";

			BigDecimal valor = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_1", Hibernate.BIG_DECIMAL).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idCreditoOrigem", idCreditoOrigem).uniqueResult();

			if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
				retorno = new ResumoFaturamento();
				retorno.setValorItemFaturamento(valor);
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor do imposto
	 * acumulado de acordo com o ano/mês de referência da conta, a situação
	 * atual da conta e o tipo de imposto e com o ano/mês da baixa contábil da
	 * conta não preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 * 
	 */
	public BigDecimal acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
			int anoMesReferencia, Integer idLocalidade, Integer idCategoria,
			Integer idImpostoTipo, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(cnid.cnid_vlimposto) as col_1 "
					+ "  from "
					+ "   faturamento.conta_impostos_deduzidos cnid "
					+ "  inner join "
					+ "   faturamento.conta cnta on cnid.cnta_id=cnta.cnta_id "
					+ "  inner join "
					+ "   faturamento.conta_categoria catg on cnta.cnta_id=catg.cnta_id "
					+ "  where "
					+ "   cnta.loca_id= :idLocalidade "
					+ "   and catg.catg_id= :idCategoria "
					+ "   and cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and cnid.imtp_id= :idTipoImposto ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}
						
			consulta = consulta	+ "   and cnta.cnta_amreferenciabaixacontabil is null ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idTipoImposto", idImpostoTipo).setInteger(
							"idSituacaoAtual", idSituacaoAtual).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * Retorna o valor de crédito a realizar acumulado, de acordo com o ano/mês
	 * de referência contábil, a situação atual ou anterior e a origem de
	 * crédito informados.
	 * 
	 * @author Pedro Alexandre, Raphael Rossiter
	 * @date 00/00/0000, 24/03/2009
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @param categoria
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer[] idsOrigemCredito, Integer idSituacaoAtual,
			Categoria categoria) throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			/*
			 * Colocado por Raphael Rossiter em 24/03/2009 - Analista: Aryed
			 * Lins OBJ - Correção da contabilização dos créditos a realizar
			 * cancelados para considerar as parcelas já concedidas (Sequencial
			 * 540). CRC1153.
			 */
			consulta = "select "
					+

					"  sum((cacg.cacg_vlcategoria - (( cacg.cacg_vlcategoria / coalesce(crar.crar_nnprestacaocredito, 1)) "
					+ "  * coalesce(crar.crar_nnprestacaorealizadas, 1) ) ) + coalesce(crar.crar_vlresidualmesanterior, 0) ) as col_1, "
					+

					"  lict.lict_nnsequenciaimpressao as col_2, "
					+ "  lict.lict_id as col_3 "
					+ " from "
					+ "  faturamento.cred_a_realiz_catg cacg  "
					+ " inner join "
					+ "  faturamento.credito_a_realizar crar on cacg.crar_id=crar.crar_id  "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on crar.lict_id=lict.lict_id  "
					+ " where "
					+ "  crar.loca_id=:idLocalidade  "
					+ "  and cacg.catg_id=:idCategoria  "
					+ "  and crar.crar_amreferenciacontabil=:anoMesReferenciaContabil  "
					+ "  and crar.dcst_idatual=:idSituacaoAtual  "
					+ "  and (crar.crog_id in (:idsOrigemCredito))  "
					+ " group by " + "  lict.lict_nnsequenciaimpressao , "
					+ "  lict.lict_id ";

			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL).addScalar("col_2", Hibernate.SHORT)
					.addScalar("col_3", Hibernate.INTEGER).setInteger(
							"anoMesReferenciaContabil",
							anoMesReferenciaContabil).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", categoria.getId()).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsOrigemCredito", idsOrigemCredito)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * Retorna o valor de crédito a realizar acumulado, de acordo com o ano/mês
	 * de referência contábil, a situação atual e a origem de crédito
	 * informados.
	 * 
	 * @author Pedro Alexandre, Raphael Rossiter
	 * @date 00/00/0000, 24/03/2009
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @param categoria
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer idOrigemCredito, Integer idSituacaoAtual,
			Categoria categoria) throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			/*
			 * Colocado por Raphael Rossiter em 24/03/2009 - Analista: Aryed
			 * Lins OBJ - Correção da contabilização dos créditos a realizar
			 * cancelados para considerar as parcelas já concedidas (Sequencial
			 * 550). CRC1153.
			 */
			consulta = "select "
					+

					"  sum((cacg.cacg_vlcategoria - (( cacg.cacg_vlcategoria / coalesce(crar.crar_nnprestacaocredito, 1)) "
					+ "  * coalesce(crar.crar_nnprestacaorealizadas, 1) ) ) + coalesce(crar.crar_vlresidualmesanterior, 0) ) as col_1 "
					+

					" from "
					+ "  faturamento.cred_a_realiz_catg cacg  "
					+ " inner join "
					+ "  faturamento.credito_a_realizar crar on cacg.crar_id=crar.crar_id  "
					+ " where "
					+ "  crar.loca_id=:idLocalidade  "
					+ "  and cacg.catg_id=:idCategoria  "
					+ "  and crar.crar_amreferenciacontabil=:anoMesReferenciaContabil  "
					+ "  and crar.dcst_idatual=:idSituacaoAtual  "
					+ "  and crar.crog_id = :idOrigemCredito  ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", categoria.getId()).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idOrigemCredito", idOrigemCredito).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de crédito a
	 * realizar acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param categoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer[] idsOrigemCredito, Integer idSituacaoAtual,
			Integer idSituacaoAnterior, Categoria categoria)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(cacg.cacg_vlcategoria) as col_1, "
					+ "  lict.lict_nnsequenciaimpressao as col_2, "
					+ "  lict.lict_id as col_3 "
					+ " from "
					+ "  faturamento.cred_a_realiz_catg cacg  "
					+ " inner join "
					+ "  faturamento.credito_a_realizar crar on cacg.crar_id=crar.crar_id  "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on crar.lict_id=lict.lict_id  "
					+ " where "
					+ "  crar.loca_id=:idLocalidade  "
					+ "  and cacg.catg_id=:idCategoria  "
					+ "  and crar.crar_amreferenciacontabil=:anoMesReferenciaContabil  "
					+ "  and (crar.dcst_idatual=:idSituacaoAtual or crar.dcst_idanterior=:idSituacaoAnterior)  "
					+ "  and (crar.crog_id in (:idsOrigemCredito))  "
					+ " group by " + "  lict.lict_nnsequenciaimpressao , "
					+ "  lict.lict_id ";

			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL).addScalar("col_2", Hibernate.SHORT)
					.addScalar("col_3", Hibernate.INTEGER).setInteger(
							"anoMesReferenciaContabil",
							anoMesReferenciaContabil).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", categoria.getId()).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setParameterList("idsOrigemCredito", idsOrigemCredito)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de crédito a
	 * realizar acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param categoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer idOrigemCredito, Integer idSituacaoAtual,
			Integer idSituacaoAnterior, Categoria categoria)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(cacg.cacg_vlcategoria) as col_1 "
					+ " from "
					+ "  faturamento.cred_a_realiz_catg cacg  "
					+ " inner join "
					+ "  faturamento.credito_a_realizar crar on cacg.crar_id=crar.crar_id  "
					+ " where "
					+ "  crar.loca_id=:idLocalidade  "
					+ "  and cacg.catg_id=:idCategoria  "
					+ "  and crar.crar_amreferenciacontabil=:anoMesReferenciaContabil  "
					+ "  and (crar.dcst_idatual=:idSituacaoAtual or crar.dcst_idanterior=:idSituacaoAnterior)  "
					+ "  and crar.crog_id =:idOrigemCredito ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", categoria.getId()).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idOrigemCredito", idOrigemCredito)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * Acumula o valor do débito a cobrar por tipo de financiamento
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 24/03/2008
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsTipoFinanciamento
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoACobrarCategoriaPorTipoFinanciamento(
			int anoMesReferenciaContabil, int idLocalidade, int idCategoria,
			Integer[] idsTipoFinanciamento, int idSituacaoAtual,
			int idSituacaoAnterior) throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select "
					+ "  sum(dbcg.dbcg_vlcategoria) as col_1	"
					+ " from	"
					+ "  faturamento.deb_a_cobrar_catg dbcg 	"
					+ " inner join "
					+ "  faturamento.debito_a_cobrar dbac on dbcg.dbac_id=dbac.dbac_id "
					+ " where	"
					+ "  dbac.loca_id= :idLocalidade "
					+ "  and dbcg.catg_id = :idCategoria	"
					+ "  and dbac.dbac_amreferenciacontabil=:anoMesReferenciaContabil "
					+ "  and (dbac.dcst_idatual=:idSituacaoAtual or dbac.dcst_idanterior=:idSituacaoAnterior) "
					+ "  and (dbac.fntp_id in(:idsTipoFinanciamento)) ";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).setInteger(
							"idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("idSituacaoAnterior",
							DebitoCreditoSituacao.NORMAL).setParameterList(
							"idsTipoFinanciamento", idsTipoFinanciamento)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de crédito a
	 * realizar acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer idCategoria, Integer idOrigemCredito,
			Integer idSituacaoAtual, Integer idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ " sum(catg.cacg_vlcategoria) as col_1 "
					+ " from "
					+ "  faturamento.cred_a_realiz_catg catg "
					+ " inner join "
					+ "  faturamento.credito_a_realizar crar on catg.crar_id=crar.crar_id "
					+ " where "
					+ "  crar.loca_id=:idLocalidade "
					+ "  and catg.catg_id = :idCategoria "
					+ "  and crar.crar_amreferenciacontabil=:anoMesReferenciaContabil "
					+ "  and (crar.dcst_idatual=:idSituacaoAtual or crar.dcst_idanterior=:idSituacaoAnterior) "
					+ "  and crar.crog_id=:idOrigemCredito ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idOrigemCredito", idOrigemCredito)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * Retorna o valor de crédito a realizar acumulado, de acordo com o ano/mês
	 * de referência contábil, a situação atual e a origem de crédito
	 * informados.
	 * 
	 * @author Pedro Alexandre, Raphael Rossiter
	 * @date 00/00/0000, 24/03/2009
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoARealizarPorOrigemCredito(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer idCategoria, Integer idOrigemCredito,
			Integer idSituacaoAtual) throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			/*
			 * Colocado por Raphael Rossiter em 24/03/2009 - Analista: Aryed
			 * Lins OBJ - Correção da contabilização dos créditos a realizar
			 * cancelados para considerar as parcelas já concedidas (Sequencial
			 * 1620). CRC1153.
			 */
			consulta = "select "
					+

					"  sum((cacg.cacg_vlcategoria - (( cacg.cacg_vlcategoria / coalesce(crar.crar_nnprestacaocredito, 1)) "
					+ "  * coalesce(crar.crar_nnprestacaorealizadas, 1) ) ) + coalesce(crar.crar_vlresidualmesanterior, 0) ) as col_1 "
					+

					" from "
					+ "  faturamento.cred_a_realiz_catg cacg "
					+ " inner join "
					+ "  faturamento.credito_a_realizar crar on cacg.crar_id = crar.crar_id "
					+ " where "
					+ "  crar.loca_id = :idLocalidade "
					+ "  and cacg.catg_id = :idCategoria "
					+ "  and crar.crar_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "  and crar.dcst_idatual = :idSituacaoAtual "
					+ "  and crar.crog_id = :idOrigemCredito ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idOrigemCredito", idOrigemCredito).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * Acumula o valor de débito cobrado por tipo de financiamento.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 07/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param localidade
	 * @param idCategoria
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoRetificada(
			int anoMesReferencia, Localidade localidade, int idCategoria,
			int idFinanciamentoTipo) throws ErroRepositorioException {

		// cria a coleção que vai armazenar os resumos de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			
			consulta = "select sum( coalesce(dccg1.dccg_vlcategoria,0) - coalesce(dccg4.dccg_vlcategoria,0)) as valorIncluidoDebitoCobrado"
				+ " from faturamento.conta cnta1"
				+ " inner join faturamento.debito_cobrado dbcb1 on dbcb1.cnta_id = cnta1.cnta_id and dbcb1.fntp_id= :tipoFinanciamento " 
				+ " inner join faturamento.debito_cobrado_categoria dccg1 on dccg1.dbcb_id = dbcb1.dbcb_id and dccg1.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta4 on (cnta4.imov_id = cnta1.imov_id and cnta4.cnta_amreferenciacontabil = :anoMesReferencia " 
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao )" 
				+ " left join faturamento.debito_cobrado dbcb4 on dbcb4.cnta_id = cnta4.cnta_id and dbcb4.fntp_id = dbcb1.fntp_id  " 
				+ " and dbcb4.dbcb_amcobrancadebito = dbcb1.dbcb_amcobrancadebito and dbcb4.dbcb_amreferenciadebito = dbcb1.dbcb_amreferenciadebito and dbcb4.dbtp_id = dbcb1.dbtp_id "
				+ " left join faturamento.debito_cobrado_categoria dccg4 on dccg4.dbcb_id = dbcb4.dbcb_id and dccg4.catg_id= dccg1.catg_id"
				+ " where cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta "
				+ " and cnta1.loca_id = :idLocalidade "
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada )" 
				+ " and coalesce(dccg1.dccg_vlcategoria,0) > coalesce(dccg4.dccg_vlcategoria,0)";				
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorIncluidoDebitoCobrado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", localidade.getId()).
				setInteger("idCategoria", idCategoria).
				setInteger("debitoCreditoSituacaoRetificada",DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao",DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setInteger("tipoFinanciamento",idFinanciamentoTipo).
				uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * Pesquisa os valores de curto e longo prazo dos débitos a cobrar da
	 * localidade informada por tipo de financiamento agrupando por lançamento
	 * item contábil.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 16/04/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoFinanciamento
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoFinanciamento, int idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "SELECT  "
					+ "SUM( "
					+ "CASE WHEN ( ( dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas ) < 13 ) "
					+ "THEN dbacCat.dbcg_vlcategoria - (trunc( (dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * dbac.dbac_nnprestacaocobradas) "
					+ "ELSE "
					+ "trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * 12 "
					+ "END "
					+ ") as valorCurtoPrazo, "
					+ "SUM( "
					+ "CASE WHEN ( ( dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas ) < 13 ) "
					+ "THEN 0.00 "
					+ "ELSE "
					+ "dbacCat.dbcg_vlcategoria - ( trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito ), 2 ) * ( 12 + dbac.dbac_nnprestacaocobradas ) ) "
					+ "END "
					+ ") as valorLongoPrazo, "
					+ "lict.lict_id as col1, "
					+ "lict.lict_nnsequenciaimpressao as col2 "
					+ "FROM cadastro.localidade loca "
					+ "INNER JOIN faturamento.debito_a_cobrar dbac	on dbac.loca_id = loca.loca_id "
					+ "INNER JOIN faturamento.deb_a_cobrar_catg dbacCat on dbacCat.dbac_id = dbac.dbac_id "
					+ "INNER JOIN financeiro.lancamento_item_contabil lict on dbac.lict_id=lict.lict_id "
					+ "WHERE loca.loca_id = :idLocalidade "
					+ "and dbac.dbac_amreferenciacontabil = :anoMesReferencia "
					+ "and dbac.dcst_idatual = :idSituacaoAtual "
					+ "and dbacCat.catg_id = :idCategoria "
					+ "and dbac.fntp_id = :idTipoFinanciamento "
					+ "group by lict.lict_id, lict.lict_nnsequenciaimpressao";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar(
					"valorCurtoPrazo", Hibernate.BIG_DECIMAL).addScalar(
					"valorLongoPrazo", Hibernate.BIG_DECIMAL).addScalar("col1",
					Hibernate.INTEGER).addScalar("col2", Hibernate.SHORT)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idTipoFinanciamento", idTipoFinanciamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa os valores de curto e longo prazo dos débitos a cobrar da
	 * localidade informada por tipo de financiamento e agrupando por lançamento
	 * item contábil.
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 16/04/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoFinanciamento
	 * @param idSituacaoAnterior
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoFinanciamento, int idSituacaoAtual, int idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "SELECT  "
					+ "SUM( "
					+ "CASE WHEN ( dbac.dbac_nnprestacaodebito < 13 ) "
					+ "THEN dbacCat.dbcg_vlcategoria "
					+ "ELSE "
					+ "trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito), 2 ) * 12 "
					+ "END "
					+ ") as valorCurtoPrazo, "
					+ "SUM( "
					+ "CASE WHEN ( dbac.dbac_nnprestacaodebito  < 13 ) "
					+ "THEN 0.00 "
					+ "ELSE "
					+ "dbacCat.dbcg_vlcategoria - ( trunc( ( dbacCat.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito ), 2 ) * ( 12 ) ) "
					+ "END "
					+ ") as valorLongoPrazo, "
					+ "lict.lict_id as col1, "
					+ "lict.lict_nnsequenciaimpressao as col2 "
					+ "FROM cadastro.localidade loca "
					+ "INNER JOIN faturamento.debito_a_cobrar dbac on dbac.loca_id = loca.loca_id "
					+ "INNER JOIN faturamento.deb_a_cobrar_catg dbacCat on dbacCat.dbac_id = dbac.dbac_id "
					+ "INNER JOIN financeiro.lancamento_item_contabil lict on dbac.lict_id=lict.lict_id "
					+ "WHERE loca.loca_id = :idLocalidade "
					+ "and dbac.dbac_amreferenciacontabil = :anoMesReferencia "
					+ "and (dbac.dcst_idatual = :idSituacaoAtual or dbac.dcst_idanterior = :idSituacaoAnterior) "
					+ "and dbacCat.catg_id = :idCategoria "
					+ "and dbac.fntp_id = :idTipoFinanciamento "
					+ "group by lict.lict_id, lict.lict_nnsequenciaimpressao";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar(
					"valorCurtoPrazo", Hibernate.BIG_DECIMAL).addScalar(
					"valorLongoPrazo", Hibernate.BIG_DECIMAL).addScalar("col1",
					Hibernate.INTEGER).addScalar("col2", Hibernate.SHORT)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idCategoria", idCategoria).setInteger(
							"idTipoFinanciamento", idTipoFinanciamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, tipo de financiamento e pelo lançamento item contábil com
	 * o ano/mês de referência da baixa contábil da conta não preenchido
	 * agrupando por lançamento item contábil.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchidaAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsFinanciamentoTipo, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1, "
					+ "  lict.lict_nnsequenciaimpressao as col_2,"
					+ "  lict.lict_id as col_3 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on dbcb.lict_id=lict.lict_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}
			consulta = consulta + "  and dccg.catg_id= :idCategoria  "
								+ "  and (dbcb.fntp_id in (:idsFinanciamentoTipo))  "
								+ "  and (cnta.cnta_amreferenciabaixacontabil is null) "
								+ " group by col_2, col_3 ";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL).addScalar("col_2", Hibernate.SHORT)
					.addScalar("col_3", Hibernate.INTEGER).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsFinanciamentoTipo",
							idsFinanciamentoTipo).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * débito cobrado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, tipo de financiamento e pelo lançamento item contábil com
	 * o ano/mês de referência da baixa contábil da conta preenchido agrupando
	 * por lançamento item contábil.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchidaAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsFinanciamentoTipo, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		// cria o objeto de resumo de faturamento
		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(dccg.dccg_vlcategoria) as col_1, "
					+ "  lict.lict_nnsequenciaimpressao as col_2, "
					+ "  lict.lict_id as col_3 "
					+ " from "
					+ "  faturamento.debito_cobrado_categoria dccg "
					+ " inner join "
					+ "  faturamento.debito_cobrado dbcb on dccg.dbcb_id=dbcb.dbcb_id "
					+ " inner join "
					+ "  faturamento.conta cnta on dbcb.cnta_id=cnta.cnta_id "
					+ " inner join "
					+ "  financeiro.lancamento_item_contabil lict on dbcb.lict_id=lict.lict_id "
					+ " where "
					+ "  cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "  and dbcb.loca_id= :idLocalidade  "
					+ "  and dccg .catg_id= :idCategoria  ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}
					consulta = consulta + "  and (dbcb.fntp_id in (:idsFinanciamentoTipo))  "
										+ "  and (cnta.cnta_amreferenciabaixacontabil is not null) "
										+ " group by col_2, col_3 ";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL).addScalar("col_2", Hibernate.SHORT)
					.addScalar("col_3", Hibernate.INTEGER).setInteger(
							"anoMesReferencia", anoMesReferencia).setInteger(
							"idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsFinanciamentoTipo",
							idsFinanciamentoTipo).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, o item de financiamento contábil e a origem do crédito
	 * informados e com o ano/mês da baixa contábil não preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchidaAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		/**
		 * Troca da coluna cnta_amreferenciaconta por cnta_amreferenciacontabil no where
		 * para corrigir contabilização.
		 * @author: Wellington Rocha
		 * @date: 10/01/12 */
		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_1, "
					+ "  lict.lict_id as col_2,"
					+ "  lict.lict_nnsequenciaimpressao as col_3 "
					+ " from "
					+ "   faturamento.cred_realizado_catg crcg  "
					+ " inner join faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
					+ " inner join faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ " inner join financeiro.lancamento_item_contabil lict on crrz.lict_id=lict.lict_id "
					+ " where "
					+ "   cnta.cnta_amreferenciacontabil=:anoMesReferencia "
					+ "   and crrz.loca_id=:idLocalidade "
					+ "   and crcg.catg_id=:idCategoria ";
			/**
			 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
			 * @author Wellington Rocha*/
			if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
				consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
									+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
			}else{
				consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
			}
			consulta = consulta	+ "   and (crrz.crog_id in (:idsCreditoOrigem)) "
								+ "   and (cnta.cnta_amreferenciabaixacontabil is null) "
								+ " group by col_2, col_3";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL)
					.addScalar("col_2", Hibernate.INTEGER).addScalar("col_3",
							Hibernate.SHORT).setInteger("anoMesReferencia",
							anoMesReferencia).setInteger("idLocalidade",
							idLocalidade)
					.setInteger("idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de categoria de
	 * credito realizado acumulado, de acordo com o ano/mês de referência, a
	 * situação atual, o item de financiamento contábil e a origem do crédito
	 * informados e com o ano/mês da baixa contábil preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchidaAgrupandoPorLancamentoItemContabil(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			/**
			 * Correção da consulta, troca da coluna cnta_amreferenciaconta por cnta_amreferenciacontabil
			 * para correta contabilização.
			 * 
			 * @author Wellington Rocha
			 * @date 10/01/2012*/
			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_1, "
					+ "  lict.lict_id as col_2,"
					+ "  lict.lict_nnsequenciaimpressao as col_3 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg  "
					+ "  inner join  faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
					+ "  inner join  faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ "  inner join financeiro.lancamento_item_contabil lict on crrz.lict_id=lict.lict_id "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil=:anoMesReferencia "
					+ "   and crrz.loca_id=:idLocalidade  ";
			
					/**
					 * Inlcuindo contas incluidas canceladas por débito prescrito na contabilização
					 * @author Wellington Rocha*/
					if (idSituacaoAtual.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)){
						consulta = consulta + " and (cnta.dcst_idatual= :idSituacaoAtual OR cnta.dcst_idatual= "
											+ DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS + ")";
					}else{
						consulta = consulta + "  and cnta.dcst_idatual= :idSituacaoAtual ";
					}
					consulta = consulta + "   and crcg.catg_id=:idCategoria  "
										+ "   and (crrz.crog_id in (:idsCreditoOrigem)) "
										+ "   and (cnta.cnta_amreferenciabaixacontabil is not null) "
										+ " group by col_2, col_3";

			retorno = session.createSQLQuery(consulta).addScalar("col_1",
					Hibernate.BIG_DECIMAL)
					.addScalar("col_2", Hibernate.INTEGER).addScalar("col_3",
							Hibernate.SHORT).setInteger("anoMesReferencia",
							anoMesReferencia).setInteger("idLocalidade",
							idLocalidade)
					.setInteger("idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * Pesquisa para cada imóvel da rota informada a principal categoria.
	 * 
	 * [UC0302] - Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 05/05/2008
	 * 
	 * @param codigoEmpresaFebraban
	 * @param idRota
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarPrincipalCategoriaImovelPorRota(
			Short codigoEmpresaFebraban, Integer idRota)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  imsb.imov_id as col_0, "
					+ "  catg.catg_id as categoria, "
					+ "  sum(imsb.imsb_qteconomia) as qtdEconomia, "
					+ "  catg.catg_iccobrancaacrescimos as col_1 "
					+ " from "
					+ "  cadastro.imovel_subcategoria imsb "
					+ " inner join cadastro.subcategoria scat on imsb.scat_id=scat.scat_id "
					+ " inner join cadastro.categoria catg on scat.catg_id=catg.catg_id  "
					+ " where "
					+ "  imsb.imov_id in(select "
					+ "		  imovel0_.imov_id  "
					+ "		 from "
					+ "		  cadastro.imovel imovel0_ "
					+ "		 left outer join cadastro.localidade localidade1_ on imovel0_.loca_id=localidade1_.loca_id "
					+ "		 left outer join cadastro.setor_comercial setorcomer2_ on imovel0_.stcm_id=setorcomer2_.stcm_id "
					+ "		 left outer join cadastro.quadra quadra3_ on imovel0_.qdra_id=quadra3_.qdra_id  "
					+ "		 left outer join micromedicao.rota rota4_ on quadra3_.rota_id=rota4_.rota_id  "
					+ "		 where  "
					+ "		  rota4_.rota_id = :idRota and imovel0_.rota_idalternativa is null "
					+ "		  and imovel0_.imov_icimovelcondominio <> 1 and imovel0_.imov_icexclusao <> 1) "
					+ " group by "
					+ "  imsb.imov_id,catg.catg_id,catg.catg_iccobrancaacrescimos ";

			// [FS0001] - Verificar mais de uma categoria com a maior quantidade
			// de economia
			if (codigoEmpresaFebraban
					.equals(SistemaParametro.CODIGO_EMPRESA_FEBRABAN_CAERN)) {
				consulta = consulta
						+ " order by qtdEconomia desc, categoria asc ";
			} else {
				consulta = consulta
						+ " order by qtdEconomia desc, categoria desc ";
			}

			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.INTEGER)
					.addScalar("categoria", Hibernate.INTEGER).addScalar(
							"qtdEconomia", Hibernate.INTEGER).addScalar(
							"col_1", Hibernate.SHORT).setInteger("idRota",
							idRota).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * Pesquisa as contas parao imóvel com situação igual a norma, retificada ou
	 * incluida que tenha pagamento.
	 * 
	 * [UC0302] - Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 08/05/2008
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param dataAnoMesReferenciaUltimoDia
	 * @param anoMesArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImovelComPagamento(Integer imovel,
			Integer situacaoNormal, Integer situacaoIncluida,
			Integer situacaoRetificada, Date dataAnoMesReferenciaUltimoDia,
			Integer anoMesArrecadacao) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, "
					+ "cnta.valorEsgoto, cnta.debitos, cnta.valorCreditos, cnta.indicadorCobrancaMulta "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.contaGeral contaGeral "
					+ "INNER JOIN contaGeral.conta cnta "
					+ "INNER JOIN cnta.imovel imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
					+ "WHERE imov.id = :idImovel AND "
					+ "cnta.dataVencimentoConta <= :dataAnoMesReferenciaUltimoDia AND "
					+ "cnta.dataRevisao is null AND "
					+ "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada) AND "
					+ "pgmt.anoMesReferenciaArrecadacao = :anoMesArrecadacao "
					+ "and pgmt.pagamentoSituacaoAtual.id = :pagamentoClassificado ";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovel).setInteger("normal", situacaoNormal).setInteger(
					"incluida", situacaoIncluida).setInteger("retificada",
					situacaoRetificada).setDate(
					"dataAnoMesReferenciaUltimoDia",
					dataAnoMesReferenciaUltimoDia).setInteger(
					"anoMesArrecadacao", anoMesArrecadacao)
					.setInteger("pagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna as contas com o indicador de pagamento para a conta.
	 * 
	 * [UC0302] - Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 08/05/2008
	 * 
	 * @param idsConta
	 * @param anoMesReferenciaConta
	 * @param anoMesReferenciaAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> obterIndicadorPagamentosClassificadosContaReferenciaMenorIgualAtual(
			Collection<Integer> idsConta, Integer anoMesReferenciaAtual)
			throws ErroRepositorioException {

		Collection<Integer> colecaoRetorno;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cnta.id "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.contaGeral contaGeral "
					+ "INNER JOIN contaGeral.conta cnta "
					+ "WHERE cnta.id in (:idsConta) "
					+ "AND pgmt.pagamentoSituacaoAtual.id = :idSituacaoAtual "
					+ "AND pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaAtual ";

			colecaoRetorno = session.createQuery(consulta).setParameterList(
					"idsConta", idsConta).setInteger("idSituacaoAtual",
					PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
					"anoMesReferenciaAtual", anoMesReferenciaAtual).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoRetorno;
	}

	/**
	 * pesquisa o indicado de acréscimo para o cliente do imóvel.
	 * 
	 * [UC0302]-Gerar Débito a cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 09/05/2008
	 * 
	 * @param idRota
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> obterIndicadorGeracaoAcrescimosClienteImovel(
			Integer idRota) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "clienteimovel.imov_id as col_0, "
					+ "cliente.clie_iccobrancaacrescimos as col_1 "
					+ "from "
					+ "cadastro.cliente_imovel clienteimovel "
					+ "inner join "
					+ "cadastro.cliente cliente on clienteimovel.clie_id=cliente.clie_id "
					+ "where "
					+ "clienteimovel.imov_id in(select "
					+ "imovel0_.imov_id "
					+ "from "
					+ "cadastro.imovel imovel0_ "
					+ "left outer join cadastro.localidade localidade1_ on imovel0_.loca_id=localidade1_.loca_id "
					+ "left outer join cadastro.setor_comercial setorcomer2_ on imovel0_.stcm_id=setorcomer2_.stcm_id "
					+ "left outer join cadastro.quadra quadra3_ on imovel0_.qdra_id=quadra3_.qdra_id "
					+ "left outer join micromedicao.rota rota4_ on quadra3_.rota_id=rota4_.rota_id "
					+ "where "
					+ "rota4_.rota_id = :idRota and imovel0_.rota_idalternativa is null "
					+ "and imovel0_.imov_icimovelcondominio <> 1 and imovel0_.imov_icexclusao <> 1) "
					+ "and clienteimovel.crtp_id= :idRelacao "
					+ "and ( clienteimovel.clim_dtrelacaofim is null) ";

			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.INTEGER).addScalar("col_1", Hibernate.SHORT)
					.setInteger("idRota", idRota).setParameter("idRelacao",
							ClienteRelacaoTipo.RESPONSAVEL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	// ******************************************************************************************
	// [UC0764] Gerar Relatorio Contas Canceladas ou Retificadas
	// Flávio Leonardo
	// 09/05/2008
	// metodo q contem a parte invariavel da query
	public Collection pesquisarContasCanceladasRetificadas(Map parameters,
			String consulta, RelatorioContasCanceladasRetificadasHelper helper)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try {
			// localidade
			if (helper.getIdLocalidade() != null
					&& !helper.getIdLocalidade().equals("")) {
				consulta += " and conta.localidade.id = :idLocalidade ";
				parameters.put("idLocalidade", new Integer(helper
						.getIdLocalidade()));
			}
			// Imovel Perfil
			if (helper.getPerfilArray() != null
					&& helper.getPerfilArray().length > 0) {
				consulta += " and conta.imovel.imovelPerfil.id in (:perfil) ";
				parameters.put("perfil", helper.getPerfilArray());
			}
			// Responsavel
			if (helper.getIdResponsavel() != null
					&& !helper.getIdResponsavel().equals("")) {
				consulta += " and conta.usuario.id = :responsavel ";
				parameters.put("responsavel", helper.getIdResponsavel());
			}
			// categoria
			if (helper.getCategoriaArray() != null
					&& helper.getCategoriaArray().length > 0) {
				consulta += " and conta.imovel.id in (select imovelSub.comp_id.imovel.id "
						+ " from ImovelSubcategoria imovelSub where "
						+ " imovelSub.comp_id.subcategoria.categoria.id in (:categoria)) ";
				parameters.put("categoria", helper.getCategoriaArray());
			}
			// esfera poder
			if (helper.getEsferaArray() != null
					&& helper.getEsferaArray().length > 0) {
				consulta += " and conta.imovel.id in ( select clienteImovel.imovel.id from "
						+ " ClienteImovel clienteImovel "
						+ " where clienteImovel.clienteRelacaoTipo.id = 2 "
						+ " and clienteImovel.cliente.clienteTipo.esferaPoder in (:esfera)) ";
				parameters.put("esfera", helper.getEsferaArray());
			}
			
			//grupo
			if (helper.getGrupo() != null && !helper.getGrupo().equals("-1")) {
			    consulta += " and conta.faturamentoGrupo.id = :idFaturamento " ;
			    parameters.put("idFaturamento", helper.getGrupo());
			}

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof String[]) {
					String[] setArray = (String[]) parameters.get(key);
					query.setParameterList(key, setArray);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else if (parameters.get(key) instanceof Date) {
					query.setDate(key, (Date) parameters.get(key));
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retorno = query.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// ******************************************************************************************
	// ******************************************************************************************
	// [UC0764] Gerar Relatorio Contas Canceladas ou Retificadas
	// Flávio Leonardo
	// 09/05/2008
	// metodo q contem a parte invariavel da query
	public Integer pesquisarQuantidadeContasCanceladasRetificadas(
			Map parameters, String consulta,
			RelatorioContasCanceladasRetificadasHelper helper)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try {
			// localidade
			if (helper.getIdLocalidade() != null
					&& !helper.getIdLocalidade().equals("")) {
				consulta += " and conta.localidade.id = :idLocalidade ";
				parameters.put("idLocalidade", new Integer(helper
						.getIdLocalidade()));
			}
			// Imovel Perfil
			if (helper.getPerfilArray() != null
					&& helper.getPerfilArray().length > 0) {
				consulta += " and conta.imovel.imovelPerfil.id in (:perfil) ";
				parameters.put("perfil", helper.getPerfilArray());
			}
			// Responsavel
			if (helper.getIdResponsavel() != null
					&& !helper.getIdResponsavel().equals("")) {
				consulta += " and conta.usuario.id = :responsavel ";
				parameters.put("responsavel", helper.getIdResponsavel());
			}
			// categoria
			if (helper.getCategoriaArray() != null
					&& helper.getCategoriaArray().length > 0) {
				consulta += " and conta.imovel.id in (select imovelSub.comp_id.imovel.id "
						+ " from ImovelSubcategoria imovelSub where "
						+ " imovelSub.comp_id.subcategoria.categoria.id in (:categoria)) ";

				parameters.put("categoria", helper.getCategoriaArray());
			}
			// esfera poder
			if (helper.getEsferaArray() != null
					&& helper.getEsferaArray().length > 0) {
				consulta += " and conta.imovel.id in ( select clienteImovel.imovel.id from "
						+ " ClienteImovel clienteImovel "
						+ " where clienteImovel.clienteRelacaoTipo.id = 2 "
						+ " and clienteImovel.cliente.clienteTipo.esferaPoder in (:esfera)) ";

				parameters.put("esfera", helper.getEsferaArray());
			}
			
			//grupo
			if (helper.getGrupo() != null && !helper.getGrupo().equals("-1")) {
			    consulta += " and conta.faturamentoGrupo.id = :idFaturamento " ;
			    parameters.put("idFaturamento", helper.getGrupo());
			}			

			 if(helper.getIdGerenciaRegional() != null && !helper.getIdGerenciaRegional().equals("")&&
		        		!helper.getIdGerenciaRegional().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
					consulta += " and gerenciaRegional.id = :idGerenciaRegional ";
					parameters.put("idGerenciaRegional",helper.getIdGerenciaRegional());
			}
			
			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof String[]) {
					String[] setArray = (String[]) parameters.get(key);
					query.setParameterList(key, setArray);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else if (parameters.get(key) instanceof Date) {
					query.setDate(key, (Date) parameters.get(key));
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0764] Gerar Relatorio Contas Canceladas ou Retificadas
	 * 
	 * @author Rafael Pinto
	 * @date 11/09/2009
	 * @param RelatorioContasCanceladasRetificadasHelper
	 * @return quantidade de registros
	 */
	public Integer pesquisarQuantidadeContasCanceladasFaturamentoFechado(
			RelatorioContasCanceladasRetificadasHelper helper) {

		Integer retorno = null;

		String consulta;

		Map parameters = new HashMap();
		
		try {
			
			if(helper.getTipoConta().equals("1")){
			consulta = "select count(conta.id) "
					+ " from ContaHistorico conta "
					+ " inner join conta.imovel imovel "
					+ " left join conta.contaMotivoCancelamento motivoCancelamento "
					+ " inner join conta.localidade localidade "
					+ " inner join localidade.unidadeNegocio unidadeNegocio "
					+ " inner join unidadeNegocio.gerenciaRegional gerenciaRegional "
					+ " left join conta.usuario usuario "
					+ " where conta.debitoCreditoSituacaoAtual.id = 3 "
					+ " and conta.anoMesReferenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));
			
			}else{
				consulta = "select count(conta.id) "
					+ " from ContaHistorico conta "
					+ " inner join conta.imovel imovel "
					+ " left join conta.contaMotivoCancelamento motivoCancelamento "
					+ " inner join conta.localidade localidade "
					+ " inner join localidade.unidadeNegocio unidadeNegocio "
					+ " inner join unidadeNegocio.gerenciaRegional gerenciaRegional "
					+ " left join conta.usuario usuario "
					+ " where (conta.debitoCreditoSituacaoAtual.id = 8 or conta.debitoCreditoSituacaoAtual.id = 12) "
					+ " and conta.anoMesReferenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));

			}

			// Motivo
			if (helper.getMotivoArray() != null
					&& helper.getMotivoArray().length > 0) {
				consulta += " and motivoCancelamento.id in (:motivo) ";
				parameters.put("motivo", helper.getMotivoArray());
			}

			if (helper.getPeriodoInicial() != null
					&& helper.getPeriodoFinal() != null
					&& !helper.getPeriodoInicial().equals("")
					&& !helper.getPeriodoFinal().equals("")) {

				consulta += " and  conta.dataCancelamento between :dt1 and :dt2";

				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
				Date in1 = Util.converteStringParaDate(helper
						.getPeriodoInicial());
				String inicial = format.format(in1);

				Date f1 = Util.converteStringParaDate(helper.getPeriodoFinal());
				String final1 = format.format(f1);

				parameters.put("dt1", inicial);
				parameters.put("dt2", final1);

			}

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.valorDebitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";
				parameters.put("valor", Util
						.formatarMoedaRealparaBigDecimal(helper.getValor()));
			}

			retorno = this.pesquisarQuantidadeContasCanceladasRetificadas(
					parameters, consulta, helper);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// -------------Parte de contas canceladas
	// contas canceladas com faturamento fechado(pesquisa em conta historico)
	public Collection pesquisarContasCanceladasFaturamentoFechado(
			RelatorioContasCanceladasRetificadasHelper helper) {
		Collection retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			if(helper.getTipoConta().equals("1")){
			consulta = "select conta "
					+ " from ContaHistorico conta "
					+ " inner join conta.imovel imovel "
					+ " inner join fetch conta.localidade localidade "
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio "
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional " 
					+ " left join fetch conta.usuario usuario "
					+ " left join fetch conta.contaMotivoCancelamento motivoCancelamento "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where conta.debitoCreditoSituacaoAtual.id = 3 "
					+ " and conta.anoMesReferenciaContabil = :anoMes ";
			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));
			
			}else{
				/**
				 * Incluir opção de contas prescritas no relatório de contas canceladas/retificadas
				 * 
				 * @author Wellington Rocha
				 * @date 04/06/2012
				 * */
				consulta = "select conta "
					+ " from ContaHistorico conta "
					+ " inner join conta.imovel imovel "
					+ " inner join fetch conta.localidade localidade "
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio "
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional " 
					+ " left join fetch conta.usuario usuario "
					+ " left join fetch conta.contaMotivoCancelamento motivoCancelamento "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where (conta.debitoCreditoSituacaoAtual.id = 8 or conta.debitoCreditoSituacaoAtual.id = 12)  "
					+ " and conta.anoMesReferenciaContabil = :anoMes ";
				parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));
			}

			// Motivo
			if (helper.getMotivoArray() != null
					&& helper.getMotivoArray().length > 0) {
				consulta += " and motivoCancelamento.id in (:motivo) ";
				parameters.put("motivo", helper.getMotivoArray());
			}

			if (helper.getPeriodoInicial() != null
					&& helper.getPeriodoFinal() != null
					&& !helper.getPeriodoInicial().equals("")
					&& !helper.getPeriodoFinal().equals("")) {
				consulta += " and  conta.dataCancelamento between :dt1 and :dt2";

				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
				Date in1 = Util.converteStringParaDate(helper
						.getPeriodoInicial());
				String inicial = format.format(in1);
				Date f1 = Util.converteStringParaDate(helper.getPeriodoFinal());
				String final1 = format.format(f1);
				parameters.put("dt1", inicial);
				parameters.put("dt2", final1);

			}

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.valorDebitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";
				parameters.put("valor", Util
						.formatarMoedaRealparaBigDecimal(helper.getValor()));
			}

	        if(helper.getIdGerenciaRegional() != null && !helper.getIdGerenciaRegional().equals("")&&
	        		!helper.getIdGerenciaRegional().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
				consulta += " and gerenciaRegional.id = :idGerenciaRegional ";
				parameters.put("idGerenciaRegional",helper.getIdGerenciaRegional());
			}
			
			retorno = this.pesquisarContasCanceladasRetificadas(parameters,
					consulta, helper);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	/**
	 * [UC0764] Gerar Relatorio Contas Canceladas ou Retificadas
	 * 
	 * @author Rafael Pinto
	 * @date 11/09/2009
	 * @param RelatorioContasCanceladasRetificadasHelper
	 * @return quantidade de registros
	 */
	public Integer pesquisarQuantidadeContasCanceladasFaturamentoAberto(
			RelatorioContasCanceladasRetificadasHelper helper) {

		Integer retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			if(helper.getTipoConta().equals("1")){
			consulta = "select count(conta.id) "
					+ " from Conta conta "
					+ " inner join conta.imovel imovel "
					+ " left join conta.contaMotivoCancelamento motivoCancelamento "
					+ " left join conta.usuario usuario "
					+ " left join conta.registroAtendimento registroAtendimento "
					+ " inner join conta.localidade localidade "
					+ " inner join localidade.unidadeNegocio unidadeNegocio "		
					+ " inner join localidade.gerenciaRegional gerenciaRegional " 
					+ " where conta.debitoCreditoSituacaoAtual.id = 3 "
					+ " and conta.referenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));
			
			}else{
				/**
				 * Incluir opção de contas prescritas no relatório de contas canceladas/retificadas
				 * 
				 * @author Wellington Rocha
				 * @date 04/06/2012
				 * */
				consulta = "select count(conta.id) "
					+ " from Conta conta "
					+ " inner join conta.imovel imovel "
					+ " left join conta.contaMotivoCancelamento motivoCancelamento "
					+ " left join conta.usuario usuario "
					+ " left join conta.registroAtendimento registroAtendimento "
					+ " inner join conta.localidade localidade "
					+ " inner join localidade.unidadeNegocio unidadeNegocio "		
					+ " inner join localidade.gerenciaRegional gerenciaRegional " 
					+ " where (conta.debitoCreditoSituacaoAtual.id = 8 or conta.debitoCreditoSituacaoAtual.id = 12)  "
					+ " and conta.referenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));
				
			}

			// Motivo
			if (helper.getMotivoArray() != null
					&& helper.getMotivoArray().length > 0) {
				consulta += " and motivoCancelamento.id in (:motivo) ";
				parameters.put("motivo", helper.getMotivoArray());
			}

			if (helper.getPeriodoInicial() != null
					&& helper.getPeriodoFinal() != null
					&& !helper.getPeriodoInicial().equals("")
					&& !helper.getPeriodoFinal().equals("")) {

				consulta += " and  conta.dataCancelamento between :dt1 and :dt2";

				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
				Date in1 = Util.converteStringParaDate(helper
						.getPeriodoInicial());
				String inicial = format.format(in1);

				Date f1 = Util.converteStringParaDate(helper.getPeriodoFinal());
				String final1 = format.format(f1);

				parameters.put("dt1", inicial);
				parameters.put("dt2", final1);

			}

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.debitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";
				parameters.put("valor", Util
						.formatarMoedaRealparaBigDecimal(helper.getValor()));
			}
			
			retorno = this.pesquisarQuantidadeContasCanceladasRetificadas(
					parameters, consulta, helper);

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// contas canceladas com faturamento Aberto(pesquisa em conta)
	public Collection pesquisarContasCanceladasFaturamentoAberto(
			RelatorioContasCanceladasRetificadasHelper helper) {
		Collection retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			if(helper.getTipoConta().equals("1")){
			consulta = "select conta "
					+ " from Conta conta "
					+ " inner join conta.imovel imovel "
					+ " left join fetch conta.contaMotivoCancelamento motivoCancelamento "
					+ " left join fetch conta.usuario usuario "
					+ " left join fetch conta.registroAtendimento registroAtendimento "
					+ " inner join fetch conta.localidade localidade "
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio " 
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where conta.debitoCreditoSituacaoAtual.id = 3 "
					+ " and conta.referenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));
			
			}else{
				/**
				 * Incluir opção de contas prescritas no relatório de contas canceladas/retificadas
				 * 
				 * @author Wellington Rocha
				 * @date 04/06/2012
				 * */
				consulta = "select conta "
					+ " from Conta conta "
					+ " inner join conta.imovel imovel "
					+ " left join fetch conta.contaMotivoCancelamento motivoCancelamento "
					+ " left join fetch conta.usuario usuario "
					+ " left join fetch conta.registroAtendimento registroAtendimento "
					+ " inner join fetch conta.localidade localidade "
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio " 
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where (conta.debitoCreditoSituacaoAtual.id = 8 or conta.debitoCreditoSituacaoAtual.id = 12)"
					+ " and conta.referenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));
			}

			// Motivo
			if (helper.getMotivoArray() != null
					&& helper.getMotivoArray().length > 0) {
				consulta += " and motivoCancelamento.id in (:motivo) ";
				parameters.put("motivo", helper.getMotivoArray());
			}

			if (helper.getPeriodoInicial() != null
					&& helper.getPeriodoFinal() != null
					&& !helper.getPeriodoInicial().equals("")
					&& !helper.getPeriodoFinal().equals("")) {
				consulta += " and  conta.dataCancelamento between :dt1 and :dt2";

				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
				Date in1 = Util.converteStringParaDate(helper
						.getPeriodoInicial());
				String inicial = format.format(in1);

				Date f1 = Util.converteStringParaDate(helper.getPeriodoFinal());
				String final1 = format.format(f1);

				parameters.put("dt1", inicial);
				parameters.put("dt2", final1);

			}

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.debitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";
				parameters.put("valor", Util
						.formatarMoedaRealparaBigDecimal(helper.getValor()));
			}
			
	        if(helper.getIdGerenciaRegional() != null && !helper.getIdGerenciaRegional().equals("")&&
	        		!helper.getIdGerenciaRegional().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
				consulta += " and gerenciaRegional.id = :idGerenciaRegional ";
				parameters.put("idGerenciaRegional",helper.getIdGerenciaRegional());
			}
				

			retorno = this.pesquisarContasCanceladasRetificadas(parameters,
					consulta, helper);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	/**
	 * [UC0764] Gerar Relatorio Contas Canceladas ou Retificadas
	 * 
	 * @author Rafael Pinto
	 * @date 11/09/2009
	 * @param RelatorioContasCanceladasRetificadasHelper
	 * @return quantidade de registros
	 */

	public Integer pesquisarQuantidadeContasRetificadasFaturamentoFechado(
			RelatorioContasCanceladasRetificadasHelper helper) {

		Integer retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			consulta = "select count(conta.id) "
					+ " from ContaHistorico conta "
					+ " inner join conta.imovel imovel "
					+ " left join conta.contaMotivoRetificacao contaMotivoRetificacao "
					+ " inner join conta.localidade localidade "
					+ " inner join localidade.unidadeNegocio unidadeNegocio "
					+ " inner join localidade.gerenciaRegional gerenciaRegional " 
					+ " where conta.debitoCreditoSituacaoAtual.id = 4 "
					+ " and conta.anoMesReferenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId ";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.valorDebitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";

				String valor = helper.getValor().replace(".", "");
				parameters
						.put("valor", new BigDecimal(valor.replace(",", ".")));
			}
			
			 if(helper.getIdGerenciaRegional() != null && !helper.getIdGerenciaRegional().equals("")&&
		        		!helper.getIdGerenciaRegional().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
					consulta += " and gerenciaRegional.id = :idGerenciaRegional ";
					parameters.put("idGerenciaRegional",helper.getIdGerenciaRegional());
				}
			
			retorno = this.pesquisarQuantidadeContasCanceladasRetificadas(
					parameters, consulta, helper);

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// ------------------Parte de contas retificadas
	// contas retificadas com faturamento fechado(pesquisa em conta historico)
	public Collection pesquisarContasRetificadasFaturamentoFechado(
			RelatorioContasCanceladasRetificadasHelper helper) {
		Collection retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			consulta = "select conta "
					+ " from ContaHistorico conta "
					+ " left join fetch conta.contaMotivoRetificacao contaMotivoRetificacao "
					+ " inner join conta.imovel imovel "
					+ " inner join fetch conta.localidade localidade "
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio "
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where conta.debitoCreditoSituacaoAtual.id = 4 "
					+ " and conta.anoMesReferenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId ";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.valorDebitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";

				String valor = helper.getValor().replace(".", "");
				parameters
						.put("valor", new BigDecimal(valor.replace(",", ".")));
			}
			
			retorno = this.pesquisarContasCanceladasRetificadas(parameters,
					consulta, helper);

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	/**
	 * [UC0764] Gerar Relatorio Contas Canceladas ou Retificadas
	 * 
	 * @author Rafael Pinto
	 * @date 11/09/2009
	 * @param RelatorioContasCanceladasRetificadasHelper
	 * @return quantidade de registros
	 */
	public Integer pesquisarQuantidadeContasRetificadasFaturamentoAberto(
			RelatorioContasCanceladasRetificadasHelper helper) {

		Integer retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			consulta = "select count(conta.id) "
					+ " from Conta conta "
					+ " left join conta.contaMotivoRetificacao contaMotivoRetificacao "
					+ " inner join conta.imovel imovel "
					+ " inner join conta.localidade localidade "
					+ " inner join localidade.unidadeNegocio unidadeNegocio "
					+ " inner join localidade.gerenciaRegional gerenciaRegional "
					+ " where conta.debitoCreditoSituacaoAtual.id = 4 "
					+ " and conta.referenciaContabil = :anoMes ";

			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId ";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {

				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.debitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";

				String valor = helper.getValor().replace(".", "");

				parameters
						.put("valor", new BigDecimal(valor.replace(",", ".")));
			}
			
			retorno = this.pesquisarQuantidadeContasCanceladasRetificadas(
					parameters, consulta, helper);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// contas retificadas com faturamento Aberto(pesquisa em conta)
	public Collection pesquisarContasRetificadasFaturamentoAberto(
			RelatorioContasCanceladasRetificadasHelper helper) {
		Collection retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			consulta = "select conta "
					+ " from Conta conta "
					+ " left join fetch conta.contaMotivoRetificacao motivo "
					+ " inner join conta.imovel imovel "
					+ " inner join fetch conta.localidade localidade "
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio "
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where conta.debitoCreditoSituacaoAtual.id = 4 "
					+ " and conta.referenciaContabil = :anoMes ";
			parameters.put("anoMes", Util
					.formatarMesAnoComBarraParaAnoMes(helper.getMesAno()));

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId ";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.debitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";
				String valor = helper.getValor().replace(".", "");
				parameters
						.put("valor", new BigDecimal(valor.replace(",", ".")));
				// parameters.put("valor", new
				// BigDecimal(helper.getValor().replace(",",".")));
			}
			

			retorno = this.pesquisarContasCanceladasRetificadas(parameters,
					consulta, helper);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}
	
//	 contas Retificadas(pesquisa em conta)
	public Collection pesquisarContasRetificadasValorNovoContaAberta(
			RelatorioContasCanceladasRetificadasHelper helper, String idImovel,
			String anoMesReferenciaContaOriginal) {
		Collection retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			consulta = "select conta "
					+ " from Conta conta "
					+ " left join fetch conta.contaMotivoRetificacao motivo "
					+ " inner join fetch conta.localidade localidade "
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio "
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional "
					+ " left join fetch conta.usuario "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where conta.debitoCreditoSituacaoAtual.id in (1, 5) and "
					+ " conta.imovel.id = :idImovel"
					+ " and conta.referencia = :anoMes ";
			parameters.put("anoMes", anoMesReferenciaContaOriginal);

			// Motivo
			if (helper.getMotivoArray() != null
					&& helper.getMotivoArray().length > 0) {
				consulta += " and conta.contaMotivoRetificacao.id in (:motivo) ";
				parameters.put("motivo", helper.getMotivoArray());
			}

			if (helper.getPeriodoInicial() != null
					&& helper.getPeriodoFinal() != null
					&& !helper.getPeriodoInicial().equals("")
					&& !helper.getPeriodoFinal().equals("")) {
				consulta += " and  conta.dataRetificacao between :dt1 and :dt2";

				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
				Date in1 = Util.converteStringParaDate(helper
						.getPeriodoInicial());
				String inicial = format.format(in1);

				Date f1 = Util.converteStringParaDate(helper.getPeriodoFinal());
				String final1 = format.format(f1);

				parameters.put("dt1", inicial);
				parameters.put("dt2", final1);

			}

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId ";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			parameters.put("idImovel", new Integer(idImovel));

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.debitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";
				// parameters.put("valor", new
				// BigDecimal(helper.getValor().replace(",",".")));
				String valor = helper.getValor().replace(".", "");
				parameters
						.put("valor", new BigDecimal(valor.replace(",", ".")));
			}

			retorno = this.pesquisarContasCanceladasRetificadas(parameters,
					consulta, helper);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// contas Retificadas(pesquisa em conta)
	public Collection pesquisarContasRetificadasValorNovoConta(
			RelatorioContasCanceladasRetificadasHelper helper, String idImovel,
			String anoMesReferenciaContaOriginal) {
		Collection retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			consulta = "select conta "
					+ " from Conta conta "
					+ " left join fetch conta.contaMotivoRetificacao motivo "
					+ " inner join fetch conta.localidade localidade "
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio "
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional "
					+ " left join fetch conta.usuario "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where conta.debitoCreditoSituacaoAtual.id in (1, 4, 5) and "
					+ " conta.imovel.id = :idImovel"
					+ " and conta.referencia = :anoMes "
					+ " and conta.dataRetificacao is not null";
			parameters.put("anoMes", anoMesReferenciaContaOriginal);

			// Motivo
			if (helper.getMotivoArray() != null
					&& helper.getMotivoArray().length > 0) {
				consulta += " and conta.contaMotivoRetificacao.id in (:motivo) ";
				parameters.put("motivo", helper.getMotivoArray());
			}

			if (helper.getPeriodoInicial() != null
					&& helper.getPeriodoFinal() != null
					&& !helper.getPeriodoInicial().equals("")
					&& !helper.getPeriodoFinal().equals("")) {
				consulta += " and  conta.dataRetificacao between :dt1 and :dt2";

				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
				Date in1 = Util.converteStringParaDate(helper
						.getPeriodoInicial());
				String inicial = format.format(in1);

				Date f1 = Util.converteStringParaDate(helper.getPeriodoFinal());
				String final1 = format.format(f1);

				parameters.put("dt1", inicial);
				parameters.put("dt2", final1);

			}

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId ";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			parameters.put("idImovel", new Integer(idImovel));

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.debitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";
				// parameters.put("valor", new
				// BigDecimal(helper.getValor().replace(",",".")));
				String valor = helper.getValor().replace(".", "");
				parameters
						.put("valor", new BigDecimal(valor.replace(",", ".")));
			}

			retorno = this.pesquisarContasCanceladasRetificadas(parameters,
					consulta, helper);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// contas Retificadas(pesquisa em contaHistorico)
	public Collection pesquisarContasRetificadasValorNovoContaHistorico(
			RelatorioContasCanceladasRetificadasHelper helper, String idImovel,
			String anoMesReferenciaContaOriginal) {
		Collection retorno = null;

		String consulta;

		Map parameters = new HashMap();

		try {
			consulta = "select conta "
					+ " from ContaHistorico conta "
					+ " left join fetch conta.contaMotivoRetificacao motivo "
					+ " inner join fetch conta.localidade localidade"
					+ " inner join fetch localidade.unidadeNegocio unidadeNegocio "
					+ " inner join fetch localidade.gerenciaRegional gerenciaRegional "
					+ " left join fetch conta.usuario "
					+ " left join fetch conta.faturamentoGrupo faturamentoGrupo "
					+ " where conta.debitoCreditoSituacaoAtual.id in (1,4, 5) "
					+ " and conta.imovel.id = " + idImovel + " "
					+ " and conta.anoMesReferenciaConta = "
					+ anoMesReferenciaContaOriginal + " ";

			// Motivo
			if (helper.getMotivoArray() != null
					&& helper.getMotivoArray().length > 0) {
				consulta += " and conta.contaMotivoRetificacao.id in (:motivo) ";
				parameters.put("motivo", helper.getMotivoArray());
			}

			if (helper.getUnidadeNegocio() != null
					&& !helper.getUnidadeNegocio().equals("")) {
				consulta += " and conta.localidade.unidadeNegocio.id = :unId ";
				parameters.put("unId", Integer.parseInt(helper
						.getUnidadeNegocio()));
			}

			if (helper.getPeriodoInicial() != null
					&& helper.getPeriodoFinal() != null
					&& !helper.getPeriodoInicial().equals("")
					&& !helper.getPeriodoFinal().equals("")) {
				consulta += " and  conta.dataRetificacao between :dt1 and :dt2";

				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
				Date in1 = Util.converteStringParaDate(helper
						.getPeriodoInicial());
				String inicial = format.format(in1);
				Date f1 = Util.converteStringParaDate(helper.getPeriodoFinal());
				String final1 = format.format(f1);
				parameters.put("dt1", inicial);
				parameters.put("dt2", final1);

			}

			// valor
			if (helper.getValor() != null && !helper.getValor().equals("")) {
				consulta += " and ((conta.valorAgua + conta.valorEsgoto + conta.valorDebitos "
						+ " - (conta.valorCreditos + conta.valorImposto)) >= :valor)";
				String valor = helper.getValor().replace(".", "");
				parameters
						.put("valor", new BigDecimal(valor.replace(",", ".")));
				// parameters.put("valor", new
				// BigDecimal(helper.getValor().replace(",",".")));
			}

			retorno = this.pesquisarContasCanceladasRetificadas(parameters,
					consulta, helper);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// ******************************************************************************************

	// ******************************************************************************************

	/**
	 * @author Vivianne Sousa
	 * @date 15/05/2008
	 * 
	 * @param
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMaxIdConta() throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT MAX(conta.id) FROM Conta conta ";

			retorno = (Integer) session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 15/05/2008
	 * 
	 * @param
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMaxIdContaHistorico()
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT MAX(contaHistorico.id) FROM ContaHistorico contaHistorico ";

			retorno = (Integer) session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0000] - Pré-Faturar Grupo de Faturamento
	 * 
	 * Obter o registro da tabela FaturamentoAtivCronRota referente a rota que
	 * está sendo pré-faturada
	 * 
	 * @author Raphael Rossiter
	 * @date 09/04/2008
	 * 
	 * @param idRota
	 * @param idFaturamentoAtividade
	 * @param idFaturamentoGrupo
	 * @param anoMesReferencia
	 * @return FaturamentoAtivCronRota
	 * @throws ErroRepositorioException
	 */
	public FaturamentoAtivCronRota pesquisarFaturamentoAtivCronRota(
			Integer idRota, Integer idFaturamentoAtividade,
			Integer idFaturamentoGrupo, Integer anoMesReferencia)
			throws ErroRepositorioException {

		FaturamentoAtivCronRota retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT facr "
					+ "FROM FaturamentoAtivCronRota facr "
					+ "INNER JOIN facr.rota rota "
					+ "INNER JOIN facr.faturamentoAtividadeCronograma ftac "
					+ "INNER JOIN ftac.faturamentoAtividade ftat "
					+ "INNER JOIN fetch ftac.faturamentoGrupoCronogramaMensal ftcm "
					+ "INNER JOIN fetch ftcm.faturamentoGrupo ftgr "
					+ "WHERE rota.id = :idRota AND ftat.id = :idFaturamentoAtividade "
					+ "AND ftgr.id = :idFaturamentoGrupo AND ftcm.anoMesReferencia = :anoMesReferencia ";

			retorno = (FaturamentoAtivCronRota) session.createQuery(consulta)
					.setInteger("idRota", idRota).setInteger(
							"idFaturamentoAtividade", idFaturamentoAtividade)
					.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [FS0002] - Verificar Situação Especial de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 17/04/2008
	 * 
	 * @param rota
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @throws ErroRepositorioException
	 */
	/**
	 * 
	 * Alteracao para enviar informacao se a rota é alternativa ou nao, para 
	 * corrigir o problema da geracao da rota do IS para os grupos 101 e 401
	 */
	public Collection pesquisarImovelGerarArquivoTextoFaturamento(
			Rota rota, int numeroPaginas, int quantidadeRegistros,
			SistemaParametro sistemaParametro,Integer idImovelCondominio) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gerenciaRegional.nome, "// 0
					+ "localidade.id, localidade.descricao, "// 1,2
					+ "imovel.nomeImovel, clienteUsuario.nome, "// 3,4
					+ "setorComercial.codigo, quadra.numeroQuadra, "// 5,6
					+ "imovel.lote, imovel.subLote, "// 7,8
					+ "clienteResposanvel.id, clienteResposanvel.nome, "// 9,10
					+ "ligacaoAguaSituacao.id, ligacaoEsgotoSituacao.id, "// 11,12
					+ "ligacaoAgua.numeroConsumoMinimoAgua, ligacaoEsgoto.consumoMinimo, "// 13,14
					+ "ligacaoEsgoto.percentualAguaConsumidaColetada, "// 15
					+ "faturamentoSituacaoTipo.indicadorParalisacaoFaturamento, "// 16
					+ "faturamentoSituacaoTipo.indicadorValidoAgua, " // 17
					+ "faturamentoSituacaoTipo.indicadorValidoEsgoto, "// 18
					+ "imovelCondominio.id, imovel.indicadorImovelCondominio, "// 19,20
					+ "imovelPerfil.id, consumoTarifa.id, imovel.id, pocoTipo.id, "// 21,22,23,24
					+ "consumoTarifa.tarifaTipoCalculo.id, "// 25
					+ "setorComercial.id, "// 26
					+ "imovel.numeroSequencialRota, "// 27
					+ "gerenciaRegional.id, "// 28
					+ "ligacaoAguaSituacao.indicadorFaturamentoSituacao,"// 29
					+ "ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, "// 30
					+ "ice.id, "// 31
					+ "clienteUsuario.cpf, "// 32
					+ "clienteUsuario.cnpj, "// 33
					+ "hidAgua.id, "// 34
					+ "hidPoco.id, "// 35
					+ "ligacaoAguaSituacao.indicadorAbastecimento, " // 36
					+ "ligacaoAgua.id, "// 37
					+ "ligacaoAguaSituacao.descricao, "// 38
					+ "leiturista.id, "// 39
					+ "empresa.id, "// 40
					+ "quadraFace.id, "// 41
					+ "quadraFace.numeroQuadraFace, "// 42
					+ "imovel.numeroMorador, "// 43
					+ "medTipoAgua.id, "// 44
					+ "medTipoPoco.id, "// 45
					+ "ligacaoAgua.numeroLacre, "// 46
					+ "logradouroBairro.id, " // 47
					+ "logradouro.id, " // 48
					+ "logradouro.nome, " // 49
					+ "bairro.nome, " // 50
					+ "imovel.numeroImovel, " // 51
					+ "imovel.complementoEndereco, "// 52
					+ "hidLocInsAgua.id, "// 53
					+ "hidAgua.dataInstalacao, "// 54
					+ "hidProtAgua.id, "// 55
					+ "hidLocInsPoco.id, "// 56
					+ "hidPoco.dataInstalacao, "// 57
					+ "hidProtPoco.id, "// 58
					+ "usu.login, "// 59
					+ "usu.senha, "// 60
					+ "faturamentoSituacaoTipo.id, " //61
					+ "imovel.codigoDebitoAutomatico, "//62
					+ "ligacaoEsgoto.percentualAlternativo, "//63
					+ "ligacaoEsgoto.numeroConsumoPercentualAlternativo, "//64
					+ "faturamentoSituacaoTipo.indicadorParalisacaoLeitura, "// 65
					+ "ligacaoAguaSituacao.indicadorConsumoReal, "// 66
					+ "ligacaoAguaSituacao.numeroDiasCorte, "// 67
					+ "ligacaoAgua.dataCorte, "// 68
					+ "imovel.indicadorImovelAreaComum, "// 69
					/*  Adicionando campos para enviar na rota */
					+ "ligacaoAgua.dataLigacao, " //70 
					+ "ligacaoEsgoto.dataLigacao, " //71
					/*  Adicionando informacao do nome da conta */
					+ "clienteImoveisReposanvel.cliente.id, " //72
					+ "clienteImoveisReposanvel.indicadorNomeConta, " //73
					+ "clienteImoveisUsuario.cliente.id, " //74
					+ "clienteImoveisUsuario.indicadorNomeConta " //75
					+ "FROM Imovel imovel "
					+ "INNER JOIN imovel.localidade localidade "
					+ "INNER JOIN localidade.gerenciaRegional gerenciaRegional "
					+ "INNER JOIN imovel.setorComercial setorComercial "
					+ "INNER JOIN imovel.quadra quadra "
					+ "INNER JOIN quadra.rota rota "
					+ "INNER JOIN imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "INNER JOIN imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "INNER JOIN imovel.imovelPerfil imovelPerfil "
					+ "INNER JOIN imovel.consumoTarifa consumoTarifa "
					+ "LEFT JOIN imovel.quadraFace quadraFace "
					+ "LEFT JOIN imovel.ligacaoAgua ligacaoAgua "
					+ "LEFT JOIN ligacaoAgua.hidrometroInstalacaoHistorico hidAgua "
					+ "LEFT JOIN hidAgua.medicaoTipo medTipoAgua "
					+ "LEFT JOIN hidAgua.hidrometroLocalInstalacao hidLocInsAgua "
					+ "LEFT JOIN hidAgua.hidrometroProtecao hidProtAgua "
					+ "LEFT JOIN imovel.hidrometroInstalacaoHistorico hidPoco "
					+ "LEFT JOIN hidPoco.medicaoTipo medTipoPoco "
					+ "LEFT JOIN hidPoco.hidrometroLocalInstalacao hidLocInsPoco "
					+ "LEFT JOIN hidPoco.hidrometroProtecao hidProtPoco "
					+ "LEFT JOIN imovel.ligacaoEsgoto ligacaoEsgoto "
					+ "LEFT JOIN imovel.pocoTipo pocoTipo "
					+ "LEFT JOIN imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ "LEFT JOIN imovel.imovelCondominio imovelCondominio "
					+ "LEFT JOIN imovel.clienteImoveis clienteImoveisUsuario WITH "
					+ "(clienteImoveisUsuario.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ ") AND clienteImoveisUsuario.dataFimRelacao IS NULL "
					+ "LEFT JOIN clienteImoveisUsuario.cliente clienteUsuario "
					+ "LEFT JOIN imovel.clienteImoveis clienteImoveisReposanvel WITH "
					+ "(clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ ") and clienteImoveisReposanvel.dataFimRelacao IS NULL "
					+ "LEFT JOIN clienteImoveisReposanvel.cliente clienteResposanvel "
					+ "LEFT JOIN imovel.imovelContaEnvio ice "
					+ "LEFT JOIN rota.leiturista leiturista "
					+ "LEFT JOIN rota.empresa empresa "
					+ "LEFT JOIN leiturista.usuario usu "
					+ "LEFT JOIN imovel.logradouroBairro logradouroBairro "
					+ "LEFT JOIN logradouroBairro.logradouro logradouro "
					+ "LEFT JOIN logradouroBairro.bairro bairro "
					+ "LEFT JOIN imovel.rotaAlternativa rtAlternativa "
					+ "WHERE  imovelPerfil.indicadorGerarDadosLeitura = 1 AND imovel.indicadorExclusao <> :idExclusao and rtAlternativa.id is null ";
			
			if( rota != null &&  rota.getId() != null && !rota.getId().equals("")){
				
				if (!rota.getIndicadorRotaAlternativa().equals(new Short("1")))
					consulta += " AND rota.id = " + rota.getId() 
						+ " AND imovel.rotaAlternativa is null ";
				else 
					consulta += " AND imovel.rotaAlternativa.id = " + rota.getId() ; 
			}
			
			if(idImovelCondominio != null && !idImovelCondominio.equals("")){
				consulta += " AND imovelCondominio.id ="+idImovelCondominio ;
			}else{
				consulta += " AND imovelCondominio.id is null ";
			}
			if (sistemaParametro.getNomeAbreviadoEmpresa() != null
					&& sistemaParametro.getNomeAbreviadoEmpresa().equals(
							"COMPESA")) {
				consulta = consulta
						+ " ORDER BY imovel.numeroSequencialRota, setorComercial.codigo,quadra.numeroQuadra,imovel.lote,imovel.subLote ";

			} else {
				consulta = consulta
						//+ " ORDER BY imovel.indicadorImovelCondominio,imovel.numeroSequencialRota,imovel.lote,imovel.subLote ";
				/*
				 * 
				 * Alteração feita para gerar a rota ordenada pela inscrição.
				 */
						+ " ORDER BY imovel.indicadorImovelCondominio,localidade.id, setorComercial.codigo,quadra.numeroQuadra,imovel.lote,imovel.subLote ";
			}

			if(rota != null && rota.getId() != null && !rota.getId().equals("")){
				retorno = session.createQuery(consulta)
						.setShort("idExclusao", Imovel.IMOVEL_EXCLUIDO)
						.setFirstResult(numeroPaginas)
						.setMaxResults(quantidadeRegistros)
						.list();
			}else{
				retorno = session.createQuery(consulta)
				.setShort("idExclusao", Imovel.IMOVEL_EXCLUIDO).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 17/04/2008
	 * 
	 * @param idRota
	 * @param anoMesReferencia
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarArquivoTextoRoteiroEmpresa(
			Integer idRota, Integer anoMesReferencia)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select txre.id,sitl.id "
					+ "from ArquivoTextoRoteiroEmpresa txre "
					+ "inner join txre.rota rota "
					+ "inner join txre.situacaoTransmissaoLeitura sitl "
					+ "where rota.id = :idRota and txre.anoMesReferencia = :anoMesReferencia ";

			retorno = (Object[]) session
					.createQuery(consulta).setInteger("idRota", idRota)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 23/04/2008
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaGerarArquivoTextoFaturamento(
			Integer idImovel, Integer anoMesReferencia,Integer idFaturamentoGrupo)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gerenciaRegional.nome, "// 0
					+ "localidade.id, localidade.descricao, "// 1,2
					+ "clienteUsuario.nome, "// 3
					+ "conta.codigoSetorComercial, conta.quadra, "// 4,5
					+ "conta.lote, conta.subLote, "// 6,7
					+ "clienteResposanvel.id, clienteResposanvel.nome, "// 8,9
					+ "ligacaoAguaSituacao.id, ligacaoEsgotoSituacao.id, "// 10,11
					+ "conta.dataVencimentoConta, conta.dataValidadeConta, "// 12,13
					+ "conta.digitoVerificadorConta, conta.percentualEsgoto, "// 14,15
					+ "imovelPerfil.id, consumoTarifa.id, conta.id, conta.referencia, "// 16,17,18,19
					+ "gerenciaRegional.id, "// 20
					+ "ligacaoAguaSituacao.indicadorFaturamentoSituacao, "// 21
					+ "ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, "// 22
					+ "ice.id, "// 23
					+ "clienteUsuario.cpf, "// 24
					+ "clienteUsuario.cnpj "// 25
					+ "FROM Conta conta "
					+ "INNER JOIN conta.imovel imovel "
					+ "INNER JOIN conta.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "INNER JOIN conta.localidade localidade "
					+ "INNER JOIN localidade.gerenciaRegional gerenciaRegional "
					+ "INNER JOIN conta.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "INNER JOIN conta.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "INNER JOIN conta.imovelPerfil imovelPerfil "
					+ "INNER JOIN conta.consumoTarifa consumoTarifa "
					+ "LEFT JOIN conta.clienteContas clienteContasUsuario WITH "
					+ "(clienteContasUsuario.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ ") "
					+ "LEFT JOIN clienteContasUsuario.cliente clienteUsuario "
					+ "LEFT JOIN conta.clienteContas clienteContasReposanvel WITH "
					+ "(clienteContasReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ ") "
					+ "LEFT JOIN clienteContasReposanvel.cliente clienteResposanvel "
					+ "LEFT JOIN imovel.imovelContaEnvio ice "
					+ "LEFT JOIN conta.faturamentoGrupo fg "
					+ "WHERE imovel.id = :idImovel AND "
					+ " conta.referencia = :anoMesReferencia "
					+ "AND debitoCreditoSituacaoAtual.id = :preFaturada "
					+ "and not exists ( from MovimentoContaPrefaturada mcpf where mcpf.anoMesReferenciaPreFaturamento = fg.anoMesReferencia and imovel.id = mcpf.imovel.id  )";

					//+ "AND fg.id = :idFaturamentoGrupo";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setInteger("anoMesReferencia",
					anoMesReferencia)
					.setInteger("preFaturada",DebitoCreditoSituacao.PRE_FATURADA)
					//.setInteger("idFaturamentoGrupo",idFaturamentoGrupo)
					.setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0002] - Obter dados dos serviços de parcelamento
	 * 
	 * @author Raphael Rossiter
	 * @date 25/04/2008
	 * 
	 * @param conta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoCobradoDeParcelamento(Conta conta)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT " +
                "  dbcb.numeroPrestacaoDebito, " +
                "  (dbcb.numeroPrestacao - COALESCE(dbcb.numeroParcelaBonus,0)) as totalParcela, " +
                "  SUM(dbcb.valorPrestacao), " +
                "  dbcb.debitoTipo.codigoConstante " +
                "FROM " +
                "  DebitoCobrado dbcb " +
                "  INNER JOIN dbcb.conta conta " +
                "  INNER JOIN dbcb.financiamentoTipo fntp " +
                "WHERE " +
                "  conta.id = :idConta AND " +
                "  fntp.id IN(:agua, :esgoto, :servico) " +
                " GROUP BY  dbcb.numeroPrestacaoDebito,  (dbcb.numeroPrestacao - COALESCE(dbcb.numeroParcelaBonus,0)),  dbcb.debitoTipo.codigoConstante " ;


			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", conta.getId()).setInteger("agua",
					FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger("esgoto",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
					"servico", FinanciamentoTipo.PARCELAMENTO_SERVICO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0002] - Obter dados dos serviços de parcelamento
	 * 
	 * @author Raphael Rossiter
	 * @date 25/04/2008
	 * 
	 * @param conta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoCobradoNaoParcelamento(Conta conta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT new DebitoCobrado(dbcb.anoMesReferenciaDebito, dbcb.numeroPrestacaoDebito, "
					+ "dbcb.numeroPrestacao - COALESCE(dbcb.numeroParcelaBonus,0), dbcb.valorPrestacao, "
					+ "dbtp) "// 0
					+ "FROM DebitoCobrado dbcb "
					+ "INNER JOIN dbcb.conta conta "
					+ "INNER JOIN dbcb.financiamentoTipo fntp "
					+ "INNER JOIN FETCH dbcb.debitoTipo dbtp "
					+ "WHERE conta.id = :idConta "
					+ "AND fntp.id NOT IN(:agua, :esgoto, :servico) "
					+ "ORDER BY dbtp.id, dbcb.anoMesReferenciaDebito ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					conta.getId()).setInteger("agua",
					FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger("esgoto",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
					"servico", FinanciamentoTipo.PARCELAMENTO_SERVICO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0003] - Obter dados dos créditos realizados
	 * 
	 * @author Raphael Rossiter
	 * @date 29/04/2008
	 * 
	 * @param conta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditoRealizado(Conta conta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT new CreditoRealizado(crrz.anoMesReferenciaCredito, crrz.numeroPrestacaoCredito, "
					+ "crrz.numeroPrestacao - COALESCE(crrz.numeroParcelaBonus,0), crrz.valorCredito, "
					+ "crtp) "// 0
					+ "FROM CreditoRealizado crrz "
					+ "INNER JOIN crrz.conta conta "
					+ "INNER JOIN FETCH crrz.creditoTipo crtp "
					+ "WHERE conta.id = :idConta "
					+ "ORDER BY crtp.id, crrz.anoMesReferenciaCredito ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					conta.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Emitir Contas CAERN
	 * 
	 * Obter dados dos créditos realizados Referente a Ação Judicial da CAERN
	 * (50% de Agua)
	 * 
	 * @author Tiago Moreno
	 * @date 23/01/2009
	 * 
	 * @param conta
	 * @return CreditoRealizado
	 * @throws ErroRepositorioException
	 */
	public CreditoRealizado pesquisarCreditoRealizadoNitrato(Conta conta)
			throws ErroRepositorioException {

		CreditoRealizado retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT new CreditoRealizado(crrz.anoMesReferenciaCredito, crrz.numeroPrestacaoCredito, "
					+ "crrz.numeroPrestacao - COALESCE(crrz.numeroParcelaBonus,0), crrz.valorCredito, "
					+ "crtp) "// 0
					+ "FROM CreditoRealizado crrz "
					+ "INNER JOIN crrz.conta conta "
					+ "INNER JOIN crrz.creditoTipo crtp "
					+ "WHERE conta.id = :idConta AND crtp.id = 12 "
					+ "ORDER BY crtp.id, crrz.anoMesReferenciaCredito ";

			retorno = (CreditoRealizado) session.createQuery(consulta)
					.setInteger("idConta", conta.getId()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 02/05/2008
	 * 
	 * @param idRota
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarIntervaloNumeroQuadraPorRota(Integer idRota)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT MIN(qdra.numeroQuadra), MAX(qdra.numeroQuadra) "
					+ "FROM Quadra qdra " + "INNER JOIN qdra.rota rota "
					+ "WHERE rota.id = :idRota ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idRota", idRota).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras - LEGADO
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA
	 * 
	 * @author Raphael Rossiter
	 * @date 27/05/2008
	 * 
	 * @param codigoQualifica
	 * @param dataVencimento
	 * @param valorDebito
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarFaturaItem(Integer idCliente,
			Integer anoMesReferencia, BigDecimal valorDebito)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT fi.valorConta, conta.id, localidade.id, "
					+ "imovel.id, localidadeHistorico.id, imovelHistorico.id, contaHistorico.id, "
					+ "fatura.anoMesReferencia "
					+ "FROM FaturaItem fi "
					+ "LEFT JOIN fi.fatura fatura "
					+ "LEFT JOIN fi.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN conta.imovel imovel "
					+ "LEFT JOIN conta.localidade localidade "
					+ "LEFT JOIN contaHistorico.imovel imovelHistorico "
					+ "LEFT JOIN contaHistorico.localidade localidadeHistorico "
					+ "LEFT JOIN fatura.cliente cliente "
					+ "WHERE cliente.id = :idCliente AND "
					+ "fatura.anoMesReferencia = :anoMesReferencia AND "
					+ "fatura.debito = :valordebito";

			retorno = session.createQuery(consulta).setInteger("idCliente",
					idCliente).setInteger("anoMesReferencia", anoMesReferencia)
					.setBigDecimal("valordebito", valorDebito).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0147] - Cancelar Conta
	 * 
	 * Atualizar a conta que está sendo cancelada com o ra que está autorizando
	 * o cancelamento da mesma.
	 * 
	 * @author Raphael Rossiter
	 * @date 17/06/2008
	 * 
	 * @param conta
	 * @param registroAtendimento
	 * @throws ErroRepositorioException
	 */
	public void atualizarContaCanceladaOuRetificada(Conta conta,
			RegistroAtendimento registroAtendimento)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {

			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "rgat_id = :idRA, cnta_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE cnta_id = :idConta ";

			session.createQuery(update).setInteger("idRA",
					registroAtendimento.getId()).setTimestamp(
					"dataUltimaAlteracao", conta.getUltimaAlteracao())
					.setInteger("idConta", conta.getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0352] - Emitir Contas
	 * 
	 * [SB0036] - Obter Valor dos Debitos Cobrados Servicos - CAEMA
	 * 
	 * @author Tiago Moreno
	 * @date 03/07/2008
	 * 
	 * @param id
	 *            da conta
	 * @throws ErroRepositorioException
	 */

	public BigDecimal obterValorDebitoServico(Integer idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT sum(valorPrestacao) " + "FROM DebitoCobrado dc "
					+ "WHERE dc.financiamentoTipo.id = 1 AND "
					+ "dc.conta.id = :idConta";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idConta", idConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] - Emitir Contas
	 * 
	 * [SB0037] - Obter Valor dos Debitos Cobrados Multas - CAEMA
	 * 
	 * @author Tiago Moreno
	 * @date 03/07/2008
	 * 
	 * @param id
	 *            da conta
	 * @throws ErroRepositorioException
	 */

	public BigDecimal obterValorDebitoMultas(Integer idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT sum(valorPrestacao) " + "FROM DebitoCobrado dc "
					+ "WHERE dc.id = 80 AND " + "dc.conta.id = :idConta";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idConta", idConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0641] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * @author Rafael Corrêa
	 * @date 10/07/2008
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDadosRelatorioFaturasAgrupadas(
			Integer anoMesReferencia, Cliente cliente,
			Collection<Integer> idsClientes) throws ErroRepositorioException {
		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT clieResponsavel.clie_id as idClienteReponsavel, " // 0
					+ " clieResponsavel.clie_nmcliente as nomeClienteReponsavel, " // 1
					+ " fatura.fatu_id as idFatura, " // 2
					+ " fatura.fatu_amreferencia as anoMesReferencia, " // 3
					+ " fatura.fatu_dtemissao as dataEmissao, " // 4
					+ " fatura.fatu_dtvencimento as dataVencimento, " // 5
					+ " faturaItem.fitm_vlimposto as valorImposto, " // 6
					+ " fatura.fatu_vldebito as valorDebito, " // 7
					+ " fatura.fatu_nnsequencial as sequencialFatura, " // 8
					+ " faturaItem.imov_id as idImovel, " // 9
					+ " clieUsuario.clie_nmcliente as nomeClienteUsuario, " // 10
					+ " loca.uneg_id as idUnidadeNegocio, " // 11
					+ " loca.loca_id as idLocalidade, " // 12
					+ " loca.loca_nmlocalidade as descricaoLocalidade, " // 13
					+ " CASE WHEN (hidrInstHistAgua.hidi_id is not null or hidrInstHistEsgoto.hidi_id is not null) "
					+ " 	THEN 'S' "
					+ " 	ELSE 'N' "
					+ " END as hidrometro, " // 14
					+ " CASE WHEN (imov.last_id >= 3 and imov.lest_id >= 3) "
					+ " 	THEN 'A/E' "
					+ " WHEN (imov.last_id >= 3) "
					+ " 	THEN 'A' "
					+ " 	ELSE 'E' "
					+ " END as tipo, " // 15
					+ " CASE WHEN (medHistAgua.mdhi_id is not null) "
					+ " 	THEN medHistAgua.mdhi_nnleituraatualfaturamento "
					+ " 	ELSE medHistEsgoto.mdhi_nnleituraatualfaturamento "
					+ " END as leitura, " // 16
					+ " faturaItem.fitm_nnconsumo as consumo, " // 17
					+ " faturaItem.fitm_vlconta as valor, " // 18
					+ " contageral.cntg_ichistorico as indicadorContaHist, " // 19
					+ " faturaItem.fitm_id as idFaturaItem, " // 20
					/**
					 * Nome do Imovel no lugar do nome do cliente usuário no relatório de faturas agrupadas
					 * 
					 * @author Wellington Rocha
					 * @date 22/11/2012*/
					+ " imov.imov_nmimovel as nomeImovel " // 21
					+ " FROM faturamento.fatura fatura "
					+ " INNER JOIN faturamento.fatura_item faturaItem on fatura.fatu_id = faturaItem.fatu_id "
					+ " INNER JOIN cadastro.cliente clieResponsavel on fatura.clie_id = clieResponsavel.clie_id "
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on faturaItem.imov_id = clieImovUsuario.imov_id and clieImovUsuario.clim_dtrelacaofim is null and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO
					+ " INNER JOIN cadastro.cliente clieUsuario on clieImovUsuario.clie_id = clieUsuario.clie_id "
					+ " INNER JOIN faturamento.conta_geral contageral on faturaItem.cnta_id = contageral.cnta_id "
					+ " LEFT JOIN faturamento.conta conta on contageral.cnta_id = conta.cnta_id "
					+ " LEFT JOIN cadastro.localidade loca on conta.loca_id = loca.loca_id "
					+ " INNER JOIN cadastro.imovel imov on faturaItem.imov_id = imov.imov_id "
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua ligAgua on faturaItem.imov_id = ligAgua.lagu_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist hidrInstHistAgua "
					+ " on ligAgua.hidi_id = hidrInstHistAgua.hidi_id and hidrInstHistAgua.hidi_dtretiradahidrometro is null "
					+ " and hidrInstHistAgua.hidi_dtinstalacaohidrometro is not null "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist hidrInstHistEsgoto "
					+ " on imov.hidi_id = hidrInstHistEsgoto.hidi_id and hidrInstHistEsgoto.hidi_dtretiradahidrometro is null "
					+ " and hidrInstHistEsgoto.hidi_dtinstalacaohidrometro is not null "
					+ " LEFT OUTER JOIN micromedicao.medicao_historico medHistAgua on faturaItem.imov_id = medHistAgua.lagu_id and medHistAgua.mdhi_amleitura = fatura.fatu_amreferencia "
					+ " LEFT OUTER JOIN micromedicao.medicao_historico medHistEsgoto on faturaItem.imov_id = medHistEsgoto.imov_id and medHistEsgoto.mdhi_amleitura = fatura.fatu_amreferencia "
					+ " WHERE fatura.fatu_amreferencia = :referencia ";
//					+ " and  contageral.cntg_ichistorico = 2 ";

			if (cliente != null && cliente.getId() != null) {
				consulta = consulta + " and fatura.clie_id = "
						+ cliente.getId();
			}

			if (idsClientes != null && !idsClientes.isEmpty()) {
				consulta = consulta + " and fatura.clie_id in (:idsClientes) ";
			}

			consulta = consulta + " ORDER BY idClienteReponsavel, idImovel ";

			SQLQuery query = session.createSQLQuery(consulta);

			if (idsClientes != null && !idsClientes.isEmpty()) {
				query.setParameterList("idsClientes", idsClientes);
			}

			retorno = query.addScalar("idClienteReponsavel", Hibernate.INTEGER)
					.addScalar("nomeClienteReponsavel", Hibernate.STRING)
					.addScalar("idFatura", Hibernate.INTEGER).addScalar(
							"anoMesReferencia", Hibernate.INTEGER).addScalar(
							"dataEmissao", Hibernate.DATE).addScalar(
							"dataVencimento", Hibernate.DATE).addScalar(
							"valorImposto", Hibernate.BIG_DECIMAL).addScalar(
							"valorDebito", Hibernate.BIG_DECIMAL).addScalar(
							"sequencialFatura", Hibernate.INTEGER).addScalar(
							"idImovel", Hibernate.INTEGER).addScalar(
							"nomeClienteUsuario", Hibernate.STRING).addScalar(
							"idUnidadeNegocio", Hibernate.INTEGER).addScalar(
							"idLocalidade", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"hidrometro", Hibernate.STRING).addScalar("tipo",
							Hibernate.STRING).addScalar("leitura",
							Hibernate.INTEGER).addScalar("consumo",
							Hibernate.INTEGER).addScalar("valor",
							Hibernate.BIG_DECIMAL).addScalar("indicadorContaHist",
							Hibernate.INTEGER).addScalar("idFaturaItem",
							Hibernate.INTEGER).addScalar("nomeImovel", Hibernate.STRING)
							.setInteger("referencia",
							anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0641] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * @author Rafael Corrêa
	 * @date 10/07/2008
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDadosRelatorioFaturasAgrupadasCount(
			Integer anoMesReferencia, Cliente cliente,
			Collection<Integer> idsClientes) throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT COUNT(fatura.fatu_id) as qtde " // 0
					+ " FROM faturamento.fatura fatura "
					+ " INNER JOIN faturamento.fatura_item faturaItem on fatura.fatu_id = faturaItem.fatu_id "
					+ " INNER JOIN cadastro.cliente clieResponsavel on fatura.clie_id = clieResponsavel.clie_id "
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on faturaItem.imov_id = clieImovUsuario.imov_id and clieImovUsuario.clim_dtrelacaofim is null and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO
					+ " INNER JOIN cadastro.cliente clieUsuario on clieImovUsuario.clie_id = clieUsuario.clie_id "
					+ " INNER JOIN faturamento.conta_geral contageral on faturaItem.cnta_id = contageral.cnta_id "
					+ " LEFT JOIN faturamento.conta conta on contageral.cnta_id = conta.cnta_id "
					+ " LEFT JOIN cadastro.localidade loca on conta.loca_id = loca.loca_id "
					+ " INNER JOIN cadastro.imovel imov on faturaItem.imov_id = imov.imov_id "
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua ligAgua on faturaItem.imov_id = ligAgua.lagu_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist hidrInstHistAgua "
					+ " on ligAgua.hidi_id = hidrInstHistAgua.hidi_id and hidrInstHistAgua.hidi_dtretiradahidrometro is null "
					+ " and hidrInstHistAgua.hidi_dtinstalacaohidrometro is not null "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist hidrInstHistEsgoto "
					+ " on imov.hidi_id = hidrInstHistEsgoto.hidi_id and hidrInstHistEsgoto.hidi_dtretiradahidrometro is null "
					+ " and hidrInstHistEsgoto.hidi_dtinstalacaohidrometro is not null "
					+ " LEFT OUTER JOIN micromedicao.medicao_historico medHistAgua on faturaItem.imov_id = medHistAgua.lagu_id and medHistAgua.mdhi_amleitura = fatura.fatu_amreferencia "
					+ " LEFT OUTER JOIN micromedicao.medicao_historico medHistEsgoto on faturaItem.imov_id = medHistEsgoto.imov_id and medHistEsgoto.mdhi_amleitura = fatura.fatu_amreferencia "
					+ " WHERE fatura.fatu_amreferencia = :referencia "
					+ " and contageral.cntg_ichistorico = 2 ";

			if (cliente != null && cliente.getId() != null) {
				consulta = consulta + " and fatura.clie_id = "
						+ cliente.getId();
			}

			if (idsClientes != null && !idsClientes.isEmpty()) {
				consulta = consulta + " and fatura.clie_id in (:idsClientes) ";
			}

			SQLQuery query = session.createSQLQuery(consulta);

			if (idsClientes != null && !idsClientes.isEmpty()) {
				query.setParameterList("idsClientes", idsClientes);
			}

			retorno = (Integer) query.addScalar("qtde", Hibernate.INTEGER)
						.setInteger("referencia", anoMesReferencia).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * Pesquisa a quantidade de itens de faturas para o cliente responsável
	 * 
	 * @author Rafael Corrêa
	 * @date 12/07/2008
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeFaturasReponsavel(
			Integer anoMesReferencia, Integer idCliente)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT count(fatura.fatu_id) as qtdFatura " 
					  + "FROM faturamento.fatura fatura "  
					  + "INNER JOIN faturamento.fatura_item faturaItem on fatura.fatu_id = faturaItem.fatu_id "  
					  + "INNER JOIN cadastro.cliente clieResponsavel on fatura.clie_id = clieResponsavel.clie_id "
					  + "INNER JOIN cadastro.cliente_imovel clieImovUsuario on faturaItem.imov_id = clieImovUsuario.imov_id and clieImovUsuario.clim_dtrelacaofim is null and clieImovUsuario.crtp_id = 2 "
					  + "INNER JOIN cadastro.cliente clieUsuario on clieImovUsuario.clie_id = clieUsuario.clie_id " 
					  + "INNER JOIN faturamento.conta_geral contageral on faturaItem.cnta_id = contageral.cnta_id " 
					  + "INNER JOIN faturamento.conta conta on contageral.cnta_id = conta.cnta_id " 
					  + "INNER JOIN cadastro.localidade loca on conta.loca_id = loca.loca_id " 
					  + "INNER JOIN cadastro.imovel imov on faturaItem.imov_id = imov.imov_id " 
					  + "LEFT OUTER JOIN atendimentopublico.ligacao_agua ligAgua on faturaItem.imov_id = ligAgua.lagu_id " 
					  + "LEFT OUTER JOIN micromedicao.hidrometro_inst_hist hidrInstHistAgua "
					  + "on ligAgua.hidi_id = hidrInstHistAgua.hidi_id and hidrInstHistAgua.hidi_dtretiradahidrometro is null " 
					  + "and hidrInstHistAgua.hidi_dtinstalacaohidrometro is not null "
					  + "LEFT OUTER JOIN micromedicao.hidrometro_inst_hist hidrInstHistEsgoto " 
					  + "on imov.hidi_id = hidrInstHistEsgoto.hidi_id and hidrInstHistEsgoto.hidi_dtretiradahidrometro is null " 
					  + "and hidrInstHistEsgoto.hidi_dtinstalacaohidrometro is not null "
					  + "LEFT OUTER JOIN micromedicao.medicao_historico medHistAgua on faturaItem.imov_id = medHistAgua.lagu_id and medHistAgua.mdhi_amleitura = fatura.fatu_amreferencia " 
					  + "LEFT OUTER JOIN micromedicao.medicao_historico medHistEsgoto on faturaItem.imov_id = medHistEsgoto.imov_id and medHistEsgoto.mdhi_amleitura = fatura.fatu_amreferencia " 
					  + "WHERE fatura.fatu_amreferencia = :referencia "
					  + "and  contageral.cntg_ichistorico = 2 ";
					
			 if (idCliente != null ) {
				 consulta = consulta + "and fatura.clie_id = " + idCliente;
			 }
			
			
			
			SQLQuery query = session.createSQLQuery(consulta);

			retorno = (Integer) query.addScalar("qtdFatura", Hibernate.INTEGER)
			.setInteger("referencia",anoMesReferencia).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0641] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * Pesquisa os clientes associados as faturas de uma determinada esfera de
	 * porder
	 * 
	 * @author Rafael Corrêa
	 * @date 21/01/2009
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClientesFaturas(Integer idEsferaPoder)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT DISTINCT cliente " + " FROM Fatura fatura "
					+ " INNER JOIN fatura.cliente cliente "
					+ " INNER JOIN cliente.clienteTipo clienteTipo "
					+ " INNER JOIN clienteTipo.esferaPoder esferaPoder "
					+ " WHERE esferaPoder.id = :idEsferaPoder "
					+ " ORDER BY cliente.id ";

			retorno = (Collection) session.createQuery(consulta).setInteger(
					"idEsferaPoder", idEsferaPoder).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * Pesquisa o percentual de retenção
	 * 
	 * @author Rafael Corrêa
	 * @date 12/07/2008
	 * 
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarPercentualAliquota()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT sum(impTipoAliquota.percentualAliquota) "
					+ " FROM ImpostoTipoAliquota impTipoAliquota ";

			retorno = (BigDecimal) session.createQuery(consulta).setMaxResults(
					1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UCXXXX] - Relatório de Protocolo de Entrega de Faturas
	 * 
	 * @author Rafael Corrêa
	 * @date 12/11/2008
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDadosRelatorioProtocoloEntregaFatura(
			Integer anoMesReferencia, Cliente cliente,
			Collection<Integer> idsClientes) throws ErroRepositorioException {
		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cliente.id, cliente.nome, fatura.anoMesReferencia, fatura.vencimento "
					+ " FROM Fatura fatura "
					+ " INNER JOIN fatura.cliente cliente "
					+ " WHERE fatura.anoMesReferencia = :referencia ";

			if (cliente != null && cliente.getId() != null) {
				consulta = consulta + " and cliente.id = " + cliente.getId();
			}

			if (idsClientes != null && !idsClientes.isEmpty()) {
				consulta = consulta + " and cliente.id in (:idsClientes) ";
			}

			Query query = session.createQuery(consulta);

			if (idsClientes != null && !idsClientes.isEmpty()) {
				query.setParameterList("idsClientes", idsClientes);
			}

			retorno = (Collection<Object[]>) query.setInteger("referencia",
					anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0153] - Apresentar Dados Para Análise da Medição e Consumo
	 * 
	 * Pesquisa a situação especial de faturamento vigente do mês/ano informada
	 * 
	 * @author Rafael Corrêa
	 * @date 11/08/2008
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarSituacaoEspecialFaturamentoVigente(
			Integer idImovel, Integer anoMesReferencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT fatSitTp.descricao, fatSitMot.descricao, fatSitHist.anoMesFaturamentoSituacaoInicio, "
					+ " fatSitHist.anoMesFaturamentoSituacaoFim, usuario.nomeUsuario "
					+ " FROM FaturamentoSituacaoHistorico fatSitHist "
					+ " INNER JOIN fatSitHist.faturamentoSituacaoTipo fatSitTp "
					+ " INNER JOIN fatSitHist.faturamentoSituacaoMotivo fatSitMot "
					+ " LEFT OUTER JOIN fatSitHist.usuario usuario "
					+ " WHERE fatSitHist.anoMesFaturamentoSituacaoInicio <= :anoMesReferencia and fatSitHist.anoMesFaturamentoRetirada is null "
					+ " and fatSitHist.imovel.id = :idImovel ";

			retorno = (Collection<Object[]>) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).setInteger(
							"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0352] - Emitir Contas
	 * 
	 * [SB0041] - Gerar Linhas das Faixas de Consumo da Conta - CAEMA
	 * 
	 * Pesquisa as faixas da subcategoria
	 * 
	 * @author Rafael Corrêa
	 * @date 03/07/2008
	 * 
	 * @param idSubcategoria
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarConsumoTarifaFaixaPelaSubcategoria(
			Integer idSubcategoria) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT consTarFaixa.numeroConsumoFaixaInicio, consTarFaixa.numeroConsumoFaixaFim, consTarFaixa.valorConsumoTarifa, "
					+ " consTarCat.numeroConsumoMinimo, consTarCat.valorTarifaMinima "
					+ " FROM ConsumoTarifaFaixa consTarFaixa "
					+ " INNER JOIN faturamento.consumoTarifaCategoria consTarCat "
					+ " WHERE consTarCat.subCategoria.id = :idSubcategoria ";

			retorno = session.createQuery(consulta).setInteger(
					"idSubcategoria", idSubcategoria).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0857] - Gerar Relatório de Arrecadação das Multas de Autos de Infração
	 * 
	 * Pesquisa os dados necessários para geração do relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 10/09/2008
	 * 
	 * @param idUnidadeNegocio,
	 *            idFuncionario, dataPagamentoInicial, dataPagamentoFinal
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDadosRelatorioAutoInfracao(
			Integer idUnidadeNegocio, Integer idFuncionario,
			Integer dataPagamentoInicial, Integer dataPagamentoFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = " SELECT unidNeg.uneg_id as idUnidadeNegocio,"
					+ " unidNeg.uneg_nmunidadenegocio as nomeUnidadeNegocio,"
					+ " funcionario.func_id as idFuncionario,"
					+ " funcionario.func_nmfuncionario as nomeFuncionario,"
					+ " pagto.pgmt_dtpagamento as dataPagamento,"
					+ " autoInfracao.auif_id as autoInfracao,"
					+ " debitoTipo.dbtp_dsdebitotipo as descricaoServico,"
					+ " debitoTipo.dbtp_vlsugerido as valorServico,"
					+ " debCob.dbcb_nnprestacao as qtdParcelas,"
					+ " debCob.dbcb_nnprestacaodebito as parcelaPaga,"
					+ " debCob.dbcb_vlprestacao as valorParcelaPaga,"
					+ " trunc(( ( debCob.dbcb_vlprestacao * fisSitServACobrar.fscb_pcmultafuncionario ) / 100 ), 2) as valorFuncionario,"
					+ " pagto.imov_id as idImovel,"
					+ " clieUsuario.clie_nmcliente as nomeUsuario"
					+ " FROM faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar"
					+ " INNER JOIN faturamento.debito_cobrado debCob on debCob.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN arrecadacao.pagamento pagto on (pagto.dbac_id = autosInfracaoDebitoACobrar.dbac_id or pagto.cnta_id = debcob.cnta_id)  "
					+ " INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id"
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = pagto.loca_id"
					+ " INNER JOIN cadastro.unidade_negocio unidNeg on unidNeg.uneg_id = loca.uneg_id"
					+ " INNER JOIN cadastro.funcionario funcionario on funcionario.func_id = autoInfracao.func_id"
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null"
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id"
					+ " INNER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id"
					+ " INNER JOIN atendimentopublico.fiscaliz_sit_serv_a_cob fisSitServACobrar on (fisSitServACobrar.fzst_id = autoInfracao.fzst_id and fisSitServACobrar.dbtp_id = debitoACobrar.dbtp_id"
					+ " and fisSitServACobrar.fscb_icmultaaltoinfracao = 1)"
					+ " WHERE autosInfracaoDebitoACobrar.aida_icmultaautoinfracao = 1 and ";

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				consulta = consulta
						+ " pagto.pgmt_amreferenciaarrecadacao between :dataPagamentoInicial and :dataPagamentoFinal and ";
			} else {
				consulta = consulta
						+ " pagto.pgmt_amreferenciaarrecadacao = :dataPagamentoInicial and ";
			}

			if (idUnidadeNegocio != null) {
				consulta = consulta + " unidNeg.uneg_id = " + idUnidadeNegocio
						+ " and ";
			}

			if (idFuncionario != null) {
				consulta = consulta + " funcionario.func_id = " + idFuncionario
						+ " and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION ALL "
					+ " SELECT unidNeg.uneg_id as idUnidadeNegocio,"
					+ " unidNeg.uneg_nmunidadenegocio as nomeUnidadeNegocio,"
					+ " funcionario.func_id as idFuncionario,"
					+ " funcionario.func_nmfuncionario as nomeFuncionario,"
					+ " pagto.pgmt_dtpagamento as dataPagamento,"
					+ " autoInfracao.auif_id as autoInfracao,"
					+ " debitoTipo.dbtp_dsdebitotipo as descricaoServico,"
					+ " debitoTipo.dbtp_vlsugerido as valorServico,"
					+ " 0 as qtdParcelas,"
					+ " 0 as parcelaPaga,"
					+ " pagto.pgmt_vlpagamento as valorParcelaPaga,"
					+ " trunc(( ( pagto.pgmt_vlpagamento * fisSitServACobrar.fscb_pcmultafuncionario ) / 100 ), 2) as valorFuncionario,"
					+ " pagto.imov_id as idImovel,"
					+ " clieUsuario.clie_nmcliente as nomeUsuario"
					+ " FROM faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar"
					+ " INNER JOIN arrecadacao.pagamento pagto on pagto.dbac_id = autosInfracaoDebitoACobrar.dbac_id "
					+ " INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id"
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = pagto.loca_id"
					+ " INNER JOIN cadastro.unidade_negocio unidNeg on unidNeg.uneg_id = loca.uneg_id"
					+ " INNER JOIN cadastro.funcionario funcionario on funcionario.func_id = autoInfracao.func_id"
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null"
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id"
					+ " INNER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id"
					+ " INNER JOIN atendimentopublico.fiscaliz_sit_serv_a_cob fisSitServACobrar on (fisSitServACobrar.fzst_id = autoInfracao.fzst_id and fisSitServACobrar.dbtp_id = debitoACobrar.dbtp_id"
					+ " and fisSitServACobrar.fscb_icmultaaltoinfracao = 1)"
					+ " WHERE autosInfracaoDebitoACobrar.aida_icmultaautoinfracao = 1 and ";

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				consulta = consulta
						+ " pagto.pgmt_amreferenciaarrecadacao between :dataPagamentoInicial and :dataPagamentoFinal and ";
			} else {
				consulta = consulta
						+ " pagto.pgmt_amreferenciaarrecadacao = :dataPagamentoInicial and ";
			}

			if (idUnidadeNegocio != null) {
				consulta = consulta + " unidNeg.uneg_id = " + idUnidadeNegocio
						+ " and ";
			}

			if (idFuncionario != null) {
				consulta = consulta + " funcionario.func_id = " + idFuncionario
						+ " and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION ALL "
					+ " SELECT"
					+ " unidNeg.uneg_id as idUnidadeNegocio,"
					+ " unidNeg.uneg_nmunidadenegocio as nomeUnidadeNegocio,"
					+ " funcionario.func_id as idFuncionario,"
					+ " funcionario.func_nmfuncionario as nomeFuncionario,"
					+ " pagtoHist.pghi_dtpagamento as dataPagamento,"
					+ " autoInfracao.auif_id as autoInfracao,"
					+ " debitoTipo.dbtp_dsdebitotipo as descricaoServico,"
					+ " debitoTipo.dbtp_vlsugerido as valorServico,"
					+ " debCobHist.dbhi_nnprestacao as qtdParcelas,"
					+ " debCobHist.dbhi_nnprestacaodebito as parcelaPaga,"
					+ " debCobHist.dbhi_vlprestacao as valorParcelaPaga,"
					+ " trunc(( ( debCobHist.dbhi_vlprestacao * fisSitServACobrar.fscb_pcmultafuncionario ) / 100 ), 2) as valorFuncionario,"
					+ " pagtoHist.imov_id as idImovel,"
					+ " clieUsuario.clie_nmcliente as nomeUsuario"
					+ " FROM faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar"
					+ " INNER JOIN faturamento.debito_cobrado_historico debCobHist on debCobHist.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN arrecadacao.pagamento_historico pagtoHist on pagtoHist.cnta_id = debCobHist.cnta_id"
					+ " INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id"
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = pagtoHist.loca_id"
					+ " INNER JOIN cadastro.unidade_negocio unidNeg on unidNeg.uneg_id = loca.uneg_id"
					+ " INNER JOIN cadastro.funcionario funcionario on funcionario.func_id = autoInfracao.func_id"
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null"
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id"
					+ " LEFT OUTER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " LEFT OUTER JOIN faturamento.deb_a_cobrar_hist debitoACobrarHistorico on debitoACobrarHistorico.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id or debitoTipo.dbtp_id = debitoACobrarHistorico.dbtp_id"
					+ " INNER JOIN atendimentopublico.fiscaliz_sit_serv_a_cob fisSitServACobrar on (fisSitServACobrar.fzst_id = autoInfracao.fzst_id and fisSitServACobrar.dbtp_id = debitoTipo.dbtp_id"
					+ " and fisSitServACobrar.fscb_icmultaaltoinfracao = 1)"
					+ " WHERE autosInfracaoDebitoACobrar.aida_icmultaautoinfracao = 1 and ";

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				consulta = consulta
						+ " pagtoHist.pghi_amreferenciaarrecadacao between :dataPagamentoInicial and :dataPagamentoFinal and ";
			} else {
				consulta = consulta
						+ " pagtoHist.pghi_amreferenciaarrecadacao = :dataPagamentoInicial and ";
			}

			if (idUnidadeNegocio != null) {
				consulta = consulta + " unidNeg.uneg_id = " + idUnidadeNegocio
						+ " and ";
			}

			if (idFuncionario != null) {
				consulta = consulta + " funcionario.func_id = " + idFuncionario
						+ " and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION ALL "
					+ " SELECT"
					+ " unidNeg.uneg_id as idUnidadeNegocio,"
					+ " unidNeg.uneg_nmunidadenegocio as nomeUnidadeNegocio,"
					+ " funcionario.func_id as idFuncionario,"
					+ " funcionario.func_nmfuncionario as nomeFuncionario,"
					+ " pagtoHist.pghi_dtpagamento as dataPagamento,"
					+ " autoInfracao.auif_id as autoInfracao,"
					+ " debitoTipo.dbtp_dsdebitotipo as descricaoServico,"
					+ " debitoTipo.dbtp_vlsugerido as valorServico,"
					+ " 0 as qtdParcelas,"
					+ " 0 as parcelaPaga,"
					+ " pagtoHist.pghi_vlpagamento as valorParcelaPaga,"
					+ " trunc(( ( pagtoHist.pghi_vlpagamento * fisSitServACobrar.fscb_pcmultafuncionario ) / 100 ), 2)as valorFuncionario,"
					+ " pagtoHist.imov_id as idImovel,"
					+ " clieUsuario.clie_nmcliente as nomeUsuario"
					+ " FROM faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar"
					+ " INNER JOIN arrecadacao.pagamento_historico pagtoHist on pagtoHist.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id"
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = pagtoHist.loca_id"
					+ " INNER JOIN cadastro.unidade_negocio unidNeg on unidNeg.uneg_id = loca.uneg_id"
					+ " INNER JOIN cadastro.funcionario funcionario on funcionario.func_id = autoInfracao.func_id"
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null"
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id"
					+ " LEFT OUTER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " LEFT OUTER JOIN faturamento.deb_a_cobrar_hist debitoACobrarHistorico on debitoACobrarHistorico.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id or debitoTipo.dbtp_id = debitoACobrarHistorico.dbtp_id"
					+ " INNER JOIN atendimentopublico.fiscaliz_sit_serv_a_cob fisSitServACobrar on (fisSitServACobrar.fzst_id = autoInfracao.fzst_id and fisSitServACobrar.dbtp_id = debitoTipo.dbtp_id"
					+ " and fisSitServACobrar.fscb_icmultaaltoinfracao = 1)"
					+ " WHERE autosInfracaoDebitoACobrar.aida_icmultaautoinfracao = 1 and ";

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				consulta = consulta
						+ " pagtoHist.pghi_amreferenciaarrecadacao between :dataPagamentoInicial and :dataPagamentoFinal and ";
			} else {
				consulta = consulta
						+ " pagtoHist.pghi_amreferenciaarrecadacao = :dataPagamentoInicial and ";
			}

			if (idUnidadeNegocio != null) {
				consulta = consulta + " unidNeg.uneg_id = " + idUnidadeNegocio
						+ " and ";
			}

			if (idFuncionario != null) {
				consulta = consulta + " funcionario.func_id = " + idFuncionario
						+ " and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " ORDER BY 1, 3, 5, 13, 6, 10 ";
			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				retorno = session.createSQLQuery(consulta).addScalar(
						"idUnidadeNegocio", Hibernate.INTEGER).addScalar(
						"nomeUnidadeNegocio", Hibernate.STRING).addScalar(
						"idFuncionario", Hibernate.INTEGER).addScalar(
						"nomeFuncionario", Hibernate.STRING).addScalar(
						"dataPagamento", Hibernate.DATE).addScalar(
						"autoInfracao", Hibernate.INTEGER).addScalar(
						"descricaoServico", Hibernate.STRING).addScalar(
						"valorServico", Hibernate.BIG_DECIMAL).addScalar(
						"qtdParcelas", Hibernate.INTEGER).addScalar(
						"parcelaPaga", Hibernate.INTEGER).addScalar(
						"valorParcelaPaga", Hibernate.BIG_DECIMAL).addScalar(
						"valorFuncionario", Hibernate.BIG_DECIMAL).addScalar(
						"idImovel", Hibernate.INTEGER).addScalar("nomeUsuario",
						Hibernate.STRING).setInteger("dataPagamentoInicial",
						dataPagamentoInicial).setInteger("dataPagamentoFinal",
						dataPagamentoFinal).list();
			} else {
				retorno = session.createSQLQuery(consulta).addScalar(
						"idUnidadeNegocio", Hibernate.INTEGER).addScalar(
						"nomeUnidadeNegocio", Hibernate.STRING).addScalar(
						"idFuncionario", Hibernate.INTEGER).addScalar(
						"nomeFuncionario", Hibernate.STRING).addScalar(
						"dataPagamento", Hibernate.DATE).addScalar(
						"autoInfracao", Hibernate.INTEGER).addScalar(
						"descricaoServico", Hibernate.STRING).addScalar(
						"valorServico", Hibernate.BIG_DECIMAL).addScalar(
						"qtdParcelas", Hibernate.INTEGER).addScalar(
						"parcelaPaga", Hibernate.INTEGER).addScalar(
						"valorParcelaPaga", Hibernate.BIG_DECIMAL).addScalar(
						"valorFuncionario", Hibernate.BIG_DECIMAL).addScalar(
						"idImovel", Hibernate.INTEGER).addScalar("nomeUsuario",
						Hibernate.STRING).setInteger("dataPagamentoInicial",
						dataPagamentoInicial).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Exclui resumo faturamento do ano/mês de faturamento corrente por
	 * localidade
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Vivianne Sousa
	 * @date 11/08/2008
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 */
	public void excluirResumoFaturamentoPorAnoMesArrecadacaoPorLocalidade(
			int anoMesReferenciaFaturamento, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Constroi o hql para remover os resumos do faturamento
			// referentes ao ano/mês de faturamento atual
			consulta = "delete ResumoFaturamento rf "
					+ " where rf.anoMesReferencia = :anoMesReferenciaFaturamento "
					+ " and rf.localidade.id = :idLocalidade";

			// Executa o hql
			session.createQuery(consulta).setInteger(
					"anoMesReferenciaFaturamento", anoMesReferenciaFaturamento)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0866] Gerar Comando Contas em Cobrança por Empresa
	 * 
	 * Pesquisa a quantidade de contas
	 * 
	 * @author: Rafael Corrêa, Mariana Victor
	 * @date: 27/10/2008, 07/04/2011
	 */
	public Collection pesquisarQuantidadeContas(
			ComandoEmpresaCobrancaContaHelper comandoEmpresaCobrancaContaHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;
		ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta();
		
		try {
			consulta = "SELECT COUNT(DISTINCT conta.cnta_id) as qtdContas, "
					+ "COUNT(DISTINCT conta.imov_id) as qtdImovel, "
					+ "SUM ( coalesce( conta.cnta_vlagua, 0 ) + "
					+ "coalesce( conta.cnta_vlesgoto, 0 ) + "
					+ "coalesce( conta.cnta_vldebitos, 0 ) - "
					+ "coalesce( conta.cnta_vlcreditos, 0 ) - "
					+ "coalesce( conta.cnta_vlimpostos, 0 ) "
					+ ") as valorTotalDebitos "
					+ " FROM faturamento.conta conta ";
			
			if (comandoEmpresaCobrancaConta.getCliente() != null) {
				consulta = consulta
					+ " INNER JOIN cadastro.cliente_conta clieConta "
					+ "   on clieConta.cnta_id = conta.cnta_id "
					+ "   AND clieConta.crtp_id = :clienteUsuario ";
			}
			

			consulta = consulta 
				+ " INNER JOIN cadastro.imovel imov on imov.imov_id = conta.imov_id "
				+ " INNER JOIN faturamento.conta_categoria contaCat  on conta.cnta_id = contaCat.cnta_id "			
				+ " LEFT OUTER JOIN arrecadacao.pagamento pagto  on pagto.cnta_id = conta.cnta_id "
				+ " LEFT OUTER JOIN cobranca.empresa_cobranca_conta emprCobConta on emprCobConta.imov_id = imov.imov_id ";
			
			
			if (comandoEmpresaCobrancaConta.getUnidadeNegocio() != null
					|| (comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio() != null
							&& !comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().isEmpty())
					|| comandoEmpresaCobrancaConta.getGerenciaRegional() != null
					|| (comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional() != null
							&& !comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().isEmpty())
					|| comandoEmpresaCobrancaConta.getLocalidadeInicial() != null
				) {
				
				consulta = consulta
					+ " INNER JOIN cadastro.localidade loca "
					+ "   on loca.loca_id = imov.loca_id ";
				
			}
			
			consulta = consulta + " WHERE ";

			consulta = consulta
					+ criarCondicionaisPesquisarQuantidadeContas(comandoEmpresaCobrancaContaHelper, false);
			
			consulta = consulta + " AND contaCat.catg_id IN (:idsCategoria) ";
			
			Collection<Integer> idsCategorias = new ArrayList();
			idsCategorias.add(Categoria.RESIDENCIAL);
			idsCategorias.add(Categoria.COMERCIAL);
			idsCategorias.add(Categoria.INDUSTRIAL);
			idsCategorias.add(Categoria.PUBLICO);
			
			if ((comandoEmpresaCobrancaConta.getIndicadorResidencial() != null && !comandoEmpresaCobrancaConta
					.getIndicadorResidencial().equals(
							ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorComercial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorComercial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorIndustrial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorPublico() != null && !comandoEmpresaCobrancaConta
							.getIndicadorPublico().equals(
									ConstantesSistema.NAO.intValue()))) {
	
				
				idsCategorias = new ArrayList();
				
				if (comandoEmpresaCobrancaConta.getIndicadorResidencial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorResidencial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.RESIDENCIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorComercial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorComercial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.COMERCIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorIndustrial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.INDUSTRIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorPublico() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorPublico()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.PUBLICO);
				}
	
			}						

			consulta = consulta + " GROUP BY conta.imov_id "; 
			
			
			if (comandoEmpresaCobrancaConta.getQtdContasInicial() != null) {
				consulta = consulta + " HAVING count(DISTINCT conta.cnta_id) between " +  comandoEmpresaCobrancaConta.getQtdContasInicial() + " and  " +  comandoEmpresaCobrancaConta.getQtdContasFinal() + " ";
			}
			
			retorno =  session.createSQLQuery(consulta).addScalar(
					"qtdContas", Hibernate.INTEGER).addScalar("qtdImovel",
					Hibernate.INTEGER).addScalar("valorTotalDebitos",
					Hibernate.BIG_DECIMAL).setParameterList("idsCategoria",idsCategorias).list();
			
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * Pesquisa os imóveis das contas
	 * 
	 * @author: Rafael Corrêa, Mariana Victor
	 * @date: 28/10/2008, 03/05/2011
	 */
	public Collection<Integer> pesquisarImoveisInformarContasEmCobranca(
			ComandoEmpresaCobrancaContaHelper comandoEmpresaCobrancaContaHelper,
			Integer numeroPagina, boolean percentualInformado) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Integer> retorno = null;
		String consulta = null;

		try {
			Integer quantidadeMenorFaixa = null;
			
			if (!percentualInformado) {
				quantidadeMenorFaixa = pesquisarQuantidadeContasMenorFaixa(
						comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta().getEmpresa().getId());
			}
			
			consulta = "SELECT DISTINCT conta.imov_id as idImovel "
					+ " FROM faturamento.conta conta ";

			if (comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta().getCliente() != null) {
				consulta = consulta
						+ " INNER JOIN cadastro.cliente_conta clieConta "
						+ " on clieConta.cnta_id = conta.cnta_id ";
			}

			consulta = consulta
					+ " INNER JOIN cadastro.imovel imov on imov.imov_id = conta.imov_id "
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ " LEFT OUTER JOIN cobranca.empresa_cobranca_conta emprCobConta on emprCobConta.imov_id = conta.imov_id "
					+ " LEFT OUTER JOIN cobranca.cmd_empr_cobr_conta cecc on emprCobConta.cecc_id = cecc.cecc_id ";
			
			if (!percentualInformado) {
				consulta = consulta 
						+ " LEFT OUTER JOIN cobranca.cobranca_situacao cbst "
						+ " ON cbst.cbst_id = imov.cbst_id " + " WHERE "
						+ " (imov.cbst_id IS NULL or cbst.cbst_icnaocobranca <> 1) "
						+ " AND imov.imov_id NOT IN (SELECT cbsh.imov_id FROM cobranca.cobranca_situacao_hist cbsh WHERE cbsh.imov_id = imov.imov_id and cbsh.cbsh_amcobrancaretirada IS NULL) " 
						+ " AND ";
			} else {
				consulta = consulta + " WHERE ";
			}
			
			consulta = consulta + " NOT EXISTS (select pagto.pgmt_id FROM arrecadacao.pagamento pagto WHERE pagto.cnta_id = conta.cnta_id) AND ";
			consulta = consulta + " imov.imov_idcategoriaprincipal in (:idsCategoria) AND ";
			
			
			consulta = consulta
					+ criarCondicionaisPesquisarQuantidadeContas(comandoEmpresaCobrancaContaHelper, !percentualInformado);
			
			if (comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta().getQtdContasInicial() != null) {
				consulta = consulta + " group by conta.imov_id ";
				consulta = consulta + " HAVING count(DISTINCT conta.cnta_id) between "
						+ comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta().getQtdContasInicial()
						+ " and "
						+ comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta().getQtdContasFinal();
			} else if (!percentualInformado && quantidadeMenorFaixa != null){
				consulta = consulta + " group by conta.imov_id ";
				consulta = consulta + " HAVING count(DISTINCT conta.cnta_id) >= " + quantidadeMenorFaixa;	
			}
			
			Collection<Integer> idsCategorias = new ArrayList();
			idsCategorias.add(Categoria.RESIDENCIAL);
			idsCategorias.add(Categoria.COMERCIAL);
			idsCategorias.add(Categoria.INDUSTRIAL);
			idsCategorias.add(Categoria.PUBLICO);
			
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta();

			if ((comandoEmpresaCobrancaConta.getIndicadorResidencial() != null && !comandoEmpresaCobrancaConta
					.getIndicadorResidencial().equals(
							ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorComercial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorComercial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorIndustrial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorPublico() != null && !comandoEmpresaCobrancaConta
							.getIndicadorPublico().equals(
									ConstantesSistema.NAO.intValue()))) {
	
				idsCategorias = new ArrayList();
				
				if (comandoEmpresaCobrancaConta.getIndicadorResidencial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorResidencial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.RESIDENCIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorComercial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorComercial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.COMERCIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorIndustrial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.INDUSTRIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorPublico() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorPublico()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.PUBLICO);
				}
	
			}			
			
			retorno = session.createSQLQuery(consulta).
				addScalar("idImovel",Hibernate.INTEGER).
				setParameterList("idsCategoria",idsCategorias).
				setMaxResults(1000).
				setFirstResult(numeroPagina).
				list();
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [????] Informar Subdivisões de Rota
	 * 
	 * Verifica se esse grupo de Faturamento já está comandado para a atividade
	 * Gerar Arquivo de Leitura
	 * 
	 * @author: Victor Cisneiros
	 * @date: 30/09/2008
	 */
	public Boolean verificarGrupoFaturamentoComandado(
			int anoMesReferenciaFaturamento, int idGrupoFaturamento)
			throws ErroRepositorioException {

		Boolean retorno = false;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "SELECT "
					+ "count(*) as count "
					+ "FROM faturamento.fatur_grupo_crg_mensal fgcm "
					+ "INNER JOIN faturamento.fatur_ativ_cronograma fac ON (fgcm.ftcm_id = fac.ftcm_id) "
					+ "WHERE "
					+ "fgcm.ftcm_amreferencia = :anoMesReferenciaFaturamento "
					+ "AND fgcm.ftgr_id = :idGrupoFaturamento "
					+ "AND fac.ftat_id = "
					+ FaturamentoAtividade.GERAR_ARQUIVO_LEITURA + " "
					+ "AND fac.ftac_tmcomando is not null "
					+ "AND fac.ftac_tmrealizacao is null ";

			SQLQuery q = session.createSQLQuery(consulta);
			q.setInteger("anoMesReferenciaFaturamento",
					anoMesReferenciaFaturamento);
			q.setInteger("idGrupoFaturamento", idGrupoFaturamento);
			q.addScalar("count", Hibernate.LONG);

			Long result = (Long) q.uniqueResult();
			if (result != null && result > 0) {
				retorno = true;
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * @author Sávio Luiz
	 * @date 24/10/2008
	 * 
	 * @param conta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisaridDebitoTipoDoDebitoCobradoDeParcelamento(
			Integer idConta, Collection idsFinanciamentoTipo)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT dbcb.debitoTipo.id,"// 0
					+ "parc.id,"// 1
					+ "parc.valorDebitoAtualizado,"// 2
					+ "dbcb.valorPrestacao, "// 3
					+ "dbcb.numeroPrestacaoDebito, "// 4
					+ "dbcb.numeroPrestacao, "// 5
					+ "parc.valorConta "// 6
					+ "FROM DebitoCobrado dbcb "
					+ "INNER JOIN dbcb.conta conta "
					+ "INNER JOIN dbcb.financiamentoTipo fntp "
					+ "LEFT JOIN dbcb.debitoACobrarGeral dacg "
					+ "LEFT JOIN dacg.debitoACobrar dac "
					+ "LEFT JOIN dac.parcelamento parc "
					+ "WHERE conta.id = :idConta ";
			if (idsFinanciamentoTipo != null && !idsFinanciamentoTipo.isEmpty()) {
				consulta = consulta + "AND fntp.id IN(:idsFinanciamentoTipo) ";

				retorno = session.createQuery(consulta).setInteger("idConta",
						idConta).setParameterList("idsFinanciamentoTipo",
						idsFinanciamentoTipo).list();
			} else {
				retorno = session.createQuery(consulta).setInteger("idConta",
						idConta).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 29/10/2008
	 */
	public Collection pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobranca(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que já monta uma coleção de
		 * GerarArquivoTextoContasCobrancaEmpresaHelper com tudo que é
		 * necessário **
		 */
		try {
			consulta = "select new gcom.cabranca.GerarArquivoTextoContasCobrancaEmpresaHelper("
					+ "    comandoEmpresaCobrancaConta.id,"
					+ "    comandoEmpresaCobrancaConta.empresa,"
					+ "    comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ "    comandoEmpresaCobrancaConta.codigoSetorComercialFinal,"
					+ "	   comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ "    comandoEmpresaCobrancaConta.valorMaximoConta,"
					+ "	   comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	   comandoEmpresaCobrancaConta.referenciaContaFinal,"
					+ "    comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	   comandoEmpresaCobrancaConta.dataVencimentoContaFinal,"
					+ "    comandoEmpresaCobrancaConta.dataExecucao,"
					+ "    comandoEmpresaCobrancaConta.imovel,"
					+ "    comandoEmpresaCobrancaConta.cliente,"
					+ "    comandoEmpresaCobrancaConta.localidadeInicial,"
					+ "    comandoEmpresaCobrancaConta.localidadeFinal,"
					+ "    comandoEmpresaCobrancaConta.unidadeNegocio,"
					+ "    comandoEmpresaCobrancaConta.ultimaAlteracao,"
					+ "    count(ecco.comandoEmpresaCobrancaConta.id),"
					+ "    sum(ecco.cnta_vlagua),"
					+ "    comandoEmpresaCobrancaConta.ultimaAlteracao) "
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ " LEFT JOIN EmpresaCobrancaConta ecco "
					+ "where comandoEmpresaCobrancaConta.Empresa.id = :idEmpresa ";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta + "and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)  + "','YYYY-MM-DD')";

			}

			retorno = session.createQuery(consulta).setInteger("idEmpresa",
					idEmpresa).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 29/10/2008
	 */
	public Collection<Object[]> pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCriterio(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select comandoEmpresaCobrancaConta.id, "
					+ "count(ecco.comandoEmpresaCobrancaConta.id), "
					+ "sum(ecco.cnta_vlagua) "
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "LEFT JOIN EmpresaCobrancaConta ecco "
					+ "where comandoEmpresaCobrancaConta.Empresa.id = :idEmpresa and ecco.indicadorPagamentoValido = 1 ";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta + "and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)  + "','YYYY-MM-DD')";

			}

			retorno = session.createQuery(consulta).setInteger("idEmpresa",
					idEmpresa).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	// ///////////////////////////////////////////////////////////////////////////

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 11/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterDebitoACobrarImovel(Integer imovelID)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac "
					+ "from DebitoACobrar dac "
					+ "inner join dac.imovel imovel "
					+ "inner join fetch dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch dac.debitoTipo debitoTipo "
					+ "where imovel.id = :id "
					+ "order by dac.anoMesReferenciaContabil, debitoCreditoSituacaoAtual.id ";

			retorno = session.createQuery(consulta).setInteger("id", imovelID)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 11/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterDebitoACobrarHistoricoImovel(Integer imovelID)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac "
					+ "from DebitoACobrarHistorico dac "
					+ "inner join dac.imovel imovel "
					+ "inner join fetch dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch dac.debitoTipo debitoTipo "
					+ "where imovel.id = :id "
					+ "order by dac.anoMesReferenciaContabil, debitoCreditoSituacaoAtual.id ";

			retorno = session.createQuery(consulta).setInteger("id", imovelID)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 11/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterCreditoARealizarImovel(Integer imovelID)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car "
					+ "from CreditoARealizar car "
					+ "inner join car.imovel imovel "
					+ "inner join fetch car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch car.creditoTipo creditoTipo "
					+ "where imovel.id = :id "
					+ "order by car.anoMesReferenciaContabil, debitoCreditoSituacaoAtual.id ";

			retorno = session.createQuery(consulta).setInteger("id", imovelID)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 11/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterCreditoARealizarHistoricoImovel(Integer imovelID)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select car "
					+ "from CreditoARealizarHistorico car "
					+ "inner join car.imovel imovel "
					+ "inner join fetch car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch car.creditoTipo creditoTipo "
					+ "where imovel.id = :id "
					+ "order by car.anoMesReferenciaContabil, debitoCreditoSituacaoAtual.id ";

			retorno = session.createQuery(consulta).setInteger("id", imovelID)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterGuiaPagamentoImovel(Integer imovelID)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select guia "
					+ " from GuiaPagamento guia "
					+ " inner join guia.imovel imovel "
					+ " inner join fetch guia.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ " inner join fetch guia.debitoTipo debitoTipo "
					+ " where imovel = :idImovel "
					+ " order by guia.anoMesReferenciaContabil, debitoCreditoSituacaoAtual.id ";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovelID).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterGuiaPagamentoHistoricoImovel(Integer imovelID)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select guia "
					+ " from GuiaPagamentoHistorico guia "
					+ " inner join guia.imovel imovel "
					+ " inner join fetch guia.debitoCreditoSituacaoByDcstIdatual debitoCreditoSituacaoAtual "
					+ " inner join fetch guia.debitoTipo debitoTipo "
					+ " where imovel.id = :idImovel "
					+ " order by guia.anoMesReferenciaContabil, debitoCreditoSituacaoAtual.id ";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovelID).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] Retificar Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 17/11/2008
	 * 
	 * @param idConta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarFaturaItemDeConta(Integer idConta)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT fitm.id, fitm.valorConta, fitm.valorImposto, fatura.id, fatura.debito "
					+ "FROM FaturaItem as fitm "
					+ "INNER JOIN fitm.fatura fatura "
					+ "WHERE fitm.contaGeral.id = :idConta ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] Retificar Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 17/11/2008
	 * 
	 * @param idFaturaItem
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void atualizarContaEmFaturaItem(Integer idFaturaItem, Conta conta,
			Integer consumoFaturaItem) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "UPDATE FaturaItem fitm "
					+ "SET fitm.contaGeral.id = :idConta, fitm.valorConta = :valorConta, fitm.ultimaAlteracao = :ultimaAlteracao ";

			if (conta.getValorImposto() != null) {

				consulta = consulta + ",fitm.valorImposto = :valorImposto ";

				if (consumoFaturaItem != null) {

					consulta = consulta
							+ ",fitm.numeroConsumo = :consumoFaturaItem "
							+ "WHERE fitm.id = :idFaturaItem ";

					session.createQuery(consulta).setInteger("idFaturaItem",
							idFaturaItem).setInteger("idConta", conta.getId())
							.setBigDecimal("valorConta", conta.getValorTotal())
							.setBigDecimal("valorImposto",
									conta.getValorImposto()).setTimestamp(
									"ultimaAlteracao", new Date()).setInteger(
									"consumoFaturaItem", consumoFaturaItem)
							.executeUpdate();
				} else {

					consulta = consulta + "WHERE fitm.id = :idFaturaItem ";

					session.createQuery(consulta).setInteger("idFaturaItem",
							idFaturaItem).setInteger("idConta", conta.getId())
							.setBigDecimal("valorConta", conta.getValorTotal())
							.setBigDecimal("valorImposto",
									conta.getValorImposto()).setTimestamp(
									"ultimaAlteracao", new Date())
							.executeUpdate();
				}

			} else if (consumoFaturaItem != null) {

				consulta = consulta
						+ ",fitm.numeroConsumo = :consumoFaturaItem "
						+ "WHERE fitm.id = :idFaturaItem ";

				session.createQuery(consulta).setInteger("idFaturaItem",
						idFaturaItem).setInteger("idConta", conta.getId())
						.setBigDecimal("valorConta", conta.getValorTotal())
						.setTimestamp("ultimaAlteracao", new Date())
						.setInteger("consumoFaturaItem", consumoFaturaItem)
						.executeUpdate();
			} else {

				consulta = consulta + "WHERE fitm.id = :idFaturaItem ";

				session.createQuery(consulta).setInteger("idFaturaItem",
						idFaturaItem).setInteger("idConta", conta.getId())
						.setBigDecimal("valorConta", conta.getValorTotal())
						.setTimestamp("ultimaAlteracao", new Date())
						.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0150] Retificar Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 17/11/2008
	 * 
	 * @param idFatura
	 * @param valorDebitoFatura
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorDebitoFatura(Integer idFatura,
			BigDecimal valorDebitoFatura) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "UPDATE Fatura fatura ";

			consulta = consulta
					+ "SET fatura.debito = :valorDebito, fatura.ultimaAlteracao = :ultimaAlteracao "
					+ "WHERE fatura.id = :idFatura ";

			session.createQuery(consulta).setInteger("idFatura", idFatura)
					.setBigDecimal("valorDebito", valorDebitoFatura)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 01/12/2008
	 * 
	 * @param codigoCliente
	 * @param anoMes
	 * @param dataVencimentoFaturaInicio
	 * @param dataVencimentoFaturaFim
	 * @param anoMesFim
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarFaturasCliente(Integer codigoCliente,
			Integer anoMes, Date dataVencimentoFaturaInicio,
			Date dataVencimentoFaturaFim, Integer anoMesFim,
			Integer codigoClienteSuperior) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT fatura " + "FROM Fatura fatura "
					+ "INNER JOIN fatura.cliente cliente ";

			consulta = consulta
					+ "WHERE "
					+ " fatura.anoMesReferencia BETWEEN :anoMes AND :anoMesFim ";

			Integer codigo = null;

			if (codigoClienteSuperior != null) {
				consulta += " and cliente.cliente.id = :codigo ";
				codigo = codigoClienteSuperior;
			} else {
				consulta += " and cliente.id = :codigo ";
				codigo = codigoCliente;
			}

			if (dataVencimentoFaturaInicio != null) {

				consulta += "AND fatura.vencimento BETWEEN :dataVencimentoFaturaInicio AND "
						+ ":dataVencimentoFaturaFim ";

				if (dataVencimentoFaturaFim != null) {

					retorno = (Collection) session.createQuery(consulta)
							.setInteger("codigo", codigo).setInteger("anoMes",
									anoMes).setInteger("anoMesFim", anoMesFim)
							.setDate("dataVencimentoFaturaInicio",
									dataVencimentoFaturaInicio).setDate(
									"dataVencimentoFaturaFim",
									dataVencimentoFaturaFim).list();
				} else {

					retorno = (Collection) session.createQuery(consulta)
							.setInteger("codigo", codigo).setInteger("anoMes",
									anoMes).setInteger("anoMesFim", anoMesFim)
							.setDate("dataVencimentoFaturaInicio",
									dataVencimentoFaturaInicio).setDate(
									"dataVencimentoFaturaFim",
									dataVencimentoFaturaInicio).list();
				}
			} else {

				retorno = (Collection) session.createQuery(consulta)
						.setInteger("codigo", codigo).setInteger("anoMes",
								anoMes).setInteger("anoMesFim", anoMesFim)
						.list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 01/12/2008
	 * 
	 * @param fatura
	 * @throws ErroRepositorioException
	 */
	public void alterarVencimentoFatura(Fatura fatura)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {

			update = "UPDATE gcom.faturamento.conta.Fatura SET "
					+ "fatu_dtvencimento = :dataVencimento, fatu_dtvalidade = :dataValidade, "
					+ "fatu_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE fatu_id = :idFatura ";

			session.createQuery(update).setDate("dataVencimento",
					fatura.getVencimento()).setDate("dataValidade",
					fatura.getValidade()).setTimestamp("dataUltimaAlteracao",
					fatura.getUltimaAlteracao()).setInteger("idFatura",
					fatura.getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * É necessário colocar a query abaixo no processo de faturar grupo como uma
	 * funcionalidade (Antes de rodar o faturar), para atender uma necessidade
	 * de uma localidade (Petrolina), onde existe uma cobrança diferenciada de
	 * esgoto. CRC771 - Socorro Oliveira
	 * 
	 * @author Raphael Rossiter
	 * @date 22/12/2008
	 * 
	 * @param percentualAlternativo
	 * @param consumoPercentualAlternativo
	 * @param rota
	 * @throws ErroRepositorioException
	 */
	public void atualizarLigacaoEsgotoPorRota(BigDecimal percentualAlternativo,
			Integer consumoPercentualAlternativo, Rota rota)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String update = "UPDATE atendimentopublico.ligacao_esgoto SET "
					+ "lesg_pcalternativo = ?, "
					+ "lesg_nnconsumopcalternativo = ?, "
					+ "lesg_tmultimaalteracao = ? "
					+ "WHERE lesg_id IN ( "
					+ "SELECT DISTINCT (im.imov_id) FROM cadastro.imovel im "
					+ "INNER JOIN cadastro.quadra qdra on (qdra.qdra_id = im.qdra_id) "
					+ "INNER JOIN micromedicao.rota rota on (rota.rota_id = qdra.rota_id) "
					+ "INNER JOIN cadastro.imovel_subcategoria ims on (im.imov_id = ims.imov_id) "
					+ "WHERE rota.rota_id = ? AND im.loca_id = 111 "
					+ "AND im.last_id in (? , ?, ?) "
					+ "AND im.lest_id = ? AND ims.scat_id < 20) "
					+ "AND lesg_nnconsumopcalternativo IS NULL ";

			st = jdbcCon.prepareStatement(update);
			st.setBigDecimal(1, percentualAlternativo);
			st.setInt(2, consumoPercentualAlternativo);
			st.setTimestamp(3, Util.getSQLTimesTemp(new Date()));
			st.setInt(4, rota.getId());
			st.setInt(5, LigacaoAguaSituacao.LIGADO);
			st.setInt(6, LigacaoAguaSituacao.EM_FISCALIZACAO);
			st.setInt(7, LigacaoAguaSituacao.CORTADO);
			st.setInt(8, LigacaoEsgotoSituacao.LIGADO);

			st.executeUpdate();

		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] Retificar Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 06/01/2009
	 * 
	 * @param idConta
	 * @return ContaMotivoRevisao
	 * @throws ErroRepositorioException
	 */
	public ContaMotivoRevisao pesquisarContaMotivoRevisao(Integer idConta)
			throws ErroRepositorioException {

		ContaMotivoRevisao retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cmrv FROM Conta conta "
					+ "INNER JOIN conta.contaMotivoRevisao cmrv "
					+ "WHERE conta.id = :idConta ";

			retorno = (ContaMotivoRevisao) session.createQuery(consulta)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0877] EmitirGuiaPagamentoEmAtraso
	 * 
	 * @author Flávio Leonardo
	 * @date 27/01/2009
	 */
	public Collection pesquisarDadosRelatorioGuiaPagamentoEmAtraso(
			FiltroGuiaPagamento filtro) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;
		String condicional = "";
		Collection filtroParametros = filtro.getParametros();

		try {

			Iterator iterator = filtroParametros.iterator();
			while (iterator.hasNext()) {
				FiltroParametro filtroParametro = (FiltroParametro) iterator
						.next();

				if (filtroParametro instanceof ParametroSimples) {
					ParametroSimples parametroSimples = ((ParametroSimples) filtroParametro);

					if (parametroSimples.getNomeAtributo().trim()
							.equalsIgnoreCase(
									FiltroGuiaPagamento.FINANCIAMENTO_TIPO_ID)) {

						condicional += " AND guia."
								+ parametroSimples.getNomeAtributo() + " = "
								+ parametroSimples.getValor() + " ";
					}
				} else if (filtroParametro instanceof Intervalo) {
					Intervalo intervalo = ((Intervalo) filtroParametro);

					if (intervalo.getNomeAtributo().trim().equalsIgnoreCase(
							FiltroGuiaPagamento.DATA_VENCIMENTO)) {
						// vencimento
						condicional += " AND (guia."
								+ intervalo.getNomeAtributo()
								+ " BETWEEN to_date('"
								+ Util
										.formatarDataComTracoAAAAMMDD((Date) intervalo
												.getIntervaloInicial())
								+ "','YYYY-MM-DD') AND to_date('"
								+ Util
										.formatarDataComTracoAAAAMMDD((Date) intervalo
												.getIntervaloFinal()) + "','YYYY-MM-DD')) ";

					} else {
						// referencia contabil
						condicional += " AND (guia."
								+ intervalo.getNomeAtributo() + " BETWEEN "
								+ intervalo.getIntervaloInicial() + " AND "
								+ intervalo.getIntervaloFinal() + ") ";
					}
				}

			}

			consulta = "SELECT guia FROM GuiaPagamento guia "
					+ "INNER JOIN FETCH guia.debitoTipo "
					+ "INNER JOIN FETCH guia.financiamentoTipo "
					+ " WHERE not exists"

					+ " (SELECT pag.id FROM Pagamento pag "
					+ " WHERE pag.guiaPagamento.id = guia.id "
					+ ") and not exists "

					+ " (SELECT pagHis.id FROM PagamentoHistorico pagHis "
					+ " WHERE pagHis.guiaPagamento.id = guia.id " + ") "

					+ condicional + " order by guia.dataVencimento";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar categoria por tarifa consumo
	 * 
	 * @author Rômulo Aurélio
	 * @date 19/12/2008
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCategoriaPorTarifaConsumo(Integer idConsumoTarifa)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select cstc.catg_id as idCategoria "
					+ "from faturamento.consumo_tarifa cstf "
					+ "left join faturamento.consumo_tarifa_vigencia cstv on cstv.cstf_id = cstf.cstf_id "
					+ "left join faturamento.consumo_tarifa_categoria cstc on cstc.cstv_id = cstv.cstv_id "
					+ "where cstf.cstf_id = :idConsumoTarifa and cstv.cstv_dtvigencia = (select max(cstv_dtvigencia) "
					+ "from faturamento.consumo_tarifa_vigencia where cstf_id = cstf.cstf_id)"
					+ "group by cstc.catg_id order by cstc.catg_id";

			retorno = session.createSQLQuery(consulta).addScalar("idCategoria",
					Hibernate.INTEGER).setInteger("idConsumoTarifa",
					idConsumoTarifa).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0871] Manter Fatura de Cliente Responsável
	 */
	public Integer maximoNumeroSequencia(Fatura fatura)
			throws ErroRepositorioException {
		Integer numeroSequencia = new Integer("0");

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select max(fatHis.itemSequencia) from FaturaItemHistorico fatHis"
					+ " where fatHis.fatura.id = :idFatura";

			numeroSequencia = (Integer) session.createQuery(consulta)
					.setInteger("idFatura", fatura.getId()).setMaxResults(1)
					.uniqueResult();

			if (numeroSequencia == null) {
				numeroSequencia = 0;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return numeroSequencia;
	}

	/**
	 * [UC0871] Manter Fatura de Cliente Responsável
	 */
	public Integer maximoNumeroSequenciaFaturaItem(Fatura fatura)
			throws ErroRepositorioException {
		Integer numeroSequencia = new Integer("0");

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select max(fatItem.itemSequencia) from FaturaItem fatItem"
					+ " where fatItem.fatura.id = :idFatura";

			numeroSequencia = (Integer) session.createQuery(consulta)
					.setInteger("idFatura", fatura.getId()).setMaxResults(1)
					.uniqueResult();

			if (numeroSequencia == null) {
				numeroSequencia = 0;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return numeroSequencia;
	}

	/**
	 * [UC0871] Manter Fatura de Cliente Responsável
	 */
	public BigDecimal somarValorFaturasItemFatura(Fatura fatura)
			throws ErroRepositorioException {
		BigDecimal retorno = BigDecimal.ZERO;
		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select sum(fatItem.valorConta) from FaturaItem fatItem"
					+ " where fatItem.fatura.id = :idFatura";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idFatura", fatura.getId()).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0871] Manter Fatura de Cliente Responsável
	 */
	public Date vencimentoFaturasItemFatura(Fatura fatura)
			throws ErroRepositorioException {
		Date retorno = null;
		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select max(fatItem.contaGeral.conta.dataVencimentoConta) from FaturaItem fatItem"
					+ " where fatItem.fatura.id = :idFatura";

			retorno = (Date) session.createQuery(consulta).setInteger(
					"idFatura", fatura.getId()).setMaxResults(1).uniqueResult();

			if (retorno == null) {
				consulta = "select max(fatItem.contaGeral.contaHistorico.dataVencimentoConta) from FaturaItem fatItem"
						+ " where fatItem.fatura.id = :idFatura";

				retorno = (Date) session.createQuery(consulta).setInteger(
						"idFatura", fatura.getId()).setMaxResults(1)
						.uniqueResult();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0871] Manter Fatura de Cliente Responsável
	 * 
	 * @param fatura
	 * @throws ErroRepositorioException
	 */
	public void alterarVencimentoFaturaFaturaItem(Fatura fatura)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {

			update = "UPDATE Fatura SET "
					+ "vencimento = :dataVencimento,  debito= :debito, "
					+ "ultimaAlteracao = :dataUltimaAlteracao "
					+ "WHERE fatu_id = :idFatura ";

			session.createQuery(update).setDate("dataVencimento",
					fatura.getVencimento()).setBigDecimal("debito",
					fatura.getDebito()).setTimestamp("dataUltimaAlteracao",
					fatura.getUltimaAlteracao()).setInteger("idFatura",
					fatura.getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0876] - Gerar Crédito Situação Especial Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 27/01/2009
	 * 
	 * @param anoMesFaturamento
	 * @param idRota
	 * @param idCreditoTipo
	 * @return qtdCreditosARealizar por Rota
	 * @throws ErroRepositorioException
	 */
	public Integer quantidadeCreditosARealizarRota(Integer anoMesFaturamento,
			Rota rota, Integer idCreditoTipo) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String consulta = null;

		Integer retorno = null;

		try {
			consulta = "SELECT count(crar.id) FROM CreditoARealizar crar "
					+ "INNER JOIN crar.imovel imov "
					+ "INNER JOIN crar.creditoTipo crti ";

			/*
			 * Caso a rota não esteja com o indicador de rota alternativa ativo;
			 * a pesquisa dos imóveis será feita a partir de sua quadra.
			 */
			if (!rota.getIndicadorRotaAlternativa().equals(
					ConstantesSistema.SIM)) {

				consulta = consulta + "INNER JOIN imov.quadra qdra "
						+ "INNER JOIN qdra.rota rota ";
			}
			/*
			 * Caso contrário; a pesquisa dos imóveis será feita a partir da
			 * rota alternativa que estará associada ao mesmo.
			 */
			else {

				consulta = consulta + "INNER JOIN imov.rotaAlternativa rota ";
			}

			consulta = consulta
					+ "WHERE rota.id = :idRota AND crar.anoMesReferenciaCredito = :anoMesFaturamento "
					+ "AND crti.id = :idCreditoTipo ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"anoMesFaturamento", anoMesFaturamento).setInteger(
					"idRota", rota.getId().intValue()).setInteger(
					"idCreditoTipo", idCreditoTipo).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0876] - Gerar Crédito Situação Especial Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 27/01/2009
	 * 
	 * @param helper
	 * @throws ErroRepositorioException
	 */
	public void apagarCreditoARealizarCategoria(
			ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.cred_a_realiz_catg where crar_id in  ";

			/*
			 * Caso a rota não esteja com o indicador de rota alternativa ativo;
			 * a pesquisa dos imóveis será feita a partir de sua quadra.
			 */
			if (!helper.getRota().getIndicadorRotaAlternativa().equals(
					ConstantesSistema.SIM)) {

				delete = delete
						+ " (select crar_id from faturamento.credito_a_realizar crar, cadastro.imovel imov, "
						+ " cadastro.quadra qdra, micromedicao.rota rota "
						+ " where crar.crar_amreferenciacredito = ? and crar.crti_id = ? "
						+ " and crar.imov_id = imov.imov_id and imov.qdra_id = qdra.qdra_id "
						+ " and qdra.rota_id = rota.rota_id and rota.rota_id = ? and crar.dcst_idatual = ?)";
			}
			/*
			 * Caso contrário; a pesquisa dos imóveis será feita a partir da
			 * rota alternativa que estará associada ao mesmo.
			 */
			else {

				delete = delete
						+ " (select crar_id from faturamento.credito_a_realizar crar, cadastro.imovel imov, "
						+ " micromedicao.rota rota "
						+ " where crar.crar_amreferenciacredito = ? and crar.crti_id = ? "
						+ " and crar.imov_id = imov.imov_id "
						+ " and imov.rota_idalternativa = rota.rota_id and rota.rota_id = ? and crar.dcst_idatual = ?)";
			}

			if (helper.getDataEmissaoInicial() != null) {
				delete = delete.substring(0, delete.length() - 1)
						+ " and crar.crar_tmatucredito between ? and ? and crar_nnprestacaorealizadas = 0)";
			}

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, helper.getAnoMesFaturamento());
			st.setInt(2, helper.getIdCreditoTipo());
			st.setInt(3, helper.getRota().getId().intValue());
			st.setInt(4, helper.getIdDebitoCreditoSituacaoAtual().intValue());

			if (helper.getDataEmissaoInicial() != null) {
				st.setTimestamp(5, Util.getSQLTimesTemp(helper
						.getDataEmissaoInicial()));
				st.setTimestamp(6, Util.getSQLTimesTemp(helper
						.getDataEmissaoFinal()));
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
				session.flush();
				HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0876] - Gerar Crédito Situação Especial Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 27/01/2009
	 * 
	 * @param helper
	 * @throws ErroRepositorioException
	 */
	public void atualizarCreditoARealizarGeral(
			ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		String atualizar = null;

		try {

			Connection jdbcCon = session.connection();

			atualizar = "update faturamento.credito_a_realizar_geral set cage_ichistorico=3 where crar_id in ";

			/*
			 * Caso a rota não esteja com o indicador de rota alternativa ativo;
			 * a pesquisa dos imóveis será feita a partir de sua quadra.
			 */
			if (!helper.getRota().getIndicadorRotaAlternativa().equals(
					ConstantesSistema.SIM)) {

				atualizar = atualizar
						+ " (select crar_id from faturamento.credito_a_realizar crar, cadastro.imovel imov, "
						+ " cadastro.quadra qdra, micromedicao.rota rota "
						+ " where crar.crar_amreferenciacredito = ? and crar.crti_id = ? "
						+ " and crar.imov_id = imov.imov_id and imov.qdra_id = qdra.qdra_id "
						+ " and qdra.rota_id = rota.rota_id and rota.rota_id = ? and crar.dcst_idatual = ?)";
			}
			/*
			 * Caso contrário; a pesquisa dos imóveis será feita a partir da
			 * rota alternativa que estará associada ao mesmo.
			 */
			else {

				atualizar = atualizar
						+ " (select crar_id from faturamento.credito_a_realizar crar, cadastro.imovel imov, "
						+ " micromedicao.rota rota "
						+ " where crar.crar_amreferenciacredito = ? and crar.crti_id = ? "
						+ " and crar.imov_id = imov.imov_id "
						+ " and imov.rota_idalternativa = rota.rota_id and rota.rota_id = ? and crar.dcst_idatual = ?)";
			}

			if (helper.getDataEmissaoInicial() != null) {
				atualizar = atualizar.substring(0, atualizar.length() - 1)
						+ " and crar.crar_tmatucredito between ? and ? and crar_nnprestacaorealizadas = 0)";
			}

			st = jdbcCon.prepareStatement(atualizar);
			st.setInt(1, helper.getAnoMesFaturamento());
			st.setInt(2, helper.getIdCreditoTipo());
			st.setInt(3, helper.getRota().getId().intValue());
			st.setInt(4, helper.getIdDebitoCreditoSituacaoAtual().intValue());

			if (helper.getDataEmissaoInicial() != null) {
				st.setTimestamp(5, Util.getSQLTimesTemp(helper
						.getDataEmissaoInicial()));
				st.setTimestamp(6, Util.getSQLTimesTemp(helper
						.getDataEmissaoFinal()));
			}

			st.executeUpdate();
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			session.flush();
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0876] - Gerar Crédito Situação Especial Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 27/01/2009
	 * 
	 * @param helper
	 * @throws ErroRepositorioException
	 */
	public void apagarCreditoARealizar(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;
		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.credito_a_realizar where crar_id in ";

			/*
			 * Caso a rota não esteja com o indicador de rota alternativa ativo;
			 * a pesquisa dos imóveis será feita a partir de sua quadra.
			 */
			if (!helper.getRota().getIndicadorRotaAlternativa().equals(
					ConstantesSistema.SIM)) {

				delete = delete
						+ " (select crar_id from faturamento.credito_a_realizar crar, cadastro.imovel imov, "
						+ " cadastro.quadra qdra, micromedicao.rota rota "
						+ " where crar.crar_amreferenciacredito = ? and crar.crti_id = ? "
						+ " and crar.imov_id = imov.imov_id and imov.qdra_id = qdra.qdra_id "
						+ " and qdra.rota_id = rota.rota_id and rota.rota_id = ? and crar.dcst_idatual = ?)";
			}
			/*
			 * Caso contrário; a pesquisa dos imóveis será feita a partir da
			 * rota alternativa que estará associada ao mesmo.
			 */
			else {

				delete = delete
						+ " (select crar_id from faturamento.credito_a_realizar crar, cadastro.imovel imov, "
						+ " micromedicao.rota rota "
						+ " where crar.crar_amreferenciacredito = ? and crar.crti_id = ? "
						+ " and crar.imov_id = imov.imov_id "
						+ " and imov.rota_idalternativa = rota.rota_id and rota.rota_id = ? and crar.dcst_idatual = ?)";
			}

			if (helper.getDataEmissaoInicial() != null) {
				delete = delete.substring(0, delete.length() - 1)
						+ " and crar.crar_tmatucredito between ? and ? and crar_nnprestacaorealizadas = 0)";
			}

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, helper.getAnoMesFaturamento().intValue());
			st.setInt(2, helper.getIdCreditoTipo().intValue());
			st.setInt(3, helper.getRota().getId().intValue());
			st.setInt(4, helper.getIdDebitoCreditoSituacaoAtual().intValue());

			if (helper.getDataEmissaoInicial() != null) {
				st.setTimestamp(5, Util.getSQLTimesTemp(helper
						.getDataEmissaoInicial()));
				st.setTimestamp(6, Util.getSQLTimesTemp(helper
						.getDataEmissaoFinal()));
			}

			int qdt = st.executeUpdate();
			System.out.println("quantidade"+ qdt);
			System.out.println("descriçao"+ delete);
		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}

			// fecha a sessão
			session.flush();
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0876] - Gerar Crédito Situação Especial Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 27/01/2009
	 * 
	 * @param helper
	 * @throws ErroRepositorioException
	 */
	public void apagarCreditoARealizarGeral(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = "delete from faturamento.credito_a_realizar_geral where cage_ichistorico = 3 ";

			st = jdbcCon.prepareStatement(delete);

			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}

			//fecha a sessão
			session.flush();
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0819] Gerar Historico do Encerramento do Faturamento
	 * 
	 * Verifica se existe ocorrência na tabela RESUMO_FATURAMENTO
	 * 
	 * @author Raphael Rossiter
	 * @date 10/02/2009
	 * 
	 * @param anoMesReferencia
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarResumoFaturamento(Integer anoMesReferencia)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT count(resumo.id) "
					+ "FROM ResumoFaturamento resumo "
					+ "WHERE resumo.anoMesReferencia = :anoMesReferencia ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0215] Consultar Posicao de Faturamento
	 * 
	 * @author Vinicius Medeiros
	 * @date 11/03/2009
	 * 
	 * @param faturamentoGrupo
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection retornaLeiturasNaoRegistradas(
			FaturamentoGrupo faturamentoGrupo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select localidade.id,"
					+ " localidade.descricao, "
					+ " mre.codigoSetorComercial,"
					+ " setorComercial.descricao,"
					+ " mre.codigoRota,"
					+ " count(mre.imovel.id)"
					+ " from MovimentoRoteiroEmpresa mre, SetorComercial setorComercial"
					+ " inner join mre.localidade localidade "
					+ " where mre.anoMesMovimento = :anoMes"
					+ " and setorComercial.localidade.id = localidade.id and setorComercial.codigo = mre.codigoSetorComercial "
					+ " and mre.faturamentoGrupo.id = :faturamentoGrupoId"
					+ " and not exists"
					+ " (select mh.ligacaoAgua.id from MedicaoHistorico mh"
					+ " where mh.anoMesReferencia = :anoMes"
					+ " and (mh.ligacaoAgua.id = mre.imovel.id or mh.imovel.id = mre.imovel.id))"
					+ "  GROUP BY  localidade.id,  localidade.descricao,  mre.codigoSetorComercial,  setorComercial.descricao,  mre.codigoRota " + " order by 1,2,3,4,5";

			retorno = session.createQuery(consulta).setInteger("anoMes",
					faturamentoGrupo.getAnoMesReferencia()).setInteger(
					"faturamentoGrupoId", faturamentoGrupo.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Sávio Luiz
	 * @date 31/03/2009
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorCreditoPorOrigem(int idConta)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select sum(cr.valorCredito) "
					+ "from CreditoRealizado cr " + "inner join cr.conta cnta "
					+ "inner join cr.creditoOrigem co "
					+ "where cnta.id = :idConta " + "and co.id = :descontoCon";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idConta", idConta).setInteger("descontoCon",
					CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * [SB0005] - Obter Valor do Parcelamento Concedido como Bonus
	 * 
	 * Acumula ((DBCG_VLCATEGORIA / DBAC_NNPRESTACAODEBITO) *
	 * DBAC_NNPARCELABONUS) a partir das tabelas DEBITO_A_COBRAR_CATEGORIA e
	 * DEBITO_A_COBRAR com mesmo DBAC_ID e com DBAC_NNPARCELABONUS diferente de
	 * nulo e maior que zero e DBAC_NNPRESTACAOCOBRADAS = DBAC_NNPRESTACAODEBITO -
	 * DBAC_NNPARCELABONUS
	 * 
	 * @author Raphael Rossiter
	 * @date 24/03/2009
	 * 
	 * @param idLocalidade
	 * @param idCategoria
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoACobrarParcelamentoConcedidoBonus(
			Integer idLocalidade, Integer idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			/*
			 * Colocado por Raphael Rossiter em 24/03/2009 - Analista: Aryed
			 * Lins OBJ - Correção da contabilização dos créditos a realizar
			 * cancelados para considerar as parcelas já concedidas (Sequencial
			 * 3200). CRC1153.
			 */
			consulta = " SELECT SUM( ( dbcg.dbcg_vlcategoria / dbac.dbac_nnprestacaodebito ) "
					+ " * dbac.dbac_nnparcelabonus ) as col_1 "
					+

					" FROM faturamento.deb_a_cobrar_catg dbcg "
					+ " INNER JOIN faturamento.debito_a_cobrar dbac on dbcg.dbac_id = dbac.dbac_id "
					+

					" WHERE dbac.loca_id = :idLocalidade "
					+ " AND dbcg.catg_id = :idCategoria "
					+ " AND (dbac.dbac_nnparcelabonus IS NOT NULL AND dbac.dbac_nnparcelabonus > 0) "
					+ " AND dbac.dbac_nnprestacaocobradas = (dbac.dbac_nnprestacaodebito - dbac.dbac_nnparcelabonus)";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * [SB0005] - Obter Valor do Parcelamento Concedido como Bonus
	 * 
	 * Acumula negativamente ((CACG_VLCATEGORIA / CRAR_NNPRESTACAOCREDITO) *
	 * CRAR_NNPARCELABONUS) a partir das tabelas CREDITO_A_REALIZAR_CATEGORIA e
	 * CREDITO_A_REALIZAR com mesmo CRAR_ID e com CRAR_NNPARCELABONUS diferente
	 * de nulo e maior que zero e CRAR_NNPRESTACAOREALIZADAS =
	 * CRAR_NNPRESTACAOCREDITO - CRAR_NNPARCELABONUS
	 * 
	 * @author Raphael Rossiter
	 * @date 24/03/2009
	 * 
	 * @param idLocalidade
	 * @param idCategoria
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoARealizarParcelamentoConcedidoBonus(
			Integer idLocalidade, Integer idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			/*
			 * Colocado por Raphael Rossiter em 24/03/2009 - Analista: Aryed
			 * Lins OBJ - Correção da contabilização dos créditos a realizar
			 * cancelados para considerar as parcelas já concedidas (Sequencial
			 * 3200). CRC1153.
			 */
			consulta = " SELECT SUM( ( cacg.cacg_vlcategoria / crar.crar_nnprestacaocredito ) "
					+ " * crar_nnparcelabonus ) as col_1 "
					+

					" FROM faturamento.cred_a_realiz_catg cacg "
					+ " INNER JOIN faturamento.credito_a_realizar crar on cacg.crar_id = crar.crar_id "
					+

					" WHERE crar.loca_id = :idLocalidade "
					+ " AND cacg.catg_id = :idCategoria "
					+ " AND (crar.crar_nnparcelabonus IS NOT NULL AND crar.crar_nnparcelabonus > 0) "
					+ " AND crar.crar_nnprestacaorealizadas = (crar.crar_nnprestacaocredito - crar_nnparcelabonus)";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger("idLocalidade",
					idLocalidade).setInteger("idCategoria", idCategoria)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa o valor da água da conta.
	 * 
	 * @author Sávio Luiz
	 * @date 11/05/2009
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorAguaConta(Integer idImovel,
			Integer referencia) throws ErroRepositorioException {

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cnta.valorAgua "
					+ "from Conta cnta "
					+ "inner join cnta.imovel im "
					+ "where im.id = :idImovel and cnta.referencia = :referencia";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setInteger("referencia", referencia)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * Calcula os dados do consumo tarifa de vigência
	 * 
	 * @author Sávio Luiz
	 * @date 02/07/2009
	 * 
	 * @param consumoTarifa
	 * @param dataFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosConsumoTarifaVigenciaProporcional(
			Date dataLeituraAnterior, Integer idConsumoTarifa,
			Integer idCategoria, Integer idSubcategoria)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ctcg.id,"// 0
					+ "ct.id,"// 1
					+ "ctv.dataVigencia,"// 2
					+ "catg.id,subCatg.id,"// 3,4
					+ "ctcg.numeroConsumoMinimo,"// 5
					+ "ctcg.valorTarifaMinima "// 6
					+ "from ConsumoTarifaCategoria ctcg "
					+ "inner join ctcg.consumoTarifaVigencia ctv "
					+ "inner join ctv.consumoTarifa ct "
					+ "inner join ctcg.categoria catg "
					+ "inner join ctcg.subCategoria subCatg "
					+ "where ctv.dataVigencia between :dataLeituraAnterior  and  :dataLeituraAtual "
					+ " AND ct.id = :idConsumoTarifa AND "
					+ "     catg.id = :idCategoria AND "
					+ "     subCatg.id = :idSubcategoria "
					+ "order by ctv.dataVigencia ";

			retorno = session.createQuery(consulta).setDate(
					"dataLeituraAnterior", dataLeituraAnterior).setDate(
					//"dataLeituraAtual", Util.adicionarNumeroDiasDeUmaData(new Date(),5)).setInteger(
							"dataLeituraAtual", new Date()).setInteger(
					"idConsumoTarifa", idConsumoTarifa).setInteger(
					"idCategoria", idCategoria).setInteger("idSubcategoria",
					idSubcategoria).list();
		
//			retorno = session.createQuery(consulta).setDate(
//					"dataLeituraAnterior", dataLeituraAnterior).setDate(
//					"dataLeituraAtual", new Date()).setInteger(
//					"idConsumoTarifa", idConsumoTarifa).setInteger(
//					"idCategoria", idCategoria).setInteger("idSubcategoria",
//					idSubcategoria).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * Calcula os dados do consumo tarifa de vigência
	 * 
	 * @author Sávio Luiz
	 * @date 02/07/2009
	 * 
	 * @param consumoTarifa
	 * @param dataFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosConsumoTarifaVigencia(Date dataFaturamento,
			Integer idConsumoTarifa, Integer idCategoria, Integer idSubcategoria)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT ctcg.id,"// 0
					+ "ct.id,"// 1
					+ "ctv.dataVigencia,"// 2
					+ "catg.id,subCatg.id,"// 3,4
					+ "ctcg.numeroConsumoMinimo,"// 5
					+ "ctcg.valorTarifaMinima "// 6
					+ "FROM ConsumoTarifaCategoria ctcg "
					+ "inner join ctcg.consumoTarifaVigencia ctv "
					+ "inner join ctv.consumoTarifa ct "
					+ "inner join ctcg.categoria catg "
					+ "inner join ctcg.subCategoria subCatg "
					+ "WHERE ctv.dataVigencia = :dataFaturamento AND "
					+ "      ct.id = :idConsumoTarifa AND "
					+ "      catg.id = :idCategoria AND "
					+ "      subCatg.id = :idSubcategoria "
					+ "order by ctv.dataVigencia DESC";

			retorno = session.createQuery(consulta).setDate("dataFaturamento",
					dataFaturamento).setInteger("idConsumoTarifa",
					idConsumoTarifa).setInteger("idCategoria", idCategoria)
					.setInteger("idSubcategoria", idSubcategoria).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * Calcula os dados do consumo tarifa de vigência
	 * 
	 * @author Sávio Luiz
	 * @date 02/07/2009
	 * 
	 * @param consumoTarifa
	 * @param dataFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosConsumoMaiorTarifaVigenciaPorTarifa(
			Date dataFaturamento, Integer idTarifaVigencia)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT ct.id,MAX(ctv.dataVigencia) "
					+ " FROM  ConsumoTarifaVigencia ctv "
					+ " INNER JOIN ctv.consumoTarifa ct "
					+ " WHERE ctv.dataVigencia <= :dataFaturamento ";
			if (idTarifaVigencia != null) {
				consulta = consulta + "AND ct.id = " + idTarifaVigencia;
			}
			consulta = consulta + " GROUP BY ct.id";

			retorno = session.createQuery(consulta).setDate("dataFaturamento",
					dataFaturamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * Calcula os dados do consumo tarifa de vigência
	 * 
	 * @author Sávio Luiz
	 * @date 02/07/2009
	 * 
	 * @param consumoTarifa
	 * @param dataFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosConsumoTarifaFaixa(
			Collection idsConsumoTarifaCategoria)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct.id,"// 0
					+ "ctv.dataVigencia,"// 1
					+ "catg.id,subCatg.id,"// 2,3
					+ "ctfx.numeroConsumoFaixaInicio,"// 4
					+ "ctfx.numeroConsumoFaixaFim, "// 5
					+ "ctfx.valorConsumoTarifa "// 6
					+ "from ConsumoTarifaFaixa ctfx "
					+ "inner join ctfx.consumoTarifaCategoria ctcg "
					+ "inner join ctcg.consumoTarifaVigencia ctv "
					+ "inner join ctv.consumoTarifa ct "
					+ "inner join ctcg.categoria catg "
					+ "inner join ctcg.subCategoria subCatg "
					+ "where ctcg.id in (:idsConsumoTarifaCategoria) "
					+ "order by ct.id,ctv.dataVigencia, "
					+ "catg.id,subCatg.id,ctfx.numeroConsumoFaixaInicio ";

			retorno = session.createQuery(consulta).setParameterList(
					"idsConsumoTarifaCategoria", idsConsumoTarifaCategoria)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0857] - Conta quantidade de registros do relatorio
	 * 
	 * @author Hugo Amorim
	 * @date 10/07/2009
	 * 
	 * @param idUnidadeNegocio,
	 *            idFuncionario, dataPagamentoInicial, dataPagamentoFinal
	 * @throws ErroRepositorioException
	 */
	public int countRelatorioAutoInfracao(Integer idUnidadeNegocio,
			Integer idFuncionario, Integer dataPagamentoInicial,
			Integer dataPagamentoFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		int retorno = 0;
		Collection resultado = null;
		String consulta = null;

		try {
			consulta = " SELECT count(*) as qtde "
					+ " FROM faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar"
					+ " INNER JOIN faturamento.debito_cobrado debCob on debCob.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN arrecadacao.pagamento pagto on (pagto.dbac_id = autosInfracaoDebitoACobrar.dbac_id or pagto.cnta_id = debcob.cnta_id) "
					+ " INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id"
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = pagto.loca_id"
					+ " INNER JOIN cadastro.unidade_negocio unidNeg on unidNeg.uneg_id = loca.uneg_id"
					+ " INNER JOIN cadastro.funcionario funcionario on funcionario.func_id = autoInfracao.func_id"
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null"
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id"
					+ " INNER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id"
					+ " INNER JOIN atendimentopublico.fiscaliz_sit_serv_a_cob fisSitServACobrar on (fisSitServACobrar.fzst_id = autoInfracao.fzst_id and fisSitServACobrar.dbtp_id = debitoACobrar.dbtp_id"
					+ " and fisSitServACobrar.fscb_icmultaaltoinfracao = 1)"
					+ " WHERE autosInfracaoDebitoACobrar.aida_icmultaautoinfracao = 1 and ";

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				consulta = consulta
						+ " pagto.pgmt_amreferenciaarrecadacao between :dataPagamentoInicial and :dataPagamentoFinal and ";
			} else {
				consulta = consulta
						+ " pagto.pgmt_amreferenciaarrecadacao = :dataPagamentoInicial and ";
			}

			if (idUnidadeNegocio != null) {
				consulta = consulta + " unidNeg.uneg_id = " + idUnidadeNegocio
						+ " and ";
			}

			if (idFuncionario != null) {
				consulta = consulta + " funcionario.func_id = " + idFuncionario
						+ " and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION ALL "
					+ " SELECT count(*) as qtde "
					+ " FROM faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar"
					+ " INNER JOIN arrecadacao.pagamento pagto on pagto.dbac_id = autosInfracaoDebitoACobrar.dbac_id "
					+ " INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id"
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = pagto.loca_id"
					+ " INNER JOIN cadastro.unidade_negocio unidNeg on unidNeg.uneg_id = loca.uneg_id"
					+ " INNER JOIN cadastro.funcionario funcionario on funcionario.func_id = autoInfracao.func_id"
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null"
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id"
					+ " INNER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id"
					+ " INNER JOIN atendimentopublico.fiscaliz_sit_serv_a_cob fisSitServACobrar on (fisSitServACobrar.fzst_id = autoInfracao.fzst_id and fisSitServACobrar.dbtp_id = debitoACobrar.dbtp_id"
					+ " and fisSitServACobrar.fscb_icmultaaltoinfracao = 1)"
					+ " WHERE autosInfracaoDebitoACobrar.aida_icmultaautoinfracao = 1 and ";

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				consulta = consulta
						+ " pagto.pgmt_amreferenciaarrecadacao between :dataPagamentoInicial and :dataPagamentoFinal and ";
			} else {
				consulta = consulta
						+ " pagto.pgmt_amreferenciaarrecadacao = :dataPagamentoInicial and ";
			}
			if (idUnidadeNegocio != null) {
				consulta = consulta + " unidNeg.uneg_id = " + idUnidadeNegocio
						+ " and ";
			}

			if (idFuncionario != null) {
				consulta = consulta + " funcionario.func_id = " + idFuncionario
						+ " and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION ALL "
					+ " SELECT count(*) as qtde "
					+ " FROM faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar"
					+ " INNER JOIN faturamento.debito_cobrado_historico debCobHist on debCobHist.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN arrecadacao.pagamento_historico pagtoHist on pagtoHist.cnta_id = debCobHist.cnta_id"
					+ " INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id"
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = pagtoHist.loca_id"
					+ " INNER JOIN cadastro.unidade_negocio unidNeg on unidNeg.uneg_id = loca.uneg_id"
					+ " INNER JOIN cadastro.funcionario funcionario on funcionario.func_id = autoInfracao.func_id"
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null"
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id"
					+ " LEFT OUTER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " LEFT OUTER JOIN faturamento.deb_a_cobrar_hist debitoACobrarHistorico on debitoACobrarHistorico.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id or debitoTipo.dbtp_id = debitoACobrarHistorico.dbtp_id"
					+ " INNER JOIN atendimentopublico.fiscaliz_sit_serv_a_cob fisSitServACobrar on (fisSitServACobrar.fzst_id = autoInfracao.fzst_id and fisSitServACobrar.dbtp_id = debitoTipo.dbtp_id"
					+ " and fisSitServACobrar.fscb_icmultaaltoinfracao = 1)"
					+ " WHERE autosInfracaoDebitoACobrar.aida_icmultaautoinfracao = 1 and ";

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				consulta = consulta
						+ " pagtoHist.pghi_amreferenciaarrecadacao between :dataPagamentoInicial and :dataPagamentoFinal and ";
			} else {
				consulta = consulta
						+ " pagtoHist.pghi_amreferenciaarrecadacao = :dataPagamentoInicial and ";
			}

			if (idUnidadeNegocio != null) {
				consulta = consulta + " unidNeg.uneg_id = " + idUnidadeNegocio
						+ " and ";
			}

			if (idFuncionario != null) {
				consulta = consulta + " funcionario.func_id = " + idFuncionario
						+ " and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION ALL "
					+ " SELECT count(*) as qtde "
					+ " FROM faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar"
					+ " INNER JOIN arrecadacao.pagamento_historico pagtoHist on pagtoHist.dbac_id = autosInfracaoDebitoACobrar.dbac_id "
					+ " INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id"
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = pagtoHist.loca_id"
					+ " INNER JOIN cadastro.unidade_negocio unidNeg on unidNeg.uneg_id = loca.uneg_id"
					+ " INNER JOIN cadastro.funcionario funcionario on funcionario.func_id = autoInfracao.func_id"
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null"
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id"
					+ " LEFT OUTER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " LEFT OUTER JOIN faturamento.deb_a_cobrar_hist debitoACobrarHistorico on debitoACobrarHistorico.dbac_id = autosInfracaoDebitoACobrar.dbac_id"
					+ " INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id or debitoTipo.dbtp_id = debitoACobrarHistorico.dbtp_id"
					+ " INNER JOIN atendimentopublico.fiscaliz_sit_serv_a_cob fisSitServACobrar on (fisSitServACobrar.fzst_id = autoInfracao.fzst_id and fisSitServACobrar.dbtp_id = debitoTipo.dbtp_id"
					+ " and fisSitServACobrar.fscb_icmultaaltoinfracao = 1)"
					+ " WHERE autosInfracaoDebitoACobrar.aida_icmultaautoinfracao = 1 and ";

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				consulta = consulta
						+ " pagtoHist.pghi_amreferenciaarrecadacao between :dataPagamentoInicial and :dataPagamentoFinal and ";
			} else {
				consulta = consulta
						+ " pagtoHist.pghi_amreferenciaarrecadacao = :dataPagamentoInicial and ";
			}

			if (idUnidadeNegocio != null) {
				consulta = consulta + " unidNeg.uneg_id = " + idUnidadeNegocio
						+ " and ";
			}

			if (idFuncionario != null) {
				consulta = consulta + " funcionario.func_id = " + idFuncionario
						+ " and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			if (dataPagamentoInicial.compareTo(dataPagamentoFinal) != 0) {
				resultado = session.createSQLQuery(consulta).addScalar("qtde",
						Hibernate.INTEGER).setInteger("dataPagamentoInicial",
						dataPagamentoInicial).setInteger("dataPagamentoFinal",
						dataPagamentoFinal).list();
			} else {
				resultado = session.createSQLQuery(consulta).addScalar("qtde",
						Hibernate.INTEGER).setInteger("dataPagamentoInicial",
						dataPagamentoInicial).list();
			}

			Iterator iterator = resultado.iterator();
			while (iterator.hasNext()) {
				retorno = retorno
						+ new Integer(iterator.next().toString()).intValue();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 15/07/2009
	 * 
	 * @param imovel
	 * @param anoMesReferencia
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarConsumoTarifaImoveis(
			Collection idsImoveis) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT ct.id " + "FROM Imovel im "
					+ "INNER JOIN im.consumoTarifa ct "
					+ "WHERE  im.id in (:idsImoveis) " + "GROUP BY ct.id";

			retorno = session.createQuery(consulta).setParameterList(
					"idsImoveis", idsImoveis).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0184] - Manter débito a Cobrar
	 * 
	 * @author Hugo Amorim
	 * @date 17/07/2009
	 * 
	 */
	public boolean verificarAutosAssociadosAoDebito(String[] idsDebitosACobrar)
			throws ErroRepositorioException {

		boolean retorno = false;
		Collection autos = null;
		Collection ids = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		for (int i = 0; i < idsDebitosACobrar.length; i++) {
			ids.add(new Integer(idsDebitosACobrar[i]));
		}
		try {
			consulta = "SELECT aidc.id "
					+ " FROM gcom.faturamento.autoinfracao.AutosInfracaoDebitoACobrar aidc"
					+ " INNER JOIN aidc.debitoACobrarGeral dc"
					+ " WHERE aidc.debitoACobrarGeral IN (:idsDebitosACobrar)";

			autos = session.createQuery(consulta).setParameterList(
					"idsDebitosACobrar", ids).list();

			if (autos.size() > 0) {
				retorno = true;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0184] - Manter débito a Cobrar
	 * 
	 * @author Hugo Amorim
	 * @date 17/07/2009
	 * 
	 */
	public void cancelarAutosInfracao(String[] idsDebitosACobrar)
			throws ErroRepositorioException {

		Collection ids = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		for (int i = 0; i < idsDebitosACobrar.length; i++) {
			ids.add(new Integer(idsDebitosACobrar[i]));
		}
		try {
			consulta = "DELETE gcom.faturamento.autoinfracao.AutosInfracaoDebitoACobrar as aidc "
					+ " WHERE aidc.debitoACobrarGeral IN (:idsDebitosACobrar)";

			session.createQuery(consulta).setParameterList("idsDebitosACobrar",
					ids).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0896] - Manter Autos de Infração
	 * 
	 * @author Hugo Amorim
	 * @date 17/07/2009
	 * 
	 */
	public boolean validarExistenciaDebitoAtivosAutoInfracao(
			Integer idAutoInfracao) throws ErroRepositorioException {

		boolean retorno = false;
		Collection autos = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT aidc.id "
					+ " FROM gcom.faturamento.autoinfracao.AutosInfracaoDebitoACobrar aidc"
					+ " INNER JOIN aidc.debitoACobrarGeral dcg"
					+ " INNER JOIN dcg.debitoACobrar dc"
					+ " WHERE aidc.autosInfracao = :idAutoInfracao"
					+ " AND dc.debitoCreditoSituacaoAtual.id in (0,1,2)";

			autos = session.createQuery(consulta).setInteger("idAutoInfracao",
					idAutoInfracao).list();

			if (autos.size() > 0) {
				retorno = true;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0896] - Manter Autos de Infração
	 * 
	 * @author Hugo Amorim
	 * @date 17/07/2009
	 * 
	 */
	public boolean validarExistenciaDeDebitosAutoInfracao(Integer idAutoInfracao)
			throws ErroRepositorioException {

		boolean retorno = false;
		Collection autos = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT aidc.id "
					+ " FROM gcom.faturamento.autoinfracao.AutosInfracaoDebitoACobrar aidc"
					+ " INNER JOIN aidc.debitoACobrarGeral dcg"
					+ " INNER JOIN dcg.debitoACobrar dc"
					+ " WHERE aidc.autosInfracao = :idAutoInfracao";

			autos = session.createQuery(consulta).setInteger("idAutoInfracao",
					idAutoInfracao).list();

			if (autos.size() > 0) {
				retorno = true;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito 
	 * 
	 * @author Hugo Amorim, Raphael Rossiter
	 * @date 30/07/2009, 14/01/2010
	 *
	 * @param idArrecadacaoForma
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCartoes(Integer idArrecadacaoForma) throws ErroRepositorioException{
		
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cli.clie_id as id,"
					+ // 0
					" cli.clie_nmcliente as nome "
					+ // 1
					" FROM cadastro.cliente cli"
					+ " INNER JOIN arrecadacao.arrecadador ar on ar.clie_id = cli.clie_id"
					+ " INNER JOIN arrecadacao.arrecadador_contrato arc on arc.arrc_id = ar.arrc_id"
					+ " INNER JOIN arrecadacao.arrecadador_contrato_tar arct on arct.arct_id = arc.arct_id"
					+ " WHERE arct.arfm_id = :arrecadadorForma"
					+ " and ar.arrc_icuso = :indicadorUso";

			retorno = session.createSQLQuery(consulta)
				.addScalar("id",Hibernate.INTEGER)
				.addScalar("nome",Hibernate.STRING)
				.setInteger("arrecadadorForma", idArrecadacaoForma)
				.setInteger("indicadorUso",ConstantesSistema.INDICADOR_USO_ATIVO.intValue())
				.list();
			

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UCXXXX] - Gerar Conta
	 * 
	 * @author Rafael Corrêa
	 * @date 22/07/2009
	 * 
	 * @param anoMes
	 * @param idFaturamentoGrupo
	 * @param idLocalidadeInicial
	 * @param idLocalidadeFinal
	 * @param codigoSetorComercialInicial
	 * @param codigoSetorComercialFinal
	 * @param codigoRotaInicial
	 * @param codigoRotaFinal
	 * @return Collection<RelatorioContaBean>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDadosContaRelatorio(Integer anoMes,
			Integer idFaturamentoGrupo, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal, Integer codigoSetorComercialInicial,
			Integer codigoSetorComercialFinal, Short codigoRotaInicial,
			Short codigoRotaFinal, Short sequencialRotaInicial,
			Short sequencialRotaFinal, String indicadorEmissao, String indicadorOrdenacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		String consulta;

		try {
			consulta = "SELECT imov.imov_id as idImovel, conta.cnta_id as idConta, conta.cnta_amreferenciaconta as anoMesConta,  "
					+ " CASE WHEN (ligAguaSit.last_icfaturamento = 1 and ligEsgSit.lest_icfaturamento = 1) THEN 'A/E' "
					+ "      WHEN (ligAguaSit.last_icfaturamento = 1 and ligEsgSit.lest_icfaturamento = 2) THEN 'A' "
					+ "      WHEN (ligAguaSit.last_icfaturamento = 2 and ligEsgSit.lest_icfaturamento = 1) THEN 'E' "
					+ " END as aguaEsgoto, "
					+ " imov.imov_qteconomia as qtdEconomias, rota.rota_cdrota as codigoRota, imov.imov_nnsequencialrota as seqRota, conta.cnta_dtemissao as dataEmissao, "
					+ " conta.cnta_pcesgoto as percentualEsgoto, conta.cnta_dtvencimentoconta as dataVencimento, conta.cnta_dgverificadorconta as digitoVerificador, "
					+ " conta.loca_id as idLocalidade, conta.cnta_cdsetorcomercial as codigoSetorComercial, conta.cnta_nnquadra as numeroQuadra, "
					+ " conta.cnta_nnlote as lote, conta.cnta_nnsublote as sublote, "
					+ " contaImpressao.cnti_vlconta as valorConta, clieUsuario.clie_nmcliente as nomeUsuario, "
					+ " CASE WHEN (clieTipo.cltp_icpessoafisicajuridica = 1) THEN clieUsuario.clie_nncpf ELSE clieUsuario.clie_nncnpj END as cpfCnpj, "
					+ " CASE WHEN (hidrAgua.hidr_id is not null) THEN hidrAgua.hidr_nnhidrometro ELSE hidrEsg.hidr_nnhidrometro END as numeroHidrometro, "
					+ " CASE WHEN (hidrInstHistAgua.hidi_id is not null) THEN hidrInstHistAgua.hidi_dtinstalacaohidrometro ELSE hidrInstHistEsg.hidi_dtinstalacaohidrometro END as dataInstalacao, "
					+ " CASE WHEN (medHistAgua.mdhi_id is not null) THEN medHistAgua.mdhi_nnleitantfatmt ELSE medHistEsg.mdhi_nnleitantfatmt END as leituraAnterior, "
					+ " CASE WHEN (medHistAgua.mdhi_id is not null) THEN medHistAgua.mdhi_dtleitantfatmt ELSE medHistEsg.mdhi_dtleitantfatmt END as dataLeituraAnterior, "
					+ " CASE WHEN (medHistAgua.mdhi_id is not null) THEN medHistAgua.mdhi_nnleituraatualfaturamento ELSE medHistEsg.mdhi_nnleituraatualfaturamento END as leituraAtual, "
					+ " CASE WHEN (medHistAgua.mdhi_id is not null) THEN medHistAgua.mdhi_dtleituraatualfaturamento ELSE medHistEsg.mdhi_dtleituraatualfaturamento END as dataLeituraAtual, "
					+ " CASE WHEN (medHistAgua.mdhi_id is not null) THEN medHistAgua.ltan_idleitanormfatmt ELSE medHistEsg.ltan_idleitanormfatmt END as anormalidadeLeitura, "
					+ " CASE WHEN (medHistAgua.mdhi_id is not null) THEN medHistAgua.leit_id ELSE medHistEsg.leit_id END as leiturista, "
					+ " CASE WHEN (consHistAgua.cshi_id is not null) THEN consHistAgua.cshi_nnconsumofaturadomes ELSE consHistEsg.cshi_nnconsumofaturadomes END as consumoFaturado, "
					+ " CASE WHEN (consHistAgua.cshi_id is not null) THEN consHistAgua.cshi_nnconsumomedio ELSE consHistEsg.cshi_nnconsumomedio END as consumoMedio, "
					+ " conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlagua as valorAgua, "
					+ " conta.cnta_nnconsumoesgoto as consumoEsgoto, conta.cnta_vlesgoto as valorEsgoto, "
					+ " conta.cnta_vlimpostos as valorImposto,imov.imov_icdebitoconta as indicadorDebitoConta "
					+ " FROM faturamento.conta_impressao contaImpressao "
					+ " INNER JOIN faturamento.conta conta on conta.cnta_id = contaImpressao.cnta_id "
					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario on clieImovUsuario.imov_id = conta.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null "
					+ " INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " INNER JOIN cadastro.cliente_tipo clieTipo on clieTipo.cltp_id = clieUsuario.cltp_id "
					+ " INNER JOIN cadastro.imovel imov on imov.imov_id = conta.imov_id " 
					+ " INNER JOIN cadastro.quadra quadra on quadra.qdra_id = conta.qdra_id "
					+ " INNER JOIN micromedicao.rota rota on rota.rota_id = quadra.rota_id "
					+ " INNER JOIN atendimentopublico.ligacao_agua_situacao ligAguaSit on ligAguaSit.last_id = conta.last_id "
					+ " INNER JOIN atendimentopublico.ligacao_esgoto_situacao ligEsgSit on ligEsgSit.lest_id = conta.lest_id "
					+ " LEFT JOIN atendimentopublico.ligacao_agua ligAgua on ligAgua.lagu_id = imov.imov_id "
					+ " LEFT JOIN micromedicao.hidrometro_inst_hist hidrInstHistAgua on hidrInstHistAgua.hidi_id = ligAgua.hidi_id "
					+ " LEFT JOIN micromedicao.hidrometro hidrAgua on hidrAgua.hidr_id = hidrInstHistAgua.hidr_id "
					+ " LEFT JOIN micromedicao.hidrometro_inst_hist hidrInstHistEsg on hidrInstHistEsg.hidi_id = imov.hidi_id "
					+ " LEFT JOIN micromedicao.hidrometro hidrEsg on hidrEsg.hidr_id = hidrInstHistEsg.hidr_id "
					+ " LEFT JOIN micromedicao.medicao_historico medHistAgua on medHistAgua.lagu_id = imov.imov_id and medHistAgua.mdhi_amleitura = conta.cnta_amreferenciaconta "
					+ " LEFT JOIN micromedicao.medicao_historico medHistEsg on medHistEsg.imov_id = imov.imov_id and medHistEsg.mdhi_amleitura = conta.cnta_amreferenciaconta "
					+ " LEFT JOIN micromedicao.consumo_historico consHistAgua on consHistAgua.imov_id = imov.imov_id and consHistAgua.cshi_amfaturamento = conta.cnta_amreferenciaconta and consHistAgua.lgti_id = "
					+ LigacaoTipo.LIGACAO_AGUA
					+ " LEFT JOIN micromedicao.consumo_historico consHistEsg on consHistEsg.imov_id = imov.imov_id and consHistEsg.cshi_amfaturamento = conta.cnta_amreferenciaconta and consHistEsg.lgti_id = "
					+ LigacaoTipo.LIGACAO_ESGOTO
					+ " LEFT JOIN cobranca.indices_acresc_impont iai on iai.iaci_amreferencia = conta.cnta_amreferenciaconta "
					+ " WHERE conta.cnta_amreferenciaconta = :anoMes ";
			
			if (indicadorEmissao.equalsIgnoreCase("2")){
				consulta = consulta + " and imov.icte_id in (2,5) "; 
			} else if (indicadorEmissao.equalsIgnoreCase("3")){
				consulta = consulta + " and imov.icte_id = 1 "; 
			}

			consulta = consulta
					+ criarCondicionaisRelatorioContas(idFaturamentoGrupo,
							idLocalidadeInicial, idLocalidadeFinal,
							codigoSetorComercialInicial,
							codigoSetorComercialFinal, codigoRotaInicial,
							codigoRotaFinal, sequencialRotaInicial,
							sequencialRotaFinal);
			
			if (indicadorOrdenacao.equalsIgnoreCase("1")){
			consulta = consulta
					+ " ORDER BY idLocalidade, codigoSetorComercial, codigoRota, seqRota";
			} else {
				consulta = consulta
				+ " ORDER BY idLocalidade, codigoSetorComercial, numeroQuadra, lote, sublote";
			}
			
			retorno = session.createSQLQuery(consulta).addScalar("idImovel",
					Hibernate.INTEGER).addScalar("idConta", Hibernate.INTEGER)
					.addScalar("anoMesConta", Hibernate.INTEGER).addScalar(
							"aguaEsgoto", Hibernate.STRING).addScalar(
							"qtdEconomias", Hibernate.SHORT).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar("seqRota",
							Hibernate.INTEGER).addScalar("dataEmissao",
							Hibernate.DATE).addScalar("percentualEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("dataVencimento",
							Hibernate.DATE).addScalar("digitoVerificador",
							Hibernate.SHORT).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("valorConta",
							Hibernate.BIG_DECIMAL).addScalar("nomeUsuario",
							Hibernate.STRING).addScalar("cpfCnpj",
							Hibernate.STRING).addScalar("numeroHidrometro",
							Hibernate.STRING).addScalar("dataInstalacao",
							Hibernate.DATE).addScalar("leituraAnterior",
							Hibernate.INTEGER).addScalar("dataLeituraAnterior",
							Hibernate.DATE).addScalar("leituraAtual",
							Hibernate.INTEGER).addScalar("dataLeituraAtual",
							Hibernate.DATE).addScalar("anormalidadeLeitura",
							Hibernate.INTEGER).addScalar("leiturista",
							Hibernate.INTEGER).addScalar("consumoFaturado",
							Hibernate.INTEGER).addScalar("consumoMedio",
							Hibernate.INTEGER).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("valorImposto",
							Hibernate.BIG_DECIMAL).addScalar(
							"indicadorDebitoConta", Hibernate.SHORT)
					.setInteger("anoMes", anoMes).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	private String criarCondicionaisRelatorioContas(Integer idFaturamentoGrupo,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer codigoSetorComercialInicial,
			Integer codigoSetorComercialFinal, Short codigoRotaInicial,
			Short codigoRotaFinal, Short sequencialRotaInicial,
			Short sequencialRotaFinal) {

		String retorno = "";

		if (idFaturamentoGrupo != null) {
			retorno = retorno + " and contaImpressao.ftgr_id = "
					+ idFaturamentoGrupo;
		}

		if (idLocalidadeInicial != null) {
			retorno = retorno + " and conta.loca_id between "
					+ idLocalidadeInicial + " and " + idLocalidadeFinal;
		}

		if (codigoSetorComercialInicial != null) {
			retorno = retorno + " and conta.cnta_cdsetorcomercial between "
					+ codigoSetorComercialInicial + " and "
					+ codigoSetorComercialFinal;
		}

		if (codigoRotaInicial != null) {
			retorno = retorno + " and rota.rota_cdrota between "
					+ codigoRotaInicial + " and " + codigoRotaFinal;
		}
		if (sequencialRotaInicial != null) {
			retorno = retorno + " and imov.imov_nnsequencialrota between "
					+ sequencialRotaInicial + " and " + sequencialRotaFinal;
		}

		return retorno;
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento
	 * 
	 * Author: Raphael Rossiter Data: 04/08/2009
	 * 
	 * UPDATE COBRANCA_PARCELAMENTO_ITEM DELETE COBRANCA_DOCUMENTO_ITEM
	 */
	public void apagarDadosCobranca(ApagarDadosFaturamentoHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String atualizar = null;

		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			// UPDATE COBRANCA_PARCELAMENTO_ITEM
			atualizar = "update cobranca.parcelamento_item set cnta_id=null where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					atualizar = atualizar
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					atualizar = atualizar
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? ";
						
				    /**
				     * 
				     * Pamela Gatinho - 29/08/2011
				     * Alteracao para regerar todas as contas PF
				     * ao faturar o grupo
				     */
					if (!helper.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRE_FATURADA)) {
						atualizar = atualizar + " and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2) ";	
					}
					
					atualizar = atualizar + ")";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(atualizar);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZANDO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZANDO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				atualizar = atualizar
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
						
						+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2))";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					atualizar = atualizar.substring(0, atualizar.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(atualizar);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}


			st.executeUpdate();

			// DELETE COBRANCA_DOCUMENTO_ITEM
			st = null;

			String delete = "delete from cobranca.cobranca_documento_item where cnta_id in ";

			if(helper.getIdImovel() == null || helper.getIdImovel().equals("")){
				/*
				 * Caso a rota não esteja com o indicador de rota alternativa ativo;
				 * a pesquisa dos imóveis será feita a partir de sua quadra.
				 */
				if (!helper.getRota().getIndicadorRotaAlternativa().equals(
						ConstantesSistema.SIM)) {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join cadastro.quadra qdra on ( qdra.qdra_id = imov.qdra_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = qdra.rota_id ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and imov.rota_idalternativa is null "
							+ " and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2))";
				}
				/*
				 * Caso contrário; a pesquisa dos imóveis será feita a partir da
				 * rota alternativa que estará associada ao mesmo.
				 */
				else {
	
					delete = delete
							+ " (select cnta.cnta_id "
							+ " from faturamento.conta cnta "
							+ " inner join cadastro.imovel imov on ( cnta.imov_id = imov.imov_id ) "
							+ " inner join micromedicao.rota rota on ( rota.rota_id = imov.rota_idalternativa ) "
							+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
							
							+ " where rota.rota_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2))";
				}
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.ftgr_id = ?)";
				}
	
				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getRota().getId().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());
	
				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
				
				//UTILIZADO APENAS NO PRÉ FATURAMENTO
				if (helper.getFaturamentoGrupo() != null) {
					st.setInt(4, helper.getFaturamentoGrupo().getId());
				}
			}
			else{
				
				delete = delete
						+ " (select cnta.cnta_id "
						+ " from faturamento.conta cnta "
						+ " left join faturamento.mov_conta_prefaturada mcpf on ( mcpf.cnta_id = cnta.cnta_id  ) "
				
							+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and cnta.dcst_idatual = ? and (mcpf.cnta_id is null or mcpf.mcpf_icatualizarfaturamento = 2))";

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					delete = delete.substring(0, delete.length() - 1)
							+ " and cnta.cnta_dtemissao between ? and ?)";
				}

				st = jdbcCon.prepareStatement(delete);
				st.setInt(1, helper.getIdImovel().intValue());
				st.setInt(2, helper.getAnoMesFaturamento());
				st.setInt(3, helper.getIdDebitoCreditoSituacaoAtual());

				//UTILIZADO APENAS NO FATURAMENTO
				if (helper.getDataEmissaoInicial() != null) {
					st.setDate(4, Util.getSQLDate(helper.getDataEmissaoInicial()));
					st.setDate(5, Util.getSQLDate(helper.getDataEmissaoFinal()));
				}
			}

			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa os dados do imóvel que será faturado
	 * 
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * @author Raphael Rossiter, Raphael Rossiter
	 * @date 26/08/2009, 16/08/2011
	 * 
	 * @param idRota
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @param preFaturar
	 * @param resumo
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImovelFaturarGrupoPorRotaAlternativa(
			Integer idRota, int numeroPaginas, int quantidadeRegistros, boolean preFaturar, boolean resumo)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.ligacaoAguaSituacao.id," // 0
					+ "imovel.ligacaoEsgotoSituacao.id," // 1
					+ "consumoTarifa.id, " // 2
					+ "localidade.id," // 3
					+ "quadra.id," // 4
					+ "quadra.numeroQuadra," // 5
					+ "imovel.lote," // 6
					+ "setorComercial.codigo," // 7
					+ "faturamentoTipo.id, " // 8
					+ "imovel.imovelPerfil.id," // 9
					+ "imovel.indicadorDebitoConta," // 10
					+ "imovelContaEnvio.id," // 11
					+ "imovel.subLote, " // 12
					+ "imovel.indicadorEmissaoExtratoFaturamento, " // 13
					+ "localidade.gerenciaRegional.id," // 14
					+ "setorComercial.id," // 15
					+ "quadra.rota.id," // 16
					+ "esferaPoder.id, " // 17
					+ "imovel.id, " // 18
					+ "imovel.diaVencimento, " // 19
					+ "imovel.ligacaoAguaSituacao.indicadorFaturamentoSituacao, " // 20
					+ "imovel.ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, " // 21
					+ "imovel.ligacaoAguaSituacao.consumoMinimoFaturamento, " // 22
					+ "imovel.ligacaoEsgotoSituacao.volumeMinimoFaturamento, " // 23
					+ "faturamentoSituacaoTipo.id, " // 24
					+ "imovel.indicadorVencimentoMesSeguinte, " // 25
					+ "faturamentoSituacaoTipo.indicadorParalisacaoFaturamento, "// 26
					+ "faturamentoSituacaoTipo.indicadorValidoAgua, "// 27
					+ "unidadeNegocio.id, "// 28
					+ "hihAgua.id, "//29
					+ "hihPoco.id, "//30
					/** 
					 * 
					 * Adicionando parametro para verificar se o imóvel
					 * faz parte de um condomínio
					 */
					+ "imovel.imovelCondominio.id, " //31 
					+ "imovel.quantidadeEconomias, " // 32
					+ "imovel.indicadorImovelCondominio " //33
				//	+ "imovel.imovelCondominio.ligacaoEsgotoSituacao.id, " //34
				//	+ "imovel.imovelCondominio.ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, " //35
				//	+ "imovel.imovelCondominio.ligacaoAguaSituacao.id, " //36
				//	+ "imovel.imovelCondominio.ligacaoAguaSituacao.indicadorFaturamentoSituacao " //37
					+ "from Imovel imovel "
					+ "inner join imovel.rotaAlternativa rotaAlternativa "
					+ "inner join imovel.consumoTarifa consumoTarifa "
					+ "inner join imovel.localidade localidade "
					+ "inner join localidade.unidadeNegocio unidadeNegocio "
					+ "inner join imovel.setorComercial setorComercial "
					+ "inner join imovel.quadra quadra "
					+ "inner join quadra.rota rota "
					+ "left join imovel.faturamentoTipo faturamentoTipo "
					+ "left join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ "left join imovel.imovelContaEnvio imovelContaEnvio "
					+ "left join imovel.clienteImoveis clienteImoveisReposanvel with (clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ ") and clienteImoveisReposanvel.dataFimRelacao is null "
					+ " left join clienteImoveisReposanvel.cliente clienteResposanvel "
					+ " left join clienteResposanvel.clienteTipo clienteTipo "
					+ " left join clienteTipo.esferaPoder esferaPoder "
					+ " left join imovel.imovelPerfil imovelPerfil "
					+ " left join imovel.ligacaoAgua la "
					+ " left join la.hidrometroInstalacaoHistorico hihAgua "
					+ " left join imovel.hidrometroInstalacaoHistorico hihPoco "
					+ " where rotaAlternativa.id = :rotaId ";
			
			/*
			 * RM 1272 - A pedido de Eduardo Borges
			 * 
			 * Alterar para considerar as contas de imóveis excluídos ou condomínio que foram faturados antes de serem 
			 * colocados como excluídos/condomínio.
			 */
			if(!resumo){
				
				consulta += "AND imovel.indicadorImovelCondominio <> 1 ";
				
				//Não faturar imóveis com indicador de excluído - CRC1577
				consulta += "AND imovel.indicadorExclusao <> 1 ";
			}
			
			// Alterado por Sávio Luiz
			// Data: 23/02/2010
			// Qaundo for pré-faturamento não trazer os imóveis tele medidos
			if (preFaturar) {
				consulta += "AND imovelPerfil.indicadorGerarDadosLeitura = 1 ";
			}


			retorno = session.createQuery(consulta).setInteger("rotaId",
					idRota.intValue()).setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Método que retorna todos os imóveis que tenham cliente responsável e
	 * indicacao de conta a ser entregue em outro endereço e que estejam nas
	 * quadras pertencentes às rotas passadas
	 * 
	 * UC0209 Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2009
	 * 
	 * @param rotas
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterImoveisPorRotasComContaEntregaEmOutroEnderecoPorRotaAlternativa(
			Integer idRota) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select i.localidade.id, i.setorComercial.codigo, q.numeroQuadra, "
					+ "q.id , i.id ,i.lote, i.subLote, ip.id, last.id, last.indicadorFaturamentoSituacao, "
					+ "last.consumoMinimoFaturamento, lest.id, lest.indicadorFaturamentoSituacao, "
					+ "lest.volumeMinimoFaturamento "
					+ "from ClienteImovel ci "
					+ "inner join ci.imovel i "
					+ "inner join i.rotaAlternativa rotaAlternativa "
					+ "inner join i.ligacaoAguaSituacao last "
					+ "inner join i.ligacaoEsgotoSituacao lest "
					+ "inner join ci.cliente clie "
					+ "inner join clie.clienteTipo cltp "
					+ "inner join cltp.esferaPoder epod "
					+ "inner join ci.clienteRelacaoTipo crt "
					+ "inner join i.quadra q "
					+ "inner join q.rota r "
					+ "inner join i.setorComercial sc "
					+ "inner join i.imovelPerfil ip "
					+ "WHERE rotaAlternativa.id = :idRota "
					+ "AND i.indicadorImovelCondominio <> 1 "
					+ "AND i.imovelContaEnvio.id <> 4 "
					+ "AND i.indicadorExclusao <> 1 "
					+ "AND ci.dataFimRelacao IS NULL AND epod.id = :idEsferaPoder "
					+ "AND crt.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL
					+ " AND (i.imovelContaEnvio.id = "
					+ ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL
					+ " OR i.imovelContaEnvio = "
					+ ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL
					+ " )";

			retorno = session.createQuery(consulta).setInteger("idEsferaPoder",
					EsferaPoder.PARTICULAR).setInteger("idRota", idRota).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Metodo que retorna os imóveis das quadras pertencentes às rotas
	 * 
	 * Utilizado pelo [UC0302] Gerar Débitos a Cobrar de Acréscimos por
	 * Impontualidade
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2009
	 * 
	 * @param idRota
	 * @return Collection
	 */
	public Collection pesquisarImoveisDasQuadrasPorRotaAlternativa(
			Integer idRota) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select imovel.id," + // 0
					"localidade.id," + // 1
					"setorComercial.codigo," + // 2
					"quadra.numeroQuadra," + // 3
					"imovel.lote," + // 4
					"imovel.subLote," + // 5
					"rota.id, " + // 6
					"quadra.id, " + // 7
					"imovel.indicadorDebitoConta " // 8

					+ "from Imovel imovel "
					+ "inner join imovel.rotaAlternativa rotaAlternativa "
					+ "left join imovel.localidade localidade "
					+ "left join imovel.setorComercial setorComercial "
					+ "left join imovel.quadra quadra "
					+ "left join quadra.rota rota "

					+ "WHERE rotaAlternativa.id = :idRota "
					+ "AND imovel.indicadorImovelCondominio <> 1 "
					+ "AND imovel.indicadorExclusao <> 1 ";

			retorno = session.createQuery(consulta)
					.setInteger("idRota", idRota).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Permite pesquisar imóvel doação baseando-se em rotas [UC0394] Gerar
	 * Débitos a Cobrar de Doações
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param idRota
	 * @return Collection<ImovelCobrarDoacaoHelper> - Coleção de
	 *         ImovelCobrarDoacaoHelper já com as informações necessárias para
	 *         registro da cobrança
	 * @throws ErroRepositorioException
	 */
	public Collection<ImovelCobrarDoacaoHelper> pesquisarImovelDoacaoPorRota(
			Integer idRota) throws ErroRepositorioException {

		/** * Declara variáveis locais ** */
		Session session = null;
		Collection<ImovelCobrarDoacaoHelper> retorno = null;

		session = HibernateUtil.getSession();

		/**
		 * * Script HQL que já monta uma coleção de ImovelCobrarDoacaoHelper com
		 * tudo que é necessário **
		 */
		try {
			String consulta = "select "
					+ "  new gcom.cadastro.imovel.bean.ImovelCobrarDoacaoHelper("
					+ "    imovelDoacao.imovel.id,"
					+ "    imovelDoacao.entidadeBeneficente.debitoTipo.id,"
					+ "    imovelDoacao.valorDoacao,"
					+ "	   imovelDoacao.imovel.localidade.id,"
					+ "    imovelDoacao.imovel.quadra.id,"
					+ "	   imovelDoacao.imovel.setorComercial.codigo,"
					+ "	   imovelDoacao.imovel.quadra.numeroQuadra,"
					+ "    imovelDoacao.imovel.lote,"
					+ "	   imovelDoacao.imovel.subLote,"
					+ "    imovelDoacao.entidadeBeneficente.debitoTipo.financiamentoTipo.id,"
					+ "    imovelDoacao.entidadeBeneficente.debitoTipo.lancamentoItemContabil.id, "
					+ "    imovelDoacao.anoMesReferenciaFinal," 
				    + "    imovelDoacao.id," 
				    + "    imovelDoacao.anoMesReferenciaInicial) "
					+ "from"
					+ "  gcom.cadastro.imovel.ImovelDoacao imovelDoacao "
					+ "where" + " imovelDoacao.imovel.quadra.rota.id = :idRota"
					+ " AND imovelDoacao.imovel.rotaAlternativa IS NULL"
					+ " AND imovelDoacao.imovel.indicadorImovelCondominio <> 1"
					+ " AND imovelDoacao.imovel.indicadorExclusao <> 1"
					+ " AND imovelDoacao.dataCancelamento is null";

			retorno = session.createQuery(consulta)
					.setInteger("idRota", idRota).list();

		} catch (HibernateException e) {
			/** * levanta a exceção para a próxima camada ** */
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			/** * fecha a sessão ** */
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Permite pesquisar imóvel doação baseando-se em rotas [UC0394] Gerar
	 * Débitos a Cobrar de Doações
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param idRota
	 * @return Collection<ImovelCobrarDoacaoHelper> - Coleção de
	 *         ImovelCobrarDoacaoHelper já com as informações necessárias para
	 *         registro da cobrança
	 * @throws ErroRepositorioException
	 */
	public Collection<ImovelCobrarDoacaoHelper> pesquisarImovelDoacaoPorRotaAlternativa(
			Integer idRota) throws ErroRepositorioException {

		/** * Declara variáveis locais ** */
		Session session = null;
		Collection<ImovelCobrarDoacaoHelper> retorno = null;

		session = HibernateUtil.getSession();

		/**
		 * * Script HQL que já monta uma coleção de ImovelCobrarDoacaoHelper com
		 * tudo que é necessário **
		 */
		try {
			String consulta = "select "
					+ "  new gcom.cadastro.imovel.bean.ImovelCobrarDoacaoHelper("
					+ "    imovelDoacao.imovel.id,"
					+ "    imovelDoacao.entidadeBeneficente.debitoTipo.id,"
					+ "    imovelDoacao.valorDoacao,"
					+ "	   imovelDoacao.imovel.localidade.id,"
					+ "    imovelDoacao.imovel.quadra.id,"
					+ "	   imovelDoacao.imovel.setorComercial.codigo,"
					+ "	   imovelDoacao.imovel.quadra.numeroQuadra,"
					+ "    imovelDoacao.imovel.lote,"
					+ "	   imovelDoacao.imovel.subLote,"
					+ "    imovelDoacao.entidadeBeneficente.debitoTipo.financiamentoTipo.id,"
					+ "    imovelDoacao.entidadeBeneficente.debitoTipo.lancamentoItemContabil.id, "
					+ "    imovelDoacao.anoMesReferenciaFinal," 
				    + "    imovelDoacao.id," 
				    + "    imovelDoacao.anoMesReferenciaInicial) "
					+ "from"
					+ "  gcom.cadastro.imovel.ImovelDoacao imovelDoacao "
					+ "  inner join imovelDoacao.imovel imovel "
					+ "  inner join imovel.rotaAlternativa rotaAlternativa "
					+ "where" + " rotaAlternativa.id = :idRota"
					+ " AND imovelDoacao.imovel.indicadorImovelCondominio <> 1"
					+ " AND imovelDoacao.imovel.indicadorExclusao <> 1"
					+ " AND imovelDoacao.dataCancelamento is null";

			retorno = session.createQuery(consulta)
					.setInteger("idRota", idRota).list();

		} catch (HibernateException e) {
			/** * levanta a exceção para a próxima camada ** */
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			/** * fecha a sessão ** */
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0819] Gerar Historico do Encerramento do Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 04/08/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsSetorParaGerarHistoricoParaEncerrarFaturamento()
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = " select stcm_id as setorComercial from cadastro.setor_comercial where loca_id in  "
					+ " (select loca_id as localidade from faturamento.conta "
					+ " union select loca_id as localidade from faturamento.debito_a_cobrar "
					+ " union select loca_id as localidade from faturamento.credito_a_realizar "
					+ " union select loca_id as localidade from faturamento.guia_pagamento )";

			retorno = session.createSQLQuery(consulta).addScalar(
					"setorComercial", Hibernate.INTEGER).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarSituacaoEspecialFaturamentoCount(
			FaturamentoSituacaoComando comando) throws ErroRepositorioException {

		int retorno = 0;

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try {

			consulta.append("select count(fatSitCom.id) as id \n");
			consulta
					.append("from gcom.faturamento.FaturamentoSituacaoComando fatSitCom\n");
			consulta.append("where fatSitCom.indicadorComando <> 2\n");
			consulta.append("and fatSitCom.id in ( \n");
			consulta
					.append("	select fatSitHis.faturamentoSituacaoComandoInforma.id \n");
			consulta
					.append("	from gcom.faturamento.FaturamentoSituacaoHistorico fatSitHis \n");
			consulta
					.append("	where fatSitHis.faturamentoSituacaoComandoRetirada is null \n");
			consulta.append(") \n");

			if (comando.getImovel() != null
					&& comando.getImovel().getId() != null) {
				consulta.append("and  fatSitCom.imovel.id = "
						+ comando.getImovel().getId() + "\n");
			}
			
			if (comando.getAnoMesInicialSituacaoFaturamento() != null &&
					comando.getAnoMesFinalSituacaoFaturamento() != null) {
				consulta.append("and  fatSitCom.anoMesFinalSituacaoFaturamento between "
						+ comando.getAnoMesInicialSituacaoFaturamento() + " " 
						+ " and " + comando.getAnoMesFinalSituacaoFaturamento()+" \n");
			}
			
			if (comando.getFaturamentoSituacaoTipo() != null &&
					comando.getFaturamentoSituacaoTipo().getId() != null) {
				consulta.append("and  fatSitCom.faturamentoSituacaoTipo.id = "
						+ comando.getFaturamentoSituacaoTipo().getId()+" \n");
			}
			
			if (comando.getLocalidadeInicial() != null
					&& comando.getLocalidadeInicial().getId() != null
					&& comando.getLocalidadeFinal() != null
					&& comando.getLocalidadeFinal().getId() != null) {
				consulta.append("and  fatSitCom.localidadeInicial.id between "
						+ comando.getLocalidadeInicial().getId()  
						+" and "+comando.getLocalidadeFinal().getId()+"\n");
			}
			
			/*
			if (comando.getLocalidadeInicial() != null
					&& comando.getLocalidadeInicial().getId() != null) {
				consulta.append("and  fatSitCom.localidadeInicial.id = "
						+ comando.getLocalidadeInicial().getId() + "\n");
			}

			if (comando.getLocalidadeFinal() != null
					&& comando.getLocalidadeFinal().getId() != null) {
				consulta.append("and  fatSitCom.localidadeFinal.id = "
						+ comando.getLocalidadeFinal().getId() + "\n");
			}
			*/

			if (comando.getCodigoSetorComercialInicial() != null) {
				consulta.append("and  fatSitCom.codigoSetorComercialInicial = "
						+ comando.getCodigoSetorComercialInicial() + "\n");
			}

			if (comando.getCodigoSetorComercialFinal() != null) {
				consulta.append("and  fatSitCom.codigoSetorComercialFinal = "
						+ comando.getCodigoSetorComercialFinal() + "\n");
			}

			if (comando.getNumeroQuadraInicial() != null) {
				consulta.append("and  fatSitCom.numeroQuadraInicial = "
						+ comando.getNumeroQuadraInicial() + "\n");
			}

			if (comando.getNumeroQuadraFinal() != null) {
				consulta.append("and  fatSitCom.numeroQuadraFinal = "
						+ comando.getNumeroQuadraFinal() + "\n");
			}

			if (comando.getNumeroLoteInicial() != null) {
				consulta.append("and  fatSitCom.numeroLoteInicial = "
						+ comando.getNumeroLoteInicial() + "\n");
			}

			if (comando.getNumeroLoteFinal() != null) {
				consulta.append("and  fatSitCom.numeroLoteFinal = "
						+ comando.getNumeroLoteFinal() + "\n");
			}

			if (comando.getNumeroSubLoteInicial() != null) {
				consulta.append("and  fatSitCom.numeroSubLoteInicial = "
						+ comando.getNumeroSubLoteInicial() + "\n");
			}

			if (comando.getNumeroSubLoteFinal() != null) {
				consulta.append("and  fatSitCom.numeroSubLoteFinal = "
						+ comando.getNumeroSubLoteFinal() + "\n");
			}

			if (comando.getCodigoRotaInicial() != null) {
				consulta.append("and  fatSitCom.codigoRotaInicial = "
						+ comando.getCodigoRotaInicial() + "\n");
			}

			if (comando.getCodigoRotaFinal() != null) {
				consulta.append("and  fatSitCom.codigoRotaFinal = "
						+ comando.getCodigoRotaFinal() + "\n");
			}

			if (comando.getSequencialRotaInicial() != null) {
				consulta.append("and  fatSitCom.sequencialRotaInicial = "
						+ comando.getSequencialRotaInicial() + "\n");
			}

			if (comando.getSequencialRotaFinal() != null) {
				consulta.append("and  fatSitCom.sequencialRotaFinal = "
						+ comando.getSequencialRotaFinal() + "\n");
			}

			if (comando.getCategoria1() != null
					&& comando.getCategoria1().getId() != null) {

				consulta.append("and  fatSitCom.categoria1.id = "
						+ comando.getCategoria1().getId() + "\n");

				if (comando.getCategoria2() != null
						&& comando.getCategoria2().getId() != null) {

					consulta.append("and  fatSitCom.categoria2.id = "
							+ comando.getCategoria2().getId() + "\n");
				} else {
					consulta.append("and  fatSitCom.categoria2 is null \n");
				}

				if (comando.getCategoria3() != null
						&& comando.getCategoria3().getId() != null) {

					consulta.append("and  fatSitCom.categoria3.id = "
							+ comando.getCategoria3().getId() + "\n");
				} else {
					consulta.append("and  fatSitCom.categoria3 is null \n");
				}

				if (comando.getCategoria4() != null
						&& comando.getCategoria4().getId() != null) {

					consulta.append("and  fatSitCom.categoria4.id = "
							+ comando.getCategoria4().getId() + "\n");
				} else {
					consulta.append("and  fatSitCom.categoria4 is null \n");
				}

			}

			if (!Util.isVazioOrNulo(comando.getIndicadoresConsumo())) {
				String indicadores = comando.getIndicadoresConsumo().toString()
						.replace("[", "").replace("]", "");
				consulta.append("and  fatSitCom.indicadorConsumo in ("
						+ indicadores + " )\n");
			}

			Collection valores = (Collection) session.createQuery(
					consulta.toString()).list();

			Integer valor = 0;
			Iterator iteratorValor = valores.iterator();
			while (iteratorValor.hasNext()) {
				valor = valor + (Integer) iteratorValor.next();
			}

			retorno = valor;

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<FaturamentoSituacaoComando> pesquisarSituacaoEspecialFaturamento(
			FaturamentoSituacaoComando comando, Integer numeroPaginasPesquisa)
			throws ErroRepositorioException {

		Collection<FaturamentoSituacaoComando> retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try {

			consulta
					.append("from gcom.faturamento.FaturamentoSituacaoComando fatSitCom\n");
			consulta.append("left join fetch fatSitCom.categoria1\n");
			consulta.append("left join fetch fatSitCom.categoria2\n");
			consulta.append("left join fetch fatSitCom.categoria3\n");
			consulta.append("left join fetch fatSitCom.categoria4 \n");
			consulta
					.append("left join fetch fatSitCom.faturamentoSituacaoTipo \n");
			consulta.append("left join fetch fatSitCom.imovel \n");
			consulta.append("left join fetch fatSitCom.localidadeFinal \n");
			consulta.append("left join fetch fatSitCom.localidadeInicial  \n");
			consulta.append("where fatSitCom.indicadorComando <> 2\n");
			consulta.append("and fatSitCom.id in ( \n");
			consulta
					.append("	select fatSitHis.faturamentoSituacaoComandoInforma.id \n");
			consulta
					.append("	from gcom.faturamento.FaturamentoSituacaoHistorico fatSitHis \n");
			consulta
					.append("	where fatSitHis.faturamentoSituacaoComandoRetirada is null \n");
			consulta.append(") \n");

			if (comando.getImovel() != null
					&& comando.getImovel().getId() != null) {
				consulta.append("and  fatSitCom.imovel.id = "
						+ comando.getImovel().getId() + "\n");
			}
			
			if (comando.getAnoMesInicialSituacaoFaturamento() != null &&
					comando.getAnoMesFinalSituacaoFaturamento() != null) {
				consulta.append("and  fatSitCom.anoMesFinalSituacaoFaturamento between "
						+ comando.getAnoMesInicialSituacaoFaturamento() + " " 
						+ " and " + comando.getAnoMesFinalSituacaoFaturamento()+" \n");
			}
			
			if (comando.getFaturamentoSituacaoTipo() != null &&
					comando.getFaturamentoSituacaoTipo().getId() != null) {
				consulta.append("and  fatSitCom.faturamentoSituacaoTipo.id = "
						+ comando.getFaturamentoSituacaoTipo().getId()+" \n");
			}
			
			if (comando.getLocalidadeInicial() != null
					&& comando.getLocalidadeInicial().getId() != null
					&& comando.getLocalidadeFinal() != null
					&& comando.getLocalidadeFinal().getId() != null) {
				consulta.append("and  fatSitCom.localidadeInicial.id between "
						+ comando.getLocalidadeInicial().getId()  
						+" and "+comando.getLocalidadeFinal().getId()+"\n");
			}

			
			/*
			if (comando.getLocalidadeInicial() != null
					&& comando.getLocalidadeInicial().getId() != null) {
				consulta.append("and  fatSitCom.localidadeInicial.id = "
						+ comando.getLocalidadeInicial().getId() + "\n");
			}

			if (comando.getLocalidadeFinal() != null
					&& comando.getLocalidadeFinal().getId() != null) {
				consulta.append("and  fatSitCom.localidadeFinal.id = "
						+ comando.getLocalidadeFinal().getId() + "\n");
			}
			*/

			if (comando.getCodigoSetorComercialInicial() != null) {
				consulta.append("and  fatSitCom.codigoSetorComercialInicial = "
						+ comando.getCodigoSetorComercialInicial() + "\n");
			}

			if (comando.getCodigoSetorComercialFinal() != null) {
				consulta.append("and  fatSitCom.codigoSetorComercialFinal = "
						+ comando.getCodigoSetorComercialFinal() + "\n");
			}

			if (comando.getNumeroQuadraInicial() != null) {
				consulta.append("and  fatSitCom.numeroQuadraInicial = "
						+ comando.getNumeroQuadraInicial() + "\n");
			}

			if (comando.getNumeroQuadraFinal() != null) {
				consulta.append("and  fatSitCom.numeroQuadraFinal = "
						+ comando.getNumeroQuadraFinal() + "\n");
			}

			if (comando.getNumeroLoteInicial() != null) {
				consulta.append("and  fatSitCom.numeroLoteInicial = "
						+ comando.getNumeroLoteInicial() + "\n");
			}

			if (comando.getNumeroLoteFinal() != null) {
				consulta.append("and  fatSitCom.numeroLoteFinal = "
						+ comando.getNumeroLoteFinal() + "\n");
			}

			if (comando.getNumeroSubLoteInicial() != null) {
				consulta.append("and  fatSitCom.numeroSubLoteInicial = "
						+ comando.getNumeroSubLoteInicial() + "\n");
			}

			if (comando.getNumeroSubLoteFinal() != null) {
				consulta.append("and  fatSitCom.numeroSubLoteFinal = "
						+ comando.getNumeroSubLoteFinal() + "\n");
			}

			if (comando.getCodigoRotaInicial() != null) {
				consulta.append("and  fatSitCom.codigoRotaInicial = "
						+ comando.getCodigoRotaInicial() + "\n");
			}

			if (comando.getCodigoRotaFinal() != null) {
				consulta.append("and  fatSitCom.codigoRotaFinal = "
						+ comando.getCodigoRotaFinal() + "\n");
			}

			if (comando.getSequencialRotaInicial() != null) {
				consulta.append("and  fatSitCom.sequencialRotaInicial = "
						+ comando.getSequencialRotaInicial() + "\n");
			}

			if (comando.getSequencialRotaFinal() != null) {
				consulta.append("and  fatSitCom.sequencialRotaFinal = "
						+ comando.getSequencialRotaFinal() + "\n");
			}

			if (comando.getCategoria1() != null
					&& comando.getCategoria1().getId() != null) {

				consulta.append("and  fatSitCom.categoria1.id = "
						+ comando.getCategoria1().getId() + "\n");

				if (comando.getCategoria2() != null
						&& comando.getCategoria2().getId() != null) {

					consulta.append("and  fatSitCom.categoria2.id = "
							+ comando.getCategoria2().getId() + "\n");
				} else {
					consulta.append("and  fatSitCom.categoria2 is null \n");
				}

				if (comando.getCategoria3() != null
						&& comando.getCategoria3().getId() != null) {

					consulta.append("and  fatSitCom.categoria3.id = "
							+ comando.getCategoria3().getId() + "\n");
				} else {
					consulta.append("and  fatSitCom.categoria3 is null \n");
				}

				if (comando.getCategoria4() != null
						&& comando.getCategoria4().getId() != null) {

					consulta.append("and  fatSitCom.categoria4.id = "
							+ comando.getCategoria4().getId() + "\n");
				} else {
					consulta.append("and  fatSitCom.categoria4 is null \n");
				}

			}

			if (!Util.isVazioOrNulo(comando.getIndicadoresConsumo())) {
				String indicadores = comando.getIndicadoresConsumo().toString()
						.replace("[", "").replace("]", "");
				consulta.append("and  fatSitCom.indicadorConsumo in ("
						+ indicadores + " )\n");
			}

			consulta
					.append("\n order by fatSitCom.faturamentoSituacaoTipo.descricao\n");

			retorno = (Collection<FaturamentoSituacaoComando>) session
					.createQuery(consulta.toString()).setFirstResult(
							10 * numeroPaginasPesquisa).setMaxResults(10)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * Verifica se todos os grupos já foram faturados
	 * 
	 * @author Vivianne Sousa
	 * @date 17/08/2009
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGrupoFaturamentoNaoFaturados(
			Integer anoMesReferenciaFaturamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "from FaturamentoGrupo fatGrupo "
					+ " where fatGrupo.anoMesReferencia <= :anoMesReferenciaFaturamento "
					+ " and fatGrupo.indicadorUso = :indicadorUso ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaFaturamento", anoMesReferenciaFaturamento)
					.setInteger("indicadorUso",
							ConstantesSistema.INDICADOR_USO_ATIVO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * @author Hugo Amorim
	 * @date 26/08/2009
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return Collection
	 */
	public Collection pesquisarVencimentoConta(Integer idImovel,
			Integer anoMesReferencia) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			/**
			 * Autor: Adriana Muniz
			 * data: 05/09/2011
			 * 
			 * Adicão do filtro de situação da conta igual a normal, retificada, parcelada ou incluida 
			 * */
			consulta = "select c.cnta_id as id , c.cnta_dtvencimentoconta as vencimento "
					+ " from faturamento.conta c "
					+ " where imov_id = :idImovel " 
					+ " and cnta_amreferenciaconta = :anoMesReferencia " 
					+ " and (dcst_idatual = " + DebitoCreditoSituacao.NORMAL + " or dcst_idatual = " + DebitoCreditoSituacao.RETIFICADA
					+ " or dcst_idatual = " + DebitoCreditoSituacao.INCLUIDA + " or dcst_idatual = " + DebitoCreditoSituacao.PARCELADA + ")"
					+ " union"
					+ " select ch.cnta_id as id, ch.cnhi_dtvencimentoconta as vencimento "
					+ " from faturamento.conta_historico ch "
					+ " where imov_id = :idImovel " 
					+ " and cnhi_amreferenciaconta = :anoMesReferencia "
					+ " and (dcst_idatual = " + DebitoCreditoSituacao.NORMAL + " or dcst_idatual = " + DebitoCreditoSituacao.RETIFICADA
					+ " or dcst_idatual = " + DebitoCreditoSituacao.INCLUIDA + " or dcst_idatual = " + DebitoCreditoSituacao.PARCELADA + ")";

			retorno = session.createSQLQuery(consulta).addScalar("id",
					Hibernate.INTEGER).addScalar("vencimento", Hibernate.DATE)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * @author Hugo Amorim
	 * @date 26/08/2009
	 * @param idConta
	 * @return dataPagamento
	 */
	public Collection pesquisarDataPagamento(Integer idContal)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select p.pgmt_dtpagamento as data "
					+ "from arrecadacao.pagamento p "
					+ "where p.cnta_id = :idConta " + "union "
					+ "select ph.pghi_dtpagamento as data "
					+ "from arrecadacao.pagamento_historico ph "
					+ "where ph.cnta_id = :idConta ";

			retorno = session.createSQLQuery(consulta).addScalar("data",
					Hibernate.DATE).setInteger("idConta", idContal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0147] - Cancelar Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/09/2009
	 */
	public void atualizarIndicadorHistoricoContaGeral(Integer idContaGeral,
			Short indicadorHistorico) throws ErroRepositorioException {
		// obtém uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		String update;

		try {
			// constroi o hql
			update = "update ContaGeral cntg "
					+ "set cntg.indicadorHistorico = :indicadorHistorico, "
					+ " cntg.ultimaAlteracao= :dataUltimaAlteracao where cntg.id = :idContaGeral";

			// executa o hql
			session.createQuery(update)
					.setInteger("idContaGeral", idContaGeral).setShort(
							"indicadorHistorico", indicadorHistorico)
					.setTimestamp("dataUltimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa para cada imóvel da rota informada a principal categoria.
	 * 
	 * [UC0302] - Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Raphael Rossiter
	 * @date 01/09/2009
	 * 
	 * @param codigoEmpresaFebraban
	 * @param idRota
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarPrincipalCategoriaImovelPorRotaAlternativa(
			Short codigoEmpresaFebraban, Integer idRota)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  imsb.imov_id as col_0, "
					+ "  catg.catg_id as categoria, "
					+ "  sum(imsb.imsb_qteconomia) as qtdEconomia, "
					+ "  catg.catg_iccobrancaacrescimos as col_1 "
					+ " from "
					+ "  cadastro.imovel_subcategoria imsb "
					+ " inner join cadastro.subcategoria scat on imsb.scat_id=scat.scat_id "
					+ " inner join cadastro.categoria catg on scat.catg_id=catg.catg_id  "
					+ " where "
					+ "  imsb.imov_id in(select "
					+ "		  imovel0_.imov_id  "
					+ "		 from "
					+ "		  cadastro.imovel imovel0_ "
					+ "		 left outer join cadastro.localidade localidade1_ on imovel0_.loca_id=localidade1_.loca_id "
					+ "		 left outer join cadastro.setor_comercial setorcomer2_ on imovel0_.stcm_id=setorcomer2_.stcm_id "
					+ "		 left outer join cadastro.quadra quadra3_ on imovel0_.qdra_id=quadra3_.qdra_id  "
					+ "		 left outer join micromedicao.rota rota4_ on quadra3_.rota_id=rota4_.rota_id  "
					+ "		 where  "
					+ "		  imovel0_.rota_idalternativa = :idRota "
					+ "		  and imovel0_.imov_icimovelcondominio <> 1 and imovel0_.imov_icexclusao <> 1) "
					+ " group by "
					+ "  imsb.imov_id,catg.catg_id,catg.catg_iccobrancaacrescimos ";

			// [FS0001] - Verificar mais de uma categoria com a maior quantidade
			// de economia
			if (codigoEmpresaFebraban
					.equals(SistemaParametro.CODIGO_EMPRESA_FEBRABAN_CAERN)) {
				consulta = consulta
						+ " order by qtdEconomia desc, categoria asc ";
			} else {
				consulta = consulta
						+ " order by qtdEconomia desc, categoria desc ";
			}

			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.INTEGER)
					.addScalar("categoria", Hibernate.INTEGER).addScalar(
							"qtdEconomia", Hibernate.INTEGER).addScalar(
							"col_1", Hibernate.SHORT).setInteger("idRota",
							idRota).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * pesquisa o indicado de acréscimo para o cliente do imóvel.
	 * 
	 * [UC0302]-Gerar Débito a cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Raphael Rossiter
	 * @date 01/09/2009
	 * 
	 * @param idRota
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> obterIndicadorGeracaoAcrescimosClienteImovelPorRotaAlternativa(
			Integer idRota) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "clienteimovel.imov_id as col_0, "
					+ "cliente.clie_iccobrancaacrescimos as col_1 "
					+ "from "
					+ "cadastro.cliente_imovel clienteimovel "
					+ "inner join "
					+ "cadastro.cliente cliente on clienteimovel.clie_id=cliente.clie_id "
					+ "where "
					+ "clienteimovel.imov_id in(select "
					+ "imovel0_.imov_id "
					+ "from "
					+ "cadastro.imovel imovel0_ "
					+ "left outer join cadastro.localidade localidade1_ on imovel0_.loca_id=localidade1_.loca_id "
					+ "left outer join cadastro.setor_comercial setorcomer2_ on imovel0_.stcm_id=setorcomer2_.stcm_id "
					+ "left outer join cadastro.quadra quadra3_ on imovel0_.qdra_id=quadra3_.qdra_id "
					+ "left outer join micromedicao.rota rota4_ on quadra3_.rota_id=rota4_.rota_id "
					+ "where "
					+ "imovel0_.rota_idalternativa = :idRota "
					+ "and imovel0_.imov_icimovelcondominio <> 1 and imovel0_.imov_icexclusao <> 1) "
					+ "and clienteimovel.crtp_id= :idRelacao "
					+ "and ( clienteimovel.clim_dtrelacaofim is null) ";

			retorno = session.createSQLQuery(consulta).addScalar("col_0",
					Hibernate.INTEGER).addScalar("col_1", Hibernate.SHORT)
					.setInteger("idRota", idRota).setParameter("idRelacao",
							ClienteRelacaoTipo.RESPONSAVEL).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * [SB0004] - Calcular Valor de Água e/ou Esgoto
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 04/12/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */
	public Date pesquisarDataPrevistaFaturamentoAtividadeCronograma(
			Integer idFaturamentoGrupo, Integer idFaturamentoAtividade,
			Integer amReferencia) throws ErroRepositorioException {
		Date retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT ftac.dataPrevista "
					+ "FROM FaturamentoAtividadeCronograma ftac "
					+ "LEFT JOIN ftac.faturamentoAtividade ftat "
					+ "LEFT JOIN ftac.faturamentoGrupoCronogramaMensal ftcm "
					+ "LEFT JOIN ftcm.faturamentoGrupo ftgr "
					+ "WHERE ftat.id = :idFaturamentoAtividade AND "
					+ "ftgr.id = :idFaturamentoGrupo AND "
					+ "ftcm.anoMesReferencia = :amReferencia ";

			retorno = (Date) session.createQuery(consulta).setInteger(
					"idFaturamentoAtividade", idFaturamentoAtividade)
					.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
					.setInteger("amReferencia", amReferencia).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa a quantidade de dados do relatório
	 * 
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Arthur Carvalho
	 * @created 14/09/2009
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Integer pesquisarDadosRelatorioContasRevisaoCount(
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer codigoSetorComercialInicial,
			Integer codigoSetorComercialFinal,
			Collection colecaoIdsMotivoRevisao, Integer idImovelPerfil,
			Integer referenciaInicial, Integer referenciaFinal,
			Integer idCategoria, Integer idEsferaPoder)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT  "
					+ "count(conta.cnta_id) as qtdeContas "
					+ " FROM cadastro.imovel imov "
					+ " INNER JOIN faturamento.conta conta "
					+ " on conta.imov_id = imov.imov_id and conta.cnta_dtrevisao is not null "
					+ " and conta.dcst_idatual in ("
					+ DebitoCreditoSituacao.NORMAL
					+ ", "
					+ DebitoCreditoSituacao.RETIFICADA
					+ ", "
					+ DebitoCreditoSituacao.INCLUIDA
					+ ", "
					+ DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO
					+ ") "

					+ " INNER JOIN cadastro.cliente_imovel clieImovUsuario "
					+ " on clieImovUsuario.imov_id = imov.imov_id "
					+ " and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO
					+ " and clieImovUsuario.clim_dtrelacaofim is null "
					+ " INNER JOIN cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " INNER JOIN cadastro.cliente_tipo clieUsuarioTipo "
					+ " on clieUsuarioTipo.cltp_id = clieUsuario.cltp_id "
					+ " INNER JOIN cadastro.setor_comercial setor "
					+ " on setor.stcm_id = imov.stcm_id "
					+ " INNER JOIN cadastro.quadra quadra "
					+ " on quadra.qdra_id = imov.qdra_id "
					+ " INNER JOIN cadastro.localidade loc "
					+ " on loc.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.localidade elo "
					+ " on elo.loca_id = loc.loca_cdelo "
					+ " INNER JOIN cadastro.gerencia_regional gerReg "
					+ " on gerReg.greg_id = loc.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio uneg "
					+ " on loc.uneg_id = uneg.uneg_id "
					+ " LEFT OUTER JOIN cadastro.cliente_fone clieUsuarioFone "
					+ " on clieUsuarioFone.clie_id = clieUsuario.clie_id "
					+ " and clieUsuarioFone.cfon_icfonepadrao = "
					+ ClienteFone.INDICADOR_FONE_PADRAO
					+ " LEFT OUTER JOIN faturamento.conta_motivo_revisao contaMotRev "
					+ " on contaMotRev.cmrv_id = conta.cmrv_id "
					+ " LEFT OUTER JOIN arrecadacao.pagamento pagto "
					+ " on pagto.cnta_id = conta.cnta_id ";

			consulta = consulta
					+ criarCondicionaisRelatorioContasRevisao(
							idGerenciaRegional, idUnidadeNegocio,
							idLocalidadeInicial, idLocalidadeFinal,
							codigoSetorComercialInicial,
							codigoSetorComercialFinal, colecaoIdsMotivoRevisao,
							idImovelPerfil, referenciaInicial, referenciaFinal,
							idCategoria, idEsferaPoder);

			SQLQuery query = session.createSQLQuery(consulta);

			if (colecaoIdsMotivoRevisao != null
					&& colecaoIdsMotivoRevisao.size() > 0) {
				query.setParameterList("colecaoIdsMotivoRevisao",
						colecaoIdsMotivoRevisao);
			}

			retorno = (Integer) query
					.addScalar("qtdeContas", Hibernate.INTEGER).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Gerar Relacao Acompanhamento Faturamento
	 * 
	 * [UC0336] GerarRelacaoAcompanhamentoFaturamentoCount
	 * 
	 * @author Arthur Carvalho
	 * @date 23/09/2009
	 * 
	 */
	public Integer gerarRelacaoAcompanhamentoFaturamentoCount(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(distinct imovel.id )"
					+ " from ImovelSubcategoria imovelSubcategoria "
					+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
					+ " left  join  imovelSubcategoria.comp_id.subcategoria subcategoria "
					+ " left join subcategoria.categoria categoria   "
					+ " inner join imovel.localidade localidade   "
					+ " inner join localidade.gerenciaRegional gerenciaRegional "
					+ " inner join imovel.setorComercial setorComercial   "
					+ " left  join imovel.logradouroBairro logradouroBairro  "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " left  join bairro.municipio municipio   "
					+ " left  join imovel.logradouroBairro logradouroBairro "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " inner join imovel.quadra quadra   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.cep cep   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.logradouro logradouro   "
					+ " left  join imovel.imovelCondominio imovelCondominio   "
					+ " left  join imovel.imovelPrincipal imovelPrincipal   "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua  "
					+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  "
					+ " left  join imovel.imovelPerfil imovelPerfil  "
					+ " left  join imovel.pocoTipo pocoTipo   "
					+ " left  join imovel.faturamentoTipo faturamentoTipo "
					+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
					+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ " left  join imovel.eloAnormalidade eloAnormalidade   "
					+ " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
					+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  "
					+ " left  join imovel.consumoTarifa consumoTarifa   "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left join imovel.consumosHistoricos consumosHistorico   "
					+ " left join imovel.medicaoHistoricos medicaoHistorico   "
					+ " left join imovel.clienteImoveis clienteImoveis "
					+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo "
					+ " left join clienteImoveis.cliente cliente "
					+ " left join cliente.clienteTipo clienteTipo "
					+ " left join imovel.consumosHistoricos consumosHistorico "
					+ " left outer join imovel.clienteImoveis clienteImoveisUsuario with (clienteImoveisUsuario.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ ") and clienteImoveisUsuario.dataFimRelacao is null "
					+ " left outer join clienteImoveisUsuario.cliente clienteUsuario";

			consulta = consulta
					+ montarCondicaoWhereFiltrarImovelOutrosCriterio(
							idImovelCondominio, idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
							consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto,
							consumoMinimoFinalEsgoto,
							intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal,
							intervaloMediaMinimaImovelInicial,
							intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal,
							idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
							idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal,
							idCadastroOcorrencia, idConsumoTarifa,
							idGerenciaRegional, idLocalidadeInicial,
							idLocalidadeFinal, setorComercialInicial,
							setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro,
							municipio, idTipoMedicao, indicadorMedicao,
							idSubCategoria, idCategoria,
							quantidadeEconomiasInicial,
							quantidadeEconomiasFinal, diaVencimento, idCliente,
							idClienteTipo, idClienteRelacaoTipo,
							numeroPontosInicial, numeroPontosFinal,
							numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa);

			Query query = session.createQuery(consulta.substring(0, (consulta
					.length() - 6)));

			informarDadosQueryFiltrarImovelOutrosCriterio(query,
					idImovelCondominio, idImovelPrincipal, idNomeConta,
					idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
					consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
					consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
					intervaloValorPercentualEsgotoInicial,
					intervaloValorPercentualEsgotoFinal,
					intervaloMediaMinimaImovelInicial,
					intervaloMediaMinimaImovelFinal,
					intervaloMediaMinimaHidrometroInicial,
					intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
					idPocoTipo, idFaturamentoSituacaoTipo,
					idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
					idEloAnormalidade, areaConstruidaInicial,
					areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa,
					idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal,
					setorComercialInicial, setorComercialFinal, quadraInicial,
					quadraFinal, loteOrigem, loteDestno, cep, logradouro,
					bairro, municipio, idTipoMedicao, indicadorMedicao,
					idSubCategoria, idCategoria, quantidadeEconomiasInicial,
					quantidadeEconomiasFinal, diaVencimento, idCliente,
					idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial,
					numeroPontosFinal, numeroMoradoresInicial,
					numeroMoradoresFinal, idAreaConstruidaFaixa);

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Object[]> pesquisarRelatorioJurosMultasDebitosCancelados(
			FiltrarRelatorioJurosMultasDebitosCanceladosHelper filtro)
			throws ErroRepositorioException {

		StringBuilder sqlPrincipal = new StringBuilder();
		StringBuilder sqlComplementoContaHistoricoInners = new StringBuilder();
		StringBuilder sqlComplementoContaHistoricoWhere = new StringBuilder();

		Map<String, Object> parameters = new HashMap<String, Object>();

		sqlPrincipal.append("select  \n");
		sqlPrincipal
				.append("	conta.cnta_dtretificacao as dataCancelamento, \n");
		sqlPrincipal.append("	usuario.usur_id as responsavel, \n");
		sqlPrincipal.append("	imovel.loca_id as localidade,  \n");
		sqlPrincipal.append("	setor.stcm_cdsetorcomercial as setor, \n");
		sqlPrincipal.append("	quadra.qdra_nnquadra as quadra, \n");
		sqlPrincipal.append("	imovel.imov_nnlote as lote, \n");
		sqlPrincipal.append("	imovel.imov_nnsublote as sublote, \n");
		sqlPrincipal.append("	imovel.imov_id as imovel, \n");
		sqlPrincipal.append("	conta.cnta_amreferenciaconta as anoMes,  \n");
		sqlPrincipal.append("	dt.dbtp_dsabreviado as descTipoDebito,  \n");
		sqlPrincipal.append("	sum(dc.dbcb_vlprestacao) as valorDebito,  \n");
		sqlPrincipal
				.append("	conta.cnta_nnretificacao as numRetificacoes,  \n");
		sqlPrincipal.append("	'CONTA' as tabela  \n");
		sqlPrincipal.append("from faturamento.conta  \n");
		sqlPrincipal
				.append(" inner join cadastro.imovel on ( imovel.imov_id = conta.imov_id)  \n");

		if (filtro.getUnidadeNegocio() != null) {// é isso mesmo
			sqlPrincipal
					.append(" inner join cadastro.localidade loc on (imovel.loca_id = loc.loca_id )  \n");

			sqlComplementoContaHistoricoInners
					.append(" inner join cadastro.localidade loc on (imovel.loca_id = loc.loca_id ) \n");
		}

		if (!Util.isVazioOrNulo(filtro.getColecaoCategorias())) {
			sqlPrincipal
					.append(" inner join cadastro.imovel_subcategoria imsub on(imsub.imov_id = conta.imov_id)  \n");
			sqlPrincipal
					.append(" inner join cadastro.subcategoria subcat on( subcat.scat_id = imsub.scat_id)  \n");

			sqlComplementoContaHistoricoInners
					.append(" inner join cadastro.imovel_subcategoria imsub on(imsub.imov_id = ch.imov_id) \n");
			sqlComplementoContaHistoricoInners
					.append(" inner join cadastro.subcategoria subcat on( subcat.scat_id = imsub.scat_id)  \n");

		}

		if (!Util.isVazioOrNulo(filtro.getColecaoEsferaPoder())) {
			sqlPrincipal
					.append(" inner join cadastro.cliente_imovel ci on( ci.imov_id = conta.imov_id)  \n");
			sqlPrincipal
					.append(" inner join cadastro.cliente on ( cliente.clie_id = ci.clie_id)   \n");
			sqlPrincipal
					.append(" inner join cadastro.cliente_tipo ct on( ct.cltp_id = cliente.cltp_id)  \n");

			sqlComplementoContaHistoricoInners
					.append(" inner join cadastro.cliente_imovel ci on( ci.imov_id = ch.imov_id) \n");
			sqlComplementoContaHistoricoInners
					.append(" inner join cadastro.cliente on ( cliente.clie_id = ci.clie_id) \n");
			sqlComplementoContaHistoricoInners
					.append(" inner join cadastro.cliente_tipo ct on( ct.cltp_id = cliente.cltp_id) \n");
		}

		sqlPrincipal
				.append(" inner join seguranca.usuario on ( conta.usur_id = usuario.usur_id)  \n");
		sqlPrincipal
				.append(" inner join cadastro.setor_comercial setor on ( imovel.stcm_id = setor.stcm_id)  \n");
		sqlPrincipal
				.append(" inner join cadastro.quadra on ( imovel.qdra_id = quadra.qdra_id)  \n");
		sqlPrincipal
				.append(" left join faturamento.debito_cobrado dc on ( dc.cnta_id = conta.cnta_id)  \n");
		sqlPrincipal
				.append(" left join faturamento.debito_tipo dt on ( dc.dbtp_id = dt.dbtp_id)  \n");

		sqlPrincipal.append("where conta.dcst_idatual = "
				+ DebitoCreditoSituacao.RETIFICADA + "  \n");
		sqlPrincipal
				.append(" and conta.cnta_dtretificacao between :dataCancelamentoInicial and :dataCancelamentoFinal  \n");

		if (filtro.getMesAnoFaturamento() != null) {
			sqlPrincipal
					.append(" and conta.cnta_amreferenciaconta = :anoMesFaturamento  \n");

			sqlComplementoContaHistoricoWhere
					.append(" and ch.cnhi_amreferenciaconta = :anoMesFaturamento \n");

			parameters.put("anoMesFaturamento", filtro.getMesAnoFaturamento());
		}

		if (filtro.getUnidadeNegocio() != null) {
			sqlPrincipal.append(" and loc.uneg_id = :unidadeNegocio   \n");

			sqlComplementoContaHistoricoWhere
					.append(" and loc.uneg_id = :unidadeNegocio \n");

			parameters.put("unidadeNegocio", filtro.getUnidadeNegocio());
		}

		if (filtro.getLocalidade() != null) {
			sqlPrincipal.append(" and imovel.loca_id = :localidade  \n");

			sqlComplementoContaHistoricoWhere
					.append(" and imovel.loca_id = :localidade \n");

			parameters.put("localidade", filtro.getLocalidade());
		}

		/*
		 * if(!Util.isVazioOrNulo(filtro.getColecaoTiposDebito())){
		 * sqlPrincipal.append(" and dt.dbtp_id in ( :tiposDebito) \n");
		 * 
		 * sqlComplementoContaHistoricoWhere.append(" and dt.dbtp_id in (
		 * :tiposDebito) \n");
		 * 
		 * parameters.put("tiposDebito", filtro.getColecaoTiposDebito()); }
		 */
		if (!Util.isVazioOrNulo(filtro.getColecaoCategorias())) {
			sqlPrincipal.append(" and subcat.catg_id in ( :categorias) \n");

			sqlComplementoContaHistoricoWhere
					.append(" and subcat.catg_id in ( :categorias)  \n");

			parameters.put("categorias", filtro.getColecaoCategorias());
		}

		if (!Util.isVazioOrNulo(filtro.getColecaoPerfilImovel())) {
			sqlPrincipal.append(" and imovel.iper_id in ( :perfisImovel)  \n");

			sqlComplementoContaHistoricoWhere
					.append(" and imovel.iper_id in ( :perfisImovel) \n");

			parameters.put("perfisImovel", filtro.getColecaoPerfilImovel());
		}

		if (!Util.isVazioOrNulo(filtro.getColecaoEsferaPoder())) {
			sqlPrincipal
					.append(" and ci.crtp_id = 2 and ci.clim_dtrelacaofim is null and ct.epod_id in( :esferasPoder)  \n");

			sqlComplementoContaHistoricoWhere
					.append(" and ci.crtp_id = 2 and ci.clim_dtrelacaofim is null and ct.epod_id in( :esferasPoder) \n");

			parameters.put("esferasPoder", filtro.getColecaoEsferaPoder());
		}

		if (filtro.getUsuarioCancelamento() != null) {
			sqlPrincipal.append(" and conta.usur_id = :usuarioCancelamento \n");

			sqlComplementoContaHistoricoWhere
					.append(" and ch.usur_id = :usuarioCancelamento \n");

			parameters.put("usuarioCancelamento", filtro
					.getUsuarioCancelamento());
		}

		sqlPrincipal.append("group by conta.cnta_dtretificacao,usuario.usur_id,imovel.loca_id,setor.stcm_cdsetorcomercial,quadra.qdra_nnquadra,imovel.imov_nnlote,imovel.imov_nnsublote,imovel.imov_id,conta.cnta_amreferenciaconta,dt.dbtp_dsabreviado,conta.cnta_nnretificacao,'CONTA'");

		sqlPrincipal.append("\n UNION  \n\n");

		sqlPrincipal.append("select  \n");
		sqlPrincipal.append("	ch.cnhi_dtretificacao as dataCancelamento, \n");
		sqlPrincipal.append("	usuario.usur_id as responsavel, \n");
		sqlPrincipal.append("	imovel.loca_id as localidade, \n");
		sqlPrincipal.append("	setor.stcm_cdsetorcomercial as setor, \n");
		sqlPrincipal.append("	quadra.qdra_nnquadra as quadra, \n");
		sqlPrincipal.append("	imovel.imov_nnlote as lote, \n");
		sqlPrincipal.append("	imovel.imov_nnsublote as sublote, \n");
		sqlPrincipal.append("	imovel.imov_id as imovel, \n");
		sqlPrincipal.append("	ch.cnhi_amreferenciaconta as anoMes, \n");
		sqlPrincipal.append("	dt.dbtp_dsabreviado as descTipoDebito, \n");
		sqlPrincipal.append("	sum(dch.dbhi_vlprestacao) as valorDebito, \n");
		sqlPrincipal.append("	ch.cnhi_nnretificacao as numRetificacoes, \n");
		sqlPrincipal.append("	'CONTA_HISTORICO' as tabela \n");
		sqlPrincipal.append("from faturamento.conta_historico ch  \n");
		sqlPrincipal
				.append(" inner join cadastro.imovel on ( imovel.imov_id = ch.imov_id) \n");

		sqlPrincipal.append(sqlComplementoContaHistoricoInners.toString());

		sqlPrincipal
				.append(" inner join seguranca.usuario on ( ch.usur_id = usuario.usur_id) \n");
		sqlPrincipal
				.append(" inner join cadastro.setor_comercial setor on ( imovel.stcm_id = setor.stcm_id) \n");
		sqlPrincipal
				.append(" inner join cadastro.quadra on ( imovel.qdra_id = quadra.qdra_id) \n");
		sqlPrincipal
				.append(" left join faturamento.debito_cobrado_historico dch on ( dch.cnta_id = ch.cnta_id) \n");
		sqlPrincipal
				.append(" left join faturamento.debito_tipo dt on ( dch.dbtp_id = dt.dbtp_id) \n");

		sqlPrincipal.append("where ch.dcst_idatual = "
				+ DebitoCreditoSituacao.RETIFICADA + "  \n");
		sqlPrincipal
				.append(" and ch.cnhi_dtretificacao between :dataCancelamentoInicial and :dataCancelamentoFinal  \n");

		sqlPrincipal.append(sqlComplementoContaHistoricoWhere.toString());

		sqlPrincipal.append("group by ch.cnhi_dtretificacao,usuario.usur_id,imovel.loca_id,setor.stcm_cdsetorcomercial,quadra.qdra_nnquadra,imovel.imov_nnlote,imovel.imov_nnsublote,imovel.imov_id,ch.cnhi_amreferenciaconta,dt.dbtp_dsabreviado,ch.cnhi_nnretificacao,'CONTA_HISTORICO'");

		// order by fora do sql

		Session session = HibernateUtil.getSession();

		try {
			SQLQuery query = criarSQLQueryComParametros(
					sqlPrincipal.toString(), parameters, session);

			return query.addScalar("dataCancelamento", Hibernate.DATE)
					.addScalar("responsavel", Hibernate.STRING).addScalar(
							"localidade", Hibernate.INTEGER).addScalar("setor",
							Hibernate.INTEGER).addScalar("quadra",
							Hibernate.INTEGER).addScalar("lote",
							Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("imovel",
							Hibernate.INTEGER).addScalar("anoMes",
							Hibernate.INTEGER).addScalar("descTipoDebito",
							Hibernate.STRING).addScalar("valorDebito",
							Hibernate.BIG_DECIMAL).addScalar("numRetificacoes",
							Hibernate.INTEGER).addScalar("tabela",
							Hibernate.STRING).setDate(
							"dataCancelamentoInicial",
							filtro.getDataCancelamentoInicial()).setDate(
							"dataCancelamentoFinal",
							filtro.getDataCancelamentoFinal()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Metodo seta os parametros numa determinada consulta e retorna um objeto
	 * SQLQuery com o sql já com parametros.
	 * 
	 * @since 16/09/2009
	 * @author Marlon Patrick
	 */
	private SQLQuery criarSQLQueryComParametros(String consulta,
			Map<String, Object> parameters, Session session) {

		SQLQuery query = session.createSQLQuery(consulta);

		Set<String> set = parameters.keySet();
		Iterator<String> iterMap = set.iterator();
		while (iterMap.hasNext()) {
			String key = iterMap.next();
			if (parameters.get(key) instanceof Collection) {
				Collection<? extends Object> collection = (ArrayList<? extends Object>) parameters
						.get(key);
				query.setParameterList(key, collection);
			} else {
				query.setParameter(key, parameters.get(key));
			}
		}

		return query;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author:Sávio Luiz Data:27/10/2009
	 * Consultar os Cre´ditos a Realizar do Imovel
	 * 
	 * @param imovelId
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualId
	 *            Id do Debito Credito Situação
	 * @return Coleção de Creditos a Realizar
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizarPeloCreditoRealizado(
			Integer IdCreditoARealizar,Integer anoMesFaturamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		/**
		 * Data: 30/01/2011
		 * 
		 * retirada de um criterio da select que impedia que o credito a realizar de determinado credito 
		 * realizado fosse encontrado, com isso o crédito era liberado no IS, mas não era liberado no gsan
		 * 
		 * */
		try {

			consulta = "select "
					+ "  crar.crar_id as idCreditoARealizar, "
					+ "  crar.crar_nnprestacaorealizadas as numeroPrestacaoRealizada, "
					+ "  crar.crar_nnprestacaocredito as numeroPrestacaoCredito, "
					+ "  crar.crar_vlcredito as valorCredito, "
					+ "  crar.crar_vlresidualmesanterior as valorResidualMesAnterior, "
					+ "  crti.crti_id as idCreditoTipo, "
					+ "  lict.lict_id as idLancamentoItemContabil, "
					+ "  loca.loca_id as idLocalidade, "
					+ "  qdra.qdra_id as idQuadra, "
					+ "  crar.crar_cdsetorcomercial as codigoSetorComercial, "
					+ "  crar.crar_nnquadra as numeroQuadra, "
					+ "  crar.crar_nnlote as lote, "
					+ "  crar.crar_nnsublote as sublote, "
					+ "  crar.crar_amreferenciacredito as amReferenciaCredito, "
					+ "  crar.crar_amcobrancacredito as amCobrancaCredito, "
					+ "  crog.crog_id as idCreditoOrigem, "
					+ "  crar.crar_nnparcelabonus as numeroParcelaBonus, "
					+ "  crar.crar_vlresidualconcedidomes as vlResidualConsedidoMes "
					+ " from "
					+ "  faturamento.credito_a_realizar crar "
					+ " inner join faturamento.debito_credito_situacao dcst on crar.dcst_idatual=dcst.dcst_id "
					+ " inner join cadastro.imovel imov on crar.imov_id=imov.imov_id "
					+ " inner join faturamento.credito_tipo crti on crar.crti_id=crti.crti_id "
					+ " inner join financeiro.lancamento_item_contabil lict on crar.lict_id=lict.lict_id "
					+ " inner join cadastro.localidade loca on crar.loca_id=loca.loca_id "
					+ " inner join cadastro.quadra qdra on crar.qdra_id=qdra.qdra_id "
					+ " inner join faturamento.credito_origem crog on crar.crog_id=crog.crog_id "
					+ " left outer join cobranca.parcelamento parc on crar.parc_id=parc.parc_id "
					+ " where  crar.crar_id = :idCreditoARealizar "
					+ "  and (parc.parc_id is null or crar.crar_nnprestacaorealizadas>1 or (parc.parc_id is not null) "
					+ "       and crar.crar_nnprestacaorealizadas=1 and parc.parc_amreferenciafaturamento< :anoMesFaturamento) ";

			retorno = session.createSQLQuery(consulta).addScalar(
					"idCreditoARealizar", Hibernate.INTEGER).addScalar(
					"numeroPrestacaoRealizada", Hibernate.SHORT).addScalar(
					"numeroPrestacaoCredito", Hibernate.SHORT).addScalar(
					"valorCredito", Hibernate.BIG_DECIMAL).addScalar(
					"valorResidualMesAnterior", Hibernate.BIG_DECIMAL)
					.addScalar("idCreditoTipo", Hibernate.INTEGER).addScalar(
							"idLancamentoItemContabil", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar(
							"idQuadra", Hibernate.INTEGER).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("amReferenciaCredito",
							Hibernate.INTEGER).addScalar("amCobrancaCredito",
							Hibernate.INTEGER).addScalar("idCreditoOrigem",
							Hibernate.INTEGER).addScalar("numeroParcelaBonus",
							Hibernate.SHORT)
							.addScalar("vlResidualConsedidoMes",Hibernate.BIG_DECIMAL)
							.setInteger("idCreditoARealizar",
									IdCreditoARealizar).setInteger("anoMesFaturamento",anoMesFaturamento)
									.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0113] - Faturar Grupo Faturamento Author:Sávio Luiz Data:27/10/2009
	 * Consultar os Creditos a Realizar do Imovel
	 * 
	 * @param imovelId
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualId
	 *            Id do Debito Credito Situação
	 * @return Coleção de Creditos a Realizar
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizarPeloCreditoRealizadoAntigo(
			Integer imovelId, Integer idCreditoTipo, BigDecimal valorCredito,
			Integer debitoCreditoSituacaoAtualId, Integer anoMesFaturamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		/**
		 * Data: 30/01/2011
		 * 
		 * retirada de um criterio da select que impedia que o credito a realizar de determinado credito 
		 * realizado fosse encontrado, com isso o crédito era liberado no IS, mas não era liberado no gsan
		 * 
		 * */
		try {

			consulta = "select "
					+ "  crar.crar_id as idCreditoARealizar, "
					+ "  crar.crar_nnprestacaorealizadas as numeroPrestacaoRealizada, "
					+ "  crar.crar_nnprestacaocredito as numeroPrestacaoCredito, "
					+ "  crar.crar_vlcredito as valorCredito, "
					+ "  crar.crar_vlresidualmesanterior as valorResidualMesAnterior, "
					+ "  crti.crti_id as idCreditoTipo, "
					+ "  lict.lict_id as idLancamentoItemContabil, "
					+ "  loca.loca_id as idLocalidade, "
					+ "  qdra.qdra_id as idQuadra, "
					+ "  crar.crar_cdsetorcomercial as codigoSetorComercial, "
					+ "  crar.crar_nnquadra as numeroQuadra, "
					+ "  crar.crar_nnlote as lote, "
					+ "  crar.crar_nnsublote as sublote, "
					+ "  crar.crar_amreferenciacredito as amReferenciaCredito, "
					+ "  crar.crar_amcobrancacredito as amCobrancaCredito, "
					+ "  crog.crog_id as idCreditoOrigem, "
					+ "  crar.crar_nnparcelabonus as numeroParcelaBonus "
					+ " from "
					+ "  faturamento.credito_a_realizar crar "
					+ " inner join faturamento.debito_credito_situacao dcst on crar.dcst_idatual=dcst.dcst_id "
					+ " inner join cadastro.imovel imov on crar.imov_id=imov.imov_id "
					+ " inner join faturamento.credito_tipo crti on crar.crti_id=crti.crti_id "
					+ " inner join financeiro.lancamento_item_contabil lict on crar.lict_id=lict.lict_id "
					+ " inner join cadastro.localidade loca on crar.loca_id=loca.loca_id "
					+ " inner join cadastro.quadra qdra on crar.qdra_id=qdra.qdra_id "
					+ " inner join faturamento.credito_origem crog on crar.crog_id=crog.crog_id "
					+ " left outer join cobranca.parcelamento parc on crar.parc_id=parc.parc_id "
					+ " where  imov.imov_id= :imovelId "
					+ "  and crar.dcst_idatual= :debitoCreditoSituacaoAtualId "
					//+ "  and (crar.crar_vlcredito + crar_vlresidualmesanterior) = :valorCredito "
					+ "  and crar.crti_id = :idCreditoTipo "
					+ "  and crar.crar_amreferenciaprestacao = :anoMesFaturamento "
					+ "  and (parc.parc_id is null or crar.crar_nnprestacaorealizadas>1 or (parc.parc_id is not null) "
					+ "       and crar.crar_nnprestacaorealizadas=1 and parc.parc_amreferenciafaturamento< :anoMesFaturamento) ";

			retorno = session.createSQLQuery(consulta).addScalar(
					"idCreditoARealizar", Hibernate.INTEGER).addScalar(
					"numeroPrestacaoRealizada", Hibernate.SHORT).addScalar(
					"numeroPrestacaoCredito", Hibernate.SHORT).addScalar(
					"valorCredito", Hibernate.BIG_DECIMAL).addScalar(
					"valorResidualMesAnterior", Hibernate.BIG_DECIMAL)
					.addScalar("idCreditoTipo", Hibernate.INTEGER).addScalar(
							"idLancamentoItemContabil", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar(
							"idQuadra", Hibernate.INTEGER).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("amReferenciaCredito",
							Hibernate.INTEGER).addScalar("amCobrancaCredito",
							Hibernate.INTEGER).addScalar("idCreditoOrigem",
							Hibernate.INTEGER).addScalar("numeroParcelaBonus",
							Hibernate.SHORT).setInteger("imovelId",
							imovelId.intValue()).setInteger(
							"debitoCreditoSituacaoAtualId",
							debitoCreditoSituacaoAtualId).setInteger(
							"anoMesFaturamento", anoMesFaturamento)
					//.setBigDecimal("valorCredito", valorCredito)
					.setInteger("idCreditoTipo", idCreditoTipo).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Metodo que deleta os creditos realizados categoria de um respectivo
	 * débito a cobrar
	 * 
	 * Utilizado pelo [UC0745] .
	 * 
	 * @author Sávio Luiz
	 * @date 24/08/2006
	 * 
	 * @param idDebitoACobrar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarCreditoRealizadoCategoria(Integer idCreditoRealizado)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String delete = "delete CreditoRealizadoCategoria crc "
					+ "where crc.creditoRealizado.id = :idCreditoRealizado ";

			session.createQuery(delete).setInteger("idCreditoRealizado",
					idCreditoRealizado).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Método que retorna as contas para impressao
	 * 
	 * Pesquisar Contas Emitir CAEMA
	 * 
	 * @author Rafael Pinto
	 * @date 03/11/2009
	 * 
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasEmitirCAEMA(Integer numeroPaginas,
			Integer anoMesReferencia, Integer idFaturamentoGrupo)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel "// 32
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "where ";

			consulta += "contaImpressao.cnti_amreferenciaconta ="
					+ anoMesReferencia;

			consulta += " AND cnt.cnta_tmultimaalteracao > :data "
					+ "AND contaImpressao.ftgr_id = :idFaturamentoGrupoParms "
					+ "AND cliCnt.clct_icnomeconta = :indicadorNomeConta "
					+ "AND imovel.icte_id <> 9 "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id, loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota, imovel.imov_nnsequencialrota";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).setDate("data",
							Util.criarData(16, 05, 2007)).setInteger(
							"indicadorNomeConta", ConstantesSistema.INDICADOR_USO_ATIVO)
					.setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo)
					.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0972] Gerar TXT das Contas dos Projetos Especiais
	 * 
	 * @author Hugo Amorim, Anderson Italo, Magno Gouveia
	 * @since 14/12/2009, 29/01/2010, 02/08/2011
	 * 
	 */
	public Collection pesquisarDadosTxtContasProjetosEspeciais(String anoMes,
			Integer idCliente, Integer quantidadeRegistros , Integer numeroIndice) throws ErroRepositorioException{
		
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();

		StringBuilder sqlPrincipal = new StringBuilder();

		try {

			sqlPrincipal.append("SELECT  \n");
			sqlPrincipal.append("	localidade.loca_id AS idLocalidade, \n");
			sqlPrincipal.append("	localidade.loca_nmlocalidade AS nomeLocalidade, \n");
			sqlPrincipal.append("	faturaItem.imov_id AS idImovel,  \n");
			sqlPrincipal.append("	cliente.clie_nmcliente AS nomeCliente, \n");
			sqlPrincipal.append("	hidrometro.hidr_nnhidrometro AS numeroHidrometro, \n");
			sqlPrincipal.append("	fatura.fatu_amreferencia AS referencia, \n");
			sqlPrincipal.append("	faturaItem.fitm_nnconsumo AS consumo, \n");
			sqlPrincipal.append("	faturaItem.fitm_vlconta AS valorConta, \n");
			sqlPrincipal.append("	cliente.clie_nncpf AS cpf, \n");
			sqlPrincipal.append("	stcm.stcm_cdsetorcomercial AS setorComercial, \n");
			sqlPrincipal.append("	rota.ftgr_id AS grupoFaturamento \n");
			sqlPrincipal.append("FROM faturamento.fatura_item faturaItem  \n");
			sqlPrincipal.append(" INNER JOIN faturamento.fatura fatura ON fatura.fatu_id = faturaItem.fatu_id ");
			sqlPrincipal.append(" INNER JOIN cadastro.imovel imovel ON imovel.imov_id = faturaItem.imov_id  \n");
			sqlPrincipal.append(" INNER JOIN cadastro.localidade localidade ON localidade.loca_id = imovel.loca_id  \n");
			sqlPrincipal.append(" INNER JOIN cadastro.cliente_imovel clienteImovel ON clienteImovel.imov_id = imovel.imov_id  \n");
			sqlPrincipal.append(" INNER JOIN cadastro.cliente cliente ON cliente.clie_id = clienteImovel.clie_id  \n");
			sqlPrincipal.append(" INNER JOIN cadastro.setor_comercial stcm ON stcm.stcm_id = imovel.stcm_id  \n");
			sqlPrincipal.append(" INNER JOIN cadastro.quadra quadra ON quadra.qdra_id = imovel.qdra_id  \n");
			sqlPrincipal.append(" INNER JOIN micromedicao.rota rota ON rota.rota_id = quadra.rota_id  \n");
			sqlPrincipal.append(" LEFT JOIN atendimentopublico.ligacao_agua ligacaoAgua ON ligacaoAgua.lagu_id = imovel.imov_id  \n");
			sqlPrincipal.append(" LEFT JOIN micromedicao.hidrometro_inst_hist hidrometroHistorico ON hidrometroHistorico.hidi_id = ligacaoAgua.hidi_id and hidrometroHistorico.hidi_dtretiradahidrometro is null \n");
			sqlPrincipal.append(" LEFT JOIN micromedicao.hidrometro hidrometro ON hidrometro.hidr_id = hidrometroHistorico.hidr_id   \n");

			sqlPrincipal.append(" WHERE   \n");
			sqlPrincipal.append(" fatura.fatu_amreferencia = :anoMes  \n");
			sqlPrincipal.append(" AND fatura.clie_id = :idCliente  \n");
			sqlPrincipal.append(" AND clienteImovel.crtp_id = " + ClienteRelacaoTipo.USUARIO + "  \n");
			sqlPrincipal.append(" AND clienteImovel.clim_dtrelacaofim IS NULL  \n");
			
			// ORDENADO PELO ID LOCALIDADE
			sqlPrincipal.append(" ORDER BY localidade.loca_id, faturaItem.imov_id \n");

			retorno = session.createSQLQuery(sqlPrincipal.toString())
				.addScalar("idLocalidade", Hibernate.INTEGER)
				.addScalar("nomeLocalidade", Hibernate.STRING)
				.addScalar("idImovel", Hibernate.INTEGER)
				.addScalar("nomeCliente", Hibernate.STRING)
				.addScalar("numeroHidrometro", Hibernate.STRING)
				.addScalar("referencia", Hibernate.INTEGER)
				.addScalar("consumo", Hibernate.INTEGER)
				.addScalar("valorConta", Hibernate.BIG_DECIMAL)
				.addScalar("cpf", Hibernate.STRING)
				.addScalar("setorComercial", Hibernate.INTEGER)
				.addScalar("grupoFaturamento", Hibernate.INTEGER)
				.setInteger("anoMes", new Integer(anoMes))
				.setInteger("idCliente", new Integer(idCliente))
				.setMaxResults(quantidadeRegistros)
				.setFirstResult(numeroIndice)
				.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0972] count Gerar TXT das Contas dos Projetos Especiais
	 * 
	 * @author Hugo Amorim, Anderson Italo
	 * @since 15/12/2009, 29/01/2010
	 * 
	 */
	public Integer countTxtContasProjetosEspeciais(
			String anoMes,Integer idCliente)
					throws ErroRepositorioException{
		
		Integer retorno = new Integer(0);

		Session session = HibernateUtil.getSession();

		StringBuilder sqlPrincipal = new StringBuilder();

		try {

			sqlPrincipal.append("select  \n");
			sqlPrincipal.append("	count(*) as count \n");
			sqlPrincipal.append("from faturamento.fatura_item faturaItem  \n");
			sqlPrincipal.append(" INNER JOIN faturamento.fatura fatura on fatura.fatu_id = faturaItem.fatu_id ");
			sqlPrincipal.append(" INNER JOIN cadastro.imovel imovel on imovel.imov_id = faturaItem.imov_id  \n");
			sqlPrincipal.append(" INNER JOIN cadastro.localidade localidade on localidade.loca_id = imovel.loca_id  \n");
			sqlPrincipal.append(" INNER JOIN cadastro.cliente_imovel clienteImovel on clienteImovel.imov_id = imovel.imov_id  \n");
			sqlPrincipal.append(" INNER JOIN cadastro.cliente cliente on cliente.clie_id = clienteImovel.clie_id  \n");
			sqlPrincipal.append(" LEFT JOIN atendimentopublico.ligacao_agua ligacaoAgua on ligacaoAgua.lagu_id = imovel.imov_id  \n");
			sqlPrincipal.append(" LEFT JOIN micromedicao.hidrometro_inst_hist hidrometroHistorico on hidrometroHistorico.hidi_id = ligacaoAgua.hidi_id and hidrometroHistorico.hidi_dtretiradahidrometro is null \n");
			sqlPrincipal.append(" LEFT JOIN micromedicao.hidrometro hidrometro on hidrometro.hidr_id = hidrometroHistorico.hidr_id   \n");
			sqlPrincipal.append(" WHERE   \n");
			sqlPrincipal.append(" fatura.fatu_amreferencia = :anoMes  \n");
			sqlPrincipal.append(" and fatura.clie_id = :idCliente  \n");
			sqlPrincipal.append(" and clienteImovel.crtp_id = " + ClienteRelacaoTipo.USUARIO + "  \n");
			sqlPrincipal.append(" and clienteImovel.clim_dtrelacaofim is null  \n");
			
			retorno = (Integer)session.createSQLQuery(sqlPrincipal.toString())
				.addScalar("count", Hibernate.INTEGER)
				.setInteger("anoMes", new Integer(anoMes))
				.setInteger("idCliente", new Integer(idCliente))
				.setMaxResults(1)
				.uniqueResult();


		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0971] Inserir Pagamentos para Faturas Especiais [SB0002] Processar
	 * fatura do cliente responsavel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2009
	 */
	public Collection pesquisarFatura(Integer idCliente,
			Integer anoMesReferencia, Integer numeroSequencial,
			BigDecimal valordebito) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT fatura.id " + "FROM Fatura fatura "
					+ "INNER JOIN fatura.cliente cliente "
					+ "WHERE cliente.id = :idCliente AND "
					+ "fatura.anoMesReferencia = :anoMesReferencia AND "
					+ "fatura.sequencial = :numeroSequencial AND "
					+ "fatura.debito = :valordebito";

			retorno = session.createQuery(consulta).setInteger("idCliente",
					idCliente.intValue()).setInteger("anoMesReferencia",
					anoMesReferencia.intValue()).setInteger("numeroSequencial",
					numeroSequencial.intValue()).setBigDecimal("valordebito",
					valordebito).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	

	
	/**
	 * Recupera as contas dos imóveis selecionados que tenham o mês ano de
	 * referência e que estejam com a situação atual igual a normal ou situação
	 * anterior igual a normal
	 * 
	 * @author Fernando Fontelles Filho
	 * @date 20/01/2010
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContasResumoSimulacaoFaturamento(
			Integer idImovel, Integer anoMes) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "select cnta.id, "
					+ "cnta.referencia, "
					+ "ftgr.id, "
					+ "greg.id, "
					+ "loca.id, "
					+ "stcm.id, "
					+ "rota.id, "
					+ "qdra.id, "
					+ "stcm.codigo, "
					+ "qdra.numeroQuadra, "
					+ "last.id, "
					+ "lest.id, "
					+ "iper.id, "
					+ "epod.id, "
					+ "cnta.indicadorDebitoConta, "
					+ "2, "
					+ "cnta.valorAgua, "
					+ "cnta.consumoAgua, "
					+ "cnta.valorEsgoto, "
					+ "cnta.consumoEsgoto, "
					+ "cnta.debitos, "
					+ "cnta.valorCreditos, "
					+ "cnta.valorImposto "
					+ " from Conta cnta "
					+ " inner join cnta.imovel imov "
					+ " inner join imov.quadra qdra "
					+ " inner join qdra.rota rota "
					+ " inner join rota.faturamentoGrupo ftgr "
					+ " inner join imov.localidade loca "
					+ " inner join imov.setorComercial stcm "
					+ " inner join cnta.imovelPerfil iper "
					+ " inner join cnta.ligacaoAguaSituacao last "
					+ " inner join cnta.ligacaoEsgotoSituacao lest "
					+ " inner join loca.gerenciaRegional greg "
					+ " inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ " left join cnta.debitoCreditoSituacaoAnterior dcsan "
					+ " left join imov.clienteImoveis clienteImoveisResponsavel with ( clienteImoveisResponsavel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ ") and clienteImoveisResponsavel.dataFimRelacao is null "
					+ " left join clienteImoveisResponsavel.cliente clienteResponsavel "
					+ " left join clienteResponsavel.clienteTipo clienteTipo "
					+ " left join clienteTipo.esferaPoder epod "
					+ " where "
					+ " imov.id = :idImovel and cnta.referencia = :anoMes "
					+ " and (cnta.debitoCreditoSituacaoAtual = :normal "
					+ " or cnta.debitoCreditoSituacaoAnterior = :normal) ";

			retorno = (Object[]) session
					.createQuery(consulta).setInteger("anoMes", anoMes)
					.setInteger("idImovel", idImovel).setInteger("normal",
							DebitoCreditoSituacao.NORMAL).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	
	/**
	 * Recupera as contas que foram impressas do grupo de faturamento e que sejam para envio de email.
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 *
	 * @author Raphael Rossiter
	 * @date 23/02/2010
	 *
	 * @param idImovel
	 * @param anoMesReferenciaContabil
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarDeDoacao(Integer idImovel,
			Integer anoMesReferenciaContabil, Integer idDebitoTipo) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;

		try {
			consulta = "select dc.id "
					+ "from DebitoACobrar dc "
					+ "inner join dc.imovel imov ";

			consulta = consulta
					+ "where imov.id = :idImovel and "
					+ "dc.anoMesReferenciaContabil = :anoMesReferenciaContabil and "
					+ "dc.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao and "
					+ "dc.debitoTipo.id = :idDebitoTipo ";

			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel.intValue())
					.setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL)
					.setInteger("idDebitoTipo", idDebitoTipo).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0840] - Atualizar Faturamento do Movimento Celular 
	 *
	 * @author Rafael Pinto
	 * @date 26/02/2010
	 *
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return Conta
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarContaPreFaturada(Integer idImovel,
			Integer anoMesReferencia,Integer idDebitoCreditoSituacaoAtual) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Conta retorno = null;

		try {
			consulta = "SELECT ct "
					+ "FROM Conta ct "
					+ "inner join ct.imovel imov "
					+ "inner join ct.debitoCreditoSituacaoAtual debitoCredito "
					+ "INNER JOIN FETCH ct.ligacaoAguaSituacao las "
					+ "INNER JOIN FETCH ct.ligacaoEsgotoSituacao les "
					+ "WHERE imov.id = :idImovel "
					+ "AND ct.referencia = :anoMesReferencia " 
					+ "AND debitoCredito.id = :debCredSitAtual ";

			retorno = (Conta) session.createQuery(consulta).
				setInteger("idImovel", idImovel).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("debCredSitAtual", idDebitoCreditoSituacaoAtual).
				setMaxResults(1).
				uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	

	/**
	 * [UC0994] Envio de Email da conta para o Cliente
	 * 
	 * @author Fernando Fontelles Filho
	 * @date 02/03/2010
	 * 
	 * @param idLocalidade
	 * @param sistemaParametro
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpressasParaEnvioEmail(
			Integer idLocalidade, SistemaParametro sistemaParametro) throws ErroRepositorioException {
		
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "SELECT DISTINCT i.imov_id as imovel, cli.clie_dsemail as email "
					 + "FROM faturamento.conta_impressao ci "
					 +   "INNER JOIN faturamento.conta c ON c.cnta_id = ci.cnta_id "
					 + 	 "INNER JOIN cadastro.quadra q ON q.qdra_id = c.qdra_id "
					 + 	 "INNER JOIN cadastro.cliente_conta cc ON cc.cnta_id = ci.cnta_id "
					 + 	 "INNER JOIN cadastro.cliente cli ON cli.clie_id = cc.clie_id "
					 + 	 "INNER JOIN cadastro.imovel i ON i.imov_id = c.imov_id "
					 + "WHERE ci.cnti_amreferenciaconta = :anoMes " 
					 + 	 "AND i.icte_id IN (:indicadorEnvioEmail, :indicadorEnvioImovelEmail) " 
					 + 	 "AND cc.clct_icnomeconta = :indicadorNomeConta "
					 + 	 "AND cli.clie_dsemail IS NOT NULL "
					 +   "AND i.loca_id = :idLocalidade "
			 		 +   "AND c.cnta_dtenvioemailconta IS NULL "
			 		 +	 "AND (c.cnta_dtemissao + :qtdDiasEnvioEmailConta) <= CURRENT_DATE ";

			retorno = (Collection) session
									.createSQLQuery(consulta)
									.addScalar("imovel", Hibernate.INTEGER)
									.addScalar("email", Hibernate.STRING)		
									.setInteger("anoMes", sistemaParametro.getAnoMesFaturamento())
									.setInteger("idLocalidade", idLocalidade)
									.setInteger("indicadorEnvioEmail", ImovelContaEnvio.ENVIAR_PARA_EMAIL)
									.setInteger("indicadorEnvioImovelEmail", ImovelContaEnvio.ENVIAR_PARA_IMOVEL_E_PARA_EMAIL)
									.setShort("indicadorNomeConta", ConstantesSistema.SIM)
									.setInteger("qtdDiasEnvioEmailConta", sistemaParametro.getQtdeDiasEnvioEmailConta())
									.list();
						
		}catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
		
	}
	
	/**
	 * [UC0993] Consultar Faturamento Imediato Ajuste
	 *
	 * @author Hugo Leonardo
	 * @data  26/02/2010
	 * 
	 * @param anoMesReferencia, idFaturamentoGrupo, idImovel, idRota
     * @throws ErroRepositorioException 
	 *
	 */
	public Collection pesquisarFaturamentoImediatoAjuste(String anoMesReferencia, String idFaturamentoGrupo, 
			String idImovel, String idRota, int qtd) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;
		Query query = null;
		Map parameters = new HashMap();

		try {
			consulta =   " select mcpf.imovel.id, "
					   + " rota.faturamentoGrupo.id, "
					   + " rota.codigo, "
					   + " ajuste.valorCobradoAgua, "
					   + " ajuste.numeroConsumoAgua, "  
					   + " ajuste.valorCobradoEsgoto, "
					   + " ajuste.numeroConsumoEsgoto, "
					   + " mcpf.anoMesReferenciaPreFaturamento "
					   + " from FaturamentoImediatoAjuste ajuste, MovimentoContaPrefaturada mcpf, Rota rota "
					   + " where mcpf.conta.id = ajuste.conta.id "
					   + " and mcpf.anoMesReferenciaPreFaturamento = :anoMesReferencia ";
			
			consulta += " and mcpf.rota.id = rota.id ";
			
			// Grupo Faturamento
		    if(idFaturamentoGrupo != null && !idFaturamentoGrupo.equals("")){
		    	
			    consulta += " and rota.faturamentoGrupo.id = :faturamentoGrupo ";
			    parameters.put("faturamentoGrupo", idFaturamentoGrupo);
		    }
		  
		    // Rota
		    if(idRota != null && !idRota.equals("")){
		    	
		    	consulta += " and rota.id = :rota1 ";
		    	parameters.put("rota1", idRota);
		    }
		    
		    // Imovel
		    if(idImovel != null && !idImovel.equals("")){
		    	
		    	consulta += " and mcpf.imovel.id = :imovel ";
		    	parameters.put("imovel", idImovel);
		    }	
				
			consulta += " group by mcpf.imovel.localidade.id, " 
				  	 +  " mcpf.imovel.setorComercial.codigo, " 
				  	 +  " mcpf.imovel.quadra.numeroQuadra, " 
				  	 +  " rota.codigo, " 
				  	 +  " mcpf.imovel.id, " 
				  	 +  " rota.faturamentoGrupo.id, " 
			  		 +  " ajuste.valorCobradoAgua, "
					 +  " ajuste.numeroConsumoAgua, "  
					 +  " ajuste.valorCobradoEsgoto, "
					 +  " ajuste.numeroConsumoEsgoto, "
					 +  " mcpf.anoMesReferenciaPreFaturamento ";

			consulta += " order by mcpf.imovel.localidade.id, " 
					 +  " mcpf.imovel.setorComercial.codigo, "
					 +  " mcpf.imovel.quadra.numeroQuadra, "
					 +  " rota.codigo, "
					 +  " mcpf.imovel.id ";

			query = session.createQuery(consulta).setParameter("anoMesReferencia", anoMesReferencia);
			
			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}
			
			retorno = query.setFirstResult(10 * qtd).setMaxResults(10).list();
			//retorno = query.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0993] Consultar Faturamento Imediato Ajuste
	 * 
	 * @author Hugo Leonardo
	 * @date 01/03/2010
	 * 
	 * @param anoMesReferencia, idFaturamentoGrupo, idImovel, idRota
	 * @return Quantidade 
	 * @throws ErroRepositorioException
	 */
	
	public Integer contarFaturamentoImediatoAjuste(String anoMesReferencia, String idFaturamentoGrupo, 
			String idImovel, String idRota) throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String consulta = null;
		Query query = null;
		Map parameters = new HashMap();
		
		try {
			consulta = " select count(distinct ajuste.id) as cont "
					 + " from FaturamentoImediatoAjuste ajuste, MovimentoContaPrefaturada mcpf, Rota rota ";
					 
			consulta += " where mcpf.conta.id = ajuste.conta.id "
				     +  " and mcpf.anoMesReferenciaPreFaturamento = :anoMesReferencia ";
				  
			// Grupo Faturamento
		    if(idFaturamentoGrupo != null && !idFaturamentoGrupo.equals("")){
		    	
		    	consulta += " and rota.faturamentoGrupo.id = :faturamentoGrupo ";
			    parameters.put("faturamentoGrupo", idFaturamentoGrupo);
		    }
		    
		    consulta += " and mcpf.rota.id = rota.id ";
		  
		    // Rota
		    if(idRota != null && !idRota.equals("")){
		    	
		    	consulta += " and rota.id = :rota1 ";
		    	parameters.put("rota1", idRota);
		    }
		    
		    // Imovel
		    if(idImovel != null && !idImovel.equals("")){
		    	
		    	consulta += " and mcpf.imovel.id = :imovel ";
		    	parameters.put("imovel", idImovel);
		    }
				  
		    query = session.createQuery(consulta).setParameter("anoMesReferencia", anoMesReferencia);	  
				
		    Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}
			
			retorno = (Integer) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarContasPagasGeracaoDeclaracaoQuitacao(
			Integer id, String ano, Date dataVerificacaoPagamentos)
			throws ErroRepositorioException {
		
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		String consulta = null;

		try {
			
			consulta 
					= 
					" SELECT  i.imov_id as idImovel,ch.cnta_id as idConta, "+
					"	cnhi_vlagua as vlAgua,cnhi_vlesgoto as vlEsgoto,cnhi_vldebitos as vlDebitos," +
					"   cnhi_vlcreditos as vlCreditos,cnhi_vlimpostos as vlImposto,"+
					"	pghi_dtpagamento as data,cnhi_amreferenciaconta as referencia,"+
					"   'PAGA' as situacao"+
					" FROM  faturamento.conta_historico ch"+
					" INNER JOIN cadastro.imovel i on i.imov_id = ch.imov_id"+
					" INNER JOIN arrecadacao.pagamento_historico ph on ph.cnta_id = ch.cnta_id"+
					" INNER JOIN faturamento.debito_credito_situacao dcs on dcs.dcst_id = ch.dcst_idatual" +
					" WHERE ch.dcst_idatual in("
					+DebitoCreditoSituacao.NORMAL+","+DebitoCreditoSituacao.RETIFICADA+","+DebitoCreditoSituacao.INCLUIDA +")"+
					"	AND ch.cnhi_amreferenciaconta like :anoConta"+
					"	AND ph.pghi_dtpagamento is not null "+
					"	AND ph.pghi_dtpagamento <= :dataPagamento "+
					"	AND i.imov_id = :idImovel"+
					"   AND ph.pgst_idatual = :pagamentoSituacao "+
					" ORDER BY 9";
			
				retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("vlAgua", Hibernate.BIG_DECIMAL)
					.addScalar("vlEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("vlDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("vlCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("vlImposto", Hibernate.BIG_DECIMAL)
					.addScalar("data", Hibernate.DATE)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("situacao", Hibernate.STRING)
					.setParameter("anoConta", ano)
					.setDate("dataPagamento", dataVerificacaoPagamentos)
					.setInteger("idImovel", id)
					.setInteger("pagamentoSituacao",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.list();


		} catch (HibernateException e) {
			e.printStackTrace();			
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarContasCanceladasGeracaoDeclaracaoQuitacao(
			Integer id, String ano, Date dataVerificacaoPagamentos)
			throws ErroRepositorioException {
		
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		String consulta = null;

		try {
			
			consulta 
					= 
					" SELECT  i.imov_id as idImovel,ch.cnta_id as idConta, "+
					"	cnhi_vlagua as vlAgua,cnhi_vlesgoto as vlEsgoto,cnhi_vldebitos as vlDebitos," +
					"   cnhi_vlcreditos as vlCreditos,cnhi_vlimpostos as vlImposto,"+
					"	cnhi_dtcancelamento as data,cnhi_amreferenciaconta as referencia,"+
					"   dcs.dcst_dsdebitocreditosituacao as situacao"+
					" FROM faturamento.conta_historico ch"+
					" INNER JOIN cadastro.imovel i on i.imov_id = ch.imov_id"+
					" INNER JOIN faturamento.debito_credito_situacao dcs on dcs.dcst_id = ch.dcst_idatual" +
					" WHERE ch.dcst_idatual = "+ DebitoCreditoSituacao.CANCELADA + 
					"	AND ch.cnhi_amreferenciaconta like :anoConta"+
					"	AND  ch.cnhi_dtcancelamento is not null "+
					"	AND ch.cnhi_dtcancelamento <= :dataPagamento "+
					"	AND i.imov_id = :idImovel"+
					" ORDER BY 9";
			
				retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("vlAgua", Hibernate.BIG_DECIMAL)
					.addScalar("vlEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("vlDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("vlCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("vlImposto", Hibernate.BIG_DECIMAL)
					.addScalar("data", Hibernate.DATE)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("situacao", Hibernate.STRING)
					.setParameter("anoConta", ano)
					.setDate("dataPagamento", dataVerificacaoPagamentos)
					.setInteger("idImovel", id)
					.list();


		} catch (HibernateException e) {
			e.printStackTrace();
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarContasEmCobrancaJudicialGeracaoDeclaracaoQuitacao(
			Integer id, String ano, Date dataVerificacao)
			throws ErroRepositorioException {
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		String consulta = null;

		try {
			
			consulta 
					= 
						" SELECT  i.imov_id as idImovel,c.cnta_id as idConta, "+
						"	cnta_vlagua as vlAgua,cnta_vlesgoto as vlEsgoto,cnta_vldebitos as vlDebitos," +
						"   cnta_vlcreditos as vlCreditos,cnta_vlimpostos as vlImposto,"+
						"	cnta_amreferenciaconta as referencia,"+
						"   cs.cbst_dscobrancasituacao as situacao,"+
						"   cnta_dtrevisao as dataRevisao"+
						" FROM cadastro.imovel i"+
						" INNER JOIN faturamento.conta c on c.imov_id = i.imov_id"+
						" INNER JOIN cobranca.cobranca_situacao cs on cs.cmrv_id = c.cmrv_id"+
						" WHERE cs.cbst_id = :cobrancaSituacao" +
						" and i.imov_id = :idImovel"+
						" and cnta_amreferenciaconta like :anoConta " +
						" and cnta_dtrevisao <= :data";
			
				retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("vlAgua", Hibernate.BIG_DECIMAL)
					.addScalar("vlEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("vlDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("vlCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("vlImposto", Hibernate.BIG_DECIMAL)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("situacao", Hibernate.STRING)
					.addScalar("dataRevisao", Hibernate.DATE)
					.setInteger("cobrancaSituacao", CobrancaSituacao.EM_COBRANCA_JUDICIAL)
					.setParameter("anoConta", ano)
					.setInteger("idImovel", id)	
					.setDate("data", dataVerificacao)
					.list();


		} catch (HibernateException e) {			
			e.printStackTrace();
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarContasParceladasGeracaoDeclaracaoQuitacao(
			Integer id, String ano, Date dataVerificacaoPagamentos)
			throws ErroRepositorioException {
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		String consulta = null;

		try {
			
			consulta 
					= 
					" SELECT  i.imov_id as idImovel,ch.cnta_id as idConta, "+
					"	cnhi_vlagua as vlAgua,cnhi_vlesgoto as vlEsgoto,cnhi_vldebitos as vlDebitos," +
					"   cnhi_vlcreditos as vlCreditos,cnhi_vlimpostos as vlImposto,"+
					"	parc_tmparcelamento as data,cnhi_amreferenciaconta as referencia,"+
					"   dcs.dcst_dsdebitocreditosituacao as situacao"+
					" FROM  faturamento.conta_historico ch"+
					" INNER JOIN cadastro.imovel i on i.imov_id = ch.imov_id"+
					" INNER JOIN  cobranca.parcelamento_item pi on pi.cnta_id = ch.cnta_id"+
					" INNER JOIN cobranca.parcelamento p on p.parc_id = pi.parc_id"+
					" INNER JOIN faturamento.debito_credito_situacao dcs on dcs.dcst_id = ch.dcst_idatual" +
					" WHERE ch.dcst_idatual = "+ DebitoCreditoSituacao.PARCELADA + 
					"   AND p.pcst_id = :parcelamentoSituacao"+
					"	AND p.parc_tmparcelamento is not null"+
					"	AND ch.cnhi_amreferenciaconta like :anoConta"+
					"	AND p.parc_tmparcelamento < :dataPagamento"+
					"	AND i.imov_id = :idImovel"+
					" " +
					" " +
					" ORDER BY 9";
			
				
			
				retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("vlAgua", Hibernate.BIG_DECIMAL)
					.addScalar("vlEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("vlDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("vlCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("vlImposto", Hibernate.BIG_DECIMAL)
					.addScalar("data", Hibernate.DATE)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("situacao", Hibernate.STRING)
					.setInteger("parcelamentoSituacao", ParcelamentoSituacao.NORMAL)
					.setParameter("anoConta", ano)
					.setDate("dataPagamento", dataVerificacaoPagamentos)
					.setInteger("idImovel", id)
					.list();


		} catch (HibernateException e) {
			e.printStackTrace();
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC1008] Gerar TXT declaração de quitação anual de débitos
	 * 
	 * 	Este caso de uso permite a geração do TXT da declaração de quitação de débitos.
	 * 
	 * @author Hugo Amorim
	 * @date 23/03/2010
	 */
	public Collection<Integer> pesquisarAnosParaGerarArquivoTextoDeclaracaoQuitacaoAnualDebitos()
			throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		String consulta;
		Collection<Integer> retorno = null;

		try {
			consulta = "select anoReferencia"+
					" from ExtratoQuitacao "+
					" where indicadorImpressao = :indicadorImpressao"+
					" group by anoReferencia";

			retorno = session.createQuery(consulta)
					.setInteger("indicadorImpressao", ConstantesSistema.NAO.intValue())		
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	/**
	 * [UC1001] Emitir declaração de quitação anual de débitos
	 * 
	 * Pesquisa das contas.
	 * 
	 * @author Hugo Amorim
	 * @date 17/03/2010
	 */
	public Collection<Integer> pesquisarImoveisParaGeracaoDaDeclaracaodeQuitacaoDebitos(Integer idRota,
			int quantidadeInicio, int quantidadeMaxima) 
		throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		String consulta;
		Collection<Integer> retorno = null;

		try {
			consulta = "select i.id"+
					" from Imovel i"+
					" inner join  i.quadra q"+
					" inner join  q.rota r"+
					" where i.indicadorExclusao = :indicadorExclusao and r.id = :idRota"+
					" order by i.id";

			retorno = session.createQuery(consulta)
					.setShort("indicadorExclusao", ConstantesSistema.NAO)	
					.setInteger("idRota", idRota)
					.setFirstResult(quantidadeInicio).setMaxResults(quantidadeMaxima)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}	
	
	/**
	 * [UC1008] Gerar TXT declaração de quitação anual de débitos
	 * 
	 * 	Este caso de uso permite a geração do TXT da declaração de quitação de débitos.
	 * 
	 * @author Hugo Amorim
	 * @date 23/03/2010
	 */
	public Collection pesquisarExtratoQuitacaoParaGeracaoArquivoTexto(
			Integer ano, int empresaId, int quantidadeMaxima, Integer idGrupo) throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;
		
		/*
		 * autor: Adriana Muniz
		 * data: 21/03/2011
		 * Ordenação dos imoveis por Localidade, Setor, Quadra e Sequencial da Rota,
		 * */

		try {
			consulta = 
					"SELECT extq_id as id," //0
					+" eq.imov_id as imovel," //1
					+" extq_aareferenciaarrecadacao as ano," //2
					+" exqi_vltotal as valor," //3
					+" e.empr_id as empresa," //4
					+" extq_icimpressao as icimpressao," //5
					+" extq_tmultimaalteracao as ultimaalteracao," //6
					+" extq_ammensagemconta as anoMensagemConta," //7
					+" extq_icimpressaoconta as icimpressaoConta " //8
					+" FROM faturamento.extrato_quitacao eq" 
					+" INNER JOIN cadastro.imovel i on i.imov_id = eq.imov_id" 
					+" INNER JOIN cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id"
					+" INNER JOIN cadastro.quadra q on q.qdra_id = i.qdra_id" 
					+" INNER JOIN micromedicao.rota r on r.rota_id = q.rota_id"
					+" INNER JOIN faturamento.faturamento_grupo f on f.ftgr_id = r.ftgr_id"
					+" INNER JOIN cadastro.empresa e on e.empr_id = r.empr_id" 
					+" WHERE extq_aareferenciaarrecadacao = :anoReferencia"
					+" and eq.extq_icimpressao = :indicadorImpressao"
					+" and e.empr_id = :empresa" 
					+" and f.ftgr_id = :idGrupo"
					+" order by  i.loca_id, sc.stcm_cdsetorcomercial, q.qdra_nnquadra, "
					+" i.imov_nnlote, i.imov_nnsublote, i.imov_nnsequencialrota, r.rota_cdrota";

			retorno = session.createSQLQuery(consulta)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("ano", Hibernate.INTEGER)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.addScalar("empresa", Hibernate.INTEGER)
					.addScalar("icimpressao", Hibernate.INTEGER)	
					.addScalar("ultimaalteracao", Hibernate.TIMESTAMP)	
					.addScalar("anoMensagemConta", Hibernate.INTEGER)
					.addScalar("icimpressaoConta", Hibernate.INTEGER)
					.setInteger("anoReferencia", ano)
					.setInteger("empresa", empresaId)
					.setInteger("idGrupo", idGrupo)
					.setInteger("indicadorImpressao", ConstantesSistema.NAO.intValue())
					.setMaxResults(quantidadeMaxima)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	/**
	 * [UC1008] Gerar TXT declaração de quitação anual de débitos
	 * 
	 * 	Este caso de uso permite a geração do TXT da declaração de quitação de débitos.
	 * 
	 * @author Hugo Amorim
	 * @date 23/03/2010
	 */
	public Collection<ExtratoQuitacaoItem> pesquisarExtratoQuitacaoItensParaGeracaoArquivoTexto(
			Integer id)throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		String consulta;
		Collection<ExtratoQuitacaoItem> retorno = null;

		try {
			consulta = 
					" FROM ExtratoQuitacaoItem"+
					" where extratoQuitacao = :extratoQuitacao"+
					" order by anoMesReferenciaConta";

			retorno = session.createQuery(consulta)
					.setInteger("extratoQuitacao", id)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 *
	 * @author Hugo Amorim
	 * @date 07/04/2010
	 *
	 * @param idImovel
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarDeDoacaoAtivos(Integer idImovel, Integer anoMesReferenciaContabil, Integer idDebitoTipo)
		throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;
		
		try {
			consulta = "select dc.id "
					+ "from DebitoACobrar dc,ImovelDoacao imovDoacao "
					+ "inner join dc.imovel imov "
					+ "inner join imovDoacao.imovel imovD "
					+ "inner join imovDoacao.entidadeBeneficente entBenef "
					+ "inner join entBenef.debitoTipo debTipoEntBef "
					+ "inner join dc.debitoTipo debTipoACob ";

			consulta = consulta
					+ "where imov.id = :idImovel and "
					+ "debTipoEntBef.id = debTipoACob.id and imov.id = imovD.id and " 
					+ "dc.debitoTipo.id = :idDebitoTipo and "
					+ "dc.debitoCreditoSituacaoAtual = :debitoCreditoSituacaoAtual and "
					+ "(dc.numeroPrestacaoDebito > dc.numeroPrestacaoCobradas " 
					+ "and (dc.numeroPrestacaoDebito <> 1  or dc.anoMesReferenciaContabil = :anoMesReferenciaContabil) "
			 		+ "or (dc.numeroPrestacaoDebito = 1 and dc.anoMesReferenciaDebito = :anoMesReferenciaContabil ))"; 
			
			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel.intValue())
					.setInteger("debitoCreditoSituacaoAtual", DebitoCreditoSituacao.NORMAL)
					.setInteger("anoMesReferenciaContabil",anoMesReferenciaContabil)
					.setInteger("idDebitoTipo",idDebitoTipo)
					.list();
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [SB0002]  Replicar os débitos existentes para uma nova vigência e valor.
	 * Pesquisa a última vigência de cada débito tipo, e retorna uma coleção com limite de 10 registros. 
	 * 
	 * @author Josenildo Neves - Hugo Leonardo
	 * @date 22/02/2010		   - 14/04/2010
	 */
	public Collection<DebitoTipoVigencia> pesquisarDebitoTipoVigenciaUltimaVigencia(Integer numeroPagina) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
								+"* "
							+"from faturamento.debito_tipo_vigencia dtv, "
								+"(select "
										+"dbtp_id id, "
										+"max(dbtv_dtvigenciafinal) as data "
									+"from faturamento.debito_tipo_vigencia "
									+"group by "
									+"dbtp_id) sc "
							+"where "
							+"dtv.dbtp_id = id and "
							+"dtv.dbtv_dtvigenciafinal = sc.data"; 	
				
			retorno = session.createSQLQuery(consulta)
					.addScalar("dbtv_id",Hibernate.INTEGER)
					.addScalar("dbtp_id",Hibernate.INTEGER)
					.addScalar("dbtv_vldebito",Hibernate.BIG_DECIMAL)
					.addScalar("dbtv_tmultimaalteracao",Hibernate.TIMESTAMP)
					.addScalar("dbtv_dtvigenciainicial",Hibernate.DATE)
					.addScalar("dbtv_dtvigenciafinal",Hibernate.DATE)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [SB0002]  Replicar os débitos existentes para uma nova vigência e valor.
	 * Pesquisa a última vigência de cada tipo débito, e retorna o total.   
	 * 
	 * @author Josenildo Neves
	 * @date 22/02/2010
	 */
	public Integer pesquisarDebitoTipoVigenciaUltimaVigenciaTotal() throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
							+"* "
						+"from faturamento.debito_tipo_vigencia dtv, "
							+"(select "
									+"dbtp_id id, "
									+"max(dbtv_dtvigenciafinal) as data "
								+"from faturamento.debito_tipo_vigencia "
								+"group by "
								+"dbtp_id) sc "
						+"where "
						+"dtv.dbtp_id = id and "
						+"dtv.dbtv_dtvigenciafinal = sc.data";
			
			retorno = session.createSQLQuery(consulta)
						.addScalar("dbtv_id",Hibernate.INTEGER)
						.addScalar("dbtp_id",Hibernate.INTEGER)
						.addScalar("dbtv_vldebito",Hibernate.BIG_DECIMAL)
						.addScalar("dbtv_tmultimaalteracao",Hibernate.TIMESTAMP)
						.addScalar("dbtv_dtvigenciainicial",Hibernate.DATE)
						.addScalar("dbtv_dtvigenciafinal",Hibernate.DATE).list().size();
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [SB0002]  Replicar os débitos existentes para uma nova vigência e valor.
	 * Pesquisa a última vigência de cada tipo débito, e retorna uma coleção.   
	 * 
	 * @author Josenildo Neves - Hugo Leonardo	
	 * @date 22/02/2010		   - 14/04/2010
	 */
	public Collection<DebitoTipoVigencia> pesquisarDebitoTipoVigenciaUltimaVigenciaSelecionados(String[] selecionados) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
								+"* "
							+"from faturamento.debito_tipo_vigencia dtv, "
								+"(select "
										+"dbtp_id id, "
										+"max(dbtv_dtvigenciafinal) as data "
									+"from faturamento.debito_tipo_vigencia "
									+"group by "
									+"dbtp_id) sc "
							+"where "
							+"dtv.dbtp_id = id and "
							+"dtv.dbtv_dtvigenciafinal = sc.data and "
							+"dtv.dbtv_id in (:selecionados)"; 	
				
			retorno = session.createSQLQuery(consulta)
						.addScalar("dbtv_id",Hibernate.INTEGER)
						.addScalar("dbtp_id",Hibernate.INTEGER)
						.addScalar("dbtv_vldebito",Hibernate.BIG_DECIMAL)
						.addScalar("dbtv_tmultimaalteracao",Hibernate.TIMESTAMP)
						.addScalar("dbtv_dtvigenciainicial",Hibernate.DATE)
						.addScalar("dbtv_dtvigenciafinal",Hibernate.DATE)
						.setParameterList("selecionados",selecionados).list();
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1008] Gerar TXT declaração de quitação anual de débitos
	 * 
	 * 	Este caso de uso permite a geração do TXT da declaração de quitação de débitos.
	 * 
	 * @author Hugo Amorim
	 * @date 23/03/2010
	 */
	public Collection<Empresa> pesquisarEmpresasParaGeraracaoExtrato(Integer idGrupo)
			throws ErroRepositorioException {
		
		Collection empresas = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct empresa from Rota r where r.faturamentoGrupo = :idGrupo";

			empresas = session.createQuery(consulta)
				.setInteger("idGrupo", idGrupo)
				.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return empresas;
	}    

	/**
	 * [UC0820] Atualizar Faturamento do Movimento Celular
     * 
     * Método criado para atualizar apenas os campos necessários para
     * Conta.
     * 	 
     * @author Bruno Barros
     * @date 31/03/2010
     * @param medicaoHistorico
	 * @throws ErroRepositorioException
	 */
	public void atualizarContaProcessoMOBILE( Conta conta ) 
		throws ErroRepositorioException{
		
		String update;
		Session session = HibernateUtil.getSession();

		try {
			
			
			update = 		
				"UPDATE Conta " +
				"   SET cnta_nnconsumoagua= :consumoAgua, " +
				"       cnta_nnconsumoesgoto= :consumoEsgoto, " +
				"       cnta_nnconsumorateioagua= :consumoRateioAgua, " +
				"       cnta_nnconsumorateioesgoto= :consumoRateioEsgoto, " +
				"       cnta_vlagua= :valorAgua, " +
				"       cnta_vlesgoto= :valorEsgoto, " +
				"       cnta_vlimpostos= :valorImpostos, " +
				"       cnta_dtemissao= :dataEmissao, " +
				"       cnta_tmultimaalteracao= :dataUltimaAlteracao, " +
				"       dcst_idatual= :situacaoAtual, " +
				"       cnta_vlcreditos= :valorCreditos " ;
			
			// Caso tenha leitura atual para atualizar
			if(conta.getNumeroLeituraAtual() != null && !conta.getNumeroLeituraAtual().equals("")){
				update = update + " ,cnta_nnleituraatual= " + conta.getNumeroLeituraAtual();
			}
			// Caso tenha leitura anterior para atualizar
			if(conta.getNumeroLeituraAnterior() != null && !conta.getNumeroLeituraAnterior().equals("")){
				update = update + " ,cnta_nnleituraanterior= " + conta.getNumeroLeituraAnterior();
			}
			
			if (conta.getValorRateioAgua() != null) {
				update = update + " ,cnta_vlrateioagua= " + conta.getValorRateioAgua();
			}
			
			if (conta.getValorRateioEsgoto() != null) {
				update = update + " ,cnta_vlrateioesgoto= " + conta.getValorRateioEsgoto();
			}
			/**
			 * 
			 * Alteracao para atualizar a data de vencimento
			 * das contas não impressas
			 * Data: 25/10/2011
			 * Autor: Pamela Gatinho
			 */
			// Caso tenha data de vencimento
//			if(conta.getDataVencimentoConta() != null && !conta.getDataVencimentoConta().equals("")){
//				update = update + " ,cnta_dtvencimentoconta = '" + Util.formatarData(conta.getDataVencimentoConta()) + "'";
//				
//				
//			}
				update = update + " WHERE cnta_id = :idConta ";
			
			session.createQuery(update).
			setInteger( "consumoAgua", conta.getConsumoAgua() ).
			setInteger( "consumoEsgoto", conta.getConsumoEsgoto() ).
			setInteger( "consumoRateioAgua", conta.getConsumoRateioAgua() ).
			setInteger( "consumoRateioEsgoto", conta.getConsumoRateioEsgoto() ).
			setBigDecimal( "valorAgua", conta.getValorAgua() ).
			setBigDecimal( "valorEsgoto", conta.getValorEsgoto() ).
			setBigDecimal( "valorImpostos", conta.getValorImposto() ).
			setTimestamp( "dataEmissao", conta.getDataEmissao() ).
			setTimestamp( "dataUltimaAlteracao",  new Date() ).
			setInteger( "situacaoAtual", conta.getDebitoCreditoSituacaoAtual().getId() ).
			setBigDecimal( "valorCreditos", conta.getValorCreditos() ).
			setInteger( "idConta", conta.getId() )
			.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	
	/**
	 * [UC0820] Atualizar Faturamento do Movimento Celular
     * 
     * Método criado para atualizar apenas os campos necessários para
     * Conta Categoria.
     * 	 
     * @author Bruno Barros
     * @date 31/03/2010
     * @param medicaoHistorico
	 * @throws ErroRepositorioException
	 */
	public void atualizarContaCategoriaProcessoMOBILE( ContaCategoria contaCategoria ) 
		throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {
			
			Connection jdbcCon = session.connection();
			
			String update = 		
				"UPDATE faturamento.conta_categoria " +
				// 1
				"   SET ctcg_vlagua=?, " +
				// 2
				"       ctcg_nnconsumoagua=?, " +
				// 3
				"       ctcg_vlesgoto=?, " +
				// 4
				"       ctcg_nnconsumoesgoto=?, " +
				// 5
				"       ctcg_vltarifaminimaagua=?, " +
				// 6
				"       ctcg_nnconsumominimoagua=?, " +
				// 7
				"       ctcg_vltarifaminimaesgoto=?, " +
				// 8
				"       ctcg_nnconsumominimoesgoto=?, " +
				// 9
				"       ctcg_tmultimaalteracao=? " +
				" WHERE " +
				// 10
				"   cnta_id = ? and " +
				// 11
				"   catg_id = ? and "+
				// 12
				"   scat_id =? ";			
			st = 
				jdbcCon.prepareStatement(update);
			
			st.setBigDecimal( 1, contaCategoria.getValorAgua() );
			st.setInt( 2, contaCategoria.getConsumoAgua() );
			st.setBigDecimal( 3, contaCategoria.getValorEsgoto() );
			st.setInt( 4, contaCategoria.getConsumoEsgoto() );
			st.setBigDecimal( 5, contaCategoria.getValorTarifaMinimaAgua() );
			st.setInt( 6, contaCategoria.getConsumoMinimoAgua());
			st.setBigDecimal( 7, contaCategoria.getValorTarifaMinimaEsgoto() );
			st.setInt( 8, contaCategoria.getConsumoEsgoto() );
			st.setTimestamp( 9, new Timestamp( new Date().getTime() ) );
			st.setInt( 10, contaCategoria.getComp_id().getConta().getId() );
			st.setInt( 11, contaCategoria.getComp_id().getCategoria().getId() );
			st.setInt( 12, contaCategoria.getComp_id().getSubcategoria().getId() );
			
			st.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0820] Atualizar Faturamento do Movimento Celular
     * 
     * Método criado para atualizar apenas os campos necessários para
     * Conta Impostos Deduzidos.
     * 	 
     * @author Bruno Barros
     * @date 31/03/2010
     * @param medicaoHistorico
	 * @throws ErroRepositorioException
	 */
	public void atualizarContaImpostosDeduzidosProcessoMOBILE( ContaImpostosDeduzidos contaImpostosDeduzidos ) 
		throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {
			
			Connection jdbcCon = session.connection();
			
			String update = 		
				"UPDATE faturamento.conta_impostos_deduzidos " +
				// 1
				"   SET cnid_vlimposto = ?, " +
				// 2
				"       cnid_pcaliquota = ?, " +
				// 3
				"       cnid_vlbasecalculo = ?, " +
				// 4
				"       cnid_tmultimaalteracao = ? " +
				" WHERE " +
				// 5
				"   cnid_id = ? ";
			
			st = 
				jdbcCon.prepareStatement(update);
			
			st.setBigDecimal( 1, contaImpostosDeduzidos.getValorImposto() );
			st.setBigDecimal( 2, contaImpostosDeduzidos.getPercentualAliquota() );
			st.setBigDecimal( 3, contaImpostosDeduzidos.getValorBaseCalculo() );
			st.setTimestamp( 4, new Timestamp( new Date().getTime() ) );
			st.setInt( 5, contaImpostosDeduzidos.getId() );

			st.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0820] Atualizar Faturamento do Movimento Celular
     * 
     * Método criado para atualizar apenas os campos necessários para
     * Movimento Conta Prefaturada.
     * 	 
     * @author Bruno Barros
     * @date 31/03/2010
     * @param medicaoHistorico
	 * @throws ErroRepositorioException
	 */
	public void atualizarMovimentoContaPrefaturadaProcessoMOBILE( MovimentoContaPrefaturada movimentoContaPrefaturada ) 
		throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {
			
			Connection jdbcCon = session.connection();
			
			String update = 		
				"UPDATE faturamento.mov_conta_prefaturada " +
				// 1
				"   SET mcpf_icatualizarfaturamento = ?, " +
				// 2
				"       mcpf_tmultimaalteracao = ? ";
			
			try{
				if(movimentoContaPrefaturada.getConta() != null && !movimentoContaPrefaturada.getConta().equals("") &&
						movimentoContaPrefaturada.getConta().getId() != null){
					update = update + " ,cnta_id = "+ movimentoContaPrefaturada.getConta().getId();
				}
			}catch (LazyInitializationException e) {
				

			}
				
			update = update +" WHERE " +
				// 3
				"   imov_id = ? AND "+
			    // 4
			    "  mcpf_ammovimento = ? ";
			
			st = 
				jdbcCon.prepareStatement(update);
			
			st.setShort( 1, movimentoContaPrefaturada.getIndicadorAtualizacaoFaturamento() );
			st.setTimestamp( 2, new Timestamp( new Date().getTime() ) );
			st.setInt( 3, movimentoContaPrefaturada.getImovel().getId() );
			st.setInt( 4, movimentoContaPrefaturada.getAnoMesReferenciaPreFaturamento() );

			st.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0820] Atualizar Faturamento do Movimento Celular
     * 
     * Método criado para atualizar apenas os campos necessários para
     * Conta.
     * 	 
     * @author Bruno Barros
     * @date 22/04/2010
     * @param Conta
	 * @throws ErroRepositorioException
	 */
	public void zerarValoresContaPassarDebitoCreditoSituacaoAtualPreFaturadaMOBILE( Conta conta ) 
		throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {
			
			Connection jdbcCon = session.connection();
			
			String update = 		
				"UPDATE faturamento.conta " +
				// 1
				"   SET dcst_idatual = ?, " +
				// 2
				"          cnta_vlagua = ?, " +
				// 3
				"          cnta_vlesgoto = ?, " +
				// 4
				"          cnta_vlimpostos = ?, " +
				// 5 
				"          cnta_vlcreditos = ? " +
				" WHERE " +
				// 6
				"   cnta_id = ? ";
			
			st = 
				jdbcCon.prepareStatement(update);
			
			st.setInt( 1, conta.getDebitoCreditoSituacaoAtual().getId()  );
			st.setBigDecimal( 2, conta.getValorAgua()  );
			st.setBigDecimal( 3, conta.getValorEsgoto()  );
			st.setBigDecimal( 4, conta.getValorImposto()  );
			st.setBigDecimal( 5, conta.getValorCreditos()  );
			st.setInt( 6, conta.getId() );

			st.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0982] Inserir tipo de Débito com Vigência.
	 * 
	 * Verificar se existe vigência já cadastrada para o tipo de débito.
	 * 
	 * @author Hugo Leonardo
	 * @param dataVigenciaInicial
	 * @param dataVigenciaFinal
	 * @throws ErroRepositorioException
	 * @data 30/04/2010
	 * @return String
	 */
	public String verificarExistenciaVigenciaDebito(String dataVigenciaInicial, String dataVigenciaFinal, Integer idDebitoTipo)
		throws ErroRepositorioException {

		String retorno = "";
		
		Session session = HibernateUtil.getSession();
		
		String consulta = "";
		
		consulta +=" select dbtp_id as cont " 
				 + " from faturamento.debito_tipo_vigencia " 
				 + " where ((dbtv_dtvigenciainicial <= :dataInicial " 
				 + " or dbtv_dtvigenciainicial <= :dataFinal) "
				 + " and dbtv_dtvigenciafinal >= :dataFinal ) "
				 + " and dbtp_id = :idDebitoTipo";

		try {
			retorno = (String) session.createSQLQuery(consulta)
				.addScalar("cont", Hibernate.STRING)
				.setInteger("idDebitoTipo", idDebitoTipo)
				.setDate("dataInicial", Util.converteStringParaDate(dataVigenciaInicial))
			    .setDate("dataFinal", Util.converteStringParaDate(dataVigenciaFinal))
				.setMaxResults(1).uniqueResult();
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	/** 
	 *  4.1.1.	Através do DBTP_ID relacionar com o DBTP_ID da tabela DEBITO_TIPO_VIGENCIA.
	 *   Selecionar a última vigência (maior data DBTV_DTVIGENCIAFINAL) para o tipo de débito 
	 *   o valor DBTV_VLDEBITO correspondente. 
	 *	4.1.2.	Caso não seja encontrado para uma vigência e tipo de débito na tabela 
	 *	DEBITO_TIPO_VIGENCIA, deverá selecionar o valor sugerido (DBTP_VLSUGERIDO<>0) 
	 *	correspondente a constante 22 na tabela DEBITO_TIPO e utilizar este valor. 
	 *
	 *  @author: Hugo Amorim
	 *  @Analista: Nelson Carvalho
	 *  @data: 17/05/210
	 *
	 *  @throws ErroRepositorioException
	 */
	public DebitoTipoVigencia pesquisarDebitoTipoVigenciaPorDebitoTipo(
			Integer idDebitoTipo) throws ErroRepositorioException {
		/** * Declara variáveis locais ** */
		Session session = null;
		DebitoTipoVigencia retorno = null;

		session = HibernateUtil.getSession();

		/**
		 * * Script HQL que já monta uma coleção de ImovelCobrarDoacaoHelper com
		 * tudo que é necessário **
		 */
		try {
			String consulta = "from DebitoTipoVigencia" +
					" where debitoTipo = :idDebitoTipo" +
					" order by dataVigenciaFinal desc";

			retorno = (DebitoTipoVigencia) session.createQuery(consulta)
					.setInteger("idDebitoTipo", idDebitoTipo)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			/** * levanta a exceção para a próxima camada ** */
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			/** * fecha a sessão ** */
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
//	/**
//	 * [UC1008] Gerar TXT declaração de quitação anual de débitos
//	 * 
//	 * 	Este caso de uso permite a geração do TXT da declaração de quitação de débitos.
//	 * 
//	 * @author Hugo Amorim
//	 * @date 23/03/2010
//	 */
//	public Collection pesquisarExtratoQuitacaoParaGeracaoArquivoTextoCAERN(
//			Integer ano, int empresaId, int quantidadeMaxima, Integer idGrupo) throws ErroRepositorioException{
//		
//		Session session = HibernateUtil.getSession();
//		String consulta;
//		Collection retorno = null;
//
//		try {
//			consulta = 
//					"SELECT extq_id as id," //0
//					+" extq_imov_id as imovel," //1
//					+" extq_aareferenciaarrecadacao as ano," //2
//					+" exqi_vltotal as valor," //3
//					+" e.empr_id as empresa," //4
//					+" extq_icimpressao as icimpressao," //5
//					+" extq_tmultimaalteracao as ultimaalteracao," //6
//					+" extq_ammensagemconta as anoMensagemConta" //7
//					+" FROM faturamento.extrato_quitacao eq" 
//					+" INNER JOIN cadastro.imovel i on i.imov_id = extq_imov_id" 
//					+" INNER JOIN cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id"
//					+" INNER JOIN cadastro.quadra q on q.qdra_id = i.qdra_id" 
//					+" INNER JOIN micromedicao.rota r on r.rota_id = q.rota_id"
//					+" INNER JOIN faturamento.faturamento_grupo f on f.ftgr_id = r.ftgr_id"
//					+" INNER JOIN cadastro.empresa e on e.empr_id = r.empr_id" 
//					+" WHERE extq_aareferenciaarrecadacao = :anoReferencia"
//					+" and eq.extq_icimpressao = :indicadorImpressao"
//					+" and e.empr_id = :empresa" 
//					+" and f.ftgr_id = :idGrupo"
//					+" order by  i.loca_id,sc.stcm_cdsetorcomercial,"
//					+" r.rota_cdrota,i.imov_nnsequencialrota";
//
//			retorno = session.createSQLQuery(consulta)
//					.addScalar("id", Hibernate.INTEGER)
//					.addScalar("imovel", Hibernate.INTEGER)
//					.addScalar("ano", Hibernate.INTEGER)
//					.addScalar("valor", Hibernate.BIG_DECIMAL)
//					.addScalar("empresa", Hibernate.INTEGER)
//					.addScalar("icimpressao", Hibernate.INTEGER)	
//					.addScalar("ultimaalteracao", Hibernate.TIMESTAMP)
//					.addScalar("anoMensagemConta", Hibernate.INTEGER)	
//					.setInteger("anoReferencia", ano)
//					.setInteger("empresa", empresaId)
//					.setInteger("idGrupo", idGrupo)
//					.setInteger("indicadorImpressao", ConstantesSistema.NAO.intValue())
//					.setMaxResults(quantidadeMaxima)
//					.list();
//
//		} catch (HibernateException e) {
//			// levanta a exceção para a próxima camada
//			throw new ErroRepositorioException(e, "Erro no Hibernate");
//		} finally {
//			// fecha a sessão
//			HibernateUtil.closeSession(session);
//		}
//
//		return retorno;
//	}
	
	/**
	 *
	 *   Metodo para calculo da receita liquida.
	 * 
	 * @author Hugo Amorim
	 * @analista Ana Cristina
	 * @since 04/06/2010
	 * @param colecaoCategorias
	 * @param colecaoIdsLocalidades
	 */
	public Object[] pesquisarDadosReceitaLiquidaAguaEsgoto(
			Integer anoMesFaturamentoSistemaParametro,Integer idLocalidade, Integer idCategoria)throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		String consulta;
		Object[] retorno = null;

		try {
			consulta = 
					"select	"
					+" sum(case when ((refa.lcit_id=1 and lctp_id in (1,3,4,5,11,15,16))  " 
					+" or  (refa.lcit_id=3 and lctp_id in (1,3,4,5,11,15,16) and lict_id = 10))"
					+" then rfat_vlitemfaturamento"
					+" when ((refa.lcit_id=1 and lctp_id in (9,10,18,19))"
					+" or  (refa.lcit_id=3 and lctp_id in (7,8,9,10,18,19,59,60,61,62) and lict_id = 10))"
					+" then -1*rfat_vlitemfaturamento"
					+" end)  as agua,"
					+" sum(case when ((refa.lcit_id=2 and lctp_id in (2,3,4,5,11,15,16))" 
					+" or  (refa.lcit_id=3 and lctp_id in (2,3,4,5,11,15,16) and lict_id = 11))"
					+" then rfat_vlitemfaturamento"
					+" when ((refa.lcit_id=2 and lctp_id in (9,10,18,19))"
					+" or  (refa.lcit_id=3 and lctp_id in (7,8,9,10,18,19,59,60,61,62) and lict_id = 11))" 
					+" then -1*rfat_vlitemfaturamento"
					+" end)  as esgoto,"
					+" sum(case when rfat_nnsequenciatipolancamento = 600"
					+" then rfat_vlitemfaturamento"
					+" when rfat_nnsequenciatipolancamento = 1100"
					+" then -1*rfat_vlitemfaturamento"
					+" end)  as total"
					+" from"	
					+" financeiro.resumo_faturamento refa"
					+" left join financeiro.lancamento_item lcit on (refa.lcit_id = lcit.lcit_id)"
					+" inner join cadastro.localidade loca on (loca.loca_id = refa.loca_id)"
					+" where"	
					+" rfat_amreferencia = :anoMes"
					+" and refa.catg_id = :categoria"
					+" and refa.loca_id = :localidade"
					+" group by rfat_amreferencia"
					+" order by rfat_amreferencia";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("agua", Hibernate.BIG_DECIMAL)
					.addScalar("esgoto", Hibernate.BIG_DECIMAL)
					.addScalar("total", Hibernate.BIG_DECIMAL)
					.setInteger("anoMes", anoMesFaturamentoSistemaParametro)
					.setInteger("categoria", idCategoria)
					.setInteger("localidade", idLocalidade)
					.setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
		
	}
	
	/**
	 *
	 *   Metodo para calculo da receita liquida indireta.
	 * 
	 * @author Hugo Amorim
	 * @analista Ana Cristina
	 * @since 04/06/2010
	 * @param colecaoCategorias
	 * @param colecaoIdsLocalidades
	 */
	public BigDecimal pesquisarDadosReceitaLiquidaIndireta(
			Integer anoMesFaturamentoSistemaParametro,Integer idLocalidade, Integer idCategoria)throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		String consulta;
		BigDecimal retorno = null;

		try {
			consulta = 
					"select	"
					+" sum(case when rfat_nnsequenciatipolancamento = 1200"
					+" then rfat_vlitemfaturamento"
					+" when rfat_nnsequenciatipolancamento in (1110,1120)"
					+" then -1*rfat_vlitemfaturamento"
					+" end)  as indireta"
					+" from"	
					+" financeiro.resumo_faturamento refa"
					+" left join financeiro.lancamento_item lcit on (refa.lcit_id = lcit.lcit_id)"
					+" inner join cadastro.localidade loca on (loca.loca_id = refa.loca_id)"
					+" where"	
					+" rfat_amreferencia = :anoMes"
					+" and refa.catg_id = :categoria"
					+" and refa.loca_id = :localidade"
					+" group by rfat_amreferencia"
					+" order by rfat_amreferencia";

			retorno =  (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("indireta", Hibernate.BIG_DECIMAL)
					.setInteger("anoMes", anoMesFaturamentoSistemaParametro)
					.setInteger("categoria", idCategoria)
					.setInteger("localidade", idLocalidade)
					.setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
		
	}
	

	 /**
	 * [UC0876] - Gerar Crédito Situação Especial Faturamento 
	 *
	 * @author Sávio Luiz
	 * @date 10/06/2010
	 *
	 * @param colecaoFaturamentoAtividadeCronogramaRota
	 * @param faturamentoGrupo
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public Object[] pesquisarCreditoARealizar(
			Integer imovelId, Integer idCreditoTipo,
			Integer debitoCreditoSituacaoAtualId, Integer anoMesFaturamento)
			throws ErroRepositorioException {
		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "select crar.crar_id as idCreditoARealizar,crar.crar_vlcredito as valorCredito "
					+ " from "
					+ "  faturamento.credito_a_realizar crar "
					+ " inner join faturamento.debito_credito_situacao dcst on crar.dcst_idatual=dcst.dcst_id "
					+ " inner join cadastro.imovel imov on crar.imov_id=imov.imov_id "
					+ " inner join faturamento.credito_tipo crti on crar.crti_id=crti.crti_id "
					+ " where  usur_id is null and imov.imov_id= :imovelId "
					+ "  and crar.dcst_idatual= :debitoCreditoSituacaoAtualId "
					+ "  and crar.crti_id = :idCreditoTipo "
					+ "  and crar.crar_amreferenciacredito = :anoMesFaturamento ";

			retorno = (Object[])session.createSQLQuery(consulta).addScalar(
					"idCreditoARealizar", Hibernate.INTEGER)
					.addScalar("valorCredito",Hibernate.BIG_DECIMAL)
					.setInteger("imovelId",
							imovelId.intValue()).setInteger(
							"debitoCreditoSituacaoAtualId",
							debitoCreditoSituacaoAtualId).setInteger(
							"anoMesFaturamento", anoMesFaturamento).setInteger(
							"idCreditoTipo", idCreditoTipo).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0391] Inserir valor de cobrança de serviço.
	 * 
	 * Verificar se existe valor de cobrança de serviço já cadastrada.
	 * 
	 * @author Hugo Amorim
	 * @throws ControladorException
	 * @data 07/06/2010
	 * 
	 */
	public Boolean validarVigenciaValorCobrancaServico(
			ServicoCobrancaValor servicoCobrancaValor)throws ErroRepositorioException{
		/** * Declara variáveis locais ** */
		Session session = null;
		Boolean retorno = false;
		Collection retornoConsulta = null;

		session = HibernateUtil.getSession();

		/**
		 * * Script HQL que já monta uma coleção de ImovelCobrarDoacaoHelper com
		 * tudo que é necessário **
		 */
		try {
			String consulta = "FROM ServicoCobrancaValor"
				+" WHERE servicoTipo = :servicoTipo"
				+" AND indicadorMedido = :indicadorMedido"
				+" AND indicadorGeracaoDebito = :indicadorGeracaoDebito"
				+" AND indicadorConsideraEconomias = :indicadorConsideraEconomias"
				+" AND (:dataVigenciaInicial between dataVigenciaInicial and dataVigenciaFinal"
				+" OR :dataVigenciaFinal between dataVigenciaInicial and dataVigenciaFinal)";
				
			    if(servicoCobrancaValor.getImovelPerfil()!=null){
					consulta+=" AND imovelPerfil = :imovelPerfil";
				}
				if(servicoCobrancaValor.getHidrometroCapacidade()!=null){			
					consulta+=" AND hidrometroCapacidade = :hidrometroCapacidade";
				}
				if(servicoCobrancaValor.getCategoria()!=null){
					consulta+="  AND categoria = :categoria";
				}
				if(servicoCobrancaValor.getSubCategoria()!=null){
					consulta+="  AND subCategoria = :subCategoria";
				}
				if(servicoCobrancaValor.getQuantidadeEconomiasInicial()!=null){
					consulta+="  AND quantidadeEconomiasInicial = :quantidadeEconomiasInicial";
				}
				if(servicoCobrancaValor.getQuantidadeEconomiasFinal()!=null){
					consulta+=" AND quantidadeEconomiasFinal = :quantidadeEconomiasFinal";
				}

				Query query = 
					session.createQuery(consulta)
						.setInteger("servicoTipo", servicoCobrancaValor.getServicoTipo().getId())
						.setShort("indicadorMedido", servicoCobrancaValor.getIndicadorMedido())
						.setShort("indicadorGeracaoDebito", servicoCobrancaValor.getIndicadorMedido())					
						.setShort("indicadorConsideraEconomias", servicoCobrancaValor.getIndicadorConsideraEconomias())
						.setDate("dataVigenciaInicial", servicoCobrancaValor.getDataVigenciaInicial())
						.setDate("dataVigenciaFinal", servicoCobrancaValor.getDataVigenciaFinal());
				
				if(servicoCobrancaValor.getImovelPerfil()!=null){
					query.setInteger("imovelPerfil", servicoCobrancaValor.getImovelPerfil().getId());
				}
				if(servicoCobrancaValor.getHidrometroCapacidade()!=null){			
					query.setInteger("hidrometroCapacidade", servicoCobrancaValor.getHidrometroCapacidade().getId());
				}
				if(servicoCobrancaValor.getCategoria()!=null){
					query.setInteger("categoria", servicoCobrancaValor.getCategoria().getId());
				}
				if(servicoCobrancaValor.getSubCategoria()!=null){
					query.setInteger("subCategoria", servicoCobrancaValor.getSubCategoria().getId());
				}
				if(servicoCobrancaValor.getQuantidadeEconomiasInicial()!=null){
					query.setInteger("quantidadeEconomiasInicial", servicoCobrancaValor.getQuantidadeEconomiasInicial());
				}
				if(servicoCobrancaValor.getQuantidadeEconomiasFinal()!=null){
					query.setInteger("quantidadeEconomiasFinal", servicoCobrancaValor.getQuantidadeEconomiasFinal());
				}
			
			
			retornoConsulta	= query.list();
			
			if(retornoConsulta!=null && !retornoConsulta.isEmpty()){
				retorno = true;
			}
					
					
		} catch (HibernateException e) {
			/** * levanta a exceção para a próxima camada ** */
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			/** * fecha a sessão ** */
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Rômulo Aurélio
	 * @throws ControladorException
	 * @data 22/06/2010
	 */

	public Integer retornaAnoMesFaturamentoGrupoDaRota(Integer idRota)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer anoMesFaturamento = null;

		try {

			String sqlMesFaturamentoGrupo = "select fg.ftgr_amreferencia as anoMes "
					+ " from faturamento.faturamento_grupo fg,"
					+ "	micromedicao.rota rota "
					+ " where "
					+ " rota.ftgr_id = fg.ftgr_id "
					+ " and rota.rota_id =:idRota ";

			anoMesFaturamento = (Integer) session.createSQLQuery(sqlMesFaturamentoGrupo)
			.addScalar("anoMes",Hibernate.INTEGER)
			.setInteger("idRota",idRota.intValue())
			.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return anoMesFaturamento;
	}
	

	/**
	 * Atualizar Credito a Realizar Campo numero de prestações realizadas e
	 * valor do crédito
	 * 
	 * [UC0840] - Atualizar Faturamento do Movimento Celular 
	 * 
	 * @author Sávio Luiz
	 * @date 11/06/2010
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorCreditoARealizar(Integer idCreditoARealizar,BigDecimal valorCredito,Integer idDebitoCreditoSituacaoAtual)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {

			

			atualizarImovel = "update gcom.faturamento.credito.CreditoARealizar "
					+ "set crar_vlcredito = :valorCredito, "
					+ "dcst_idatual = :idDebitoCreditoSituacaoAtual, "
					+ "crar_tmultimaalteracao = :dataAtual "
					+ " where crar_id = :idCreditoARelizar ";

			session.createQuery(atualizarImovel)
			    .setInteger("idCreditoARelizar",idCreditoARealizar)
				.setBigDecimal("valorCredito",valorCredito)
				.setInteger("idDebitoCreditoSituacaoAtual",idDebitoCreditoSituacaoAtual)
				.setTimestamp("dataAtual",new Date()).executeUpdate();
			

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * Método que retorna uma array de object com a soma do valor dos debitos
	 * cobrados de parcelamento(parcelamento de água,parcelamento de esgoto,
	 * parcelamento de serviços e juros de parcelamento),o numero da prestacao 
	 * e o numero total de prestações
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 11/06/2010
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParmsDebitoAutomaticoParcelasMaisJurosParcelamento(Integer idConta)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobrado.valorPrestacao),debCobrado.numeroPrestacaoDebito,"
					+ "debCobrado.numeroPrestacao,debCobrado.numeroParcelaBonus "
					+ "from DebitoCobrado debCobrado "
					+ "inner join debCobrado.financiamentoTipo finTipo "
					+ "inner join debCobrado.conta conta "
					+ "where conta.id = :idConta AND "
					+ "(finTipo.id = :parcelamentoAgua OR finTipo.id = :parcelamentoEsgoto OR "
					+ "finTipo.id = :parcelamentoServicos OR finTipo.id = :jurosParcelamento ) "
					+ "group by debCobrado.numeroPrestacaoDebito,debCobrado.numeroPrestacao,debCobrado.numeroParcelaBonus ";

			retorno = session.createQuery(consulta)
					.setInteger("idConta",idConta.intValue())
					.setInteger("parcelamentoAgua",	FinanciamentoTipo.PARCELAMENTO_AGUA)
					.setInteger("parcelamentoEsgoto", FinanciamentoTipo.PARCELAMENTO_ESGOTO)
					.setInteger("parcelamentoServicos",	FinanciamentoTipo.PARCELAMENTO_SERVICO)
					.setInteger("jurosParcelamento",FinanciamentoTipo.JUROS_PARCELAMENTO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualizar Credito a Realizar Categoria Campo valor do crédito por categoria
	 * 
	 * [UC0840] - Atualizar Faturamento do Movimento Celular 
	 * 
	 * @author Sávio Luiz
	 * @date 11/06/2010
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorCreditoARealizarCategoria(Integer idCreditoARealizar,Collection colecaoCategoria,Collection colecaoValorPorCategoria)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			
			Iterator iteratorCategoria = colecaoCategoria.iterator();
			
			Iterator iteratorValorPorCategoria = colecaoValorPorCategoria.iterator();
			
			while (iteratorCategoria.hasNext()){
				
				Categoria categoria = (Categoria) iteratorCategoria.next();
				
				BigDecimal valorPorCategoria = (BigDecimal) iteratorValorPorCategoria.next();
				
				atualizarImovel = "update gcom.faturamento.credito.CreditoARealizarCategoria "
					+ "set cacg_vlcategoria = :valorPorCategoria, "
					+ "cacg_tmultimaalteracao = :dataAtual "
					+ " where crar_id = :idCreditoARelizar and catg_id = :idCategoria ";

				session.createQuery(atualizarImovel)
					.setInteger("idCreditoARelizar",idCreditoARealizar)
					.setBigDecimal("valorPorCategoria",valorPorCategoria)
					.setInteger("idCategoria",categoria.getId())
					.setTimestamp("dataAtual",new Date()).executeUpdate();
					
				
			}

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	
	/**
	 * Atualizar Credito a Realizar Campo numero de prestações realizadas e
	 * valor do crédito
	 * 
	 * [UC0840] - Atualizar Faturamento do Movimento Celular 
	 * 
	 * @author Sávio Luiz
	 * @date 11/06/2010
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorCreditoRealizado(Integer idCreditoRealizado,BigDecimal valorCredito)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {

			

			atualizarImovel = "update gcom.faturamento.credito.CreditoRealizado "
					+ "set crrz_vlcredito = :valorCredito, "
					+ "crrz_tmultimaalteracao = :dataAtual "
					+ " where crrz_id = :idCreditoRealizado ";

			session.createQuery(atualizarImovel)
				.setBigDecimal("valorCredito",valorCredito)
				.setInteger("idCreditoRealizado",idCreditoRealizado)
				.setTimestamp("dataAtual",new Date()).executeUpdate();
			

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * Atualizar Credito a Realizar Categoria Campo valor do crédito por categoria
	 * 
	 * [UC0840] - Atualizar Faturamento do Movimento Celular 
	 * 
	 * @author Sávio Luiz
	 * @date 11/06/2010
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorCreditoRealizadoCategoria(Integer idCreditoRealizado,Collection colecaoCategoriasObterValor,Collection colecaoCategoriasCalculadasValor)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			
			Iterator colecaoCategoriasCalculadasValorIterator = colecaoCategoriasCalculadasValor.iterator();
			
			Iterator colecaoCategoriasObterValorIterator = colecaoCategoriasObterValor.iterator();
			
			while (colecaoCategoriasCalculadasValorIterator
					.hasNext()
					&& colecaoCategoriasObterValorIterator
							.hasNext()) {
				// Obtém o valor por categoria
				BigDecimal valorPorCategoria = (BigDecimal) colecaoCategoriasCalculadasValorIterator
						.next();

				// Obtém a categoria
				Categoria categoria = (Categoria) colecaoCategoriasObterValorIterator
						.next();
				
				atualizarImovel = "update gcom.faturamento.credito.CreditoRealizadoCategoria "
					+ "set crcg_vlcategoria = :valorPorCategoria, "
					+ "crcg_tmultimaalteracao = :dataAtual "
					+ " where crrz_id = :idCreditoRealizado and catg_id = :idCategoria ";

				session.createQuery(atualizarImovel)
					.setBigDecimal("valorPorCategoria",valorPorCategoria)
					.setInteger("idCategoria",categoria.getId())
					.setInteger("idCreditoRealizado",idCreditoRealizado)
					.setTimestamp("dataAtual",new Date()).executeUpdate();


			}
			
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	
	/**
	 * Pesquisa Credito Realizado de nitrato
	 * 
	 * [UC0840] - Atualizar Faturamento do Movimento Celular 
	 * 
	 * @author Sávio Luiz
	 * @date 11/06/2010
	 * 
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdCreditoRealizadoNitrato(Conta conta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT crrz.id "// 0
					+ "FROM CreditoRealizado crrz "
					+ "INNER JOIN crrz.conta conta "
					+ "INNER JOIN crrz.creditoTipo crtp "
					+ "WHERE conta.id = :idConta AND crtp.id = 12 ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idConta", conta.getId()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	

	/**
	 * Método que retorna uma array de object com a soma do valor dos debitos
	 * cobrados de parcelamento(parcelamento de água,parcelamento de esgoto,
	 * parcelamento de serviços e juros de parcelamento),o numero da prestacao 
	 * e o numero total de prestações
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 11/06/2010
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParmsDebitoAutomaticoHistoricoParcelasMaisJurosParcelamento(
			Integer idConta) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobradoHist.valorPrestacao),debCobradoHist.numeroPrestacaoDebito,"
					+ "debCobradoHist.numeroPrestacao,debCobradoHist.numeroParcelaBonus "
					+ "from DebitoCobradoHistorico debCobradoHist "
					+ "inner join debCobradoHist.financiamentoTipo finTipo "
					+ "inner join debCobradoHist.contaHistorico contaHist "
					+ "where contaHist.id = :idConta AND "
					+ "(finTipo.id = :parcelamentoAgua OR finTipo.id = :parcelamentoEsgoto OR "
					+ "finTipo.id = :parcelamentoServicos OR finTipo.id = :jurosParcelamento ) "
					+ "group by debCobradoHist.numeroPrestacaoDebito,debCobradoHist.numeroPrestacao,debCobradoHist.numeroParcelaBonus ";

			retorno = session.createQuery(consulta)
					.setInteger("idConta",idConta.intValue())
					.setInteger("parcelamentoAgua",FinanciamentoTipo.PARCELAMENTO_AGUA)
					.setInteger("parcelamentoEsgoto",FinanciamentoTipo.PARCELAMENTO_ESGOTO)
					.setInteger("parcelamentoServicos",	FinanciamentoTipo.PARCELAMENTO_SERVICO)
					.setInteger("jurosParcelamento",FinanciamentoTipo.JUROS_PARCELAMENTO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * 
	 * [UC0348] Emitir Contas
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/01/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsDebitoCobradoPorTipoSemParcelasEJurosParcelamento(Integer idConta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobrado.valorPrestacao), "// 0
					+ "debCobrado.numeroPrestacaoDebito," // 1
					+ "debCobrado.numeroPrestacao, "// 2
					+ "debCobrado.anoMesReferenciaDebito, "// 3
					+ "debitoTipo.id, "// 4
					+ "debCobrado.debitoTipo.descricao, "// 5
					+ "debCobrado.numeroParcelaBonus " // 6
					+ "from DebitoCobrado debCobrado "
					+ "inner join debCobrado.financiamentoTipo finTipo "
					+ "inner join debCobrado.debitoTipo debitoTipo "
					+ "inner join debCobrado.conta conta "
					+ "where conta.id = :idConta AND "
					+ "( finTipo.id <> :parcelamentoAgua"
					+ " and finTipo.id <> :parcelamentoEsgoto"
					+ " and finTipo.id <> :parcelamentoServicos" 
					+ " and finTipo.id <> :jurosParcelamento )"
					+ "group by "
					+ "debitoTipo.id, "
					+ "debCobrado.numeroPrestacaoDebito,"
					+ "debCobrado.numeroPrestacao, "
					+ "debCobrado.anoMesReferenciaDebito, "
					+ "debCobrado.debitoTipo.descricao, "
					+ "debCobrado.numeroParcelaBonus "
					+ "order by debitoTipo.id,debCobrado.anoMesReferenciaDebito desc";

			retorno = session.createQuery(consulta)
				.setInteger("idConta",idConta.intValue())
				.setInteger("parcelamentoAgua",FinanciamentoTipo.PARCELAMENTO_AGUA)
				.setInteger("parcelamentoEsgoto",FinanciamentoTipo.PARCELAMENTO_ESGOTO)
				.setInteger("parcelamentoServicos",FinanciamentoTipo.PARCELAMENTO_SERVICO)
				.setInteger("jurosParcelamento",FinanciamentoTipo.JUROS_PARCELAMENTO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 11/06/2010
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsDebitoCobradoHistoricoPorTipoSemParcelasEJurosParcelamento(Integer idConta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(debCobradoHist.valorPrestacao), "// 0
					+ "debCobradoHist.numeroPrestacaoDebito," // 1
					+ "debCobradoHist.numeroPrestacao, "// 2
					+ "debCobradoHist.anoMesReferenciaDebito, "// 3
					+ "debitoTipo.id, "// 4
					+ "debCobradoHist.debitoTipo.descricao, "// 5
					+ "debCobradoHist.numeroParcelaBonus " // 6
					+ "from DebitoCobradoHistorico debCobradoHist "
					+ "inner join debCobradoHist.financiamentoTipo finTipo "
					+ "inner join debCobradoHist.debitoTipo debitoTipo "
					+ "inner join debCobradoHist.contaHistorico contaHist "
					+ "where contaHist.id = :idConta AND "
					+ "( finTipo.id <> :parcelamentoAgua"
					+ " and finTipo.id <> :parcelamentoEsgoto"
					+ " and finTipo.id <> :parcelamentoServicos "
					+ " and finTipo.id <> :jurosParcelamento )"
					+ "group by "
					+ "debitoTipo.id, "
					+ "debCobradoHist.numeroPrestacaoDebito,"
					+ "debCobradoHist.numeroPrestacao, "
					+ "debCobradoHist.anoMesReferenciaDebito, "
					+ "debCobradoHist.debitoTipo.descricao, "
					+ "debCobradoHist.numeroParcelaBonus "
					+ "order by debitoTipo.id,debCobradoHist.anoMesReferenciaDebito desc";

			retorno = session.createQuery(consulta)
				.setInteger("idConta",idConta.intValue())
				.setInteger("parcelamentoAgua",FinanciamentoTipo.PARCELAMENTO_AGUA)
				.setInteger("parcelamentoEsgoto",FinanciamentoTipo.PARCELAMENTO_ESGOTO)
				.setInteger("parcelamentoServicos",FinanciamentoTipo.PARCELAMENTO_SERVICO)
				.setInteger("jurosParcelamento",FinanciamentoTipo.JUROS_PARCELAMENTO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0002] - Obter dados dos serviços de parcelamento
	 * 
	 * @author Raphael Rossiter,Vivianne Sousa
	 * @date 25/04/2008,14/06/2010
	 * 
	 * @param conta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoCobradoDeParcelamentoMaisJurosParcelamento(Conta conta)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT dbcb.numeroPrestacaoDebito, "// 0
					+ "(dbcb.numeroPrestacao - COALESCE(dbcb.numeroParcelaBonus,0)) as totalParcela, "// 1
					+ "SUM(dbcb.valorPrestacao), "// 2
					+ "dbcb.debitoTipo.codigoConstante " // 3
					+ "FROM DebitoCobrado dbcb "
					+ "INNER JOIN dbcb.conta conta "
					+ "INNER JOIN dbcb.financiamentoTipo fntp "
					+ "WHERE conta.id = :idConta "
					+ "AND fntp.id IN(:agua, :esgoto, :servico, :jurosParcelamento) "
					+ "GROUP BY dbcb.numeroPrestacaoDebito, (dbcb.numeroPrestacao - COALESCE(dbcb.numeroParcelaBonus, 0)), dbcb.debitoTipo.codigoConstante ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", conta.getId()).setInteger("agua",
					FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger("esgoto",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
					"servico", FinanciamentoTipo.PARCELAMENTO_SERVICO)
					.setInteger("jurosParcelamento",FinanciamentoTipo.JUROS_PARCELAMENTO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0002] - Obter dados dos serviços de parcelamento
	 * 
	 * @author Raphael Rossiter,Vivianne Sousa
	 * @date 25/04/2008,14/06/2010
	 * 
	 * @param conta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoCobradoNaoParcelamentoEJurosParcelamento(Conta conta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT new DebitoCobrado(dbcb.anoMesReferenciaDebito, dbcb.numeroPrestacaoDebito, "
					+ "dbcb.numeroPrestacao - COALESCE(dbcb.numeroParcelaBonus,0), dbcb.valorPrestacao, "
					+ "dbtp) "// 0
					+ "FROM DebitoCobrado dbcb "
					+ "INNER JOIN dbcb.conta conta "
					+ "INNER JOIN dbcb.financiamentoTipo fntp "
					+ "INNER JOIN FETCH dbcb.debitoTipo dbtp "
					+ "WHERE conta.id = :idConta "
					+ "AND fntp.id NOT IN(:agua, :esgoto, :servico, :jurosParcelamento) "
					+ "ORDER BY dbtp.id, dbcb.anoMesReferenciaDebito ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					conta.getId()).setInteger("agua",
					FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger("esgoto",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
					"servico", FinanciamentoTipo.PARCELAMENTO_SERVICO)
					.setInteger("jurosParcelamento",FinanciamentoTipo.JUROS_PARCELAMENTO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0745] - Deleta Arquivo Texto Dividido para Faturamento 
	 *
	 * @author Hugo Leonardo
	 * @date 16/06/2010
	 *
	 * @param idArquivoTextoRoteiroEmpresa

	 * @throws ControladorException
	 */
	public void deletaArquivoTextoRoteiroEmpresaDivisao(Integer idArquivoTextoRoteiroEmpresa) 
		throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		String delete;

		try {
			
			delete = " delete ArquivoTextoRoteiroEmpresaDivisao as arqTxtRotEmpDiv "
				   + " where arqTxtRotEmpDiv.arquivoTextoRoteiroEmpresa = :idArqTxtRotEmp ";

			session.createQuery(delete).setInteger("idArqTxtRotEmp", idArquivoTextoRoteiroEmpresa).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	
	
	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Hugo Amorim
	 * @created 16/06/2010
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarContasEmitidasImpressaoSimultaneaRelatorio(int anoMesReferencia,
			Integer grupoFaturamento, Collection esferaPoder)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select movimentoContaPrefaturada.id, "
					+ // 0
					"(select clienteImovel.cliente.id "
					+ "from ClienteImovel clienteImovel "
					+ "where clienteImovel.imovel.id = imovel.id "
					+ "and clienteImovel.clienteRelacaoTipo.id = 2 "
					+ "and clienteImovel.dataFimRelacao is null), "
					+ // 1
					"(select clienteImovel.cliente.nome "
					+ "from ClienteImovel clienteImovel "
					+ "where clienteImovel.imovel.id = imovel.id "
					+ "and clienteImovel.clienteRelacaoTipo.id = 3 "
					+ "and clienteImovel.dataFimRelacao is null), "
					+ // 2
					"imovel.localidade.id, "
					+ // 3
					"imovel.localidade.descricao, "
					+ // 4
					"conta.dataVencimentoConta, "
					+ // 5
					"imovel.id, "
					+ // 6
					"imovel.setorComercial.codigo, "
					+ // 7
					"imovel.quadra.numeroQuadra, "
					+ // 8
					"imovel.lote, "
					+ // 9
					"imovel.subLote, "
					+ // 10
					"(select clienteImovel.cliente.nome "
					+ "from ClienteImovel clienteImovel "
					+ "where clienteImovel.imovel.id = imovel.id "
					+ "and clienteImovel.clienteRelacaoTipo.id = 2 "
					+ "and clienteImovel.dataFimRelacao is null), "
					+ // 11
					"conta.valorAgua, "
					+ // 12
					"conta.valorEsgoto, "
					+ // 13
					"conta.debitos, "
					+ // 14
					"conta.valorCreditos, "
					+ // 15
					"esferaPoder.id, "
					+ // 16
					"esferaPoder.descricao "
					+ // 17
					"from MovimentoContaPrefaturada movimentoContaPrefaturada "
					+ "left join movimentoContaPrefaturada.conta conta "
					+ "left join conta.clienteContas cliCon "
					+ "left join cliCon.cliente cliente "
					+ "left join cliente.clienteTipo clienteTipo "
					+ "left join clienteTipo.esferaPoder esferaPoder "
					+ "left join conta.imovel imovel "
					+ "where movimentoContaPrefaturada.faturamentoGrupo.id = :grupoFaturamento "
					+ "and esferaPoder.id in (:esferaPoder) "
					+ "and movimentoContaPrefaturada.anoMesReferenciaPreFaturamento = :anoMesReferencia "
					+ "and movimentoContaPrefaturada.indicadorEmissaoConta = :indicadorEmissaoConta "
					+ "and cliCon.clienteRelacaoTipo = :clienteRelacaoTipo "
					+ "and movimentoContaPrefaturada.medicaoTipo = :medicaoTipo " 
					+ "order by esferaPoder.id,2 ";
					
					
					 

			retorno = session.createQuery(consulta)
				.setInteger("grupoFaturamento", grupoFaturamento)
				.setParameterList("esferaPoder", esferaPoder)
				.setInteger("anoMesReferencia",anoMesReferencia)
				.setShort("indicadorEmissaoConta", ConstantesSistema.SIM)
				.setInteger("clienteRelacaoTipo", ClienteRelacaoTipo.USUARIO)
				.setInteger("medicaoTipo", MedicaoTipo.LIGACAO_AGUA)
				.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * Monta a colecao de resultdos apartir da tabela mov_conta_prefaturada para
	 * geracao do relatorio de RESUMO CONTAS EMITIDAS POR LOCALIDADE NO GRUPO
	 * 
	 * @author Hugo Amorim
	 * @date 18/06/2010
	 * 
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarResumoContasLocalidadeImpressaoSimultanea(Integer idGrupoFaturamento,
			String anoMes, Integer idFirma) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String sql = "select"
				+" localidade.loca_id as idLocalidade," //0
				+" empresa.empr_id as idEmpresa," //1
				+" null as esferaPoder," //2
				+" null as sequencialInicial," //3
				+" null as sequencialFinal," //4
				+" count(distinct contaPreFat.cnta_id) as qtdeContas, " //5
				+" sum ( case when (imovel.imov_icimovelcondominio = 1) "
					+ " then 1 else 0 end ) as extratoMacro " //6
				+" from faturamento.mov_conta_prefaturada contaPreFat"
				+" inner join faturamento.conta conta on contaPreFat.cnta_id = conta.cnta_id"
				+" inner join faturamento.faturamento_grupo grupoFaturamento on contaPreFat.ftgr_id = grupoFaturamento.ftgr_id"
				+" inner join micromedicao.rota rota on contaPreFat.rota_id = rota.rota_id"
				+" left join cadastro.empresa empresa on empresa.empr_id = rota.empr_id"
				+" inner join cadastro.imovel imovel on conta.imov_id = imovel.imov_id"
				+" inner join cadastro.localidade localidade on imovel.loca_id = localidade.loca_id"
				+" inner join cadastro.cliente_imovel cliImov on cliImov.imov_id = imovel.imov_id and cliImov.crtp_id = :relacaoTipo and cliImov.clim_dtrelacaofim is null"
				+" left join cadastro.cliente cliente on cliente.clie_id = cliImov.clie_id"
				+" left join cadastro.cliente_tipo clienteTipo on cliente.cltp_id = clienteTipo.cltp_id"
				+ " where contaPreFat.ftgr_id = :idGrupoFaturamento"
				+ " and contaPreFat.mcpf_ammovimento = :anoMes"
				+ " and contaPreFat.mcpf_icemissaoconta = :icEmissaoConta";
				
			if (idFirma != null) {
				sql = sql + " and empresa.empr_id = :idEmpresa ";
			}
			sql = sql + " group by  " + " localidade.loca_id," + " empresa.empr_id,"
					+ " null"
					+ " order by idLocalidade, idEmpresa, esferaPoder";

			if (idFirma != null) {
				retorno = (Collection) session.createSQLQuery(sql).addScalar(
						"idLocalidade", Hibernate.INTEGER)// 0
						.addScalar("idEmpresa", Hibernate.INTEGER)// 1
						.addScalar("esferaPoder", Hibernate.INTEGER)// 2
						.addScalar("sequencialInicial", Hibernate.INTEGER)// 3
						.addScalar("sequencialFinal", Hibernate.INTEGER)// 4
						.addScalar("qtdeContas", Hibernate.INTEGER) // 5
						.addScalar("extratoMacro", Hibernate.INTEGER) // 6
						.setInteger("idGrupoFaturamento", idGrupoFaturamento)
						.setInteger("anoMes", new Integer(anoMes))
						.setInteger("idEmpresa", idFirma)
						.setInteger("relacaoTipo", ClienteRelacaoTipo.USUARIO)
						.setShort("icEmissaoConta", ConstantesSistema.SIM)
						.list();
			} else {
				retorno = (Collection) session.createSQLQuery(sql).addScalar(
						"idLocalidade", Hibernate.INTEGER)// 0
						.addScalar("idEmpresa", Hibernate.INTEGER)// 1
						.addScalar("esferaPoder", Hibernate.INTEGER)// 2
						.addScalar("sequencialInicial", Hibernate.INTEGER)// 3
						.addScalar("sequencialFinal", Hibernate.INTEGER)// 4
						.addScalar("qtdeContas", Hibernate.INTEGER) // 5
						.addScalar("extratoMacro", Hibernate.INTEGER) // 6
						.setInteger("idGrupoFaturamento", idGrupoFaturamento)
						.setInteger("anoMes", new Integer(anoMes))
						.setInteger("relacaoTipo", ClienteRelacaoTipo.USUARIO)
						.setShort("icEmissaoConta", ConstantesSistema.SIM)
						.list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1001] 
	 * 
	 * [SB0047] Exibir mensagem quitação de débitos
	 * 
	 * @author Hugo Amorim
	 * @created 21/06/2010
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMesagemExtrato(Integer anoMesReferencia,
			Integer idImovel)throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		String consulta;
		Integer retorno = null;

		try {
			
			consulta = "select anoReferencia from ExtratoQuitacao where "
					+" anoMesMensagemConta = :anoMesReferencia "
					+" and imovel = :idImovel ";

			retorno = (Integer) session.createQuery(consulta)
				.setInteger("anoMesReferencia", anoMesReferencia)
				.setInteger("idImovel", idImovel)
				.setMaxResults(1)
				.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 17/04/2008
	 * 
	 * @param idRota
	 * @param anoMesReferencia
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public void deletarArquivoTextoRoteiroEmpresa(Integer idArquivoTextoRoteiroEmpresa)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			String delete = "delete ArquivoTextoRoteiroEmpresa as arquivoTextoRoteiroEmpresa "
					+ "where arquivoTextoRoteiroEmpresa.id = :idArquivoTextoRoteiroEmpresa ";

			session.createQuery(delete).setInteger("idArquivoTextoRoteiroEmpresa",
					idArquivoTextoRoteiroEmpresa).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	/**
	 * [UC0014] Manter Imóvel
	 * 
	 * [FS0037] Verificar Imóvel em Processo de Faturamento 
	 * 
	 * @author Hugo Amorim
	 * @created 02/07/2010
	 * 
	 * @param idImovel
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public boolean verificarImovelEmProcessoDeFaturamento(
			Integer idImovel) throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		String consulta;
		MovimentoRoteiroEmpresa retornoConsulta = null;
		boolean retorno = false;

		try {
			
			consulta = consulta = "select mre from MovimentoRoteiroEmpresa mre " 
							+ "inner join mre.faturamentoGrupo fg "
							+ "where fg.anoMesReferencia = mre.anoMesMovimento "
							+ "and mre.imovel = :idImovel ";

			retornoConsulta = (MovimentoRoteiroEmpresa) session.createQuery(consulta)
				.setInteger("idImovel", idImovel)
				.setMaxResults(1)
				.uniqueResult();
			
			if(retornoConsulta!=null){
				retorno = true;
			}
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	 /**
	 * [UC1035] Efetivar Alterar Inscrição de Imóvel
	 * 
	 * @author Hugo Amorim
	 * @throws ControladorException
	 * @data 08/07/201
	 */
	public Collection pesquisarImoveisComInscricaoPedenteParaAtualizacao(
			Integer idLocalidade,int numeroIndice,int quantidadeRegistros) 
			throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;

		try {
			
			consulta = "SELECT " 
				/*+ " imovel,"
				+ " imovelInscricaoAlterada.localidadeAtual, "
				+ " imovelInscricaoAlterada.setorComercialAtual, "
				+ " imovelInscricaoAlterada.quadraAtual, "
				+ " imovelInscricaoAlterada.quadraFaceAtual, "
				+ " imovelInscricaoAlterada.loteAtual, "
				+ " imovelInscricaoAlterada.subLoteAtual "*/
				+ " imovelInscricaoAlterada "
				+ "FROM ImovelInscricaoAlterada imovelInscricaoAlterada"
				+ " INNER JOIN FETCH imovelInscricaoAlterada.imovel imovel"
				+ " LEFT JOIN FETCH imovelInscricaoAlterada.usuarioAlteracao usuario"
				+ " WHERE "
				+ " imovel.localidade.id = :idLocalidade"
				+ " AND imovelInscricaoAlterada.indicadorAtualizacaoExcluida = :indicadorAtualizacaoExcluida"
				+ " AND imovelInscricaoAlterada.indicadorAtualizado = :indicadorAtualizado"
				+ " AND imovelInscricaoAlterada.indicadorErroAlteracao is null "
				+ " AND imovelInscricaoAlterada.indicadorAutorizado = :indicadorAutorizado "
				+ "ORDER BY imovelInscricaoAlterada.id";

		retorno = session.createQuery(consulta)
				.setInteger("idLocalidade", idLocalidade)
				.setShort("indicadorAtualizacaoExcluida", ConstantesSistema.NAO)
				.setShort("indicadorAtualizado", ConstantesSistema.NAO)
				.setShort("indicadorAutorizado", ConstantesSistema.SIM)
				.setMaxResults(quantidadeRegistros)
				.list();
			
		} catch (HibernateException e) {
			e.printStackTrace();
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
  

	
	/**
	 * [UC1041] Gerar Taxa Percentual da Tarifa Mínima para Cortado 
	 *
	 * @author Raphael Rossiter
	 * @date 09/07/2010
	 *
	 * @param idRota
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImovelCortadoSemTarifaSocialPorRotaAlternativa(
			Integer idRota, int numeroPaginas, int quantidadeRegistros)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.ligacaoAguaSituacao.id, " // 0
					+ "imovel.ligacaoEsgotoSituacao.id, " // 1
					+ "consumoTarifa.id, " // 2
					+ "localidade.id, " // 3
					+ "quadra.id, " // 4
					+ "quadra.numeroQuadra, " // 5
					+ "imovel.lote, " // 6
					+ "setorComercial.codigo, " // 7
					+ "imovel.subLote, " // 8
					+ "setorComercial.id, " // 9
					+ "imovel.id, " // 10
					+ "imovel.ligacaoAguaSituacao.indicadorFaturamentoSituacao, " // 11
					+ "imovel.ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, " // 12
					+ "imovel.ligacaoAguaSituacao.consumoMinimoFaturamento, " // 13
					+ "imovel.ligacaoEsgotoSituacao.volumeMinimoFaturamento " // 14
					+ "from Imovel imovel "
					+ "inner join imovel.rotaAlternativa rotaAlternativa "
					+ "inner join imovel.consumoTarifa consumoTarifa "
					+ "inner join imovel.localidade localidade "
					+ "inner join imovel.setorComercial setorComercial "
					+ "inner join imovel.quadra quadra "
					+ " where rotaAlternativa.id = :rotaId "
					+ " and imovel.indicadorImovelCondominio <> 1 "
					+ " and imovel.indicadorExclusao <> 1 "
					+ " and imovel.ligacaoAguaSituacao.id = :CORTADO and consumoTarifa.id <> :TARIFASOCIAL ";

			retorno = session.createQuery(consulta)
					.setInteger("rotaId", idRota.intValue())
					.setInteger("CORTADO", LigacaoAguaSituacao.CORTADO)
					.setInteger("TARIFASOCIAL", ConsumoTarifa.CONSUMO_SOCIAL)
					.setMaxResults(quantidadeRegistros).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1041] Gerar Taxa Percentual da Tarifa Mínima para Cortado 
	 *
	 * @author Raphael Rossiter
	 * @date 09/07/2010
	 *
	 * @param idRota
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImovelCortadoSemTarifaSocialPorRota(Integer idRota,
			int numeroPaginas, int quantidadeRegistros)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.ligacaoAguaSituacao.id, " // 0
					+ "imovel.ligacaoEsgotoSituacao.id, " // 1
					+ "consumoTarifa.id, " // 2
					+ "localidade.id, " // 3
					+ "quadra.id, " // 4
					+ "quadra.numeroQuadra, " // 5
					+ "imovel.lote, " // 6
					+ "setorComercial.codigo, " // 7
					+ "imovel.subLote, " // 8
					+ "setorComercial.id, " // 9
					+ "imovel.id, " // 10
					+ "imovel.ligacaoAguaSituacao.indicadorFaturamentoSituacao, " // 11
					+ "imovel.ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, " // 12
					+ "imovel.ligacaoAguaSituacao.consumoMinimoFaturamento, " // 13
					+ "imovel.ligacaoEsgotoSituacao.volumeMinimoFaturamento " // 14
					+ "from Imovel imovel "
					+ "inner join imovel.consumoTarifa consumoTarifa "
					+ "inner join imovel.localidade localidade "
					+ "inner join imovel.setorComercial setorComercial "
					+ "inner join imovel.quadra quadra "
					+ "inner join quadra.rota rota "
					+ " WHERE rota.id = :rotaId "
					+ " and imovel.rotaAlternativa IS NULL AND imovel.indicadorImovelCondominio <> 1 "
					+ " and imovel.indicadorExclusao <> 1 "
					+ " and imovel.ligacaoAguaSituacao.id = :CORTADO and consumoTarifa.id <> :TARIFASOCIAL ";
			
			retorno = session.createQuery(consulta)
					.setInteger("rotaId", idRota.intValue())
					.setInteger("CORTADO", LigacaoAguaSituacao.CORTADO)
					.setInteger("TARIFASOCIAL", ConsumoTarifa.CONSUMO_SOCIAL)
					.setMaxResults(quantidadeRegistros).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	

	/**
	 * [UC1041] Gerar Taxa Percentual da Tarifa Mínima para Cortado
	 * 
	 * [FS0002] - Verificar existência de débito a cobrar de Tarifa de Cortado ativo para o imóvel
	 *
	 * @author Raphael Rossiter
	 * @date 12/07/2010
	 *
	 * @param idImovel
	 * @param anoMesFaturamento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarTarifaCortado(Integer idImovel, Integer anoMesFaturamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dbca.id " // 0
					+ " from DebitoACobrar dbca "
					+ " where dbca.imovel.id = :idImovel and dbca.debitoCreditoSituacaoAtual.id = :NORMAL "
					+ " and dbca.debitoTipo.id = :TARIFACORTADO and dbca.anoMesReferenciaDebito = :anoMesFaturamento ";

			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("NORMAL", DebitoCreditoSituacao.NORMAL)
					.setInteger("TARIFACORTADO", DebitoTipo.TARIFA_CORTADO)
					.setInteger("anoMesFaturamento", anoMesFaturamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
    
    /**
     * [UC1042] Verificar Farturamento dos Imóveis Cortados
     * 
     * Apaga todos os debitos a cobrar, debitos a cobrar categoria
     * e debito a cobrar geral, para o imovel/anoMes informado, com
     * debito tipo = DebitoTipo.TARIFA_CORTADO e debito tipo situacao
     * atual = DebitoCreditoSituacao.NORMAL, e diminue o valor da
     * conta.
     * 
     * @autor Bruno Barros
     * @date 13/07/2010
     *  
     * @param idImovel
     * @param anoMesReferencia
     * @throws ErroRepositorioException
     */
    public Collection atualizarValorDebitoDaConta( int idImovel, int anoMesReferencia ) throws ErroRepositorioException{
        Session session = HibernateUtil.getSession();

        Collection<Integer> colIdDebitoACobrar = null;
        
        try {
        		
        	String select = "select dc.id, dc.valorDebito from DebitoACobrar dc " +
                        "where dc.imovel.id = :idImovel and " +
                        "dc.anoMesReferenciaDebito = :anoMesFaturamento and " +
                        "dc.debitoTipo.id = :idDebitoTipo and " +
                        "dc.debitoCreditoSituacaoAtual.id = :idDCSA ";

            Collection<Object[]> retorno =
                session
                    .createQuery(select).
                    setParameter( "idImovel", idImovel ).
                    setParameter( "anoMesFaturamento", anoMesReferencia ).
                    setParameter( "idDebitoTipo", DebitoTipo.TARIFA_CORTADO ).
                    setParameter( "idDCSA", DebitoCreditoSituacao.NORMAL ).                    
                    list();
            
            // Diminuimos o valor do débito da conta
            if(retorno != null && !retorno.isEmpty()){
	            
            	colIdDebitoACobrar = new ArrayList(1);
	            
            	colIdDebitoACobrar.add( (Integer) ( (Object[]) retorno.toArray()[0] )[0] );
	            BigDecimal valorDebito = (BigDecimal) ( (Object[]) retorno.toArray()[0] )[1];
	            
	            String update =
	                "update " +
	                "  Conta c " +
	                "set " +
	                "  c.debitos = c.debitos - :valorDebito " +
	                "where " +
	                "  c.referencia = :anoMesFaturamento and " +
	                "  c.imovel.id = :idImovel ";                
	            
	            session
	                    .createQuery(update).
	                        setParameter( "valorDebito", valorDebito ).
	                        setParameter( "anoMesFaturamento", anoMesReferencia ).
	                        setParameter( "idImovel", idImovel ).
	                            executeUpdate();
            }
        } catch (HibernateException e) {
            // levanta a exceção para a próxima camada
            throw new ErroRepositorioException(e, "Erro no Hibernate");
        } finally {
            // fecha a sessão
            HibernateUtil.closeSession(session);
        }
        
        
        return colIdDebitoACobrar;
    }
    
    /**
	 * [UC1042] Verificar Farturamento dos Imóveis Cortados 
	 *
	 * @author Raphael Rossiter
	 * @date 13/07/2010
	 *
	 * @param idRota
	 * @param anoMesFaturamento
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImovelComDebitoTarifaCortadoPorRota(Integer idRota,
			Integer anoMesFaturamento, int numeroPaginas, int quantidadeRegistros) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.id, imovel.ligacaoAguaSituacao.id " // 0, 1
					+ "from Imovel imovel "
					+ "inner join imovel.quadra quadra "
					+ "inner join quadra.rota rota "
					+ " WHERE rota.id = :rotaId "
					+ " and imovel.rotaAlternativa IS NULL AND imovel.indicadorImovelCondominio <> 1 "
					+ " and imovel.indicadorExclusao <> 1 "
					+ " and imovel.id in (select dbca.imovel.id from DebitoACobrar dbca "
					+ " where imovel.id = dbca.imovel.id and dbca.anoMesReferenciaDebito = :anoMesFaturamento "
					+ " and dbca.debitoTipo.id = :TARIFACORTADO and dbca.debitoCreditoSituacaoAtual.id = :NORMAL) ";
			
			retorno = session.createQuery(consulta)
					.setInteger("rotaId", idRota.intValue())
					.setInteger("anoMesFaturamento", anoMesFaturamento)
					.setInteger("TARIFACORTADO", DebitoTipo.TARIFA_CORTADO)
					.setInteger("NORMAL", DebitoCreditoSituacao.NORMAL)
					.setMaxResults(quantidadeRegistros).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1042] Verificar Farturamento dos Imóveis Cortados 
	 *
	 * @author Raphael Rossiter
	 * @date 13/07/2010
	 *
	 * @param idRota
	 * @param anoMesFaturamento
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImovelComDebitoTarifaCortadoPorRotaAlternativa(Integer idRota,
			Integer anoMesFaturamento, int numeroPaginas, int quantidadeRegistros) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.id, imovel.ligacaoAguaSituacao.id " // 0, 1
					+ "from Imovel imovel "
					+ " WHERE imovel.rotaAlternativa.id = :rotaId "
					+ " and imovel.indicadorImovelCondominio <> 1 and imovel.indicadorExclusao <> 1 "
					+ " and imovel.id in (select dbca.imovel.id from DebitoACobrar dbca "
					+ " where imovel.id = dbca.imovel.id and dbca.anoMesReferenciaDebito = :anoMesFaturamento "
					+ " and dbca.debitoTipo.id = :TARIFACORTADO and dbca.debitoCreditoSituacaoAtual.id = :NORMAL) ";
			
			retorno = session.createQuery(consulta)
					.setInteger("rotaId", idRota.intValue())
					.setInteger("anoMesFaturamento", anoMesFaturamento)
					.setInteger("TARIFACORTADO", DebitoTipo.TARIFA_CORTADO)
					.setInteger("NORMAL", DebitoCreditoSituacao.NORMAL)
					.setMaxResults(quantidadeRegistros).setFirstResult(numeroPaginas).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 *
	 * @author Vivianne Sousa
	 * @date 21/07/2010
	 */
	public Conta pesquisarUltimaContaDoImovel(Integer idImovel) throws ErroRepositorioException {

		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta "
				+ "from Conta cnta "
				+ "inner join cnta.imovel imov "
				+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
				+ "where "
				+ "imov.id = :idImovel "
				+ "and dcst.id in(:normal, :incluida, :retificada) "
				//+ "and cnta.dataVencimentoConta < :dataVencimentoConta "
				+ "and not exists "
				+ "(select conta.id " 
				+ "from Pagamento pgmt "
				+ "inner join pgmt.contaGeral contaGeral "
				+ "inner join contaGeral.conta conta "
				+ "where conta.id = cnta.id) "
				+ " order by cnta.referencia desc ";

			retorno = (Conta) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("normal",DebitoCreditoSituacao.NORMAL)
					.setInteger("incluida",DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada",DebitoCreditoSituacao.RETIFICADA)
					//.setDate("dataVencimentoConta", new Date())
					.setMaxResults(1).uniqueResult();
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
     * [UC1042] Verificar Farturamento dos Imóveis Cortados
     * 
     * Apaga todos os debitos a cobrar, debitos a cobrar categoria
     * e debito a cobrar geral, para o imovel/anoMes informado, com
     * debito tipo = DebitoTipo.TARIFA_CORTADO e debito tipo situacao
     * atual = DebitoCreditoSituacao.NORMAL 
     * 
     * @autor Sávio Luiz
     * @date 13/07/2010
     *  
     * @param idImovel
     * @param anoMesReferencia
     * @throws ErroRepositorioException
     */
	public void deletarDebitosCobradosCategoriaImoveisCortados( int idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {
			Connection jdbcCon = session.connection();

			String delete = " delete from faturamento.debito_cobrado_categoria where dbcb_id in ";
		    
		    delete = delete
			+ " (select dbcb.dbcb_id "
			+ " from faturamento.debito_cobrado dbcb "
			+ " inner join faturamento.conta cnta on ( cnta.cnta_id = dbcb.cnta_id ) "
			+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and dbcb.dbtp_id = ?)";

		st = jdbcCon.prepareStatement(delete);
		st.setInt(1, idImovel);
		st.setInt(2, anoMesReferencia);
		st.setInt(3, DebitoTipo.TARIFA_CORTADO );

		st.executeUpdate();


		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}
	
	 /**
     * [UC1042] Verificar Farturamento dos Imóveis Cortados
     * 
     * Apaga todos os debitos a cobrar, debitos a cobrar categoria
     * e debito a cobrar geral, para o imovel/anoMes informado, com
     * debito tipo = DebitoTipo.TARIFA_CORTADO e debito tipo situacao
     * atual = DebitoCreditoSituacao.NORMAL 
     * 
     * @autor Sávio Luiz
     * @date 13/07/2010
     *  
     * @param idImovel
     * @param anoMesReferencia
     * @throws ErroRepositorioException
     */
	public void deletarDebitosCobradosImoveisCortados( int idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {
			Connection jdbcCon = session.connection();

			String delete = " delete from faturamento.debito_cobrado where dbcb_id in ";
		    
		    delete = delete
			+ " (select dbcb.dbcb_id "
			+ " from faturamento.debito_cobrado dbcb "
			+ " inner join faturamento.conta cnta on ( cnta.cnta_id = dbcb.cnta_id ) "
			+ " where cnta.imov_id = ? and cnta.cnta_amreferenciaconta = ? and dbcb.dbtp_id = ?)";

		st = jdbcCon.prepareStatement(delete);
		st.setInt(1, idImovel);
		st.setInt(2, anoMesReferencia);
		st.setInt(3, DebitoTipo.TARIFA_CORTADO );

		st.executeUpdate();


		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}
	
    /**
     * 
     * [UC1042] Verificar Farturamento dos Imóveis Cortados
     * 
     * Atualizar o indicador de faturamento do consumo historo
     * 
     * @param idConsumoHistorico
     * @param indicadorFaturamento
     * @throws ErroRepositorioException
     */	
	public void atualizarIndicadorFaturamentoConsumoHistorico( 
			Integer idConsumoHistorico, short indicadorFaturamento ) throws ErroRepositorioException {
		// obtém uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		String update;

		try {
			// constroi o hql
			update = "update gcom.micromedicao.consumo.ConsumoHistorico  "
					+ " set cshi_icfaturamento = :indicadorFaturamento "
					+ " where cshi_id = :id";

			// executa o hql
			session.createQuery(update)
					.setInteger("id", idConsumoHistorico)
					.setShort("indicadorFaturamento", indicadorFaturamento)
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
    
    /**
     *  [UC0820] - Atualizar Faturamento do Movimento Celular
     *  
     * Verifica se a quantidade de imóveis que chegaram 
     * é a esperada.
     * 
     * @author bruno
     * @date 16/08/2010
     * 
     * @param idRota - Id da rota ser verificada
     * @param anoMesFaturamento - Ano mes de faturamento a ser pesquisado
     * 
     * @return Integer
     *  
     */
    public Integer pesquisarDiferencaQuantidadeMovimentoContaPrefaturadaArquivoTextoRoteiroEmpresa(Integer idRota,
            Integer anoMesFaturamento ) throws ErroRepositorioException{
        Session session = HibernateUtil.getSession();
        
        Integer diferenca = null;
        
        try {

            String select = 
                "select " +
                "  count( distinct mcpf.imov_id ) - atre.txre_qtimovel as diferenca " +
                "from " +
                "  faturamento.mov_conta_prefaturada mcpf " +
                "  inner join micromedicao.arquivo_texto_rot_empr atre on ( atre.rota_id = mcpf.rota_id and atre.txre_amreferencia = mcpf.mcpf_ammovimento ) " +
                "where " +
                "  mcpf.rota_id = :idRota and mcpf.mcpf_ammovimento = :anoMesFaturamento " +
                /**
                 * 
                 * Pamela Gatinho - 12/08/2011
                 * Adiconando essa validacao para contabilizar somente
                 * imoveis que possuirem conta
                 */
               " and mcpf.cnta_id is not null " +
                "group by " +
                "  atre.txre_qtimovel ";
            
            diferenca = (Integer) session.createSQLQuery(select).addScalar("diferenca",
                    Hibernate.INTEGER).
                    setInteger( "idRota", idRota ).
                    setInteger( "anoMesFaturamento", anoMesFaturamento ).setMaxResults( 1 ).uniqueResult();

        } catch (HibernateException e) {
            // levanta a exceção para a próxima camada
            throw new ErroRepositorioException(e, "Erro no Hibernate");
        } finally {
            // fecha a sessão
            HibernateUtil.closeSession(session);
        }
        
        return diferenca;
    }

	/**
	 * 
	 * Pesquisa a conta historico digitada
	 * 
	 * @author Fernando Fontelles
	 * @date 06/08/2010
	 * 
	 * @param idImovel
	 * @param referenciaConta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarContaHistoricoDigitada(String idImovel,
			String referenciaConta) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = " SELECT conta.id, conta.anoMesReferenciaConta, conta.valorAgua, "
					+ " conta.valorEsgoto, conta.valorDebitos, conta.valorCreditos, conta.valorImposto, "
					+ " conta.dataVencimentoConta, conta.debitoCreditoSituacaoAtual.id, "
					+ " conta.debitoCreditoSituacaoAtual.descricaoAbreviada, conta.localidade.id "
					+ " FROM ContaHistorico conta " + " INNER JOIN conta.imovel imov "
					+ " INNER JOIN conta.debitoCreditoSituacaoAtual dcsa "
					+ " WHERE imov.id = :idImovel and "
					+ " conta.anoMesReferenciaConta = " + referenciaConta
					+ " and ( dcsa.id = " + DebitoCreditoSituacao.NORMAL
					+ " or dcsa.id = " + DebitoCreditoSituacao.RETIFICADA
					+ " or dcsa.id = " + DebitoCreditoSituacao.INCLUIDA + ")";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", new Integer(idImovel)).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * Obter o número de retificações da Conta
	 * 
	 * @author Hugo Leonardo
	 * @date 10/08/2010
	 * 
	 * @return void
	 * @throws ControladorException
	 */
	public Integer obterQuantidadeAlteracoesVencimentoConta(
			Integer idConta) throws ErroRepositorioException {
		
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cnta.numeroAlteracoesVencimento "
					+ "from Conta cnta "
					+ "where cnta.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta)
						.setInteger("idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1051] Gerar Relatório de Amostragem das Anormalidades Informadas
	 * 
	 * @author Hugo Leonardo
	 * @date 09/08/2010
	 * 
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarDadosRelatorioAnormalidadeConsumoPorAmostragem(
			Integer idGrupoFaturamento, Short codigoRota,
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorComercialInicial, Integer idSetorComercialFinal,
			Integer referencia, Integer idImovelPerfil,
			Integer numOcorConsecutivas, String indicadorOcorrenciasIguais,
			Integer mediaConsumoInicial, Integer mediaConsumoFinal,
			Collection<Integer> colecaoIdsAnormalidadeConsumo,
			Collection<Integer> colecaoIdsAnormalidadeLeitura,
			Collection<Integer> colecaoIdsAnormalidadeLeituraInformada,
			Integer tipoMedicao, Collection<Integer> colecaoIdsEmpresa,
			Integer numeroQuadraInicial, Integer numeroQuadraFinal,Integer idCategoria, Integer limite)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			
			consulta = "SELECT "
				+ " grupoFat.ftgr_id as idGrupoFaturamento," 
				+ " grupoFat.ftgr_dsfaturamentogrupo as descricaoGrupoFaturamento," 
				+ " greg.greg_id as idGerencia," 
				+ " greg.greg_nmabreviado as nomeGerencia," 
				+ " unidNeg.uneg_id as idUnidadeNegocio," 
				+ " unidNeg.uneg_nmabreviado as nomeUnidadeNegocio," 
				+ " elo.loca_id as idElo," 
				+ " elo.loca_nmlocalidade as nomeElo," 
				+ " loc.loca_id as idLocalidade," 
				+ " loc.loca_nmlocalidade as nomeLocalidade," 
				+ " mrem.imov_id as idImovel," 
				+ " clieUsuario.clie_nmcliente as nomeUsuario,"
				+ " mrem.last_id as sitLigAgua," 
				+ " mrem.lest_id as sitLigEsgoto," 
				+ " imov.imov_icdebitoconta as indicadorDebito, " 
				+ " mrem.mrem_nnconsumomedio as consumoMedio, "
				+ " consHist.cshi_nnconsumofaturadomes as consumoMes," 
				+ " consAnor.csan_dsabrvconsanormalidade as anormalidadeConsumo," 
				+ " mrem.ltan_id as anormalidadeLeitura," 
				+ " mrem.mrem_qteconomias as qtdeEconomias," 
				+ " mrem.medt_id as tipoMedicao,";

		if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			consulta = consulta
					+ " hidrCapAgua.hicp_dsabreviadahidrcapacidade as capHidAgua, "
					+ " hidrLocInstAgua.hili_dshidmtlocalinstalacao as locInstHidAgua, ";
		} else {
			consulta = consulta
					+ " hidrCapPoco.hicp_dsabreviadahidrcapacidade as capHidPoco, "
					+ " hidrLocInstPoco.hili_dshidmtlocalinstalacao as locInstHidPoco, ";
		}

		consulta = consulta
				+ " setor.stcm_id as idSetorComercial, "
				+ " setor.stcm_cdsetorcomercial as codigoSetorComercial,"
				+ " medHist.mdhi_nnleituraatualinformada as nnLeituraInformada,"
				+ " empr.empr_id as idEmpresa," 
				+ " empr.empr_nmempresa as nomeEmpresa, "
				
				+ " mrem.mrem_inscricaoimovel as inscricaoImovel,"
				+ " mrem_enderecoimovel as enderecoImovel"

				+ " FROM micromedicao.movimento_roteiro_empr     mrem"
				+ " INNER JOIN faturamento.faturamento_grupo        grupoFat 		on grupoFat.ftgr_id = mrem.ftgr_id"
				+ " INNER JOIN cadastro.gerencia_regional 			greg 			on greg.greg_id = mrem.greg_id"
				+ " INNER JOIN cadastro.localidade 					loc 			on loc.loca_id  = mrem.loca_id"
				+ " INNER JOIN cadastro.localidade 					elo 			on elo.loca_id = loc.loca_cdelo" 
				+ " INNER JOIN cadastro.unidade_negocio 			unidNeg 		on unidNeg.uneg_id = loc.uneg_id" 
				+ " INNER JOIN cadastro.imovel 					    imov 			on imov.imov_id = mrem.imov_id"
				+ " INNER JOIN cadastro.setor_comercial 			setor 			on setor.stcm_id = imov.stcm_id" 
				+ " INNER JOIN cadastro.cliente_imovel 				clieImovUsuario on clieImovUsuario.imov_id = imov.imov_id" 
				+ " and clieImovUsuario.crtp_id = " + ClienteRelacaoTipo.USUARIO 
				+ " and clieImovUsuario.clim_dtrelacaofim is null "
				+ " INNER JOIN cadastro.cliente 					clieUsuario 	on clieUsuario.clie_id = clieImovUsuario.clie_id" 
				+ " INNER JOIN cadastro.empresa 					empr 			on empr.empr_id = mrem.empr_id";

		
		if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			consulta = consulta
			+ " INNER JOIN micromedicao.consumo_historico 		consHist 		on consHist.imov_id = imov.imov_id" 
			+ " and consHist.lgti_id =  " + LigacaoTipo.LIGACAO_AGUA
			+ " and consHist.cshi_amfaturamento = :referencia "
			+ " INNER JOIN micromedicao.medicao_historico 		medHist 		on medHist.lagu_id = imov.imov_id" 
			+ " and medHist.medt_id =  " + MedicaoTipo.LIGACAO_AGUA
			+ " and medHist.mdhi_amleitura = :referencia ";

		} else {
			consulta = consulta
			+ " INNER JOIN micromedicao.consumo_historico 		consHist 		on consHist.imov_id = imov.imov_id" 
			+ " and consHist.lgti_id =  " + LigacaoTipo.LIGACAO_ESGOTO
			+ " and consHist.cshi_amfaturamento = :referencia "
			+ " INNER JOIN micromedicao.medicao_historico 		medHist 		on medHist.imov_id = imov.imov_id" 
			+ " and medHist.medt_id =  " + MedicaoTipo.POCO
			+ " and medHist.mdhi_amleitura = :referencia ";
		}

		consulta = consulta
			+ " LEFT OUTER JOIN micromedicao.consumo_anormalidade 	consAnor 		on consAnor.csan_id = consHist.csan_id"
			+ " LEFT OUTER JOIN micromedicao.leitura_anormalidade 	leitAnor 		on leitAnor.ltan_id = medhist.ltan_idleitanormfatmt"; 
 

		if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			consulta = consulta
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua 				lagu" 
					+ "     on lagu.lagu_id = imov.imov_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist 	hidrInstHistAgua" 
					+ " 	on hidrInstHistAgua.hidi_id = lagu.hidi_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro 						hidrAgua" 
					+ " 	on hidrAgua.hidr_id = hidrInstHistAgua.hidr_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_capacidade 				hidrCapAgua" 
					+ " 	on hidrCapAgua.hicp_id = hidrAgua.hicp_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_local_inst 		hidrLocInstAgua" 
					+ " 	on hidrLocInstAgua.hili_id = hidrInstHistAgua.hili_id ";
		} else {
			consulta = consulta
					+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist 	hidrInstHistPoco " 
					+ "		on hidrInstHistPoco.hidi_id = imov.hidi_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro 						hidrPoco" 
					+ " 	on hidrPoco.hidr_id = hidrInstHistPoco.hidr_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_capacidade 				hidrCapPoco " 
					+ "		on hidrCapPoco.hicp_id = hidrPoco.hicp_id "
					+ " LEFT OUTER JOIN micromedicao.hidrometro_local_inst 		hidrLocInstPoco " 
					+ "		on hidrLocInstPoco.hili_id = hidrInstHistPoco.hili_id ";
		}

		consulta = consulta
				+ criarCondicionaisRelatorioAnormalidadesConsumo(
						idGrupoFaturamento, codigoRota, idGerenciaRegional,
						idUnidadeNegocio, idLocalidadeInicial,
						idLocalidadeFinal, idSetorComercialInicial,
						idSetorComercialFinal, referencia, idImovelPerfil,
						numOcorConsecutivas, indicadorOcorrenciasIguais,
						mediaConsumoInicial, mediaConsumoFinal,
						colecaoIdsAnormalidadeConsumo,
						colecaoIdsAnormalidadeLeitura,
						colecaoIdsAnormalidadeLeituraInformada,
						colecaoIdsEmpresa, numeroQuadraInicial,  
						numeroQuadraFinal, idCategoria)+ " and ROWNUM <= :limite "; 
		
		consulta = consulta + " and ROWNUM <= :limite ";

		consulta = consulta
				+ " ORDER BY grupoFat.ftgr_id, greg.greg_id, unidNeg.uneg_id, elo.loca_id, "
				+ " loc.loca_id, setor.stcm_cdsetorcomercial, empr.empr_id, imov.imov_id ";
				

		SQLQuery query = session.createSQLQuery(consulta);

		if (colecaoIdsAnormalidadeConsumo != null
				&& colecaoIdsAnormalidadeConsumo.size() > 0) {
			query.setParameterList("colecaoIdsAnormalidadeConsumo",
					colecaoIdsAnormalidadeConsumo);
		}

		if (colecaoIdsAnormalidadeLeitura != null
				&& colecaoIdsAnormalidadeLeitura.size() > 0) {
			query.setParameterList("colecaoIdsAnormalidadeLeitura",
					colecaoIdsAnormalidadeLeitura);
		}

		if (colecaoIdsAnormalidadeLeituraInformada != null
				&& colecaoIdsAnormalidadeLeituraInformada.size() > 0) {
			query.setParameterList(
					"colecaoIdsAnormalidadeLeituraInformada",
					colecaoIdsAnormalidadeLeituraInformada);
		}

		if (colecaoIdsEmpresa != null && colecaoIdsEmpresa.size() > 0) {
			query.setParameterList("colecaoIdsEmpresa", colecaoIdsEmpresa);
		}

		if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			retorno = query.addScalar("idGrupoFaturamento",	Hibernate.INTEGER)
				.addScalar("descricaoGrupoFaturamento", Hibernate.STRING)
				.addScalar("idGerencia", Hibernate.INTEGER)
				.addScalar("nomeGerencia", Hibernate.STRING)
				.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
				.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
				.addScalar("idElo", Hibernate.INTEGER)
				.addScalar("nomeElo", Hibernate.STRING)
				.addScalar("idLocalidade", Hibernate.INTEGER)
				.addScalar("nomeLocalidade", Hibernate.STRING)
				.addScalar("idImovel", Hibernate.INTEGER)
				.addScalar("nomeUsuario", Hibernate.STRING)
				.addScalar("sitLigAgua", Hibernate.INTEGER)
				.addScalar("sitLigEsgoto", Hibernate.INTEGER)
				.addScalar("indicadorDebito", Hibernate.SHORT)
				.addScalar("consumoMedio", Hibernate.INTEGER)
				.addScalar("consumoMes", Hibernate.INTEGER)
				.addScalar("anormalidadeConsumo", Hibernate.STRING)
				.addScalar("anormalidadeLeitura", Hibernate.INTEGER)
				.addScalar("qtdeEconomias", Hibernate.SHORT)
				.addScalar("tipoMedicao", Hibernate.INTEGER)
				.addScalar("capHidAgua", Hibernate.STRING)
				.addScalar("locInstHidAgua", Hibernate.STRING)
				.addScalar("idSetorComercial", Hibernate.INTEGER)
				.addScalar("codigoSetorComercial", Hibernate.INTEGER)
				.addScalar("nnLeituraInformada", Hibernate.INTEGER)
				.addScalar("idEmpresa", Hibernate.INTEGER)
				.addScalar("nomeEmpresa", Hibernate.STRING)
				.addScalar("inscricaoImovel", Hibernate.STRING)
				.addScalar("enderecoImovel", Hibernate.STRING)
				.setInteger("referencia", referencia)
				.setInteger("limite", limite)
				.list();
		} else {
			retorno = query.addScalar("idGrupoFaturamento",	Hibernate.INTEGER)
				.addScalar("descricaoGrupoFaturamento", Hibernate.STRING)
				.addScalar("idGerencia", Hibernate.INTEGER)
				.addScalar("nomeGerencia", Hibernate.STRING)
				.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
				.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
				.addScalar("idElo", Hibernate.INTEGER)
				.addScalar("nomeElo", Hibernate.STRING)
				.addScalar("idLocalidade", Hibernate.INTEGER)
				.addScalar("nomeLocalidade", Hibernate.STRING)
				.addScalar("idImovel", Hibernate.INTEGER)
				.addScalar("nomeUsuario", Hibernate.STRING)
				.addScalar("sitLigAgua", Hibernate.INTEGER)
				.addScalar("sitLigEsgoto", Hibernate.INTEGER)
				.addScalar("indicadorDebito", Hibernate.SHORT)
				.addScalar("consumoMedio", Hibernate.INTEGER)
				.addScalar("consumoMes", Hibernate.INTEGER)
				.addScalar("anormalidadeConsumo", Hibernate.STRING)
				.addScalar("anormalidadeLeitura", Hibernate.INTEGER)
				.addScalar("qtdeEconomias", Hibernate.SHORT)
				.addScalar("tipoMedicao", Hibernate.INTEGER)
				.addScalar("capHidPoco", Hibernate.STRING)
				.addScalar("locInstHidPoco", Hibernate.STRING)
				.addScalar("idSetorComercial", Hibernate.INTEGER)
				.addScalar("codigoSetorComercial", Hibernate.INTEGER)
				.addScalar("nnLeituraInformada", Hibernate.INTEGER)
				.addScalar("idEmpresa", Hibernate.INTEGER)
				.addScalar("nomeEmpresa", Hibernate.STRING)
				.addScalar("inscricaoImovel", Hibernate.STRING)
				.addScalar("enderecoImovel", Hibernate.STRING)
				.setInteger("referencia", referencia)
				.setInteger("limite", limite)
				.list();
		}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1051] Gerar Relatório de Amostragem das Anormalidades Informadas
	 * 
	 * @author Hugo Leonardo
	 * @date 09/08/2010
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarTotalDadosRelatorioAnormalidadeConsumoPorAmostragem(
			Integer idGrupoFaturamento, Short codigoRota,
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorComercialInicial, Integer idSetorComercialFinal,
			Integer referencia, Integer idImovelPerfil,
			Integer numOcorConsecutivas, String indicadorOcorrenciasIguais,
			Integer mediaConsumoInicial, Integer mediaConsumoFinal,
			Collection<Integer> colecaoIdsAnormalidadeConsumo,
			Collection<Integer> colecaoIdsAnormalidadeLeitura,
			Collection<Integer> colecaoIdsAnormalidadeLeituraInformada,
			Integer tipoMedicao, Collection<Integer> colecaoIdsEmpresa,
			Integer numeroQuadraInicial, Integer numeroQuadraFinal,Integer idCategoria)
			throws ErroRepositorioException {
		
		Integer retorno = 0;
		
		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {
			
			consulta = "SELECT count(mrem.mrem_id) as contador"
					+ " FROM micromedicao.movimento_roteiro_empr     mrem"
					+ " INNER JOIN faturamento.faturamento_grupo        grupoFat 		on grupoFat.ftgr_id = mrem.ftgr_id"
					+ " INNER JOIN cadastro.gerencia_regional 			greg 			on greg.greg_id = mrem.greg_id"
					+ " INNER JOIN cadastro.localidade 					loc 			on loc.loca_id  = mrem.loca_id"
					+ " INNER JOIN cadastro.localidade 					elo 			on elo.loca_id = loc.loca_cdelo" 
					+ " INNER JOIN cadastro.unidade_negocio 			unidNeg 		on unidNeg.uneg_id = loc.uneg_id" 
					+ " INNER JOIN cadastro.imovel 					    imov 			on imov.imov_id = mrem.imov_id"
					+ " INNER JOIN cadastro.setor_comercial 			setor 			on setor.stcm_id = imov.stcm_id" 
					+ " INNER JOIN cadastro.cliente_imovel 				clieImovUsuario on clieImovUsuario.imov_id = imov.imov_id" 
					+ " and clieImovUsuario.crtp_id = " + ClienteRelacaoTipo.USUARIO.toString() 
					+ " and clieImovUsuario.clim_dtrelacaofim is null "
					+ " INNER JOIN cadastro.cliente 					clieUsuario 	on clieUsuario.clie_id = clieImovUsuario.clie_id" 
					+ " INNER JOIN cadastro.empresa 					empr 			on empr.empr_id = mrem.empr_id";
	
			
			if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
				consulta = consulta
				+ " INNER JOIN micromedicao.consumo_historico 		consHist 		on consHist.imov_id = imov.imov_id" 
				+ " and consHist.lgti_id =  " + LigacaoTipo.LIGACAO_AGUA.toString()
				+ " and consHist.cshi_amfaturamento = :referencia "
				+ " INNER JOIN micromedicao.medicao_historico 		medHist 		on medHist.lagu_id = imov.imov_id" 
				+ " and medHist.medt_id =  " + MedicaoTipo.LIGACAO_AGUA.toString()
				+ " and medHist.mdhi_amleitura = :referencia ";
	
			} else {
				consulta = consulta
				+ " INNER JOIN micromedicao.consumo_historico 		consHist 		on consHist.imov_id = imov.imov_id" 
				+ " and consHist.lgti_id =  " + LigacaoTipo.LIGACAO_ESGOTO.toString()
				+ " and consHist.cshi_amfaturamento = :referencia "
				+ " INNER JOIN micromedicao.medicao_historico 		medHist 		on medHist.imov_id = imov.imov_id" 
				+ " and medHist.medt_id =  " + MedicaoTipo.POCO.toString()
				+ " and medHist.mdhi_amleitura = :referencia ";
			}
	
			consulta = consulta
				+ " LEFT OUTER JOIN micromedicao.consumo_anormalidade 	consAnor 		on consAnor.csan_id = consHist.csan_id"
				+ " LEFT OUTER JOIN micromedicao.leitura_anormalidade 	leitAnor 		on leitAnor.ltan_id = medhist.ltan_idleitanormfatmt"; 
	 
	
			if (tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
				consulta = consulta
						+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua 				lagu" 
						+ "     on lagu.lagu_id = imov.imov_id "
						+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist 	hidrInstHistAgua" 
						+ " 	on hidrInstHistAgua.hidi_id = lagu.hidi_id "
						+ " LEFT OUTER JOIN micromedicao.hidrometro 						hidrAgua" 
						+ " 	on hidrAgua.hidr_id = hidrInstHistAgua.hidr_id "
						+ " LEFT OUTER JOIN micromedicao.hidrometro_capacidade 				hidrCapAgua" 
						+ " 	on hidrCapAgua.hicp_id = hidrAgua.hicp_id "
						+ " LEFT OUTER JOIN micromedicao.hidrometro_local_inst 		hidrLocInstAgua" 
						+ " 	on hidrLocInstAgua.hili_id = hidrInstHistAgua.hili_id ";
			} else {
				consulta = consulta
						+ " LEFT OUTER JOIN micromedicao.hidrometro_inst_hist 	hidrInstHistPoco " 
						+ "		on hidrInstHistPoco.hidi_id = imov.hidi_id "
						+ " LEFT OUTER JOIN micromedicao.hidrometro 						hidrPoco" 
						+ " 	on hidrPoco.hidr_id = hidrInstHistPoco.hidr_id "
						+ " LEFT OUTER JOIN micromedicao.hidrometro_capacidade 				hidrCapPoco " 
						+ "		on hidrCapPoco.hicp_id = hidrPoco.hicp_id "
						+ " LEFT OUTER JOIN micromedicao.hidrometro_local_inst 		hidrLocInstPoco " 
						+ "		on hidrLocInstPoco.hili_id = hidrInstHistPoco.hili_id ";
			}
	
			consulta = consulta
					+ criarCondicionaisRelatorioAnormalidadesConsumo(
							idGrupoFaturamento, codigoRota, idGerenciaRegional,
							idUnidadeNegocio, idLocalidadeInicial,
							idLocalidadeFinal, idSetorComercialInicial,
							idSetorComercialFinal, referencia, idImovelPerfil,
							numOcorConsecutivas, indicadorOcorrenciasIguais,
							mediaConsumoInicial, mediaConsumoFinal,
							colecaoIdsAnormalidadeConsumo,
							colecaoIdsAnormalidadeLeitura,
							colecaoIdsAnormalidadeLeituraInformada,
							colecaoIdsEmpresa, numeroQuadraInicial,  
							numeroQuadraFinal, idCategoria);
			
			SQLQuery query = session.createSQLQuery(consulta);
	
			if (colecaoIdsAnormalidadeConsumo != null
					&& colecaoIdsAnormalidadeConsumo.size() > 0) {
				query.setParameterList("colecaoIdsAnormalidadeConsumo",
						colecaoIdsAnormalidadeConsumo);
			}
	
			if (colecaoIdsAnormalidadeLeitura != null
					&& colecaoIdsAnormalidadeLeitura.size() > 0) {
				query.setParameterList("colecaoIdsAnormalidadeLeitura",
						colecaoIdsAnormalidadeLeitura);
			}
	
			if (colecaoIdsAnormalidadeLeituraInformada != null
					&& colecaoIdsAnormalidadeLeituraInformada.size() > 0) {
				query.setParameterList(
						"colecaoIdsAnormalidadeLeituraInformada",
						colecaoIdsAnormalidadeLeituraInformada);
			}
	
			if (colecaoIdsEmpresa != null && colecaoIdsEmpresa.size() > 0) {
				query.setParameterList("colecaoIdsEmpresa", colecaoIdsEmpresa);
			}
			
			retorno = (Integer) query.addScalar("contador", Hibernate.INTEGER)
								.setInteger("referencia", referencia)
								.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;	
	}
	/**
	 * Metodo que retornar o grupo de faturamento a partir do id do Imovel
	 * 
	 * @author Rômulo Aurélio
	 * @date 24/08/2010
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public FaturamentoGrupo recuperaGrupoFaturamentoDoImovel(Integer idImovel)throws ErroRepositorioException {
		FaturamentoGrupo retorno = null;
		
		
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select faturamentoGrupo " 
					+" from FaturamentoGrupo faturamentoGrupo, Imovel imov, Rota rota, Quadra qdra "
					+" where imov.id = :idImovel " 
					+" and qdra.id = imov.quadra.id and qdra.rota.id = rota.id and rota.faturamentoGrupo.id = faturamentoGrupo.id "; 

			retorno = (FaturamentoGrupo)session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 *
	 * @author Vivianne Sousa
	 * @date 18/08/2010
	 *
	 * @param idOrdemServico
	 * @throws ErroRepositorioException
	 */
	public Collection verificarExistenciaAutosInfracaoPorOS(
			Integer idOrdemServico) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select auif.id "
					+ " from AutosInfracao auif "
					+ " where auif.ordemServico.id = :idOrdemServico ";
			
			retorno = session.createQuery(consulta)
					.setInteger("idOrdemServico", idOrdemServico)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 *
	 * @author Vivianne Sousa
	 * @date 18/08/2010
	 *
	 * @param idOrdemServico
	 * @throws ErroRepositorioException
	 */
	public AutosInfracao pesquisarAutosInfracaoPorOS(
			Integer idOrdemServico) throws ErroRepositorioException {

		AutosInfracao retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select auif "
					+ " from AutosInfracao auif "
					+ " where auif.ordemServico.id = :idOrdemServico ";
			
			retorno = (AutosInfracao)session.createQuery(consulta)
					.setInteger("idOrdemServico", idOrdemServico)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 *
	 * @author Vivianne Sousa
	 * @date 24/08/2010
	 *
	 * @param idAutoInfracao
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaAutosInfracaoDebitoACobrar(
			Integer idAutoInfracao) throws ErroRepositorioException {

		Collection autos = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT aidc.id "
					+ " FROM gcom.faturamento.autoinfracao.AutosInfracaoDebitoACobrar aidc"
					+ " WHERE aidc.autosInfracao = :idAutoInfracao";

			autos = session.createQuery(consulta)
				.setInteger("idAutoInfracao",idAutoInfracao)
				.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return autos;
	}
	
	/**
	 * 
	 * Pesquisa os imóveis que ja foram enviados para uma
	 * determinada rota em impressão simultanea
	 * 
	 * @autor Bruno Barros.
	 * @date 24/08/2010 
	 * 
	 * @param idRota - Id da rota a ser pesquisada
	 * 
	 * @return Collection<Integer> - Matriculas dos imóveis que ja foram processados
	 */
	public Collection<Integer> pesquisarImoveisJaProcessadosBufferImpressaoSimultanea( Integer idRota )
		throws ErroRepositorioException{
		
		Collection<Integer> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			
			Integer anoMesFaturamento = this.retornaAnoMesFaturamentoGrupoDaRota( idRota );			

			consulta = 
				"select " +
				"  mcpf.imovel.id " +
				"from " +
				"  MovimentoContaPrefaturada mcpf " +
				"where " +
				"  mcpf.rota.id = :idRota and mcpf.anoMesReferenciaPreFaturamento = :anoMesFaturamento";

			retorno = (Collection<Integer>)session
					.createQuery(consulta)
					.setInteger("idRota", idRota )
					.setInteger("anoMesFaturamento", anoMesFaturamento )
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;		
	}
	
	/**
	 * [UC0014] Manter Imóvel
	 * 
	 * Verifica se o mesmo cliente está associado ao Imóvel em ClienteImovel.
	 * 
	 * Autor: Hugo Leonardo
	 * Data: 03/09/2010
	 */
	public int pesquisarExisteClienteAssociadoAoImovelEmClienteImovel(Integer idImovel, Integer idCliente) 
		throws ErroRepositorioException {

		int retorno = 0;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = " SELECT COUNT(clienteImovel.id) as count "
				+ " from ClienteImovel clienteImovel "
				+ " inner join clienteImovel.imovel imovel "
				+ " inner join clienteImovel.cliente cliente "
				+ " WHERE cliente.id = :idCliente "
				+ " AND imovel.id = :idImovel "
				+ " AND clienteImovel.dataFimRelacao is null ";

			retorno = (Integer) session.createQuery(consulta)
				.setInteger("idCliente", idCliente)
				.setInteger("idImovel", idImovel)
				.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 *
	 * @Author Hugo Amorim
	 * @Date 29/07/2010
	 * 
	 * @param idFaturamentoGrupo
	 *            Id do Faturamento Grupo
	 * @param anoMesReferencia
	 *            Ano Mes Referencia
	 * @exception ErroRepositorioException
	 *                Erro de Hibernate
	 */
	public void deletarResumoFaturamentoSimulacaoDetalheCredito(Integer idFaturamentoGrupo,
			Integer anoMesReferencia, Integer idRota)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		
		PreparedStatement st = null;
	
		try {
			
			Connection jdbcCon = session.connection();
		
			String delete = "DELETE "
				+" FROM faturamento.res_fatu_simulacao_cred resFaturamentoSimulacaoCred"
				+" WHERE EXISTS (SELECT * FROM faturamento.resumo_fatur_simulacao resumoFaturamentoSimulacao"  
				+" WHERE resumoFaturamentoSimulacao.rfts_id = resFaturamentoSimulacaoCred.rfts_id" 
				+" AND resumoFaturamentoSimulacao.rfts_amreferencia = ? "
				+" AND resumoFaturamentoSimulacao.ftgr_id = ? "
				+" AND resumoFaturamentoSimulacao.rota_id = ? )";

			st = jdbcCon.prepareStatement(delete);
			
			st.setInt(1,anoMesReferencia.intValue());
			st.setInt(2,idFaturamentoGrupo.intValue());
			st.setInt(3,idRota.intValue());
			
			st.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 *
	 * @Author Hugo Amorim
	 * @Date 29/07/2010
	 * 
	 * @param idFaturamentoGrupo
	 *            Id do Faturamento Grupo
	 * @param anoMesReferencia
	 *            Ano Mes Referencia
	 * @exception ErroRepositorioException
	 *                Erro de Hibernate
	 */
	public void deletarResumoFaturamentoSimulacaoDetalheDebito(Integer idFaturamentoGrupo,
			Integer anoMesReferencia, Integer idRota)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		
		try {
			
			Connection jdbcCon = session.connection();
			
			String delete = "DELETE "
					+" FROM faturamento.res_fatu_simulacao_debi resFaturamentoSimulacaoDbt"
					+" WHERE EXISTS (SELECT * FROM faturamento.resumo_fatur_simulacao resumoFaturamentoSimulacao"  
					+" WHERE resumoFaturamentoSimulacao.rfts_id = resFaturamentoSimulacaoDbt.rfts_id" 
					+" AND resumoFaturamentoSimulacao.rfts_amreferencia = ? "
					+" AND resumoFaturamentoSimulacao.ftgr_id = ? "
					+" AND resumoFaturamentoSimulacao.rota_id = ? )";

				st = jdbcCon.prepareStatement(delete);
				
				st.setInt(1,anoMesReferencia.intValue());
				st.setInt(2,idFaturamentoGrupo.intValue());
				st.setInt(3,idRota.intValue());
				
				st.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 *
	 * @Author Hugo Amorim
	 * @Date 02/08/2010
	 * 
	 */
	public Collection<ResumoFaturamentoSimulacaoDebito> pesquisarResumoFaturamentoDebitoSimulacao(
			ResumoFaturamentoSimulacao resumoFaturamentoSimulacao)
			throws ErroRepositorioException {

		Collection<ResumoFaturamentoSimulacaoDebito> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select resumoFaturamentoSimulacaoDebito " 
					+" from ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebito "
					+" inner join fetch resumoFaturamentoSimulacaoDebito.comp_id.debitoTipo deb"
					+" where  resumoFaturamentoSimulacaoDebito.comp_id.resumoFaturamentoSimulacao = " 
					+" :resumoFaturamentoSimulacao";

			retorno = session
					.createQuery(consulta)
					.setInteger("resumoFaturamentoSimulacao", resumoFaturamentoSimulacao.getId())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 *
	 * @Author Hugo Amorim
	 * @Date 02/08/2010
	 * 
	 */
	public Collection<ResumoFaturamentoSimulacaoCredito> pesquisarResumoFaturamentoCreditoSimulacao(
			ResumoFaturamentoSimulacao resumoFaturamentoSimulacao)
			throws ErroRepositorioException {

		Collection<ResumoFaturamentoSimulacaoCredito> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select resumoFaturamentoSimulacaoCredito " 
					+" from ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCredito "
					+" inner join fetch resumoFaturamentoSimulacaoCredito.comp_id.creditoTipo cre"
					+" where resumoFaturamentoSimulacaoCredito.comp_id.resumoFaturamentoSimulacao = " 
					+" :resumoFaturamentoSimulacao";

			retorno = session
					.createQuery(consulta)
					.setInteger("resumoFaturamentoSimulacao", resumoFaturamentoSimulacao.getId())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC1010] Emitir 2ª via de declaração anual de quitação de débitos
	 *
	 * @Author Daniel Alves
	 * @Date 14/09/2010
	 * 
	 */
	public Collection pesquisarAnoImovelEmissao2ViaDeclaracaoAnualQuitacaoDebitos(
			String idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT extratoQuitacao.id, extratoQuitacao.anoReferencia " 
					+" FROM ExtratoQuitacao extratoQuitacao "
					+" WHERE extratoQuitacao.imovel.id = :idImovel ";

			retorno = session
					.createQuery(consulta)
					.setString("idImovel", idImovel)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC1073]  Religar Imóveis Cortados com Consumo Real
	 * 
	 * Data: 13/09/2010
	 * @author Vivianne Sousa
	 */
	public Collection pesquisarImoveisCortados(Integer situacaoAgua, Date dataCorte, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imov.id "
					+ "from Imovel imov "
					+ "inner join imov.ligacaoAguaSituacao last "
					+ "inner join imov.ligacaoAgua lagu "
					+ "inner join imov.imovelPerfil iper "
					+ "where last.id = :situacaoAgua  "
					+ "and lagu.dataCorte <= :dataCorte  " 
					+ "and iper.id <> :tarifaSocial " 
					+ "and imov.localidade.id = :idLocalidade ";

			retorno = session.createQuery(consulta)
				.setInteger("situacaoAgua",	situacaoAgua)
				.setDate("dataCorte", dataCorte)
				.setInteger("tarifaSocial", ImovelPerfil.TARIFA_SOCIAL)
				.setInteger("idLocalidade", idLocalidade)
				.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1073]  Religar Imóveis Cortados com Consumo Real
	 * 
	 * Data: 13/09/2010
	 * @author Vivianne Sousa
	 */
	public String pesquisarImoveisConsumoFaturadoReal(
			Integer idImovel,
			Integer anoMesReferencia, 
			Integer consumoTipo,
			Integer ligacaoTipo) throws ErroRepositorioException {

		String idConsumoHistorico = null;
		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ch.id " 
					+ "from ConsumoHistorico ch "
					+ "inner join ch.imovel imov "
					+ "inner join ch.consumoTipo ct "
					+ "inner join ch.ligacaoTipo lt "
					+ "where " 
					+ " ct.id = :consumoTipo " 
					+ " and lt.id = :ligacaoTipo "
					+ " and ch.referenciaFaturamento = :anoMesReferencia "
					+ " and imov.id = :idImovel "
					+ " and ch.numeroConsumoFaturadoMes > :zero ";

			retorno = session.createQuery(consulta)
				.setInteger("consumoTipo",consumoTipo)
				.setInteger("ligacaoTipo",ligacaoTipo)
				.setInteger("anoMesReferencia",anoMesReferencia)
				.setInteger("idImovel", idImovel)
				.setInteger("zero", new Integer(0))
				.setMaxResults(1)
				.uniqueResult();

			if (retorno != null) {

				idConsumoHistorico = ((Integer) retorno).toString();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idConsumoHistorico;
	}
	
	/**
	 * [UC1073]  Religar Imóveis Cortados com Consumo Real
	 * 
	 * Data: 15/09/2010
	 * @author Vivianne Sousa
	 */
	public void religarImovelCortado(Integer idImovel, Integer idLigacaoAguaSituacao,
			Date dataReligacaoAgua) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {

			String atualizarImovel = " update gcom.cadastro.imovel.Imovel "
					+ " set last_id = :idLigacaoAguaSituacao " 
					+ " where imov_id = :idImovel";

			session.createQuery(atualizarImovel)
			.setInteger("idLigacaoAguaSituacao",idLigacaoAguaSituacao)
			.setInteger("idImovel", idImovel)
			.executeUpdate();

			String atualizarLigacaoAgua = " update gcom.atendimentopublico.ligacaoagua.LigacaoAgua "
					+ " set lagu_dtreligacaoagua = :dataReligacaoAgua"
					+ " where hidi_id = :idImovel";

			session.createQuery(atualizarLigacaoAgua)
			.setDate("dataReligacaoAgua", dataReligacaoAgua)
			.setInteger("idImovel", idImovel)
			.executeUpdate();
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0352] Emitir Contas e Cartas
	 * [SB0005] - Obter Dados da Medição da Conta 
	 * 
	 * @author Vivianne Sousa
	 * @date 20/09/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public  Object[] obterLeituraAnteriorEAtualConta(
			Integer idConta) throws ErroRepositorioException {

		 Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cnta.numeroLeituraAnterior," 
					+ " cnta.numeroLeituraAtual "
					+ " FROM Conta cnta "
					+ " WHERE cnta.id = :idConta ";

			retorno = ( Object[]) session.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	
	/**
	 * [UC0352] Emitir Contas e Cartas
	 * [SB0005] - Obter Dados da Medição da Conta 
	 * 
	 * @author Vivianne Sousa
	 * @date 20/09/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public  Object[] obterLeituraAnteriorEAtualContaHistorico(
			Integer idConta) throws ErroRepositorioException {

		 Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cnta.numeroLeituraAnterior," 
					+ " cnta.numeroLeituraAtual "
					+ " FROM ContaHistorico cnta "
					+ " WHERE cnta.id = :idConta ";

			retorno = ( Object[]) session.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0994] Envio de Email da conta para o Cliente
	 * 
	 * @author Fernando Fontelles
	 * @date 27/09/2010
	 * 
	 * Retorna as contas prefaturadas para enviar email com a conta.
	 * 
	 */
	
	public Collection pesquisarContasPrefaturadasParaEnvioEmail(SistemaParametro sistemaParametro, Integer idLocalidade)
		throws ErroRepositorioException{
		
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "SELECT distinct i.imov_id as imovel, cli.clie_dsemail as email "
					 + "FROM faturamento.mov_conta_prefaturada ci "
				     +   "INNER JOIN faturamento.conta c ON c.cnta_id = ci.cnta_id "
				     +   "INNER JOIN cadastro.cliente_conta cc ON cc.cnta_id = ci.cnta_id "
				     +   "INNER JOIN cadastro.cliente cli ON cli.clie_id = cc.clie_id "
				     +   "INNER JOIN cadastro.imovel i ON i.imov_id = ci.imov_id "
				     + "WHERE ci.mcpf_ammovimento = :anoMes "  
				     +   "AND i.icte_id IN (:indicadorEnvioEmail, :indicadorEnvioImovelEmail) " 
				     +   "AND cli.clie_dsemail IS NOT NULL "
				     +   "AND cc.clct_icnomeconta = :indicadorNomeConta "
				     +   "AND i.loca_id = :idLocalidade "
				     +   "AND c.cnta_dtenvioemailconta IS NULL "
				     +	 "AND (c.cnta_dtemissao + :qtdDiasEnvioEmailConta) <= CURRENT_DATE ";
			
			retorno = (Collection) session
									.createSQLQuery(consulta)
									.addScalar("imovel",Hibernate.INTEGER)
									.addScalar("email",Hibernate.STRING)		
									.setInteger("anoMes", sistemaParametro.getAnoMesFaturamento())
									.setInteger("indicadorEnvioEmail",ImovelContaEnvio.ENVIAR_PARA_EMAIL)
									.setInteger("indicadorEnvioImovelEmail",ImovelContaEnvio.ENVIAR_PARA_IMOVEL_E_PARA_EMAIL)
									.setShort("indicadorNomeConta",ConstantesSistema.SIM)
									.setInteger("idLocalidade", idLocalidade)
									.setInteger("qtdDiasEnvioEmailConta", sistemaParametro.getQtdeDiasEnvioEmailConta())
									.list();
						
		}catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
		
	}
	
	/**
	 * Método que retorna as contas para impressao
	 * 
	 * Pesquisar Contas Emitir(Ficha de Compensação)Caern
	 * 
	 * @author Vivianne Sousa
	 * @date 13/10/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasFichaCompensacaoEmitirCAERN(Integer idTipoConta,
			Integer idEmpresa, Integer anoMesReferencia, Integer idFaturamentoGrupo,
			BigDecimal valorContaFichaComp) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel "// 32
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "where "
					+ "contaImpressao.cnti_amreferenciaconta = :referencia AND "
					+ "cnt.cnta_tmultimaalteracao > :data AND "
					+ "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND "
					// + "loc.loca_id = 312 AND cnt.cnta_cdsetorcomercial = 1
					// AND rota.rota_cdrota =3 AND " Alterado em 16/01/09 -
					// Emitir contas Extraviadas
					+ "cliCnt.clct_icnomeconta = :indicadorNomeConta AND imovel.icte_id <> 9 "
					+ "AND contaImpressao.cnti_vlconta > :valorLimite "
					
//					+ "AND imovel.imov_id in (6546470,7696647)"
					
					+ "order by  cnt.cnta_amreferenciaconta, loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota, imovel.imov_nnsequencialrota";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idConta",Hibernate.INTEGER)
					.addScalar("nomeCliente",Hibernate.STRING)
					.addScalar("dataVencimentoConta",Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER)
					.addScalar("digitoVerificador", Hibernate.SHORT)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("lote", Hibernate.SHORT)
					.addScalar("sublote",Hibernate.SHORT)
					.addScalar("consumoAgua",Hibernate.INTEGER)
					.addScalar("consumoEsgoto",Hibernate.INTEGER)
					.addScalar("valorAgua",Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgoto",Hibernate.BIG_DECIMAL)
					.addScalar("debitos",Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditos",	Hibernate.BIG_DECIMAL)
					.addScalar("valorImpostos",	Hibernate.BIG_DECIMAL)
					.addScalar("dataValidade",	Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerencia", Hibernate.STRING)
					.addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER)
					.addScalar("idSetorComercial", Hibernate.INTEGER)
					.addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("descricaoLocalidade", Hibernate.STRING)
					.addScalar("descricaoLigAguaSit", Hibernate.STRING)
					.addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING)
					.setDate("data",Util.criarData(16, 05, 2007))
					.setInteger("indicadorNomeConta", ConstantesSistema.INDICADOR_USO_ATIVO)
					.setInteger("referencia", anoMesReferencia)
					.setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo)
					.setBigDecimal("valorLimite",valorContaFichaComp)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Método que retorna as contas para impressao
	 * 
	 * Pesquisar Contas Emitir(Ficha de Compensação)Caern
	 * 
	 * @author Vivianne Sousa
	 * @date 13/10/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasFichaCompensacaoEmitirOrgaoPublicoCAERN(
			Integer idTipoConta, Integer idEmpresa,Integer anoMesReferencia,
			Integer idFaturamentoGrupo,BigDecimal valorContaFichaComp)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel "// 32
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "where "
					+ "contaImpressao.cnti_amreferenciaconta = :referencia AND "
					+ "contaImpressao.empr_id = :idEmpresa AND "
					+ "cliCnt.clct_icnomeconta = :indicadorNomeConta AND imovel.icte_id = 9 "
					+ "AND contaImpressao.cnti_vlconta > :valorLimite "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.clie_idresponsavel, loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota, imovel.imov_nnsequencialrota";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).setInteger(
							"idEmpresa", idEmpresa).setInteger("indicadorNomeConta",
							ConstantesSistema.INDICADOR_USO_ATIVO).setInteger(
							"referencia", anoMesReferencia)
								.setBigDecimal("valorLimite",valorContaFichaComp)
								.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	
	/**
	 * 
	 * [UC1083] Prescrever Débitos de Imóveis Públicos Manual
	 * 
	 * @author Hugo Leonardo
	 * @date 18/10/2010
	 * 
	 * @param prescreverDebitosImovelHelper
	 * @throws ErroRepositorioException
	 */
	public void prescreverDebitosImoveisPublicosManual(PrescreverDebitosImovelHelper helper) 
		throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();
		
		PreparedStatement st = null;
		
		try {

			// declara o tipo de conexao
			Connection jdbcCon = session.connection();
			
			// Atualiza Contas
			update =" update faturamento.conta c " 
				  + " set 	dcst_idatual = 8, "
				  + "       usur_id = " + helper.getUsuarioLogado().getId().intValue() + ", "
				  + " 		dcst_idanterior = NULL, "
				  + " 		cnta_dtcancelamento =  " + Util.obterSQLDataAtual() + " , "
				  + " 		cmcn_id = 99, "
				  + " 		cnta_amreferenciacontabil = " + helper.getAnoMesReferencia() + ", "	
				  + "       cnta_tmultimaalteracao =  " + Util.obterSQLDataAtual()  
				  + " where cnta_id in ( "
				  + " 		select cnta_id "
				  + " 		from faturamento.conta c "
				  + " 		inner join cadastro.cliente_imovel ci on ( " 
				  +	" 			c.imov_id = ci.imov_id and ci.clim_dtrelacaofim is null and ci.crtp_id in (2,3) ) "
				  + " 		inner join cadastro.cliente cl on (ci.clie_id = cl.clie_id ) "
				  + " 		inner join cadastro.cliente_tipo ct on (cl.cltp_id = ct.cltp_id) "
				  + " 		where ";
			
			if(Util.verificarNaoVazio(helper.getIdCliente())){
				
				update += " (cl.clie_id = " + helper.getIdCliente() 
					   +  " or cl.clie_cdclienteresponsavel = " + helper.getIdCliente() + ") and ";
			}else if(Util.verificarNaoVazio(helper.getIdImovel())){
				
				update += " c.imov_id = " + helper.getIdImovel() + " and ";
			}
			
			if(Util.verificarNaoVazio(helper.getEsferaPoder()) ){
				update +=" ct.epod_id in (" + helper.getEsferaPoder() + " ) and ";
			}
			
			 update	+= " dcst_idatual in (0,1,2) and "
				   + " cnta_amreferenciaconta between " + helper.getDataInicio() + " and " + helper.getDataFim() + " and "
				   + " cnta_amreferenciacontabil < " + helper.getAnoMesReferencia() + " and "
				   + " not exists ( "
				   + " 			select cnta_id "
				   + " 			from faturamento.conta_categoria g "
				   + " 			where c.cnta_id = g.cnta_id "
				   + " 			and catg_id in (1,2,3) "
				   + " 		) "
				   + " ) ";
			
			st = jdbcCon.prepareStatement(update);
			
			// executa o update
			st.executeUpdate();
				
			// erro no hibernate
		} catch (SQLException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}
		
	/**
	 * 
	 * [UC1083] Prescrever Débitos de Imóveis Públicos Automático
	 * 
	 * @author Hugo Leonardo
	 * @date 19/10/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection obterDadosPrescricaoDebitosAutomaticos() throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = " select presc.esferaPoder1.id, presc.esferaPoder2.id "
					 + " from Prescricao presc "
					 + " order by presc.anoMesReferencia desc, presc.ultimaAlteracao desc";

			retorno = (Collection) session.createQuery(consulta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}
	
	/**
	 * 
	 * [UC1083] Prescrever Débitos de Imóveis Públicos Automático
	 * 
	 * @author Hugo Leonardo
	 * @date 19/10/2010
	 * 
	 * @param idFuncionalidadeIniciada
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public void prescreverDebitosImoveisPublicosAutomatico(Integer anoMesReferencia, Integer anoMesPrescricao, 
			Integer usuario, String idsEsferaPoder) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();
		
		PreparedStatement st = null;
		
		try {

			// declara o tipo de conexao
			Connection jdbcCon = session.connection();
			
			// Atualiza Contas
			update =" update faturamento.conta c " 
				  + " set 	dcst_idatual = 8, "
				  + "       usur_id = " + usuario.intValue() + ", "
				  + " 		dcst_idanterior = NULL, "
				  + " 		cnta_dtcancelamento =   " + Util.obterSQLDataAtual() + " , "
				  + " 		cmcn_id = 99, "
				  + " 		cnta_amreferenciacontabil = " + anoMesReferencia.intValue() + ", "
				  + "       cnta_tmultimaalteracao =   " + Util.obterSQLDataAtual()
				  + " where cnta_id in ( "
				  + " 		select cnta_id "
				  + " 		from faturamento.conta c "
				  + " 		inner join cadastro.cliente_imovel ci on ( " 
				  +	" 			c.imov_id = ci.imov_id and ci.clim_dtrelacaofim is null and ci.crtp_id in (2,3) ) "
				  + " 		inner join cadastro.cliente cl on (ci.clie_id = cl.clie_id ) "
				  + " 		inner join cadastro.cliente_tipo ct on (cl.cltp_id = ct.cltp_id) "
				  + " 		where "
				  + " 		ct.epod_id in ( " + idsEsferaPoder + " ) and "
				  + " 		dcst_idatual in (0,1,2) and "
				  + " 		cnta_amreferenciaconta < " + anoMesPrescricao.toString() + " and "
				  + " 		cnta_amreferenciacontabil < " + anoMesReferencia.toString() + " and "
				  + " 		not exists ( "
				  + " 				select cnta_id "
				  + " 				from faturamento.conta_categoria g "
				  + " 				where c.cnta_id = g.cnta_id "
				  + " 				and catg_id in (1,2,3) "
				  + " 			) "
				  + " 	) ";
			
			st = jdbcCon.prepareStatement(update);
			
			// executa o update
			st.executeUpdate();
				
			// erro no hibernate
		} catch (SQLException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}
	
	/*
	 * 
	 * Método criado para não salvar na tabela de geração da rota
	 * todos os imóveis da rota, e sim, somente os que possuem conta pre-faturada
	 * 
	 * Obter quantidade de imóveis com conta Pré-faturada
	 */
	
	 /** @author Adriana Muniz e Pamela Gatinho  
	 * @date 13/12/2010
	 * 
	 * @param anoMesReferencia
	 * @param idRota
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int verificarQuantidadeImoveisMovimentoContaPreFaturada(
			int anoMesReferencia,
			int idRota)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = 
				"select count(*) " +
				"from MovimentoContaPrefaturada movimentoContaPrefaturada " +
				"where movimentoContaPrefaturada.rota.id = :idRota " +
				"and movimentoContaPrefaturada.anoMesReferenciaPreFaturamento = :anoMesReferencia ";

			retorno = (Integer)session.createQuery(consulta)
				.setInteger("anoMesReferencia",anoMesReferencia)
				.setInteger("idRota", idRota)
				.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}	
	
	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 22/11/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualDaConta(Integer idImovel,
			Integer anoMesReferencia) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dcst.id "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "where imov.id = :idImovel AND cnta.referencia = :anoMesReferencia AND dcst.id = "
					+ DebitoCreditoSituacao.PRE_FATURADA + " ";

			retorno = (Integer) session.createQuery(consulta)
				.setInteger("idImovel", idImovel)
				.setInteger("anoMesReferencia",	anoMesReferencia)
				.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0651] Inserir Comando de Negativação
	 * [FS0031]  Verificar existência de conta em nome do cliente
	 * 
	 * Pesquisa os relacionamentos entre cliente e conta.
	 * 
	 * @author Vivianne Sousa
	 * @date 29/12/2010
	 * 
	 * @param idCliente
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarSeExisteClienteConta(Integer idCliente,Collection colecaoContasIds)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select clienteConta.id "
				+ "from ClienteConta clienteConta "
				+ "inner join clienteConta.cliente cliente "
				+ "where cliente.id = :idCliente " 
				+ "and clienteConta.conta.id in (:colecaoContasIds)";

			retorno = session.createQuery(consulta)
				.setInteger("idCliente",idCliente)
				.setParameterList("colecaoContasIds",colecaoContasIds)
				.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * 
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 03/12/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarDataLeituraAtualMovimentoContaPreFaturada(Integer amMovimento,Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;
		
		Date dataLeitura = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = " select dataHoraLeitura "
					 + " from MovimentoContaPrefaturada mcpf "
					 + " where mcpf.anoMesReferenciaPreFaturamento = :amMovimento and mcpf.imovel.id = :idImovel ";

			retorno = (Collection) session.createQuery(consulta)
									.setInteger("amMovimento",amMovimento)
									.setInteger("idImovel",idImovel)
									.list();
			if(retorno != null && !retorno.isEmpty()){
				dataLeitura = (Date)Util.retonarObjetoDeColecao(retorno);
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return dataLeitura;
	}
	
	/**
	 * [RM-4643 (COMPESA)] 
	 * Verificamos se o imóvel sofreu alterações 
	 * depois de ter sido mandado para o GSAN a primeira vez
	 * 
	 * @author Bruno Barros
	 * @date 14/12/2010
	 * 
	 * @param anoMes
	 * @param idImovel
	 * @param tipoMedicao
	 * @param leitura
	 * @param idAnormalidade
	 * @return
	 * @throws ControladorException
	 */
	public boolean reprocessarImovelImpressaoSimultanea(
			Integer anoMes,
			Integer idImovel,
			Short tipoMedicao,
			Integer leitura,
			Integer idAnormalidade,
			Short icImpresso) throws ErroRepositorioException{
		Integer retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = 
				"select " +
				"  count(*) " +
				"from " +
				"  MovimentoContaPrefaturada mcpf " +
				"where " +
				"  mcpf.anoMesReferenciaPreFaturamento = :anoMesFaturamento and " +
				"  mcpf.imovel.id = :idImovel and " +
				"  mcpf.medicaoTipo.id = :medicaoTipo and " +
				"  mcpf.indicadorEmissaoConta = :icImpresso and ";
			
			
			if ( leitura == null ){
				consulta += "  mcpf.leituraHidrometro is null and ";
			} else {
				consulta += "  mcpf.leituraHidrometro = :leituraHidrometro and ";
			}
			
			if ( idAnormalidade == null ){
				consulta += "  mcpf.leituraAnormalidadeLeitura.id is null ";
			} else {
				consulta += "  mcpf.leituraAnormalidadeLeitura.id = :anormalidadeLeitura";
			}	
			
			Query query = session.createQuery(consulta)
				.setInteger( "anoMesFaturamento", anoMes )
				.setInteger( "idImovel", idImovel )
				.setShort( "medicaoTipo", tipoMedicao )
				.setShort( "icImpresso", icImpresso );
			
			if ( leitura != null ){
				query.setInteger( "leituraHidrometro", leitura );
			}
			
			if ( idAnormalidade != null ){
				query.setInteger( "anormalidadeLeitura", idAnormalidade );
			}
			
			retorno = (Integer)query.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return ( retorno == null || retorno.intValue() == 0 );		
	}
	
	/**
	 * 
	 * Retificação de um conjunto de contas que foram pagas e que o pagamento não estava o débito e/ou crédito (Conta paga via Impressão Simultânea) 
	 *
	 * @author Sávio Luiz
	 * @date 27/12/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasPagasSemDebitoCreditoPago(Integer amreferencia,Integer idGrupo) throws ErroRepositorioException {

		Collection retorno = null;
		
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta =  " select distinct cn.cnta_id as idConta,pgmt_vlpagamento as valorPagamento, "+
			            " (cn.cnta_vlagua + cn.cnta_vlesgoto + cn.cnta_vldebitos - cn.cnta_vlcreditos - cnta_vlimpostos) as valorConta "+
						" from faturamento.conta cn "+
						" inner join arrecadacao.pagamento p on p.cnta_id = cn.cnta_id "+
						" inner join faturamento.mov_conta_prefaturada mcpf on mcpf.IMOV_ID = cn.IMOV_ID and mcpf.MCPF_AMMOVIMENTO = cn.CNTA_AMREFERENCIACONTA "+
						" where cn.cnta_amreferenciaconta = :amreferencia and cn.DCST_IDATUAL = 0 and (cn.cnta_vldebitos <> 0 ) "+
						"	and pgmt_vlpagamento < (cn.cnta_vlagua + cn.cnta_vlesgoto + cn.cnta_vldebitos - cn.cnta_vlcreditos - cnta_vlimpostos) ";
			
			if(idGrupo != null && !idGrupo.equals("")){
				consulta = consulta + " and cn.ftgr_id = "+ idGrupo;
			}

			retorno = (Collection) session.createSQLQuery(consulta)
											.addScalar("idConta", Hibernate.INTEGER)
											.addScalar("valorPagamento",Hibernate.BIG_DECIMAL)
											.addScalar("valorConta",Hibernate.BIG_DECIMAL)
											.setInteger("amreferencia",amreferencia)
											.list();
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}
	
	/**
	 * 
	 * Retificação de um conjunto de contas que foram pagas e que o pagamento não estava o débito e/ou crédito (Conta paga via Impressão Simultânea) 
	 *
	 * @author Sávio Luiz
	 * @date 28/12/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public List pesquisarValorPrestacaoDebitoCobradoSemreferencia(Integer idConta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select debCobrado, "// 0
					+ "debCobrado.debitoACobrarGeral.id " // 1
					+ "from DebitoCobrado debCobrado "
					+ "inner join debCobrado.conta conta "
					+ "where conta.id = :idConta and "
					+ "debCobrado.anoMesReferenciaDebito is null ";

			retorno = session.createQuery(consulta).setInteger("idConta",
					idConta.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Inserir Débitos para as contas impressas via Impressão Simultânea de Contas que sairam com o valor da conta errada (Alguns grupos com tarifa proporcional
	 *  que não estava levando em consideração a quantidade de economias)
	 *
	 * @author Sávio Luiz
	 * @date 12/01/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasComValorFaixasErradas(Integer amreferencia) throws ErroRepositorioException {

		Collection retorno = null;
		
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta =  " select imov_id as imovel,c.cnta_amreferenciaconta as referencia, "
						+ " (((select sum(ctcg_vltarifaminimaagua)  from faturamento.conta_categoria g where c.cnta_id=g.cnta_id) + "
						+ " (select sum(cccf_vlagua * ctcg_qteconomia) from faturamento.conta_catg_cons_fx f, faturamento.conta_categoria g "
						+ " where g.cnta_id=c.cnta_id and f.cnta_id=g.cnta_id and f.catg_id=g.catg_id)) - cnta_vlagua) as diferenca "
						+ " from faturamento.conta c " 
						+ " where cnta_amreferenciaconta = :amreferencia and c.dcst_idatual = 0" 
						+ " and  cnta_vlagua > 0 and (cnta_vlagua - "
						+ " ((select sum(ctcg_vltarifaminimaagua)  from faturamento.conta_categoria g where c.cnta_id=g.cnta_id) + "
						+ " (select sum(cccf_vlagua * ctcg_qteconomia) from faturamento.conta_catg_cons_fx f, faturamento.conta_categoria g "
						+ " where g.cnta_id=c.cnta_id and f.cnta_id=g.cnta_id and f.catg_id=g.catg_id))) < -2.5 ";
			

			retorno = (Collection) session.createSQLQuery(consulta)
											.addScalar("imovel", Hibernate.INTEGER)
											.addScalar("referencia",Hibernate.INTEGER)
											.addScalar("diferenca",Hibernate.BIG_DECIMAL)
											.setInteger("amreferencia",amreferencia)
											.list();
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}
	
	/**
	 * [UC0204] Consultar Conta
	 * 
	 * Pesquisa o consumo faturado do imóvel
	 * 
	 * @author Mariana Victor
	 * @date 06/01/2011
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] consultarConsumoCadastrado(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cstc.cstc_nnconsumominimo AS consumoMinimo, cstc.cstc_vltarifaminima AS valorTarifaMinima "
					+ " FROM faturamento.consumo_tarifa_categoria cstc "
					+ " INNER JOIN faturamento.consumo_tarifa_vigencia cstv ON cstc.cstv_id = cstv.cstv_id "
					+ " INNER JOIN cadastro.imovel imov ON imov.cstf_id = cstv.cstf_id AND imov.imov_id = :idImovel "
					+ " INNER JOIN cadastro.subcategoria scat ON cstc.catg_id = scat.catg_id "
					+ " INNER JOIN cadastro.imovel_subcategoria imov_scat ON scat.scat_id = imov_scat.scat_id AND imov.imov_id = imov_scat.imov_id "
					+ " ORDER BY cstv.cstv_dtvigencia DESC ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"consumoMinimo", Hibernate.INTEGER).addScalar(
					"valorTarifaMinima", Hibernate.BIG_DECIMAL).setInteger("idImovel",
					idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	

	/**
	 * [UC0473] Consultar Dados Complementares do Imóvel
	 * 
	 * Pesquisa as matrículas associadas à mesma tarifa de consumo do imóvel.
	 * 
	 * @author Mariana Victor
	 * @date 06/01/2011
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> consultarMatriculasAssociadas(Integer idConsumoTarifa, Integer idImovel)
			throws ErroRepositorioException {

		Collection<Integer> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT imov.imov_id AS idImovel "
					+ " FROM cadastro.imovel imov "
					+ " INNER JOIN faturamento.consumo_tarifa cstf ON cstf.cstf_id = imov.cstf_id "
					+ " INNER JOIN arrecadacao.contrato_demanda ctdm ON ctdm.imov_id = imov.imov_id "
					+ " AND ctdm.ctdm_nncontrato IS NOT NULL "
					+ " WHERE imov.cstf_id = :idConsumoTarifa AND imov.imov_id <> :idImovel "
					+ " GROUP BY imov.imov_id ";

			retorno = (Collection<Integer>) session.createSQLQuery(consulta).addScalar(
					"idImovel", Hibernate.INTEGER).setInteger("idConsumoTarifa",
						idConsumoTarifa).setInteger("idImovel",
								idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0150] Retificar Conta 
	 *
	 * @author Raphael Rossiter
	 * @date 19/01/2011
	 *
	 * @param idConta
	 * @return Rota
	 * @throws ErroRepositorioException
	 */
	public Rota pesquisarRotaParaRetificacao(Integer idConta)throws ErroRepositorioException {

		Rota rota = null;
		Object[] dadosRotas = null;
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
			
			consulta = "select rotaConta, faturamentoGrupoConta, rotaAlternativa, faturamentoGrupoRotaAlternativa, " //0, 1, 2, 3
					+ " rotaQuadra, faturamentoGrupoQuadra " // 4, 5
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join imov.quadra qdra "
					+ "left join cnta.rota rotaConta "
					+ "left join cnta.faturamentoGrupo faturamentoGrupoConta "
					+ "left join imov.rotaAlternativa rotaAlternativa "
					+ "left join rotaAlternativa.faturamentoGrupo faturamentoGrupoRotaAlternativa "
					+ "left join qdra.rota rotaQuadra "
					+ "left join rotaQuadra.faturamentoGrupo faturamentoGrupoQuadra "
					+ "where cnta.id = :idConta ";
		
			dadosRotas = (Object[]) session.createQuery(consulta).setInteger("idConta",
			idConta.intValue()).uniqueResult();
			
			if (dadosRotas != null){
				
				//ROTA DA CONTA
				if (dadosRotas[0] != null){
					
					rota = (Rota) dadosRotas[0];
					rota.setFaturamentoGrupo((FaturamentoGrupo) dadosRotas[1]);
				}
				//ROTA ALTERNATIVA
				else if (dadosRotas[2] != null){
					
					rota = (Rota) dadosRotas[2];
					rota.setFaturamentoGrupo((FaturamentoGrupo) dadosRotas[3]);
				}
				//ROTA DA QUADRA
				else{
					
					rota = (Rota) dadosRotas[4];
					rota.setFaturamentoGrupo((FaturamentoGrupo) dadosRotas[5]);
				}
			}
		
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return rota;
	}
	
	
	/**
	 * [UC0150] Retificar Conta 
	 *
	 * @author Raphael Rossiter
	 * @date 20/01/2011
	 *
	 * @param conta
	 * @param rota
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarArquivoTextoRoteiroEmpresaNaoFinalizado(Conta conta, Rota rota)throws ErroRepositorioException {

		Integer idArquivoTextoRoteiroEmpresa = null;
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
			
			consulta = "select txre.id " // 0
					+ "from ArquivoTextoRoteiroEmpresa txre "
					+ "inner join txre.rota rota "
					+ "inner join txre.situacaoTransmissaoLeitura sitl "
					+ "inner join txre.servicoTipoCelular stce "
					+ "where rota.id = :idRota and txre.anoMesReferencia = :anoMesReferencia and "
					+ "sitl.id in (:disponivel, :liberado, :emCampo) and stce.id = :impressaoSimultanea";
		
			idArquivoTextoRoteiroEmpresa = (Integer) session.createQuery(consulta)
				.setInteger("idRota", rota.getId().intValue())
				.setInteger("anoMesReferencia", conta.getReferencia())
				.setInteger("disponivel", SituacaoTransmissaoLeitura.DISPONIVEL)
				.setInteger("liberado", SituacaoTransmissaoLeitura.LIBERADO)
				.setInteger("emCampo", SituacaoTransmissaoLeitura.EM_CAMPO)
				.setInteger("impressaoSimultanea", ServicoTipoCelular.IMPRESSAO_SIMULTANEA)
				.uniqueResult();
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return idArquivoTextoRoteiroEmpresa;
	}
	
	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [FS0002] - Verificar Situação Especial de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 17/04/2008
	 * 
	 * @param rota
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImovelGerarArquivoTextoFaturamentoPorRotaAlternativa(
			Rota rota, int numeroPaginas, int quantidadeRegistros,
			SistemaParametro sistemaParametro,Integer idImovelCondominio) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gerenciaRegional.nome, "// 0
					+ "localidade.id, localidade.descricao, "// 1,2
					+ "imovel.nomeImovel, clienteUsuario.nome, "// 3,4
					+ "setorComercial.codigo, quadra.numeroQuadra, "// 5,6
					+ "imovel.lote, imovel.subLote, "// 7,8
					+ "clienteResposanvel.id, clienteResposanvel.nome, "// 9,10
					+ "ligacaoAguaSituacao.id, ligacaoEsgotoSituacao.id, "// 11,12
					+ "ligacaoAgua.numeroConsumoMinimoAgua, ligacaoEsgoto.consumoMinimo, "// 13,14
					+ "ligacaoEsgoto.percentualAguaConsumidaColetada, "// 15
					+ "faturamentoSituacaoTipo.indicadorParalisacaoFaturamento, "// 16
					+ "faturamentoSituacaoTipo.indicadorValidoAgua, " // 17
					+ "faturamentoSituacaoTipo.indicadorValidoEsgoto, "// 18
					+ "imovelCondominio.id, imovel.indicadorImovelCondominio, "// 19,20
					+ "imovelPerfil.id, consumoTarifa.id, imovel.id, pocoTipo.id, "// 21,22,23,24
					+ "consumoTarifa.tarifaTipoCalculo.id, "// 25
					+ "setorComercial.id, "// 26
					+ "imovel.numeroSequencialRota, "// 27
					+ "gerenciaRegional.id, "// 28
					+ "ligacaoAguaSituacao.indicadorFaturamentoSituacao,"// 29
					+ "ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, "// 30
					+ "ice.id, "// 31
					+ "clienteUsuario.cpf, "// 32
					+ "clienteUsuario.cnpj, "// 33
					+ "hidAgua.id, "// 34
					+ "hidPoco.id, "// 35
					+ "ligacaoAguaSituacao.indicadorAbastecimento, " // 36
					+ "ligacaoAgua.id, "// 37
					+ "ligacaoAguaSituacao.descricao, "// 38
					+ "leiturista.id, "// 39
					+ "empresa.id, "// 40
					+ "quadraFace.id, "// 41
					+ "quadraFace.numeroQuadraFace, "// 42
					+ "imovel.numeroMorador, "// 43
					+ "medTipoAgua.id, "// 44
					+ "medTipoPoco.id, "// 45
					+ "ligacaoAgua.numeroLacre, "// 46
					+ "logradouroBairro.id, " // 47
					+ "logradouro.id, " // 48
					+ "logradouro.nome, " // 49
					+ "bairro.nome, " // 50
					+ "imovel.numeroImovel, " // 51
					+ "imovel.complementoEndereco, "// 52
					+ "hidLocInsAgua.id, "// 53
					+ "hidAgua.dataInstalacao, "// 54
					+ "hidProtAgua.id, "// 55
					+ "hidLocInsPoco.id, "// 56
					+ "hidPoco.dataInstalacao, "// 57
					+ "hidProtPoco.id, "// 58
					+ "usu.login, "// 59
					+ "usu.senha, "// 60
					+ "faturamentoSituacaoTipo.id, " //61
					+ "imovel.codigoDebitoAutomatico, "//62
					+ "ligacaoEsgoto.percentualAlternativo, "//63
					+ "ligacaoEsgoto.numeroConsumoPercentualAlternativo, "//64
					+ "faturamentoSituacaoTipo.indicadorParalisacaoLeitura, "// 65
					+ "ligacaoAguaSituacao.indicadorConsumoReal, "// 66
					+ "ligacaoAguaSituacao.numeroDiasCorte, "// 67
					+ "ligacaoAgua.dataCorte, "// 68
                    + "imovel.indicadorImovelAreaComum, " // 69
                    /*  Adicionando campos para enviar na rota */
					+ "ligacaoAgua.dataLigacao, " // 70
					+ "ligacaoEsgoto.dataLigacao, " // 71
					/*  Adicionando informacao do nome da conta */
					+ "clienteImoveisReposanvel.cliente.id, " //72
					+ "clienteImoveisReposanvel.indicadorNomeConta, " //73
					+ "clienteImoveisUsuario.cliente.id, " //74
					+ "clienteImoveisUsuario.indicadorNomeConta " //75
					+ "FROM Imovel imovel "
					+ "inner join imovel.rotaAlternativa rotaAlternativa "
					+ "INNER JOIN imovel.localidade localidade "
					+ "INNER JOIN localidade.gerenciaRegional gerenciaRegional "
					+ "INNER JOIN imovel.setorComercial setorComercial "
					+ "INNER JOIN imovel.quadra quadra "
					+ "INNER JOIN quadra.rota rota "
					+ "INNER JOIN imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "INNER JOIN imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "INNER JOIN imovel.imovelPerfil imovelPerfil "
					+ "INNER JOIN imovel.consumoTarifa consumoTarifa "
					+ "LEFT JOIN imovel.quadraFace quadraFace "
					+ "LEFT JOIN imovel.ligacaoAgua ligacaoAgua "
					+ "LEFT JOIN ligacaoAgua.hidrometroInstalacaoHistorico hidAgua "
					+ "LEFT JOIN hidAgua.medicaoTipo medTipoAgua "
					+ "LEFT JOIN hidAgua.hidrometroLocalInstalacao hidLocInsAgua "
					+ "LEFT JOIN hidAgua.hidrometroProtecao hidProtAgua "
					+ "LEFT JOIN imovel.hidrometroInstalacaoHistorico hidPoco "
					+ "LEFT JOIN hidPoco.medicaoTipo medTipoPoco "
					+ "LEFT JOIN hidPoco.hidrometroLocalInstalacao hidLocInsPoco "
					+ "LEFT JOIN hidPoco.hidrometroProtecao hidProtPoco "
					+ "LEFT JOIN imovel.ligacaoEsgoto ligacaoEsgoto "
					+ "LEFT JOIN imovel.pocoTipo pocoTipo "
					+ "LEFT JOIN imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ "LEFT JOIN imovel.imovelCondominio imovelCondominio "
					+ "LEFT JOIN imovel.clienteImoveis clienteImoveisUsuario WITH "
					+ "(clienteImoveisUsuario.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ ") AND clienteImoveisUsuario.dataFimRelacao IS NULL "
					+ "LEFT JOIN clienteImoveisUsuario.cliente clienteUsuario "
					+ "LEFT JOIN imovel.clienteImoveis clienteImoveisReposanvel WITH "
					+ "(clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ ") and clienteImoveisReposanvel.dataFimRelacao IS NULL "
					+ "LEFT JOIN clienteImoveisReposanvel.cliente clienteResposanvel "
					+ "LEFT JOIN imovel.imovelContaEnvio ice "
					+ "LEFT JOIN rotaAlternativa.leiturista leiturista "
					+ "LEFT JOIN rotaAlternativa.empresa empresa "
					+ "LEFT JOIN leiturista.usuario usu "
					+ "LEFT JOIN imovel.logradouroBairro logradouroBairro "
					+ "LEFT JOIN logradouroBairro.logradouro logradouro "
					+ "LEFT JOIN logradouroBairro.bairro bairro "
					+ "WHERE  imovelPerfil.indicadorGerarDadosLeitura = 1 AND imovel.indicadorExclusao <> :idExclusao ";
			
			if(rota.getId() != null && !rota.getId().equals("")){
				consulta += " AND rotaAlternativa.id = "+rota.getId() ;
			}
			
			if(idImovelCondominio != null && !idImovelCondominio.equals("")){
				consulta += " AND imovelCondominio.id ="+idImovelCondominio ;
			}else{
				consulta += " AND imovelCondominio.id is null ";
			}
			if (sistemaParametro.getNomeAbreviadoEmpresa() != null
					&& sistemaParametro.getNomeAbreviadoEmpresa().equals(
							"COMPESA")) {
				consulta = consulta
						+ " ORDER BY imovel.numeroSequencialRota, setorComercial.codigo,quadra.numeroQuadra,imovel.lote,imovel.subLote ";

			} else {
				consulta = consulta
						+ " ORDER BY imovel.numeroSequencialRota,imovel.lote,imovel.subLote ";
			}

			if(rota.getId() != null && !rota.getId().equals("")){
				retorno = session.createQuery(consulta)
						.setShort("idExclusao", Imovel.IMOVEL_EXCLUIDO)
						.setFirstResult(numeroPaginas)
						.setMaxResults(quantidadeRegistros)
						.list();
			}else{
				retorno = session.createQuery(consulta)
				.setShort("idExclusao", Imovel.IMOVEL_EXCLUIDO).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0600] Emitir Histograma de Esgoto - Volume Faturado Ligacao Estimado
	 * ou Real
	 * 
	 * 
	 * @author Rafael Pinto
	 * @date 05/11/2007
	 * 
	 * @param FiltrarEmitirHistogramaEsgotoHelper
	 * 
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Integer pesquisarEmitirHistogramaEsgotoVolumeConsumo(
			FiltrarEmitirHistogramaEsgotoHelper filtro, Short consumo,
			Subcategoria subcategoria, Short medicao) throws ErroRepositorioException {

		Integer retornoConsulta = null;

		Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

		GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
		UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();

		Localidade eloPolo = filtro.getEloPolo();
		Localidade localidade = filtro.getLocalidade();
		SetorComercial setorComercial = filtro.getSetorComercial();
		Quadra quadra = filtro.getQuadra();

		Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
		Collection<Integer> colecaoSubcategoria = filtro.getColecaoSubcategoria();
		Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
		Collection<Integer> colecaoPerfilImovel = filtro
				.getColecaoPerfilImovel();
		Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
		Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro
				.getColecaoSituacaoLigacaoEsgoto();
		Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro
				.getColecaoPercentualLigacaoEsgoto();

		CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
		ConsumoTarifa tarifa = filtro.getTarifa();
		ImovelPerfil perfilImovel = filtro.getPerfilImovel();
		EsferaPoder esferaPoder = filtro.getEsferaPoder();
		LigacaoEsgotoSituacao situacaoLigacaoEsgoto = filtro
				.getSituacaoLigacaoEsgoto();
		BigDecimal percentualLigacaoEsgoto = filtro
				.getPercentualLigacaoEsgoto();
		
		int indicadorTarifaCategoria = filtro.getIndicadorTarifaCategoria().intValue();

		Short poco = filtro.getPoco();
		Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

		ConsumoFaixaLigacao consumoFaixaLigacao = filtro
				.getConsumoFaixaLigacao();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro
				.getConsumoFaixaLigacaoIntervaloMedido();

		ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro
				.getConsumoFaixaLigacaoIntervaloNaoMedido();

		Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
		Integer numeroQuadra = filtro.getNumeroQuadra();

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum(histograma.volumeFaturadoLigacao) "; // 0

			String consultaFrom = "";
			
			if ( indicadorTarifaCategoria == 1 ){
				consultaFrom = "FROM HistogramaEsgotoLigacao histograma "
					+ "INNER JOIN histograma.categoria categoria ";
			} else {
				consultaFrom = "FROM HistogramaEsgotoLigacaoSemQuadra histograma "
					+ "INNER JOIN histograma.subcategoria subcategoria "				
					+ "INNER JOIN histograma.categoria categoria ";
			}
			
			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if (consumoFaixaLigacao != null) {
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao
						.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao
						.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if (consumoFaixaLigacaoIntervaloMedido != null
					&& consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
						+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido",
						consumoFaixaLigacaoIntervaloMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido",
						consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			} else if (consumoFaixaLigacaoIntervaloNaoMedido != null) {

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido",
						consumoFaixaLigacaoIntervaloNaoMedido
								.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if (gerenciaRegional != null) {
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if (unidadeNegocio != null) {
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if (eloPolo != null) {
				if ( filtro.getIndicadorTarifaCategoria() != null && filtro.getIndicadorTarifaCategoria().intValue() == ConstantesSistema.NAO ) {
					consultaFrom += "INNER JOIN histograma.localidadeEelo localidadeElo ";
				} else {
					consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";	
				}

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if (localidade != null) {
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if (setorComercial != null) {
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if (codigoSetorComercial != null) {
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if (quadra != null) {
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if (numeroQuadra != null) {
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if (tipoCategoria != null) {
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}
			
			// Subcategoria
			if (subcategoria != null) {
				consultaWhere += "AND subcategoria.id = (:scate) AND categoria.id = :catg_id ";
				parameters.put("scate", subcategoria.getId());
				parameters.put("catg_id", subcategoria.getCategoria().getId() );
			} else if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {
				consultaWhere += "AND subcategoria.id in (:scate) ";
				parameters.put("scate", colecaoSubcategoria);
			}			

			// Tarifa
			if (tarifa != null) {
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			} else if (colecaoTarifa != null && !colecaoTarifa.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if (perfilImovel != null) {
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			} else if (colecaoPerfilImovel != null
					&& !colecaoPerfilImovel.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if (esferaPoder != null) {
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			} else if (colecaoEsferaPoder != null
					&& !colecaoEsferaPoder.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if (situacaoLigacaoEsgoto != null) {
				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id = (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", situacaoLigacaoEsgoto
						.getId());
			} else if (colecaoSituacaoLigacaoEsgoto != null
					&& !colecaoSituacaoLigacaoEsgoto.isEmpty()) {

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto",
						colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if (percentualLigacaoEsgoto != null) {

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						percentualLigacaoEsgoto);

			} else if (colecaoPercentualLigacaoEsgoto != null
					&& !colecaoPercentualLigacaoEsgoto.isEmpty()) {

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto",
						colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if (consumo != null) {
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if (medicao != null) {
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if (poco != null) {
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if (volumoFixoEsgoto != null) {
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retornoConsulta = (Integer) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}
    /**
	 * [UC0366] Inserir Registro de Atendimento
	 * 
	 * [FS0048]  Verificar existência da conta.
	 * 
	 * @author Mariana Victor
	 * @date 27/01/2011
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarContaAnoMesImovel(Integer idImovel, int anoMesReferencia)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		Conta conta = null;
		
		try {
			consulta = " SELECT conta.cnta_id AS idConta, conta.cnta_amreferenciaconta AS anoMes, " +
					" conta.cnta_dtvencimentoconta AS vencimento " +
					" FROM faturamento.conta conta " +
					" WHERE conta.imov_id = :idImovel AND conta.cnta_amreferenciaconta = :anoMesReferencia " +
					" AND (conta.dcst_idatual = 0 OR conta.dcst_idatual = 1 OR conta.dcst_idatual = 2) ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"idConta", Hibernate.INTEGER).addScalar(
							"anoMes", Hibernate.INTEGER).addScalar(
									"vencimento", Hibernate.DATE).setInteger("anoMesReferencia",
										anoMesReferencia).setInteger("idImovel",
											idImovel).setMaxResults(1).uniqueResult();
			
			
			if (retorno != null) {
				conta = new Conta();
				if (retorno[0] != null && !retorno[0].toString().equals("")) {
					conta.setId(new Integer(retorno[0].toString()));
				}
				if (retorno[1] != null && !retorno[1].toString().equals("")) {
					conta.setReferencia(new Integer(retorno[1].toString()));
				}
				if (retorno[2] != null && !retorno[2].toString().equals("")) {
					conta.setDataVencimentoConta(
							(Date) retorno[2]);
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return conta;
	}
	
	/**
	 * [UC0146] Manter Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 11/02/2011
	 * 
	 * @throws ControladorException
	 */
	public Integer pesquisaQtdeContaRetificadaMotivo(
			Integer idMotivo,Integer idImovel,Date dataLimite) throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "SELECT count(cnta.id) "
					+ "FROM Conta cnta "
					+ "WHERE cnta.imovel.id = :idImovel " 
					+ "and cnta.dataRetificacao > :dataLimite "
					+ "and cnta.contaMotivoRetificacao.id = :idMotivo "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idImovel",idImovel)
					.setInteger("idMotivo", idMotivo)
					.setInteger("idSituacao", DebitoCreditoSituacao.RETIFICADA)
					.setDate("dataLimite",dataLimite)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0146] Manter Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 11/02/2011
	 * 
	 * @throws ControladorException
	 */
	public Integer pesquisaQtdeContaHistoricoRetificadaMotivo(
			Integer idMotivo,Integer idImovel,Date dataLimite) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "SELECT count(cnta.id) "
					+ "FROM ContaHistorico cnta "
					+ "WHERE cnta.imovel.id = :idImovel " 
					+ "and cnta.dataRetificacao > :dataLimite "
					+ "and cnta.contaMotivoRetificacao.id = :idMotivo "
					+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
					+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idImovel",idImovel)
					.setInteger("idMotivo", idMotivo)
					.setInteger("idSituacao", DebitoCreditoSituacao.RETIFICADA)
					.setDate("dataLimite",dataLimite)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0146] Manter Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 11/02/2011
	 * 
	 * @throws ControladorException
	 */
	public Collection pesquisaTabelaColunaContaMotivoRetificacaoColuna(
			Integer idMotivo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "SELECT cmrc.tabelaColuna "
					+ "FROM ContaMotivoRetificacaoColuna cmrc "
					+ "WHERE cmrc.contaMotivoRetificacao.id = :idMotivo ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idMotivo", idMotivo)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1122] Automatizar Perfis de Grandes Consumidores
	 * 
	 * Pesquisa o consumo faturado do imóvel
	 * 
	 * @author Mariana Victor
	 * @date 06/01/2011
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarImovelConsumoHistorico(Integer idImovel)
		throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cshi.cshi_nnconsumofaturadomes AS consumo " +
					" FROM micromedicao.consumo_historico cshi " +
					" INNER JOIN faturamento.faturamento_grupo ftgr ON cshi.cshi_amfaturamento = (ftgr.ftgr_amreferencia - 1)" +
					" INNER JOIN micromedicao.rota rota ON rota.ftgr_id = ftgr.ftgr_id " +
					" INNER JOIN cadastro.quadra qdra ON qdra.rota_id = rota.rota_id " +
					" INNER JOIN cadastro.imovel imov ON imov.imov_id = :idImovel AND imov.qdra_id = qdra.qdra_id AND imov.imov_id = cshi.imov_id ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar(
					"consumo", Hibernate.INTEGER).setInteger("idImovel",
					idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public BigDecimal obterValorConta (Conta conta)
			throws ErroRepositorioException {

		BigDecimal retorno = new BigDecimal("0.00");
		retorno = retorno.setScale(2);

		Session session = HibernateUtil.getSession();
		Integer id = conta.getId();
		
		String consulta;

		try {

			consulta = "select conta.valorAgua + conta.valorEsgoto + conta.debitos - conta.valorCreditos - conta.valorImposto as total from Conta conta "
					+  "where conta.id = :idConta ";

			
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idConta", id).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	
	/**
	 * 
	 * Consulta conta Tipo de conta impressao no emitir contas
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarContaTipodeContaImpressao(
			Integer idConta)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select cttp_id as idConta "
				+ "from faturamento.conta_impressao "
				+ "where cnta_id = :idConta";

			retorno = (Integer)session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
				.setInteger("idConta",idConta)
				.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	// retorna o anoMes do faturamento grupo do imóvel passado inclusive se ele tiver rota alternativa
	public Integer retornaAnoMesGrupoFaturamento(Integer idImovel)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer anoMesFaturamento = null;

		try {

			// Pesquisa para saber qual o anoMes de faturamento do grupo q akele
			// imovel pertence
			String sqlMesFaturamentoGrupoRotaAlternativa = "select fg.ftgr_amreferencia as anoMes "
				+ " from faturamento.faturamento_grupo fg,"
				+ "	cadastro.imovel im, "
				+ "	cadastro.quadra qd, "
				+ " micromedicao.rota rota "
				+ " where im.rota_idalternativa is not null "
				+ " and im.rota_idalternativa = rota.rota_id "
				+ " and rota.ftgr_id = fg.ftgr_id "
				+ " and im.imov_id =:idImovel ";

			anoMesFaturamento = (Integer) session.createSQLQuery(
					sqlMesFaturamentoGrupoRotaAlternativa).addScalar("anoMes",
				Hibernate.INTEGER).setInteger("idImovel",
				idImovel.intValue()).setMaxResults(1).uniqueResult();
			
			if (anoMesFaturamento == null){
				
				String sqlMesFaturamentoGrupo = "select fg.ftgr_amreferencia as anoMes "
					+ " from faturamento.faturamento_grupo fg,"
					+ "	cadastro.imovel im, "
					+ "	cadastro.quadra qd, "
					+ " micromedicao.rota rota "
					+ " where im.qdra_id = qd.qdra_id "
					+ " and qd.rota_id = rota.rota_id "
					+ " and rota.ftgr_id = fg.ftgr_id "
					+ " and im.imov_id =:idImovel ";

				anoMesFaturamento = (Integer) session.createSQLQuery(
					sqlMesFaturamentoGrupo).addScalar("anoMes",
					Hibernate.INTEGER).setInteger("idImovel",
					idImovel.intValue()).setMaxResults(1).uniqueResult();
				
			}
			
			

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return anoMesFaturamento;
	}

	/**
	 * [UC0352] Emitir Contas e Cartas
	 * 
	 * Retorna o cliente usuário 
	 * 
	 * @author Mariana Victor
	 * @date 11/03/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Cliente obterClienteConta(Integer idConta)
			throws ErroRepositorioException {
		Cliente retorno = new Cliente();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cli.nome, cli.nomeAbreviado, "
					+ " cli.indicadorUsoNomeFantasiaConta "
					+ "from ClienteConta cliCnt "
					+ "inner join cliCnt.conta cnt "
					+ "inner join cliCnt.clienteRelacaoTipo crt "
					+ "inner join cliCnt.cliente cli "
					+ "where cnt.id = :idConta AND " + "cliCnt.indicadorNomeConta = :tipoNomeConta ";

			Object[] objeto = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", idConta).setShort("tipoNomeConta",
					ConstantesSistema.SIM).setMaxResults(1).uniqueResult();

			if (objeto[0] != null) {
				retorno.setNome((String) objeto[0]);
			}
			if (objeto[1] != null) {
				retorno.setNomeAbreviado((String) objeto[1]);
			}
			if (objeto[2] != null) {
				retorno.setIndicadorUsoNomeFantasiaConta((Short) objeto[2]);
			}
			
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	/**
	 * [UC1129] Gerar Relatório Devolução dos Pagamentos em Duplicidade
	 * 
	 * @author Hugo Leonardo
	 * @date 10/03/2011
	 * 
	 * @param FiltrarRelatorioDevolucaoPagamentosDuplicidadeHelper
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarRelatorioDevolucaoPagamentosDuplicidade(
			FiltrarRelatorioDevolucaoPagamentosDuplicidadeHelper helper) throws ErroRepositorioException{
		
		Collection retorno = null;
		StringBuffer consulta = new StringBuffer();
		Session session = HibernateUtil.getSession();
		
		try {

			consulta.append(" SELECT loca.loca_id as idLocalidade, "); //0
			consulta.append(" 		 pd.rgat_id as idRA, "); //1
			consulta.append(" 		 paga.imov_id as idImovel, "); //2
			consulta.append(" 		 paga.pgmt_amreferenciapagamento as aMRefPag, "); //3
			consulta.append(" 		 paga.pgmt_vlpagamento as vlPag, "); //4
			consulta.append(" 		 pd.rapd_amreferenciaconta as aMRefCont, "); //5
			consulta.append(" 		 SUM ( COALESCE( cont.cnta_vlagua, 0 ) + COALESCE( cont.cnta_vlesgoto, 0 ) " +
									" + COALESCE( cont.cnta_vldebitos, 0 ) - COALESCE( cont.cnta_vlcreditos, 0 ) " +
									" - COALESCE( cont.cnta_vlimpostos, 0 ) ) as valorContaOriginal, "); //6
			consulta.append(" 		 paga.pgmt_tmultimaalteracao as ultima, "); //7
			consulta.append(" 		 loca.loca_nmlocalidade as nmLocalidade, "); //8
			consulta.append(" 		 gre.greg_id as idGerencia, "); //9
			consulta.append(" 		 gre.greg_nmregional as nmGerencia, "); //10
			consulta.append(" 		 uneg.uneg_id as idUnidade, "); //11
			consulta.append(" 		 uneg.uneg_nmunidadenegocio as nmUnidade "); //12
			consulta.append(" FROM atendimentopublico.ra_pagto_duplicidade pd ");
			consulta.append(" INNER JOIN arrecadacao.pagamento paga ON paga.pgmt_id = pd.pgmt_id ");
			consulta.append(" INNER JOIN faturamento.conta cont ON cont.imov_id = paga.imov_id ");
			consulta.append(" 	AND cont.cnta_amreferenciaconta = paga.pgmt_amreferenciapagamento ");
			consulta.append(" INNER JOIN cadastro.imovel imo ON imo.imov_id = cont.imov_id ");
			consulta.append(" INNER JOIN cadastro.localidade loca ON loca.loca_id = imo.loca_id ");
			consulta.append(" INNER JOIN cadastro.gerencia_regional gre ON gre.greg_id = loca.greg_id ");
			consulta.append(" INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id ");
			
			if(helper.getIdCategoriaImovel() != null){
				
				consulta.append(" INNER JOIN cadastro.vw_imovel_principal_categoria cat ON cat.imov_id = imo.imov_id ");
			}
			
			consulta.append(" WHERE paga.pgst_idatual = 9 ");
			consulta.append(" AND cont.dcst_idatual in (0,1,2) ");
			consulta.append(" AND paga.pgmt_amreferenciapagamento BETWEEN " +
					helper.getAnoMesReferenciaInicial() + " AND " + helper.getAnoMesReferenciaFinal());
			
			// Localidade
			if(helper.getIdLocalidade() != null ){
					
				consulta.append(" AND loca.loca_id = " + helper.getIdLocalidade() ); 
			}
			
			// Gerência
			if(helper.getIdGerencia() != null ){
					
				consulta.append(" AND loca.greg_id = " + helper.getIdGerencia()); 
			}
			
			// Unidade Negócio
			if(helper.getIdUnidadeNegocio() != null ){
					
				consulta.append(" AND loca.uneg_id = " + helper.getIdUnidadeNegocio()); 
			}
			
			// Perfil Imóvel
			if(helper.getIdPerfilImovel() != null ){
					
				consulta.append(" AND imo.iper_id = " + helper.getIdPerfilImovel()); 
			}
			
			// Imóvel Categoria
			if(helper.getIdCategoriaImovel() != null){
				
				consulta.append(" AND cat.catg_id = " + helper.getIdCategoriaImovel());
			}
			
			consulta.append(" GROUP BY  gre.greg_id, ");
			consulta.append("			uneg.uneg_id, ");
			consulta.append("			loca.loca_id, ");
			consulta.append(" 			pd.rgat_id, ");
			consulta.append(" 			paga.imov_id, ");
			consulta.append(" 			paga.pgmt_amreferenciapagamento, ");
			consulta.append(" 			paga.pgmt_vlpagamento, ");
			consulta.append(" 			pd.rapd_amreferenciaconta, ");
			consulta.append(" 			paga.pgmt_tmultimaalteracao, ");
			consulta.append(" 			loca.loca_nmlocalidade, ");
			consulta.append(" 			gre.greg_nmregional, ");
			consulta.append(" 			uneg.uneg_nmunidadenegocio ");
			
			consulta.append(" UNION ");
			
			consulta.append(" SELECT loca.loca_id as idLocalidade, "); //0
			consulta.append(" 		 pd.rgat_id as idRA, "); //1
			consulta.append(" 		 paga.imov_id as idImovel, "); //2
			consulta.append(" 		 paga.pghi_amreferenciapagamento as aMRefPag, "); //3
			consulta.append(" 		 paga.pghi_vlpagamento as vlPag, "); //4
			consulta.append(" 		 pd.rapd_amreferenciaconta as aMRefCont, "); //5
			consulta.append(" 		 SUM ( COALESCE( cont.cnhi_vlagua, 0 ) + COALESCE( cont.cnhi_vlesgoto, 0 ) " +
									" + COALESCE( cont.cnhi_vldebitos, 0 ) - COALESCE( cont.cnhi_vlcreditos, 0 ) " +
									" - COALESCE( cont.cnhi_vlimpostos, 0 ) ) as valorContaOriginal, "); //6
			consulta.append(" 		 paga.pghi_tmultimaalteracao as ultima, "); //7
			consulta.append(" 		 loca.loca_nmlocalidade as nmLocalidade, "); //8
			consulta.append(" 		 gre.greg_id as idGerencia, "); //9
			consulta.append(" 		 gre.greg_nmregional as nmGerencia, "); //10
			consulta.append(" 		 uneg.uneg_id as idUnidade, "); //11
			consulta.append(" 		 uneg.uneg_nmunidadenegocio as nmUnidade "); //12
			consulta.append(" FROM atendimentopublico.ra_pagto_duplicidade pd ");
			consulta.append(" INNER JOIN arrecadacao.pagamento_historico paga ON paga.pghi_id = pd.pgmt_id ");
			
			consulta.append(" INNER JOIN faturamento.conta_historico cont ON cont.imov_id = paga.imov_id ");
			consulta.append(" 	AND cont.cnhi_amreferenciaconta = paga.pghi_amreferenciapagamento ");
			consulta.append(" INNER JOIN cadastro.imovel imo ON imo.imov_id = cont.imov_id ");
			consulta.append(" INNER JOIN cadastro.localidade loca ON loca.loca_id = imo.loca_id ");
			consulta.append(" INNER JOIN cadastro.gerencia_regional gre ON gre.greg_id = loca.greg_id ");
			consulta.append(" INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id ");
			
			if(helper.getIdCategoriaImovel() != null){
				
				consulta.append(" INNER JOIN cadastro.vw_imovel_principal_categoria cat ON cat.imov_id = imo.imov_id ");
			}
			
			consulta.append(" WHERE paga.pgst_idatual = 9 ");
			consulta.append(" AND cont.dcst_idatual in (0,1,2) ");
			consulta.append(" AND paga.pghi_amreferenciapagamento BETWEEN " +
					helper.getAnoMesReferenciaInicial() + " AND " + helper.getAnoMesReferenciaFinal());
			
			// Localidade
			if(helper.getIdLocalidade() != null ){
					
				consulta.append(" AND loca.loca_id = " + helper.getIdLocalidade() ); 
			}
			
			// Gerência
			if(helper.getIdGerencia() != null ){
					
				consulta.append(" AND loca.greg_id = " + helper.getIdGerencia()); 
			}
			
			// Unidade Negócio
			if(helper.getIdUnidadeNegocio() != null ){
					
				consulta.append(" AND loca.uneg_id = " + helper.getIdUnidadeNegocio()); 
			}
			
			// Perfil Imóvel
			if(helper.getIdPerfilImovel() != null ){
					
				consulta.append(" AND imo.iper_id = " + helper.getIdPerfilImovel()); 
			}
			
			// Imóvel Categoria
			if(helper.getIdCategoriaImovel() != null){
				
				consulta.append(" AND cat.catg_id = " + helper.getIdCategoriaImovel());
			}
			
			consulta.append(" GROUP BY  gre.greg_id, ");
			consulta.append("			uneg.uneg_id, ");
			consulta.append("			loca.loca_id, ");
			consulta.append(" 			pd.rgat_id, ");
			consulta.append(" 			paga.imov_id, ");
			consulta.append(" 			paga.pghi_amreferenciapagamento, ");
			consulta.append(" 			paga.pghi_vlpagamento, ");
			consulta.append(" 			pd.rapd_amreferenciaconta, ");
			consulta.append(" 			paga.pghi_tmultimaalteracao, ");
			consulta.append(" 			loca.loca_nmlocalidade, ");
			consulta.append(" 			gre.greg_nmregional, ");
			consulta.append(" 			uneg.uneg_nmunidadenegocio ");
			
			consulta.append(" UNION ");
			
			consulta.append(" SELECT loca.loca_id as idLocalidade, "); //0
			consulta.append(" 		 pd.rgat_id as idRA, "); //1
			consulta.append(" 		 paga.imov_id as idImovel, "); //2
			consulta.append(" 		 paga.pgmt_amreferenciapagamento as aMRefPag, "); //3
			consulta.append(" 		 paga.pgmt_vlpagamento as vlPag, "); //4
			consulta.append(" 		 pd.rapd_amreferenciaconta as aMRefCont, "); //5
			consulta.append(" 		 SUM ( COALESCE( cont.cnhi_vlagua, 0 ) + COALESCE( cont.cnhi_vlesgoto, 0 ) " +
									" + COALESCE( cont.cnhi_vldebitos, 0 ) - COALESCE( cont.cnhi_vlcreditos, 0 ) " +
									" - COALESCE( cont.cnhi_vlimpostos, 0 ) ) as valorContaOriginal, "); //6
			consulta.append(" 		 paga.pgmt_tmultimaalteracao as ultima, "); //7
			consulta.append(" 		 loca.loca_nmlocalidade as nmLocalidade, "); //8
			consulta.append(" 		 gre.greg_id as idGerencia, "); //9
			consulta.append(" 		 gre.greg_nmregional as nmGerencia, "); //10
			consulta.append(" 		 uneg.uneg_id as idUnidade, "); //11
			consulta.append(" 		 uneg.uneg_nmunidadenegocio as nmUnidade "); //12
			consulta.append(" FROM atendimentopublico.ra_pagto_duplicidade pd ");
			consulta.append(" INNER JOIN arrecadacao.pagamento paga ON paga.pgmt_id = pd.pgmt_id ");
			consulta.append(" INNER JOIN faturamento.conta_historico cont ON cont.imov_id = paga.imov_id ");
			consulta.append(" 	AND cont.cnhi_amreferenciaconta = paga.pgmt_amreferenciapagamento ");
			consulta.append(" INNER JOIN cadastro.imovel imo ON imo.imov_id = cont.imov_id ");
			consulta.append(" INNER JOIN cadastro.localidade loca ON loca.loca_id = imo.loca_id ");
			consulta.append(" INNER JOIN cadastro.gerencia_regional gre ON gre.greg_id = loca.greg_id ");
			consulta.append(" INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id ");
			
			if(helper.getIdCategoriaImovel() != null){
				
				consulta.append(" INNER JOIN cadastro.vw_imovel_principal_categoria cat ON imo.imov_id = cont.imov_id ");
			}
			
			consulta.append(" WHERE paga.pgst_idatual = 9 ");
			consulta.append(" AND cont.dcst_idatual in (0,1,2) ");
			consulta.append(" AND paga.pgmt_amreferenciapagamento BETWEEN " +
					helper.getAnoMesReferenciaInicial() + " AND " + helper.getAnoMesReferenciaFinal());
			
			// Localidade
			if(helper.getIdLocalidade() != null ){
					
				consulta.append(" AND loca.loca_id = " + helper.getIdLocalidade() ); 
			}
			
			// Gerência
			if(helper.getIdGerencia() != null ){
					
				consulta.append(" AND loca.greg_id = " + helper.getIdGerencia()); 
			}
			
			// Unidade Negócio
			if(helper.getIdUnidadeNegocio() != null ){
					
				consulta.append(" AND loca.uneg_id = " + helper.getIdUnidadeNegocio()); 
			}
			
			// Perfil Imóvel
			if(helper.getIdPerfilImovel() != null ){
					
				consulta.append(" AND imo.iper_id = " + helper.getIdPerfilImovel()); 
			}
			
			// Imóvel Categoria
			if(helper.getIdCategoriaImovel() != null){
				
				consulta.append(" AND cat.catg_id = " + helper.getIdCategoriaImovel());
			}
			
			consulta.append(" GROUP BY  gre.greg_id, ");
			consulta.append("			uneg.uneg_id, ");
			consulta.append("			loca.loca_id, ");
			consulta.append(" 			pd.rgat_id, ");
			consulta.append(" 			paga.imov_id, ");
			consulta.append(" 			paga.pgmt_amreferenciapagamento, ");
			consulta.append(" 			paga.pgmt_vlpagamento, ");
			consulta.append(" 			pd.rapd_amreferenciaconta, ");
			consulta.append(" 			paga.pgmt_tmultimaalteracao, ");
			consulta.append(" 			loca.loca_nmlocalidade, ");
			consulta.append(" 			gre.greg_nmregional, ");
			consulta.append(" 			uneg.uneg_nmunidadenegocio ");
			
			consulta.append(" ORDER BY idGerencia, idUnidade, idLocalidade ");
			
			retorno = (Collection) session.createSQLQuery(consulta.toString().trim())
				.addScalar("idLocalidade", Hibernate.INTEGER)
				.addScalar("idRA", Hibernate.INTEGER)
				.addScalar("idImovel", Hibernate.INTEGER)
				.addScalar("aMRefPag", Hibernate.INTEGER)
				.addScalar("vlPag", Hibernate.BIG_DECIMAL)
				.addScalar("aMRefCont", Hibernate.INTEGER)
				.addScalar("valorContaOriginal", Hibernate.BIG_DECIMAL)
				.addScalar("ultima", Hibernate.DATE)
				.addScalar("nmLocalidade", Hibernate.STRING)
				.addScalar("idGerencia", Hibernate.INTEGER)
				.addScalar("nmGerencia", Hibernate.STRING)
				.addScalar("idUnidade", Hibernate.INTEGER)
				.addScalar("nmUnidade", Hibernate.STRING)
				.list();
			 
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	
	/**
	 * [UC1129] - Relatorio Devolucao dos Pagamentos em Duplicidade
	 * 
	 * @param idImovel Id do Imovel
	 * @param anoMesCobrancaCredito Ano/Mes da cobranca do credito
	 * 
	 * @throws ErroRepositorioException Erro no hibernate
	 */
	public BigDecimal pesquisarValorCreditosARealizar(
			Integer idImovel,Integer anoMesCredito) throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			
			consulta = "select sum(creditoare0_.crar_vlcredito) as valor "
				+ "from faturamento.credito_a_realizar creditoare0_ "
				+ "where creditoare0_.imov_id = :idImovel "
				+ "and creditoare0_.crar_amreferenciacredito = :anoMesReferenciaCredito "
				+ "and creditoare0_.dcst_idatual in (0,1,2) "
				+ "and creditoare0_.crti_id = :creditoTipo ";				

		// executa o hql
		retorno = (BigDecimal) session.createSQLQuery(consulta).
			addScalar("valor", Hibernate.BIG_DECIMAL).
			setInteger("idImovel",idImovel).
			setInteger("creditoTipo",CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE).
			setInteger("anoMesReferenciaCredito",anoMesCredito).
			setMaxResults(1).
			uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1129] - Relatorio Devolucao dos Pagamentos em Duplicidade
	 * 
	 * @param idImovel Id do Imovel
	 * @param anoMesCobrancaCredito Ano/Mes da cobranca do credito
	 * 
	 * @throws ErroRepositorioException Erro no hibernate
	 */
	public BigDecimal pesquisarValorCreditosARealizarHistorico(
			Integer idImovel,Integer anoMesCredito) throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			consulta = "select sum(creditoare0_.carh_vlcredito) as valor "
				+ "from faturamento.cred_a_realiz_hist creditoare0_ "
				+ "where creditoare0_.imov_id = :idImovel "
				+ "and creditoare0_.carh_amreferenciacredito = :anoMesReferenciaCredito "
				+ "and creditoare0_.dcst_idatual in (0,1,2) "
				+ "and creditoare0_.crti_id = :creditoTipo ";		

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valor", Hibernate.BIG_DECIMAL).
				setInteger("idImovel",idImovel).
				setInteger("creditoTipo",CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE).
				setInteger("anoMesReferenciaCredito",anoMesCredito).
				setMaxResults(1).
				uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC1129] - Relatorio Devolucao dos Pagamentos em Duplicidade
	 * 
	 * @param idImovel Id do Imovel
	 * @param anoMesCobrancaCredito Ano/Mes da cobranca do credito
	 * 
	 * @throws ErroRepositorioException Erro no hibernate
	 */
	public Collection<CreditoRealizado> pesquisarCreditosRealizado(
			Integer idImovel,Integer anoMesCobrancaCredito) throws ErroRepositorioException {

		Collection<CreditoRealizado> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select crrz " 
					+ "from CreditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "INNER JOIN FETCH crrz.creditoTipo crtp "
					+ "where cnta.imovel.id = :idImovel "
					+ "and cnta.debitoCreditoSituacaoAtual in (0,1,2) "
					+ "and crrz.anoMesCobrancaCredito = :anoMesCobrancaCredito "
					+ "and crtp.id = :creditoTipo "
					+ "ORDER BY crtp.id, crrz.anoMesReferenciaCredito ";

			// executa o hql
			retorno = session.createQuery(consulta).
				setInteger("idImovel",idImovel).
				setInteger("creditoTipo",CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE).
				setInteger("anoMesCobrancaCredito",anoMesCobrancaCredito).
				list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1129] - Relatorio Devolucao dos Pagamentos em Duplicidade
	 * 
	 * @param idImovel Id do Imovel
	 * @param anoMesCobrancaCredito Ano/Mes da cobranca do credito
	 * 
	 * @throws ErroRepositorioException Erro no hibernate
	 */
	public Collection<CreditoRealizadoHistorico> pesquisarCreditosRealizadoHistorico(
			Integer idImovel,Integer anoMesCobrancaCredito) throws ErroRepositorioException {

		Collection<CreditoRealizadoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select crrz " 
					+ "from CreditoRealizadoHistorico crrz "
					+ "inner join crrz.contaHistorico cnta "
					+ "INNER JOIN FETCH crrz.creditoTipo crtp "
					+ "where cnta.imovel.id = :idImovel "
					+ "and cnta.debitoCreditoSituacaoAtual in (0,1,2) "
					+ "and crrz.anoMesCobrancaCredito = :anoMesCobrancaCredito "
					+ "and crtp.id = :creditoTipo "
					+ "ORDER BY crtp.id, crrz.anoMesReferenciaCredito ";

			// executa o hql
			retorno = session.createQuery(consulta).
				setInteger("idImovel",idImovel).
				setInteger("anoMesCobrancaCredito",anoMesCobrancaCredito).
				setInteger("creditoTipo",CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE).
				list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1157] Seleciona Comando para Retirar Imóvel da Tarifa Social
	 * [SB0003] Excluir Comando Selecionado 
	 * 
	 * @author Vivianne Sousa
	 * @date 01/04/2011
	 * 
	 * @exception ErroRepositorioException
	 */
	public Integer pesquisarQtdeContaNaoPaga(Collection idContas) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(ct.id) " +
					" from Conta ct "
					+ "where  ct.id in (:idContas) and "
					+ "ct.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)" 
//					+ "and NOT EXISTS (SELECT pgmt.id FROM Pagamento pgmt WHERE pgmt.contaGeral.id in (:idContas)) ";
					+ "and NOT EXISTS (SELECT pgmt.id FROM Pagamento pgmt WHERE pgmt.contaGeral.id = ct.id) ";

			retorno = (Integer) session.createQuery(consulta)
			.setParameterList("idContas",idContas)
			.setInteger("normal",
					DebitoCreditoSituacao.NORMAL).setInteger("incluida",
					DebitoCreditoSituacao.INCLUIDA).setInteger("retificada",
					DebitoCreditoSituacao.RETIFICADA).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 10/03/2011
	 * 
	 * @throws ErroRepositorioException
	 */
    public Integer gerarSequencialContaBoleto() throws ErroRepositorioException {

        Session session = HibernateUtil.getSession();

        Integer retorno = null;
        String consulta = null;
        
        try {
        	
    		consulta = "select faturamento.seq_conta_numero_boleto.nextval as sequencial from dual ";
    		
    		retorno = (Integer) session.createSQLQuery(consulta).addScalar("sequencial", Hibernate.INTEGER).uniqueResult();

        } catch (HibernateException e) {
            // levanta a exceção para a próxima camada
            throw new ErroRepositorioException(e, "Erro no Hibernate");
        } finally {
            // fecha a sessão
            HibernateUtil.closeSession(session);
        }

        return retorno;

    }
    
    /**
	 * [UC0352] Emitir Contas e Cartas
	 * 
	 * [SB0031] Obter Representação numérica do Nosso Número da Ficha de Compensação
	 * 
	 * @author Raphael Rossiter
	 * @date 10/03/2011
	 * 
	 * @throws ErroRepositorioException
	 */
    public Integer pesquisarSequencialContaBoleto(Integer idConta)throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		
		try {

			consulta = "select cnta_nnboleto as numeroBoleto "
				+ "from faturamento.conta where cnta_id = :idConta";

			retorno = (Integer)session.createSQLQuery(consulta).addScalar("numeroBoleto", Hibernate.INTEGER)
				.setInteger("idConta",idConta)
				.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
    
    /**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação 
	 *
	 * @author Raphael Rossiter
	 * @date 15/03/2011
	 *
	 * @param nnBoleto
	 * @return Conta
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarExistenciaContaPorNumeroBoleto(Integer nnBoleto)
			throws ErroRepositorioException {

		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct " + "from Conta ct "
					+ "inner join fetch ct.imovel imov "
					+ "inner join fetch imov.localidade loc "
					+ "inner join fetch ct.debitoCreditoSituacaoAtual "
					+ "where ct.numeroBoleto = :nnBoleto ";

			retorno = (Conta) session.createQuery(consulta).setInteger("nnBoleto", nnBoleto).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação 
	 *
	 * @author Raphael Rossiter
	 * @date 15/03/2011
	 *
	 * @param nnBoleto
	 * @return Conta
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarExistenciaContaPorIdentificadorEValor(Integer idConta, BigDecimal valorPagamento)
			throws ErroRepositorioException {

		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct " + "from Conta ct "
					+ "inner join fetch ct.imovel imov "
					+ "inner join fetch imov.localidade loc "
					+ "inner join fetch ct.debitoCreditoSituacaoAtual "
					+ "where ct.id = :idConta and "
					+ "((ct.valorAgua + ct.valorEsgoto + ct.debitos) - (ct.valorCreditos + coalesce(ct.valorImposto,0))) = :valorPagamento ";

			retorno = (Conta) session.createQuery(consulta).setInteger("idConta", idConta)
			.setBigDecimal("valorPagamento", valorPagamento).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação 
	 *
	 * @author Raphael Rossiter
	 * @date 15/03/2011
	 *
	 * @param nnBoleto
	 * @return Conta
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarExistenciaContaPorIdentificadorTruncadoEValor(Integer idConta, BigDecimal valorPagamento)
			throws ErroRepositorioException {

		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			
			String identificadores = "";
			
			for (int i = 0; i <= 9; i++) {
				
				identificadores = identificadores + idConta.toString() + i + ",";
			}
			
			identificadores = identificadores.substring(0, identificadores.length() - 1);
			
			consulta = "select ct " + "from Conta ct "
					+ "inner join fetch ct.imovel imov "
					+ "inner join fetch imov.localidade loc "
					+ "inner join fetch ct.debitoCreditoSituacaoAtual "
					+ "where ct.id in( " + identificadores + " ) and "
					+ "((ct.valorAgua + ct.valorEsgoto + ct.debitos) - (ct.valorCreditos + coalesce(ct.valorImposto,0))) = :valorPagamento ";

			retorno = (Conta) session.createQuery(consulta).setBigDecimal("valorPagamento", valorPagamento).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação 
	 *
	 * @author Raphael Rossiter
	 * @date 15/03/2011
	 *
	 * @param nnBoleto
	 * @return ContaHistorico
	 * @throws ErroRepositorioException
	 */
	public ContaHistorico pesquisarExistenciaContaHistoricoPorNumeroBoleto(Integer nnBoleto)
			throws ErroRepositorioException {

		ContaHistorico retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct " + "from ContaHistorico ct "
					+ "inner join fetch ct.imovel imov "
					+ "inner join fetch imov.localidade loc "
					+ "inner join fetch ct.debitoCreditoSituacaoAtual "
					+ "where ct.numeroBoleto = :nnBoleto ";

			retorno = (ContaHistorico) session.createQuery(consulta)
					.setInteger("nnBoleto", nnBoleto).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação 
	 *
	 * @author Raphael Rossiter
	 * @date 15/03/2011
	 *
	 * @param nnBoleto
	 * @return ContaHistorico
	 * @throws ErroRepositorioException
	 */
	public ContaHistorico pesquisarExistenciaContaHistoricoPorIdentificadorEValor(Integer idConta, BigDecimal valorPagamento)
			throws ErroRepositorioException {

		ContaHistorico retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct " + "from ContaHistorico ct "
					+ "inner join fetch ct.imovel imov "
					+ "inner join fetch imov.localidade loc "
					+ "inner join fetch ct.debitoCreditoSituacaoAtual "
					+ "where ct.id = :idConta and "
					+ "((ct.valorAgua + ct.valorEsgoto + ct.valorDebitos) - (ct.valorCreditos + coalesce(ct.valorImposto,0))) = :valorPagamento ";

			retorno = (ContaHistorico) session.createQuery(consulta)
			.setInteger("idConta", idConta).setBigDecimal("valorPagamento", valorPagamento).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação 
	 *
	 * @author Raphael Rossiter
	 * @date 15/03/2011
	 *
	 * @param nnBoleto
	 * @return ContaHistorico
	 * @throws ErroRepositorioException
	 */
	public ContaHistorico pesquisarExistenciaContaHistoricoPorIdentificadorTruncadoEValor(Integer idConta, BigDecimal valorPagamento)
			throws ErroRepositorioException {

		ContaHistorico retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			
			String identificadores = "";
			
			for (int i = 0; i <= 9; i++) {
				
				identificadores = identificadores + idConta.toString() + i + ",";
			}
			
			identificadores = identificadores.substring(0, identificadores.length() - 1);
			
			consulta = "select ct " + "from ContaHistorico ct "
				+ "inner join fetch ct.imovel imov "
				+ "inner join fetch imov.localidade loc "
				+ "inner join fetch ct.debitoCreditoSituacaoAtual "
				+ "where ct.id in( " + identificadores + " ) and "
				+ "((ct.valorAgua + ct.valorEsgoto + ct.valorDebitos) - (ct.valorCreditos + coalesce(ct.valorImposto,0))) = :valorPagamento ";

			retorno = (ContaHistorico) session.createQuery(consulta).setBigDecimal("valorPagamento", valorPagamento).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	private String criarCondicionaisPesquisarQuantidadeContas(
			ComandoEmpresaCobrancaContaHelper comandoEmpresaCobrancaContaHelper, boolean agrupadoPorImovel) {
		String retorno = "";

		if (agrupadoPorImovel) {
			retorno = retorno + " (emprCobConta.ecco_id is null or cecc.cecc_dtencerramento is not null) ";			
		} else {
			retorno = retorno + " emprCobConta.ecco_id is null ";
		}
		
		retorno = retorno 
				+ " AND conta.cmrv_id        IS NULL "
				+ " AND conta.cnta_dtrevisao IS NULL ";
		
		retorno = retorno + " and conta.dcst_idatual in ( "
				+ DebitoCreditoSituacao.NORMAL
				+ ", "
				+ DebitoCreditoSituacao.INCLUIDA
				+ ", "
				+ DebitoCreditoSituacao.RETIFICADA + " ) ";
		
		ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta();

		
		if (comandoEmpresaCobrancaConta.getImovel() != null) {
			retorno = retorno + " and conta.imov_id = "
					+ comandoEmpresaCobrancaConta.getImovel().getId();
		}

		if (comandoEmpresaCobrancaConta.getCliente() != null) {
			retorno = retorno + " and clieConta.clie_id = "
					+ comandoEmpresaCobrancaConta.getCliente().getId();
		}

		if (comandoEmpresaCobrancaConta.getUnidadeNegocio() != null) {
			
			retorno = retorno + " and loca.uneg_id = "
					+ comandoEmpresaCobrancaConta.getUnidadeNegocio().getId();
			
		} else if (comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio() != null
				&& !comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().isEmpty()) {
			
			boolean consulta = true;
			if(comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().size() == 1){
				Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().iterator();
				while(it.hasNext()){
					UnidadeNegocio obj = (UnidadeNegocio) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				Iterator iterator = comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().iterator();
				UnidadeNegocio unidadeNegocio = null;
				retorno = retorno + " and loca.uneg_id in (";
				while (iterator.hasNext()) {
					unidadeNegocio = (UnidadeNegocio) iterator.next();
					retorno = retorno + unidadeNegocio.getId() + ",";
				}
				retorno = Util.removerUltimosCaracteres(retorno, 1);
				retorno = retorno + ") ";
			}
			
		}
		

		if (comandoEmpresaCobrancaConta.getGerenciaRegional() != null) {
			
			retorno = retorno + " and loca.greg_id = "
					+ comandoEmpresaCobrancaConta.getGerenciaRegional().getId();
			
		} else if (comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional() != null
				&& !comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().isEmpty()) {
			
			boolean consulta = true;
			if(comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().size() == 1){
				Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().iterator();
				while(it.hasNext()){
					GerenciaRegional obj = (GerenciaRegional) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				Iterator iterator = comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().iterator();
				GerenciaRegional gerenciaRegional = null;
				retorno = retorno + " and loca.greg_id in (";
				while (iterator.hasNext()) {
					gerenciaRegional = (GerenciaRegional) iterator.next();
					retorno = retorno + gerenciaRegional.getId() + ",";
				}
				retorno = Util.removerUltimosCaracteres(retorno, 1);
				retorno = retorno + ") ";
			}
			
		}

		if (comandoEmpresaCobrancaConta.getImovelPerfil() != null) {
			
			retorno = retorno + " and imov.iper_id = "
					+ comandoEmpresaCobrancaConta.getImovelPerfil().getId();
			
		} else if (comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil() != null
				&& !comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().isEmpty()) {
			
			boolean consulta = true;
			if(comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().size() == 1){
				Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().iterator();
				while(it.hasNext()){
					ImovelPerfil obj = (ImovelPerfil) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				Iterator iterator = comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().iterator();
				ImovelPerfil imovelPerfil = null;
				retorno = retorno + " and imov.iper_id in (";
				while (iterator.hasNext()) {
					imovelPerfil = (ImovelPerfil) iterator.next();
					retorno = retorno + imovelPerfil.getId() + ",";
				}
				retorno = Util.removerUltimosCaracteres(retorno, 1);
				retorno = retorno + ") ";
			}
			
		}

		if (comandoEmpresaCobrancaConta.getLigacaoAguaSituacao() != null) {
			
			retorno = retorno + " and imov.last_id = "
					+ comandoEmpresaCobrancaConta.getLigacaoAguaSituacao().getId();
			
		} else if (comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao() != null
				&& !comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().isEmpty()) {
			
			boolean consulta = true;
			if(comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().size() == 1){
				Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().iterator();
				while(it.hasNext()){
					LigacaoAguaSituacao obj = (LigacaoAguaSituacao) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				Iterator iterator = comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().iterator();
				LigacaoAguaSituacao ligacaoAguaSituacao = null;
				retorno = retorno + " and imov.last_id in (";
				while (iterator.hasNext()) {
					ligacaoAguaSituacao = (LigacaoAguaSituacao) iterator.next();
					retorno = retorno + ligacaoAguaSituacao.getId() + ",";
				}
				retorno = Util.removerUltimosCaracteres(retorno, 1);
				retorno = retorno + ") ";
			}
			
		}

		if (comandoEmpresaCobrancaConta.getLocalidadeInicial() != null) {
			retorno = retorno
					+ " and loca.loca_id between "
					+ comandoEmpresaCobrancaConta.getLocalidadeInicial()
							.getId() + " and "
					+ comandoEmpresaCobrancaConta.getLocalidadeFinal().getId();
		}

		if (comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_cdsetorcomercial between "
					+ comandoEmpresaCobrancaConta
							.getCodigoSetorComercialInicial()
					+ " and "
					+ comandoEmpresaCobrancaConta
							.getCodigoSetorComercialFinal();
		}

		if (comandoEmpresaCobrancaConta.getQuadraInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_nnquadra between "
					+ comandoEmpresaCobrancaConta.getQuadraInicial()
							.getNumeroQuadra() + " and "
					+ comandoEmpresaCobrancaConta.getQuadraFinal().getNumeroQuadra();
		}

		if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {
			retorno = retorno + " and conta.cnta_amreferenciaconta between "
					+ comandoEmpresaCobrancaConta.getReferenciaContaInicial()
					+ " and "
					+ comandoEmpresaCobrancaConta.getReferenciaContaFinal();
		}

		if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_dtvencimentoconta between to_date('"
					+ Util
							.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
									.getDataVencimentoContaInicial())
					+ "','YYYY-MM-DD') and to_date('"
					+ Util
							.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
									.getDataVencimentoContaFinal()) + "','YYYY-MM-DD')";
		}

		if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {
			retorno = retorno
					+ " and ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) between "
					+ comandoEmpresaCobrancaConta.getValorMinimoConta()
					+ " and "
					+ comandoEmpresaCobrancaConta.getValorMaximoConta();
		}

		if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {
			retorno = retorno
					+ " and conta.cnta_dtvencimentoconta < to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(Util.subtrairNumeroDiasDeUmaData(
							new Date(), comandoEmpresaCobrancaConta.getQtdDiasVencimento())) 
						+ "','YYYY-MM-DD')";
		}

		return retorno;
	}


	private String criarCondicionaisPesquisarQuantidadeContasComParametros(
			ComandoEmpresaCobrancaContaHelper comandoEmpresaCobrancaContaHelper) {
		String retorno = "";
		
		retorno = retorno + " conta.dcst_idatual in ( "
				+ ":debitoCreditoSituacaoNormal"
				+ ", "
				+ ":debitoCreditoSituacaoIncluida"
				+ ", "
				+ ":debitoCreditoSituacaoRetificada" 
				+ " ) ";
		
		ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta();
		
		if (comandoEmpresaCobrancaConta.getImovel() != null) {
			retorno = retorno + " and conta.imov_id = "
					+ ":idImovel";
		}

		if (comandoEmpresaCobrancaConta.getCliente() != null) {
			retorno = retorno + " and clieConta.clie_id = "
					+ ":idCliente";
		}

		if (comandoEmpresaCobrancaConta.getUnidadeNegocio() != null) {
			
			retorno = retorno + " and loca.uneg_id = "
					+ ":idUnidadeNegocio";
			
		} else if (comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio() != null
				&& !comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().isEmpty()) {
			
			boolean consulta = true;
			if(comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().size() == 1){
				Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().iterator();
				while(it.hasNext()){
					UnidadeNegocio obj = (UnidadeNegocio) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				retorno = retorno + " and loca.uneg_id in (:idsUnidadeNegocio)";
			}
			
		}
		

		if (comandoEmpresaCobrancaConta.getGerenciaRegional() != null) {
			
			retorno = retorno + " and loca.greg_id = "
					+ ":idGerenciaRegional";
			
		} else if (comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional() != null
				&& !comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().isEmpty()) {
			
			boolean consulta = true;
			if(comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().size() == 1){
				Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().iterator();
				while(it.hasNext()){
					GerenciaRegional obj = (GerenciaRegional) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				retorno = retorno + " and loca.greg_id in (:idsGerenciaRegional)";
			}
			
		}

		if (comandoEmpresaCobrancaConta.getImovelPerfil() != null) {
			
			retorno = retorno + " and imov.iper_id = "
					+ ":idImovelPerfil";
			
		} else if (comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil() != null
				&& !comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().isEmpty()) {
			
			boolean consulta = true;
			if(comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().size() == 1){
				Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().iterator();
				while(it.hasNext()){
					ImovelPerfil obj = (ImovelPerfil) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				retorno = retorno + " and imov.iper_id in (:idsImovelPerfil)";
			}
			
		}

		if (comandoEmpresaCobrancaConta.getLigacaoAguaSituacao() != null) {
			
			retorno = retorno + " and imov.last_id = "
					+ ":idLigacaoAguaSituacao";
			
		} else if (comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao() != null
				&& !comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().isEmpty()) {
			
			boolean consulta = true;
			if(comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().size() == 1){
				Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().iterator();
				while(it.hasNext()){
					LigacaoAguaSituacao obj = (LigacaoAguaSituacao) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				retorno = retorno + " and imov.last_id in (:idsLigacaoAguaSituacao)";
			}
			
		}

		if (comandoEmpresaCobrancaConta.getLocalidadeInicial() != null) {
			retorno = retorno
					+ " and loca.loca_id between :idLocaInicial"
					+ " and :idLocaFinal";
		}

		if (comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_cdsetorcomercial between :idSetorInicial"
					+ " and :idSetorFinal";
		}

		if (comandoEmpresaCobrancaConta.getQuadraInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_nnquadra between :idQuadraInicial "
					+ " and :idQuadraFinal ";
		}

		if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {
			retorno = retorno + " and conta.cnta_amreferenciaconta between :idAnoMesInicial "
					+ " and :idAnoMesFinal ";
		}

		if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_dtvencimentoconta between :dataInicial and :dataFinal ";
		}

		if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {
			retorno = retorno
					+ " and ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) between "
					+ " :valorMaximoConta "
					+ " and "
					+ " :valorMinimoConta ";
		}

		if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {
			retorno = retorno
					+ " and conta.cnta_dtvencimentoconta < :dataMaximaVencimento ";
		}

		return retorno;
	}
	
	/**
	 * [UC0866] Gerar Comando Contas em Cobrança por Empresa
	 * 
	 * Pesquisa a quantidade de contas, agrupando por imóvel
	 * 
	 * @author: Mariana Victor
	 * @date: 07/04/2011
	 */
	public Collection<Object[]> pesquisarQuantidadeContasAgrupandoPorImovel(
			ComandoEmpresaCobrancaContaHelper comandoEmpresaCobrancaContaHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta();
		
		try {
			consulta = "SELECT COUNT(DISTINCT conta.cnta_id) as qtdContas, "
					+ "COUNT(DISTINCT conta.imov_id) as qtdImovel, "
					+ "SUM ( coalesce( conta.cnta_vlagua, 0 ) + "
					+ "coalesce( conta.cnta_vlesgoto, 0 ) + "
					+ "coalesce( conta.cnta_vldebitos, 0 ) - "
					+ "coalesce( conta.cnta_vlcreditos, 0 ) - "
					+ "coalesce( conta.cnta_vlimpostos, 0 ) "
					+ ") as valorTotalDebitos "
					+ " FROM faturamento.conta conta ";

			if (comandoEmpresaCobrancaConta.getCliente() != null) {
				consulta = consulta
					+ " INNER JOIN cadastro.cliente_conta clieConta "
					+ "   on clieConta.cnta_id = conta.cnta_id "
					+ "   AND clieConta.crtp_id = :clienteUsuario ";
			}

			consulta = consulta
					+ " INNER JOIN cadastro.imovel imov "
					+ "   on imov.imov_id = conta.imov_id ";
			
			if (comandoEmpresaCobrancaConta.getUnidadeNegocio() != null
					|| (comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio() != null
							&& !comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().isEmpty())
					|| comandoEmpresaCobrancaConta.getGerenciaRegional() != null
					|| (comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional() != null
							&& !comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().isEmpty())
					|| comandoEmpresaCobrancaConta.getLocalidadeInicial() != null
				) {
				
				consulta = consulta
					+ " INNER JOIN cadastro.localidade loca "
					+ "   on loca.loca_id = imov.loca_id ";
				
			}

			consulta = consulta
					+ " LEFT OUTER JOIN cobranca.cobranca_situacao cbst "
					+ "   ON cbst.cbst_id = imov.cbst_id " + " WHERE ";
			
			consulta = consulta 
					+ " (imov.cbst_id IS NULL or cbst.cbst_icnaocobranca <> 1) "
					+ " AND imov.imov_id NOT IN (SELECT imov_id FROM cobranca.cobranca_situacao_hist WHERE cbsh_amcobrancaretirada IS NULL) " 
					+ " AND conta.cmrv_id is null and conta.cnta_dtrevisao is null "
					+ " AND ";

			consulta = consulta
					+ " NOT EXISTS (SELECT pagto.pgmt_id "
					+ "    FROM arrecadacao.pagamento pagto "
					+ "    WHERE pagto.cnta_id = conta.cnta_id) AND ";
			
			consulta = consulta
					+ " NOT EXISTS (SELECT emprCobConta.imov_id FROM cobranca.empresa_cobranca_conta emprCobConta "
					+ "      INNER JOIN cobranca.cmd_empr_cobr_conta cecc ON emprCobConta.cecc_id = cecc.cecc_id "
					+ "     WHERE emprCobConta.imov_id = imov.imov_id AND cecc.cecc_dtencerramento is null) AND ";
			
			if ((comandoEmpresaCobrancaConta.getIndicadorResidencial() != null && !comandoEmpresaCobrancaConta
					.getIndicadorResidencial().equals(
							ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorComercial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorComercial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorIndustrial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorPublico() != null && !comandoEmpresaCobrancaConta
							.getIndicadorPublico().equals(
									ConstantesSistema.NAO.intValue()))) {
				
				consulta = consulta + " imov.imov_idcategoriaprincipal in (:idsCategoria) AND ";
			}
			
			consulta = consulta
					+ criarCondicionaisPesquisarQuantidadeContasComParametros(comandoEmpresaCobrancaContaHelper);

			consulta = consulta + " GROUP BY conta.imov_id ";

			if (comandoEmpresaCobrancaConta.getQtdContasInicial() != null) {
				consulta = consulta + " HAVING count(DISTINCT conta.cnta_id) between :qtdContasInicial  and  :qtdContasFinal ";
			}
			
			Query query = session.createSQLQuery(consulta).addScalar(
					"qtdContas", Hibernate.INTEGER).addScalar("qtdImovel",
					Hibernate.INTEGER).addScalar("valorTotalDebitos",
					Hibernate.BIG_DECIMAL).setInteger("debitoCreditoSituacaoNormal", 
					DebitoCreditoSituacao.NORMAL).setInteger("debitoCreditoSituacaoIncluida", 
					DebitoCreditoSituacao.INCLUIDA).setInteger("debitoCreditoSituacaoRetificada", 
					DebitoCreditoSituacao.RETIFICADA);
		
			
			if (comandoEmpresaCobrancaConta.getImovel() != null) {
				query = query.setInteger("idImovel",comandoEmpresaCobrancaConta.getImovel().getId());
			}
	
			if (comandoEmpresaCobrancaConta.getCliente() != null) {
				query = query.setInteger("clienteUsuario", ClienteRelacaoTipo.USUARIO);
				query = query.setInteger("idCliente",comandoEmpresaCobrancaConta.getCliente().getId());
			}
	
			if (comandoEmpresaCobrancaConta.getUnidadeNegocio() != null) {
				
				query = query.setInteger("idUnidadeNegocio",comandoEmpresaCobrancaConta.getUnidadeNegocio().getId());
				
			} else if (comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio() != null
					&& !comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().isEmpty()) {
				
				boolean consultar = true;
				if(comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().size() == 1){
					Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().iterator();
					while(it.hasNext()){
						UnidadeNegocio obj = (UnidadeNegocio) it.next();
						if(obj != null && obj.getId() == -1){
							consultar = false;
						}
					}	
				}
				if(consultar){	
					Iterator iterator = comandoEmpresaCobrancaContaHelper.getColecaoUnidadeNegocio().iterator();
					UnidadeNegocio unidadeNegocio = null;
					Collection<Integer> idsUnidadeNegocio = new ArrayList();
					while (iterator.hasNext()) {
						unidadeNegocio = (UnidadeNegocio) iterator.next();
						idsUnidadeNegocio.add(unidadeNegocio.getId());
					}
					query = query.setParameterList("idsUnidadeNegocio",idsUnidadeNegocio);
				}
				
			}
			
	
			if (comandoEmpresaCobrancaConta.getGerenciaRegional() != null) {
	
				query = query.setInteger("idGerenciaRegional",comandoEmpresaCobrancaConta.getGerenciaRegional().getId());
				
			} else if (comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional() != null
					&& !comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().isEmpty()) {
				
				boolean consultar = true;
				if(comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().size() == 1){
					Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().iterator();
					while(it.hasNext()){
						GerenciaRegional obj = (GerenciaRegional) it.next();
						if(obj != null && obj.getId() == -1){
							consultar = false;
						}
					}	
				}
				if(consultar){	
					Iterator iterator = comandoEmpresaCobrancaContaHelper.getColecaoGerenciaRegional().iterator();
					GerenciaRegional gerenciaRegional = null;
					Collection<Integer> idsGerenciaRegional = new ArrayList();
					while (iterator.hasNext()) {
						gerenciaRegional = (GerenciaRegional) iterator.next();
						idsGerenciaRegional.add(gerenciaRegional.getId());
					}
					query = query.setParameterList("idsGerenciaRegional",idsGerenciaRegional);
				}
				
			}
	
			if (comandoEmpresaCobrancaConta.getImovelPerfil() != null) {
	
				query = query.setInteger("idImovelPerfil",comandoEmpresaCobrancaConta.getImovelPerfil().getId());
				
			} else if (comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil() != null
					&& !comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().isEmpty()) {
				
				boolean consultar = true;
				if(comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().size() == 1){
					Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().iterator();
					while(it.hasNext()){
						ImovelPerfil obj = (ImovelPerfil) it.next();
						if(obj != null && obj.getId() == -1){
							consultar = false;
						}
					}	
				}
				if(consultar){	
					Iterator iterator = comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil().iterator();
					ImovelPerfil imovelPerfil = null;
					Collection<Integer> idsImovelPerfil = new ArrayList();
					while (iterator.hasNext()) {
						imovelPerfil = (ImovelPerfil) iterator.next();
						idsImovelPerfil.add(imovelPerfil.getId());
					}
					query = query.setParameterList("idsImovelPerfil",idsImovelPerfil);
				}
				
			}
	
			if (comandoEmpresaCobrancaConta.getLigacaoAguaSituacao() != null) {
	
				query = query.setInteger("idLigacaoAguaSituacao",
						comandoEmpresaCobrancaConta.getLigacaoAguaSituacao().getId());
				
			} else if (comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao() != null
					&& !comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().isEmpty()) {
				
				boolean consultar = true;
				if(comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().size() == 1){
					Iterator it = comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().iterator();
					while(it.hasNext()){
						LigacaoAguaSituacao obj = (LigacaoAguaSituacao) it.next();
						if(obj != null && obj.getId() == -1){
							consultar = false;
						}
					}	
				}
				if(consultar){	
					Iterator iterator = comandoEmpresaCobrancaContaHelper.getColecaoLigacaoAguaSituacao().iterator();
					LigacaoAguaSituacao ligacaoAguaSituacao = null;
					Collection<Integer> idsLigacaoAguaSituacao = new ArrayList();
					while (iterator.hasNext()) {
						ligacaoAguaSituacao = (LigacaoAguaSituacao) iterator.next();
						idsLigacaoAguaSituacao.add(ligacaoAguaSituacao.getId());
					}
					query = query.setParameterList("idsLigacaoAguaSituacao",idsLigacaoAguaSituacao);
				}
			}
	
			if (comandoEmpresaCobrancaConta.getLocalidadeInicial() != null) {
				query = query.setInteger("idLocaInicial",comandoEmpresaCobrancaConta.getLocalidadeInicial().getId());
				query = query.setInteger("idLocaFinal",comandoEmpresaCobrancaConta.getLocalidadeFinal().getId());
			}
	
			if (comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial() != null) {
				query = query.setInteger("idSetorInicial",comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial());
				query = query.setInteger("idSetorFinal",comandoEmpresaCobrancaConta.getCodigoSetorComercialFinal());
			}
	
			if (comandoEmpresaCobrancaConta.getQuadraInicial() != null) {
				query = query.setInteger("idQuadraInicial",comandoEmpresaCobrancaConta.getQuadraInicial().getNumeroQuadra());
				query = query.setInteger("idQuadraFinal",comandoEmpresaCobrancaConta.getQuadraFinal().getNumeroQuadra());
			}
	
			if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {
				query = query.setInteger("idAnoMesInicial",comandoEmpresaCobrancaConta.getReferenciaContaInicial());
				query = query.setInteger("idAnoMesFinal",comandoEmpresaCobrancaConta.getReferenciaContaFinal());
			}
	
			if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {
				query = query.setDate("dataInicial",comandoEmpresaCobrancaConta.getDataVencimentoContaInicial());
				query = query.setDate("dataFinal",comandoEmpresaCobrancaConta.getDataVencimentoContaFinal());
			}
	
			if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {
				query = query.setBigDecimal("valorMaximoConta",comandoEmpresaCobrancaConta.getValorMinimoConta());
				query = query.setBigDecimal("valorMinimoConta",comandoEmpresaCobrancaConta.getValorMaximoConta());
			}
	
			if (comandoEmpresaCobrancaConta.getQtdContasInicial() != null) {
				query = query.setInteger("qtdContasInicial",comandoEmpresaCobrancaConta.getQtdContasInicial());
				query = query.setInteger("qtdContasFinal",comandoEmpresaCobrancaConta.getQtdContasFinal());
			}
	
			if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {
				query = query.setDate("dataMaximaVencimento",Util.subtrairNumeroDiasDeUmaData(
						new Date(), comandoEmpresaCobrancaConta.getQtdDiasVencimento()));
			}
	
			if ((comandoEmpresaCobrancaConta.getIndicadorResidencial() != null && !comandoEmpresaCobrancaConta
					.getIndicadorResidencial().equals(
							ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorComercial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorComercial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorIndustrial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorPublico() != null && !comandoEmpresaCobrancaConta
							.getIndicadorPublico().equals(
									ConstantesSistema.NAO.intValue()))) {
	
				Collection<Integer> idsCategorias = new ArrayList();
	
				if (comandoEmpresaCobrancaConta.getIndicadorResidencial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorResidencial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.RESIDENCIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorComercial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorComercial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.COMERCIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorIndustrial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.INDUSTRIAL);
				}
	
				if (comandoEmpresaCobrancaConta.getIndicadorPublico() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorPublico()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.PUBLICO);
				}
	
				query = query.setParameterList("idsCategoria",idsCategorias);
			}
				
				retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC0933] Alterar Leiturista do Arquivo Texto para Leitura
	 * 
	 * Alterar o leiturista da tabela de movimento conta prefaturada
	 * 
	 * @author Bruno Barros
	 * @Data 12/04/2011
	 *
	 */
	public void alterarLeituristaMovimentoRoteiroEmpresa( Integer idRota, Integer anoMes, Integer idLeituristaNovo ) throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			atualizarImovel = "update gcom.micromedicao.MovimentoRoteiroEmpresa "
					+ "set leiturista = :idLeituristaNovo where rota = :idRota and anoMesMovimento = :anoMes";

			session.createQuery(atualizarImovel).
				setInteger("idRota", idRota).
				setInteger("anoMes", anoMes).
				setInteger("idLeituristaNovo", idLeituristaNovo).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}		
	}
	
	/**
	 * [UC0933] Alterar Leiturista do Arquivo Texto para Leitura
	 * 
	 * Alterar o leiturista da tabela de movimento conta prefaturada
	 * 
	 * @author Bruno Barros
	 * @Data 12/04/2011
	 *
	 */
	public void alterarLeituristaMovimentoRoteiroEmpresa( Collection<Integer> idsImovel, Integer anoMes, Integer idLeituristaNovo ) 
		throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		
		String atualizarImovel;

		try {
			atualizarImovel = "update gcom.micromedicao.MovimentoRoteiroEmpresa "
					+ "set leiturista = :idLeituristaNovo where imovel in ( :idsImoveis ) and anoMesMovimento = :anoMes";

			session.createQuery(atualizarImovel).
				setParameterList("idsImoveis", idsImovel ).
				setInteger("anoMes", anoMes).
				setInteger("idLeituristaNovo", idLeituristaNovo).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * @author Vivianne Sousa
	 * @date 20/04/2011
	 */
	public Collection pesquisarContaBraille( Integer anoMesFaturamento )
		throws ErroRepositorioException{
		
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			
//			consulta =  "select cnta, " +
//						"imov.nomeImovel," +
//						"imov.localidade.gerenciaRegional.id, " +
//						"imov.setorComercial.id " +
//						"from Conta cnta " +
//						"inner join cnta.imovel imov " +
//						"inner join imov.imovelContaEnvio icte " +
//						"where imov.indicadorExclusao = :indicadorExclusao " +
//						"and icte.id in(:braille , :brailleResponsavel )" +
//						"and cnta.referencia = :anoMesFaturamento  " +
//						"and cnta.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada) " ; 
			
			consulta = "select " +
					"cnta.id," +
					"imov.nomeImovel," +
					"imov.localidade.gerenciaRegional.id, " +
					"imov.setorComercial.id " +
//					"cnta.ligacaoAguaSituacao.id, " +
//					"cnta.ligacaoEsgotoSituacao.id, " +
//					"cnta.imovelPerfil.id, " +
//					"imov.id, " +
//					"cnta.faturamentoGrupo.id, " +
//					"cnta.localidade.id " +
					"from ContaImpressao contaImpressao " + 
					"inner join contaImpressao.contaGeral contaGeral " +
					"inner join contaGeral.conta cnta " +
					"inner join cnta.imovel imov " +
					"inner join imov.imovelContaEnvio icte " +
					"where imov.indicadorExclusao = :indicadorExclusao " +
					"and icte.id in(:braille , :brailleResponsavel )" +
					"and cnta.referencia = :anoMesFaturamento  " +
					"and cnta.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada) " ; 
		

			retorno = (Collection)session
					.createQuery(consulta)
					.setInteger("anoMesFaturamento", anoMesFaturamento )
					.setShort("indicadorExclusao",ConstantesSistema.NAO)
					.setInteger("braille",ImovelContaEnvio.ENVIAR_CONTA_BRAILLE)
					.setInteger("brailleResponsavel",ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL)
					.setInteger("anoMesFaturamento",anoMesFaturamento)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;		
	}
	
	
	/**
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * 
	 * @author Vivianne Sousa
	 * @date 20/04/2011
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterQuantidadeEconomiasContaCategoria(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(contaCategoria.quantidadeEconomia), categoria.id "
					+ "from ContaCategoria contaCategoria "
					+ "inner join contaCategoria.comp_id.conta conta "
					+ "inner join contaCategoria.comp_id.categoria categoria "
					+ "where conta.id = :idConta " 
					+ "group by categoria.id " 
					+ "order by categoria.id ";

			retorno = (Collection) session.createQuery(consulta).setInteger(
					"idConta", idConta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}
	
	
	/**
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * 
	 * @author Vivianne Sousa
	 * @date 20/04/2011
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGrupoFaturamentoGrupoNaoFaturados(
			Integer anoMesReferenciaFaturamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select fatGrupo.id " +
					"from FaturamentoGrupo fatGrupo "
					+ "where fatGrupo.anoMesReferencia = :anoMesReferenciaFaturamento " 
					+ "and fatGrupo.indicadorUso = " + ConstantesSistema.SIM;

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaFaturamento", anoMesReferenciaFaturamento)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	
	/** 
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * @author Vivianne Sousa
	 * @date 25/04/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasBrailleEmitir(Collection<Integer> idTipoConta,
			 Integer anoMesReferencia,Integer anoMesReferenciaFaturamentoAntecipado)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega "// 41
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id in (:idTipoConta) AND " 
					+ "imovel.icte_id = :idImovelContaEnvio AND " ;
			
			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2 ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}

			consulta += " AND cliCnt.clct_icnomeconta = :indicadorNomeConta "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"tipoConta", Hibernate.INTEGER).addScalar(
							"rotaEntrega", Hibernate.INTEGER).addScalar(
							"seqRotaEntrega", Hibernate.INTEGER)
							
					.setParameterList("idTipoConta", idTipoConta)
					.setInteger("indicadorNomeConta",ConstantesSistema.INDICADOR_USO_ATIVO)
					.setInteger("idImovelContaEnvio", ImovelContaEnvio.ENVIAR_CONTA_BRAILLE)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/** 
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * @author Vivianne Sousa
	 * @date 25/04/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasBrailleClienteResponsavelFichaCompensacao(
			Integer idTipoConta, Integer anoMesReferencia, 
			Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta " // 39
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "imovel.icte_id = :idImovelContaEnvio AND " 
					+ "contaImpressao.empr_id is null AND "
					+ "contaImpressao.cnti_vlconta > :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ")";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
		
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idTipoConta", idTipoConta)
					.setInteger("idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("idImovelContaEnvio",ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL)
					.setShort("indicadorEmissaoExtratoFaturamento",indicadorEmissaoExtratoFaturamento)
					.setBigDecimal("valorLimite",EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * @author Vivianne Sousa
	 * @date 25/04/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasBrailleClienteResponsavelNaoFichaCompensacao(
			Integer idTipoConta, Integer anoMesReferencia, Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta " // 39
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "contaImpressao.empr_id is null AND " 
					+ "imovel.icte_id = :idImovelContaEnvio AND "
					+ "contaImpressao.cnti_vlconta <= :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2 ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}

			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).setInteger(
							"idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento).setBigDecimal(
							"valorLimite",
							EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
							.setInteger("idImovelContaEnvio",ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	* [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * @author Vivianne Sousa
	 * @date 25/04/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasBrailleClienteResponsavel(
			Collection<Integer> idTipoConta, 
			Integer anoMesReferencia, Short indicadorEmissaoExtratoFaturamento,
			Integer anoMesReferenciaFaturamentoAntecipado)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cttp_id as tipoConta, "// 39
					+ "imovel.rota_identrega as rotaEntrega, "// 40
					+ "imovel.imov_nnsequencialrotaentrega as seqRotaEntrega "// 41
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id in (:idTipoConta) AND "
					+ "contaImpressao.empr_id is null AND " 
					+ "imovel.icte_id = :idImovelContaEnvio AND ";
			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2 ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
					+ "imovel.imov_icemsextfatmt = :indicadorEmissaoExtratoFaturamento "
					+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"tipoConta", Hibernate.INTEGER).addScalar(
							"rotaEntrega", Hibernate.INTEGER).addScalar(
							"seqRotaEntrega", Hibernate.INTEGER)
					.setParameterList("idTipoConta", idTipoConta).setInteger(
							"idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setShort("indicadorEmissaoExtratoFaturamento",
							indicadorEmissaoExtratoFaturamento)
					.setInteger("idImovelContaEnvio",ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * @author Vivianne Sousa
	 * @date 25/04/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasBrailleFichaCompensacao(Integer idTipoConta,
			Integer anoMesReferencia,Integer anoMesReferenciaFaturamentoAntecipado)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta " // 39
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "imovel.icte_id = :idImovelContaEnvio AND "
					+ "contaImpressao.cnti_vlconta > :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}
			consulta += " AND cliCnt.clct_icnomeconta = :indicadorNomeConta "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).setInteger(
							"idTipoConta", idTipoConta)
							.setInteger("idImovelContaEnvio",ImovelContaEnvio.ENVIAR_CONTA_BRAILLE)
					.setInteger("indicadorNomeConta",ConstantesSistema.INDICADOR_USO_ATIVO)
					.setBigDecimal("valorLimite",EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * @author Vivianne Sousa
	 * @date 25/04/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasBrailleNaoFichaCompensacao(Integer idTipoConta,
			Integer anoMesReferencia,Integer anoMesReferenciaFaturamentoAntecipado)throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "cnt.cnta_id as idConta, "// 0
					+ "cli.clie_nmcliente as nomeCliente, "// 1
					+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
					+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
					+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
					+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
					+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
					+ "cnt.cnta_nnlote as lote, "// 7
					+ "cnt.cnta_nnsublote as sublote, "// 8
					+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
					+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
					+ "cnt.cnta_vlagua as valorAgua, "// 11
					+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
					+ "cnt.cnta_vldebitos as debitos, "// 13
					+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
					+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
					+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
					+ "imovel.imov_id as idImovel, "// 17
					+ "loc.loca_id as idLocalidade, "// 18
					+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
					+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
					+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
					+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
					+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
					+ "setorComercial.stcm_id as idSetorComercial, "// 24
					+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
					+ "contaImpressao.empr_id as idEmpresa, "// 26
					+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
					+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
					+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
					+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
					+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
					+ "imovel.imov_nmimovel as nomeImovel, "// 32
					+ "rota.rota_cdrota as codigoRota, "// 33
					+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
					+ "cnt.cnta_idorigem as origem, "// 35
					+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
					+ "func.func_id as idFuncionario, "// 37
					+ "func.func_nmfuncionario as nomeFuncionario, "// 38
					+ "contaImpressao.cnti_vlconta as valorConta, " // 39
					+ "cli.clie_nncpf as cpf " // 40
					+ "from cadastro.cliente_conta cliCnt "
					+ "inner join faturamento.conta cnt on cliCnt.cnta_id=cnt.cnta_id "
					+ "inner join faturamento.conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
					+ "inner join cadastro.quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
					+ "inner join micromedicao.rota rota on quadraConta.rota_id=rota.rota_id "
					+ "inner join cadastro.setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
					+ "inner join cadastro.localidade loc on cnt.loca_id=loc.loca_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
					+ "inner join atendimentopublico.ligacao_agua_situacao ligacaoAguaSituacao "
					+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
					+ "inner join atendimentopublico.ligacao_esgoto_situacao ligacaoEsgotoSituacao "
					+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
					+ "inner join cadastro.imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
					+ "inner join cadastro.imovel imovel on cnt.imov_id=imovel.imov_id "
					+ "inner join cadastro.cliente cli on cliCnt.clie_id=cli.clie_id "
					+ "left join cadastro.funcionario func on imovel.func_id=func.func_id "
					+ "where contaImpressao.cttp_id = :idTipoConta AND "
					+ "imovel.icte_id = :idImovelContaEnvio AND "
					+ "contaImpressao.cnti_vlconta <= :valorLimite AND ";

			if (anoMesReferenciaFaturamentoAntecipado != null) {
				consulta += "(contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia
						+ " OR contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferenciaFaturamentoAntecipado + ") ";
				// + "AND contaImpressao.cnti_icimpressao = 2";
			} else {
				consulta += "contaImpressao.cnti_amreferenciaconta ="
						+ anoMesReferencia;
			}

			consulta += " AND cliCnt.clct_icnomeconta = :indicadorNomeConta "
					+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
					+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta",
					Hibernate.INTEGER).addScalar("nomeCliente",
					Hibernate.STRING).addScalar("dataVencimentoConta",
					Hibernate.DATE)
					.addScalar("amReferencia", Hibernate.INTEGER).addScalar(
							"digitoVerificador", Hibernate.SHORT).addScalar(
							"codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar(
							"lote", Hibernate.SHORT).addScalar("sublote",
							Hibernate.SHORT).addScalar("consumoAgua",
							Hibernate.INTEGER).addScalar("consumoEsgoto",
							Hibernate.INTEGER).addScalar("valorAgua",
							Hibernate.BIG_DECIMAL).addScalar("valorEsgoto",
							Hibernate.BIG_DECIMAL).addScalar("debitos",
							Hibernate.BIG_DECIMAL).addScalar("valorCreditos",
							Hibernate.BIG_DECIMAL).addScalar("valorImpostos",
							Hibernate.BIG_DECIMAL).addScalar("dataValidade",
							Hibernate.DATE).addScalar("idImovel",
							Hibernate.INTEGER).addScalar("idLocalidade",
							Hibernate.INTEGER).addScalar("idGerenciaRegional",
							Hibernate.INTEGER).addScalar("nomeGerencia",
							Hibernate.STRING).addScalar(
							"idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPrefil", Hibernate.INTEGER).addScalar(
							"idSetorComercial", Hibernate.INTEGER).addScalar(
							"idFaturamentoGrupo", Hibernate.INTEGER).addScalar(
							"idEmpresa", Hibernate.INTEGER).addScalar(
							"descricaoLocalidade", Hibernate.STRING).addScalar(
							"descricaoLigAguaSit", Hibernate.STRING).addScalar(
							"descricaoLigEsgotoSit", Hibernate.STRING)
					.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("idClienteResponsavel", Hibernate.INTEGER)
					.addScalar("nomeImovel", Hibernate.STRING).addScalar(
							"codigoRota", Hibernate.SHORT).addScalar(
							"sequencialRota", Hibernate.INTEGER).addScalar(
							"origem", Hibernate.INTEGER).addScalar(
							"debitoCreditoSituacaoAtual", Hibernate.INTEGER)
					.addScalar("idFuncionario", Hibernate.INTEGER).addScalar(
							"nomeFuncionario", Hibernate.STRING).addScalar(
							"valorConta", Hibernate.BIG_DECIMAL).
							addScalar("cpf", Hibernate.STRING).							
							setInteger("idTipoConta", idTipoConta)
							.setInteger("indicadorNomeConta",ConstantesSistema.INDICADOR_USO_ATIVO)
							.setInteger("idImovelContaEnvio",ImovelContaEnvio.ENVIAR_CONTA_BRAILLE)
							.setBigDecimal("valorLimite",EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO)
							.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	
	/**
	 * [UC1166]  Gerar  txt para impressão de contas no formato braille
	 * @author Vivianne Sousa
	 * @date 20/04/2011
	 */
	public Conta obterObjetoConta( Integer idConta )
		throws ErroRepositorioException{
		
		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			
			consulta =  "select cnta " +
						"from Conta cnta " +
						"where cnta.id = :idConta " ;
		
			retorno = (Conta)session
					.createQuery(consulta)
					.setInteger("idConta", idConta )
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;		
	}

	
	/**
	 * [UC0866] Gerar Comando Contas em Cobrança por Empresa
	 * 
	 * Pesquisa a quantidade de contas por imóvel
	 * 
	 * @author: Mariana Victor
	 * @date: 03/05/2011
	 */
	private Integer pesquisarQuantidadeContasMenorFaixa(
			Integer idEmpresa)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = " select eccf.emcf_nncontasmin as numeroMinimo "
				+ " from cadastro.empr_contrato_cobranca ecco "
				+ " inner join cadastro.empr_cobr_faixa eccf on ecco.emco_id = eccf.emco_id "
				+ " where ecco.empr_id = :idEmpresa "
				+ " order by eccf.emcf_nncontasmin ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar(
					"numeroMinimo", Hibernate.INTEGER).setInteger("idEmpresa", idEmpresa)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}


	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Pesquisa a quantidade de contas, agrupando por imóvel
	 * 
	 * @author: Mariana Victor
	 * @date: 12/05/2011
	 */
	public Collection<Object[]> pesquisarQuantidadeContasComandoAgrupandoPorImovel(
			MovimentarOrdemServicoEmitirOSHelper movimentarOrdemServicoEmitirOSHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT COUNT(DISTINCT ecco.cnta_id) as qtdContas, "
				+ " COUNT(DISTINCT ecco.imov_id) as qtdImovel, "
				+ " SUM (ecco.ecco_vloriginalconta) as valorTotalDebitos "
				+ " FROM cobranca.empresa_cobranca_conta ecco ";

			consulta = consulta
					+ " INNER JOIN faturamento.conta conta "
					+ " on conta.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cadastro.imovel imov "
					+ " on imov.imov_id = ecco.imov_id "
					+ " INNER JOIN cadastro.localidade loca "
					+ " on loca.loca_id = imov.loca_id "
					+ " INNER JOIN atendimentopublico.ordem_servico orse " 
					+ " on orse.orse_id = ecco.orse_id "
					+ " WHERE orse.orse_cdsituacao = :pendente and " ;
						
	
			consulta = consulta
					+ criarCondicionaisPesquisarQuantidadeContasComando(movimentarOrdemServicoEmitirOSHelper);
	
			consulta = consulta + " GROUP BY ecco.imov_id ";
			
			retorno = session.createSQLQuery(consulta).addScalar(
					"qtdContas", Hibernate.INTEGER).addScalar("qtdImovel",
					Hibernate.INTEGER).addScalar("valorTotalDebitos",
					Hibernate.BIG_DECIMAL).setInteger("pendente", OrdemServico.SITUACAO_PENDENTE).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Pesquisa a quantidade de contas
	 * 
	 * @author: Mariana Victor
	 * @date: 12/05/2011
	 */
	public Object[] pesquisarQuantidadeContasComando(
			MovimentarOrdemServicoEmitirOSHelper movimentarOrdemServicoEmitirOSHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT COUNT(DISTINCT ecco.cnta_id) as qtdContas, "
				+ " COUNT(DISTINCT ecco.imov_id) as qtdImovel, "
				+ " SUM (ecco.ecco_vloriginalconta) as valorTotalDebitos "
				+ " FROM cobranca.empresa_cobranca_conta ecco ";

			consulta = consulta
					+ " INNER JOIN faturamento.conta conta "
					+ " on conta.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cadastro.imovel imov "
					+ " on imov.imov_id = ecco.imov_id "
					+ " INNER JOIN cadastro.localidade loca "
					+ " on loca.loca_id = imov.loca_id "
					+ " LEFT OUTER JOIN faturamento.conta_categoria contaCat "
					+ " on ecco.cnta_id = contaCat.cnta_id"
					+ " INNER JOIN atendimentopublico.ordem_servico orse " 
					+ " on orse.orse_id = ecco.orse_id "
					+ " WHERE orse.orse_cdsituacao = :pendente and ";
	
			consulta = consulta
					+ criarCondicionaisPesquisarQuantidadeContasComando(movimentarOrdemServicoEmitirOSHelper);
	
			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"qtdContas", Hibernate.INTEGER).addScalar("qtdImovel",
					Hibernate.INTEGER).addScalar("valorTotalDebitos",
					Hibernate.BIG_DECIMAL).setInteger("pendente", OrdemServico.SITUACAO_PENDENTE)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Cria as condicionais para a pesquisa de quantidade de contas, agrupanda por imóvel
	 * 
	 * @author: Mariana Victor
	 * @date: 12/05/2011
	 */
	private String criarCondicionaisPesquisarQuantidadeContasComando(
			MovimentarOrdemServicoEmitirOSHelper movimentarOrdemServicoEmitirOSHelper) {

		String retorno = "";
		
		ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = movimentarOrdemServicoEmitirOSHelper.getComandoEmpresaCobrancaConta();

		if (comandoEmpresaCobrancaConta.getId() != null) {
			retorno = retorno + " and ecco.cecc_id = "
				+ comandoEmpresaCobrancaConta.getId();
		}
		
		if (movimentarOrdemServicoEmitirOSHelper.getNumeroOSInicial() != null
				&& !movimentarOrdemServicoEmitirOSHelper.getNumeroOSInicial().equals("")
				&& movimentarOrdemServicoEmitirOSHelper.getNumeroOSFinal() != null
				&& !movimentarOrdemServicoEmitirOSHelper.getNumeroOSFinal().equals("")) {
			
			retorno = retorno
				+ " and ecco.orse_id between "
				+ movimentarOrdemServicoEmitirOSHelper.getNumeroOSInicial()
				+ " and "
				+ movimentarOrdemServicoEmitirOSHelper.getNumeroOSFinal();
		}
			
		if (comandoEmpresaCobrancaConta.getUnidadeNegocio() != null) {
			
			retorno = retorno
					+ " and loca.uneg_id = "
					+ comandoEmpresaCobrancaConta.getUnidadeNegocio().getId();
			
		} else if (movimentarOrdemServicoEmitirOSHelper.getColecaoUnidadeNegocio() != null
				&& !movimentarOrdemServicoEmitirOSHelper.getColecaoUnidadeNegocio().isEmpty()) {
			
			boolean consulta = true;
			if(movimentarOrdemServicoEmitirOSHelper.getColecaoUnidadeNegocio().size() == 1){
				Iterator it = movimentarOrdemServicoEmitirOSHelper.getColecaoUnidadeNegocio().iterator();
				while(it.hasNext()){
					UnidadeNegocio obj = (UnidadeNegocio) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				Iterator iterator = movimentarOrdemServicoEmitirOSHelper.getColecaoUnidadeNegocio().iterator();
				UnidadeNegocio unidadeNegocio = null;
				retorno = retorno + " and loca.uneg_id in (";
				while (iterator.hasNext()) {
					unidadeNegocio = (UnidadeNegocio) iterator.next();
					retorno = retorno + unidadeNegocio.getId() + ",";
				}
				retorno = Util.removerUltimosCaracteres(retorno, 1);
				retorno = retorno + ") ";
				
			}
			
		}
		

		if (comandoEmpresaCobrancaConta.getGerenciaRegional() != null) {
			
			retorno = retorno + " and loca.greg_id = "
						+ comandoEmpresaCobrancaConta.getGerenciaRegional().getId();
			
		} else if (movimentarOrdemServicoEmitirOSHelper.getColecaoGerenciaRegional() != null
				&& !movimentarOrdemServicoEmitirOSHelper.getColecaoGerenciaRegional().isEmpty()) {
			
			boolean consulta = true;
			if(movimentarOrdemServicoEmitirOSHelper.getColecaoGerenciaRegional().size() == 1){
				Iterator it = movimentarOrdemServicoEmitirOSHelper.getColecaoGerenciaRegional().iterator();
				while(it.hasNext()){
					GerenciaRegional obj = (GerenciaRegional) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				Iterator iterator = movimentarOrdemServicoEmitirOSHelper.getColecaoGerenciaRegional().iterator();
				GerenciaRegional gerenciaRegional = null;
				retorno = retorno + " and loca.greg_id in (";
				while (iterator.hasNext()) {
					gerenciaRegional = (GerenciaRegional) iterator.next();
					retorno = retorno + gerenciaRegional.getId() + ",";
				}
				retorno = Util.removerUltimosCaracteres(retorno, 1);
				retorno = retorno + ") ";
				
			}
			
		}

		if (comandoEmpresaCobrancaConta.getImovelPerfil() != null) {
			
			retorno = retorno 
					+ " and imov.iper_id = "
					+ comandoEmpresaCobrancaConta.getImovelPerfil().getId();
			
		} else if (movimentarOrdemServicoEmitirOSHelper.getColecaoImovelPerfil() != null
				&& !movimentarOrdemServicoEmitirOSHelper.getColecaoImovelPerfil().isEmpty()) {
			
			boolean consulta = true;
			if(movimentarOrdemServicoEmitirOSHelper.getColecaoImovelPerfil().size() == 1){
				Iterator it = movimentarOrdemServicoEmitirOSHelper.getColecaoImovelPerfil().iterator();
				while(it.hasNext()){
					ImovelPerfil obj = (ImovelPerfil) it.next();
					if(obj != null && obj.getId() == -1){
						consulta = false;
					}
				}	
			}
			if(consulta){	
				Iterator iterator = movimentarOrdemServicoEmitirOSHelper.getColecaoImovelPerfil().iterator();
				ImovelPerfil imovelPerfil = null;
				retorno = retorno + " and imov.iper_id in (";
				while (iterator.hasNext()) {
					imovelPerfil = (ImovelPerfil) iterator.next();
					retorno = retorno + imovelPerfil.getId() + ",";
				}
				retorno = Util.removerUltimosCaracteres(retorno, 1);
				retorno = retorno + ") ";
				
			}
			
		}

		if (comandoEmpresaCobrancaConta.getLocalidadeInicial() != null) {
			retorno = retorno
					+ " and loca.loca_id between "
					+ comandoEmpresaCobrancaConta.getLocalidadeInicial()
							.getId() + " and "
					+ comandoEmpresaCobrancaConta.getLocalidadeFinal().getId();
		}

		if (comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_cdsetorcomercial between "
					+ comandoEmpresaCobrancaConta
							.getCodigoSetorComercialInicial()
					+ " and "
					+ comandoEmpresaCobrancaConta
							.getCodigoSetorComercialFinal();
		}

		if (comandoEmpresaCobrancaConta.getQuadraInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_nnquadra between "
					+ comandoEmpresaCobrancaConta.getQuadraInicial()
							.getNumeroQuadra() + " and "
					+ comandoEmpresaCobrancaConta.getQuadraFinal().getNumeroQuadra();
		}

		if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {
			retorno = retorno + " and conta.cnta_amreferenciaconta between "
					+ comandoEmpresaCobrancaConta.getReferenciaContaInicial()
					+ " and "
					+ comandoEmpresaCobrancaConta.getReferenciaContaFinal();
		}

		if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {
			retorno = retorno
					+ " and conta.cnta_dtvencimentoconta between to_date('"
					+ Util
							.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
									.getDataVencimentoContaInicial())
					+ "','YYYY-MM-DD') and to_date('"
					+ Util
							.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
									.getDataVencimentoContaFinal()) + "','YYYY-MM-DD')";
		}

		if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {
			retorno = retorno
					+ " and ecco.ecco_vloriginalconta between "
					+ comandoEmpresaCobrancaConta.getValorMinimoConta()
					+ " and "
					+ comandoEmpresaCobrancaConta.getValorMaximoConta();
		}

		if ((comandoEmpresaCobrancaConta.getIndicadorResidencial() != null && !comandoEmpresaCobrancaConta
				.getIndicadorResidencial().equals(
						ConstantesSistema.NAO.intValue()))
				|| (comandoEmpresaCobrancaConta.getIndicadorComercial() != null && !comandoEmpresaCobrancaConta
						.getIndicadorComercial().equals(
								ConstantesSistema.NAO.intValue()))
				|| (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null && !comandoEmpresaCobrancaConta
						.getIndicadorIndustrial().equals(
								ConstantesSistema.NAO.intValue()))
				|| (comandoEmpresaCobrancaConta.getIndicadorPublico() != null && !comandoEmpresaCobrancaConta
						.getIndicadorPublico().equals(
								ConstantesSistema.NAO.intValue()))) {

			retorno = retorno + " and imov.imov_idcategoriaprincipal IN ( ";

			if (comandoEmpresaCobrancaConta.getIndicadorResidencial() != null
					&& !comandoEmpresaCobrancaConta.getIndicadorResidencial()
							.equals(ConstantesSistema.NAO.intValue())) {
				retorno = retorno + Categoria.RESIDENCIAL + ",";
			}

			if (comandoEmpresaCobrancaConta.getIndicadorComercial() != null
					&& !comandoEmpresaCobrancaConta.getIndicadorComercial()
							.equals(ConstantesSistema.NAO.intValue())) {
				retorno = retorno + Categoria.COMERCIAL + ",";
			}

			if (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null
					&& !comandoEmpresaCobrancaConta.getIndicadorIndustrial()
							.equals(ConstantesSistema.NAO.intValue())) {
				retorno = retorno + Categoria.INDUSTRIAL + ",";
			}

			if (comandoEmpresaCobrancaConta.getIndicadorPublico() != null
					&& !comandoEmpresaCobrancaConta.getIndicadorPublico()
							.equals(ConstantesSistema.NAO.intValue())) {
				retorno = retorno + Categoria.PUBLICO + ",";
			}

			retorno = Util.removerUltimosCaracteres(retorno, 1);
			retorno = retorno + ")";
		}
		
		if (!retorno.equals("")) {
			retorno = retorno.substring(4, (retorno
					.length()));
		}

		return retorno;
	}


	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Pesquisa as ordens de serviço selecionadas
	 * 
	 * @author: Mariana Victor
	 * @date: 19/05/2011
	 */
	public Collection<Integer[]> pesquisarOSComandoSelecionado(
			MovimentarOrdemServicoEmitirOSHelper movimentarOrdemServicoEmitirOSHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Integer[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT ecco.orse_id as idOS, ecco.imov_id as idImovel "
				+ " FROM cobranca.empresa_cobranca_conta ecco ";

			consulta = consulta
					+ " INNER JOIN faturamento.conta conta "
					+ " on conta.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cadastro.imovel imov "
					+ " on imov.imov_id = ecco.imov_id "
					+ " INNER JOIN cadastro.localidade loca "
					+ " on loca.loca_id = imov.loca_id "
					+ " LEFT OUTER JOIN faturamento.conta_categoria contaCat "
					+ " on ecco.cnta_id = contaCat.cnta_id"
					+ " INNER JOIN atendimentopublico.ordem_servico orse " 
					+ " on orse.orse_id = ecco.orse_id "
					+ " WHERE orse.orse_cdsituacao = :pendente and ";
	
			consulta = consulta
					+ criarCondicionaisPesquisarQuantidadeContasComando(movimentarOrdemServicoEmitirOSHelper);

			consulta = consulta + " group by ecco.orse_id, ecco.imov_id";
			
			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("pendente", OrdemServico.SITUACAO_PENDENTE)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1173] Informar Consumo por Parâmetros
	 * 
	 * [FS0005]  Validar mês ano maior ou igual 
	 * 
	 * @author Mariana Victor
	 * @date 20/05/2011
	 * 
	 * @param anoMesReferenciaInformado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarAnoMesReferenciaMenorAnoMesReferenciaFaturamentoGrupo(
			int anoMesReferenciaInformado) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(*) as quantidade " 
					+ " from faturamento.faturamento_grupo fg "
					+ " where fg.ftgr_amreferencia <= :anoMesReferenciaInformado ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("anoMesReferenciaInformado", anoMesReferenciaInformado)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Arthur Carvalho
	 * @date 01/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public boolean pesquisarContaDoImovelDiferentePreFaturada(Integer idImovel, Integer anoMesReferencia) throws ErroRepositorioException {

		Integer retorno = null;
		boolean aux = false;
		
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dcst.id "
					+ "from Conta cnta "
					+ "inner join cnta.imovel imov "
					+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
					+ "where imov.id = :idImovel " 
					+ "and cnta.referencia = :anoMesReferencia " 
					+ "and dcst.id <> " + DebitoCreditoSituacao.PRE_FATURADA + " ";

			retorno = (Integer) session.createQuery(consulta)
				.setInteger("idImovel", idImovel)
				.setInteger("anoMesReferencia",	anoMesReferencia)
				.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		if (retorno != null ) {
			aux = true;
		}
		
		return aux;
	}
	
	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores Author:
	 * 
	 * @author Raphael Rossiter
	 * @date 03/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorContaComSituacaoAtual(Integer idImovel,
			Integer anoMesReferencia) throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select (ct.valorAgua + ct.valorEsgoto + ct.debitos - ct.valorCreditos - coalesce( ct.valorImposto, 0 ) ) from Conta ct "
					+ "inner join ct.imovel "
					+ "inner join ct.debitoCreditoSituacaoAtual "
					+ "where ct.referencia = :referencia "
					+ "and ct.imovel.id = :imovel and "
					+ "ct.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"imovel", idImovel.intValue()).setInteger(
					"referencia", anoMesReferencia.intValue()).setInteger("normal",
					DebitoCreditoSituacao.NORMAL).setInteger("incluida",
					DebitoCreditoSituacao.INCLUIDA).setInteger("retificada",
					DebitoCreditoSituacao.RETIFICADA).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * UC1198 - Relatório das Multas de Autos de Infração Pendentes
	 * 
	 * @author Hugo Azevedo
	 * @date 11/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	
	public Collection obterColecaoGrupoFaturamento() throws ErroRepositorioException {
		Collection retorno = new ArrayList(); 
		Session sessao = HibernateUtil.getSession();
		
		String consulta = "select gr.id, gr.descricao "+
		                  "from FaturamentoGrupo gr "+
				          "where gr.indicadorUso = :indicadorUso "+
		                  "order by gr.id";
		
		try{
			
			retorno = sessao.createQuery(consulta).setInteger("indicadorUso", ConstantesSistema.INDICADOR_USO_ATIVO).list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			
			HibernateUtil.closeSession(sessao);
		}
		return retorno;
		
		
	}
	
	
	/**
	 * UC1198 - Relatório das Multas de Autos de Infração Pendentes
	 * 
	 * @author Hugo Azevedo
	 * @date 11/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	
	public Collection pesquisarDadosRelatorioAutoInfracaoPendentes(Integer grupo, Integer funcionario) throws ErroRepositorioException{
		Collection retorno = new ArrayList();
		Session sessao = HibernateUtil.getSession();
		
		String consulta = "";
		
		/*
		 * 3.1.1. Caso o débito a cobrar esteja associado a um auto de infração
		 *        e seja correspondente a uma multa de auto de infração 
		 */
		consulta =  " Select fg.ftgr_id," +
					"fg.FTGR_DSFATURAMENTOGRUPO,"+
					"funcionario.FUNC_ID,"+
					"funcionario.FUNC_NMFUNCIONARIO,"+
					"loca.LOCA_ID,"+
					"loca.LOCA_NMLOCALIDADE,"+
					"rota.ROTA_CDROTA,"+
					"imovel.IMOV_ID, "+
					"clieUsuario.CLIE_ID,"+
					"clieUsuario.CLIE_NMCLIENTE,"+
					"autoInfracao.AUIF_ID,"+
					"debitoTipo.DBTP_DSDEBITOTIPO,"+
					"autoInfracao.AUIF_DTEMISSAO, "+
					"debitoACobrar.dbac_id "+
			"From faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar "+
			"INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id "+
			"inner join cadastro.imovel imovel on (autoInfracao.imov_id = imovel.imov_id) "+
			"INNER JOIN cadastro.cliente_imovel clieImovUsuario on (clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null) "+
			"INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id "+
			"inner join cadastro.localidade loca on (loca.loca_id = imovel.loca_id) "+
			"inner join cadastro.quadra qdra on qdra.qdra_id = imovel.qdra_id "+
			"inner join cadastro.setor_comercial sc on (sc.loca_id  = loca.loca_id) "+
			"inner join micromedicao.rota rota on (qdra.rota_id = rota.rota_id) "+
			"inner join faturamento.faturamento_grupo fg on (fg.ftgr_id = rota.ftgr_id) "+
			"INNER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id "+
			"INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id "+
			"inner join cadastro.funcionario funcionario on (autoInfracao.func_id = funcionario.func_id) "+
			"where  "+
			"autosInfracaoDebitoACobrar.AIDA_ICMULTAAUTOINFRACAO=1 "+
			"and not exists( "+
		    "               select * from arrecadacao.pagamento pagt "+
			"	where pagt.dbac_id = autosInfracaoDebitoACobrar.dbac_id"+
			") and ";
			
			if(grupo != null && grupo.intValue() != 0){
				consulta += "fg.ftgr_id = :idGrupo and ";
			}
			
			if(funcionario != null && funcionario.intValue() != 0){
				 consulta += "funcionario.func_id = :idFuncionario and ";
			}
		
			consulta = Util.removerUltimosCaracteres(consulta, 4);
			
		/*
		 * 3.1.2. Caso não tenha pagamento associado a uma conta
		 *        e esta conta esteja associada a um auto de infração
		 *        e seja correspondente a uma multa de auto de infração	
		 */
			
		 consulta +="union "+
					"Select fg.ftgr_id," +
					"fg.FTGR_DSFATURAMENTOGRUPO,"+
					"funcionario.FUNC_ID,"+
					"funcionario.FUNC_NMFUNCIONARIO,"+
					"loca.LOCA_ID,"+
					"loca.LOCA_NMLOCALIDADE,"+
					"rota.ROTA_CDROTA,"+
					"imovel.IMOV_ID, "+
					"clieUsuario.CLIE_ID,"+
					"clieUsuario.CLIE_NMCLIENTE,"+
					"autoInfracao.AUIF_ID,"+
					"debitoTipo.DBTP_DSDEBITOTIPO,"+
					"autoInfracao.AUIF_DTEMISSAO, "+
					"debitoACobrar.dbac_id "+
			"From faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar "+
			"INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id "+
			"inner join cadastro.imovel imovel on (autoInfracao.imov_id = imovel.imov_id) "+
			"INNER JOIN cadastro.cliente_imovel clieImovUsuario on (clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null) "+
			"INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id "+
			"inner join cadastro.localidade loca on (loca.loca_id = imovel.loca_id) "+
			"inner join cadastro.quadra qdra on qdra.qdra_id = imovel.qdra_id "+
			"inner join cadastro.setor_comercial sc on (sc.loca_id  = loca.loca_id) "+
			"inner join micromedicao.rota rota on (qdra.rota_id = rota.rota_id) "+
			"inner join faturamento.faturamento_grupo fg on (fg.ftgr_id = rota.ftgr_id) "+
			"INNER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id "+
			"INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id "+
			"inner join cadastro.funcionario funcionario on (autoInfracao.func_id = funcionario.func_id) "+
			"where  "+
			"autosInfracaoDebitoACobrar.AIDA_ICMULTAAUTOINFRACAO=1 "+
			"and not exists( "+
			"	   select * from faturamento.debito_cobrado debcob  "+
			"	   inner join arrecadacao.pagamento pagt on (pagt.cnta_id = debcob.cnta_id) "+
			"	   where debcob.dbac_id = autosInfracaoDebitoACobrar.dbac_id "+
			") and ";
		 
		 if(grupo != null && grupo.intValue() != 0){
				consulta += "fg.ftgr_id = :idGrupo and ";
			}
			
			if(funcionario != null && funcionario.intValue() != 0){
				 consulta += "funcionario.func_id = :idFuncionario and ";
			}
		
			consulta = Util.removerUltimosCaracteres(consulta, 4);
			
			/*
			 * 3.2 Caso não exista  pagamento histórico associado ao débito a cobrar
			 *     e este débito a cobrar esteja associado a um auto de infração
			 *     e seja correspondente a uma multa de auto de infração
			 */
			
			consulta += "union "+
						"Select fg.ftgr_id," +
						"fg.FTGR_DSFATURAMENTOGRUPO,"+
						"funcionario.FUNC_ID,"+
						"funcionario.FUNC_NMFUNCIONARIO,"+
						"loca.LOCA_ID,"+
						"loca.LOCA_NMLOCALIDADE,"+
						"rota.ROTA_CDROTA,"+
						"imovel.IMOV_ID, "+
						"clieUsuario.CLIE_ID,"+
						"clieUsuario.CLIE_NMCLIENTE,"+
						"autoInfracao.AUIF_ID,"+
						"debitoTipo.DBTP_DSDEBITOTIPO,"+
						"autoInfracao.AUIF_DTEMISSAO, "+
						/*"2 as s0001, "+
					    "case when "+
						"	exists( "+
						"		select * from faturamento.debito_a_cobrar debitoACobrar "+
						"			 where debitoACobrar.parc_id is not null "+
						"			 and debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id "+
						"            and debitoACobrar.dbac_id in (select dbac_id  "+
						"            from cobranca.parcelamento_item pcit  "+
					    "            where pcit.dbac_id = debitoACobrar.dbac_id) "+
						"	) "+
						"	then 1 "+
						"	else 2 "+
						"end "+
						"as s0002, "+*/
						"debitoACobrar.dbac_id "+
				"From faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar "+
				"INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id "+
				"inner join cadastro.imovel imovel on (autoInfracao.imov_id = imovel.imov_id) "+
				"INNER JOIN cadastro.cliente_imovel clieImovUsuario on (clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null) "+
				"INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id "+
				"inner join cadastro.localidade loca on (loca.loca_id = imovel.loca_id) "+
				"inner join cadastro.quadra qdra on qdra.qdra_id = imovel.qdra_id "+
				"inner join cadastro.setor_comercial sc on (sc.loca_id  = loca.loca_id) "+
				"inner join micromedicao.rota rota on (qdra.rota_id = rota.rota_id) "+
				"inner join faturamento.faturamento_grupo fg on (fg.ftgr_id = rota.ftgr_id) "+
				"INNER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id "+
				"INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id "+
				"inner join cadastro.funcionario funcionario on (autoInfracao.func_id = funcionario.func_id) "+
				"where  "+
				"autosInfracaoDebitoACobrar.AIDA_ICMULTAAUTOINFRACAO=1 "+
				"and not exists( "+
				"	select * from arrecadacao.pagamento_historico pagth "+
				"	where pagth.dbac_id = autosInfracaoDebitoACobrar.dbac_id "+
				") and ";
			 
			 	if(grupo != null && grupo.intValue() != 0){
					consulta += "fg.ftgr_id = :idGrupo and ";
				}
				
				if(funcionario != null && funcionario.intValue() != 0){
					 consulta += "funcionario.func_id = :idFuncionario and ";
				} 
				
				consulta = Util.removerUltimosCaracteres(consulta, 4);
				
				/*
				 * 3.2.2 Caso o auto de infração esteja associado a uma conta
				 *       e não exista pagamento histórico 
				 *       e esta conta esteja associada a um auto de infração 
				 *       e seja correspondente a uma multa de auto de infração
				 */
				
				consulta +="union "+
							"Select fg.ftgr_id," +
							"fg.FTGR_DSFATURAMENTOGRUPO,"+
							"funcionario.FUNC_ID,"+
							"funcionario.FUNC_NMFUNCIONARIO,"+
							"loca.LOCA_ID,"+
							"loca.LOCA_NMLOCALIDADE,"+
							"rota.ROTA_CDROTA,"+
							"imovel.IMOV_ID, "+
							"clieUsuario.CLIE_ID,"+
							"clieUsuario.CLIE_NMCLIENTE,"+
							"autoInfracao.AUIF_ID,"+
							"debitoTipo.DBTP_DSDEBITOTIPO,"+
							"autoInfracao.AUIF_DTEMISSAO, "+
							"debitoACobrar.dbac_id "+
					"From faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar "+
					"INNER JOIN faturamento.autos_infracao autoInfracao on autoInfracao.auif_id = autosInfracaoDebitoACobrar.auif_id "+
					"inner join cadastro.imovel imovel on (autoInfracao.imov_id = imovel.imov_id) "+
					"INNER JOIN cadastro.cliente_imovel clieImovUsuario on (clieImovUsuario.imov_id = autoinfracao.imov_id and clieImovUsuario.crtp_id = 2 and clieImovUsuario.clim_dtrelacaofim is null) "+
					"INNER JOIN cadastro.cliente clieUsuario on clieUsuario.clie_id = clieImovUsuario.clie_id "+
					"inner join cadastro.localidade loca on (loca.loca_id = imovel.loca_id) "+
					"inner join cadastro.quadra qdra on qdra.qdra_id = imovel.qdra_id "+
					"inner join cadastro.setor_comercial sc on (sc.loca_id  = loca.loca_id) "+
					"inner join micromedicao.rota rota on (qdra.rota_id = rota.rota_id) "+
					"inner join faturamento.faturamento_grupo fg on (fg.ftgr_id = rota.ftgr_id) "+
					"INNER JOIN faturamento.debito_a_cobrar debitoACobrar on debitoACobrar.dbac_id = autosInfracaoDebitoACobrar.dbac_id "+
					"INNER JOIN faturamento.debito_tipo debitoTipo on debitoTipo.dbtp_id = debitoACobrar.dbtp_id "+
					"inner join cadastro.funcionario funcionario on (autoInfracao.func_id = funcionario.func_id) "+
					"where  "+
					"autosInfracaoDebitoACobrar.AIDA_ICMULTAAUTOINFRACAO=1 " +
					"and not exists( " +
					"	   select * from faturamento.debito_cobrado debcob " +
					"	   inner join arrecadacao.pagamento_historico pagth on (pagth.cnta_id = debcob.cnta_id) " +
					"	   where debcob.dbac_id = autosInfracaoDebitoACobrar.dbac_id " +
					") and ";
				 
				 	if(grupo != null && grupo.intValue() != 0){
						consulta += "fg.ftgr_id = :idGrupo and ";
					}
					
					if(funcionario != null && funcionario.intValue() != 0){
						 consulta += "funcionario.func_id = :idFuncionario and ";
					} 
					
					consulta = Util.removerUltimosCaracteres(consulta, 4);
					
					try{
						
					   Query query = sessao.createSQLQuery(consulta).addScalar("ftgr_id",Hibernate.STRING)
																.addScalar("FTGR_DSFATURAMENTOGRUPO",Hibernate.STRING)
																.addScalar("FUNC_ID",Hibernate.STRING)
																.addScalar("FUNC_NMFUNCIONARIO",Hibernate.STRING)
																.addScalar("LOCA_ID",Hibernate.STRING)
																.addScalar("LOCA_NMLOCALIDADE",Hibernate.STRING)
																.addScalar("ROTA_CDROTA",Hibernate.STRING)
																.addScalar("IMOV_ID",Hibernate.STRING)
																.addScalar("CLIE_ID",Hibernate.STRING)
																.addScalar("CLIE_NMCLIENTE",Hibernate.STRING)
																.addScalar("AUIF_ID",Hibernate.STRING)
																.addScalar("DBTP_DSDEBITOTIPO",Hibernate.STRING)
																.addScalar("AUIF_DTEMISSAO",Hibernate.DATE)
																/*.addScalar("s0001",Hibernate.INTEGER)
																.addScalar("s0002",Hibernate.INTEGER)*/
																.addScalar("dbac_id",Hibernate.INTEGER);
					   
					   if(grupo != null && grupo.intValue() != 0){
							query = query.setInteger("idGrupo", grupo);
						}
						
						if(funcionario != null && funcionario.intValue() != 0){
							 query = query.setInteger("idFuncionario", funcionario);
						} 
						System.out.println(consulta);									   
						retorno = query.list();
															  
						
					} catch (HibernateException e) {
						// levanta a exce??o para a pr?xima camada
						throw new ErroRepositorioException(e, "Erro no Hibernate");
					} finally {
						// fecha a sess?o
						HibernateUtil.closeSession(sessao);
					}

					return retorno;
					
	}
	
	/**
	 * UC1198 - Relatório das Multas de Autos de Infração Pendentes
	 * [SB0001] - Verificar itens de parcelamento a partir de débito cobrado
	 * [SB0002] - Verificar itens de parcelamento a partir do débito a cobrar
	 * 
	 * @author Hugo Azevedo
	 * @date 11/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	
	
	public Collection pesquisarItensParcelamentosNivel1(Integer idDebACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;
		

		try {
			 consulta = " select debacob1.dbac_id" + //0
				   	  /*" CASE WHEN" +
				   	  " exists(" +
				   	  "  	Select * from faturamento.deb_a_cobrar_hist debch " +
				   	  " 	where debch.parc_id is not null and debch.dbac_id = pi.dbac_id " +
				   	  " ) " +
				   	  "	THEN 1" +
				   	  "	else 2" +
				   	  " END" +
				   	  " as s003 " +*/
				   	  " from faturamento.debito_a_cobrar debacob " +
				   	  " inner join cobranca.parcelamento_item pi on pi.dbac_id = debacob.dbac_id " +
				   	  " inner join faturamento.debito_a_cobrar debacob1 on pi.parc_id = debacob1.parc_id " +
				   	  " inner join faturamento.autos_infr_deb_a_cobrar autosInfracaoDebitoACobrar on debacob.dbac_id = autosInfracaoDebitoACobrar.dbac_id " +
				   	  " left join faturamento.debito_cobrado debcob on debcob.dbac_id = debacob1.dbac_id " +
				   	  " left join faturamento.conta cnta on cnta.cnta_id = debcob.cnta_id " +
				   	  " where debacob.dcst_idatual = 5 " +
				   	  " and debacob.dbac_id = :idDebACobrar" +
					  " and cnta.cnta_id not in ( " +
					  "		select pagt.cnta_id from arrecadacao.pagamento pagt " +
					  "		inner join arrecadacao.pagamento_historico pagth on pagth.cnta_id = cnta.cnta_id " +
					  "		where pagt.cnta_id = cnta.cnta_id " +
					  "		or pagth.cnta_id = cnta.cnta_id   " +
					  " )";				
					
			retorno = (Collection<Object[]>)session.createSQLQuery(consulta)
					.addScalar("dbac_id",Hibernate.INTEGER)
					//.addScalar("s003",Hibernate.INTEGER)
					.setInteger("idDebACobrar",idDebACobrar).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	

	
	/**
	 * UC1198 - Relatório das Multas de Autos de Infração Pendentes
	 * [SB0003]-Verificar itens de parcelamento a partir de débito a cobrar de nível 2
	 * [SB0004]-Verificar itens de parcelamento a partir de débito cobrado de nível 2
	 * 
	 * @author Hugo Azevedo
	 * @date 11/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	
	public Collection pesquisarItensParcelamentosNivel2(Integer idDebACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;
		

		try {
			/*consulta = " select pi.cnta_id "//0
					+ " from cobranca.parcelamento_item pi "
					+ " inner join faturamento.debito_a_cobrar_historico dach on dac.parc_id = pi.parc_id "
					+ " inner join faturamento.debito_cobrado dbcb on dbcb.dbac_id = dach.dbac_id "
					+ " left join faturamento.conta cnta on cnta.cnta_id = dbcb.cnta_id"
					+ " where  pi.cntaid = :idConta "
					+ " and cnta.cnta_id not in ("
					+ "       select pagt.cnta_id from arrecadacao.pagamento pagt"
					+ "       where pagt.cnta_id = debcob.cnta_id) "
					+ ")";*/
			
			 consulta = " select debacob2.dbac_id " +
					  " from faturamento.debito_a_cobrar debacob1 " +
					  " inner join cobranca.parcelamento_item pi2 on pi2.dbac_id = debacob1.dbac_id " +
					  " inner join faturamento.debito_a_cobrar debacob2 on pi2.parc_id = debacob2.parc_id " +
					  " left join faturamento.debito_cobrado debcob2 on debcob2.dbac_id = debacob2.dbac_id " +
					  " left join faturamento.conta cnta2 on cnta2.cnta_id = debcob2.cnta_id " +
					  " where debacob1.dbac_id = :idDebACobrar " +
					  //" and debacob.dcst_idatual = 5 " +
					  " and cnta2.cnta_id not in ( " +
					  "		select pagt.cnta_id from arrecadacao.pagamento pagt " +
					  "		inner join arrecadacao.pagamento_historico pagth on pagth.cnta_id = cnta2.cnta_id " +
					  "		where pagt.cnta_id = cnta2.cnta_id " +
					  "		or pagth.cnta_id = cnta2.cnta_id   " +
					  " )";				
					
					
					
			retorno = (Collection<Object[]>)session.createSQLQuery(consulta)
					.addScalar("dbac_id",Hibernate.INTEGER)
					.setInteger("idDebACobrar",idDebACobrar).list(); 
					

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}	
	
	/**
	 * [UC0713] Emitir Ordem de Serviço Seletiva
	 * [SB0002] Gerar TXT 
	 * 
	 * @author Vivianne Sousa
	 * @date 29/06/2011
	 */
	public Integer pesquisarFaturamentoGrupoImovel(Integer idImovel)
			throws ErroRepositorioException {
		
		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT fatGrupo.id "
					+ "FROM Imovel imov " 
					+ "INNER JOIN imov.quadra qdr "
					+ "INNER JOIN qdr.rota rota "
					+ "INNER JOIN rota.faturamentoGrupo fatGrupo "
					+ "WHERE imov.id = :idImovel ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0840] - Atualizar Faturamento do Movimento Celular
	 * 
	 * @author Raphael Rossiter
     * @date 20/07/2011
	 * 
	 * @param idConta
	 * @param idMedicaoTipo
	 * @return MovimentoContaPrefaturada
	 * @throws ErroRepositorioException
	 */
	public MovimentoContaPrefaturada pesquisarMovimentoContaPrefaturadaPorIdConta(Integer idConta, Integer idMedicaoTipo)
		throws ErroRepositorioException {
	
		MovimentoContaPrefaturada retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		
		try {
			consulta = "SELECT mcpf "
					+ "FROM MovimentoContaPrefaturada as mcpf "
					+ "INNER JOIN mcpf.conta as cnta "
					+ "INNER JOIN mcpf.medicaoTipo as medt "
					+ "INNER JOIN FETCH mcpf.imovel as imov "
					+ "LEFT JOIN FETCH mcpf.consumoTipo as cstp "
					+ "LEFT JOIN FETCH mcpf.consumoAnormalidade as csan "
					+ "WHERE cnta.id = :idConta AND medt.id = :idMedicaoTipo ";
		
			retorno = (MovimentoContaPrefaturada) session.createQuery(consulta)
						.setInteger("idConta", idConta.intValue())
						.setInteger("idMedicaoTipo", idMedicaoTipo.intValue()).setMaxResults(1).uniqueResult();
		
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}


	/**
	 * Acumula o valor de agua cancelado por retificação
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Rafael Pinto
	 * @date 20/07/2011
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal diferencaValorAguaCanceladaRetificacao(
			int anoMesReferencia,int idLocalidade,int idCategoria) throws ErroRepositorioException {
			BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			
			consulta = "select sum( coalesce(cg4.ctcg_vlagua,0) - coalesce(cg1.ctcg_vlagua,0)) as valorCanceladoAgua "
				+ " from faturamento.conta c4 "
				+ " inner join faturamento.conta_categoria cg4 on c4.cnta_id = cg4.cnta_id and cg4.catg_id = :idCategoria "
				+ " inner join faturamento.conta c1 on (c1.imov_id = c4.imov_id "
				+ " and c1.cnta_amreferenciaconta = c4.cnta_amreferenciaconta "
				+ " and c4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao "
				+ " and (c1.dcst_idatual = :debitoCreditoSituacaoRetificada or c1.dcst_idanterior = :debitoCreditoSituacaoRetificada) "
				+ " and c4.cnta_amreferenciacontabil = :anoMesReferencia) "
				+ " left join faturamento.conta_categoria cg1 on (c1.cnta_id = cg1.cnta_id and cg1.catg_id = cg4.catg_id and cg1.scat_id = cg4.scat_id)"
				+ " where coalesce(cg4.ctcg_vlagua,0) > coalesce(cg1.ctcg_vlagua,0)" 
				+ " and c4.loca_id = :idLocalidade" ;

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorCanceladoAgua", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				uniqueResult();
			
			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Acumula o valor de esgoto cancelado por retificação
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Rafael Pinto
	 * @date 20/07/2011
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal diferencaValorEsgotoCanceladaRetificacao(
			int anoMesReferencia,int idLocalidade,int idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			
			consulta = "select sum( coalesce(cg4.ctcg_vlesgoto,0) - coalesce(cg1.ctcg_vlesgoto,0)) as valorCanceladoAgua "
				+ " from faturamento.conta c4 "
				+ " inner join faturamento.conta_categoria cg4 on c4.cnta_id = cg4.cnta_id and cg4.catg_id = :idCategoria "
				+ " inner join faturamento.conta c1 on (c1.imov_id = c4.imov_id "
				+ " and c1.cnta_amreferenciaconta = c4.cnta_amreferenciaconta "
				+ " and c4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao "
				+ " and (c1.dcst_idatual = :debitoCreditoSituacaoRetificada or c1.dcst_idanterior = :debitoCreditoSituacaoRetificada) "
				+ " and c4.cnta_amreferenciacontabil = :anoMesReferencia) "
				+ " left join faturamento.conta_categoria cg1 on (c1.cnta_id = cg1.cnta_id and cg1.catg_id = cg4.catg_id and cg1.scat_id = cg4.scat_id)"
				+ " where coalesce(cg4.ctcg_vlesgoto,0) > coalesce(cg1.ctcg_vlesgoto,0)" 
				+ " and c4.loca_id = :idLocalidade" ;

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorCanceladoAgua", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				uniqueResult();
			
			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Acumula o valor de agua incluido por retificacao
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Rafael Pinto
	 * @date 20/07/2011
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal diferencaValorAguaRetificada(
			int anoMesReferencia,int idLocalidade,int idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(cg1.ctcg_vlagua,0) - coalesce(cg4.ctcg_vlagua,0)) as valorIncluidoAgua"
				+ " from faturamento.conta c1"
				+ " inner join faturamento.conta_categoria cg1 on c1.cnta_id = cg1.cnta_id and cg1.catg_id = :idCategoria"
				+ " inner join faturamento.conta c4 on (c4.imov_id = c1.imov_id "
				+ " and c4.cnta_amreferenciacontabil = :anoMesReferencia"
				+ " and c4.cnta_amreferenciaconta = c1.cnta_amreferenciaconta"
				+ " and c4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao"
				+ " and (c1.dcst_idatual = :debitoCreditoSituacaoRetificada or c1.dcst_idanterior = :debitoCreditoSituacaoRetificada) )"
				+ " left join faturamento.conta_categoria cg4 on (c4.cnta_id = cg4.cnta_id and cg4.catg_id = cg1.catg_id and cg4.scat_id = cg1.scat_id)"
				+ " where coalesce(cg1.ctcg_vlagua,0) > coalesce(cg4.ctcg_vlagua,0)"
				+ " and c1.loca_id = :idLocalidade";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorIncluidoAgua", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				uniqueResult();
			
			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Acumula o valor de esgoto incluido por retificacao
	 * 
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Rafael Pinto
	 * @date 20/07/2011
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal diferencaValorEsgotoRetificada(
			int anoMesReferencia,int idLocalidade,int idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(cg1.ctcg_vlesgoto,0) - coalesce(cg4.ctcg_vlesgoto,0)) as valorIncluidoAgua"
				+ " from faturamento.conta c1"
				+ " inner join faturamento.conta_categoria cg1 on c1.cnta_id = cg1.cnta_id and cg1.catg_id = :idCategoria"
				+ " inner join faturamento.conta c4 on (c4.imov_id = c1.imov_id "
				+ " and c4.cnta_amreferenciacontabil = :anoMesReferencia"
				+ " and c4.cnta_amreferenciaconta = c1.cnta_amreferenciaconta"
				+ " and c4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao"
				+ " and (c1.dcst_idatual = :debitoCreditoSituacaoRetificada or c1.dcst_idanterior = :debitoCreditoSituacaoRetificada) )"
				+ " left join faturamento.conta_categoria cg4 on (c4.cnta_id = cg4.cnta_id and cg4.catg_id = cg1.catg_id and cg4.scat_id = cg1.scat_id)"
				+ " where coalesce(cg1.ctcg_vlesgoto,0) > coalesce(cg4.ctcg_vlesgoto,0)"
				+ " and c1.loca_id = :idLocalidade";

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorIncluidoAgua", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				uniqueResult();
			
			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	
	/**
	 * [UC0840] - Atualizar Faturamento do Movimento Celular
	 * 
	 * @author Raphael Rossiter
     * @date 20/07/2011
	 * 
	 * @param movimentoContaPrefaturada
	 * @throws ErroRepositorioException
	 */
	public void atualizarMedicaoHistoricoMovimentoCelular(MovimentoContaPrefaturada movimentoContaPrefaturada) 
		throws ErroRepositorioException {
	

		String update;
		Session session = HibernateUtil.getSession();

		try {
			
			update = "UPDATE MedicaoHistorico SET "
					+ "mdhi_tmultimaalteracao = :dataAtual, "
					+ "mdhi_nnleituraatualfaturamento = " 
					+ (movimentoContaPrefaturada.getLeituraFaturamento() == null ? null : movimentoContaPrefaturada.getLeituraFaturamento()) + ", "
					+ "mdhi_nnconsumomedidomes = "
					+ (movimentoContaPrefaturada.getConsumoMedido() == null ? null : movimentoContaPrefaturada.getConsumoMedido());
			
			if (movimentoContaPrefaturada.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){
					
				update += " WHERE lagu_id = :idImovel ";
			}
			else{
					
				update += " WHERE imov_id = :idImovel ";
			}
				
			update += "AND medt_id = :idMedicaoTipo AND mdhi_amleitura = :anoMesLeitura";
	
			session.createQuery(update)
					.setTimestamp("dataAtual", new Date())
					.setInteger("idImovel", movimentoContaPrefaturada.getImovel().getId())
					.setInteger("idMedicaoTipo", movimentoContaPrefaturada.getMedicaoTipo().getId())
					.setInteger("anoMesLeitura", movimentoContaPrefaturada.getAnoMesReferenciaPreFaturamento()).executeUpdate();
			
			

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0840] - Atualizar Faturamento do Movimento Celular
	 * 
	 * @author Raphael Rossiter
     * @date 20/07/2011
	 * 
	 * @param movimentoContaPrefaturada
	 * @param consumo
	 * @param idConsumoHistoricoImovelCondominio
	 * @param consumoImovelVinculadosCondominio
	 * @throws ErroRepositorioException
	 */
	public void atualizarConsumoHistoricoMovimentoCelular(MovimentoContaPrefaturada movimentoContaPrefaturada, Integer consumo,
			Integer idConsumoHistoricoImovelCondominio, Integer consumoImovelVinculadosCondominio) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			update = "UPDATE ConsumoHistorico SET "
					+ "cshi_nnconsumofaturadomes = :cosumoFaturaoMes, "
					+ "cshi_nnconsumocalculomedia = :cosumoFaturaoMes, "
					+ "cshi_tmultimaalteracao = :dataAtual, "
					+ "cstp_id = " 
					+ (movimentoContaPrefaturada.getConsumoTipo() == null ? null : movimentoContaPrefaturada.getConsumoTipo().getId()) + ", "
					+ "csan_id = "
					+ (movimentoContaPrefaturada.getConsumoAnormalidade() == null ? null : movimentoContaPrefaturada.getConsumoAnormalidade().getId());
			
					if (idConsumoHistoricoImovelCondominio != null){
						
						update += ", "
							+ "cshi_idconsumoimovelcondominio = " + idConsumoHistoricoImovelCondominio + ", "
							+ "cshi_nnconsimoveisvinculados = " 
							+ (consumoImovelVinculadosCondominio == null ? null : consumoImovelVinculadosCondominio);
						
						if (movimentoContaPrefaturada.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){
							
							update += ", "
								+ "cshi_nnconsumorateio = " + movimentoContaPrefaturada.getConsumoRateioAgua();
						}
						else{
							
							update += ", "
								+ "cshi_nnconsumorateio = " + movimentoContaPrefaturada.getConsumoRateioEsgoto();
						}
					}
					
					update += " WHERE imov_id = :idImovel AND lgti_id = :idMedicaoTipo AND cshi_amfaturamento = :anoMesReferencia";
			
			session.createQuery(update)
					.setInteger("cosumoFaturaoMes", consumo)
					.setTimestamp("dataAtual", new Date())
					.setInteger("idImovel", movimentoContaPrefaturada.getImovel().getId())
					.setInteger("idMedicaoTipo", movimentoContaPrefaturada.getMedicaoTipo().getId())
					.setInteger("anoMesReferencia", movimentoContaPrefaturada.getAnoMesReferenciaPreFaturamento()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * @author Gustavo Amaral
	 * @date 20/07/2011
	 * 
	 */
	public void atualizarIndicadorContaHistorico(Integer idFaturaItem) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "UPDATE FaturaItem faturaItem ";

			consulta = consulta
					+ "SET faturaItem.indicadorUsoAtivo = :indicadorUsoAtivo "
					+ "WHERE faturaItem.id = :idFaturaItem ";

			session.createQuery(consulta).setInteger("idFaturaItem", idFaturaItem)
					.setInteger("indicadorUsoAtivo", new Integer(ConstantesSistema.NAO))
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}


	//	Tiago Moreno - 21/07/11
	public Collection pesquisarContaCategoriaResumo(Integer idConta) throws ErroRepositorioException {
		Collection retorno = new ArrayList();
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
		
			consulta = "select contaCategoria "
					+ "from ContaCategoria contaCategoria "
					+ "inner join contaCategoria.comp_id.conta conta "
					+ "inner join fetch contaCategoria.comp_id.categoria categoria "
					+ "inner join fetch contaCategoria.comp_id.subcategoria subcategoria "
					+ "where conta.id = :idConta ";
		
			retorno = new ArrayList(session
					.createQuery(consulta).setInteger("idConta", idConta)
					.list());
		
	
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	//Tiago Moreno - 21/07/11
	public Collection pesquisarDebitoCobradoCategoriaResumo(Integer idConta) throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
		
			consulta = "select debitoCobradoCategoria "
					+ "from DebitoCobradoCategoria debitoCobradoCategoria " 
					+ "inner join fetch debitoCobradoCategoria.debitoCobrado debitoCobrado " 
					+ "inner join fetch debitoCobrado.conta conta "
					+ "inner join fetch debitoCobrado.lancamentoItemContabil lancamentoItemContabil "
					+ "inner join fetch debitoCobrado.financiamentoTipo financiamentoTipo "
					+ "inner join fetch debitoCobrado.debitoTipo debitoTipo "
					+ "inner join fetch debitoCobradoCategoria.categoria categoria "
					+ "where conta.id = :idConta ";
		
			retorno = new ArrayList(session
					.createQuery(consulta).setInteger("idConta", idConta)
					.list());
		
	
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	//Tiago Moreno - 21/07/11
	
	public Collection pesquisarCreditoRealizadoCategoriaResumo(Integer idConta) throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
		
			consulta = "select creditoRealizadoCategoria "
					+ "from CreditoRealizadoCategoria creditoRealizadoCategoria " 
					+ "inner join fetch creditoRealizadoCategoria.creditoRealizado creditoRealizado " 
					+ "inner join fetch creditoRealizado.conta conta "
					+ "inner join fetch creditoRealizado.creditoOrigem creditoOrigem "
					+ "inner join fetch creditoRealizado.lancamentoItemContabil lancamentoItemContabil "
					+ "inner join fetch creditoRealizado.creditoTipo creditoTipo "
					+ "inner join fetch creditoRealizadoCategoria.categoria categoria " 
					+ "where conta.id = :idConta ";
		
			retorno = new ArrayList(session
					.createQuery(consulta).setInteger("idConta", idConta)
					.list());
		
	
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	public Integer obterQuantidadeDebitoCobrados(
			Integer idConta) throws ErroRepositorioException {
		
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(debitoCobrado.id) "
				+ "from DebitoCobrado debitoCobrado " 
				+ "inner join debitoCobrado.conta conta "
				+ "where conta.id = :idConta ";
			
			retorno = (Integer) session.createQuery(consulta)
						.setInteger("idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Integer obterQuantidadeCreditosRealizados(
			Integer idConta) throws ErroRepositorioException {
		
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(creditoRealizado.id) "
				+ "from CreditoRealizado creditoRealizado " 
				+ "inner join creditoRealizado.conta conta "
				+ "where conta.id = :idConta ";
			
			retorno = (Integer) session.createQuery(consulta)
						.setInteger("idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection pesquisarGuiaPagamentoCategoriaResumo(Integer idGuiaPagamento) throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
		
			consulta = "select guiaPagamentoCategoria "
					+ "from GuiaPagamentoCategoria guiaPagamentoCategoria " 
					+ "inner join fetch guiaPagamentoCategoria.guiaPagamento guiaPagamento " 
					+ "inner join fetch guiaPagamentoCategoria.categoria "
					+ "where guiaPagamento.id = :idGuiaPagamento ";
		
			retorno = new ArrayList(session
					.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento)
					.list());
		
	
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	public Collection pesquisarDebitoACobrarCategoriaResumo(Integer idDebitoACobrar) throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
		
			consulta = "select debitoACobrarCategoria "
					+ "from DebitoACobrarCategoria debitoACobrarCategoria " 
					+ "inner join fetch debitoACobrarCategoria.debitoACobrar debitoACobrar " 
					+ "inner join fetch debitoACobrarCategoria.categoria "
					+ "where debitoACobrar.id = :idDebitoACobrar ";
		
			retorno = new ArrayList(session
					.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar)
					.list());
		
	
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	public Collection pesquisarCreditoARealizarCategoriaResumo(Integer idCreditoARealizar) throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
		
			consulta = "select creditoARealizarCategoria "
					+ "from CreditoARealizarCategoria creditoARealizarCategoria " 
					+ "inner join fetch creditoARealizarCategoria.creditoARealizar creditoARealizar " 
					+ "inner join fetch creditoARealizarCategoria.categoria "
					+ "where creditoARealizar.id = :idCreditoARealizar ";
		
			retorno = new ArrayList(session
					.createQuery(consulta).setInteger("idCreditoARealizar", idCreditoARealizar)
					.list());
		
	
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	public Integer pesquisarQuantidadeEconomiasCreditoARealizar(Integer idCreditoARealizar) throws ErroRepositorioException {

		Integer retorno = new Integer(0);
		
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
		
			consulta = "select sum(creditoARealizarCategoria.quantidadeEconomia) "
					+ "from CreditoARealizarCategoria creditoARealizarCategoria " 
					+ "inner join creditoARealizarCategoria.creditoARealizar creditoARealizar "
					+ "where creditoARealizar.id = :idCreditoARealizar ";
		
			retorno = (Integer) session.createQuery(consulta).setInteger("idCreditoARealizar", idCreditoARealizar).setMaxResults(1).uniqueResult();
		
	
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}

/**
	 * [UC1194] Consultar Estrutura Tarifária Loja Virtual
	 * [SB0001]  Pesquisar Tarifa Social ou Tarifa Mínima
	 * 
	 * Método que vai retornar um Helper que possui o consumo
	 * da tarifa mínima e da tarifa social e seus respectivos
	 * valores.
	 * 
	 * @author Diogo Peixoto
	 * @since 14/07/2011
	 * 
	 * @param idTarifa
	 * @param idCategoria
	 * 
	 * @throws ErroRepositorioException
	 * 
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarTarifaSocialOuTarifaMinima(Integer idTarifa, Integer idCategoria) throws ErroRepositorioException {
		
		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();

		try {
			
			sb.append("SELECT ");
			sb.append("cstc_nnconsumominimo AS consumo, ");
			sb.append("cstc_vltarifaminima AS valor, ");
			sb.append("catg_dscategoria AS categoriaImovel ");
			sb.append("FROM faturamento.consumo_tarifa_vigencia consumoTarifaVigencia, ");
			sb.append("faturamento.consumo_tarifa consumoTarifa, ");
			sb.append("faturamento.consumo_tarifa_categoria consumoTarifaCategoria, ");
			sb.append("cadastro.categoria categoriaImovel ");
			sb.append("WHERE ");
			sb.append("consumoTarifa.cstf_id = :idTarifa ");
			sb.append("AND consumoTarifaVigencia.cstf_id = consumoTarifa.cstf_id ");
			sb.append("AND consumoTarifaVigencia.cstv_dtvigencia = ");
			sb.append("(SELECT MAX(cstv_dtvigencia) ");
			sb.append("FROM faturamento.consumo_tarifa_vigencia ");
			sb.append("WHERE cstf_id = consumoTarifa.cstf_id) ");
			sb.append("AND consumoTarifaCategoria.cstv_id = consumoTarifaVigencia.cstv_id ");
			sb.append("AND consumoTarifaCategoria.catg_id = categoriaImovel.catg_id ");
			sb.append("AND categoriaImovel.catg_id = :idCategoria");
			
			SQLQuery query = session.createSQLQuery(sb.toString());
			query = query.addScalar("consumo", Hibernate.STRING).
						  addScalar("valor", Hibernate.BIG_DECIMAL).
						  addScalar("categoriaImovel", Hibernate.STRING);
			retorno = query.setInteger("idTarifa", idTarifa).
				setInteger("idCategoria", idCategoria).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC1194] Consultar Estrutura Tarifária Loja Virtual
	 * [SB0001]  Pesquisar Tarifa Normal
	 * 
	 * Método que vai retornar um Helper que possui o consumo
	 * da tarifa normal e seus respectivos valores.
	 * 
	 * @author Diogo Peixoto
	 * @since 14/07/2011
	 * 
	 * @param idTarifa
	 * @param idCategoria
	 * 
	 * @throws ErroRepositorioException
	 * 
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarTarifaNormal(Integer idTarifa, Integer idCategoria) throws ErroRepositorioException{
		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();

		try {
			
			sb.append("SELECT ");
			sb.append("ctfx_nncosumofaixainicio AS faixaInicio, ");
			sb.append("ctfx_nnconsumofaixafim AS faixaFim, ");
			sb.append("ctfx_vlconsumotarifa AS valorConsumo, ");
			sb.append("catg_dscategoria AS categoriaImovel ");
			sb.append("FROM faturamento.consumo_tarifa_vigencia consumoTarifaVigencia, ");
			sb.append("faturamento.consumo_tarifa consumoTarifa, ");
			sb.append("faturamento.consumo_tarifa_categoria consumoTarifaCategoria, ");
			sb.append("faturamento.consumo_tarifa_faixa consumoTarifaFaixa, ");
			sb.append("cadastro.categoria categoriaImovel ");
			sb.append("WHERE ");
			sb.append("consumoTarifa.cstf_id = :idTarifa ");
			sb.append("AND consumoTarifaVigencia.cstf_id = consumoTarifa.cstf_id ");
			sb.append("AND consumoTarifaVigencia.cstv_dtvigencia = ");
			sb.append("(SELECT MAX(cstv_dtvigencia) ");
			sb.append("FROM faturamento.consumo_tarifa_vigencia ");
			sb.append("WHERE cstf_id = consumoTarifa.cstf_id) ");
			sb.append("AND consumoTarifaCategoria.cstv_id = consumoTarifaVigencia.cstv_id ");
			sb.append("AND consumotarifacategoria.catg_id = :idCategoria ");
			sb.append("AND consumoTarifaFaixa.cstc_id = consumoTarifaCategoria.cstc_id ");
			sb.append("AND consumotarifacategoria.catg_id = categoriaImovel.catg_id ");
			sb.append("ORDER BY faixaInicio");
			
			SQLQuery query = session.createSQLQuery(sb.toString());
			query = query.addScalar("faixaInicio", Hibernate.STRING).
			addScalar("faixaFim", Hibernate.STRING).			  
			addScalar("valorConsumo", Hibernate.BIG_DECIMAL).
			addScalar("categoriaImovel", Hibernate.STRING);
			
			retorno = query.setInteger("idTarifa", idTarifa).
				setInteger("idCategoria", idCategoria).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1194] Consultar Estrutura Tarifária Loja Virtual 
	 * 
	 * Método que vai retornar um Helper que possui o consumo não medido
	 * de chafariz público.
	 * 
	 * @author Diogo Peixoto
	 * @since 06/09/2011
	 * 
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarEstruturaTarifariaChafarizPublico() throws ErroRepositorioException{
		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();

		try {
			
			sb.append("SELECT ");
			sb.append("'por 1.000L' AS consumo, ");
			sb.append("ctfx_vlconsumotarifa AS valor, ");
			sb.append("'Chafariz Público' AS categoriaImovel ");
			sb.append("FROM faturamento.consumo_tarifa_vigencia consumoTarifaVigencia, ");
			sb.append("faturamento.consumo_tarifa consumoTarifa, ");
			sb.append("faturamento.consumo_tarifa_categoria consumoTarifaCategoria, ");
			sb.append("faturamento.consumo_tarifa_faixa consumoTarifaFaixa ");
			sb.append("WHERE ");
			sb.append("consumoTarifa.cstf_id = 20 ");
			sb.append("AND consumoTarifaVigencia.cstf_id = consumoTarifa.cstf_id ");
			sb.append("AND consumoTarifaVigencia.cstv_dtvigencia = ");
			sb.append("(SELECT MAX(cstv_dtvigencia) ");
			sb.append("FROM faturamento.consumo_tarifa_vigencia ");
			sb.append("WHERE cstf_id = consumoTarifa.cstf_id) ");
			sb.append("AND consumoTarifaCategoria.cstv_id = consumoTarifaVigencia.cstv_id ");
			sb.append("AND consumotarifacategoria.catg_id = 4 ");
			sb.append("AND consumoTarifaFaixa.cstc_id = consumoTarifaCategoria.cstc_id ");
			sb.append("ORDER BY ctfx_nncosumofaixainicio");
			
			SQLQuery query = session.createSQLQuery(sb.toString());
			query = query.addScalar("consumo", Hibernate.STRING).			  
			addScalar("valor", Hibernate.BIG_DECIMAL).
			addScalar("categoriaImovel", Hibernate.STRING);
			
			retorno = query.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC1187] Colocar Débito a Cobrar em Revisão
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param debitoACobrar
	 * @throws ErroRepositorioException
	 */
	public void colocarRevisaoDebitoACobrar(DebitoACobrar debitoACobrar)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			update = "UPDATE gcom.faturamento.debito.DebitoACobrar SET "
					+ "dbac_dtrevisao = :dataRevisao, cmrv_id = :motivoRevisao, "
					+ "dbac_tmultimaalteracao = :dataUltimaAlteracao, "
					+ "usur_id = :usuarioLogado " + "WHERE dbac_id = :idDebitoACobrar ";

			session.createQuery(update)
						.setDate("dataRevisao", debitoACobrar.getDataRevisao())
						.setInteger("motivoRevisao", debitoACobrar.getContaMotivoRevisao().getId())
						.setTimestamp("dataUltimaAlteracao", debitoACobrar.getUltimaAlteracao())
						.setInteger("idDebitoACobrar", debitoACobrar.getId())
						.setInteger("usuarioLogado", debitoACobrar.getUsuario().getId())
					.executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1188] Retirar Débito A Cobrar de Revisão
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param debitoACobrar
	 * @throws ErroRepositorioException
	 */
	public void retirarDebitoACobrarRevisao(DebitoACobrar debitoACobrar)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			update = "UPDATE gcom.faturamento.debito.DebitoACobrar SET "
					+ "dbac_dtrevisao = null, cmrv_id = null, "
					+ "dbac_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE dbac_id = :idDebitoACobrar ";

			session.createQuery(update)
						.setTimestamp("dataUltimaAlteracao", debitoACobrar.getUltimaAlteracao())
						.setInteger("idDebitoACobrar", debitoACobrar.getId())
					.executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
     * [UC1136] Inserir Contrato de Parcelamento por Cliente
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param idDebitoACobrar
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public DebitoACobrar obterDebitoACobrar(Integer idDebitoACobrar)
			throws ErroRepositorioException {

		DebitoACobrar retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT debitoACobrar " + "FROM DebitoACobrar debitoACobrar "
					+ "WHERE debitoACobrar.id = :idDebitoACobrar ";

			retorno = (DebitoACobrar) session.createQuery(consulta)
							.setInteger("idDebitoACobrar", idDebitoACobrar)
							.setMaxResults(1)
							.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC1216] Suspender Leitura para Imóvel com Hidrômetro Retirado
	 * 
	 * [SB0001]  Selecionar Imóveis com Hidrômetro Retirado
	 *
	 * @author Vivianne Sousa
	 * @date 23/08/2011
	 *
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarImovelNumeroDeOcorrenciasConsecultivasAnormalidades(			
			Integer idAnormalidade, Integer qtdAnormalidades, Integer referenciaFaturamento,
			Integer grupofaturamento,Integer idRota )throws ErroRepositorioException {
		
		Collection retorno = new ArrayList();		
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "SELECT idImovel FROM (" +		  
			"	select imovel.imov_id  as idImovel, mh.ltan_idleitanorminformada "+                                                
			"	from  micromedicao.medicao_historico mh " +
			"	inner join cadastro.imovel imovel on mh.lagu_id = imovel.imov_id " +
			"   inner join cadastro.quadra quadra on quadra.qdra_id = imovel.qdra_id " +
			"   inner join micromedicao.rota rota on rota.rota_id = quadra.rota_id ";
			
			int numOcorrencias = (qtdAnormalidades.intValue()) + 1;
			List<String> anoMesOcorrencias = new ArrayList<String>();
			for (int i = 1; i < numOcorrencias; i++) {
			    anoMesOcorrencias.add(Integer.toString(Util.subtrairMesDoAnoMes(referenciaFaturamento, i)));
			}
			
			consulta = consulta +
			"   where mh.mdhi_amleitura in (:anoMesOcorrencias) "+
			"	and mh.ltan_idleitanorminformada  = :idAnormalidade " +
			" 	and rota.ftgr_id = :grupofaturamento " +
			" 	and rota.rota_id = :idRota " +
			"   and mh.medt_id = :ligacaoAgua " +
			"   and imovel.ftst_id is null " + 
			"	group by imovel.imov_id, mh.ltan_idleitanorminformada " +
			"	having Count(imovel.imov_id) >= :qtdAnormalidades ) temp ";
			
			retorno = session.createSQLQuery(consulta)
			.addScalar("idImovel", Hibernate.INTEGER)
			.setParameterList("anoMesOcorrencias", anoMesOcorrencias)
			.setInteger("idAnormalidade", idAnormalidade)
			.setInteger("qtdAnormalidades", qtdAnormalidades)
			.setInteger("grupofaturamento",grupofaturamento)
			.setInteger("idRota",idRota)
			.setInteger("ligacaoAgua",MedicaoTipo.LIGACAO_AGUA)
			.list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC1216] Suspender Leitura para Imóvel com Hidrômetro Retirado
	 * [SB0003]  Incluir Imóvel na Situação Especial de Faturamento
	 *
	 * @author Vivianne Sousa
	 * @date 23/08/2011
	 *
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public LeituraAnormalidade obterNumeroMesesLeituraSuspensaLeituraAnormalidade(Integer idLeituraAnormalidade)
			throws ErroRepositorioException {

		LeituraAnormalidade retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT ltan " 
					+ "FROM LeituraAnormalidade ltan "
					+ "WHERE ltan.id = :idLeituraAnormalidade ";

			retorno = (LeituraAnormalidade) session.createQuery(consulta)
							.setInteger("idLeituraAnormalidade", idLeituraAnormalidade)
							.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC1218] Suspender Leitura para Imóvel com Consumo Real não Superior a 10m3
	 *
	 * @author Vivianne Sousa
	 * @date 26/08/2011
	 *
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarImovelComConsumoRealNaoSuperiorA10(			
			Integer qtdConsumoRealNaoSuperiorA10, Integer referenciaFaturamento,
			Integer grupofaturamento,Integer idRota , 
			Integer numeroMesesReinicioSitEspFaturamento)throws ErroRepositorioException {
		
		Collection retorno = new ArrayList();		
		Session session = HibernateUtil.getSession();
		try {
			
			int numOcorrencias = (qtdConsumoRealNaoSuperiorA10.intValue()) + 1;
			List<String> anoMesOcorrencias = new ArrayList<String>();
			for (int i = 1; i < numOcorrencias; i++) {
			    anoMesOcorrencias.add(Integer.toString(Util.subtrairMesDoAnoMes(referenciaFaturamento, i)));
			}
			
			int referenciaFaturamentoMenosUm  = Util.subtrairMesDoAnoMes(referenciaFaturamento, 1);
			int referenciaFaturamentoRetirada = Util.subtrairMesDoAnoMes(referenciaFaturamento, numeroMesesReinicioSitEspFaturamento);
			
			String consulta = "(Select imov.imov_id As idimovel"+
					" From Micromedicao.Consumo_Historico cshi"+
					" Inner Join Cadastro.imovel imov On cshi.imov_id = imov.imov_id"+
					" Inner Join Cadastro.Quadra qdra On qdra.qdra_id = imov.qdra_id"+
					" Inner Join Micromedicao.Rota rota On rota.rota_id = qdra.rota_id"+
					"                                  and rota.ftgr_id = :grupofaturamento"+
					" Where cshi.lgti_id = :ligacaoTipo"+
					" And cshi.cstp_id = :consumoTipo"+
					" And cshi.cshi_amfaturamento in (:anoMesOcorrencias)"+
					" And imov.ftst_id Is Null"+
					" And (cshi.cshi_nnconsumofaturadomes / imov.imov_qteconomia) <= :consumoReal" +
					" And rota.rota_id = :idRota "+
					" Group By imov.imov_id Having Count(imov.imov_id) >= :qtdConsumoRealNaoSuperiorA10)"+

					" UNION"+

					" (Select imov.imov_id As idimovel"+
					" From micromedicao.consumo_historico cshi"+
					" Inner Join Cadastro.imovel imov On cshi.imov_id = imov.imov_id"+
					" Inner Join Cadastro.Quadra qdra On qdra.qdra_id = imov.qdra_id"+
					" Inner Join Micromedicao.Rota rota On rota.rota_id = qdra.rota_id "+
					"                                  and rota.ftgr_id = :grupofaturamento"+
					" Inner Join Faturamento.Fatur_Situacao_Hist ftsh On ftsh.imov_id = imov.imov_id"+
					"                                                 and ftsh.ftst_id = :faturamentoSituacaoTipo"+
					"                                                 and ftsh.ftsh_amfaturamentoretirada = :referenciaFaturamentoRetirada"+
					" Where cshi.lgti_id = :ligacaoTipo"+
					" And cshi.cstp_id = :consumoTipo"+
					" And imov.ftst_id Is Null"+
					" And cshi.cshi_amfaturamento = :referenciaFaturamentoMenosUm"+
					" And (cshi.cshi_nnconsumofaturadomes / imov.imov_qteconomia) <= :consumoReal" +
					" And rota.rota_id = :idRota)" ;
			
			retorno = session.createSQLQuery(consulta)
			.addScalar("idImovel", Hibernate.INTEGER)
			.setParameterList("anoMesOcorrencias", anoMesOcorrencias)
			.setInteger("consumoTipo",ConsumoTipo.REAL)
			.setInteger("ligacaoTipo",LigacaoTipo.LIGACAO_AGUA)
			.setInteger("grupofaturamento",grupofaturamento)
			.setInteger("idRota",idRota)
			.setInteger("qtdConsumoRealNaoSuperiorA10", qtdConsumoRealNaoSuperiorA10)
			.setInteger("consumoReal",10)
			.setInteger("referenciaFaturamentoMenosUm",referenciaFaturamentoMenosUm)
			.setInteger("referenciaFaturamentoRetirada",referenciaFaturamentoRetirada)
			.setInteger("faturamentoSituacaoTipo",FaturamentoSituacaoTipo.PARALISAR_LEITURA_FATURAR_TAXA_MINIMA)
			.list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	

	/**
	 * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * [SB0002] ? Selecionar Débitos Pagos
	 * 
	 * @author Mariana Victor
	 * @date 23/08/2011
	 * 
	 * @param idImovel
	 * @param referenciaConta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaOuContaHistoricoDigitada(String idImovel,
			String referenciaConta) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = " SELECT conta.id, " +
					"   conta.anoMesReferenciaConta, " +
					"   conta.valorAgua, " +
					"   conta.valorEsgoto, " +
					"   conta.valorDebitos, " +
					"   conta.valorCreditos, " +
					"   conta.valorImposto, " +
					" FROM ContaHistorico conta "
					+ " INNER JOIN conta.imovel imov "
					+ " left join conta.debitoCreditoSituacaoAtual dcsa "
					+ " WHERE imov.id = :idImovel and "
					+ " conta.anoMesReferenciaConta = :referenciaConta "
					+ " and ( dcsa.id = :dcstNormal "
					+ "   or dcsa.id = :dcstRetif "
					+ "   or dcsa.id = :dcstIncluida) ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idImovel", new Integer(idImovel))
					.setInteger("referenciaConta", new Integer(referenciaConta))
					.setInteger("dcstNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("dcstRetif", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("dcstIncluida", DebitoCreditoSituacao.INCLUIDA)
					.setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0457] - Encerrar Ordem de Serviço
	 * [SB0009 - Verificar Situação Especial de Faturamento]
	 * 
	 * @param idImovel
	 * @return FaturamentoSituacaoHistorico
	 * @throws ErroRepositorioException
	 */
	public FaturamentoSituacaoHistorico pesquisarFaturamentoSituacaoHistorico(Integer idImovel) throws ErroRepositorioException {

		FaturamentoSituacaoHistorico historico = null;
		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		try {
			sb.append("SELECT situacaoHistorico ");
			sb.append("FROM FaturamentoSituacaoHistorico situacaoHistorico ");
			sb.append("WHERE situacaoHistorico.imovel.id = :idImovel ");

			historico = (FaturamentoSituacaoHistorico) session.createQuery(sb.toString())
					.setInteger("idImovel", new Integer(idImovel)).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return historico;
	}
	
	/**
	 * [UC0457] - Encerrar Ordem de Serviço
	 * [SB0009 - Verificar Situação Especial de Faturamento]
	 * 
	 * @param faturamentoSituacaoHistorico
	 * @throws ErroRepositorioException
	 */
	public void atualizarFaturamentoSituacaoHistorico(FaturamentoSituacaoHistorico faturamentoSituacaoHistorico) 
		throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try {
			session.update(faturamentoSituacaoHistorico);
			session.flush();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
     * [UC1136] Inserir Contrato de Parcelamento por Cliente
	 * 
	 * @author Mariana Victor
	 * @date 17/08/2011
	 * 
	 * @param codigoConstante
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public DebitoTipo obterDebitoTipoCodigoConstante(Integer codigoConstante)
			throws ErroRepositorioException {

		DebitoTipo retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT debitoTipo " + "FROM DebitoTipo debitoTipo "
					+ "WHERE debitoTipo.codigoConstante = :codigoConstante ";

			retorno = (DebitoTipo) session.createQuery(consulta)
							.setInteger("codigoConstante", codigoConstante)
							.setMaxResults(1)
							.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
     * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 29/08/2011
	 * 
	 * @param idImovel
	 * 
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterPercentualColetaEsgotoImovel(Integer idImovel)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT percentualAguaConsumidaColetada " + "FROM LigacaoEsgoto lesg "
					+ "WHERE lesg.id = :idImovel ";

			retorno = (BigDecimal) session.createQuery(consulta)
							.setInteger("idImovel", idImovel)
							.setMaxResults(1)
							.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 30/08/2011
	 * 
	 * @param idImovelMacro
	 * @param anoMesReferencia
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMovimentoContaPrefaturadaArquivoTextoFaturamento(Integer idImovelMacro, Integer anoMesReferencia)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT count(mcpf.id) "
					+ "FROM MovimentoContaPrefaturada mcpf "
					+ "INNER JOIN mcpf.imovel imovel "
					+ "WHERE imovel.imovelCondominio.id = :idImovelMacro and "
					+ "mcpf.anoMesReferenciaPreFaturamento = :anoMesReferencia ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idImovelMacro", idImovelMacro).setInteger("anoMesReferencia", anoMesReferencia)
					.setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Por Tiago Moreno
	 * Ajuste de mensagem da CAEMA
	 * Autorizado por Eduardo.
	 * 28/09/2011
	 */
	public String[] obterContaMensagemImovel(Integer imovelId, Integer amRef)
			throws ErroRepositorioException {
		String[] retorno = new String[3];

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "select mensagem1 as msg1, mensagem2 as msg2 , mensagem3 as msg3 "
					+ "from  "
					+ " faturamento.conta_mensagem_imovel cmi   "
					+ "where cmi.imov_id = :imovelId and cmi.ano_mes = :amRef ";

			Object[] retornoSQL = (Object[]) session.createSQLQuery(consulta).addScalar(
					"msg1", Hibernate.STRING).addScalar(
					"msg2", Hibernate.STRING).addScalar(
					"msg3", Hibernate.STRING).setInteger(
					"imovelId", imovelId.intValue()).setInteger(
					"amRef",	amRef).setMaxResults(1).uniqueResult();
			if (retornoSQL != null){
				retorno[0] = (String) retornoSQL[0];
				retorno[1] = (String) retornoSQL[1];
				retorno[2] = (String) retornoSQL[2];
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

 	
	
	/**
	 * autor: Adriana Muniz
	 * Data: 16/05/2011
	 * Método para retornar uma coleção de debitos cobrados do parcelamento
	 * */
	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0002] - Obter dados dos serviços de parcelamento
	 * 
	 * @author Adriana Muniz
	 * @date 13/05/2011
	 * 
	 * @param conta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoCobradoDeParcelamentoIS(Conta conta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT " +
                "  dbcb.numeroPrestacaoDebito, " +
                "  (dbcb.numeroPrestacao - COALESCE(dbcb.numeroParcelaBonus,0)) as totalParcela, " +
                "  SUM(dbcb.valorPrestacao), " +
                "  dbcb.debitoTipo.codigoConstante " +
                "FROM " +
                "  DebitoCobrado dbcb " +
                "  INNER JOIN dbcb.conta conta " +
                "  INNER JOIN dbcb.financiamentoTipo fntp " +
                "WHERE " +
                "  conta.id = :idConta AND " +
                "  fntp.id IN(:agua, :esgoto, :servico) " +
                "GROUP BY " +
                "  1, 2,4 ";

			retorno = session.createQuery(consulta).setInteger(
					"idConta", conta.getId()).setInteger("agua",
					FinanciamentoTipo.PARCELAMENTO_AGUA).setInteger("esgoto",
					FinanciamentoTipo.PARCELAMENTO_ESGOTO).setInteger(
					"servico", FinanciamentoTipo.PARCELAMENTO_SERVICO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

		/*
	 * 
	 * Método criado para não salvar na tabela de geração da rota
	 * todos os imóveis da rota, e sim, somente os que possuem conta pre-faturada
	 * 
	 * Obter quantidade de imóveis com conta Pré-faturada
	 */
	
	 /** @author Adriana Muniz e Pamela Gatinho  
	 * @date 13/12/2010
	 * 
	 * @return Collection Dados dos imóveis com conta pre-faturada
	 * @param anoMesReferencia
	 * @param rota
	 * @throws ErroRepositorioException
	 */
	public Collection obterImoveisComContaPF(Integer anoMesReferencia,
			Rota rota) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = "SELECT gerenciaRegional.nome, "// 0
				+ "localidade.id, localidade.descricao, "// 1,2
				+ "imovel.nomeImovel, clienteUsuario.nome, "// 3,4
				+ "setorComercial.codigo, quadra.numeroQuadra, "// 5,6
				+ "imovel.lote, imovel.subLote, "// 7,8
				+ "clienteResposanvel.id, clienteResposanvel.nome, "// 9,10
				+ "ligacaoAguaSituacao.id, ligacaoEsgotoSituacao.id, "// 11,12
				+ "ligacaoAgua.numeroConsumoMinimoAgua, ligacaoEsgoto.consumoMinimo, "// 13,14
				+ "ligacaoEsgoto.percentualAguaConsumidaColetada, "// 15
				+ "faturamentoSituacaoTipo.indicadorParalisacaoFaturamento, "// 16
				+ "faturamentoSituacaoTipo.indicadorValidoAgua, " // 17
				+ "faturamentoSituacaoTipo.indicadorValidoEsgoto, "// 18
				+ "imovelCondominio.id, imovel.indicadorImovelCondominio, "// 19,20
				+ "imovelPerfil.id, consumoTarifa.id, imovel.id, pocoTipo.id, "// 21,22,23,24
				+ "consumoTarifa.tarifaTipoCalculo.id, "// 25
				+ "setorComercial.id, "// 26
				+ "imovel.numeroSequencialRota, "// 27
				+ "gerenciaRegional.id, "// 28
				+ "ligacaoAguaSituacao.indicadorFaturamentoSituacao,"// 29
				+ "ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, "// 30
				+ "ice.id, "// 31
				+ "clienteUsuario.cpf, "// 32
				+ "clienteUsuario.cnpj, "// 33
				+ "hidAgua.id, "// 34
				+ "hidPoco.id, "// 35
				+ "ligacaoAguaSituacao.indicadorAbastecimento, " // 36
				+ "ligacaoAgua.id, "// 37
				+ "ligacaoAguaSituacao.descricao, "// 38
				+ "leiturista.id, "// 39
				+ "empresa.id, "// 40
				+ "quadraFace.id, "// 41
				+ "quadraFace.numeroQuadraFace, "// 42
				+ "imovel.numeroMorador, "// 43
				+ "medTipoAgua.id, "// 44
				+ "medTipoPoco.id, "// 45
				+ "ligacaoAgua.numeroLacre, "// 46
				+ "logradouroBairro.id, " // 47
				+ "logradouro.id, " // 48
				+ "logradouro.nome, " // 49
				+ "bairro.nome, " // 50
				+ "imovel.numeroImovel, " // 51
				+ "imovel.complementoEndereco, "// 52
				+ "hidLocInsAgua.id, "// 53
				+ "hidAgua.dataInstalacao, "// 54
				+ "hidProtAgua.id, "// 55
				+ "hidLocInsPoco.id, "// 56
				+ "hidPoco.dataInstalacao, "// 57
				+ "hidProtPoco.id, "// 58
				+ "usu.login, "// 59
				+ "usu.senha, "// 60
				+ "faturamentoSituacaoTipo.id, " //61
				+ "imovel.codigoDebitoAutomatico, "//62
				+ "ligacaoEsgoto.percentualAlternativo, "//63
				+ "ligacaoEsgoto.numeroConsumoPercentualAlternativo "//64
				+ "FROM Conta conta "
				+ "INNER JOIN conta.imovel imovel "
				+ "INNER JOIN imovel.localidade localidade "
				+ "INNER JOIN localidade.gerenciaRegional gerenciaRegional "
				+ "INNER JOIN imovel.setorComercial setorComercial "
				+ "INNER JOIN imovel.quadra quadra "
				+ "INNER JOIN quadra.rota rota "
				+ "INNER JOIN imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
				+ "INNER JOIN imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
				+ "INNER JOIN imovel.imovelPerfil imovelPerfil "
				+ "INNER JOIN imovel.consumoTarifa consumoTarifa "
				+ "LEFT JOIN imovel.quadraFace quadraFace "
				+ "LEFT JOIN imovel.ligacaoAgua ligacaoAgua "
				+ "LEFT JOIN ligacaoAgua.hidrometroInstalacaoHistorico hidAgua "
				+ "LEFT JOIN hidAgua.medicaoTipo medTipoAgua "
				+ "LEFT JOIN hidAgua.hidrometroLocalInstalacao hidLocInsAgua "
				+ "LEFT JOIN hidAgua.hidrometroProtecao hidProtAgua "
				+ "LEFT JOIN imovel.hidrometroInstalacaoHistorico hidPoco "
				+ "LEFT JOIN hidPoco.medicaoTipo medTipoPoco "
				+ "LEFT JOIN hidPoco.hidrometroLocalInstalacao hidLocInsPoco "
				+ "LEFT JOIN hidPoco.hidrometroProtecao hidProtPoco "
				+ "LEFT JOIN imovel.ligacaoEsgoto ligacaoEsgoto "
				+ "LEFT JOIN imovel.pocoTipo pocoTipo "
				+ "LEFT JOIN imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
				+ "LEFT JOIN imovel.imovelCondominio imovelCondominio "
				+ "LEFT JOIN imovel.clienteImoveis clienteImoveisUsuario WITH "
				+ "(clienteImoveisUsuario.clienteRelacaoTipo.id = "
				+ ClienteRelacaoTipo.USUARIO.toString()
				+ ") AND clienteImoveisUsuario.dataFimRelacao IS NULL "
				+ "LEFT JOIN clienteImoveisUsuario.cliente clienteUsuario "
				+ "LEFT JOIN imovel.clienteImoveis clienteImoveisReposanvel WITH "
				+ "(clienteImoveisReposanvel.clienteRelacaoTipo.id = "
				+ ClienteRelacaoTipo.RESPONSAVEL.toString()
				+ ") and clienteImoveisReposanvel.dataFimRelacao IS NULL "
				+ "LEFT JOIN clienteImoveisReposanvel.cliente clienteResposanvel "
				+ "LEFT JOIN imovel.imovelContaEnvio ice "
				+ "LEFT JOIN rota.leiturista leiturista "
				+ "LEFT JOIN rota.empresa empresa "
				+ "LEFT JOIN leiturista.usuario usu "
				+ "LEFT JOIN imovel.logradouroBairro logradouroBairro "
				+ "LEFT JOIN logradouroBairro.logradouro logradouro "
				+ "LEFT JOIN logradouroBairro.bairro bairro "
				+ "WHERE conta.referencia = :anoMesReferencia " 
			    + "AND conta.rota.id = :idRota "
				+ "AND conta.debitoCreditoSituacaoAtual.id = :situacaoPreFaturada";

			retorno = session.createQuery(consulta)
			.setInteger("anoMesReferencia", anoMesReferencia)
			.setInteger("idRota",rota.getId())
			.setInteger("situacaoPreFaturada",DebitoCreditoSituacao.PRE_FATURADA)
			.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}
	
	/*
	 * 
	 * Método criado para não salvar na tabela de geração da rota dividida
	 * todos os imóveis da rota, e sim, somente os que possuem conta pre-faturada
	 * 
	 * Obter quantidade de imóveis da rota dividida com conta Pré-faturada
	 */
	
	 /** @author Pamela Gatinho  
	 * @date 01/02/2011
	 * 
	 * @return Integer quantidade de imóveis da rota dividida com conta pre-faturada
	 * @param anoMesReferencia
	 * @param imoveis  A lista de imoveis pra verificar quem possui conta pre-faturada
	 * @throws ErroRepositorioException
	 */
	public Integer obterQtdImoveisRotaDivididaComContaPF(Integer anoMesReferencia,
			List<Integer> imoveisIds) throws ErroRepositorioException {

		Integer retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = " select count(conta) "
					 + " from Conta as conta "
					 + " where conta.referencia = :anoMesReferencia " 
					 + " and conta.imovel.id in (:imoveisIds) "
					 + " and conta.debitoCreditoSituacaoAtual.id = :situacaoPreFaturada";

			retorno = (Integer) session
			.createQuery(consulta)
			.setInteger("anoMesReferencia", anoMesReferencia)
			.setParameterList("imoveisIds",imoveisIds)
			.setInteger("situacaoPreFaturada",DebitoCreditoSituacao.PRE_FATURADA)
			.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}
	
	/*
	 * 
	 * Data: 22/02/2011
	 * 
	 * Dois métodos foram acrescentados:
	 * 
	 * Método usado na geração do bonus social, que retorna o consumo de agua para determinado imóvel
	 * Que será utilizado para verificar uma das condições para o crédito ser concedido
	 * que é o consumo menor ou igual a 10 
	 * 
	 * Método para verificar a subcategoria do imóvel(bônus social)
	 */
	/**
	 * @author Adriana Muniz e Welligton Rocha
	 * @date: 01/03/2011
	 * 
	 * Pesquisa o consumo de agua faturado para um determinado imóvel 
	 * 
	 * @return Integer consumo de agua do imóvel
	 * @param anoMesReferencia
	 * @param idImovel
	 * @throws ErroRepositorioException
	 * */
	public Integer pesquisarConsumoAguaImovel(Integer idImovel, Integer anoMesReferencia)
		throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			
			consulta = "select c.numeroConsumoFaturadoMes " +
					" from ConsumoHistorico c " +
					" where c.referenciaFaturamento = :anoMesReferencia" +
					" and c.imovel.id = :idImovel " +
					" and c.ligacaoTipo = " + LigacaoTipo.LIGACAO_AGUA;
			/*consulta = "select c.consumoAgua "
					+ " from Conta c "
					+ " where c.imovel.id = :idImovel and c.referencia = :anoMesReferencia"
					+ " and (c.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.NORMAL 
					+		" or c.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.RETIFICADA +")"
					+ " union "
					+ " select c.consumoAgua "
					+ " from ContaHistorico ch "
					+ " where ch.imovel.id = :idImovel and ch.anoMesReferenciaConta = :anoMesReferencia"
					+ " and (ch.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.NORMAL 
					+		" or ch.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.RETIFICADA +")";
*/
			retorno = (Integer) session
					.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idImovel",idImovel)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * @author Adriana Muniz e Welligton Rocha
	 * @date: 01/03/2011
	 * 
	 * Pesquisa a subcategoria do imóvel(Bonus social)
	 * 
	 * @return Integer com o id da subcategoria
	 * @param idImovel
	 * @throws ErroRepositorioException
	 * */
	public Integer pesquisarSubcategoriaImovel(Integer idImovel)throws ErroRepositorioException {
		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
			consulta = " select scat_id as idSubcategoria "
					 + " from cadastro.imovel_subcategoria "
					 + " where imov_id = :idImovel ";
			
			retorno = (Integer)session.createSQLQuery(consulta)
					.addScalar("idSubcategoria", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).uniqueResult();
			
		}catch(HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/*
	 * Ultizado no retorno das informações enviadas pelo IS, 
	 * para deletar os creditos realizados e a realizar, caso não tenha sido concedido, por consumo acima de 10 metros cúbicos
	 * */
	/**
	 * @author Adriana Muniz
	 * @date: 31/03/2011
	 * Verifica se tem credito realizado para determinada conta
	 * 
	 * @param idConta Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public CreditoRealizado pesquisarCreditoRealizadoBonusSocial(
			Integer idConta) throws ErroRepositorioException {

		CreditoRealizado retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select crrz " + "from CreditoRealizado crrz "
					+ "inner join crrz.conta cnta "
					+ "INNER JOIN crrz.creditoTipo crtp "
					+ "where cnta.id = :idConta " 
					+ " and crtp.id = " + CreditoTipo.DESCONTO_TARIFA_SOCIAL
					+ "ORDER BY crtp.id, crrz.anoMesReferenciaCredito ";

			// executa o hql
			retorno = (CreditoRealizado) session.createQuery(consulta).setInteger("idConta",
					idConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * @author Adriana Muniz
	 * @date: 01/04/2011
	 * Verifica se tem credito a realizar do tipo bonus social para determinado imóvel
	 * 
	 * @param idImovel 
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public CreditoARealizar pesquisarCreditoARealizarBonusSocial(
			Integer idImovel, Integer anoMesReferencia) throws ErroRepositorioException {

		CreditoARealizar retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " select crar " + "from CreditoARealizar crar "
					+ " inner join crar.imovel i "
					+ " INNER JOIN crar.creditoTipo crtp "
					+ " where i.id = :idImovel " 
					+ " and crtp.id = " + CreditoTipo.DESCONTO_TARIFA_SOCIAL
					+ " and crar_amreferenciaprestacao = :anoMesReferencia "
					+ " ORDER BY crtp.id, crar.anoMesReferenciaCredito ";

			// executa o hql
			retorno = (CreditoARealizar) session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idImovel", idImovel).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * @author Adriana Muniz
	 * @date: 01/04/2011
	 * Exclui credito realizado do tipo bonus social para determinado imóvel
	 * 
	 * @param idImovel 
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void excluirCreditoRealizadoBonusSocial(Integer idCreditoRealizado) throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		try {
			String delete = " delete from CreditoRealizadoCategoria as crc " 
			+ " where crc.creditoRealizado.id = :idCreditoRealizado ";
			
			session.createQuery(delete).setInteger("idCreditoRealizado", idCreditoRealizado).executeUpdate();
			
			delete = " delete from CreditoRealizado as cr " 
				+ " where cr.id = :idCreditoRealizado ";
			
			session.createQuery(delete).setInteger("idCreditoRealizado", idCreditoRealizado).executeUpdate();
		} catch(HibernateException e) {
			//levanta a exceção para próxima camada
			throw new ErroRepositorioException(e,"Erro no Hibernate");
		} finally {
			//fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * @author Adriana Muniz
	 * @date: 01/04/2011
	 * Exclui credito a realizar do tipo bonus social para determinado imóvel
	 * 
	 * @param idImovel 
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void excluirCreditoARealizarBonusSocial(Integer idCreditoARealizar) throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		try {
			String delete = " delete from CreditoARealizarCategoria as carc " 
				+ " where carc.creditoARealizar.id = :idCreditoARealizar ";
			
			session.createQuery(delete).setInteger("idCreditoARealizar", idCreditoARealizar).executeUpdate();
			
			delete = " delete from CreditoARealizar as car " 
				+ " where car.id = :idCreditoARealizar ";
			
			session.createQuery(delete).setInteger("idCreditoARealizar", idCreditoARealizar).executeUpdate();
			
			delete = " delete from CreditoARealizarGeral as carg " 
				+ " where carg.creditoARealizar.id = :idCreditoARealizar ";
			
			session.createQuery(delete).setInteger("idCreditoARealizar", idCreditoARealizar).executeUpdate();
			
		} catch(HibernateException e) {
			//levanta a exceção para próxima camada
			throw new ErroRepositorioException(e,"Erro no Hibernate");
		} finally {
			//fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	/*
	 * autor: Adriana Muniz
	 * Data: 12/05/2011
	 * Utilizado na geração do arquivo da declaração de quitação anual débitos 
	 */
	/**
	 * 
	 * Método que verifica se o imovel possui cliente responsável e
	 * indicacao de conta a ser entregue em outro endereço e que estejam nas
	 * quadras pertencentes às rota passada
	 * 
	 * Gerar arquivo da declaração de quitação anual de débitos
	 * 
	 * @author Adriana Muniz
	 * @date 12/05/2011
	 * 
	 * @param rota, idImovel
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean verificaImovelPorRotasComContaEntregaEmOutroEndereco(
			Rota rota, Integer idImovel) throws ErroRepositorioException {

		Integer retorno = null;
		boolean verifica = false;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			if (rota.getIndicadorRotaAlternativa().equals(ConstantesSistema.SIM)) {
				consulta = "select i.id "
						+ "from ClienteImovel as ci "
						+ "inner join ci.imovel i "
						+ "inner join i.rotaAlternativa rotaAlternativa "
						+ "inner join i.ligacaoAguaSituacao last "
						+ "inner join i.ligacaoEsgotoSituacao lest "
						+ "inner join ci.cliente clie "
						+ "inner join clie.clienteTipo cltp "
						+ "inner join cltp.esferaPoder epod "
						+ "inner join ci.clienteRelacaoTipo crt "
						+ "inner join i.quadra q "
						+ "inner join q.rota r "
						+ "inner join i.setorComercial sc "
						+ "inner join i.imovelPerfil ip "
						+ "WHERE rotaAlternativa.id = :idRota "
						+ "AND i.indicadorImovelCondominio <> 1 "
						+ "AND i.imovelContaEnvio.id <> 4 "
						+ "AND i.indicadorExclusao <> 1 "
						+ "AND ci.dataFimRelacao IS NULL AND epod.id = :idEsferaPoder "
						+ "AND crt.id = "
						+ ClienteRelacaoTipo.RESPONSAVEL
						+ " AND (i.imovelContaEnvio.id = "
						+ ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL
						+ " OR i.imovelContaEnvio = "
						+ ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL
						+ " )" 
						+ " and i.id = :idImovel ";

				retorno = (Integer) session.createQuery(consulta)
						.setInteger("idEsferaPoder", EsferaPoder.PARTICULAR)
						.setInteger("idRota", rota.getId())
						.setInteger("idImovel", idImovel).uniqueResult();
				if (retorno != null)
					verifica = true;
			}else {
				consulta = "select i.id  "
					+ "from ClienteImovel as ci "
					+ "inner join ci.imovel i "
					+ "inner join i.ligacaoAguaSituacao last "
					+ "inner join i.ligacaoEsgotoSituacao lest "
					+ "inner join ci.cliente clie "
					+ "inner join clie.clienteTipo cltp "
					+ "inner join cltp.esferaPoder epod "
					+ "inner join ci.clienteRelacaoTipo crt "
					+ "inner join i.quadra q "
					+ "inner join q.rota r "
					+ "inner join i.setorComercial sc "
					+ "inner join i.imovelPerfil ip "
					+ "WHERE q.rota.id = :idRota AND i.rotaAlternativa IS NULL "
					+ "AND i.indicadorImovelCondominio <> 1 "
					+ "AND i.imovelContaEnvio.id <> 4 "
					+ "AND i.indicadorExclusao <> 1 "

					+ "AND ci.dataFimRelacao IS NULL AND epod.id = :idEsferaPoder "
					+ "AND crt.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL
					+ " AND (i.imovelContaEnvio.id = "
					+ ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL
					+ " OR i.imovelContaEnvio = "
					+ ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL
					+ " )"
					+ " and i.id = :idImovel ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idEsferaPoder", EsferaPoder.PARTICULAR)
					.setInteger("idRota", rota.getId())
					.setInteger("idImovel", idImovel).uniqueResult();
			
			if (retorno != null)
				verifica = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return verifica;
	}
	
	/*
	 * 
	 * Método criado para obter os imóveis de uma rota que possuem conta
	 */
	
	 /** @author Pamela Gatinho  
	 * @date 21/06/2011
	 * 
	 * @return Collection Dados dos imóveis com conta
	 * @param anoMesReferencia
	 * @param rota
	 * @throws ErroRepositorioException
	 */
	public Collection obterImoveisComConta(Integer anoMesReferencia,
			Rota rota) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = "select imovel.id," // 0
				+ "imovel.ligacaoAguaSituacao.id, " // 1
				+ "imovel.ligacaoEsgotoSituacao.id, " // 2
				+ "ligacaoagua.id, " // 3
				+ "hih.id, " // 4
				+ "hidrometro.id, " // 5
				+ "hidrometro.numeroDigitosLeitura, " // 6
				+ "fst.id," // 7
				+ "imovel.pocoTipo.id, " // 8
				+ "hie.id, " // 9
				+ "hdre.id, " // 10
				+ "imovel.quadra.rota.indicadorAjusteConsumo, " // 11
				+ "imovel.ligacaoAgua.numeroConsumoMinimoAgua, " // 12
				+ "imovel.indicadorImovelCondominio, " // 13
				+ "fst.indicadorParalisacaoFaturamento, " // 14
				+ "imovel.indicadorDebitoConta, " // 15
				+ "ligacaoesgoto.id, " // Ligacao Esgoto //16
				+ "ligacaoesgoto.consumoMinimo, " // 17
				+ "hih.dataInstalacao, " // 18
				+ "ct.id, " // 19
				+ "ligacaoesgoto.percentualAguaConsumidaColetada, " // 20
				+ "imovel.quantidadeEconomias, " // 21
				+ "hdre.numeroDigitosLeitura, " // 22
				+ "hie.dataInstalacao, "// 23
				+ "fst.indicadorValidoAgua, " // 24
				+ "fst.indicadorValidoEsgoto, " // 25
				+ "esferaPoderClieResp.id, " // 26
				+ "imovel.ligacaoAguaSituacao.indicadorFaturamentoSituacao, " // 27
				+ "imovel.ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, "// 28
				+ "imovel.ligacaoAguaSituacao.consumoMinimoFaturamento, " // 29
				+ "imovel.ligacaoEsgotoSituacao.volumeMinimoFaturamento, "// 30
				+ "imovel.ligacaoAguaSituacao.indicadorAbastecimento, " // 31
				+ "hih.numeroLeituraInstalacao," // 32
				+ "hie.numeroLeituraInstalacao, " // 33
									/**
									 *  Adicionando parametros da ligacao de agua
									 */
				+ "ligacaoagua.dataLigacao, " // 34
				+ "ligacaoesgoto.dataLigacao, " // 35
				+ "ligacaoagua.numeroConsumoMinimoAgua " //36
				+ "FROM Conta conta "
				+ "INNER JOIN conta.imovel imovel "	
				+ "inner join imovel.quadra.rota.faturamentoGrupo "
				+ "inner join imovel.consumoTarifa ct "
				+ "left join imovel.ligacaoAguaSituacao las  "
				+ "left join imovel.ligacaoEsgotoSituacao les  "
				+ "left join imovel.ligacaoAgua ligacaoagua "
				+ "left join imovel.ligacaoAgua.hidrometroInstalacaoHistorico hih "
				+ "left join imovel.ligacaoAgua.hidrometroInstalacaoHistorico.hidrometro hidrometro "
				+ "left join imovel.hidrometroInstalacaoHistorico hie "
				+ "left join imovel.hidrometroInstalacaoHistorico.hidrometro hdre "
				+ "left join imovel.faturamentoSituacaoTipo fst "
				+ "left join imovel.ligacaoEsgoto ligacaoesgoto "
				+ "left join imovel.clienteImoveis clieImovResp with (clieImovResp.clienteRelacaoTipo.id = :clienteResponsavel and clieImovResp.dataFimRelacao is null) "
				+ "left join clieImovResp.cliente clieResp "
				+ "left join clieResp.clienteTipo tipoClieResp "
				+ "left join tipoClieResp.esferaPoder esferaPoderClieResp "
				+ "WHERE conta.referencia = :anoMesReferencia " 
				+ "AND conta.rota.id = :idRota ";

			retorno = session.createQuery(consulta)
			.setInteger("anoMesReferencia", anoMesReferencia)
			.setInteger("idRota",rota.getId())
			.setInteger("clienteResponsavel",ClienteRelacaoTipo.RESPONSAVEL.intValue())
			.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}
	
	/**
	 * 
	 * @author Pamela Gatinho  
	 * @date 04/08/2011
	 * 
	 * Metodo que obtem a conta do imóvel, so não retorna
	 * a conta que estiver com a situacao
	 * CANCELADA POR RETIFICACAO
	 *  
	 * @return Conta
	 * @param anoMesReferencia
	 * @param idImovel
	 * @throws ErroRepositorioException
	 */
	public Conta obterContaImovel(Integer idImovel, Integer anoMesReferencia) 
		throws ErroRepositorioException {

		Conta conta = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = "SELECT conta "
				+ "FROM Conta conta "
				+ "INNER JOIN conta.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
				+ "INNER JOIN conta.ligacaoAguaSituacao ligacaoAguaSituacao "
				+ "INNER JOIN conta.imovelPerfil imovelPerfil "
				+ "INNER JOIN conta.imovel imovel "
				+ "INNER JOIN conta.localidade localidade "
				+ "INNER JOIN conta.localidade.gerenciaRegional gerenciaRegional "
				+ "INNER JOIN conta.quadraConta quadra "
				+ "INNER JOIN conta.quadraConta .rota rota "
				+ "INNER JOIN conta.imovelPerfil imovelPerfil "
				+ "INNER JOIN conta.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
				+ "WHERE conta.referencia = :anoMesReferencia " 
			    + "AND conta.imovel.id = :imovel "
			    + "AND conta.debitoCreditoSituacaoAtual.id <> :situacaoRetificada";

			conta = (Conta)session.createQuery(consulta)
			.setInteger("anoMesReferencia", anoMesReferencia)
			.setInteger("imovel",idImovel)
			.setInteger("situacaoRetificada", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)
			.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a conta
		return conta;
	}
	

	/*
	 * Método chamado para buscar creditos do imovel que tenha valor residual diferente de zero, 
	 * caso esse valor seja menor que o valor da conta no processamento de retorno do IS */
	/**
	 * Autor: Adriana Muniz
	 * Data: 09/08/2011
	 * Método retono todos os créditos a realizar do imovel que tenha valor residual diferente de zero
	 * 
	 * @param idImovel
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection buscarCreditoARealizarPorImovelValorResidualDiferenteZero(Integer idImovel)
		throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;
		try{
			consulta = "SELECT c " +
					" FROM CreditoARealizar c " +
					" INNER JOIN c.imovel i " +
					" INNER JOIN c.debitoCreditoSituacaoAtual d " +
					" WHERE i.id = :idImovel " +
					" AND d.id = " + DebitoCreditoSituacao.NORMAL +
					" AND c.valorResidualMesAnterior <> 0.00 ";
			
			retorno = (Collection) session.createQuery(consulta)
				.setInteger("idImovel", idImovel).list();
			
		}catch(HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no hibernate");
		}finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/*
	 * Alteração para calcular corretamente o valor do imposto no resumo do faturamento
	 * */
	/**
	 * Autor: Wellington Rocha
	 * Data: 02/08/2011
	 * 
	 * Método para obter o valor dos imposto por categoria
	 * 
	 * Encerrar faturamento do Mês
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoImposto
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorContaCategoriaPorTipoImpostoResumoFaturamento(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			int idTipoImposto, int idSituacaoAtual, int idSituacaoAnterior)
		throws ErroRepositorioException {
		
		BigDecimal retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		String consulta;
		
		try {
			consulta = "SELECT sum(cnid.cnid_vlimposto) as vlimposto "
					+ " FROM faturamento.conta_impostos_deduzidos cnid "
					+ " INNER JOIN faturamento.conta cnta ON cnid.cnta_id = cnta.cnta_id"
					+ " WHERE cnta.loca_id= :idLocalidade "
					+ " AND cnta.cnta_amreferenciaconta = :anoMesReferencia "
					+ " AND :idCategoria = (SELECT idCategoria "
					+ "						FROM (SELECT sc.catg_id as idCategoria, "
					+ " 							count(isc.imsb_qteconomia) as quantidade "
					+ " 							FROM cadastro.subcategoria sc, "
					+ "								cadastro.categoria c , "
					+ " 							cadastro.imovel_subcategoria isc "
					+ " 							WHERE sc.catg_id = c.catg_id "
					+ " 							AND isc.scat_id = sc.scat_id "
					+ " 							AND isc.imov_id = cnta.imov_id "
					+ " 							GROUP BY sc.catg_id "
					+ " 							ORDER BY quantidade DESC, idCategoria) as x "
					+ " 					limit 1) "
					+ " AND cnid.imtp_id= :idTipoImposto "
					+ " AND (cnta.dcst_idatual = :idSituacaoAtual  " 
					+		" OR cnta.dcst_idanterior = :idSituacaoAnterior) ";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("vlimposto", Hibernate.BIG_DECIMAL)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idTipoImposto", idTipoImposto)
					.setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idSituacaoAnterior", idSituacaoAnterior).uniqueResult();
			
			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}
			
		}catch(HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no hibernate");
		}finally { 
			//fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	/**
	 *
	 * 
	 * Método para obter todos os imóveis que já foram processados
	 * na transmissão do arquivo de retorno do IS
	 * 
	 * @author Felipe Santos
	 * @date 22/08/2011
	 * 
	 * @param idRota
	 * @return List<Integer> retorno
	 * @throws ErroRepositorioException
	 */
	public List<Integer> obterImoveisMovimentoContaPF(Integer idRota, Integer anoMesFaturamento)
			throws ErroRepositorioException {

		List<Integer> retorno = new ArrayList<Integer>();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT imov_id AS imovel "
				+ "FROM (SELECT imov_id, mcpf_id "
				+ "		 FROM faturamento.mov_conta_prefaturada mcpf "
				+ "		 WHERE rota_id = :idRota "
				+ "		 AND mcpf_ammovimento = :anoMesFaturamento "
				+ "		 ORDER BY mcpf_id ASC) AS imoveis";

			retorno = (List<Integer>) session.createSQLQuery(consulta)
					.addScalar("imovel", Hibernate.INTEGER)
					.setInteger("idRota", idRota)
					.setInteger("anoMesFaturamento", anoMesFaturamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 *
	 * 
	 * Método para obter todos os imóveis que faltam ser transmitidos
	 * na transmissão do arquivo de retorno do IS
	 * 
	 * @author Felipe Santos
	 * @date 24/08/2011
	 * 
	 * @param idRota
	 * @return List<Integer> retorno
	 * @throws ErroRepositorioException
	 */
	public List<Integer> obterImoveisFaltandoTransmitir(Integer idRota, Integer anoMesFaturamento)
			throws ErroRepositorioException {

		List<Integer> retorno = new ArrayList<Integer>();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {consulta = "SELECT distinct imov_id AS imovel " 
				+ "FROM faturamento.conta "
				+ "WHERE rota_id = :idRota " 
				+ "AND cnta_amreferenciaconta = :anoMesFaturamento " 
				+ "AND imov_id NOT IN (SELECT imov_id "
				+ "					   FROM (SELECT distinct imov_id, mcpf_id "
				+ "		 					 FROM faturamento.mov_conta_prefaturada mcpf "
				+ "		 					 WHERE rota_id = :idRota "
				+ "		 					 AND mcpf_ammovimento = :anoMesFaturamento "
				+ "		 					 ORDER BY mcpf_id ASC) AS imoveis)";

			retorno = (List<Integer>) session.createSQLQuery(consulta)
					.addScalar("imovel", Hibernate.INTEGER)
					.setInteger("idRota", idRota)
					.setInteger("anoMesFaturamento", anoMesFaturamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/*
	 * autor: Adriana Muniz
	 * Data: 17/06/2011
	 * Utilizado na geração do bonus social
	 * */
	/**
	 * Método verifica se a conta está cancelada
	 * 
	 * Gerar Bônus Social
	 * 
	 * @author Adriana Muniz
	 * @date: 17/06/2011
	 * 
	 * @param idConta
	 * @return boolean
	 * @throws ErroRepositorioException
	 * */
	public boolean verificaContaCancelada(Integer idConta) throws ErroRepositorioException {
		boolean retorno = false;
		Integer pesquisa = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
			consulta = " SELECT c.debitoCreditoSituacaoAtual.id " 
					+ " FROM Conta c " 
					+ " WHERE c.id = :idConta " 
					+ " AND c.debitoCreditoSituacaoAtual.id = " + DebitoCreditoSituacao.CANCELADA;
			
			pesquisa = (Integer)session.createQuery(consulta)
			.setInteger("idConta", idConta).uniqueResult();
			
			if(pesquisa != null)
				retorno = true;
				
		}catch(HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	/**
	 * 
	 * Pamela Gatinho - 15/09/2011
	 * 
	 * Gerar dados para o relatorio de contas retidas
	 * 
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @param tipoRelatorio
	 * @param usuarioLogado
	 * 
	 * @return
	 * 
	 * @throws ControladorException
	 */
	public Collection pesquisarDadosRelatorioContasRetidas(
			int anoMesReferencia, Integer idFaturamentoGrupo) throws ErroRepositorioException {
		
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		try {
			String consulta = "SELECT cnta_amreferenciaconta as anoMesReferencia, "
						+ " uneg_nmunidadenegocio as unidadeDeNegocio, "
						+ " ftgr_id as grupo, "
						+ " count(*) as qtdContasRetidas"
						+ " FROM faturamento.conta c, "
						+ " cadastro.localidade l, "
						+ " cadastro.unidade_negocio un, "
						+ " micromedicao.medicao_historico mh "
						+ " where c.imov_id = mh.lagu_id "
						+ " and  mdhi_amleitura = cnta_amreferenciaconta "
						+ " and c.loca_id = l.loca_id "
						+ " and l.uneg_id = un.uneg_id "
						+ " and dcst_idatual = :situacaoPreFaturada "
						+ " and c.ftgr_id = :idFaturamentoGrupo "
						+ " and cnta_amreferenciaconta = :anoMesReferencia "
						+ " group by 1,2,3 "
						+ " order by 1,2,3 ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("anoMesReferencia", Hibernate.STRING)
					.addScalar("unidadeDeNegocio", Hibernate.STRING)
					.addScalar("grupo", Hibernate.STRING)
					.addScalar("qtdContasRetidas", Hibernate.INTEGER)
					.setInteger("situacaoPreFaturada", DebitoCreditoSituacao.PRE_FATURADA)
					.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
					.setInteger("anoMesReferencia", Integer.valueOf(anoMesReferencia))
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * 
	 * Pamela Gatinho - 16/09/2011
	 * 
	 * Gerar dados para o relatorio de medicao do faturamento
	 * 
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @param idEmpresa
	 * @param tipoRelatorio
	 * @param usuarioLogado
	 * 
	 * @return
	 * 
	 * @throws ControladorException
	 */
	public Collection pesquisarDadosRelatorioMedicaoFaturamento(
			int anoMesReferencia, Integer idFaturamentoGrupo, Integer idEmpresa) throws ErroRepositorioException {
		
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		try {
			consulta = "select mcp.mcpf_ammovimento as referencia, " //0
				+ " mcp.ftgr_id as grupo, "                          //1
				+ " u.uneg_id as idUnidadeNegocio, "									 //2
				+ " u.uneg_nmunidadenegocio as unidadeNegocio, "     //3
				+ " emp.empr_nmempresa as nomeEmpresa, "                            //4
				+ " (select count(distinct(mcp1.imov_id)) "
					+ " from faturamento.mov_conta_prefaturada mcp1, "
					+ " micromedicao.rota r, micromedicao.consumo_historico ch, "
					+ " cadastro.imovel i, cadastro.localidade l, "
					+ " cadastro.unidade_negocio u1 " 
					+ " where mcp1.imov_id = ch.imov_id "
					+ " and mcp1.rota_id = r.rota_id "
					+ " and mcp1.medt_id = ch.lgti_id "
					+ " and mcp1.imov_id = i.imov_id "
					+ " and i.loca_id = l.loca_id " 
					+ " and l.uneg_id = u1.uneg_id " 
					+ " and mcp1.mcpf_icemissaoconta = 1 "
					+ " and ch.cstp_id <> 5  "
					+ " and mcp1.mcpf_ammovimento = :anoMesReferencia "
					+ " and ch.cshi_amfaturamento = :anoMesReferencia "
					+ " and mcp1.ftgr_id = mcp.ftgr_id "
					+ " and u1.uneg_id = u.uneg_id "
					+ " and empr_id = :idEmpresa) as lidasImpressas, "      //5
				+ " (select count(distinct(mcp1.imov_id)) "
					+ " from faturamento.mov_conta_prefaturada mcp1, "
					+ " micromedicao.rota r, micromedicao.consumo_historico ch, "
					+ " cadastro.imovel i, cadastro.localidade l, cadastro.unidade_negocio u1 "
					+ " where mcp1.imov_id = ch.imov_id "
					+ " and mcp1.rota_id = r.rota_id "
					+ " and mcp1.medt_id = ch.lgti_id "
					+ " and mcp1.imov_id = i.imov_id "
					+ " and i.loca_id = l.loca_id "
					+ " and l.uneg_id = u1.uneg_id "
					+ " and mcp1.mcpf_icemissaoconta = 2 "
					+ " and ch.cstp_id <> 5 "
					+ " and mcp1.mcpf_ammovimento = :anoMesReferencia "
					+ " and ch.cshi_amfaturamento = :anoMesReferencia "
					+ " and mcp1.ftgr_id = mcp.ftgr_id "
					+ " and u1.uneg_id = u.uneg_id "
					+ " and empr_id = :idEmpresa) as lidas, "               //6
				+ " (select count(distinct(mcp1.imov_id)) "
					+ " from faturamento.mov_conta_prefaturada mcp1, "
					+ " micromedicao.rota r, micromedicao.consumo_historico ch, "
					+ " cadastro.imovel i, cadastro.localidade l, cadastro.unidade_negocio u1 "
					+ " where mcp1.imov_id = ch.imov_id "
					+ " and mcp1.rota_id = r.rota_id "
					+ " and mcp1.medt_id = ch.lgti_id "
					+ " and mcp1.imov_id = i.imov_id "
					+ " and i.loca_id = l.loca_id "
					+ " and l.uneg_id = u1.uneg_id "
					+ " and mcp1.mcpf_icemissaoconta = 1 "
					+ " and ch.cstp_id = 5 "
					+ " and mcp1.mcpf_ammovimento = :anoMesReferencia "
					+ " and ch.cshi_amfaturamento = :anoMesReferencia "
					+ " and mcp1.ftgr_id = mcp.ftgr_id "
					+ " and u1.uneg_id = u.uneg_id "
					+ " and empr_id = :idEmpresa) "
					+ " + (select count(distinct(mcp1.imov_id)) "
					+ " from faturamento.mov_conta_prefaturada mcp1, "
					+ " micromedicao.rota r, micromedicao.consumo_historico ch, "
					+ " cadastro.imovel i, cadastro.localidade l, cadastro.unidade_negocio u1 "
					+ " where mcp1.imov_id = ch.imov_id "
					+ " and mcp1.rota_id = r.rota_id "
					+ " and mcp1.medt_id = ch.lgti_id "
					+ " and mcp1.imov_id = i.imov_id "
					+ " and i.loca_id = l.loca_id "
					+ " and l.uneg_id = u1.uneg_id "
					+ " and mcp1.cstp_id is null "
					+ " and mcp1.cnta_id is not null "
					+ " and mcp1.mcpf_ammovimento = :anoMesReferencia "
					+ " and ch.cshi_amfaturamento = :anoMesReferencia "
					+ " and mcp1.ftgr_id = mcp.ftgr_id "
					+ " and u1.uneg_id = u.uneg_id "
					+ " and empr_id = :idEmpresa) as impressas"                //7
				+ " from faturamento.mov_conta_prefaturada mcp, cadastro.imovel i, "
				+ " cadastro.localidade l, cadastro.unidade_negocio u, "
				+ " cadastro.empresa emp, micromedicao.rota rota "
				+ " where mcp.imov_id = i.imov_id "
				+ " and i.loca_id = l.loca_id "
				+ " and l.uneg_id = u.uneg_id "
				+ " and mcp.rota_id = rota.rota_id "
				+ " and rota.empr_id = emp.empr_id "
				+ " and mcpf_ammovimento = :anoMesReferencia ";
				
				if (idFaturamentoGrupo != null && !idFaturamentoGrupo.equals(new Integer(0))
						&& !idFaturamentoGrupo.equals(new Integer(-1))) {
					consulta += " and mcp.ftgr_id = " + idFaturamentoGrupo ;
				}
				
				consulta += " group by 1,2,3,4,5 "
						+ " order by 1,2,3,4,5 ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("referencia", Hibernate.STRING)
					.addScalar("grupo", Hibernate.STRING)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("unidadeNegocio", Hibernate.STRING)
					.addScalar("nomeEmpresa", Hibernate.STRING)
					.addScalar("lidasImpressas", Hibernate.INTEGER)
					.addScalar("lidas", Hibernate.INTEGER)
					.addScalar("impressas", Hibernate.INTEGER)
					
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia", new Integer(anoMesReferencia))
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
		
	/**
	 * Data: 11/10/2011
	 * Autor: Adriana Muniz
	 * 
	 * Pesquisa se já registro na tabela mov_conta_prefaturada por imóvel e referência
	 * 
	 * Utilizado no processamento das informações enviadas pelo IS.
	 * 
	 * @param idImovel
 	 * @param anoMes
 	 * @return
 	 * @throws ErroRepositorioException
	 * */
 	public Collection pesquisaMovimentoContaPF(Integer idImovel, Integer anoMes) 
 		throws ErroRepositorioException {
 		
 		Collection retorno = null;
 		Session session = HibernateUtil.getSession();
 		String consulta;
 		
 		try{
 			consulta = "SELECT mcpf.mcpf_id as id " 
 					+ " FROM faturamento.mov_conta_prefaturada mcpf " 
 					+ " WHERE mcpf.imov_id = :idImovel" 
 					+ " AND mcpf.mcpf_ammovimento = :anoMes ";
 			
 			retorno = (Collection) session.createSQLQuery(consulta)
 					.addScalar("id", Hibernate.INTEGER)
 					.setInteger("idImovel", idImovel)
 					.setInteger("anoMes", anoMes).list();
 		
 		}catch (HibernateException e){
 			throw new ErroRepositorioException (e, "Erro no hibernate.");
 		}finally {
 			HibernateUtil.closeSession(session);
 		}
 		
 		return retorno;
 	}
 	
 	/**
	 * Data: 11/10/2011
	 * Autor: Adriana Muniz
	 * 
	 * Pesquisa o indicador de retransmissão pelo imóvel e referência
	 * 
	 * Utilizado no processamento das informações enviadas pelo IS.
	 * 
 	 * @param idImovel
 	 * @param anoMes
 	 * @return
 	 * @throws ErroRepositorioException
 	 */
 	public Collection pesquisaIndicadorRetransmissaoMovimentoContaPF(Integer idImovel, Integer anoMes) 
 		throws ErroRepositorioException {
 		
 		Collection retorno = null;
 		Session session = HibernateUtil.getSession();
 		String consulta;
 		
 		try{
 			consulta = "SELECT mcpf_icretransmissao as id " 
 					+ " FROM faturamento.mov_conta_prefaturada mcpf " 
 					+ " WHERE imov_id = :idImovel" 
 					+ " AND mcpf_ammovimento = :anoMes ";
 			
 			retorno = (Collection) session.createSQLQuery(consulta)
 					.addScalar("id", Hibernate.INTEGER)
 					.setInteger("idImovel", idImovel)
 					.setInteger("anoMes", anoMes).list();
 		
 		}catch (HibernateException e){
 			throw new ErroRepositorioException (e, "Erro no hibernate.");
 		}finally {
 			HibernateUtil.closeSession(session);
 		}
 		
 		return retorno;
 	}
 	
 	/**
	 *
	 * 
	 * Método para pesquisar imóveis macro de condominios por rota
	 * 
	 * @author Felipe Santos
	 * @date 26/01/2012
	 * 
	 * @param rota
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
 	public Collection pesquisarImoveisCondominioMacro (Rota rota) throws ErroRepositorioException {
 		Collection retorno = null;
 		Session session = HibernateUtil.getSession();
 		String consulta;
 		
 		Integer idRota = rota.getId();
 		
 		try{
 			consulta = "SELECT imovel "
					+ "FROM Imovel imovel "
					+ "INNER JOIN FETCH imovel.quadra quadra "
					+ "INNER JOIN quadra.rota rota "
					+ "WHERE rota.id = :idRota "
					+ "AND imovel.indicadorImovelCondominio = 1 ";
 			
 			if (rota.getIndicadorRotaAlternativa().equals(ConstantesSistema.NAO)) {
 				consulta += " AND imovel.rotaAlternativa IS NULL";
			}
 			
 			retorno = (Collection) session.createQuery(consulta).setInteger("idRota", idRota).list();
 		
 		}catch (HibernateException e){
 			throw new ErroRepositorioException (e, "Erro no hibernate.");
 		}finally {
 			HibernateUtil.closeSession(session);
 		}
 		
 		return retorno;
 	}
 	
 	/**
	 *
	 * 
	 * Método para pesquisar os imóveis micro pelo imóvel condominio
	 * 
	 * @author Felipe Santos
	 * @date 26/01/2012
	 * 
	 * @param idImovelCondominio
	 * @return List<Integer> retorno
	 * @throws ErroRepositorioException
	 */
 	public List<Integer> pesquisarImoveisCondominioMicro (Integer idImovelCondominio) throws ErroRepositorioException {
 		List<Integer> retorno = new ArrayList<Integer>();
 		Session session = HibernateUtil.getSession();
 		String consulta;
 		
 		try{
 			consulta = "SELECT imov_id AS imovel " 
 					+ " FROM cadastro.imovel " 
 					+ " WHERE imov_idimovelcondominio = :idImovelCondominio ORDER BY imov_id";
 			
 			retorno = (List<Integer>) session.createSQLQuery(consulta)
 					.addScalar("imovel", Hibernate.INTEGER)
 					.setInteger("idImovelCondominio", idImovelCondominio).list();
 		
 		}catch (HibernateException e){
 			throw new ErroRepositorioException (e, "Erro no hibernate.");
 		}finally {
 			HibernateUtil.closeSession(session);
 		}
 		
 		return retorno;
 	}
 	
 	/**
	 *
	 * Confirmar Prescrição de Conta
	 * 
	 * @author Wellington Rocha
	 * @date 01/06/2012
	 */
	public Conta pesquisarContaParaPrescricao(Integer idConta)
			throws ErroRepositorioException {

		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select conta from Conta conta "
					+ "inner join conta.clienteConta cliCnta "
					+ "inner join cliCnta.cliente cli "
					+ "inner join fetch cli.clienteTipo clTp "
					+ "where conta.id = :idConta ";
			retorno = (Conta) session.createQuery(consulta).setInteger(
					"idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
 	 * 
	 * Data: 25/10/2011
	 * Autor: Pamela Gatinho
	 * 
	 * Metodo para pesquisar todas as contas que foram emitidas mas que 
	 * serao impressas somente no fechamento do faturamento do grupo
	 * 
 	 * @param grupo
 	 * @param anoMesReferencia
 	 * @return
 	 * @throws ErroRepositorioException
 	 */
 	public Collection obterContasNaoImpressas(FaturamentoGrupo grupo, Integer anoMesReferencia) 
 		throws ErroRepositorioException{
 		
 		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
			consulta = " SELECT c " 
					+ " FROM Conta c " 
					+ " WHERE c.id in (select ci.id " 
									+ " from ContaImpressao ci" 
									+ " where ci.faturamentoGrupo = :grupo"
									+ " and ci.referenciaConta = :referencia)";
			
			retorno = (Collection)session.createQuery(consulta)
			.setInteger("grupo", grupo.getId())
			.setInteger("referencia", anoMesReferencia).list();
			
		}catch(HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally {
			HibernateUtil.closeSession(session);
		}
		
		
 		return retorno;
 	}
 	
 	/**
	 * 
	 * @author Pamela Gatinho  
	 * @date 24/02/2012
	 * 
	 * Metodo que obtem o movimento do imóvel
	 * lido pelo IS
	 * 
	 * @return MovimentoContaPreFaturada
	 * @param anoMesReferencia
	 * @param idImovel
	 * @throws ErroRepositorioException
	 */
	public MovimentoContaPrefaturada obterMovimentoImovel(Integer idImovel, Integer anoMesReferencia) 
		throws ErroRepositorioException {

		MovimentoContaPrefaturada movimento = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = "SELECT movimento "
				+ "FROM MovimentoContaPrefaturada movimento  "
				+ "INNER JOIN movimento.imovel imovel "
				+ "WHERE movimento.anoMesReferenciaPreFaturamento = :anoMesReferencia " 
			    + "AND movimento.imovel.id = :imovel ";

			movimento = (MovimentoContaPrefaturada)session.createQuery(consulta)
			.setInteger("anoMesReferencia", anoMesReferencia)
			.setInteger("imovel",idImovel)
			.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a conta
		return movimento;
	}
	
	/**
	 * 
	 * @author Pamela Gatinho  
	 * @date 06/03/2013
	 * 
	 * Metodo que obtem o extrato de quitação
	 * de débitos de um imóvel para um determinado
	 * ano.
	 * 
	 * @return ExtratoQuitacao
	 * @param anoReferencia
	 * @param idImovel
	 * @throws ErroRepositorioException
	 */
	public ExtratoQuitacao obterExtratoQuitacaoImovel(Integer idImovel, Integer anoReferencia) 
		throws ErroRepositorioException {

		ExtratoQuitacao extrato = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		
		try {

			consulta = "SELECT extrato "
				+ "FROM ExtratoQuitacao extrato  "
				+ "INNER JOIN extrato.imovel imovel "
				+ "WHERE extrato.anoReferencia = :anoReferencia " 
			    + "AND extrato.imovel.id = :imovel ";

			extrato = (ExtratoQuitacao)session.createQuery(consulta)
			.setInteger("anoReferencia", anoReferencia)
			.setInteger("imovel",idImovel)
			.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a conta
		return extrato;
	}
	
	
	/**
	 * 
	 * [UC0155] - 
	 * 
	 * Alterar Contabilização de valores arrecadados antes de 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoARealizarPorOrigemCreditoDuplicidadeAte122012(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer idCategoria, Integer idOrigemCredito,
			Integer idSituacaoAtual, Integer idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ " sum(catg.cacg_vlcategoria) as col_1 "
					+ " from "
					+ "  faturamento.cred_a_realiz_catg catg "
					+ " inner join "
					+ "  faturamento.credito_a_realizar crar on catg.crar_id=crar.crar_id "
					+ " left join "
					+ " arrecadacao.pagamento pgmt on pgmt.imov_id = crar.imov_id and pgst_idatual in (1,3) "
					+ " where "
					+ "  crar.loca_id=:idLocalidade "
					+ "  and catg.catg_id = :idCategoria "
					+ "  and crar.crar_amreferenciacontabil=:anoMesReferenciaContabil "
					+ "  and pgmt.pgmt_amreferenciapagamento < 201301 "
					+ "  and (crar.dcst_idatual=:idSituacaoAtual or crar.dcst_idanterior=:idSituacaoAnterior) "
					+ "  and crar.crog_id=:idOrigemCredito ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idOrigemCredito", idOrigemCredito)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	
	/**
	 * 
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês Retorna o valor de crédito a
	 * realizar acumulado, de acordo com o ano/mês de referência contábil, a
	 * situação atual ou anterior e a origem de crédito informados.
	 * 
	 * Alterações para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoARealizarPorOrigemCreditoDuplicidade(
			int anoMesReferenciaContabil, Integer idLocalidade,
			Integer idCategoria, Integer idOrigemCredito,
			Integer idSituacaoAtual, Integer idSituacaoAnterior)
			throws ErroRepositorioException {

		// cria a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
				+ " sum(catg.cacg_vlcategoria) as col_1 "
				+ " from "
				+ "  faturamento.cred_a_realiz_catg catg "
				+ " inner join "
				+ "  faturamento.credito_a_realizar crar on catg.crar_id=crar.crar_id "
				+ " left join "
				+ " arrecadacao.pagamento pgmt on pgmt.imov_id = crar.imov_id and pgst_idatual in (1,3) "
				+ " where "
				+ "  crar.loca_id=:idLocalidade "
				+ "  and catg.catg_id = :idCategoria "
				+ "  and crar.crar_amreferenciacontabil=:anoMesReferenciaContabil "
				+ "  and (pgmt.pgmt_amreferenciapagamento is null or pgmt.pgmt_amreferenciapagamento > 201212) "
				+ "  and (crar.dcst_idatual=:idSituacaoAtual or crar.dcst_idanterior=:idSituacaoAnterior) "
				+ "  and crar.crog_id=:idOrigemCredito ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_1", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferenciaContabil", anoMesReferenciaContabil)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idCategoria", idCategoria).setInteger(
							"idSituacaoAtual", idSituacaoAtual).setInteger(
							"idSituacaoAnterior", idSituacaoAnterior)
					.setInteger("idOrigemCredito", idOrigemCredito)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}
	
	
	/**
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaContaDuplicidadeAte122012(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, int idSituacaoAtual,
			int idSituacaoAnterior) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		/* - Alteração para corrigir o valor dos créditos
		 *  no resumo do gerencial em 22/08/2011*/
		try {
			
			
			consulta = " select "
					+ " sum(crrz.crrz_vlcredito) as col_0 "
					+ " from "
					+ "  faturamento.credito_realizado crrz "
					+ " inner join "
					+ " faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ " left join "
					+ " arrecadacao.pagamento pgmt on pgmt.imov_id = cnta.imov_id and pgmt.pgst_idatual in (1,3) "
					+ " where "
					+ " cnta.cnta_amreferenciaconta= :anoMesReferencia "
					+ " and pgmt.pgmt_amreferenciapagamento < 201301 "
					+ " and cnta.loca_id= :idLocalidade "
					+ " and (cnta.dcst_idatual=:idSituacaoAtual or cnta.dcst_idanterior=:idSituacaoAnterior) "
					+ " and (crrz.crog_id in (:idsCreditoOrigem)) "
					+ " and :idCategoria = (SELECT idCategoria "
					+ "                   	from (SELECT sc.catg_id as idCategoria, count(isc.imsb_qteconomia) as quantidade "
					+ "                            FROM "
					+ "                             cadastro.subcategoria sc, "
					+ "                             cadastro.categoria c , "
					+ "                             cadastro.imovel_subcategoria isc "
					+ "                              where sc.catg_id = c.catg_id and isc.scat_id = sc.scat_id "
					+ "                              and isc.imov_id = cnta.imov_id group by sc.catg_id "
					+ "                               order by quantidade DESC, idCategoria) as x "
					+ "                               limit 1) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idSituacaoAnterior", idSituacaoAnterior)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}
	
	
	/**
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaContaDuplicidade(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, int idSituacaoAtual,
			int idSituacaoAnterior) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		/* - Alteração para corrigir o valor dos créditos
		 *  no resumo do gerencial em 22/08/2011*/
		try {
			
			
			consulta = " select "
				+ " sum(crrz.crrz_vlcredito) as col_0 "
				+ " from "
				+ "  faturamento.credito_realizado crrz "
				+ " inner join "
				+ " faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
				+ " left join "
				+ " arrecadacao.pagamento pgmt on pgmt.imov_id = cnta.imov_id and pgmt.pgst_idatual in (1,3) "
				+ " where "
				+ " cnta.cnta_amreferenciaconta= :anoMesReferencia "
				+ " and (pgmt.pgmt_amreferenciapagamento is null or  pgmt.pgmt_amreferenciapagamento > 201212) "
				+ " and cnta.loca_id= :idLocalidade "
				+ " and (cnta.dcst_idatual=:idSituacaoAtual or cnta.dcst_idanterior=:idSituacaoAnterior) "
				+ " and (crrz.crog_id in (:idsCreditoOrigem)) "
				+ " and :idCategoria = (SELECT idCategoria "
				+ "                   	from (SELECT sc.catg_id as idCategoria, count(isc.imsb_qteconomia) as quantidade "
				+ "                            FROM "
				+ "                             cadastro.subcategoria sc, "
				+ "                             cadastro.categoria c , "
				+ "                             cadastro.imovel_subcategoria isc "
				+ "                              where sc.catg_id = c.catg_id and isc.scat_id = sc.scat_id "
				+ "                              and isc.imov_id = cnta.imov_id group by sc.catg_id "
				+ "                               order by quantidade DESC, idCategoria) as x "
				+ "                               limit 1) ";


			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setInteger("idSituacaoAnterior", idSituacaoAnterior)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}
	
	
	/**
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoDuplicidadeAte201212(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
					+ "  sum(crcg.crcg_vlcategoria) as col_0 "
					+ "  from "
					+ "   faturamento.cred_realizado_catg crcg "
					+ "  inner join "
					+ "   faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
					+ "  inner join "
					+ "   faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
					+ "  left join "
					+ "   arrecadacao.pagamento pgmt on pgmt.imov_id = cnta.imov_id  and pgmt.pgst_idatual in (1,3) "
					+ "  where "
					+ "   cnta.cnta_amreferenciacontabil= :anoMesReferencia "
					+ "   and pgmt.pgmt_amreferenciapagamento < 201301 "
					+ "   and cnta.loca_id= :idLocalidade  "
					+ "   and crcg.catg_id= :idCategoria  "
					+ "   and cnta.dcst_idatual=:idSituacaoAtual "
					+ "   and (crrz.crog_id in (:idsCreditoOrigem)) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}
	
	/**
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoDuplicidade(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoAtual)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select "
				+ "  sum(crcg.crcg_vlcategoria) as col_0 "
				+ "  from "
				+ "   faturamento.cred_realizado_catg crcg "
				+ "  inner join "
				+ "   faturamento.credito_realizado crrz on crcg.crrz_id=crrz.crrz_id "
				+ "  inner join "
				+ "   faturamento.conta cnta on crrz.cnta_id=cnta.cnta_id "
				+ "  left join "
				+ "   arrecadacao.pagamento pgmt on pgmt.imov_id = cnta.imov_id  and pgmt.pgst_idatual in (1,3) "
				+ "  where "
				+ "   cnta.cnta_amreferenciacontabil= :anoMesReferencia "
				+ "   and (pgmt.pgmt_amreferenciapagamento is null or  pgmt.pgmt_amreferenciapagamento > 201212 )"
				+ "   and cnta.loca_id= :idLocalidade  "
				+ "   and crcg.catg_id= :idCategoria  "
				+ "   and cnta.dcst_idatual=:idSituacaoAtual "
				+ "   and (crrz.crog_id in (:idsCreditoOrigem)) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar(
					"col_0", Hibernate.BIG_DECIMAL).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).setInteger("idCategoria",
					idCategoria).setInteger("idSituacaoAtual", idSituacaoAtual)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}
	
	
	/**
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoCanceladoPorRetificacaoDuplicidadeAte201212(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(crcg4.crcg_vlcategoria,0) - coalesce(crcg1.crcg_vlcategoria,0)) as valorCanceladoCreditoRealizado"
				+ " from faturamento.conta cnta4 "
				+ " inner join faturamento.credito_realizado crrz4 on crrz4.cnta_id = cnta4.cnta_id and crrz4.crog_id in (:idsCreditoOrigem)"
				+ " inner join faturamento.cred_realizado_catg crcg4  on crcg4.crrz_id = crrz4.crrz_id and crcg4.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta1 on (cnta1.imov_id = cnta4.imov_id and cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta " 
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada) )" 
				+ " left join faturamento.credito_realizado crrz1 on crrz1.cnta_id = cnta1.cnta_id and crrz1.crog_id = crrz4.crog_id"
				+ " and crrz1.crti_id = crrz4.crti_id and crrz1.crrz_amcobrancacredito = crrz4.crrz_amcobrancacredito "
				+ " left join faturamento.cred_realizado_catg crcg1  on crcg1.crrz_id = crrz1.crrz_id and crcg1.catg_id= crcg4.catg_id "
				+ " left join arrecadacao.pagamento pgmt on pgmt.imov_id = cnta1.imov_id and pgmt.pgst_idatual in (1,3) "
				+ " where cnta4.cnta_amreferenciacontabil = :anoMesReferencia "
				+ " and pgmt.pgmt_amreferenciapagamento < 201301 "
				+ " and cnta4.loca_id = :idLocalidade "
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao" 
				+ " and coalesce(crcg4.crcg_vlcategoria,0) > coalesce(crcg1.crcg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorCanceladoCreditoRealizado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setParameterList("idsCreditoOrigem", idsCreditoOrigem).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}
	
	
	/**
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoCanceladoPorRetificacaoDuplicidade(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(crcg4.crcg_vlcategoria,0) - coalesce(crcg1.crcg_vlcategoria,0)) as valorCanceladoCreditoRealizado"
				+ " from faturamento.conta cnta4 "
				+ " inner join faturamento.credito_realizado crrz4 on crrz4.cnta_id = cnta4.cnta_id and crrz4.crog_id in (:idsCreditoOrigem)"
				+ " inner join faturamento.cred_realizado_catg crcg4  on crcg4.crrz_id = crrz4.crrz_id and crcg4.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta1 on (cnta1.imov_id = cnta4.imov_id and cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta " 
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada) )" 
				+ " left join faturamento.credito_realizado crrz1 on crrz1.cnta_id = cnta1.cnta_id and crrz1.crog_id = crrz4.crog_id"
				+ " and crrz1.crti_id = crrz4.crti_id and crrz1.crrz_amcobrancacredito = crrz4.crrz_amcobrancacredito "
				+ " left join faturamento.cred_realizado_catg crcg1  on crcg1.crrz_id = crrz1.crrz_id and crcg1.catg_id= crcg4.catg_id "
				+ " left join arrecadacao.pagamento pgmt on pgmt.imov_id = cnta1.imov_id and pgmt.pgst_idatual in (1,3) "
				+ " where cnta4.cnta_amreferenciacontabil = :anoMesReferencia "
				+ " and (pgmt.pgmt_amreferenciapagamento is null or  pgmt.pgmt_amreferenciapagamento > 201212) "
				+ " and cnta4.loca_id = :idLocalidade "
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao" 
				+ " and coalesce(crcg4.crcg_vlcategoria,0) > coalesce(crcg1.crcg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorCanceladoCreditoRealizado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setParameterList("idsCreditoOrigem", idsCreditoOrigem).
				uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}
	
	
	/**
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoRetificadaDuplicidadeAte201212(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(crcg1.crcg_vlcategoria,0) - coalesce(crcg4.crcg_vlcategoria,0)) as valorIncluidoCreditoRealizado"
				+ " from faturamento.conta cnta1 "
				+ " inner join faturamento.credito_realizado crrz1 on crrz1.cnta_id = cnta1.cnta_id and crrz1.crog_id in (:idsCreditoOrigem)"
				+ " inner join faturamento.cred_realizado_catg crcg1  on crcg1.crrz_id = crrz1.crrz_id and crcg1.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta4 on (cnta4.imov_id = cnta1.imov_id and cnta4.cnta_amreferenciacontabil = :anoMesReferencia " 
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao )" 
				+ " left join faturamento.credito_realizado crrz4 on crrz4.cnta_id = cnta4.cnta_id and crrz4.crog_id = crrz1.crog_id"
				+ " and crrz4.crti_id = crrz1.crti_id and crrz4.crrz_amcobrancacredito = crrz1.crrz_amcobrancacredito "
				+ " left join faturamento.cred_realizado_catg crcg4 on crcg4.crrz_id = crrz4.crrz_id and crcg4.catg_id= crcg1.catg_id "
				+ " left join arrecadacao.pagamento pgmt on pgmt.imov_id = cnta4.imov_id and pgmt.pgst_idatual in (1,3) " 
				+ " where cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta"
				+ " and pgmt.pgmt_amreferenciapagamento < 201301 "
				+ " and cnta1.loca_id = :idLocalidade "
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada)" 
				+ " and coalesce(crcg1.crcg_vlcategoria,0) > coalesce(crcg4.crcg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorIncluidoCreditoRealizado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setParameterList("idsCreditoOrigem", idsCreditoOrigem).
				uniqueResult();			
	
			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}
	
	/**
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoRetificadaDuplicidade(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsCreditoOrigem)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {

			consulta = "select sum( coalesce(crcg1.crcg_vlcategoria,0) - coalesce(crcg4.crcg_vlcategoria,0)) as valorIncluidoCreditoRealizado"
				+ " from faturamento.conta cnta1 "
				+ " inner join faturamento.credito_realizado crrz1 on crrz1.cnta_id = cnta1.cnta_id and crrz1.crog_id in (:idsCreditoOrigem)"
				+ " inner join faturamento.cred_realizado_catg crcg1  on crcg1.crrz_id = crrz1.crrz_id and crcg1.catg_id= :idCategoria "
				+ " inner join faturamento.conta cnta4 on (cnta4.imov_id = cnta1.imov_id and cnta4.cnta_amreferenciacontabil = :anoMesReferencia " 
				+ " and cnta4.dcst_idatual = :debitoCreditoSituacaoCanceladaPorRetificacao )" 
				+ " left join faturamento.credito_realizado crrz4 on crrz4.cnta_id = cnta4.cnta_id and crrz4.crog_id = crrz1.crog_id"
				+ " and crrz4.crti_id = crrz1.crti_id and crrz4.crrz_amcobrancacredito = crrz1.crrz_amcobrancacredito "
				+ " left join faturamento.cred_realizado_catg crcg4 on crcg4.crrz_id = crrz4.crrz_id and crcg4.catg_id= crcg1.catg_id "
				+ " left join arrecadacao.pagamento pgmt on pgmt.imov_id = cnta4.imov_id and pgmt.pgst_idatual in (1,3) " 
				+ " where cnta1.cnta_amreferenciaconta = cnta4.cnta_amreferenciaconta"
				+ " and (pgmt.pgmt_amreferenciapagamento is null or  pgmt.pgmt_amreferenciapagamento > 201212) "
				+ " and cnta1.loca_id = :idLocalidade "
				+ " and (cnta1.dcst_idatual = :debitoCreditoSituacaoRetificada or cnta1.dcst_idanterior = :debitoCreditoSituacaoRetificada)" 
				+ " and coalesce(crcg1.crcg_vlcategoria,0) > coalesce(crcg4.crcg_vlcategoria,0)";
			

			// executa o hql
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valorIncluidoCreditoRealizado", Hibernate.BIG_DECIMAL).
				setInteger("anoMesReferencia", anoMesReferencia).
				setInteger("idLocalidade", idLocalidade).
				setInteger("idCategoria",idCategoria).
				setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA).
				setInteger("debitoCreditoSituacaoCanceladaPorRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).
				setParameterList("idsCreditoOrigem", idsCreditoOrigem).
				uniqueResult();			
	
			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	
	/**
	 * Felipe Santos - 22/10/2013
	 * 
	 * Retorna quantidadeContas e valorFaturamento por referência e localidade
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContasRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT coalesce(sum(qtd), 0) as qtd, coalesce(sum(total), 0) as total " 
				+ "FROM ("
				
				+ "SELECT count(*) as qtd, "
				+ "coalesce(sum(cnta_vlagua + cnta_vlesgoto + cnta_vldebitos - cnta_vlcreditos - cnta_vlimpostos), 0) as total "
				+ "FROM faturamento.conta cnta "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND cnta_amreferenciaconta = :anoMesReferencia "
				+ "AND dcst_idatual IN (:normal, :retificada, :incluida, :parcelada) "
				
				+ "UNION "
				
				+ "SELECT count(*) as qtd, "
				+ "coalesce(sum(cnhi_vlagua + cnhi_vlesgoto + cnhi_vldebitos - cnhi_vlcreditos - cnhi_vlimpostos), 0) as total "
				+ "FROM faturamento.conta_historico cnhi "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND cnhi_amreferenciaconta = :anoMesReferencia "
				+ "AND dcst_idatual IN (:normal, :retificada, :incluida, :parcelada)"
				
				+ ") as contas";
			
			retorno = (Object[]) session.createSQLQuery(consulta)
				.addScalar("qtd", Hibernate.INTEGER)
				.addScalar("total", Hibernate.BIG_DECIMAL)
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("anoMesReferencia", anoMesReferencia)
				.setInteger("normal", DebitoCreditoSituacao.NORMAL)
				.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
				.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
				.setInteger("parcelada", DebitoCreditoSituacao.PARCELADA)
				.setMaxResults(1)
				.uniqueResult();
	
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Felipe Santos - 22/10/2013
	 * 
	 * Retorna a quantidade e valor total de Erros em Contas Retificadas e Emitidas
	 * 
	 * @param anoMesReferencia
	 * @param dataInicial
	 * @param dataFinal
	 * @param idLocalidade
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarErrosContasRelatorioBIG(
			Integer anoMesReferencia, Date dataInicial, Date dataFinal,
			Integer idLocalidade) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		
		try {
			consulta = "SELECT sum (qtdRetif) as qtdRetif, "
				+ "sum (vlrRetif) as vlrRetif, "
				+ "sum(qtdEmit) as qtdEmit, " 
				+ "sum(vlrEmit) as vlrEmit "
				+ "FROM ("
				
				+ "SELECT count(cnta_id) as qtdRetif, "
				+ "coalesce(sum(cnta_vlagua + cnta_vlesgoto + cnta_vldebitos - cnta_vlcreditos - cnta_vlimpostos), 0) as vlrRetif, "
				+ "0 as qtdEmit, 0 as vlrEmit "
				+ "FROM faturamento.conta "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND cnta_dtretificacao between :dataInicial AND :dataFinal "
				+ "AND dcst_idatual = :retificada "
				
				+ "UNION "
				
				+ "SELECT count(cnta_id) as qtdRetif, "
				+ "coalesce(sum(cnhi_vlagua + cnhi_vlesgoto + cnhi_vldebitos - cnhi_vlcreditos - cnhi_vlimpostos), 0) as vlrRetif, "
				+ "0 as qtdEmit, 0 as vlrEmit "
				+ "FROM faturamento.conta_historico "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND cnhi_dtretificacao between :dataInicial AND :dataFinal "
				+ "AND dcst_idatual = :retificada "
				
				+ "UNION "
				
				+ "SELECT 0 as qtdRetif, 0 as vlrRetif, "
				+ "count(cnta_id) as qtdEmit, "
				+ "coalesce(sum(cnta_vlagua + cnta_vlesgoto + cnta_vldebitos - cnta_vlcreditos - cnta_vlimpostos), 0) as vlrEmit "
				+ "FROM faturamento.conta "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND cnta_amreferenciaconta = :anoMesReferencia "
				+ "AND dcst_idatual IN (:normal, :incluida, :cancelada, :canceladaRetificacao, :parcelada) "

				+ "UNION "

				+ "SELECT 0 as qtdRetif, 0 as vlrRetif, "
				+ "count(cnta_id) as qtdEmit, "
				+ "coalesce(sum(cnhi_vlagua + cnhi_vlesgoto + cnhi_vldebitos - cnhi_vlcreditos - cnhi_vlimpostos), 0) as vlrEmit "
				+ "FROM faturamento.conta_historico "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND cnhi_amreferenciaconta = :anoMesReferencia "
				+ "AND dcst_idatual in (:normal, :incluida, :cancelada, :canceladaRetificacao, :parcelada) "
				
				+ ") as indicadores";
			
			retorno = (Object[]) session.createSQLQuery(consulta)
				.addScalar("qtdRetif", Hibernate.INTEGER)
				.addScalar("vlrRetif", Hibernate.BIG_DECIMAL)
				.addScalar("qtdEmit", Hibernate.INTEGER)
				.addScalar("vlrEmit", Hibernate.BIG_DECIMAL)
				.setInteger("idLocalidade", idLocalidade)
				.setDate("dataInicial", dataInicial)
				.setDate("dataFinal", dataFinal)
				.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
				.setInteger("anoMesReferencia", anoMesReferencia)
				.setInteger("normal", DebitoCreditoSituacao.NORMAL)
				.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
				.setInteger("cancelada", DebitoCreditoSituacao.CANCELADA)
				.setInteger("canceladaRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)
				.setInteger("parcelada", DebitoCreditoSituacao.PARCELADA)
				.setMaxResults(1)
				.uniqueResult();
	
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Felipe Santos - 23/10/2013
	 * 
	 * Retorna a quantidade e valor total de Inadimplencia para Contas Vencidas
	 * 
	 * @param dataInicial
	 * @param dataFinal
	 * @param idLocalidade
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarInadimplenciaVencidasRelatorioBIG(
			Date dataReferencia, Date dataInicial, Date dataFinal,
			Integer idLocalidade) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT sum(qtd) as qtd, sum(vlr) as vlr "
				+ "FROM("
				
				+ "SELECT count(*) as qtd, "
				+ "coalesce(sum(cnta_vlagua+cnta_vlesgoto-cnta_vlcreditos+cnta_vldebitos-cnta_vlimpostos), 0) as vlr "
				+ "FROM faturamento.conta "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dcst_idatual in (:normal, :retificada, :incluida) "
				+ "AND cnta_dtvencimentoconta between :dataInicial AND :dataFinal "
				
				+ "AND NOT EXISTS (SELECT cnta_id "
				+ "FROM arrecadacao.pagamento "
				+ "WHERE faturamento.conta.cnta_id = arrecadacao.pagamento.cnta_id "
				+ "AND pgmt_dtpagamento < :dataReferencia) "
					
				+ "UNION "
					
				+ "SELECT count(*) as qtd, "
				+ "coalesce(sum(cnhi_vlagua+cnhi_vlesgoto-cnhi_vlcreditos+cnhi_vldebitos-cnhi_vlimpostos), 0) as vlr "
				+ "FROM faturamento.conta_historico "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dcst_idatual in (:normal, :retificada, :incluida) "
				+ "AND cnhi_dtvencimentoconta between :dataInicial AND :dataFinal "

				+ "AND NOT EXISTS (SELECT cnta_id "
				+ "FROM arrecadacao.pagamento "
				+ "WHERE faturamento.conta_historico.cnta_id = arrecadacao.pagamento.cnta_id "
				+ "AND pgmt_dtpagamento < :dataReferencia) "
				
				+ "AND NOT EXISTS (SELECT cnta_id "
				+ "FROM arrecadacao.pagamento_historico "
				+ "WHERE faturamento.conta_historico.cnta_id = arrecadacao.pagamento_historico.cnta_id "
				+ "AND pghi_dtpagamento < :dataReferencia) "
				
				+ ") as vencidas";
			
			retorno = (Object[]) session.createSQLQuery(consulta)
				.addScalar("qtd", Hibernate.INTEGER)
				.addScalar("vlr", Hibernate.BIG_DECIMAL)
				.setDate("dataInicial", dataInicial)
				.setDate("dataFinal", dataFinal)
				.setDate("dataReferencia", dataReferencia)
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("normal", DebitoCreditoSituacao.NORMAL)
				.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
				.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
				.setMaxResults(1)
				.uniqueResult();
	
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Felipe Santos - 23/10/2013
	 * 
	 * Retorna a quantidade e valor total de Inadimplencia para Contas Emitidas
	 * 
	 * @param dataInicial
	 * @param dataFinal
	 * @param idLocalidade
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarInadimplenciaEmitidasRelatorioBIG(
			Date dataInicial, Date dataFinal, Integer idLocalidade) 
	throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT sum(qtd) as qtd, sum(vlr) as vlr "
				+ "FROM("
				
				+ "SELECT count(*) as qtd, "
				+ "coalesce(sum(cnta_vlagua+cnta_vlesgoto-cnta_vlcreditos+cnta_vldebitos-cnta_vlimpostos), 0) as vlr "
				+ "FROM faturamento.conta "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dcst_idatual in (:normal, :retificada, :incluida) "
				+ "AND cnta_dtvencimentoconta between :dataInicial AND :dataFinal "
			
				+ "UNION "
				
				+ "SELECT count(*) as qtd, "
				+ "coalesce(sum(cnhi_vlagua+cnhi_vlesgoto-cnhi_vlcreditos+cnhi_vldebitos-cnhi_vlimpostos), 0) as vlr "
				+ "FROM faturamento.conta_historico "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dcst_idatual in (:normal, :retificada, :incluida) "
				+ "AND cnhi_dtvencimentoconta between :dataInicial AND :dataFinal "
			
				+ ") as emitidas";
			
			retorno = (Object[]) session.createSQLQuery(consulta)
				.addScalar("qtd", Hibernate.INTEGER)
				.addScalar("vlr", Hibernate.BIG_DECIMAL)
				.setDate("dataInicial", dataInicial)
				.setDate("dataFinal", dataFinal)
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("normal", DebitoCreditoSituacao.NORMAL)
				.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
				.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
				.setMaxResults(1)
				.uniqueResult();
	
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Felipe Santos - 23/10/2013
	 * 
	 * Retorna a quantidade e valor total de Inadimplencia para Contas Vencidas
	 * maior que 90 dias
	 * 
	 * @param dataInicial
	 * @param dataFinal
	 * @param idLocalidade
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarInadimplenciaVencidasMaior90RelatorioBIG(
			Date dataReferencia, Date dataFinal, Integer idLocalidade)
	throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT sum(qtd) as qtd, sum(vlr) as vlr "
				+ "FROM("
				
				+ "SELECT count(*) as qtd, "
				+ "sum(cnta_vlagua+cnta_vlesgoto-cnta_vlcreditos+cnta_vldebitos-cnta_vlimpostos) as vlr "
				+ "FROM faturamento.conta "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dcst_idatual in (:normal, :retificada, :incluida) "
				+ "AND cnta_dtvencimentoconta < :dataFinal "
				
				+ "AND NOT EXISTS (SELECT cnta_id "
				+ "FROM arrecadacao.pagamento "
				+ "WHERE faturamento.conta.cnta_id = arrecadacao.pagamento.cnta_id "
				+ "AND pgmt_dtpagamento < :dataReferencia) "
					
				+ "UNION "
					
				+ "SELECT count(*) as qtd, "
				+ "sum(cnhi_vlagua+cnhi_vlesgoto-cnhi_vlcreditos+cnhi_vldebitos-cnhi_vlimpostos) as vlr "
				+ "FROM faturamento.conta_historico "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dcst_idatual in (:normal, :retificada, :incluida) "
				+ "AND cnhi_dtvencimentoconta < :dataFinal "
				
				+ "AND NOT EXISTS (SELECT cnta_id "
				+ "FROM arrecadacao.pagamento "
				+ "WHERE faturamento.conta_historico.cnta_id = arrecadacao.pagamento.cnta_id "
				+ "AND pgmt_dtpagamento < :dataReferencia) "
				
				+ "AND NOT EXISTS (SELECT cnta_id "
				+ "FROM arrecadacao.pagamento_historico "
				+ "WHERE faturamento.conta_historico.cnta_id = arrecadacao.pagamento_historico.cnta_id "
				+ "AND pghi_dtpagamento < :dataReferencia) "
				
				+ ") as vencidas";
			
			retorno = (Object[]) session.createSQLQuery(consulta)
				.addScalar("qtd", Hibernate.INTEGER)
				.addScalar("vlr", Hibernate.BIG_DECIMAL)
				.setDate("dataFinal", dataFinal)
				.setDate("dataReferencia", dataReferencia)
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("normal", DebitoCreditoSituacao.NORMAL)
				.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
				.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
				.setMaxResults(1)
				.uniqueResult();
	
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Felipe Santos - 23/10/2013
	 * 
	 * Retorna a quantidade e valor total de Inadimplencia para Contas Emitidas
	 * 
	 * @param dataInicial
	 * @param dataFinal
	 * @param idLocalidade
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarInadimplenciaEmitidasMaior90RelatorioBIG(
			Date dataFinal, Integer idLocalidade) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT sum(qtd) as qtd, sum(vlr) as vlr "
				+ "FROM("
				
				+ "SELECT count(*) as qtd, "
				+ "sum(cnta_vlagua+cnta_vlesgoto-cnta_vlcreditos+cnta_vldebitos-cnta_vlimpostos) as vlr "
				+ "FROM faturamento.conta "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dcst_idatual in (:normal, :retificada, :incluida) "
				+ "AND cnta_dtvencimentoconta < :dataFinal "
			
				+ "UNION "
				
				+ "SELECT count(*) as qtd, "
				+ "sum(cnhi_vlagua+cnhi_vlesgoto-cnhi_vlcreditos+cnhi_vldebitos-cnhi_vlimpostos) as vlr "
				+ "FROM faturamento.conta_historico "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dcst_idatual in (:normal, :retificada, :incluida) "
				+ "AND cnhi_dtvencimentoconta < :dataFinal "
			
				+ ") as emitidas";
			
			retorno = (Object[]) session.createSQLQuery(consulta)
				.addScalar("qtd", Hibernate.INTEGER)
				.addScalar("vlr", Hibernate.BIG_DECIMAL)
				.setDate("dataFinal", dataFinal)
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("normal", DebitoCreditoSituacao.NORMAL)
				.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
				.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
				.setMaxResults(1)
				.uniqueResult();
	
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public void atualizarVecimentoFaturaClienteResponsavel(Date dataVencimento, String anoMesReferencia) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try{
			String query = " UPDATE Fatura " 
					+ " SET vencimento =:dateVencimento " 
					+ " WHERE anoMesReferencia = :anoMesReferencia";

			session.createQuery(query).setDate("dateVencimento", dataVencimento)
			.setString("anoMesReferencia", anoMesReferencia)
			.executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}
	
	public Integer countFaturasClienteResponsaveis(String anoMesReferencia) throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try{
			String query = "  SELECT count(*)" 
					+ " FROM Fatura f " 
					+ " WHERE f.anoMesReferencia = :anoMesReferencia ";

			retorno = (Integer)session.createQuery(query)
					.setString("anoMesReferencia", anoMesReferencia).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	  public Collection pesquisarContaOuContaHistorico(Collection idsContas, String className)
	    throws ErroRepositorioException {

	    Collection<ContaHistorico> retorno = null;

	    Session session = HibernateUtil.getSession();
	    String consulta;

	    try {
	      consulta = "select c " + " from "+ className + " c "
	          + "inner join fetch c.imovel imov "
	          + "inner join fetch imov.localidade loc "
	          + "inner join fetch c.debitoCreditoSituacaoAtual "
	          + "inner join fetch c.quadra "
	          + "where c.id in (:contasIds) ";

	      retorno = (Collection) session.createQuery(consulta)
	          .setParameterList("contasIds", idsContas).list();
	      
	    } catch (HibernateException e) {
	      // levanta a exceção para a próxima camada
	      throw new ErroRepositorioException(e, "Erro no Hibernate");
	    } finally {
	      // fecha a sessão
	      HibernateUtil.closeSession(session);
	    }
	    
	    return retorno;
	  }
	  
	public Date obterDataVencimentoContasFaturarGrupo(FaturamentoGrupo faturamentoGrupo) throws ErroRepositorioException {
	
		Date retorno = null;
	
		Session session = HibernateUtil.getSession();
	
		try {
			String consulta = "select distinct fatAtivCronRota.dataContaVencimento "
					+ " from FaturamentoAtivCronRota fatAtivCronRota "
					+ " left join fatAtivCronRota.faturamentoAtividadeCronograma faturamentoAtividadeCronograma "
					+ " left join faturamentoAtividadeCronograma.faturamentoAtividade faturamentoAtividade "
					+ " left join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal "
					+ " left join faturamentoGrupoCronogramaMensal.faturamentoGrupo faturamentoGrupo "
					+ " where faturamentoGrupo.id = :idFaturamentoGrupo "
					+ " and faturamentoGrupoCronogramaMensal.anoMesReferencia = :anoMesReferencia "
					+ " and faturamentoAtividade.id = :idFaturamentoAtividade ";
	
			retorno = (Date) session
					.createQuery(consulta)
					.setInteger("idFaturamentoGrupo", faturamentoGrupo.getId())
					.setInteger("anoMesReferencia", faturamentoGrupo.getAnoMesReferencia())
					.setInteger("idFaturamentoAtividade", FaturamentoAtividade.FATURAR_GRUPO).uniqueResult();
	
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate!");
		} finally {
			HibernateUtil.closeSession(session);
		}
	
		return retorno;
	
	}
	
	public Collection<IDebitoCobradoCategoria> pesquisarDebitosCobradosCategoriaHistorico(Integer idDebitoCobradoHistorico) throws ErroRepositorioException {

		Collection<IDebitoCobradoCategoria> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "from DebitoCobradoCategoriaHistorico dccg where dccg.debitoCobradoHistorico.id = :idDebitoCobradoHistorico ";

			retorno = session.createQuery(consulta).setInteger("idDebitoCobradoHistorico", idDebitoCobradoHistorico).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection<ICreditoRealizado> pesquisarCreditosRealizadosHistorico(Integer idConta) throws ErroRepositorioException {

		Collection<ICreditoRealizado> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "select credito from CreditoRealizadoHistorico credito "
					+ "inner join credito.contaHistorico cnta "
					+ "INNER JOIN FETCH credito.creditoTipo crtp "
					+ "LEFT JOIN FETCH credito.creditoARealizarGeral crgr "
					+ "where cnta.id = :idConta "
					+ "ORDER BY crtp.id, credito.anoMesReferenciaCredito ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<ICreditoRealizadoCategoria> pesquisarCreditoRealizadoCategoriaHistorico(Integer idCreditoRealizado) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "from CreditoRealizadoCategoriaHistorico credito where credito.creditoRealizadoHistorico.id = :idCreditoRealizado ";

			retorno = session.createQuery(consulta).setInteger("idCreditoRealizado", idCreditoRealizado).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection<IContaImpostosDeduzidos> pesquisarContaImpostosDeduzidosHistorico(Integer idConta)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select cnid from " + "ContaImpostosDeduzidosHistorico cnid where cnid.contaHistorico.id = :idConta";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public Collection<IClienteConta> pesquisarClienteContaHistorico(Integer idConta) throws ErroRepositorioException {

		Collection<IClienteConta> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try {
			consulta.append("select clienteConta from ClienteContaHistorico clienteConta ")
			.append("inner join fetch clienteConta.contaHistorico conta ")
			.append("inner join fetch clienteConta.clienteRelacaoTipo clienteRelacaoTipo ")
			.append("inner join fetch clienteConta.cliente cliente ")
			.append("where conta.id = :idConta ");

			retorno = session.createQuery(consulta.toString()).setInteger("idConta", idConta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarClienteContaECliente(Integer idConta, String cnpjEmpresa) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cliCnt " + "from ClienteConta cliCnt " + "inner join cliCnt.conta cnt "
					 + "inner join fetch cliCnt.cliente cli " + "where cnt.id = :idConta "
					 + "and (cli.cnpj is null or cli.cnpj <>:cnpjEmpresa) ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setString("cnpjEmpresa", cnpjEmpresa)
					.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection pesquisarDadosRelatorioReceitasAFaturarDataLeituraPrevista(Integer idGrupo, Integer anoMesReferencia) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";
		try {
			consulta = " SELECT cronograma_mensal.ftgr_id as idGrupo, to_date(atividade.ftac_dtprevista, 'YYYY-MM-DD') dataPrevista "
					+ " FROM faturamento.fatur_ativ_cronograma atividade, "
					+ " faturamento.fatur_grupo_crg_mensal cronograma_mensal, "
					+ " faturamento.faturamento_grupo grupo "
					+ " WHERE atividade.ftcm_id = cronograma_mensal.ftcm_id "
					+ " and cronograma_mensal.ftgr_id = grupo.ftgr_id "
					+ " and atividade.ftat_id = 2 "
					+ " and cronograma_mensal.ftcm_amreferencia = :anoMesReferencia "
					+ " and grupo.ftgr_icuso = 1 ";
					
			if (idGrupo != null) {
				consulta += "and grupo.ftgr_id in (:idGrupo)";

				retorno = (Collection) session.createSQLQuery(consulta)
						.addScalar("idGrupo", Hibernate.INTEGER)
						.addScalar("dataPrevista", Hibernate.DATE)
						.setInteger("anoMesReferencia", anoMesReferencia)
						.setInteger("idGrupo", idGrupo)
						.list();
			} else {
				retorno = (Collection) session.createSQLQuery(consulta)
						.addScalar("idGrupo", Hibernate.INTEGER)
						.addScalar("dataPrevista", Hibernate.DATE)
						.setInteger("anoMesReferencia", anoMesReferencia)
						.list();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public Collection pesquisarDadosRelatorioReceitasAFaturarDataLeituraAnterior(Integer idGrupo, Integer anoMesReferencia) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";
		try {
			consulta = " SELECT cronograma_mensal.ftgr_id as idGrupo, to_date(atividade.ftac_dtprevista, 'YYYY-MM-DD') as dataAnterior "
					+ " FROM faturamento.fatur_ativ_cronograma atividade, "
					+ " faturamento.fatur_grupo_crg_mensal cronograma_mensal, "
					+ " faturamento.faturamento_grupo grupo "
					+ " WHERE atividade.ftcm_id = cronograma_mensal.ftcm_id "
					+ " and cronograma_mensal.ftgr_id = grupo.ftgr_id "
					+ " and atividade.ftat_id = 2 "
					+ " and cronograma_mensal.ftcm_amreferencia = :anoMesReferencia "
					+ " and grupo.ftgr_icuso = 1 ";
				
			if (idGrupo != null) {
				consulta += "and grupo.ftgr_id in (:idGrupo)";

				retorno = (Collection) session.createSQLQuery(consulta)
						.addScalar("idGrupo", Hibernate.INTEGER)
						.addScalar("dataAnterior", Hibernate.DATE)
						.setInteger("anoMesReferencia", Util.subtrairMesDoAnoMes(anoMesReferencia, 1))
						.setInteger("idGrupo", idGrupo)
						.list();
			} else {
				retorno = (Collection) session.createSQLQuery(consulta)
						.addScalar("idGrupo", Hibernate.INTEGER)
						.addScalar("dataAnterior", Hibernate.DATE)
						.setInteger("anoMesReferencia", Util.subtrairMesDoAnoMes(anoMesReferencia, 1))
						.list();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public Collection pesquisarDadosRelatorioReceitasAFaturarValorAFaturar(Integer idGrupo, Integer anoMesReferencia)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";
		try {
			consulta = " SELECT sum(valorAgua) as valorAgua, sum(valorEsgoto) as valorEsgoto FROM "
				+ " (SELECT sum (cnta_vlagua) as valorAgua, sum(cnta_vlesgoto) as valorEsgoto "
				+ " FROM faturamento.conta as conta, "
				+ " cadastro.cliente_imovel cliente_imovel, " 
				+ " cadastro.cliente cliente "
				+ " WHERE cnta_amreferenciaconta = :anoMesReferencia "
				+ " and dcst_idatual in (0, 1, 2, 5) "
				+ " and ftgr_id = :idGrupo "
				+ " and conta.imov_id = cliente_imovel.imov_id " 
				+ " and cliente.clie_id = cliente_imovel.clie_id "
				+ " and cliente_imovel.crtp_id = 2 " 
				+ " and cliente_imovel.clim_dtrelacaofim is null "
				+ " UNION  "
				+ " SELECT sum (cnhi_vlagua) as valorAgua, sum(cnhi_vlesgoto) as valorEsgoto "
				+ " FROM faturamento.conta_historico as conta_historico, "
				+ " cadastro.cliente_imovel cliente_imovel, "
				+ " cadastro.cliente cliente "
				+ " WHERE cnhi_amreferenciaconta = :anoMesReferencia "
				+ " and dcst_idatual in (0, 1, 2, 5) "
				+ " and ftgr_id = :idGrupo "
				+ " and conta_historico.imov_id = cliente_imovel.imov_id "
				+ " and cliente.clie_id = cliente_imovel.clie_id "
				+ " and cliente_imovel.crtp_id = 2 "
				+ " and cliente_imovel.clim_dtrelacaofim is null) as conta ";

			retorno = (Collection) session.createSQLQuery(consulta)
				.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
				.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
				.setInteger("anoMesReferencia", anoMesReferencia)
				.setInteger("idGrupo", idGrupo)
				.list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public Collection pesquisarDadosRelatorioReceitasAFaturarValorAFaturarPorGrupo(Integer idGrupo, Integer anoMesReferencia)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";
		try {
			consulta = " SELECT valorAgua as valorAgua, valorEsgoto as valorEsgoto, "
					+ " imovel as imovel, nomeCliente as nomeCliente from( "
					+ " SELECT conta.imov_id as imovel, cliente.clie_nmcliente as nomeCliente, cnta_vlagua as valorAgua, "
					+ " cnta_vlesgoto as valorEsgoto "
					+ " FROM faturamento.conta as conta, "
					+ " cadastro.cliente_imovel cliente_imovel, "
					+ " cadastro.cliente cliente "
					+ " WHERE cnta_amreferenciaconta = :anoMesReferencia " 
					+ " and dcst_idatual in (0, 1, 2, 5) "
					+ " and ftgr_id = :idGrupo "
					+ " and conta.imov_id = cliente_imovel.imov_id "
					+ " and cliente.clie_id = cliente_imovel.clie_id "
					+ " and cliente_imovel.crtp_id = 2 "
					+ " and cliente_imovel.clim_dtrelacaofim is null "
					+ " UNION  "
					+ " SELECT  conta_historico.imov_id as imovel, cliente.clie_nmcliente as nomeCliente, cnhi_vlagua as valorAgua, "
					+ " cnhi_vlesgoto as valorEsgoto "
					+ " FROM faturamento.conta_historico as conta_historico, "
					+ " cadastro.cliente_imovel cliente_imovel, "
					+ " cadastro.cliente cliente "
					+ " WHERE cnhi_amreferenciaconta = :anoMesReferencia  "
					+ " and dcst_idatual in (0, 1, 2, 5) "
					+ " and ftgr_id = :idGrupo "
					+ " and conta_historico.imov_id = cliente_imovel.imov_id "
					+ " and cliente.clie_id = cliente_imovel.clie_id "
					+ " and cliente_imovel.crtp_id = 2 "
					+ " and cliente_imovel.clim_dtrelacaofim is null "
					+ " ) as conta ";
				
				retorno = (Collection) session.createSQLQuery(consulta)
						.addScalar("imovel", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.setInteger("anoMesReferencia", anoMesReferencia)
						.setInteger("idGrupo", idGrupo)
						.list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public int pesquisarMaiorAnoMesReferenciaCronogramaGrupoFaturamentoMensal(Integer idGrupo) throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		
		try {
			consulta = "SELECT max(ftcm_amreferencia) as referencia "
					+ " FROM faturamento.fatur_grupo_crg_mensal ftcm "
					+ " INNER JOIN faturamento.fatur_ativ_cronograma ftac ON ftac.ftcm_id = ftcm.ftcm_id "
					+ " WHERE ftgr_id = :idGrupo "
					+ " AND ftat_id = :faturamentoAtividade "
					+ " AND ftac_tmrealizacao IS NOT NULL";
				
				retorno = (Integer) session.createSQLQuery(consulta)
						.addScalar("referencia", Hibernate.INTEGER)
						.setInteger("idGrupo", idGrupo)
						.setInteger("faturamentoAtividade", FaturamentoAtividade.FATURAR_GRUPO)
						.uniqueResult();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno.intValue();
	}
	
	public boolean verificarAnoMesReferenciaCronogramaGrupoFaturamentoMensal(Integer idGrupo, Integer referencia) throws ErroRepositorioException {
		boolean faturado = false;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		
		try {
			consulta = "SELECT EXISTS (" 
					+ " SELECT ftcm.ftcm_id "
					+ " FROM faturamento.fatur_grupo_crg_mensal ftcm "
					+ " INNER JOIN faturamento.fatur_ativ_cronograma ftac ON ftac.ftcm_id = ftcm.ftcm_id "
					+ " WHERE ftgr_id = :idGrupo "
					+ " AND ftcm_amreferencia = :referencia "
					+ " AND ftat_id = :faturamentoAtividade "
					+ " AND ftac_tmrealizacao IS NOT NULL)";
				
			faturado = (Boolean) session.createSQLQuery(consulta)
						.addScalar("exists", Hibernate.BOOLEAN)
						.setInteger("idGrupo", idGrupo)
						.setInteger("referencia", referencia)
						.setInteger("faturamentoAtividade", FaturamentoAtividade.FATURAR_GRUPO)
						.uniqueResult();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return faturado;
	}
}
