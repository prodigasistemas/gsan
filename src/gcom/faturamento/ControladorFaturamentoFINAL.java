	package gcom.faturamento;

import gcom.arrecadacao.ContratoDemanda;
import gcom.arrecadacao.Devolucao;
import gcom.arrecadacao.FiltroDevolucao;
import gcom.arrecadacao.IRepositorioArrecadacao;
import gcom.arrecadacao.RepositorioArrecadacaoHBM;
import gcom.arrecadacao.debitoautomatico.DebitoAutomatico;
import gcom.arrecadacao.debitoautomatico.DebitoAutomaticoMovimento;
import gcom.arrecadacao.pagamento.FiltroGuiaPagamento;
import gcom.arrecadacao.pagamento.FiltroGuiaPagamentoCategoria;
import gcom.arrecadacao.pagamento.FiltroGuiaPagamentoGeral;
import gcom.arrecadacao.pagamento.FiltroPagamento;
import gcom.arrecadacao.pagamento.GuiaPagamento;
import gcom.arrecadacao.pagamento.GuiaPagamentoCategoria;
import gcom.arrecadacao.pagamento.GuiaPagamentoCategoriaPK;
import gcom.arrecadacao.pagamento.GuiaPagamentoItem;
import gcom.arrecadacao.pagamento.GuiaPagamentoItemPK;
import gcom.arrecadacao.pagamento.Pagamento;
import gcom.arrecadacao.pagamento.PagamentoHistorico;
import gcom.atendimentopublico.ligacaoagua.FiltroLigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoagua.LigacaoAgua;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacaoConsumoTipo;
import gcom.atendimentopublico.ligacaoesgoto.FiltroLigacaoEsgotoSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgoto;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacaoConsumoTipo;
import gcom.atendimentopublico.ordemservico.FiltroOrdemServico;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.atendimentopublico.registroatendimento.EspecificacaoTipoValidacao;
import gcom.atendimentopublico.registroatendimento.FiltroRegistroAtendimento;
import gcom.atendimentopublico.registroatendimento.FiltroRegistroAtendimentoSolicitante;
import gcom.atendimentopublico.registroatendimento.RegistroAtendimento;
import gcom.atendimentopublico.registroatendimento.RegistroAtendimentoSolicitante;
import gcom.batch.RepositorioBatchHBM;
import gcom.batch.UnidadeProcessamento;
import gcom.cadastro.EnvioEmail;
import gcom.cadastro.IRepositorioCadastro;
import gcom.cadastro.RepositorioCadastroHBM;
import gcom.cadastro.cliente.Cliente;
import gcom.cadastro.cliente.ClienteConta;
import gcom.cadastro.cliente.ClienteContaHistorico;
import gcom.cadastro.cliente.ClienteGuiaPagamento;
import gcom.cadastro.cliente.ClienteImovel;
import gcom.cadastro.cliente.ClienteRelacaoTipo;
import gcom.cadastro.cliente.ClienteTipo;
import gcom.cadastro.cliente.EsferaPoder;
import gcom.cadastro.cliente.FiltroCliente;
import gcom.cadastro.cliente.FiltroClienteGuiaPagamento;
import gcom.cadastro.cliente.FiltroClienteImovel;
import gcom.cadastro.cliente.FiltroClienteTipo;
import gcom.cadastro.cliente.IClienteConta;
import gcom.cadastro.cliente.IRepositorioClienteImovel;
import gcom.cadastro.cliente.RepositorioClienteImovelHBM;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.endereco.Logradouro;
import gcom.cadastro.endereco.LogradouroBairro;
import gcom.cadastro.geografico.Bairro;
import gcom.cadastro.imovel.Categoria;
import gcom.cadastro.imovel.ControladorImovelLocal;
import gcom.cadastro.imovel.ControladorImovelLocalHome;
import gcom.cadastro.imovel.FiltroImovel;
import gcom.cadastro.imovel.FiltroImovelCobrancaSituacao;
import gcom.cadastro.imovel.FiltroSubCategoria;
import gcom.cadastro.imovel.IRepositorioImovel;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.imovel.ImovelCobrancaSituacao;
import gcom.cadastro.imovel.ImovelContaEnvio;
import gcom.cadastro.imovel.ImovelPerfil;
import gcom.cadastro.imovel.PocoTipo;
import gcom.cadastro.imovel.RepositorioImovelHBM;
import gcom.cadastro.imovel.Subcategoria;
import gcom.cadastro.imovel.bean.EmitirConsumoImovelCondominimoHelper;
import gcom.cadastro.localidade.FiltroGerenciaRegional;
import gcom.cadastro.localidade.FiltroLocalidade;
import gcom.cadastro.localidade.FiltroQuadra;
import gcom.cadastro.localidade.FiltroQuadraFace;
import gcom.cadastro.localidade.FiltroSetorComercial;
import gcom.cadastro.localidade.FiltroUnidadeNegocio;
import gcom.cadastro.localidade.GerenciaRegional;
import gcom.cadastro.localidade.IRepositorioLocalidade;
import gcom.cadastro.localidade.Localidade;
import gcom.cadastro.localidade.Quadra;
import gcom.cadastro.localidade.QuadraFace;
import gcom.cadastro.localidade.RepositorioLocalidadeHBM;
import gcom.cadastro.localidade.SetorComercial;
import gcom.cadastro.localidade.UnidadeNegocio;
import gcom.cadastro.sistemaparametro.NacionalFeriado;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cobranca.CobrancaDebitoSituacao;
import gcom.cobranca.CobrancaDocumentoItem;
import gcom.cobranca.CobrancaForma;
import gcom.cobranca.CobrancaSituacao;
import gcom.cobranca.DocumentoTipo;
import gcom.cobranca.EmpresaCobrancaConta;
import gcom.cobranca.FiltroCobrancaDocumentoItem;
import gcom.cobranca.FiltroEmpresaCobrancaConta;
import gcom.cobranca.IRepositorioCobranca;
import gcom.cobranca.ParcelamentoGrupo;
import gcom.cobranca.RepositorioCobrancaHBM;
import gcom.cobranca.bean.ContaValoresHelper;
import gcom.cobranca.bean.GuiaPagamentoValoresHelper;
import gcom.cobranca.bean.ObterDebitoImovelOuClienteHelper;
import gcom.cobranca.contratoparcelamento.ContratoParcelamentoItem;
import gcom.cobranca.contratoparcelamento.FiltroContratoParcelamentoItem;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.cobranca.parcelamento.ParcelamentoSituacao;
import gcom.fachada.Fachada;
import gcom.faturamento.AtualizacaoCreditoARealizarHelper.ItemCreditoARealizar;
import gcom.faturamento.autoinfracao.AutoInfracaoSituacao;
import gcom.faturamento.autoinfracao.AutosInfracao;
import gcom.faturamento.autoinfracao.AutosInfracaoDebitoACobrar;
import gcom.faturamento.autoinfracao.FiltroAutosInfracao;
import gcom.faturamento.autoinfracao.FiltroAutosInfracaoDebitoACobrar;
import gcom.faturamento.bean.ApagarDadosFaturamentoHelper;
import gcom.faturamento.bean.CalcularValoresAguaEsgotoFaixaHelper;
import gcom.faturamento.bean.CalcularValoresAguaEsgotoHelper;
import gcom.faturamento.bean.ContasEmRevisaoRelatorioHelper;
import gcom.faturamento.bean.DebitoCobradoAgrupadoHelper;
import gcom.faturamento.bean.DeterminarValoresFaturamentoAguaEsgotoHelper;
import gcom.faturamento.bean.EmitirContaHelper;
import gcom.faturamento.bean.EmitirHistogramaAguaDetalheHelper;
import gcom.faturamento.bean.EmitirHistogramaAguaHelper;
import gcom.faturamento.bean.ExecutarAtividadeFaturamentoHelper;
import gcom.faturamento.bean.FaturaClienteResponsavelHelper;
import gcom.faturamento.bean.FaturaItemClienteResponsavelHelper;
import gcom.faturamento.bean.FiltrarEmitirHistogramaAguaHelper;
import gcom.faturamento.bean.GerarContaCategoriaHelper;
import gcom.faturamento.bean.GerarCreditoRealizadoHelper;
import gcom.faturamento.bean.GerarDebitoCobradoHelper;
import gcom.faturamento.bean.GerarRelacaoAcompanhamentoFaturamentoHelper;
import gcom.faturamento.bean.GerarRelatorioAnormalidadeConsumoHelper;
import gcom.faturamento.bean.LeiturasNaoRegistradasHelper;
import gcom.faturamento.bean.MapaControleContaRelatorioHelper;
import gcom.faturamento.bean.ResumoFaturamentoRelatorioHelper;
import gcom.faturamento.bean.ResumoFaturamentoSimulacaoHelper;
import gcom.faturamento.bean.SituacaoEspecialFaturamentoHelper;
import gcom.faturamento.bean.VolumesFaturadosRelatorioHelper;
import gcom.faturamento.consumotarifa.ConsumoTarifa;
import gcom.faturamento.consumotarifa.ConsumoTarifaCategoria;
import gcom.faturamento.consumotarifa.ConsumoTarifaFaixa;
import gcom.faturamento.consumotarifa.ConsumoTarifaVigencia;
import gcom.faturamento.consumotarifa.FiltroConsumoTarifa;
import gcom.faturamento.consumotarifa.FiltroConsumoTarifaCategoria;
import gcom.faturamento.consumotarifa.FiltroConsumoTarifaFaixa;
import gcom.faturamento.consumotarifa.FiltroConsumoTarifaVigencia;
import gcom.faturamento.conta.Conta;
import gcom.faturamento.conta.ContaCategoria;
import gcom.faturamento.conta.ContaCategoriaConsumoFaixa;
import gcom.faturamento.conta.ContaCategoriaConsumoFaixaHistorico;
import gcom.faturamento.conta.ContaCategoriaHistorico;
import gcom.faturamento.conta.ContaCategoriaHistoricoPK;
import gcom.faturamento.conta.ContaCategoriaPK;
import gcom.faturamento.conta.ContaGeral;
import gcom.faturamento.conta.ContaHistorico;
import gcom.faturamento.conta.ContaImpostosDeduzidos;
import gcom.faturamento.conta.ContaImpostosDeduzidosHistorico;
import gcom.faturamento.conta.ContaImpressao;
import gcom.faturamento.conta.ContaMensagem;
import gcom.faturamento.conta.ContaMotivoCancelamento;
import gcom.faturamento.conta.ContaMotivoInclusao;
import gcom.faturamento.conta.ContaMotivoRetificacao;
import gcom.faturamento.conta.ContaMotivoRevisao;
import gcom.faturamento.conta.ContaTipo;
import gcom.faturamento.conta.Fatura;
import gcom.faturamento.conta.FaturaItem;
import gcom.faturamento.conta.FaturaItemHistorico;
import gcom.faturamento.conta.FiltroConta;
import gcom.faturamento.conta.FiltroContaGeral;
import gcom.faturamento.conta.FiltroContaMensagem;
import gcom.faturamento.conta.GerarImpostosDeduzidosContaHelper;
import gcom.faturamento.conta.IContaCategoria;
import gcom.faturamento.conta.IContaImpostosDeduzidos;
import gcom.faturamento.conta.ImpostoDeduzidoHelper;
import gcom.faturamento.conta.MotivoNaoEntregaDocumento;
import gcom.faturamento.controladores.ControladorRetificarContaLocal;
import gcom.faturamento.controladores.ControladorRetificarContaLocalHome;
import gcom.faturamento.credito.CreditoARealizar;
import gcom.faturamento.credito.CreditoARealizarCategoria;
import gcom.faturamento.credito.CreditoARealizarCategoriaHistorico;
import gcom.faturamento.credito.CreditoARealizarCategoriaHistoricoPK;
import gcom.faturamento.credito.CreditoARealizarCategoriaPK;
import gcom.faturamento.credito.CreditoARealizarGeral;
import gcom.faturamento.credito.CreditoARealizarHistorico;
import gcom.faturamento.credito.CreditoOrigem;
import gcom.faturamento.credito.CreditoRealizado;
import gcom.faturamento.credito.CreditoRealizadoCategoria;
import gcom.faturamento.credito.CreditoRealizadoCategoriaHistorico;
import gcom.faturamento.credito.CreditoRealizadoCategoriaPK;
import gcom.faturamento.credito.CreditoRealizadoHistorico;
import gcom.faturamento.credito.CreditoTipo;
import gcom.faturamento.credito.FiltroCreditoARealizar;
import gcom.faturamento.credito.FiltroCreditoARealizarGeral;
import gcom.faturamento.credito.FiltroCreditoTipo;
import gcom.faturamento.credito.ICreditoRealizado;
import gcom.faturamento.debito.DebitoACobrar;
import gcom.faturamento.debito.DebitoACobrarCategoria;
import gcom.faturamento.debito.DebitoACobrarCategoriaHistorico;
import gcom.faturamento.debito.DebitoACobrarCategoriaHistoricoPK;
import gcom.faturamento.debito.DebitoACobrarCategoriaPK;
import gcom.faturamento.debito.DebitoACobrarGeral;
import gcom.faturamento.debito.DebitoACobrarHistorico;
import gcom.faturamento.debito.DebitoCobrado;
import gcom.faturamento.debito.DebitoCobradoCategoria;
import gcom.faturamento.debito.DebitoCobradoCategoriaHistorico;
import gcom.faturamento.debito.DebitoCobradoCategoriaHistoricoPK;
import gcom.faturamento.debito.DebitoCobradoCategoriaPK;
import gcom.faturamento.debito.DebitoCobradoHistorico;
import gcom.faturamento.debito.DebitoCreditoSituacao;
import gcom.faturamento.debito.DebitoTipo;
import gcom.faturamento.debito.DebitoTipoVigencia;
import gcom.faturamento.debito.FiltroDebitoACobrar;
import gcom.faturamento.debito.FiltroDebitoACobrarCategoria;
import gcom.faturamento.debito.FiltroDebitoACobrarGeral;
import gcom.faturamento.debito.FiltroDebitoTipo;
import gcom.faturamento.debito.FiltroDebitoTipoVigencia;
import gcom.faturamento.debito.IDebitoCobrado;
import gcom.faturamento.repositorio.RepositorioFaturamentoSituacao;
import gcom.faturamento.repositorio.RepositorioFaturamentoSituacaoTipo;
import gcom.financeiro.FinanciamentoTipo;
import gcom.financeiro.ResumoFaturamento;
import gcom.financeiro.lancamento.LancamentoItem;
import gcom.financeiro.lancamento.LancamentoItemContabil;
import gcom.financeiro.lancamento.LancamentoTipo;
import gcom.gui.ActionServletException;
import gcom.gui.GcomAction;
import gcom.gui.cobranca.cobrancaporresultado.MovimentarOrdemServicoEmitirOSHelper;
import gcom.gui.faturamento.consumotarifa.bean.CategoriaFaixaConsumoTarifaHelper;
import gcom.interceptor.Interceptador;
import gcom.interceptor.ObjetoTransacao;
import gcom.interceptor.RegistradorOperacao;
import gcom.micromedicao.ArquivoTextoRoteiroEmpresa;
import gcom.micromedicao.ArquivoTextoRoteiroEmpresaDivisao;
import gcom.micromedicao.ControladorMicromedicaoLocal;
import gcom.micromedicao.ControladorMicromedicaoLocalHome;
import gcom.micromedicao.FiltroArquivoTextoRoteiroEmpresa;
import gcom.micromedicao.FiltroArquivoTextoRoteiroEmpresaDivisao;
import gcom.micromedicao.FiltroRota;
import gcom.micromedicao.IRepositorioMicromedicao;
import gcom.micromedicao.Leiturista;
import gcom.micromedicao.RepositorioMicromedicaoHBM;
import gcom.micromedicao.Rota;
import gcom.micromedicao.RotaAtualizacaoSeq;
import gcom.micromedicao.SituacaoTransmissaoLeitura;
import gcom.micromedicao.consumo.ConsumoAnormalidade;
import gcom.micromedicao.consumo.ConsumoAnormalidadeAcao;
import gcom.micromedicao.consumo.ConsumoHistorico;
import gcom.micromedicao.consumo.ConsumoTipo;
import gcom.micromedicao.consumo.LigacaoTipo;
import gcom.micromedicao.hidrometro.HidrometroInstalacaoHistorico;
import gcom.micromedicao.hidrometro.HidrometroLocalInstalacao;
import gcom.micromedicao.hidrometro.HidrometroProtecao;
import gcom.micromedicao.leitura.LeituraTipo;
import gcom.micromedicao.medicao.FiltroMedicaoHistoricoSql;
import gcom.micromedicao.medicao.MedicaoHistorico;
import gcom.micromedicao.medicao.MedicaoTipo;
import gcom.relatorio.cliente.ReportItemDTO;
import gcom.relatorio.faturamento.ConsumoTarifaRelatorioHelper;
import gcom.relatorio.faturamento.FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper;
import gcom.relatorio.faturamento.RelatorioAnaliticoFaturamentoHelper;
import gcom.relatorio.faturamento.RelatorioFaturaClienteResponsavel;
import gcom.relatorio.faturamento.RelatorioFaturasAgrupadasBean;
import gcom.relatorio.faturamento.RelatorioProtocoloEntregaFaturaBean;
import gcom.relatorio.faturamento.RelatorioRelacaoAnaliticaFaturas;
import gcom.relatorio.faturamento.autoinfracao.RelatorioAutoInfracaoBean;
import gcom.relatorio.faturamento.conta.ContaLinhasDescricaoServicosTarifasTotalHelper;
import gcom.relatorio.faturamento.conta.ContasEmitidasRelatorioHelper;
import gcom.relatorio.faturamento.conta.RelatorioContasCanceladasRetificadasHelper;
import gcom.relatorio.faturamento.conta.RelatorioMapaControleConta;
import gcom.relatorio.faturamento.dto.RelatorioAgenciaReguladoraDTO;
import gcom.seguranca.acesso.Abrangencia;
import gcom.seguranca.acesso.Funcionalidade;
import gcom.seguranca.acesso.Operacao;
import gcom.seguranca.acesso.OperacaoEfetuada;
import gcom.seguranca.acesso.PermissaoEspecial;
import gcom.seguranca.acesso.usuario.Usuario;
import gcom.seguranca.acesso.usuario.UsuarioAcao;
import gcom.seguranca.acesso.usuario.UsuarioAcaoUsuarioHelper;
import gcom.seguranca.transacao.ControladorTransacaoLocal;
import gcom.seguranca.transacao.ControladorTransacaoLocalHome;
import gcom.tarefa.TarefaRelatorio;
import gcom.util.Calculos;
import gcom.util.CodigoBarras;
import gcom.util.ConstantesJNDI;
import gcom.util.ConstantesSistema;
import gcom.util.ControladorComum;
import gcom.util.ControladorException;
import gcom.util.ControladorUtilLocal;
import gcom.util.ControladorUtilLocalHome;
import gcom.util.ErroRepositorioException;
import gcom.util.IRepositorioUtil;
import gcom.util.IoUtil;
import gcom.util.RepositorioUtilHBM;
import gcom.util.ServiceLocator;
import gcom.util.ServiceLocatorException;
import gcom.util.SistemaException;
import gcom.util.Util;
import gcom.util.ZipUtil;
import gcom.util.email.ErroEmailException;
import gcom.util.email.ServicosEmail;
import gcom.util.filtro.ComparacaoTexto;
import gcom.util.filtro.MaiorQue;
import gcom.util.filtro.ParametroNaoNulo;
import gcom.util.filtro.ParametroNulo;
import gcom.util.filtro.ParametroSimples;
import gcom.util.filtro.ParametroSimplesDiferenteDe;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import java.util.zip.ZipOutputStream;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionContext;

import org.apache.commons.fileupload.FileItem;
import org.jboss.logging.Logger;

import br.com.danhil.BarCode.Interleaved2of5;

public class ControladorFaturamentoFINAL extends ControladorComum {

	private static final long serialVersionUID = 1L;
	
	SessionContext sessionContext;

	protected IRepositorioFaturamento repositorioFaturamento;
	protected IRepositorioCobranca repositorioCobranca;
	protected IRepositorioMicromedicao repositorioMicromedicao;
	protected IRepositorioUtil repositorioUtil;
	protected IRepositorioArrecadacao repositorioArrecadacao;
	protected IRepositorioLocalidade repositorioLocalidade;
	protected IRepositorioClienteImovel repositorioClienteImovel;
	protected IRepositorioCadastro repositorioCadastro;
	protected IRepositorioImovel repositorioImovel;
	protected RepositorioFaturamentoSituacao repositorioFaturamentoSituacao;
	protected RepositorioFaturamentoSituacaoTipo repositorioFaturamentoSituacaoTipo;

	private static Logger logger = Logger.getLogger(ControladorFaturamentoFINAL.class);

	public void ejbCreate() throws CreateException {
		repositorioFaturamento = RepositorioFaturamentoHBM.getInstancia();
		repositorioCobranca = RepositorioCobrancaHBM.getInstancia();
		repositorioMicromedicao = RepositorioMicromedicaoHBM.getInstancia();
		repositorioUtil = RepositorioUtilHBM.getInstancia();
		repositorioArrecadacao = RepositorioArrecadacaoHBM.getInstancia();
		repositorioLocalidade = RepositorioLocalidadeHBM.getInstancia();
		repositorioClienteImovel = RepositorioClienteImovelHBM.getInstancia();
		repositorioCadastro = RepositorioCadastroHBM.getInstancia();
		repositorioImovel = RepositorioImovelHBM.getInstancia();
		repositorioFaturamentoSituacao = RepositorioFaturamentoSituacao.getInstance();
		repositorioFaturamentoSituacaoTipo = RepositorioFaturamentoSituacaoTipo.getInstance();
	}

	@SuppressWarnings("rawtypes")
	public Integer informarConsumoMinimoParametro(
			Collection colecaoConsumoMinimoParametro,
			Collection colecaoConsumoMinimoParametroBase, Usuario usuarioLogado)
			throws ControladorException {

		Integer qtd = 0;

		Iterator colecaoConsumoMinimoParametroIterator = colecaoConsumoMinimoParametro
				.iterator();

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_CONSUMO_PARAMETRO_INFORMAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CONSUMO_PARAMETRO_INFORMAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		if (!colecaoConsumoMinimoParametroBase.isEmpty()) {
			Iterator colecaoConsumoMinimoParametroBaseIterator = colecaoConsumoMinimoParametroBase
					.iterator();

			while (colecaoConsumoMinimoParametroBaseIterator.hasNext()) {

				ConsumoMinimoParametro consumoMinimoParametro = (ConsumoMinimoParametro) colecaoConsumoMinimoParametroBaseIterator
						.next();

				if (consumoMinimoParametro.getId() != null
						&& consumoMinimoParametro.getUltimaAlteracao() != null) {
					consumoMinimoParametro
							.setOperacaoEfetuada(operacaoEfetuada);
					consumoMinimoParametro.adicionarUsuario(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					registradorOperacao
							.registrarOperacao(consumoMinimoParametro);

					getControladorUtil().remover(consumoMinimoParametro);
				}

			}
		}

		while (colecaoConsumoMinimoParametroIterator.hasNext()) {

			ConsumoMinimoParametro consumoMinimoParametro = (ConsumoMinimoParametro) colecaoConsumoMinimoParametroIterator
					.next();

			consumoMinimoParametro.setOperacaoEfetuada(operacaoEfetuada);
			consumoMinimoParametro.adicionarUsuario(usuarioLogado,
					UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(consumoMinimoParametro);

			getControladorUtil().inserir(consumoMinimoParametro);

			qtd++;
		}

		return qtd;
	}

	public void ejbRemove() {
	}

	public void ejbActivate() {
	}

	public void ejbPassivate() {
	}

	public void setSessionContext(SessionContext sessionContext) {
		this.sessionContext = sessionContext;
	}





	/**
	 * Remove todas as rotas da tabela faturamentoAtivCronRota
	 */
	public void removerRotasFaturamentoCronograma(
			FaturamentoGrupo faturamentoGrupo,
			RegistradorOperacao registradorOperacao,
			FaturamentoAtividadeCronograma faturamentoAtividadeCronograma) {

		// o objeto FaturamentoGrupo vem so com id, aki preenchemos o resto dos
		// atributos
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
				FiltroFaturamentoGrupo.ID, faturamentoGrupo.getId()));
		Collection colecaoFaturamentoGrupo;
		try {
			colecaoFaturamentoGrupo = getControladorUtil().pesquisar(
					filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

			faturamentoGrupo = (FaturamentoGrupo) Util
					.retonarObjetoDeColecao(colecaoFaturamentoGrupo);

			// remove as rotas da tabela FATURAMENTO_ATIV_CRON_ROTA
			FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();
			filtroFaturamentoAtivCronRota
					.adicionarCaminhoParaCarregamentoEntidade("faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo");
			filtroFaturamentoAtivCronRota
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtivCronRota.FATURAMENTO_GRUPO_ID,
							faturamentoGrupo.getId()));
			filtroFaturamentoAtivCronRota
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_ID,
							faturamentoAtividadeCronograma.getId()));
			filtroFaturamentoAtivCronRota.setConsultaSemLimites(true);
			Collection colecaoRotasRemover = getControladorUtil().pesquisar(
					filtroFaturamentoAtivCronRota,
					FaturamentoAtivCronRota.class.getName());
			// FaturamentoAtivCronRota faturamentoAtivCronRotaTeste =
			// (FaturamentoAtivCronRota)
			// Util.retonarObjetoDeColecao(colecaoRotasRemover);

			Iterator iteratorRotaRemover = colecaoRotasRemover.iterator();
			FaturamentoAtivCronRota faturamentoAtivCronRota = null;
			// FaturamentoAtivCronRotaPK faturamentoAtivCronRotaPK = null;
			while (iteratorRotaRemover.hasNext()) {
				faturamentoAtivCronRota = (FaturamentoAtivCronRota) iteratorRotaRemover
						.next();
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				registradorOperacao.registrarOperacao(faturamentoAtivCronRota);
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				getControladorUtil().remover(faturamentoAtivCronRota);
			}
		} catch (ControladorException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método para auxiliar a inserção e atualização de faturamento cronograma
	 * ele é responsável por carregar uma coleção com as rotas do grupo remove
	 * as rotas da tabela FATURAMENTO_ATIV_CRON_ROTA e depois inseri as rotas
	 * habilitadas para cada atividade do grupo
	 * 
	 * Para carregar a coleção de rotas habilitadas para a atividade é chamdo o
	 * método VerificarSituacaoAtividadeRota() que retorna a coleção desejada.
	 * 
	 * @throws ControladorException
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void insercaoRotasFaturamentoCronogama(
			FaturamentoGrupo faturamentoGrupo,
			Collection faturamentoAtividadeCronogramas,
			RegistradorOperacao registradorOperacao, Integer anoMesInformado)
			throws ControladorException {

		// o objeto FaturamentoGrupo vem so com id, aki preenchemos o resto dos
		// atributos
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
				FiltroFaturamentoGrupo.ID, faturamentoGrupo.getId()));
		Collection colecaoFaturamentoGrupo = getControladorUtil().pesquisar(
				filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());
		faturamentoGrupo = (FaturamentoGrupo) Util
				.retonarObjetoDeColecao(colecaoFaturamentoGrupo);

		// carrega todas as rotas do grupo em uma coleção
		FiltroRota filtroRota = new FiltroRota();
		filtroRota.setConsultaSemLimites(true);
		filtroRota.adicionarParametro(new ParametroSimples(
				FiltroRota.FATURAMENTO_GRUPO_ID, faturamentoGrupo.getId()));
		Collection colecaoRotasFaturamentoGrupo = getControladorUtil()
				.pesquisar(filtroRota, Rota.class.getName());

		// intera a coleção de faturamentoAtividadeCronogramas para achar as
		// rotas habilitadas para cada atividade
		Iterator iteratorAtividades = faturamentoAtividadeCronogramas
				.iterator();
		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = null;
		while (iteratorAtividades.hasNext()) {
			faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iteratorAtividades
					.next();
			if (faturamentoAtividadeCronograma.getComando() != null) {
				Collection colecaoRotasHabilitadas = verificarSituacaoAtividadeRota(
						colecaoRotasFaturamentoGrupo,
						faturamentoAtividadeCronograma
								.getFaturamentoAtividade(), faturamentoGrupo,
						true);

				if (!colecaoRotasHabilitadas.isEmpty()) {
					Iterator iteratorAtividadesInserir = colecaoRotasHabilitadas
							.iterator();

					Rota rotaInserir = null;
					FaturamentoAtivCronRotaPK faturamentoAtivCronRotaPKInserir = null;
					FaturamentoAtivCronRota faturamentoAtivCronRotaInserir = null;
					while (iteratorAtividadesInserir.hasNext()) {
						rotaInserir = (Rota) iteratorAtividadesInserir.next();

						faturamentoAtivCronRotaPKInserir = new FaturamentoAtivCronRotaPK();
						faturamentoAtivCronRotaPKInserir
								.setFaturamentoAtividadeCronogramaId(faturamentoAtividadeCronograma
										.getId());
						faturamentoAtivCronRotaPKInserir.setRotaId(rotaInserir
								.getId());

						faturamentoAtivCronRotaInserir = new FaturamentoAtivCronRota();
						faturamentoAtivCronRotaInserir
								.setComp_id(faturamentoAtivCronRotaPKInserir);
						faturamentoAtivCronRotaInserir
								.setUltimaAlteracao(new Date());

						if ((faturamentoAtividadeCronograma
								.getFaturamentoAtividade().getId()
								.equals(FaturamentoAtividade.FATURAR_GRUPO))
								|| (rotaInserir.getLeituraTipo() != null
										&& rotaInserir
												.getLeituraTipo()
												.getId()
												.equals(LeituraTipo.LEITURA_E_ENTRADA_SIMULTANEA) && faturamentoAtividadeCronograma
										.getFaturamentoAtividade()
										.getId()
										.equals(FaturamentoAtividade.GERAR_ARQUIVO_LEITURA))) {

							/** alterado por pedro alexandre dia 27/06/2007 */
							/*
							 * String dataVencimentoGrupo = faturamentoGrupo
							 * .getDiaVencimento() + "/" +
							 * faturamentoGrupo.getMesAno();
							 * faturamentoAtivCronRotaInserir
							 * .setDataContaVencimento(Util
							 * .converteStringParaDate(dataVencimentoGrupo));
							 */
							// [UC0618] Obter data de vencimento do grupo.
							Date dataVencimentoGrupo = this
									.obterDataVencimentoGrupo(
											faturamentoGrupo.getId(),
											anoMesInformado);
							faturamentoAtivCronRotaInserir
									.setDataContaVencimento(dataVencimentoGrupo);
						}

						/** fim alteração */

						// ------------ REGISTRAR TRANSAÇÃO ----------------
						registradorOperacao
								.registrarOperacao(faturamentoAtivCronRotaInserir);
						// ------------ REGISTRAR TRANSAÇÃO ----------------
						getControladorUtil().inserir(
								faturamentoAtivCronRotaInserir);
					}
				} else {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.pesquisa.nenhuma.rota_habilitada_grupo");
				}

			}
		}

	}

	/**
	 * Metodo para validar: Caso usuário informe uma data prevista, de qualquer
	 * atividade, com o mês/ano maior que o mês ]/ano do cronograma+1, exibir a
	 * mensagem: "A data prevista da atividade nã pode ser superior a <<mês/ano
	 * do cronograma+1>>"
	 * 
	 * @param faturamentoAtividadeCronogramas
	 *            Descrição do parâmetro
	 * @param mesAno
	 * @throws ControladorException
	 */
	public void validarFaturamentoCronogramaAtividadeMaiorQueMesAnoCronograma(int anoMes, Collection faturamentoAtividadeCronogramas) throws ControladorException {
		Iterator iteratorFaturamentoAtividadeCronograma = faturamentoAtividadeCronogramas.iterator();

		int anoMesMaisUm = (Util.somaUmMesAnoMesReferencia(new Integer(anoMes))).intValue();

		int anoMesMenosDois = (Util.subtrairMesDoAnoMes(anoMes, 2));

		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = null;
		String mes = null;
		String ano = null;
		// Cria objeto
		String dataAtividade = null;
		int anoMesAtividade = 0;
		while (iteratorFaturamentoAtividadeCronograma.hasNext()) {
			faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iteratorFaturamentoAtividadeCronograma.next();

			if (faturamentoAtividadeCronograma.getDataPrevista() != null) {
				dataAtividade = Util.formatarDataComHora(faturamentoAtividadeCronograma.getDataPrevista());

				mes = dataAtividade.substring(3, 5);
				ano = dataAtividade.substring(6, 10);
				anoMesAtividade = (new Integer(ano + mes)).intValue();
				if (anoMesAtividade > anoMesMaisUm) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.faturamento.mes_ano_atividade_maior_mes_ano_cronograma",
							null, Util.formatarAnoMesParaMesAno(anoMesMaisUm));
				}

				if (anoMesAtividade < anoMesMenosDois) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.faturamento.mes_ano_atividade_menor_mes_ano_cronograma",
							null, Util.formatarAnoMesParaMesAno(anoMesMenosDois));
				}
			}
		}

	}

	/**
	 * O método recebe uma coleção de faturamento atividades acha as que tem
	 * atividade predecessora e compara a data desta com a data da sua
	 * predecessora.
	 * 
	 * @param faturamentoAtividadeCronogramas
	 *            Descrição do parâmetro
	 * @param faturamentoGrupoCronogramaMensal
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public void validarFaturamentoCronograma(
			Collection faturamentoAtividadeCronogramas)
			throws ControladorException {
		// ----------Parte de validação de datas em seguência -----------//
		Iterator iteratorFaturamentoAtividadeSequencia = faturamentoAtividadeCronogramas
				.iterator();
		Collection colecaoDatasPreenchidas = new ArrayList();

		FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaSegundo = null;
		FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaPrimeiro = null;
		// monta uma coleção com as datas obrigatorias e/ou não
		// obrigatoria(essas quando preenchidas)
		while (iteratorFaturamentoAtividadeSequencia.hasNext()) {
			faturamentoAtividadeCronogramaPrimeiro = (FaturamentoAtividadeCronograma) iteratorFaturamentoAtividadeSequencia
					.next();
			// teste para saber se atividade é obrigatoria, se não for, se ela
			// está preenchida
			if (faturamentoAtividadeCronogramaPrimeiro
					.getFaturamentoAtividade()
					.getIndicadorObrigatoriedadeAtividade()
					.equals(ConstantesSistema.INDICADOR_USO_ATIVO)) {
				colecaoDatasPreenchidas
						.add(faturamentoAtividadeCronogramaPrimeiro);
			} else if (faturamentoAtividadeCronogramaPrimeiro.getDataPrevista() != null) {
				colecaoDatasPreenchidas
						.add(faturamentoAtividadeCronogramaPrimeiro);
			}

		}
		// Aqui começa o teste se as datas estão em seguencia
		Iterator iteratorTesteSeguenciaDatas = colecaoDatasPreenchidas
				.iterator();

		faturamentoAtividadeCronogramaPrimeiro = (FaturamentoAtividadeCronograma) iteratorTesteSeguenciaDatas
				.next();
		while (iteratorTesteSeguenciaDatas.hasNext()) {
			faturamentoAtividadeCronogramaSegundo = (FaturamentoAtividadeCronograma) iteratorTesteSeguenciaDatas
					.next();
			if (faturamentoAtividadeCronogramaPrimeiro.getDataPrevista().after(
					faturamentoAtividadeCronogramaSegundo.getDataPrevista())) {
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.faturamento_ordem_datas");
			}
			faturamentoAtividadeCronogramaPrimeiro = faturamentoAtividadeCronogramaSegundo;
		}

		// -----------Parte de validação de
		// predecessora--------------------------//
		// iterator principal em qual procuro se a atividade tem predecessora
		Iterator iteratorFaturamentoAtividadeCronogramaPrincipal = faturamentoAtividadeCronogramas
				.iterator();
		// objeto principal
		FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaPrincipal = null;
		// objeto de teste(secundario)
		FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaTeste = null;
		while (iteratorFaturamentoAtividadeCronogramaPrincipal.hasNext()) {
			faturamentoAtividadeCronogramaPrincipal = (FaturamentoAtividadeCronograma) iteratorFaturamentoAtividadeCronogramaPrincipal
					.next();
			// testa se a atividade Principal tem predecessora
			if (faturamentoAtividadeCronogramaPrincipal
					.getFaturamentoAtividade()
					.getFaturamentoAtividadePrecedente() != null) {
				Iterator iteratorFaturamentoAtividadeCronogramaTestado = faturamentoAtividadeCronogramas
						.iterator();
				// roda a coleção a procura da predecessora da principal
				while (iteratorFaturamentoAtividadeCronogramaTestado.hasNext()) {
					faturamentoAtividadeCronogramaTeste = (FaturamentoAtividadeCronograma) iteratorFaturamentoAtividadeCronogramaTestado
							.next();
					// testa se o objeto corrente teste é o predecessor da
					// principal
					// caso seja testa se a atividade predecessora é inferior ou
					// igual a principal
					// se não for causa uma exceção
					if (faturamentoAtividadeCronogramaPrincipal
							.getFaturamentoAtividade()
							.getFaturamentoAtividadePrecedente()
							.getId()
							.equals(faturamentoAtividadeCronogramaTeste
									.getFaturamentoAtividade().getId())) {

						if (faturamentoAtividadeCronogramaTeste
								.getDataPrevista() == null) {
							sessionContext.setRollbackOnly();
							throw new ControladorException(
									"atencao.faturamento.data_predecessora_nula");
						}

						if (faturamentoAtividadeCronogramaTeste
								.getDataPrevista().after(
										faturamentoAtividadeCronogramaPrincipal
												.getDataPrevista())) {
							sessionContext.setRollbackOnly();
							throw new ControladorException(
									"atencao.data_invalida.atividade_predecessora");
						}
						break;
					}
				}
			}
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param faturamentoAtividadeCronogramas
	 *            Descrição do parâmetro
	 * @param faturamentoGrupoCronogramaMensal
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public void inserirFaturamentoCronograma(
			Collection faturamentoAtividadeCronogramas,
			FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal,
			RegistradorOperacao registradorOperacao, Usuario usuarioLogado,
			Integer anoMesInformado) throws ControladorException {
		// Prepara iterator para percorrer a coleçao de Faturamento
		// Atividade
		// Cronograma
		Iterator iteratorFaturamentoCronograma = faturamentoAtividadeCronogramas
				.iterator();
		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = new FaturamentoAtividadeCronograma();
		// FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaVelho =
		// null;
		boolean atualizar = false;
		Collection faturamentoAtividadeCronogramasNovas = new ArrayList();
		while (iteratorFaturamentoCronograma.hasNext()) {
			faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iteratorFaturamentoCronograma
					.next();
			faturamentoAtividadeCronograma
					.setFaturamentoGrupoCronogramaMensal(faturamentoGrupoCronogramaMensal);

			// Testa se data prevista é maior ou igual a data atual
			// Comparar atraves do mes ano do cronograma mensal
			Calendar dataPrevistaTeste = Calendar.getInstance();

			if (faturamentoAtividadeCronograma.getDataPrevista() != null) {
				dataPrevistaTeste.setTime(faturamentoAtividadeCronograma
						.getDataPrevista());
			}

			/*
			 * int ano = dataPrevistaTeste.get(Calendar.YEAR); int mes =
			 * dataPrevistaTeste.get(Calendar.MONTH) + 1; String anoMes = null;
			 * if (mes < 10) { anoMes = ano + "0" + mes; } else { anoMes = ano +
			 * "" + mes; }
			 * 
			 * int mesMenoUm = dataPrevistaTeste.get(Calendar.MONTH) - 1; String
			 * anoMesMenosUm = null; if (mes < 10) { anoMesMenosUm = ano + "0" +
			 * mesMenoUm; } else { anoMesMenosUm = ano + "" + mesMenoUm; }
			 */

			// if (faturamentoGrupoCronogramaMensal.getAnoMesReferencia()
			// .intValue() <= Integer.parseInt(anoMes)) {
			faturamentoAtividadeCronograma.setUsuario(usuarioLogado);
			faturamentoAtividadeCronograma.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			registradorOperacao
					.registrarOperacao(faturamentoAtividadeCronograma);
			// ------------ REGISTRAR TRANSAÇÃO ----------------
			if (faturamentoAtividadeCronograma.getId() != null
					&& !faturamentoAtividadeCronograma.getId().toString()
							.trim().equalsIgnoreCase("")) {
				getControladorUtil().atualizar(faturamentoAtividadeCronograma);
				atualizar = true;
			} else {
				faturamentoAtividadeCronograma
						.setId((Integer) getControladorUtil().inserir(
								faturamentoAtividadeCronograma));
				faturamentoAtividadeCronogramasNovas
						.add(faturamentoAtividadeCronograma);
			}

			// Pega id e guarda numa colecao p necessidade de ser
			// removido
			// por alguma falha no processo.
			// faturamentoAtividadeCronogramaVelho =
			// faturamentoAtividadeCronograma;

			// } else {
			// throw new
			// ControladorException("atencao.nao_cadastrado.consumo_cronograma_anterior");
			// sessionContext.setRollbackOnly();
			// throw new ControladorException(
			// "atencao.faturamento_atividade_menor");
			// }
			if (faturamentoAtividadeCronograma.getComando() == null) {
				removerRotasFaturamentoCronograma(
						faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
						registradorOperacao, faturamentoAtividadeCronograma);
			}
		}
		if (!atualizar) {
			insercaoRotasFaturamentoCronogama(
					faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
					faturamentoAtividadeCronogramas, registradorOperacao,
					anoMesInformado);
		} else {
			insercaoRotasFaturamentoCronogama(
					faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
					faturamentoAtividadeCronogramasNovas, registradorOperacao,
					anoMesInformado);

		}
	}

	@SuppressWarnings({ "rawtypes", "rawtypes" })
	public void atualizarFaturamentoGrupoCronogramaMensal(
			FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal,
			Collection faturamentoAtividadeCronogramas,
			Collection colecaoTodasAtividades, Usuario usuarioLogado)
			throws ControladorException {
		Integer id = null;

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ATUALIZAR_CRONOGRAMA_FATURAMENTO,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		// Procura o último registro, do grupo informado, salvo na tabela.
		/* int idMaximo = */getControladorUtil().valorMaximo(
				FaturamentoGrupoCronogramaMensal.class,
				FiltroFaturamentoGrupoCronogramaMensal.ID,
				FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO,
				faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getId()
						.toString());

		// Procura se ja existe alguma FaturaGrupoCronogramaMensal com o
		// mesmo mes ano
		FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

		filtroFaturamentoGrupoCronogramaMensal
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA,
						faturamentoGrupoCronogramaMensal.getAnoMesReferencia()));

		filtroFaturamentoGrupoCronogramaMensal
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO,
						faturamentoGrupoCronogramaMensal.getFaturamentoGrupo()
								.getId()));

		Collection faturamentoGrupoCronogramaMensais = getControladorUtil()
				.pesquisar(filtroFaturamentoGrupoCronogramaMensal,
						FaturamentoGrupoCronogramaMensal.class.getName());

		// faz o controle de concorrencia
		if (!faturamentoGrupoCronogramaMensais.isEmpty()) {
			FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensalNaBase = (FaturamentoGrupoCronogramaMensal) faturamentoGrupoCronogramaMensais
					.iterator().next();

			if ((faturamentoGrupoCronogramaMensalNaBase.getUltimaAlteracao()
					.after(faturamentoGrupoCronogramaMensal
							.getUltimaAlteracao()))) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

		}
		// faz o controle de concorrencia

		// Pega o último objeto FaturamentoGrupo para comparação de datas.
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();

		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
				FiltroFaturamentoGrupo.ID, faturamentoGrupoCronogramaMensal
						.getFaturamentoGrupo().getId()));

		Collection faturamentoGrupos = getControladorUtil().pesquisar(
				filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

		if (!faturamentoGrupos.isEmpty()) {
			FaturamentoGrupo faturamentoGrupoNaBase = (FaturamentoGrupo) faturamentoGrupos
					.iterator().next();

			// Inicio teste de datas para validação da inserçao
			if (faturamentoGrupoNaBase.getAnoMesReferencia().compareTo(
					faturamentoGrupoCronogramaMensal.getAnoMesReferencia()) == 1) {
				// || faturamentoGrupoNaBase.getAnoMesReferencia().compareTo(
				// faturamentoGrupoCronogramaMensal
				// .getAnoMesReferencia()) == 0) {
				// criar um erro de data (data informada tem q ser superior
				// a data ##/####)
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.data_invalida.ano_mes_inferior", null,
						Util.formatarAnoMesParaMesAno(faturamentoGrupoNaBase
								.getAnoMesReferencia().toString()));
			}
		}

		faturamentoGrupoCronogramaMensal.setUsuario(usuarioLogado);
		faturamentoGrupoCronogramaMensal.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		registradorOperacao.registrarOperacao(faturamentoGrupoCronogramaMensal);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		if (faturamentoGrupoCronogramaMensal.getId() == null) {
			// Grave o faturamentoGrupoCronogramaMensal na base e retorna o
			// id
			FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensalid = (FaturamentoGrupoCronogramaMensal) getControladorUtil()
					.inserir(faturamentoGrupoCronogramaMensal);
			id = faturamentoGrupoCronogramaMensalid.getId();
			// Seta um objeto com o id retornado
			faturamentoGrupoCronogramaMensal.setId(id);
		} else {
			getControladorUtil().atualizar(faturamentoGrupoCronogramaMensal);
		}

		inserirFaturamentoCronograma(faturamentoAtividadeCronogramas,
				faturamentoGrupoCronogramaMensal, registradorOperacao,
				usuarioLogado,
				faturamentoGrupoCronogramaMensal.getAnoMesReferencia());

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param localidade
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public void atualizarFaturamentoAtividadeCronograma(
			FaturamentoAtividadeCronograma faturamentoAtividadeCronograma)
			throws ControladorException {

		// -----VALIDAÇÃO DOS TIMESTAMP PARA ATUALIZAÇÃO DE CADASTRO

		// Validação para Setor Comercial
		if (faturamentoAtividadeCronograma != null) {
			// Cria o filtro
			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = FaturamentoAtividadeCronograma.class
					.getName();

			// Seta os parametros do filtro
			filtroFaturamentoAtividadeCronograma
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.ID,
							faturamentoAtividadeCronograma.getId()));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection faturamentoAtividadeCronogramas = getControladorUtil()
					.pesquisar(filtroFaturamentoAtividadeCronograma,
							nomePacoteObjeto);

			FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaNaBase = (FaturamentoAtividadeCronograma) Util
					.retonarObjetoDeColecao(faturamentoAtividadeCronogramas);

			// Verifica se a data de alteração do objeto gravado na base é
			// maior que a na instancia
			if ((faturamentoAtividadeCronogramaNaBase.getUltimaAlteracao()
					.after(faturamentoAtividadeCronograma.getUltimaAlteracao()))) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.atualizacao.timestamp");
			}

			// Seta a data/hora
			faturamentoAtividadeCronograma.setUltimaAlteracao(new Date());

		}

		// Atualiza objeto
		getControladorUtil().atualizar(faturamentoAtividadeCronograma);
	}

	/**
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * 
	 * [SB0002] - Excluir Comando de Atividade de Faturamento
	 * 
	 * @throws ControladorException
	 * 
	 */
	public void removerComandoAtividadeFaturamento(String[] ids)
			throws ControladorException {

		int indexArray = 0;
		String idsConcatenados = "";

		while (indexArray < ids.length) {
			if (idsConcatenados.equalsIgnoreCase("")) {
				idsConcatenados = ids[indexArray];
			} else {
				idsConcatenados = idsConcatenados + ", " + ids[indexArray];
			}
			indexArray++;
		}

		Collection colecaoFaturamentoAtividadeCronograma;

		try {

			colecaoFaturamentoAtividadeCronograma = this.repositorioFaturamento
					.buscarFaturamentoAtividadeCronograma(idsConcatenados);

			/*
			 * Atualiza a data e hora do comando (FTAC_TMCOMANDO=Null) na tabela
			 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=Id da Atividade e
			 * FTCM_ID=FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL
			 * para FTGR_ID=Id do Grupo de Faturamento e
			 * FTCM_AMREFERENCIA=Referência
			 */

			Iterator colecaoFaturamentoAtividadeCronogramaIterator = colecaoFaturamentoAtividadeCronograma
					.iterator();
			FaturamentoAtividadeCronograma faturamentoAtividadeCronograma;

			while (colecaoFaturamentoAtividadeCronogramaIterator.hasNext()) {
				faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) colecaoFaturamentoAtividadeCronogramaIterator
						.next();

				faturamentoAtividadeCronograma.setComando(null);
				faturamentoAtividadeCronograma.setUltimaAlteracao(new Date());

				this.atualizarFaturamentoAtividadeCronograma(faturamentoAtividadeCronograma);

				this.repositorioFaturamento
						.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma
								.getId());
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param faturamentoGrupoCronogramaMensal
	 *            Descrição do parâmetro
	 * @param faturamentoAtividadeCronogramas
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public void inserirFaturamentoGrupoCronogramaMensal(
			FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal,
			Collection faturamentoAtividadeCronogramas, Usuario usuarioLogado,
			Integer anoMesInformado) throws ControladorException {

		// Integer id = null;

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_INSERIR_CRONOGRAMA_FATURAMENTO,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		// Procura o último registro, do grupo informado, salvo na tabela.
		/* int idMaximo = */getControladorUtil().valorMaximo(
				FaturamentoGrupoCronogramaMensal.class,
				FiltroFaturamentoGrupoCronogramaMensal.ID,
				FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO,
				faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getId()
						.toString());

		// Procura se ja existe alguma FaturaGrupoCronogramaMensal com o
		// mesmo mes ano
		FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

		filtroFaturamentoGrupoCronogramaMensal
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA,
						faturamentoGrupoCronogramaMensal.getAnoMesReferencia()));

		filtroFaturamentoGrupoCronogramaMensal
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO,
						faturamentoGrupoCronogramaMensal.getFaturamentoGrupo()
								.getId()));

		Collection faturamentoGrupoCronogramaMensais = getControladorUtil()
				.pesquisar(filtroFaturamentoGrupoCronogramaMensal,
						FaturamentoGrupoCronogramaMensal.class.getName());

		if (faturamentoGrupoCronogramaMensais.isEmpty()) {
			// Pega o último objeto FaturamentoGrupo para comparação de
			// datas.
			FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();

			filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
					FiltroFaturamentoGrupo.ID, faturamentoGrupoCronogramaMensal
							.getFaturamentoGrupo().getId()/*
														 * new Integer(idMaximo)
														 */));

			Collection faturamentoGrupos = getControladorUtil().pesquisar(
					filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

			if (!faturamentoGrupos.isEmpty()) {
				FaturamentoGrupo faturamentoGrupoNaBase = (FaturamentoGrupo) faturamentoGrupos
						.iterator().next();

				// Inicio teste de datas para validação da inserçao
				if (faturamentoGrupoNaBase.getAnoMesReferencia().compareTo(
						faturamentoGrupoCronogramaMensal.getAnoMesReferencia()) == 1) {
					// criar um erro de data (data informada tem q ser
					// superior a data ##/####)
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.data_invalida.ano_mes_inferior",
							null,
							Util.formatarAnoMesParaMesAno(faturamentoGrupoNaBase
									.getAnoMesReferencia().toString()));
				}
			}
			faturamentoGrupoCronogramaMensal.setUsuario(usuarioLogado);
			faturamentoGrupoCronogramaMensal.setUltimaAlteracao(new Date());
			// Grave o faturamentoGrupoCronogramaMensal na base e retorna o
			// id
			Integer faturamentoGrupoCronogramaMensalid = null;

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			registradorOperacao
					.registrarOperacao(faturamentoGrupoCronogramaMensal);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			if (faturamentoGrupoCronogramaMensal.getId() != null
					&& !faturamentoGrupoCronogramaMensal.getId().toString()
							.trim().equalsIgnoreCase("")) {
				faturamentoGrupoCronogramaMensalid = faturamentoGrupoCronogramaMensal
						.getId();
				getControladorUtil()
						.atualizar(faturamentoGrupoCronogramaMensal);
			} else {
				faturamentoGrupoCronogramaMensalid = (Integer) getControladorUtil()
						.inserir(faturamentoGrupoCronogramaMensal);
			}

			// id = faturamentoGrupoCronogramaMensalid.getId();
			// Seta um objeto com o id retornado
			// faturamentoGrupoCronogramaMensal.setId(id);

			faturamentoGrupoCronogramaMensal
					.setId(faturamentoGrupoCronogramaMensalid);

			inserirFaturamentoCronograma(faturamentoAtividadeCronogramas,
					faturamentoGrupoCronogramaMensal, registradorOperacao,
					usuarioLogado, anoMesInformado);
		} else {
			// cronograma do mes ja gerado anteriormente
			throw new ControladorException("atencao.cronogama_mes_ja_gerado",
					null);
		}
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void faturarGrupoFaturamento(Collection colecaoFaturamentoAtividadeCronogramaRota, FaturamentoGrupo faturamentoGrupo, int atividade,
			int idFuncionalidadeIniciada) throws ControladorException {

		int idUnidadeIniciada = 0;
		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.ROTA, ((FaturamentoAtivCronRota) Util.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRota)).getRota().getId());

		try {

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			if (colecaoFaturamentoAtividadeCronogramaRota != null && !colecaoFaturamentoAtividadeCronogramaRota.isEmpty()) {

				Iterator iteratorColecaoFaturamentoAtividadeCronogramaRota = colecaoFaturamentoAtividadeCronogramaRota.iterator();

				ApagarDadosFaturamentoHelper helper = new ApagarDadosFaturamentoHelper();

				this.atualizarDataCronogramaEfetuarLeitura(faturamentoGrupo);
				
				while (iteratorColecaoFaturamentoAtividadeCronogramaRota.hasNext()) {

					FaturamentoAtivCronRota faturamentoAtivCronRota = (FaturamentoAtivCronRota) iteratorColecaoFaturamentoAtividadeCronogramaRota.next();

					Rota rota = faturamentoAtivCronRota.getRota();
					rota.setFaturamentoGrupo(faturamentoGrupo);
					
					this.prepararFaturamentoImovel(atividade, rota, null);

					// Variáveis para a paginação da pesquisa de Imovel por
					// Grupo Faturamento
					// ========================================================================
					boolean flagTerminou = false;
					final int quantidadeRegistros = 3000;
					int numeroIndice = 0;
					// ========================================================================

					while (!flagTerminou) {

						Collection colecaoImovel = this
								.pesquisarImovelGrupoFaturamento(
										faturamentoAtivCronRota.getRota(),
										numeroIndice, quantidadeRegistros,
										false, false);

						// Resumos de faturamento para simulação.
						Collection colecaoResumoFaturamento = new ArrayList();

						/*
						 * Caso exista ids de imóveis para a rota atual
						 * determina o faturamento para cada imóvel retornado.
						 */
						if (colecaoImovel != null && !colecaoImovel.isEmpty()) {

							Iterator iteratorColecaoImoveis = colecaoImovel
									.iterator();

							// LAÇO PARA DETERMINAR O FATURAMENTO DE TODOS OS
							// IMOVEIS DA ROTA ATUAL
							Imovel imovel = null;
							while (iteratorColecaoImoveis.hasNext()) {

								imovel = (Imovel) iteratorColecaoImoveis.next();

								// FATURAMENTO ATUAL
								// --------------------------------------------------------------------------------
								this.faturarImovel(
										faturamentoGrupo.getAnoMesReferencia(),
										atividade, sistemaParametro,
										faturamentoAtivCronRota,
										colecaoResumoFaturamento, imovel,
										false, faturamentoGrupo);
								// --------------------------------------------------------------------------------

								// FATURAMENTO ANTECIPADO
								// --------------------------------------------------------------------------------
								this.faturarImovelAntecipado(
										faturamentoGrupo.getAnoMesReferencia(),
										atividade, sistemaParametro,
										faturamentoAtivCronRota,
										colecaoResumoFaturamento, imovel,
										faturamentoGrupo);
								// --------------------------------------------------------------------------------

							}// FIM DO LOOP DE IMOVEIS

						}// FIM DO LOOP DE IMOVEIS

						/*
						 * Caso a coleção de resumo de faturamento não esteja
						 * vazia ou nula inseri os resumos na base de dados.
						 */
						if (colecaoResumoFaturamento != null
								&& !colecaoResumoFaturamento.isEmpty()) {

							this.inserirResumoSimulacaoFaturamento(colecaoResumoFaturamento);

							if (colecaoResumoFaturamento != null) {
								colecaoResumoFaturamento.clear();
								colecaoResumoFaturamento = null;
							}
						}

						/**
						 * Incrementa o nº do indice da páginação
						 */
						numeroIndice = numeroIndice + quantidadeRegistros;

						/**
						 * Caso a coleção de imoveis retornados for menor que a
						 * quantidade de registros seta a flag indicando que a
						 * paginação terminou.
						 */
						if (colecaoImovel == null
								|| colecaoImovel.size() < quantidadeRegistros) {

							flagTerminou = true;
						}

						if (colecaoImovel != null) {
							colecaoImovel.clear();
							colecaoImovel = null;
						}

					}// FIM DO LOOP DA PAGINAÇÃO
				}

				// ATUALIZAÇÃO DO SEQUENCIAL DE ROTA, BASEADO NA
				// TABELA ROTA_ATUALIZACAO_SEQUENCIAL
				// --------------------------------------------------------------------------------
				Integer idRota = ((FaturamentoAtivCronRota) Util
						.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRota))
						.getRota().getId();

				// this.atualizarSequencialRota( idRota,
				// faturamentoGrupo.getAnoMesReferencia() );

				// Selecionamos os dados necessários
				Collection<RotaAtualizacaoSeq> dados = this.repositorioMicromedicao
						.pesquisarRotaAtualizacao(idRota,
								faturamentoGrupo.getAnoMesReferencia());

				for (RotaAtualizacaoSeq seq : dados) {

					// Para cada um, atualizamos o imovel
					this.repositorioCadastro.atualizarSequenciaRotaImovel(seq);
				}
				// --------------------------------------------------------------------------------

			} else {
				// A LISTA COM AS ROTAS ESTÁ NULA OU VAZIA

				throw new ControladorException(
						"atencao.pesquisa.grupo_rota_vazio");
			}

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) {

			/*
			 * Este catch serve para interceptar qualquer exceção que o processo
			 * batch venha a lançar e garantir que a unidade de processamento do
			 * batch será atualizada com o erro ocorrido.
			 */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);
			throw new EJBException(e);
		}

	}

	@SuppressWarnings("rawtypes")
	protected void faturarImovel(Integer anoMesFaturamentoGrupo, int atividade,
			SistemaParametro sistemaParametro,
			FaturamentoAtivCronRota faturamentoAtivCronRota,
			Collection colecaoResumoFaturamento, Imovel imovel,
			boolean faturamentoAntecipado, FaturamentoGrupo faturamentoGrupo)
			throws ControladorException {

		Integer existeImovelConta = (Integer) getControladorImovel().pesquisarImovelIdComConta(imovel.getId(), anoMesFaturamentoGrupo);

		Conta conta = null;

		if (existeImovelConta != null) {

			Collection contas = this.obterConta(existeImovelConta);

			if (contas != null && !contas.isEmpty()) {
				Iterator contasIterator = contas.iterator();

				while (contasIterator.hasNext()) {
					conta = (Conta) contasIterator.next();
				}
			}

		}

		if (existeImovelConta == null
				|| (conta != null
					&& conta.getDebitoCreditoSituacaoAtual() != null 
					&& conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.PRE_FATURADA))) {

			boolean gerarAtividadeGrupoFaturamento = false;

			if (atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()) {
				gerarAtividadeGrupoFaturamento = true;
			} else if (atividade == FaturamentoAtividade.SIMULAR_FATURAMENTO
					.intValue()) {
				gerarAtividadeGrupoFaturamento = false;
			}

			this.determinarFaturamentoImovel(imovel,
					gerarAtividadeGrupoFaturamento, faturamentoAtivCronRota,
					colecaoResumoFaturamento, sistemaParametro,
					faturamentoAntecipado, anoMesFaturamentoGrupo, faturamentoGrupo);
		}

	}

	public void atualizarAnoMesReferenciaFaturamentoGrupo(
			FaturamentoGrupo faturamentoGrupo,
			Integer anoMesReferenciaFaturamento, int atividade)
			throws ControladorException {
		try {
			this.repositorioFaturamento
					.atualizarAnoMesReferenciaFaturamentoGrupo(
							faturamentoGrupo.getId(),
							anoMesReferenciaFaturamento);

			this.repositorioFaturamento.atualizarDataHoraRealizacaoAtividade(
					atividade, anoMesReferenciaFaturamento,
					faturamentoGrupo.getId());

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * Determina o tipo de conta que será associado na impressão da conta.
	 * 
	 * [SB0006 - ]
	 * 
	 * @author Raphael Rossiter
	 * @date 09/12/2005
	 * 
	 * @param imovel
	 * @throws ControladorException
	 */
	protected ContaTipo obterContaTipoParaContaImpressao(Conta conta,
			Integer idClienteResponsavel, Imovel imovel) {

		ContaTipo contaTipo = new ContaTipo();

		contaTipo.setId(ContaTipo.CONTA_NORMAL);

		if (conta.getContaMotivoRevisao() != null
				&& conta.getContaMotivoRevisao()
						.getId()
						.equals(ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO)) {

			contaTipo.setId(ContaTipo.CONTA_RETIDA_POR_EC);
		}

		else if (conta.getContaMotivoRevisao() != null
				&& conta.getContaMotivoRevisao()
						.getId()
						.equals(ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO)) {

			contaTipo.setId(ContaTipo.CONTA_RETIDA_POR_BC);
		}

		// Comentado por Raphael Rossiter em 01/03/2007 (Analista Responsável:
		// Aryed)

		/*
		 * else if (idClienteResponsavel != null) {
		 * 
		 * contaTipo.setId(ContaTipo.CONTA_CLIENTE_RESPONSAVEL); }
		 */

		// Colocado por Raphael Rossiter em 01/03/2007 (Analista Responsável:
		// Aryed)
		else if (idClienteResponsavel != null
				&& imovel.getIndicadorDebitoConta().shortValue() == ConstantesSistema.NAO
						.shortValue()) {

			contaTipo.setId(ContaTipo.CONTA_CLIENTE_RESPONSAVEL);
		}

		else if (idClienteResponsavel != null
				&& imovel.getIndicadorDebitoConta().shortValue() == ConstantesSistema.SIM
						.shortValue()) {

			contaTipo.setId(ContaTipo.CONTA_DEBITO_AUTO_COM_CLIENTE_RESP);
		}

		// Colocado por Raphael Rossiter em 01/03/2007 (Analista Responsável:
		// Aryed)
		else if (idClienteResponsavel == null
				&& imovel.getIndicadorDebitoConta().shortValue() == ConstantesSistema.SIM
						.shortValue()) {

			contaTipo.setId(ContaTipo.CONTA_DEBITO_AUTOMATICO);
		}

		return contaTipo;
	}

    private boolean deveFaturar(Imovel imovel, Integer anoMesFaturamento) throws ControladorException {
        boolean faturar = true;
        
        try {
            if (imovel.getFaturamentoSituacaoTipo() != null) {
                Collection<FaturamentoSituacaoHistorico> faturamentosSituacaoHistorico = repositorioFaturamentoSituacao.faturamentosHistoricoVigentesPorImovel(imovel.getId());
                
                if (faturamentosSituacaoHistorico.isEmpty()){
                    return true;
                }
                
                FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = faturamentosSituacaoHistorico.iterator().next();
                
                FaturamentoSituacaoTipo tipo = repositorioFaturamentoSituacaoTipo.situacaoTipoDoImovel(imovel.getId());
                
                if ((faturamentoSituacaoHistorico != null && faturamentoSituacaoHistorico.dentroIntervaloFaturamento(anoMesFaturamento))
                     && tipo.paralisacaoFaturamentoAtivo()  
                     && imovel.faturamentoAguaValido()) {
                    faturar = false;
                }
            }
        } catch (Exception e) {
            throw new ControladorException("Erro ao verificar se imovel deve faturar", e);
        }

        return faturar;
    }
	
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void determinarFaturamentoImovel(Imovel imovel,
			boolean gerarAtividadeGrupoFaturamento,
			FaturamentoAtivCronRota faturamentoAtivCronRota,
			Collection colecaoResumoFaturamento,
			SistemaParametro sistemaParametro, boolean faturamentoAntecipado,
			Integer anoMesFaturamentoGrupo, FaturamentoGrupo faturamentoGrupo)
			throws ControladorException {

		Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
		Collection colecaoCategoriaOUSubcategoria = getControladorImovel().obterColecaoCategoriaOuSubcategoriaDoImovel(imovel);

		DeterminarValoresFaturamentoAguaEsgotoHelper helperValoresAguaEsgoto = new DeterminarValoresFaturamentoAguaEsgotoHelper();

		LigacaoTipo ligacaoTipoAgua = new LigacaoTipo(LigacaoTipo.LIGACAO_AGUA);
		LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo(LigacaoTipo.LIGACAO_ESGOTO);

		ConsumoHistorico consumoHistoricoAgua = this.getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipoAgua, anoMesFaturamentoGrupo);

		Integer consumoAgua = null;
		ConsumoTipo consumoTipoAgua = null;

		if (consumoHistoricoAgua != null) {
			consumoAgua = consumoHistoricoAgua.getNumeroConsumoFaturadoMes();
			consumoTipoAgua = consumoHistoricoAgua.getConsumoTipo();
		}

		ConsumoHistorico consumoHistoricoEsgoto = this.getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel,ligacaoTipoEsgoto, anoMesFaturamentoGrupo);

		Integer consumoEsgoto = null;
		ConsumoTipo consumoTipoEsgoto = null;

		if (consumoHistoricoEsgoto != null) {
			consumoEsgoto = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
			consumoTipoEsgoto = consumoHistoricoEsgoto.getConsumoTipo();
		}

		if (permiteFaturarSituacaoEspecialFaturamento(imovel, anoMesFaturamentoGrupo)) {

			if (this.permiteFaturamentoParaAgua(imovel.getLigacaoAguaSituacao(), consumoAgua, consumoTipoAgua)
					|| this.permiteFaturamentoParaEsgoto(imovel.getLigacaoEsgotoSituacao(), consumoEsgoto,consumoTipoEsgoto)) {

				helperValoresAguaEsgoto = this.determinarValoresFaturamentoAguaEsgoto(imovel, anoMesFaturamentoGrupo, colecaoCategoriaOUSubcategoria,
								faturamentoGrupo, consumoHistoricoAgua, consumoHistoricoEsgoto);
			}
			
			
			boolean gerarConta = false;
			
			if (imovel.useNovaChecagemGerarConta() || imovel.getImovelCondominio() != null){
			    boolean imovelSemConsumo = helperValoresAguaEsgoto.imovelSemConsumo();
			    
			    gerarConta = getControladorAnaliseGeracaoConta().verificarGeracaoConta(imovelSemConsumo, anoMesFaturamentoGrupo, imovel);
			}else{
			    gerarConta = this.verificarNaoGeracaoConta(imovel, helperValoresAguaEsgoto.getValorTotalAgua(), 
			            helperValoresAguaEsgoto.getValorTotalEsgoto(), anoMesFaturamentoGrupo, false);
			}


			if (gerarConta) {

				boolean preFaturamento = false;

				GerarDebitoCobradoHelper gerarDebitoCobradoHelper = this.gerarDebitoCobrado(imovel, anoMesFaturamentoGrupo, 
						sistemaParametro,gerarAtividadeGrupoFaturamento);
				
				GerarCreditoRealizadoHelper gerarCreditoRealizadoHelper = this.gerarCreditoRealizado(imovel, anoMesFaturamentoGrupo,helperValoresAguaEsgoto,
						gerarDebitoCobradoHelper.getValorTotalDebito(), gerarAtividadeGrupoFaturamento, preFaturamento);

				if (gerarAtividadeGrupoFaturamento) {

					GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper = this.gerarImpostosDeduzidosConta(imovel.getId(),
									anoMesFaturamentoGrupo, helperValoresAguaEsgoto.getValorTotalAgua(),
									helperValoresAguaEsgoto.getValorTotalEsgoto(),
									gerarDebitoCobradoHelper.getValorTotalDebito(),
									gerarCreditoRealizadoHelper.getValorTotalCredito(),
									preFaturamento);

					gerarDebitoCobradoHelper.setGerarImpostosDeduzidosContaHelper(gerarImpostosDeduzidosContaHelper);

					Conta conta = this.gerarConta(imovel, anoMesFaturamentoGrupo,
							sistemaParametro, faturamentoAtivCronRota,
							helperValoresAguaEsgoto, gerarDebitoCobradoHelper,
							gerarCreditoRealizadoHelper,
							gerarImpostosDeduzidosContaHelper,
							faturamentoGrupo, faturamentoAntecipado,
							preFaturamento);

					GerarContaCategoriaHelper gerarContaCategoriaHelper = this.gerarContaCategoria(conta, colecaoCategoriaOUSubcategoria,
									helperValoresAguaEsgoto.getColecaoCalcularValoresAguaEsgotoHelper(), sistemaParametro);

					// INSERINDO CONTA_CATEGORIA NA BASE
					if (gerarContaCategoriaHelper.getColecaoContaCategoria() != null
							&& !gerarContaCategoriaHelper.getColecaoContaCategoria().isEmpty()) {
						this.getControladorBatch().inserirColecaoObjetoParaBatch(gerarContaCategoriaHelper.getColecaoContaCategoria());
					}

					// INSERINDO CONTA_CATEGORIA_CONSUMO_FAIXA
					if (gerarContaCategoriaHelper.getColecaoContaCategoriaConsumoFaixa() != null
							&& !gerarContaCategoriaHelper.getColecaoContaCategoriaConsumoFaixa().isEmpty()) {

						this.getControladorBatch().inserirColecaoObjetoParaBatch(gerarContaCategoriaHelper.getColecaoContaCategoriaConsumoFaixa());
					}

					this.inserirClienteConta(conta, imovel);
					this.inserirContaImpostosDeduzidos(conta,gerarImpostosDeduzidosContaHelper);
					this.inserirDebitoCobrado(gerarDebitoCobradoHelper.getMapDebitosCobrados(),conta);
					
					this.atualizarDebitoACobrarFaturamento(gerarDebitoCobradoHelper.getColecaoDebitoACobrar());

					this.inserirCreditoRealizado(gerarCreditoRealizadoHelper.getMapCreditoRealizado(), conta);

					this.atualizarCreditoARealizar(gerarCreditoRealizadoHelper.getColecaoCreditoARealizar());

					this.gerarContaImpressao(conta, faturamentoGrupo, imovel,faturamentoAtivCronRota.getRota());

					if (imovel.getIndicadorDebitoConta().equals(ConstantesSistema.SIM) && conta.getContaMotivoRevisao() == null) {
						conta.setImovel(imovel);
						conta.setFaturamentoGrupo(faturamentoGrupo);
						
						this.gerarMovimentoDebitoAutomatico(conta);
					}
					
					try {
						repositorioFaturamento.concluirFaturamentoConta(conta.getId());
					} catch (ErroRepositorioException e) {
						throw new ControladorException("Erro ao concluir etapa de faturamento", e);
					}
				}

				if (!gerarAtividadeGrupoFaturamento) {
					GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper = this.gerarImpostosDeduzidosConta(imovel.getId(),
									anoMesFaturamentoGrupo, helperValoresAguaEsgoto.getValorTotalAgua(),
									helperValoresAguaEsgoto.getValorTotalEsgoto(),
									gerarDebitoCobradoHelper.getValorTotalDebito(),
									gerarCreditoRealizadoHelper.getValorTotalCredito(),
									preFaturamento);

					gerarDebitoCobradoHelper.setGerarImpostosDeduzidosContaHelper(gerarImpostosDeduzidosContaHelper);

					Integer anoMesReferenciaResumoFaturamento = null;

					if (faturamentoAntecipado) {
						anoMesReferenciaResumoFaturamento = anoMesFaturamentoGrupo;
					}
					
					this.gerarResumoFaturamentoSimulacao(colecaoCategorias,
							helperValoresAguaEsgoto.getColecaoCalcularValoresAguaEsgotoHelper(),
							gerarDebitoCobradoHelper,
							gerarCreditoRealizadoHelper,
							colecaoResumoFaturamento, imovel,
							gerarAtividadeGrupoFaturamento,
							faturamentoAtivCronRota, faturamentoGrupo,
							anoMesReferenciaResumoFaturamento, false);
				}
			}
		}
	}

	private boolean permiteFaturarSituacaoEspecialFaturamento(Imovel imovel,
			Integer anoMesFaturamento) throws ControladorException {
		boolean faturar = true;

		// Verificar se é para faturar pela situação especial de faturamento
		FiltroFaturamentoSituacaoHistorico filtroFaturamentoSituacaoHistorico = new FiltroFaturamentoSituacaoHistorico();
		filtroFaturamentoSituacaoHistorico.adicionarParametro(new ParametroSimples(FiltroFaturamentoSituacaoHistorico.ID_IMOVEL, imovel.getId()));
		filtroFaturamentoSituacaoHistorico.adicionarParametro(new ParametroNulo(FiltroFaturamentoSituacaoHistorico.ANO_MES_FATURAMENTO_RETIRADA));
		Collection<FaturamentoSituacaoHistorico> colFiltroFaturamentoSituacaoHistorico = this.getControladorUtil().pesquisar(
						filtroFaturamentoSituacaoHistorico,
						FaturamentoSituacaoHistorico.class.getName());

		FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = (FaturamentoSituacaoHistorico) Util.retonarObjetoDeColecao(colFiltroFaturamentoSituacaoHistorico);

		if (imovel.getFaturamentoSituacaoTipo() != null && !imovel.getFaturamentoSituacaoTipo().equals("")) {

			if ((faturamentoSituacaoHistorico != null
					&& anoMesFaturamento >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio() 
					&& anoMesFaturamento <= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoFim())
					&& (imovel.getFaturamentoSituacaoTipo() != null
							&& imovel.getFaturamentoSituacaoTipo().getIndicadorParalisacaoFaturamento().intValue() == 1 
							&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue() == 1)) {
				faturar = false;
			}
		}
		return faturar;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * 
	 * @author Raphael Rossiter
	 * @date 04/06/2008
	 * 
	 * @param imovel
	 * @param anoMesFaturamento
	 * @return boolean
	 * @throws ControladorException
	 */
	public boolean permiteFaturamentoParaAgua(
			LigacaoAguaSituacao ligacaoAguaSituacao, Integer consumoAgua,
			ConsumoTipo consumoTipo) throws ControladorException {

		boolean permiteFaturar = false;

		// LIGACAO_TIPO_AGUA
		LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
		ligacaoTipoAgua.setId(LigacaoTipo.LIGACAO_AGUA);

		/*
		 * Selecionar os imóveis que farão parte do faturamento de acordo com o
		 * INDICADOR_FATURAMENTO_SITUACAO e CONSUMO_MINIMO_FATURAMENTO que se
		 * encontra na situação da ligação e água e esgoto do imóvel.
		 */
		if (ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().equals(
				LigacaoAguaSituacao.FATURAMENTO_ATIVO)
				&& ligacaoAguaSituacao.getConsumoMinimoFaturamento().intValue() <= 0) {

			permiteFaturar = true;
		} else if (ligacaoAguaSituacao.getIndicadorFaturamentoSituacao()
				.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
				&& ligacaoAguaSituacao.getConsumoMinimoFaturamento().intValue() > 0) {

			/*
			 * Para faturar: O valor do consumo mínimo da ligação tem que ser
			 * menor ou igual ao valor do consumo do imóvel e o tipo de consumo
			 * esteja associado a situação da ligação do imóvel.
			 */
			if (consumoAgua != null
					&& ligacaoAguaSituacao.getConsumoMinimoFaturamento()
							.intValue() <= consumoAgua.intValue()) {

				if (consumoTipo != null) {

					LigacaoAguaSituacaoConsumoTipo ligacaoAguaSituacaoConsumoTipo = this
							.getControladorLigacaoAgua()
							.pesquisarLigacaoAguaSituacaoConsumoTipo(
									ligacaoAguaSituacao.getId(),
									consumoTipo.getId());

					if (ligacaoAguaSituacaoConsumoTipo != null) {
						permiteFaturar = true;
					}
				} else {

					// Está situação irá acontecer apenas para as
					// funcionalidades do online
					permiteFaturar = true;
				}
			}
		}

		return permiteFaturar;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * 
	 * @author Raphael Rossiter
	 * @date 04/06/2008
	 * 
	 * @param imovel
	 * @param anoMesFaturamento
	 * @return boolean
	 * @throws ControladorException
	 */
	public boolean permiteFaturamentoParaEsgoto(
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao, Integer consumoEsgoto,
			ConsumoTipo consumoTipo) throws ControladorException {

		boolean permiteFaturar = false;

		// LIGACAO_TIPO_ESGOTO
		LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
		ligacaoTipoEsgoto.setId(LigacaoTipo.LIGACAO_ESGOTO);

		if (ligacaoEsgotoSituacao != null) {

			if (ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao().equals(
					LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)
					&& ligacaoEsgotoSituacao.getVolumeMinimoFaturamento()
							.intValue() <= 0) {

				permiteFaturar = true;
			} else if (ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao()
					.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)
					&& ligacaoEsgotoSituacao.getVolumeMinimoFaturamento()
							.intValue() > 0) {

				if (consumoEsgoto != null
						&& ligacaoEsgotoSituacao.getVolumeMinimoFaturamento()
								.intValue() <= consumoEsgoto.intValue()) {

					if (consumoTipo != null) {

						LigacaoEsgotoSituacaoConsumoTipo ligacaoEsgotoSituacaoConsumoTipo = this
								.getControladorLigacaoEsgoto()
								.pesquisarLigacaoEsgotoSituacaoConsumoTipo(
										ligacaoEsgotoSituacao.getId(),
										consumoTipo.getId());

						if (ligacaoEsgotoSituacaoConsumoTipo != null) {
							permiteFaturar = true;
						}
					} else {

						// Está situação irá acontecer apenas para as
						// funcionalidades do online
						permiteFaturar = true;
					}
				}
			}
		}

		return permiteFaturar;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * 
	 * @author Raphael Rossiter
	 * @date 04/06/2008
	 * 
	 * @param imovel
	 * @param anoMesFaturamento
	 * @return boolean
	 * @throws ControladorException
	 */
	public boolean permiteImovelFaturarGrupoFaturamento(Imovel imovel,
			Integer anoMesFaturamento) throws ControladorException {

		boolean permiteFaturar = false;

		// LIGACAO_TIPO_AGUA
		LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
		ligacaoTipoAgua.setId(LigacaoTipo.LIGACAO_AGUA);

		// LIGACAO_TIPO_ESGOTO
		LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
		ligacaoTipoEsgoto.setId(LigacaoTipo.LIGACAO_ESGOTO);

		/*
		 * Selecionar os imóveis que farão parte do faturamento de acordo com o
		 * INDICADOR_FATURAMENTO_SITUACAO e CONSUMO_MINIMO_FATURAMENTO que se
		 * encontra na situação da ligação e água e esgoto do imóvel.
		 */
		if (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
				.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
				&& imovel.getLigacaoAguaSituacao()
						.getConsumoMinimoFaturamento().intValue() <= 0) {

			permiteFaturar = true;
		} else if (imovel.getLigacaoAguaSituacao()
				.getIndicadorFaturamentoSituacao()
				.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
				&& imovel.getLigacaoAguaSituacao()
						.getConsumoMinimoFaturamento().intValue() > 0) {

			/*
			 * CONSUMO_HISTORICO para o imóvel no anoMesFaturamento e com
			 * ligacaoTipo igual a LIGACAO_AGUA: Inicializar o
			 * indicadorFaturamentoAgua = 1 e o consumoFaturadoMesAgua = 0
			 */

			// CONSUMO_HISTORICO_AGUA
			ConsumoHistorico consumoHistoricoAgua = this
					.getControladorMicromedicao()
					.obterConsumoHistoricoMedicaoIndividualizada(imovel,
							ligacaoTipoAgua, anoMesFaturamento);

			/*
			 * Para faturar: O valor do consumo mínimo da ligação tem que ser
			 * menor ou igual ao valor do consumo do imóvel e o tipo de consumo
			 * esteja associado a situação da ligação do imóvel.
			 */
			if (consumoHistoricoAgua != null
					&& consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null
					&& imovel.getLigacaoAguaSituacao()
							.getConsumoMinimoFaturamento().intValue() <= consumoHistoricoAgua
							.getNumeroConsumoFaturadoMes().intValue()) {

				LigacaoAguaSituacaoConsumoTipo ligacaoAguaSituacaoConsumoTipo = this
						.getControladorLigacaoAgua()
						.pesquisarLigacaoAguaSituacaoConsumoTipo(
								imovel.getLigacaoAguaSituacao().getId(),
								consumoHistoricoAgua.getConsumoTipo().getId());

				if (ligacaoAguaSituacaoConsumoTipo != null) {
					permiteFaturar = true;
				}
			}
		}

		if (!permiteFaturar) {

			if (imovel.getLigacaoEsgotoSituacao()
					.getIndicadorFaturamentoSituacao()
					.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)
					&& imovel.getLigacaoEsgotoSituacao()
							.getVolumeMinimoFaturamento().intValue() <= 0) {

				permiteFaturar = true;
			} else if (imovel.getLigacaoEsgotoSituacao()
					.getIndicadorFaturamentoSituacao()
					.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)
					&& imovel.getLigacaoEsgotoSituacao()
							.getVolumeMinimoFaturamento().intValue() > 0) {

				// CONSUMO_HISTORICO_ESGOTO
				ConsumoHistorico consumoHistoricoEsgoto = this
						.getControladorMicromedicao()
						.obterConsumoHistoricoMedicaoIndividualizada(imovel,
								ligacaoTipoEsgoto, anoMesFaturamento);

				/*
				 * Para faturar: O valor do consumo mínimo da ligação tem que
				 * ser menor ou igual ao valor do consumo do imóvel e o tipo de
				 * consumo esteja associado a situação da ligação do imóvel.
				 */
				if (consumoHistoricoEsgoto != null
						&& consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null
						&& imovel.getLigacaoEsgotoSituacao()
								.getVolumeMinimoFaturamento().intValue() <= consumoHistoricoEsgoto
								.getNumeroConsumoFaturadoMes().intValue()) {

					LigacaoEsgotoSituacaoConsumoTipo ligacaoEsgotoSituacaoConsumoTipo = this
							.getControladorLigacaoEsgoto()
							.pesquisarLigacaoEsgotoSituacaoConsumoTipo(
									imovel.getLigacaoEsgotoSituacao().getId(),
									consumoHistoricoEsgoto.getConsumoTipo()
											.getId());

					if (ligacaoEsgotoSituacaoConsumoTipo != null) {
						permiteFaturar = true;
					}
				}
			}
		}

		return permiteFaturar;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * Atualizar os Credito a Realizar
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * 
	 * @param colecaoCreditosARealizarUpdate
	 * @throws ControladorException
	 */
	@SuppressWarnings("rawtypes")
	protected void atualizarCreditoARealizar(
			Collection colecaoCreditosARealizarUpdate)
			throws ControladorException {
		// atualizar creditoARealizar
		if (colecaoCreditosARealizarUpdate != null
				&& !colecaoCreditosARealizarUpdate.isEmpty()) {

			Iterator iteratorColecaoCreditosARealizarUpdate = colecaoCreditosARealizarUpdate
					.iterator();
			CreditoARealizar creditoARealizar = null;
			while (iteratorColecaoCreditosARealizarUpdate.hasNext()) {
				creditoARealizar = (CreditoARealizar) iteratorColecaoCreditosARealizarUpdate
						.next();
				try {

					repositorioFaturamento
							.atualizarCreditoARealizar(creditoARealizar);
				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
			}

			colecaoCreditosARealizarUpdate.clear();
			colecaoCreditosARealizarUpdate = null;

		}
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * Atualizar os Debitos a Cobrar
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * 
	 * @param colecaoDebitosACobrarUpdate
	 * @throws ControladorException
	 */
	@SuppressWarnings("rawtypes")
	protected void atualizarDebitoACobrarFaturamento(
			Collection<DebitoACobrar> colecaoDebitosACobrarUpdate)
			throws ControladorException {
		if (colecaoDebitosACobrarUpdate != null
				&& !colecaoDebitosACobrarUpdate.isEmpty()) {

			Iterator iteratorColecaoDebitosACobrarUpdate = colecaoDebitosACobrarUpdate
					.iterator();

			DebitoACobrar debitoACobrar = null;

			while (iteratorColecaoDebitosACobrarUpdate.hasNext()) {
				debitoACobrar = (DebitoACobrar) iteratorColecaoDebitosACobrarUpdate
						.next();
				try {

					repositorioFaturamento
							.atualizarDebitoAcobrar(debitoACobrar);

				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
			}

			colecaoDebitosACobrarUpdate.clear();
			colecaoDebitosACobrarUpdate = null;

		}
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * Inserir credito realizado e credito realizado categoria
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * 
	 * @param mapCreditoRealizado
	 * @param conta
	 * @throws ControladorException
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void inserirCreditoRealizado(
			Map<CreditoRealizado, Collection<CreditoRealizadoCategoria>> mapCreditoRealizado,
			Conta conta) throws ControladorException {
		// inserir credito realizado
		// inserir credito realizado categoria
		if (mapCreditoRealizado != null && !mapCreditoRealizado.isEmpty()) {

			Collection colecaoCreditoRealizadoCategoria = new ArrayList();

			Iterator iteratorColecaoCreditosRealizadosCreditosARealizar = mapCreditoRealizado
					.keySet().iterator();

			CreditoRealizado creditoRealizado = null;

			while (iteratorColecaoCreditosRealizadosCreditosARealizar.hasNext()) {

				creditoRealizado = (CreditoRealizado) iteratorColecaoCreditosRealizadosCreditosARealizar
						.next();

				Collection colecaoCreditosRealizadosCategoriaCreditoRealizado = mapCreditoRealizado
						.get(creditoRealizado);

				creditoRealizado.setConta(conta);
				creditoRealizado.setUltimaAlteracao(new Date());
				Integer idCreditoRealizado = (Integer) this
						.getControladorUtil().inserir(creditoRealizado);
				creditoRealizado.setId(idCreditoRealizado);

				Iterator iteratorColecaoCreditosRealizadosCategoriaCreditoRealizado = colecaoCreditosRealizadosCategoriaCreditoRealizado
						.iterator();

				CreditoRealizadoCategoria creditoRealizadoCategoria = null;

				while (iteratorColecaoCreditosRealizadosCategoriaCreditoRealizado
						.hasNext()) {
					creditoRealizadoCategoria = (CreditoRealizadoCategoria) iteratorColecaoCreditosRealizadosCategoriaCreditoRealizado
							.next();
					creditoRealizadoCategoria.setUltimaAlteracao(new Date());
					creditoRealizadoCategoria.getComp_id().setCreditoRealizado(
							creditoRealizado);
					colecaoCreditoRealizadoCategoria
							.add(creditoRealizadoCategoria);
				}
			}

			this.getControladorBatch().inserirColecaoObjetoParaBatch(
					colecaoCreditoRealizadoCategoria);

			if (colecaoCreditoRealizadoCategoria != null) {
				colecaoCreditoRealizadoCategoria.clear();
				colecaoCreditoRealizadoCategoria = null;
			}

			mapCreditoRealizado.clear();
			mapCreditoRealizado = null;
		}
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * Gravar os Dados refernte ao ID da Conta inserir debito cobrado
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * 
	 * @param mapDebitosCobrados
	 * @param conta
	 * @throws ControladorException
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void inserirDebitoCobrado(
			Map<DebitoCobrado, Collection<DebitoCobradoCategoria>> mapDebitosCobrados,
			Conta conta) throws ControladorException {

		if (mapDebitosCobrados != null && !mapDebitosCobrados.isEmpty()) {

			Collection colecaoDebitosCobradosCategoriaInserir = new ArrayList();

			// PARA INSERIR DEBITO_CONRADO_CATEGORIA
			Iterator iteratorColecaoDebitosCobrados = mapDebitosCobrados
					.keySet().iterator();

			DebitoCobrado debitoCobrado = null;

			Collection colecaoDebitoCobradoCategoriaDebitoCobrado = null;

			while (iteratorColecaoDebitosCobrados.hasNext()) {

				// DEBITO_COBRADO QUE SERÁ INSERIDO
				debitoCobrado = (DebitoCobrado) iteratorColecaoDebitosCobrados
						.next();

				// COLEÇÃO COM OS DEBITOS_COBRADOS POR CATEGORIA QUE SERÃO
				// INSERIDOS
				colecaoDebitoCobradoCategoriaDebitoCobrado = mapDebitosCobrados
						.get(debitoCobrado);

				debitoCobrado.setConta(conta);
				debitoCobrado.setDebitoCobrado(new Date());
				debitoCobrado.setUltimaAlteracao(new Date());

				Integer idDebitoCobrado = (Integer) this.getControladorUtil()
						.inserir(debitoCobrado);

				Iterator iteratorColecaoDebitosCobradoCategoria = colecaoDebitoCobradoCategoriaDebitoCobrado
						.iterator();

				while (iteratorColecaoDebitosCobradoCategoria.hasNext()) {

					DebitoCobradoCategoria debitoCobradoCategoria = (DebitoCobradoCategoria) iteratorColecaoDebitosCobradoCategoria
							.next();

					debitoCobradoCategoria.getComp_id().setDebitoCobradoId(
							idDebitoCobrado);
					debitoCobradoCategoria.setUltimaAlteracao(new Date());

					colecaoDebitosCobradosCategoriaInserir
							.add(debitoCobradoCategoria);
				}
			}

			// INSERINDO DEBITO_COBRADO_CATEGORIA
			this.getControladorBatch().inserirColecaoObjetoParaBatch(
					colecaoDebitosCobradosCategoriaInserir);

			if (colecaoDebitosCobradosCategoriaInserir != null) {
				colecaoDebitosCobradosCategoriaInserir.clear();
				colecaoDebitosCobradosCategoriaInserir = null;
			}
		}
	}

	/**
	 * 
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * [SF0006] Item 7
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * 
	 * @param conta
	 * @param gerarImpostosDeduzidosContaHelper
	 * @throws ControladorException
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void inserirContaImpostosDeduzidos(Conta conta,
			GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper)
			throws ControladorException {
		// Incluir conta impostos deduzidos
		Collection colecaoImpostosDeduzidosHelper = gerarImpostosDeduzidosContaHelper
				.getListaImpostosDeduzidos();
		if (colecaoImpostosDeduzidosHelper != null
				&& !colecaoImpostosDeduzidosHelper.isEmpty()) {

			Collection colecaoContaImpostosDeduzidosInserir = new ArrayList();

			Iterator iteratorColecaoImpostosDeduzidosHelper = colecaoImpostosDeduzidosHelper
					.iterator();

			ImpostoDeduzidoHelper impostoDeduzidoHelper = null;

			while (iteratorColecaoImpostosDeduzidosHelper.hasNext()) {
				impostoDeduzidoHelper = (ImpostoDeduzidoHelper) iteratorColecaoImpostosDeduzidosHelper
						.next();
				ContaImpostosDeduzidos contaImpostosDeduzidos = new ContaImpostosDeduzidos();
				contaImpostosDeduzidos.setConta(conta);
				ImpostoTipo impostoTipo = new ImpostoTipo();
				impostoTipo.setId(impostoDeduzidoHelper.getIdImpostoTipo());
				contaImpostosDeduzidos.setImpostoTipo(impostoTipo);
				contaImpostosDeduzidos.setValorImposto(impostoDeduzidoHelper
						.getValor());
				contaImpostosDeduzidos
						.setPercentualAliquota(impostoDeduzidoHelper
								.getPercentualAliquota());
				contaImpostosDeduzidos.setUltimaAlteracao(new Date());

				contaImpostosDeduzidos
						.setValorBaseCalculo(gerarImpostosDeduzidosContaHelper
								.getValorBaseCalculo());

				colecaoContaImpostosDeduzidosInserir
						.add(contaImpostosDeduzidos);
			}

			if (colecaoContaImpostosDeduzidosInserir != null
					&& !colecaoContaImpostosDeduzidosInserir.isEmpty()) {
				this.getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoContaImpostosDeduzidosInserir);

				colecaoContaImpostosDeduzidosInserir.clear();
				colecaoContaImpostosDeduzidosInserir = null;
			}

		}

		if (colecaoImpostosDeduzidosHelper != null) {
			colecaoImpostosDeduzidosHelper.clear();
			colecaoImpostosDeduzidosHelper = null;
		}
	}

	/**
	 * [UC0113] - Fatuar Grupo Faturamento [SF009] - Adiconar na coleção para
	 * gerar o resumo faturamento simulação Author: Rafael Santos Data:
	 * 17/02/2006
	 * 
	 * @param colecaoResumoFaturamentoSimulacao
	 * @param categoria
	 * @param calcularValoresAguaEsgotoHelper
	 * @param imovel
	 * @param gerarAtiviadadeGrupoFaturamento
	 * @param valorTotalDebitos
	 * @param valorTotalCreditos
	 * @param rota
	 * @param anoMesReferencia
	 * @param colecaoValoresPorTipoDebito
	 * @param colecaoValoresPorTipoCredito
	 * @param bigDecimal
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void adicionarColecaoResumoFaturamentoSimulacao(
			Collection colecaoResumoFaturamentoSimulacao,
			Categoria categoria,
			Subcategoria subCategoria,
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper,
			Imovel imovel,
			boolean gerarAtiviadadeGrupoFaturamento,
			BigDecimal valorTotalDebitos,
			BigDecimal valorTotalCreditos,
			FaturamentoAtivCronRota faturamentoAtivCronRota,
			int anoMesReferencia,
			boolean primeiraCategoria,
			boolean preFaturar,
			Collection<ValorPorTipoRegistroHelper> colecaoValoresPorTipoDebito,
			Collection<ValorPorTipoRegistroHelper> colecaoValoresPorTipoCredito,
			BigDecimal valorImpostos) {

		// se tiver categoria e valores agua e esgoto, para os dados de
		// quantidades e valores faturado de agua e esgoto
		ResumoFaturamentoSimulacao resumoFaturamentoSimulacaoNaColecao = null;
		ResumoFaturamentoSimulacaoHelper resumoFaturamentoSimulacaoHelperNaColecao = null;

		if (categoria != null && calcularValoresAguaEsgotoHelper != null) {

			// SF009 - Adiconar na coleção para gerar o resumo faturamento
			// simulação
			boolean adcionar = true;
			if (colecaoResumoFaturamentoSimulacao != null
					&& !colecaoResumoFaturamentoSimulacao.isEmpty()) {

				Iterator iteratorColecaoResumoFaturamento = colecaoResumoFaturamentoSimulacao
						.iterator();

				boolean achou = true;

				while (iteratorColecaoResumoFaturamento.hasNext() && achou) {

					// resumo faturamento simulçao na coleção
					resumoFaturamentoSimulacaoHelperNaColecao = (ResumoFaturamentoSimulacaoHelper) iteratorColecaoResumoFaturamento
							.next();

					resumoFaturamentoSimulacaoNaColecao = resumoFaturamentoSimulacaoHelperNaColecao
							.getResumoFaturamentoSimulacao();

					if (resumoFaturamentoSimulacaoNaColecao
							.getAnoMesReferencia().intValue() == anoMesReferencia
							&& resumoFaturamentoSimulacaoNaColecao
									.getFaturamentoGrupo().getId().intValue() == faturamentoAtivCronRota
									.getRota().getFaturamentoGrupo().getId()
									.intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getLocalidade().getId().intValue() == imovel
									.getLocalidade().getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao.getQuadra()
									.getId().intValue() == imovel.getQuadra()
									.getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getLigacaoAguaSituacao().getId()
									.intValue() == imovel
									.getLigacaoAguaSituacao().getId()
									.intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getLigacaoEsgotoSituacao().getId()
									.intValue() == imovel
									.getLigacaoEsgotoSituacao().getId()
									.intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getCategoria().getId().intValue() == categoria
									.getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getImovelPerfil().getId().intValue() == imovel
									.getImovelPerfil().getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getIndicadorDebitoConta().shortValue() == imovel
									.getIndicadorDebitoConta().shortValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getGerenciaRegional().getId().intValue() == imovel
									.getLocalidade().getGerenciaRegional()
									.getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getSetorComercial().getId().intValue() == imovel
									.getSetorComercial().getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao.getRota()
									.getId().intValue() == imovel.getQuadra()
									.getRota().getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getLocalidade().getUnidadeNegocio()
									.getId().intValue() == imovel
									.getLocalidade().getUnidadeNegocio()
									.getId().intValue()

					) {
						EsferaPoder esferaPoder = null;

						if (imovel.getClienteImoveis() != null
								&& !imovel.getClienteImoveis().isEmpty()) {

							Cliente clienteImovel = (Cliente) imovel
									.getClienteImoveis().iterator().next();

							esferaPoder = clienteImovel.getClienteTipo()
									.getEsferaPoder();
						}

						if (resumoFaturamentoSimulacaoNaColecao
								.getEsferaPoder() != null
								&& esferaPoder != null) {

							if (resumoFaturamentoSimulacaoNaColecao
									.getEsferaPoder().getId().intValue() == esferaPoder
									.getId().intValue()) {

								if (primeiraCategoria) {

									// ATUALIZA A QUANTIDADE DE CONTAS ****
									resumoFaturamentoSimulacaoNaColecao
											.setQuantidadeContas(resumoFaturamentoSimulacaoNaColecao
													.getQuantidadeContas() + 1);
								}
								achou = false;
								adcionar = false;
							}
						}

						if (resumoFaturamentoSimulacaoNaColecao
								.getEsferaPoder() == null
								&& esferaPoder == null) {

							if (primeiraCategoria) {
								// ATUALIZA A QUANTIDADE DE CONTAS ****
								resumoFaturamentoSimulacaoNaColecao
										.setQuantidadeContas(resumoFaturamentoSimulacaoNaColecao
												.getQuantidadeContas() + 1);
							}
							achou = false;
							adcionar = false;
						}
					}
				}

				// se é para acumular ou para inserir na coleção
				// acumula se tiver algum igual
				if (!adcionar) {

					int qtdEconomias = resumoFaturamentoSimulacaoNaColecao
							.getQuantidadeEconomia().intValue();

					if (subCategoria.getId().intValue() != Subcategoria.SUBCATEGORIA_ZERO
							.getId().intValue()) {
						qtdEconomias = qtdEconomias
								+ subCategoria.getQuantidadeEconomias()
										.intValue();
					} else {
						qtdEconomias = qtdEconomias
								+ categoria.getQuantidadeEconomiasCategoria()
										.intValue();
					}

					// acumula os dados dos dados do resumo ja existente
					// quantidade economia
					resumoFaturamentoSimulacaoNaColecao
							.setQuantidadeEconomia((short) qtdEconomias);

					// valor agua
					if (calcularValoresAguaEsgotoHelper
							.getValorFaturadoAguaCategoria() != null) {
						resumoFaturamentoSimulacaoNaColecao
								.setValorAgua(resumoFaturamentoSimulacaoNaColecao
										.getValorAgua()
										.add(calcularValoresAguaEsgotoHelper
												.getValorFaturadoAguaCategoria()));
					}

					// consumo agua
					if (calcularValoresAguaEsgotoHelper
							.getConsumoFaturadoAguaCategoria() != null) {

						resumoFaturamentoSimulacaoNaColecao
								.setConsumoAgua(new Integer(
										resumoFaturamentoSimulacaoNaColecao
												.getConsumoAgua().intValue()
												+ calcularValoresAguaEsgotoHelper
														.getConsumoFaturadoAguaCategoria()
														.intValue()));
					}

					// valor esgoto
					if (calcularValoresAguaEsgotoHelper
							.getValorFaturadoEsgotoCategoria() != null) {

						resumoFaturamentoSimulacaoNaColecao
								.setValorEsgoto(resumoFaturamentoSimulacaoNaColecao
										.getValorEsgoto()
										.add(calcularValoresAguaEsgotoHelper
												.getValorFaturadoEsgotoCategoria()));
					}

					// consumo esgoto
					if (calcularValoresAguaEsgotoHelper
							.getConsumoFaturadoEsgotoCategoria() != null) {

						resumoFaturamentoSimulacaoNaColecao
								.setConsumoEsgoto(new Integer(
										resumoFaturamentoSimulacaoNaColecao
												.getConsumoEsgoto().intValue()
												+ calcularValoresAguaEsgotoHelper
														.getConsumoFaturadoEsgotoCategoria()
														.intValue()));
					}

					// valor debitos
					if (valorTotalDebitos != null) {
						resumoFaturamentoSimulacaoNaColecao
								.setValorDebitos(resumoFaturamentoSimulacaoNaColecao
										.getValorDebitos().add(
												valorTotalDebitos));

						if (colecaoValoresPorTipoDebito != null
								&& !colecaoValoresPorTipoDebito.isEmpty()) {

							Collection<ResumoFaturamentoSimulacaoDebito> colecaoDebitos = resumoFaturamentoSimulacaoHelperNaColecao
									.getResumoFaturamentoSimulacaoDebito();

							labelDebitos: for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoDebito) {
								boolean encontrou = false;
								for (ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebito : colecaoDebitos) {

									if (resumoFaturamentoSimulacaoDebito
											.getComp_id()
											.getDebitoTipo()
											.getId()
											.compareTo(
													valorPorTipoRegistroHelper
															.getDebitoTipo()
															.getId()) == 0) {

										resumoFaturamentoSimulacaoDebito
												.setValor(resumoFaturamentoSimulacaoDebito
														.getValor()
														.add(valorPorTipoRegistroHelper
																.getValor()));
										encontrou = true;
										continue labelDebitos;
									}
								}
								if (!encontrou) {

									ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebitoInserir = new ResumoFaturamentoSimulacaoDebito();

									ResumoFaturamentoSimulacaoDebitoPK comp_id = new ResumoFaturamentoSimulacaoDebitoPK();

									resumoFaturamentoSimulacaoDebitoInserir
											.setComp_id(comp_id);

									resumoFaturamentoSimulacaoDebitoInserir
											.getComp_id().setDebitoTipo(
													valorPorTipoRegistroHelper
															.getDebitoTipo());
									resumoFaturamentoSimulacaoDebitoInserir
											.setValor(valorPorTipoRegistroHelper
													.getValor());

									colecaoDebitos
											.add(resumoFaturamentoSimulacaoDebitoInserir);
								}
							}
						}
					}
					// valor creditos
					if (valorTotalCreditos != null) {
						resumoFaturamentoSimulacaoNaColecao
								.setValorCreditos(resumoFaturamentoSimulacaoNaColecao
										.getValorCreditos().add(
												valorTotalCreditos));

						if (colecaoValoresPorTipoCredito != null
								&& !colecaoValoresPorTipoCredito.isEmpty()) {

							Collection<ResumoFaturamentoSimulacaoCredito> colecaoCreditos = resumoFaturamentoSimulacaoHelperNaColecao
									.getResumoFaturamentoSimulacaoCredito();

							labelCreditos: for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoCredito) {
								boolean encontrou = false;
								for (ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCredito : colecaoCreditos) {

									if (resumoFaturamentoSimulacaoCredito
											.getComp_id()
											.getCreditoTipo()
											.getId()
											.compareTo(
													valorPorTipoRegistroHelper
															.getCreditoTipo()
															.getId()) == 0) {

										resumoFaturamentoSimulacaoCredito
												.setValor(resumoFaturamentoSimulacaoCredito
														.getValor()
														.add(valorPorTipoRegistroHelper
																.getValor()));
										encontrou = true;
										continue labelCreditos;
									}
								}
								if (!encontrou) {

									ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCreditoInserir = new ResumoFaturamentoSimulacaoCredito();

									ResumoFaturamentoSimulacaoCreditoPK comp_id = new ResumoFaturamentoSimulacaoCreditoPK();

									resumoFaturamentoSimulacaoCreditoInserir
											.setComp_id(comp_id);

									resumoFaturamentoSimulacaoCreditoInserir
											.getComp_id().setCreditoTipo(
													valorPorTipoRegistroHelper
															.getCreditoTipo());
									resumoFaturamentoSimulacaoCreditoInserir
											.setValor(valorPorTipoRegistroHelper
													.getValor());

									colecaoCreditos
											.add(resumoFaturamentoSimulacaoCreditoInserir);
								}
							}
						}
					}
					// Valor de Impostos
					if (valorImpostos != null) {
						resumoFaturamentoSimulacaoNaColecao
								.setValorImposto(resumoFaturamentoSimulacaoNaColecao
										.getValorImposto().add(valorImpostos));

					}
				} else {
					ResumoFaturamentoSimulacao resumoFaturamentoSimulacao = criarObjetoResumoFaturamentoSimulacao(
							anoMesReferencia, faturamentoAtivCronRota, imovel,
							categoria, subCategoria,
							gerarAtiviadadeGrupoFaturamento,
							calcularValoresAguaEsgotoHelper
									.getValorFaturadoAguaCategoria(),
							calcularValoresAguaEsgotoHelper
									.getConsumoFaturadoAguaCategoria(),
							calcularValoresAguaEsgotoHelper
									.getValorFaturadoEsgotoCategoria(),
							calcularValoresAguaEsgotoHelper
									.getConsumoFaturadoEsgotoCategoria(),
							valorTotalDebitos, valorTotalCreditos,
							primeiraCategoria, preFaturar, valorImpostos);

					ResumoFaturamentoSimulacaoHelper helper = new ResumoFaturamentoSimulacaoHelper();

					helper.setResumoFaturamentoSimulacao(resumoFaturamentoSimulacao);

					Collection<ResumoFaturamentoSimulacaoDebito> colecaoDebitos = new ArrayList();
					if (colecaoValoresPorTipoDebito != null
							&& !colecaoValoresPorTipoDebito.isEmpty()) {
						for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoDebito) {

							ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebitoInserir = new ResumoFaturamentoSimulacaoDebito();

							ResumoFaturamentoSimulacaoDebitoPK comp_id = new ResumoFaturamentoSimulacaoDebitoPK();

							resumoFaturamentoSimulacaoDebitoInserir
									.setComp_id(comp_id);

							resumoFaturamentoSimulacaoDebitoInserir
									.getComp_id().setDebitoTipo(
											valorPorTipoRegistroHelper
													.getDebitoTipo());
							resumoFaturamentoSimulacaoDebitoInserir
									.setValor(valorPorTipoRegistroHelper
											.getValor());

							colecaoDebitos
									.add(resumoFaturamentoSimulacaoDebitoInserir);

						}
					}

					helper.setResumoFaturamentoSimulacaoDebito(colecaoDebitos);

					Collection<ResumoFaturamentoSimulacaoCredito> colecaoCreditos = new ArrayList();

					if (colecaoValoresPorTipoCredito != null
							&& !colecaoValoresPorTipoCredito.isEmpty()) {

						for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoCredito) {

							ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCreditoInserir = new ResumoFaturamentoSimulacaoCredito();

							ResumoFaturamentoSimulacaoCreditoPK comp_id = new ResumoFaturamentoSimulacaoCreditoPK();

							resumoFaturamentoSimulacaoCreditoInserir
									.setComp_id(comp_id);

							resumoFaturamentoSimulacaoCreditoInserir
									.getComp_id().setCreditoTipo(
											valorPorTipoRegistroHelper
													.getCreditoTipo());
							resumoFaturamentoSimulacaoCreditoInserir
									.setValor(valorPorTipoRegistroHelper
											.getValor());

							colecaoCreditos
									.add(resumoFaturamentoSimulacaoCreditoInserir);
						}
					}

					helper.setResumoFaturamentoSimulacaoCredito(colecaoCreditos);

					// adiciona
					colecaoResumoFaturamentoSimulacao.add(helper);

				}
				// se a coleção vazia
				// caso for a primeira vez e tenha os valores de agua e esgoto e
				// categoria, será adicionado um resumo faturamento
			} else {
				adcionar = true;
				ResumoFaturamentoSimulacao resumoFaturamentoSimulacao = criarObjetoResumoFaturamentoSimulacao(
						anoMesReferencia, faturamentoAtivCronRota, imovel,
						categoria, subCategoria,
						gerarAtiviadadeGrupoFaturamento,
						calcularValoresAguaEsgotoHelper
								.getValorFaturadoAguaCategoria(),
						calcularValoresAguaEsgotoHelper
								.getConsumoFaturadoAguaCategoria(),
						calcularValoresAguaEsgotoHelper
								.getValorFaturadoEsgotoCategoria(),
						calcularValoresAguaEsgotoHelper
								.getConsumoFaturadoEsgotoCategoria(),
						valorTotalDebitos, valorTotalCreditos,
						primeiraCategoria, preFaturar, valorImpostos);

				ResumoFaturamentoSimulacaoHelper helper = new ResumoFaturamentoSimulacaoHelper();

				helper.setResumoFaturamentoSimulacao(resumoFaturamentoSimulacao);

				Collection<ResumoFaturamentoSimulacaoDebito> colecaoDebitos = new ArrayList();
				if (colecaoValoresPorTipoDebito != null
						&& !colecaoValoresPorTipoDebito.isEmpty()) {
					for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoDebito) {

						ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebitoInserir = new ResumoFaturamentoSimulacaoDebito();

						ResumoFaturamentoSimulacaoDebitoPK comp_id = new ResumoFaturamentoSimulacaoDebitoPK();

						resumoFaturamentoSimulacaoDebitoInserir
								.setComp_id(comp_id);

						resumoFaturamentoSimulacaoDebitoInserir.getComp_id()
								.setDebitoTipo(
										valorPorTipoRegistroHelper
												.getDebitoTipo());
						resumoFaturamentoSimulacaoDebitoInserir
								.setValor(valorPorTipoRegistroHelper.getValor());

						colecaoDebitos
								.add(resumoFaturamentoSimulacaoDebitoInserir);

					}
				}

				helper.setResumoFaturamentoSimulacaoDebito(colecaoDebitos);

				Collection<ResumoFaturamentoSimulacaoCredito> colecaoCreditos = new ArrayList();

				if (colecaoValoresPorTipoCredito != null
						&& !colecaoValoresPorTipoCredito.isEmpty()) {

					for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoCredito) {

						ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCreditoInserir = new ResumoFaturamentoSimulacaoCredito();

						ResumoFaturamentoSimulacaoCreditoPK comp_id = new ResumoFaturamentoSimulacaoCreditoPK();

						resumoFaturamentoSimulacaoCreditoInserir
								.setComp_id(comp_id);

						resumoFaturamentoSimulacaoCreditoInserir.getComp_id()
								.setCreditoTipo(
										valorPorTipoRegistroHelper
												.getCreditoTipo());
						resumoFaturamentoSimulacaoCreditoInserir
								.setValor(valorPorTipoRegistroHelper.getValor());

						colecaoCreditos
								.add(resumoFaturamentoSimulacaoCreditoInserir);
					}
				}

				helper.setResumoFaturamentoSimulacaoCredito(colecaoCreditos);

				// adiciona
				colecaoResumoFaturamentoSimulacao.add(helper);
			}

			// se so tiver categoria e não tiver valores de agua e esgoto
		} else if (categoria != null) {

			boolean adcionar = true;
			// se existe dados na coleção
			if (!colecaoResumoFaturamentoSimulacao.isEmpty()) {

				Iterator iteratorColecaoResumoFaturamento = colecaoResumoFaturamentoSimulacao
						.iterator();
				boolean achou = true;
				while (iteratorColecaoResumoFaturamento.hasNext() && achou) {

					// resumo faturamento simulçao na coleção
					resumoFaturamentoSimulacaoHelperNaColecao = (ResumoFaturamentoSimulacaoHelper) iteratorColecaoResumoFaturamento
							.next();

					resumoFaturamentoSimulacaoNaColecao = resumoFaturamentoSimulacaoHelperNaColecao
							.getResumoFaturamentoSimulacao();

					if (resumoFaturamentoSimulacaoNaColecao
							.getAnoMesReferencia().intValue() == anoMesReferencia
							&& resumoFaturamentoSimulacaoNaColecao
									.getFaturamentoGrupo().getId().intValue() == faturamentoAtivCronRota
									.getRota().getFaturamentoGrupo().getId()
									.intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getLocalidade().getId().intValue() == imovel
									.getLocalidade().getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao.getQuadra()
									.getId().intValue() == imovel.getQuadra()
									.getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getLigacaoAguaSituacao().getId()
									.intValue() == imovel
									.getLigacaoAguaSituacao().getId()
									.intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getLigacaoEsgotoSituacao().getId()
									.intValue() == imovel
									.getLigacaoEsgotoSituacao().getId()
									.intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getCategoria().getId().intValue() == categoria
									.getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getImovelPerfil().getId().intValue() == imovel
									.getImovelPerfil().getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getIndicadorDebitoConta().shortValue() == imovel
									.getIndicadorDebitoConta().shortValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getGerenciaRegional().getId().intValue() == imovel
									.getLocalidade().getGerenciaRegional()
									.getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao
									.getSetorComercial().getId().intValue() == imovel
									.getSetorComercial().getId().intValue()
							&& resumoFaturamentoSimulacaoNaColecao.getRota()
									.getId().intValue() == imovel.getQuadra()
									.getRota().getId().intValue()) {
						EsferaPoder esferaPoder = null;

						if (imovel.getClienteImoveis() != null
								&& !imovel.getClienteImoveis().isEmpty()) {

							Cliente clienteImovel = (Cliente) imovel
									.getClienteImoveis().iterator().next();

							esferaPoder = clienteImovel.getClienteTipo()
									.getEsferaPoder();
						}

						if (resumoFaturamentoSimulacaoNaColecao
								.getEsferaPoder() != null
								&& esferaPoder != null) {

							if (resumoFaturamentoSimulacaoNaColecao
									.getEsferaPoder().getId().intValue() == esferaPoder
									.getId().intValue()) {

								if (primeiraCategoria) {
									// ATUALIZA A QUANTIDADE DE CONTAS ****
									resumoFaturamentoSimulacaoNaColecao
											.setQuantidadeContas(resumoFaturamentoSimulacaoNaColecao
													.getQuantidadeContas() + 1);
								}
								achou = false;
								adcionar = false;
							}
						}
						if (resumoFaturamentoSimulacaoNaColecao
								.getEsferaPoder() == null
								&& esferaPoder == null) {

							if (primeiraCategoria) {
								// ATUALIZA A QUANTIDADE DE CONTAS ****
								resumoFaturamentoSimulacaoNaColecao
										.setQuantidadeContas(resumoFaturamentoSimulacaoNaColecao
												.getQuantidadeContas() + 1);
							}
							achou = false;
							adcionar = false;
						}
					} else {
						// System.out.println("diferente");
					}
				}

				// verifica se é para acumular ou para inserir na coleção
				if (!adcionar) {

					int qtdEconomias = resumoFaturamentoSimulacaoNaColecao
							.getQuantidadeEconomia().intValue();

					if (subCategoria.getId().intValue() != Subcategoria.SUBCATEGORIA_ZERO
							.getId().intValue()) {
						qtdEconomias = qtdEconomias
								+ subCategoria.getQuantidadeEconomias()
										.intValue();
					} else {
						qtdEconomias = qtdEconomias
								+ categoria.getQuantidadeEconomiasCategoria()
										.intValue();
					}

					// caso necessário acumulado no faturamento simulação
					// if (indicePosicaoParaAcumular != -1) {
					// acumula os dados dos dados do resumo ja existente
					resumoFaturamentoSimulacaoNaColecao
							.setQuantidadeEconomia((short) qtdEconomias);

					// valor total debitos
					if (valorTotalDebitos != null) {
						resumoFaturamentoSimulacaoNaColecao
								.setValorDebitos(resumoFaturamentoSimulacaoNaColecao
										.getValorDebitos().add(
												valorTotalDebitos));

						if (colecaoValoresPorTipoDebito != null
								&& !colecaoValoresPorTipoDebito.isEmpty()) {

							Collection<ResumoFaturamentoSimulacaoDebito> colecaoDebitos = resumoFaturamentoSimulacaoHelperNaColecao
									.getResumoFaturamentoSimulacaoDebito();

							labelDebitos: for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoDebito) {
								boolean encontrou = false;
								for (ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebito : colecaoDebitos) {

									if (resumoFaturamentoSimulacaoDebito
											.getComp_id()
											.getDebitoTipo()
											.getId()
											.compareTo(
													valorPorTipoRegistroHelper
															.getDebitoTipo()
															.getId()) == 0) {

										resumoFaturamentoSimulacaoDebito
												.setValor(resumoFaturamentoSimulacaoDebito
														.getValor()
														.add(valorPorTipoRegistroHelper
																.getValor()));
										encontrou = true;
										continue labelDebitos;
									}
								}
								if (!encontrou) {

									ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebitoInserir = new ResumoFaturamentoSimulacaoDebito();

									ResumoFaturamentoSimulacaoDebitoPK comp_id = new ResumoFaturamentoSimulacaoDebitoPK();

									resumoFaturamentoSimulacaoDebitoInserir
											.setComp_id(comp_id);

									resumoFaturamentoSimulacaoDebitoInserir
											.getComp_id().setDebitoTipo(
													valorPorTipoRegistroHelper
															.getDebitoTipo());
									resumoFaturamentoSimulacaoDebitoInserir
											.setValor(valorPorTipoRegistroHelper
													.getValor());

									colecaoDebitos
											.add(resumoFaturamentoSimulacaoDebitoInserir);
								}
							}
						}
					}

					// valor total creditos
					if (valorTotalCreditos != null) {
						resumoFaturamentoSimulacaoNaColecao
								.setValorCreditos(resumoFaturamentoSimulacaoNaColecao
										.getValorCreditos().add(
												valorTotalCreditos));

						if (colecaoValoresPorTipoCredito != null
								&& !colecaoValoresPorTipoCredito.isEmpty()) {

							Collection<ResumoFaturamentoSimulacaoCredito> colecaoCreditos = resumoFaturamentoSimulacaoHelperNaColecao
									.getResumoFaturamentoSimulacaoCredito();

							labelCreditos: for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoCredito) {
								boolean encontrou = false;
								for (ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCredito : colecaoCreditos) {

									if (resumoFaturamentoSimulacaoCredito
											.getComp_id()
											.getCreditoTipo()
											.getId()
											.compareTo(
													valorPorTipoRegistroHelper
															.getCreditoTipo()
															.getId()) == 0) {

										resumoFaturamentoSimulacaoCredito
												.setValor(resumoFaturamentoSimulacaoCredito
														.getValor()
														.add(valorPorTipoRegistroHelper
																.getValor()));
										encontrou = true;
										continue labelCreditos;
									}
								}
								if (!encontrou) {

									ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCreditoInserir = new ResumoFaturamentoSimulacaoCredito();

									ResumoFaturamentoSimulacaoCreditoPK comp_id = new ResumoFaturamentoSimulacaoCreditoPK();

									resumoFaturamentoSimulacaoCreditoInserir
											.setComp_id(comp_id);

									resumoFaturamentoSimulacaoCreditoInserir
											.getComp_id().setCreditoTipo(
													valorPorTipoRegistroHelper
															.getCreditoTipo());
									resumoFaturamentoSimulacaoCreditoInserir
											.setValor(valorPorTipoRegistroHelper
													.getValor());

									colecaoCreditos
											.add(resumoFaturamentoSimulacaoCreditoInserir);
								}
							}
						}

					}

				} else {
					ResumoFaturamentoSimulacao resumoFaturamentoSimulacaoInserir = criarObjetoResumoFaturamentoSimulacao(
							anoMesReferencia, faturamentoAtivCronRota, imovel,
							categoria, subCategoria,
							gerarAtiviadadeGrupoFaturamento, new BigDecimal(0),
							new Integer(0), new BigDecimal(0), new Integer(0),
							valorTotalDebitos, valorTotalCreditos,
							primeiraCategoria, preFaturar, valorImpostos);

					ResumoFaturamentoSimulacaoHelper helper = new ResumoFaturamentoSimulacaoHelper();

					helper.setResumoFaturamentoSimulacao(resumoFaturamentoSimulacaoInserir);

					Collection<ResumoFaturamentoSimulacaoDebito> colecaoDebitos = new ArrayList();

					if (colecaoValoresPorTipoDebito != null
							&& !colecaoValoresPorTipoDebito.isEmpty()) {
						for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoDebito) {

							ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebitoInserir = new ResumoFaturamentoSimulacaoDebito();

							ResumoFaturamentoSimulacaoDebitoPK comp_id = new ResumoFaturamentoSimulacaoDebitoPK();

							resumoFaturamentoSimulacaoDebitoInserir
									.setComp_id(comp_id);

							resumoFaturamentoSimulacaoDebitoInserir
									.getComp_id().setDebitoTipo(
											valorPorTipoRegistroHelper
													.getDebitoTipo());
							resumoFaturamentoSimulacaoDebitoInserir
									.setValor(valorPorTipoRegistroHelper
											.getValor());

							colecaoDebitos
									.add(resumoFaturamentoSimulacaoDebitoInserir);

						}
					}

					helper.setResumoFaturamentoSimulacaoDebito(colecaoDebitos);

					Collection<ResumoFaturamentoSimulacaoCredito> colecaoCreditos = new ArrayList();

					if (colecaoValoresPorTipoCredito != null
							&& !colecaoValoresPorTipoCredito.isEmpty()) {

						for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoCredito) {

							ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCreditoInserir = new ResumoFaturamentoSimulacaoCredito();

							ResumoFaturamentoSimulacaoCreditoPK comp_id = new ResumoFaturamentoSimulacaoCreditoPK();

							resumoFaturamentoSimulacaoCreditoInserir
									.setComp_id(comp_id);

							resumoFaturamentoSimulacaoCreditoInserir
									.getComp_id().setCreditoTipo(
											valorPorTipoRegistroHelper
													.getCreditoTipo());
							resumoFaturamentoSimulacaoCreditoInserir
									.setValor(valorPorTipoRegistroHelper
											.getValor());

							colecaoCreditos
									.add(resumoFaturamentoSimulacaoCreditoInserir);
						}
					}

					helper.setResumoFaturamentoSimulacaoCredito(colecaoCreditos);

					// adiciona
					colecaoResumoFaturamentoSimulacao.add(helper);
				}

				// se não tiver dados o primeiro resumo tem os valores zerados
				// COLECAO VAZIA
			} else {// adiciona se não tiver dados na coleção

				adcionar = true;

				ResumoFaturamentoSimulacao resumoFaturamentoSimulacaoInserir = criarObjetoResumoFaturamentoSimulacao(
						anoMesReferencia, faturamentoAtivCronRota, imovel,
						categoria, subCategoria,
						gerarAtiviadadeGrupoFaturamento, new BigDecimal(0),
						new Integer(0), new BigDecimal(0), new Integer(0),
						valorTotalDebitos, valorTotalCreditos,
						primeiraCategoria, preFaturar, valorImpostos);

				ResumoFaturamentoSimulacaoHelper helper = new ResumoFaturamentoSimulacaoHelper();

				helper.setResumoFaturamentoSimulacao(resumoFaturamentoSimulacaoInserir);

				Collection<ResumoFaturamentoSimulacaoDebito> colecaoDebitos = new ArrayList();

				if (colecaoValoresPorTipoDebito != null
						&& !colecaoValoresPorTipoDebito.isEmpty()) {
					for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoDebito) {

						ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebitoInserir = new ResumoFaturamentoSimulacaoDebito();

						ResumoFaturamentoSimulacaoDebitoPK comp_id = new ResumoFaturamentoSimulacaoDebitoPK();

						resumoFaturamentoSimulacaoDebitoInserir
								.setComp_id(comp_id);

						resumoFaturamentoSimulacaoDebitoInserir.getComp_id()
								.setDebitoTipo(
										valorPorTipoRegistroHelper
												.getDebitoTipo());
						resumoFaturamentoSimulacaoDebitoInserir
								.setValor(valorPorTipoRegistroHelper.getValor());

						colecaoDebitos
								.add(resumoFaturamentoSimulacaoDebitoInserir);

					}
				}

				helper.setResumoFaturamentoSimulacaoDebito(colecaoDebitos);

				Collection<ResumoFaturamentoSimulacaoCredito> colecaoCreditos = new ArrayList();

				if (colecaoValoresPorTipoCredito != null
						&& !colecaoValoresPorTipoCredito.isEmpty()) {

					for (ValorPorTipoRegistroHelper valorPorTipoRegistroHelper : colecaoValoresPorTipoCredito) {

						ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCreditoInserir = new ResumoFaturamentoSimulacaoCredito();

						ResumoFaturamentoSimulacaoCreditoPK comp_id = new ResumoFaturamentoSimulacaoCreditoPK();

						resumoFaturamentoSimulacaoCreditoInserir
								.setComp_id(comp_id);

						resumoFaturamentoSimulacaoCreditoInserir.getComp_id()
								.setCreditoTipo(
										valorPorTipoRegistroHelper
												.getCreditoTipo());
						resumoFaturamentoSimulacaoCreditoInserir
								.setValor(valorPorTipoRegistroHelper.getValor());

						colecaoCreditos
								.add(resumoFaturamentoSimulacaoCreditoInserir);
					}
				}

				helper.setResumoFaturamentoSimulacaoCredito(colecaoCreditos);

				// adiciona
				colecaoResumoFaturamentoSimulacao.add(helper);
			}

		}
	}

	/**
	 * 
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * Cria um Objeto ResumoFaturamentoSimulacao com os valores passados
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 28/04/2006, 07/09/2006
	 * 
	 * @param anoMesReferencia
	 * @param faturamentoAtivCronRota
	 * @param imovel
	 * @param categoria
	 * @param gerarAtiviadadeGrupoFaturamento
	 * @param valorAgua
	 * @param consumoAgua
	 * @param valorEsgoto
	 * @param valorTotalDebitos
	 * @param valorTotalCreditos
	 * @param valorImpostos
	 * @return
	 */
	protected ResumoFaturamentoSimulacao criarObjetoResumoFaturamentoSimulacao(
			Integer anoMesReferencia,
			FaturamentoAtivCronRota faturamentoAtivCronRota, Imovel imovel,
			Categoria categoria, Subcategoria subCategoria,
			boolean gerarAtiviadadeGrupoFaturamento, BigDecimal valorAgua,
			Integer consumoAgua, BigDecimal valorEsgoto, Integer consumoEsgoto,
			BigDecimal valorTotalDebitos, BigDecimal valorTotalCreditos,
			boolean primeiraCategoria, boolean preFaturar,
			BigDecimal valorImpostos) {

		ResumoFaturamentoSimulacao resumoFaturamentoSimulacao = new ResumoFaturamentoSimulacao();

		resumoFaturamentoSimulacao.setAnoMesReferencia(anoMesReferencia);
		resumoFaturamentoSimulacao.setFaturamentoGrupo(faturamentoAtivCronRota
				.getRota().getFaturamentoGrupo());
		resumoFaturamentoSimulacao.setLocalidade(imovel.getLocalidade());
		resumoFaturamentoSimulacao.setQuadra(imovel.getQuadra());
		resumoFaturamentoSimulacao.setCodigoSetorComercial(imovel
				.getSetorComercial().getCodigo());
		resumoFaturamentoSimulacao.setNumeroQuadra(imovel.getQuadra()
				.getNumeroQuadra());
		resumoFaturamentoSimulacao.setLigacaoAguaSituacao(imovel
				.getLigacaoAguaSituacao());
		resumoFaturamentoSimulacao.setLigacaoEsgotoSituacao(imovel
				.getLigacaoEsgotoSituacao());
		resumoFaturamentoSimulacao.setCategoria(categoria);
		resumoFaturamentoSimulacao.setImovelPerfil(imovel.getImovelPerfil());
		resumoFaturamentoSimulacao.setIndicadorDebitoConta(imovel
				.getIndicadorDebitoConta());
		resumoFaturamentoSimulacao.setUnidadeNegocio(imovel.getLocalidade()
				.getUnidadeNegocio());

		if (primeiraCategoria) {
			resumoFaturamentoSimulacao.setQuantidadeContas(1);
		} else {
			resumoFaturamentoSimulacao.setQuantidadeContas(0);
		}

		resumoFaturamentoSimulacao.setGerenciaRegional(imovel.getLocalidade()
				.getGerenciaRegional());
		resumoFaturamentoSimulacao
				.setSetorComercial(imovel.getSetorComercial());

		resumoFaturamentoSimulacao.setRota(faturamentoAtivCronRota.getRota());

		resumoFaturamentoSimulacao.setUltimaAlteracao(new Date());

		// caso seja pre-faturamento, colocar o indicador de simulação igual a 3
		// no retorno do processamente de pre-faturamento, altera para o
		// indicador Real.
		if (!preFaturar) {
			if (gerarAtiviadadeGrupoFaturamento) {
				resumoFaturamentoSimulacao
						.setIndicadorSimulacao(new Integer(2));
			} else {
				resumoFaturamentoSimulacao
						.setIndicadorSimulacao(new Integer(1));
			}
		} else {
			resumoFaturamentoSimulacao.setIndicadorSimulacao(new Integer(3));
		}

		// esfera do poder
		if (imovel.getClienteImoveis() != null
				&& !imovel.getClienteImoveis().isEmpty()) {

			Cliente cliente = (Cliente) imovel.getClienteImoveis().iterator()
					.next();

			EsferaPoder esferaPoder = cliente.getClienteTipo().getEsferaPoder();
			resumoFaturamentoSimulacao.setEsferaPoder(esferaPoder);
		}

		resumoFaturamentoSimulacao.setSubCategoria(subCategoria);

		// Caso seja subcategoria zero pega a quantidade da categoria.
		if (subCategoria.getId().intValue() == Subcategoria.SUBCATEGORIA_ZERO
				.getId().intValue()) {
			resumoFaturamentoSimulacao.setQuantidadeEconomia(categoria
					.getQuantidadeEconomiasCategoria().shortValue());
		} else {
			resumoFaturamentoSimulacao.setQuantidadeEconomia(subCategoria
					.getQuantidadeEconomias().shortValue());
		}

		// valor agua
		if (valorAgua != null) {
			resumoFaturamentoSimulacao.setValorAgua(valorAgua);
		} else {
			resumoFaturamentoSimulacao.setValorAgua(new BigDecimal("0.00"));

		}
		// consumo agua
		if (consumoAgua != null) {
			resumoFaturamentoSimulacao.setConsumoAgua(consumoAgua);
		} else {
			resumoFaturamentoSimulacao.setConsumoAgua(new Integer("0"));
		}
		// valor esgoto
		if (valorEsgoto != null) {
			resumoFaturamentoSimulacao.setValorEsgoto(valorEsgoto);
		} else {
			resumoFaturamentoSimulacao.setValorEsgoto(new BigDecimal("0.00"));
		}
		// consumo esgoto
		if (consumoEsgoto != null) {
			resumoFaturamentoSimulacao.setConsumoEsgoto(consumoEsgoto);
		} else {
			resumoFaturamentoSimulacao.setConsumoEsgoto(new Integer("0"));

		}
		// valor total debitos
		if (valorTotalDebitos != null) {
			resumoFaturamentoSimulacao.setValorDebitos(valorTotalDebitos);
		} else {
			resumoFaturamentoSimulacao.setValorDebitos(new BigDecimal("0.00"));
		}
		// valor total creditos
		if (valorTotalCreditos != null) {
			resumoFaturamentoSimulacao.setValorCreditos(valorTotalCreditos);
		} else {
			resumoFaturamentoSimulacao.setValorCreditos(new BigDecimal("0.00"));
		}

		// valor total impostos
		if (valorImpostos != null) {
			resumoFaturamentoSimulacao.setValorImposto(valorImpostos);
		} else {
			resumoFaturamentoSimulacao.setValorImposto(new BigDecimal("0.00"));
		}

		return resumoFaturamentoSimulacao;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Verifica se o imóvel gera conta ou não.
	 * [SF0003] - Verificar Não Geração da Conta
	 */
	@SuppressWarnings("rawtypes")
	public boolean verificarNaoGeracaoConta(Imovel imovel,
			BigDecimal valorTotalAgua, BigDecimal valorTotalEsgoto,
			int anoMesFaturamentoGrupo, boolean isPreFaturamento)
			throws ControladorException {

		boolean retorno = true;
		boolean primeiraCondicaoNaoGerarConta = false;
		boolean segundaCondicaoNaoGerarConta = false;

		/*
		 *  Alteração para gerar a rota com imóveis ativos ou
		 * inativos com débitos
		 */
		// 1.1 Caso o valor total da água e o valor total do esgoto seja igual a
		// zero. Satisfaz a primeira condição.
		if ((valorTotalAgua.compareTo(ConstantesSistema.VALOR_ZERO) == 0 && valorTotalEsgoto
				.compareTo(ConstantesSistema.VALOR_ZERO) == 0)
				|| (valorTotalAgua.compareTo(ConstantesSistema.VALOR_ZERO) != 0
						&& valorTotalEsgoto
								.compareTo(ConstantesSistema.VALOR_ZERO) != 0
						&& !imovel.getLigacaoAguaSituacao().getId()
								.equals(LigacaoAguaSituacao.LIGADO)
						&& !imovel.getLigacaoEsgotoSituacao().getId()
								.equals(LigacaoEsgotoSituacao.LIGADO) && (isPreFaturamento && imovel
						.getImovelCondominio() == null))) {

			primeiraCondicaoNaoGerarConta = true;
		}

		Collection colecaoDebitosACobrar = null;
		Collection colecaoCreditosARealizar = null;

		/*
		 * Colocado por Raphael Rossiter em 20/03/2007
		 */
		colecaoDebitosACobrar = this.obterDebitoACobrarImovel(imovel.getId(),
				DebitoCreditoSituacao.NORMAL, anoMesFaturamentoGrupo);

		// 1.2.1 Caso não existam Debitos a Cobrar.
		if (colecaoDebitosACobrar == null || colecaoDebitosACobrar.isEmpty()) {
			segundaCondicaoNaoGerarConta = true;
		}
		/**
		 *
		 * 
		 * @author Adriana Muniz date: 28/06/2012
		 * 
		 *         Condição para não gerar conta para imóvel na situação
		 *         especial como o indicador de paralisação do faturamento igual
		 *         a 1
		 * */
		else if (imovel.getFaturamentoSituacaoTipo() != null
				&& imovel.getFaturamentoSituacaoTipo()
						.getIndicadorParalisacaoFaturamento()
						.equals(ConstantesSistema.SIM))
			segundaCondicaoNaoGerarConta = true;
		else {
			// 1.2.2 OU, Caso existam Debitos a Cobrar E existam Pagamentos
			boolean existeDebitoSemPagamento = false;
			Iterator iColecaoDebitosACobrar = colecaoDebitosACobrar.iterator();

			while (iColecaoDebitosACobrar.hasNext()
					&& !existeDebitoSemPagamento) {
				DebitoACobrar debitoACobrar = (DebitoACobrar) iColecaoDebitosACobrar
						.next();
				// Para cada DebitoACobrar verificamos de existe pagamento
				FiltroPagamento filtroPagamento = new FiltroPagamento();
				filtroPagamento
						.adicionarParametro(new ParametroSimples(
								FiltroPagamento.DEBITO_A_COBRAR, debitoACobrar
										.getId()));
				Collection colecaoPagamentos = getControladorUtil().pesquisar(
						filtroPagamento, Pagamento.class.getName());
				if (colecaoPagamentos == null || colecaoPagamentos.isEmpty()) {
					existeDebitoSemPagamento = true;
				}
			}
			/**************************************************************/
			if (!existeDebitoSemPagamento) {
				segundaCondicaoNaoGerarConta = true;
			} else {
				// 1.2.3 OU, Caso existam Debitos a Cobrar E NAO existam
				// Pagamentos
				try {
					SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
					colecaoCreditosARealizar = repositorioFaturamento.pesquisarCreditoARealizar(imovel.getId(),DebitoCreditoSituacao.NORMAL,anoMesFaturamentoGrupo, sistemaParametro);

				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				boolean achouDevolucao = false;
				if (colecaoCreditosARealizar != null
						&& !colecaoCreditosARealizar.isEmpty()) {
					Iterator iteratorColecaoCreditosARealizar = colecaoCreditosARealizar
							.iterator();
					CreditoARealizar creditoARealizar = null;

					while (iteratorColecaoCreditosARealizar.hasNext()) {
						Object[] arrayCreditosACobrar = (Object[]) iteratorColecaoCreditosARealizar
								.next();
						creditoARealizar = new CreditoARealizar();
						creditoARealizar
								.setId((Integer) arrayCreditosACobrar[0]);

						// Para cada CreditoARealizar verificamos se existe
						// Devolucao
						FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
						filtroDevolucao
								.adicionarParametro(new ParametroSimples(
										FiltroDevolucao.CREDITO_A_REALIZAR_ID,
										creditoARealizar.getId()));
						Collection colecaoDevolucao = getControladorUtil()
								.pesquisar(filtroDevolucao,
										Devolucao.class.getName());

						if (colecaoDevolucao != null
								&& !colecaoDevolucao.isEmpty()) {
							achouDevolucao = true;
						}
					}
				}

				// 1.2.3.1.1 Caso NAO existam Credito a Realizar OU
				// Caso exista Credito a Realizar e existam Devolucoes para os
				// Creditos a Realizar.
				if ((colecaoCreditosARealizar == null || colecaoCreditosARealizar
						.isEmpty()) || (achouDevolucao)) {
					Iterator iteratorColecaoDebitosACobrar = colecaoDebitosACobrar
							.iterator();
					DebitoACobrar debitoACobrar = null;
					DebitoTipo debitoTipo = null;
					// SubCondicao3
					segundaCondicaoNaoGerarConta = true;

					while (iteratorColecaoDebitosACobrar.hasNext()) {
						debitoACobrar = (DebitoACobrar) iteratorColecaoDebitosACobrar
								.next();

						try {
							debitoTipo = repositorioFaturamento
									.getDebitoTipo(debitoACobrar
											.getDebitoTipo().getId());
						} catch (ErroRepositorioException ex) {
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", ex);
						}

						// 1.2.3.1.1.1.1 Caso os Debitos a Cobrar sejam todos
						// correspondentes
						// a Tipo de Debito com o indicador de geracao de conta
						// igual a NAO.
						if (debitoTipo.getIndicadorGeracaoConta().shortValue() != 2) {
							segundaCondicaoNaoGerarConta = false;
						}
					}
				} else {
					segundaCondicaoNaoGerarConta = false;
				}
			}
		}

		if (colecaoDebitosACobrar != null) {
			colecaoDebitosACobrar.clear();
			colecaoDebitosACobrar = null;
		}

		if (colecaoCreditosARealizar != null) {
			colecaoCreditosARealizar.clear();
			colecaoCreditosARealizar = null;
		}

		/*
		 * Caso as duas condições sejam verdadeiras não gera a conta.
		 */
		if (primeiraCondicaoNaoGerarConta && segundaCondicaoNaoGerarConta) {
			retorno = false;
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * Inclui o movimento de débito automático no sistema.
	 * 
	 * [SB0008] - Gerar Movimento de Débito Automático
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 17/01/2006, 18/09/2006
	 * 
	 * @param imovel
	 * @param conta
	 * @param valorDebito
	 * @param faturamentoAtivCronRota
	 * @throws ControladorException
	 */
	public void gerarMovimentoDebitoAutomatico(Conta conta) throws ControladorException {

		DebitoAutomaticoMovimento debitoAutomaticoMovimento = new DebitoAutomaticoMovimento();

		debitoAutomaticoMovimento.setDataVencimento(conta
				.getDataVencimentoConta());
		Integer idDebitoAutomatico = null;
		try {
			DebitoAutomatico debitoAutomatico = new DebitoAutomatico();
			idDebitoAutomatico = repositorioFaturamento.obterDebitoAutomatico(conta.getImovel().getId());
			debitoAutomatico.setId(idDebitoAutomatico);
			debitoAutomaticoMovimento.setDebitoAutomatico(debitoAutomatico);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		debitoAutomaticoMovimento.setContaGeral(conta.getContaGeral());
		debitoAutomaticoMovimento.setDebitoAutomaticoRetornoCodigo(null);
		debitoAutomaticoMovimento.setFaturamentoGrupo(conta.getFaturamentoGrupo());
		debitoAutomaticoMovimento.setProcessamento(new Date());
		debitoAutomaticoMovimento.setEnvioBanco(null);
		debitoAutomaticoMovimento.setRetornoBanco(null);
		debitoAutomaticoMovimento.setUltimaAlteracao(new Date());
		debitoAutomaticoMovimento.setNumeroSequenciaArquivoEnviado(null);
		debitoAutomaticoMovimento.setNumeroSequenciaArquivoRecebido(null);

		try {
			this.repositorioFaturamento.inserirDebitoAutomaticoMovimento(debitoAutomaticoMovimento);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	public Date determinarVencimentoConta(Imovel imovel, FaturamentoAtivCronRota faturamentoAtivCronRota, SistemaParametro sistemaParametro,
			Integer anoMesFaturamento) throws ControladorException {

		Date dataVencimentoConta = null;

		Short diaVencimentoAlternativo = null;
		Short indicadorVencimentoMesSeguinte = ConstantesSistema.NAO;

		Cliente clienteResponsavel = null;
		Short ultimoDiaMes = null;

		int diaDataVencimentoRota = Util.getDiaMes(faturamentoAtivCronRota.getDataContaVencimento());
		int mesDataVencimentoRota = Util.getMes(faturamentoAtivCronRota.getDataContaVencimento());
		int anoDataVencimentoRota = Util.getAno(faturamentoAtivCronRota.getDataContaVencimento());
		
		if (imovel.getDiaVencimento() != null
				&& imovel.getDiaVencimento().intValue() != 0
				&& (imovel.getIndicadorEmissaoExtratoFaturamento() == null || imovel.getIndicadorEmissaoExtratoFaturamento().equals(ConstantesSistema.NAO))) {

			diaVencimentoAlternativo = imovel.getDiaVencimento();
			indicadorVencimentoMesSeguinte = imovel.getIndicadorVencimentoMesSeguinte();
		} else {
			try {
				clienteResponsavel = repositorioFaturamento.pesquisarClienteImovelGrupoFaturamento(imovel.getId(), ClienteRelacaoTipo.RESPONSAVEL);
			} catch (ErroRepositorioException ex) {
				throw new ControladorException("erro.sistema", ex);
			}

			if (clienteResponsavel != null) {
				if (clienteResponsavel.getDataVencimento() != null && clienteResponsavel.getDataVencimento().intValue() != 0) {
					diaVencimentoAlternativo = clienteResponsavel.getDataVencimento();
					indicadorVencimentoMesSeguinte = clienteResponsavel.getIndicadorVencimentoMesSeguinte();
				}
				else if (imovel.getIndicadorEmissaoExtratoFaturamento() != null && imovel.getIndicadorEmissaoExtratoFaturamento().equals(ConstantesSistema.SIM)) {
					diaVencimentoAlternativo = Short.valueOf(Util.obterUltimoDiaMes(mesDataVencimentoRota, anoDataVencimentoRota));
				}
			}
		}

		if (diaVencimentoAlternativo == null || diaVencimentoAlternativo.intValue() == 0) {
			dataVencimentoConta = faturamentoAtivCronRota.getDataContaVencimento();
		} else {
			if (indicadorVencimentoMesSeguinte.equals(ConstantesSistema.NAO)) {
				if (diaDataVencimentoRota <= diaVencimentoAlternativo.intValue()) {
					ultimoDiaMes = Short.valueOf(Util.obterUltimoDiaMes(mesDataVencimentoRota, anoDataVencimentoRota));


					if (diaVencimentoAlternativo.intValue() > ultimoDiaMes.intValue()) {
						diaVencimentoAlternativo = ultimoDiaMes;
					}

					dataVencimentoConta = Util.criarData(diaVencimentoAlternativo.intValue(), mesDataVencimentoRota, anoDataVencimentoRota);
				} else {
					diaVencimentoAlternativo = new Integer(diaDataVencimentoRota).shortValue();

					ultimoDiaMes = Short.valueOf(Util.obterUltimoDiaMes(mesDataVencimentoRota, anoDataVencimentoRota));

					if (diaVencimentoAlternativo.intValue() > ultimoDiaMes
							.intValue()) {
						diaVencimentoAlternativo = ultimoDiaMes;
					}


					Date dataVencimentoAlternativo = Util.criarData(diaVencimentoAlternativo.intValue(), mesDataVencimentoRota, anoDataVencimentoRota);
					Date dataAtualMaisDiasMinimoEmissao = Util
							.adicionarNumeroDiasDeUmaData(new Date(), sistemaParametro.getNumeroMinimoDiasEmissaoVencimento());

					if (dataVencimentoAlternativo.compareTo(dataAtualMaisDiasMinimoEmissao) <= 0) {
						Date dataVencimentoRotaMesSeguinte = Util.adcionarOuSubtrairMesesAData(faturamentoAtivCronRota.getDataContaVencimento(), 1, 0);

						ultimoDiaMes = Short.valueOf(Util.obterUltimoDiaMes(Util.getMes(dataVencimentoRotaMesSeguinte),
								Util.getAno(dataVencimentoRotaMesSeguinte)));

						if (diaVencimentoAlternativo.intValue() > ultimoDiaMes.intValue()) {
							diaVencimentoAlternativo = ultimoDiaMes;
						}

						dataVencimentoConta = Util.criarData(diaVencimentoAlternativo.intValue(), Util.getMes(dataVencimentoRotaMesSeguinte),
								Util.getAno(dataVencimentoRotaMesSeguinte));
					} else {
						dataVencimentoConta = dataVencimentoAlternativo;
					}
				}
			} else {

				Date dataVencimentoRotaMesSeguinte = Util.adcionarOuSubtrairMesesAData(faturamentoAtivCronRota.getDataContaVencimento(), 1, 0);

				ultimoDiaMes = Short.valueOf(Util.obterUltimoDiaMes(Util.getMes(dataVencimentoRotaMesSeguinte), Util.getAno(dataVencimentoRotaMesSeguinte)));

				if (diaVencimentoAlternativo.intValue() > ultimoDiaMes.intValue()) {
					diaVencimentoAlternativo = ultimoDiaMes;
				}

				dataVencimentoConta = Util.criarData(diaVencimentoAlternativo.intValue(), Util.getMes(dataVencimentoRotaMesSeguinte),
						Util.getAno(dataVencimentoRotaMesSeguinte));
			}
		}

		// ENTREGA CONTA VIA CORREIO
		if ((imovel.getImovelContaEnvio().getId().equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL) || imovel.getImovelContaEnvio().getId()
				.equals(ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL))
				&& diaVencimentoAlternativo == null && imovel.getIndicadorDebitoConta().equals(ConstantesSistema.NAO)) {

			dataVencimentoConta = Util.adicionarNumeroDiasDeUmaData(
					dataVencimentoConta,
					sistemaParametro.getNumeroDiasAdicionaisCorreios());
		}

		return dataVencimentoConta;
	}

	/**
	 * Inserir o Resumo Simulção Faturamento
	 * 
	 * @param colecaoResumoSimulacaoFaturamento
	 * @throws ControladorException
	 */
	public void inserirResumoSimulacaoFaturamento(
			Collection colecaoResumoSimulacaoFaturamento)
			throws ControladorException {
		Iterator iterator = colecaoResumoSimulacaoFaturamento.iterator();

		ResumoFaturamentoSimulacao resumoFaturamentoSimulacaoNaBase = null;

		while (iterator.hasNext()) {
			ResumoFaturamentoSimulacaoHelper resumoFaturamentoSimulacaoHelper = (ResumoFaturamentoSimulacaoHelper) iterator
					.next();

			ResumoFaturamentoSimulacao resumoFaturamentoSimulacao = resumoFaturamentoSimulacaoHelper
					.getResumoFaturamentoSimulacao();

			// pesquisar se ja existe um resumo faturamento simulação
			try {

				resumoFaturamentoSimulacaoNaBase = repositorioFaturamento
						.pesquisarResumoFaturamentoSimulacao(resumoFaturamentoSimulacao);

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			// se resumo faturamento simulaçao
			if (resumoFaturamentoSimulacaoNaBase != null) {

				// acumula
				// quantidade economia
				resumoFaturamentoSimulacaoNaBase
						.setQuantidadeEconomia(new Short(
								(short) (resumoFaturamentoSimulacaoNaBase
										.getQuantidadeEconomia().shortValue() + resumoFaturamentoSimulacao
										.getQuantidadeEconomia().shortValue())));
				// valor agua
				resumoFaturamentoSimulacaoNaBase
						.setValorAgua(resumoFaturamentoSimulacaoNaBase
								.getValorAgua().add(
										resumoFaturamentoSimulacao
												.getValorAgua()));
				// consumo agua
				resumoFaturamentoSimulacaoNaBase.setConsumoAgua(new Integer(
						resumoFaturamentoSimulacaoNaBase.getConsumoAgua()
								.intValue()
								+ resumoFaturamentoSimulacao.getConsumoAgua()
										.intValue()));
				// valor esgoto
				resumoFaturamentoSimulacaoNaBase
						.setValorEsgoto(resumoFaturamentoSimulacaoNaBase
								.getValorEsgoto().add(
										resumoFaturamentoSimulacao
												.getValorEsgoto()));

				// consumo esgoto
				resumoFaturamentoSimulacaoNaBase.setConsumoEsgoto(new Integer(
						resumoFaturamentoSimulacaoNaBase.getConsumoEsgoto()
								.intValue()
								+ resumoFaturamentoSimulacao.getConsumoEsgoto()
										.intValue()));
				// valor debitos
				resumoFaturamentoSimulacaoNaBase
						.setValorDebitos(resumoFaturamentoSimulacaoNaBase
								.getValorDebitos().add(
										resumoFaturamentoSimulacao
												.getValorDebitos()));
				// valor creditos
				resumoFaturamentoSimulacaoNaBase
						.setValorCreditos(resumoFaturamentoSimulacaoNaBase
								.getValorCreditos().add(
										resumoFaturamentoSimulacao
												.getValorCreditos()));

				// qtd conta
				resumoFaturamentoSimulacaoNaBase
						.setQuantidadeContas(resumoFaturamentoSimulacaoNaBase
								.getQuantidadeContas().intValue()
								+ resumoFaturamentoSimulacao
										.getQuantidadeContas().intValue());

				// atualizar resumo faturamento
				this.getControladorUtil().atualizar(
						resumoFaturamentoSimulacaoNaBase);

				try {
					Collection<ResumoFaturamentoSimulacaoDebito> colecaoDebitosNaBase = this.repositorioFaturamento
							.pesquisarResumoFaturamentoDebitoSimulacao(resumoFaturamentoSimulacaoNaBase);

					Collection<ResumoFaturamentoSimulacaoDebito> colecaoDebitos = resumoFaturamentoSimulacaoHelper
							.getResumoFaturamentoSimulacaoDebito();

					labelDebito: for (ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebito : colecaoDebitos) {
						boolean encontrou = false;
						for (ResumoFaturamentoSimulacaoDebito resumoFaturamentoSimulacaoDebitoNaBase : colecaoDebitosNaBase) {

							if (resumoFaturamentoSimulacaoDebitoNaBase
									.getComp_id()
									.getDebitoTipo()
									.getId()
									.compareTo(
											resumoFaturamentoSimulacaoDebito
													.getComp_id()
													.getDebitoTipo().getId()) == 0) {

								resumoFaturamentoSimulacaoDebitoNaBase
										.setValor(resumoFaturamentoSimulacaoDebitoNaBase
												.getValor().add(
														resumoFaturamentoSimulacaoDebito
																.getValor()));

								this.getControladorUtil().atualizar(
										resumoFaturamentoSimulacaoDebitoNaBase);

								encontrou = true;
								continue labelDebito;
							}
						}
						if (!encontrou) {
							resumoFaturamentoSimulacaoDebito.getComp_id()
									.setResumoFaturamentoSimulacao(
											resumoFaturamentoSimulacaoNaBase);

							resumoFaturamentoSimulacaoDebito
									.setUltimaAlteracao(new Date());

							this.getControladorUtil().inserir(
									resumoFaturamentoSimulacaoDebito);
						}
					}

					Collection<ResumoFaturamentoSimulacaoCredito> colecaoCreditosNaBase = this.repositorioFaturamento
							.pesquisarResumoFaturamentoCreditoSimulacao(resumoFaturamentoSimulacaoNaBase);

					Collection<ResumoFaturamentoSimulacaoCredito> colecaoCreditos = resumoFaturamentoSimulacaoHelper
							.getResumoFaturamentoSimulacaoCredito();

					labelCredito: for (ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCredito : colecaoCreditos) {
						boolean encontrou = false;
						for (ResumoFaturamentoSimulacaoCredito resumoFaturamentoSimulacaoCreditoNaBase : colecaoCreditosNaBase) {

							if (resumoFaturamentoSimulacaoCreditoNaBase
									.getComp_id()
									.getCreditoTipo()
									.getId()
									.compareTo(
											resumoFaturamentoSimulacaoCredito
													.getComp_id()
													.getCreditoTipo().getId()) == 0) {

								resumoFaturamentoSimulacaoCreditoNaBase
										.setValor(resumoFaturamentoSimulacaoCreditoNaBase
												.getValor().add(
														resumoFaturamentoSimulacaoCredito
																.getValor()));

								this.getControladorUtil()
										.atualizar(
												resumoFaturamentoSimulacaoCreditoNaBase);

								encontrou = true;
								continue labelCredito;
							}
						}

						if (!encontrou) {
							resumoFaturamentoSimulacaoCredito.getComp_id()
									.setResumoFaturamentoSimulacao(
											resumoFaturamentoSimulacaoNaBase);

							resumoFaturamentoSimulacaoCredito
									.setUltimaAlteracao(new Date());

							this.getControladorUtil().inserir(
									resumoFaturamentoSimulacaoCredito);
						}

					}
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
					throw new ControladorException("erro.sistema", e);
				}
			} else {
				Integer idResumoFaturamentoSimulacao = (Integer) this
						.getControladorUtil().inserir(
								resumoFaturamentoSimulacao);

				resumoFaturamentoSimulacao.setId(idResumoFaturamentoSimulacao);

				for (ResumoFaturamentoSimulacaoDebito helperDebito : resumoFaturamentoSimulacaoHelper
						.getResumoFaturamentoSimulacaoDebito()) {

					helperDebito.getComp_id().setResumoFaturamentoSimulacao(
							resumoFaturamentoSimulacao);

					helperDebito.setUltimaAlteracao(new Date());

					this.getControladorUtil().inserir(helperDebito);

				}

				for (ResumoFaturamentoSimulacaoCredito helperCredito : resumoFaturamentoSimulacaoHelper
						.getResumoFaturamentoSimulacaoCredito()) {

					helperCredito.getComp_id().setResumoFaturamentoSimulacao(
							resumoFaturamentoSimulacao);

					helperCredito.setUltimaAlteracao(new Date());

					this.getControladorUtil().inserir(helperCredito);

				}

			}

		}

	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * @author Raphael Rossiter
	 * @date 28/05/2008
	 * 
	 * @param anoMesReferencia
	 * @param ligacaoSituacaoAguaId
	 * @param ligacaoSituacaoEsgotoId
	 * @param indicadorFaturamentoAgua
	 * @param indicadorFaturamentoEsgoto
	 * @param categoriasImovel
	 * @param consumoFaturadoAguaMes
	 * @param consumoFaturadoEsgotoMes
	 * @param consumoMinimoLigacao
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @param percentualEsgoto
	 * @param tarifaImovel
	 * @return Collection<CalcularValoresAguaEsgotoHelper>
	 * @throws ControladorException
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgoto(
			Integer anoMesReferencia, Integer ligacaoSituacaoAguaId,
			Integer ligacaoSituacaoEsgotoId, Short indicadorFaturamentoAgua,
			Short indicadorFaturamentoEsgoto,
			Collection categoriasOuSubcategoriasImovel,
			Integer consumoFaturadoAguaMes, Integer consumoFaturadoEsgotoMes,
			int consumoMinimoLigacao, Date dataLeituraAnterior,
			Date dataLeituraAtual, BigDecimal percentualEsgoto,
			Integer tarifaImovel, ConsumoTipo consumoTipoAgua,
			ConsumoTipo consumoTipoEsgoto) throws ControladorException {

		FiltroConsumoTarifa filtroConsumoTarifa = new FiltroConsumoTarifa();
		filtroConsumoTarifa.adicionarParametro(new ParametroSimples(
				FiltroConsumoTarifa.ID, tarifaImovel));

		Collection colecaoConsumoTarifa = getControladorUtil().pesquisar(
				filtroConsumoTarifa, ConsumoTarifa.class.getName());

		ConsumoTarifa consumoTarifa = (ConsumoTarifa) Util
				.retonarObjetoDeColecao(colecaoConsumoTarifa);

		// SELECIONANDO as tarifas vigentes para a tarifa do imóvel
		Collection colecaoConsumoTarifaVigenciaTodasDatas = this
				.obterConsumoTarifaVigencia(consumoTarifa, anoMesReferencia,
						dataLeituraAnterior, dataLeituraAtual);

		/*
		 * Alterado por Raphael Rossiter em 28/05/2008 OBJ: Calcular os consumos
		 * de água e esgoto a partir do INDICADOR_FATURAMENTO_SITUACAO que se
		 * encontra na situação da ligação de água e esgoto.
		 */
		// Carregando as informações da situação da ligação de água
		// ------------------------------------------------------------------------------------------
		FiltroLigacaoAguaSituacao filtroLigacaoAguaSituacao = new FiltroLigacaoAguaSituacao();

		filtroLigacaoAguaSituacao.adicionarParametro(new ParametroSimples(
				FiltroLigacaoAguaSituacao.ID, ligacaoSituacaoAguaId));

		Collection colecaoLigacaoAguaSituacao = this.getControladorUtil()
				.pesquisar(filtroLigacaoAguaSituacao,
						LigacaoAguaSituacao.class.getName());

		LigacaoAguaSituacao ligacaoAguaSituacao = (LigacaoAguaSituacao) Util
				.retonarObjetoDeColecao(colecaoLigacaoAguaSituacao);

		// Carregando as informações da situação da ligação de esgoto
		// ------------------------------------------------------------------------------------------
		LigacaoEsgotoSituacao ligacaoEsgotoSituacao = null;

		if (ligacaoSituacaoEsgotoId != null) {
			FiltroLigacaoEsgotoSituacao filtroLigacaoEsgotoSituacao = new FiltroLigacaoEsgotoSituacao();

			filtroLigacaoEsgotoSituacao
					.adicionarParametro(new ParametroSimples(
							FiltroLigacaoEsgotoSituacao.ID,
							ligacaoSituacaoEsgotoId));

			Collection colecaoLigacaoEsgotoSituacao = this.getControladorUtil()
					.pesquisar(filtroLigacaoEsgotoSituacao,
							LigacaoEsgotoSituacao.class.getName());

			ligacaoEsgotoSituacao = (LigacaoEsgotoSituacao) Util
					.retonarObjetoDeColecao(colecaoLigacaoEsgotoSituacao);
		}

		/*
		 * Caso o INDICADOR_FATURAMENTO_SITUACAO que se encontra na situação da
		 * LIGAÇÃO DE ÁGUA estaja ATIVO e seja indicado que é para faturar água
		 */
		Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresAgua = null;

		if (this.permiteFaturamentoParaAgua(ligacaoAguaSituacao,
				consumoFaturadoAguaMes, consumoTipoAgua)
				&& indicadorFaturamentoAgua
						.equals(ConsumoHistorico.FATURAR_AGUA)) {

			if (colecaoConsumoTarifaVigenciaTodasDatas == null
					|| colecaoConsumoTarifaVigenciaTodasDatas.isEmpty()) {
				// A lista com as tarifas vigentes está nula ou vazia

				System.out
						.println(" %%% ERRO.calcularValoresAguaEsgoto.SemTarifaVigencia: "
								+ "Tarifa: "
								+ tarifaImovel
								+ ", DataAnterior: "
								+ dataLeituraAnterior
								+ ", DataAtual: " + dataLeituraAtual);

				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.nao_cadastrada_data_vigencia");

			} else if (colecaoConsumoTarifaVigenciaTodasDatas.size() == 1) {

				// [SF0001 - Cálculo Simples Para Uma Única Tarifa]
				ConsumoTarifaVigencia consumoTarifaVigencia = (ConsumoTarifaVigencia) Util
						.retonarObjetoDeColecao(colecaoConsumoTarifaVigenciaTodasDatas);

				if (consumoTarifaVigencia.getDataVigencia() != null) {

					if (consumoTarifa.getTarifaTipoCalculo().getId().intValue() == 4) {
						colecaoValoresAgua = calculoConsumoDiretoNaFaixa(
								consumoFaturadoAguaMes,
								categoriasOuSubcategoriasImovel,
								percentualEsgoto, consumoTarifaVigencia,
								ConstantesSistema.CALCULAR_AGUA, consumoTarifa
										.getTarifaTipoCalculo().getId());
					} else {
						colecaoValoresAgua = calculoSimplesUmaTarifa(
								consumoFaturadoAguaMes,
								categoriasOuSubcategoriasImovel,
								percentualEsgoto, consumoTarifaVigencia,
								ConstantesSistema.CALCULAR_AGUA, consumoTarifa
										.getTarifaTipoCalculo().getId());
					}
				} else {
					// A data de vigência da tarifa está nula

					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.nao_cadastrada_data_vigencia");
				}

			} else {

				// [SF0002 - Cálculo Proporcional Para Mais de Uma Tarifa]
				colecaoValoresAgua = calculoProporcionalMaisDeUmaTarifa(
						dataLeituraAtual, dataLeituraAnterior,
						colecaoConsumoTarifaVigenciaTodasDatas,
						consumoFaturadoAguaMes,
						categoriasOuSubcategoriasImovel, percentualEsgoto,
						ConstantesSistema.CALCULAR_AGUA, consumoTarifa
								.getTarifaTipoCalculo().getId());
			}
		}

		/*
		 * Caso o INDICADOR_FATURAMENTO_SITUACAO que se encontra na situação da
		 * LIGAÇÃO DE ESGOTO estaja ATIVO e seja indicado que é para faturar
		 * esgoto
		 */
		Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresEsgoto = null;

		if (this.permiteFaturamentoParaEsgoto(ligacaoEsgotoSituacao,
				consumoFaturadoEsgotoMes, consumoTipoEsgoto)
				&& indicadorFaturamentoEsgoto
						.equals(ConsumoHistorico.FATURAR_ESGOTO)) {

			if (colecaoConsumoTarifaVigenciaTodasDatas == null
					|| colecaoConsumoTarifaVigenciaTodasDatas.isEmpty()) {
				// A lista com as tarifas vigentes está nula ou vazia

				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.nao_cadastrada_data_vigencia");

			} else if (colecaoConsumoTarifaVigenciaTodasDatas.size() == 1) {

				// [SF0001 - Cálculo Simples Para Uma Única Tarifa]
				ConsumoTarifaVigencia consumoTarifaVigencia = (ConsumoTarifaVigencia) Util
						.retonarObjetoDeColecao(colecaoConsumoTarifaVigenciaTodasDatas);

				if (consumoTarifaVigencia.getDataVigencia() != null) {

					if (consumoTarifa.getTarifaTipoCalculo().getId().intValue() == 4) {
						colecaoValoresEsgoto = calculoConsumoDiretoNaFaixa(
								consumoFaturadoEsgotoMes,
								categoriasOuSubcategoriasImovel,
								percentualEsgoto, consumoTarifaVigencia,
								ConstantesSistema.CALCULAR_ESGOTO,
								consumoTarifa.getTarifaTipoCalculo().getId());
					} else {
						colecaoValoresEsgoto = calculoSimplesUmaTarifa(
								consumoFaturadoEsgotoMes,
								categoriasOuSubcategoriasImovel,
								percentualEsgoto, consumoTarifaVigencia,
								ConstantesSistema.CALCULAR_ESGOTO,
								consumoTarifa.getTarifaTipoCalculo().getId());
					}
				} else {
					// A data de vigência da tarifa está nula

					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.nao_cadastrada_data_vigencia");
				}

			} else {

				// [SF0002 - Cálculo Proporcional Para Mais de Uma Tarifa]
				colecaoValoresEsgoto = calculoProporcionalMaisDeUmaTarifa(
						dataLeituraAtual, dataLeituraAnterior,
						colecaoConsumoTarifaVigenciaTodasDatas,
						consumoFaturadoEsgotoMes,
						categoriasOuSubcategoriasImovel, percentualEsgoto,
						ConstantesSistema.CALCULAR_ESGOTO, consumoTarifa
								.getTarifaTipoCalculo().getId());
			}
		}

		// Unificando os valores de água e esgoto em apenas uma coleção
		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = this
				.unificarValoresAguaEsgoto(colecaoValoresAgua,
						colecaoValoresEsgoto);

		return calcularValoresAguaEsgotoTotalizando(colecaoRetorno);
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * Selecionar as tarifas vigentes para o imóvel
	 * 
	 * @author Raphael Rossiter
	 * @date 28/05/2008
	 * 
	 * @param tarifaImovel
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @param anoMesReferencia
	 * @return Collection
	 * @throws ControladorException
	 */
	@SuppressWarnings("rawtypes")
	protected Collection obterConsumoTarifaVigenciaCalcularAguaEsgotoPorMesAno(
			Integer tarifaImovel, Date dataLeituraAnterior,
			Date dataLeituraAtual, Integer anoMesReferencia)
			throws ControladorException {

		Collection colecaoConsumoTarifaVigenciaTodasDatas = new ArrayList();

		if (tarifaImovel != null) {

			/*
			 * Alterado por Raphael Rossiter em 28/03/2008 - Analista: Eduardo
			 * Borges Utilizar a tarifa mais atual que tenha a data de vigência
			 * menor ou igual a data de faturamento.
			 */
			Date dataFaturamento = Util.criarData(1,
					Util.obterMes(anoMesReferencia),
					Util.obterAno(anoMesReferencia));

			ConsumoTarifaVigencia consumoTarifaVigencia = this
					.pesquisarConsumoTarifaVigenciaMenorOUIgualDataFaturamento(
							tarifaImovel, dataFaturamento);

			if (consumoTarifaVigencia == null) {

				try {
					sessionContext.setRollbackOnly();
				} catch (IllegalStateException e) {
					// Nesse caso o metodo não esta usando transação
					// Por isso ele não consegue da roll back
				}

				throw new ControladorException(
						"atencao.nao_cadastrada_data_vigencia");

			}

			colecaoConsumoTarifaVigenciaTodasDatas.add(consumoTarifaVigencia);
		}

		return colecaoConsumoTarifaVigenciaTodasDatas;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * Selecionar as tarifas vigentes para o imóvel
	 * 
	 * @author Raphael Rossiter
	 * @date 28/05/2008
	 * 
	 * @param tarifaImovel
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @param anoMesReferencia
	 * @return Collection
	 * @throws ControladorException
	 */
	private Collection obterConsumoTarifaVigenciaCalcularAguaEsgotoProporcionalPorData(
			Integer tarifaImovel, Date dataLeituraAnterior,
			Date dataLeituraAtual, Integer anoMesReferencia)
			throws ControladorException {

		Collection colecaoConsumoTarifaVigenciaTodasDatas = new ArrayList();

		if (tarifaImovel != null && dataLeituraAnterior != null
				&& dataLeituraAtual != null) {

			/*
			 * Seleciona todas as ocorrências da tabela CONSUMO_TARIFA_VIGENCIA
			 * com CSTF_ID=Id da tarifa para o imóvel e com CSTV_DTVIGENCIA
			 * entre as datas de leitura anterior e atual
			 */
			Collection colecaoConsumoTarifaVigenciaEntreDatas = selecionaTarifasVigentesPeriodoLeituraImovel(
					tarifaImovel, dataLeituraAnterior, dataLeituraAtual, true);

			/*
			 * Caso não seja selecionada nenhuma ocorrência ou caso nenhuma
			 * ocorrência selecionada tenha CSTV_DTVIGENCIA = data de leitura
			 * anterior, selecionar também a ocorrência da tabela
			 * CONSUMO_TARIFA_VIGENCIA com CSTF_ID= Id da tarifa para o imóvel e
			 * com a maior CSTV_DTVIGENCIA que seja menor que a data de leitura
			 * anterior.
			 */
			if (colecaoConsumoTarifaVigenciaEntreDatas == null
					|| colecaoConsumoTarifaVigenciaEntreDatas.isEmpty()) {

				Collection colecaoConsumoTarifaVigenciaMaiorData = selecionaTarifasVigentesPeriodoLeituraImovel(
						tarifaImovel, dataLeituraAnterior, dataLeituraAtual,
						false);

				colecaoConsumoTarifaVigenciaTodasDatas
						.addAll(colecaoConsumoTarifaVigenciaMaiorData);

			} else {

				ConsumoTarifaVigencia consumoTarifaVigencia = null;

				Iterator itConsumoTarifaVigencia = colecaoConsumoTarifaVigenciaEntreDatas
						.iterator();

				boolean flagBuscarOcorrencia = true;

				while (itConsumoTarifaVigencia.hasNext()) {

					consumoTarifaVigencia = (ConsumoTarifaVigencia) itConsumoTarifaVigencia
							.next();

					/*
					 * Verifica se já existe alguma ocorrência onde a
					 * dataVigencia é igual a dataLeituraAnterior
					 */
					if (consumoTarifaVigencia.getDataVigencia() != null
							&& Util.datasIguais(
									consumoTarifaVigencia.getDataVigencia(),
									dataLeituraAnterior)) {

						flagBuscarOcorrencia = false;
						break;
					}
				}

				colecaoConsumoTarifaVigenciaTodasDatas
						.addAll(colecaoConsumoTarifaVigenciaEntreDatas);

				if (flagBuscarOcorrencia) {

					Collection colecaoConsumoTarifaVigenciaMaiorData = selecionaTarifasVigentesPeriodoLeituraImovel(
							tarifaImovel, dataLeituraAnterior,
							dataLeituraAtual, false);

					/*
					 * As tarifas vigentes para o período de leitura serão as
					 * ocorrências selecionadas nas coleções parcial e final
					 */
					colecaoConsumoTarifaVigenciaTodasDatas
							.addAll(colecaoConsumoTarifaVigenciaMaiorData);

					// Organizar a coleção
					Collections.sort(
							(List) colecaoConsumoTarifaVigenciaTodasDatas,
							new Comparator() {
								public int compare(Object a, Object b) {
									Date dataVigencia1 = ((ConsumoTarifaVigencia) a)
											.getDataVigencia();
									Date dataVigencia2 = ((ConsumoTarifaVigencia) b)
											.getDataVigencia();

									return dataVigencia1
											.compareTo(dataVigencia2);

								}
							});
				}
			}
		}

		return colecaoConsumoTarifaVigenciaTodasDatas;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * Unificando os valores de água e esgoto em apenas uma coleção
	 * 
	 * @author Raphael Rossiter
	 * @date 28/05/2008
	 * 
	 * @param colecaoValoresAgua
	 * @param colecaoValoresEsgoto
	 * @return Collection<CalcularValoresAguaEsgotoHelper>
	 * @throws ControladorException
	 */
	private Collection<CalcularValoresAguaEsgotoHelper> unificarValoresAguaEsgoto(
			Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresAgua,
			Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresEsgoto)
			throws ControladorException {

		// Unificando os valores de água e esgoto em apenas uma coleção
		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		// O calculo foi realizado apenas para água
		if ((colecaoValoresAgua != null && !colecaoValoresAgua.isEmpty())
				&& (colecaoValoresEsgoto == null || colecaoValoresEsgoto
						.isEmpty())) {

			colecaoRetorno.addAll(colecaoValoresAgua);
		}
		// O calculo foi realizado apenas para esgoto
		else if ((colecaoValoresEsgoto != null && !colecaoValoresEsgoto
				.isEmpty())
				&& (colecaoValoresAgua == null || colecaoValoresAgua.isEmpty())) {

			colecaoRetorno.addAll(colecaoValoresEsgoto);
		}
		// O calculo foi realizado para ambos
		else if ((colecaoValoresEsgoto != null && !colecaoValoresEsgoto
				.isEmpty())
				&& (colecaoValoresAgua != null && !colecaoValoresAgua.isEmpty())) {

			Iterator colecaoValoresAguaIt = colecaoValoresAgua.iterator();
			Iterator colecaoValoresEsgotoIt;
			Iterator colecaoValoresAguaFaixaIt;
			Iterator colecaoValoresEsgotoFaixaIt;

			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelperAgua, calcularValoresAguaEsgotoHelperEsgoto;
			CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelperAgua, calcularValoresAguaEsgotoFaixaHelperEsgoto;

			int esgotoParada = 0;

			while (colecaoValoresAguaIt.hasNext()) {

				calcularValoresAguaEsgotoHelperAgua = (CalcularValoresAguaEsgotoHelper) colecaoValoresAguaIt
						.next();

				colecaoValoresEsgotoIt = colecaoValoresEsgoto.iterator();

				int contadorEsgoto = 0;

				while (colecaoValoresEsgotoIt.hasNext()) {

					calcularValoresAguaEsgotoHelperEsgoto = (CalcularValoresAguaEsgotoHelper) colecaoValoresEsgotoIt
							.next();

					// Carregando os valores de esgoto na coleção que contém
					// os valores calculados de água
					if (calcularValoresAguaEsgotoHelperAgua.getIdCategoria()
							.equals(calcularValoresAguaEsgotoHelperEsgoto
									.getIdCategoria())
							&& esgotoParada == contadorEsgoto) {

						// Carregando o valor faturado de esgoto na coleção
						// de água
						calcularValoresAguaEsgotoHelperAgua
								.setValorFaturadoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
										.getValorFaturadoEsgotoCategoria());

						// Carregando o consumo faturado de esgoto na
						// coleção de água
						calcularValoresAguaEsgotoHelperAgua
								.setConsumoFaturadoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
										.getConsumoFaturadoEsgotoCategoria());

						// Carregando o valor da tarifa mínima de esgoto na
						// coleção de água
						calcularValoresAguaEsgotoHelperAgua
								.setValorTarifaMinimaEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
										.getValorTarifaMinimaEsgotoCategoria());

						// Carregando o consumo mínimo de esgoto na coleção
						// de água
						calcularValoresAguaEsgotoHelperAgua
								.setConsumoMinimoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
										.getConsumoMinimoEsgotoCategoria());

						// -------------------------------------------------------------------------------
						// Carregando os valores calculados de esgoto para
						// cada faixa da tarifa de consumo
						// -------------------------------------------------------------------------------

						colecaoValoresAguaFaixaIt = calcularValoresAguaEsgotoHelperAgua
								.getFaixaTarifaConsumo().iterator();

						int faixaParada = 0;

						while (colecaoValoresAguaFaixaIt.hasNext()) {

							calcularValoresAguaEsgotoFaixaHelperAgua = (CalcularValoresAguaEsgotoFaixaHelper) colecaoValoresAguaFaixaIt
									.next();

							colecaoValoresEsgotoFaixaIt = calcularValoresAguaEsgotoHelperEsgoto
									.getFaixaTarifaConsumo().iterator();

							int contadorFaixa = 0;

							while (colecaoValoresEsgotoFaixaIt.hasNext()) {

								calcularValoresAguaEsgotoFaixaHelperEsgoto = (CalcularValoresAguaEsgotoFaixaHelper) colecaoValoresEsgotoFaixaIt
										.next();

								if (calcularValoresAguaEsgotoFaixaHelperAgua
										.getIdConsumoTarifaFaixa()
										.equals(calcularValoresAguaEsgotoFaixaHelperEsgoto
												.getIdConsumoTarifaFaixa())
										&& faixaParada == contadorFaixa) {

									// Carregando o valor faturado de esgoto
									// na faixa para coleção de água
									calcularValoresAguaEsgotoFaixaHelperAgua
											.setValorFaturadoEsgotoFaixa(calcularValoresAguaEsgotoFaixaHelperEsgoto
													.getValorFaturadoEsgotoFaixa());

									// Carregando o consumo faturado de
									// esgoto na faixa para coleção de água
									calcularValoresAguaEsgotoFaixaHelperAgua
											.setConsumoFaturadoEsgotoFaixa(calcularValoresAguaEsgotoFaixaHelperEsgoto
													.getConsumoFaturadoEsgotoFaixa());

									contadorFaixa++;
									faixaParada = contadorFaixa;
									break;
								}

								contadorFaixa++;
							}
						}

						contadorEsgoto++;
						esgotoParada = contadorEsgoto;
						break;
					}

					contadorEsgoto++;
				}

				colecaoRetorno.add(calcularValoresAguaEsgotoHelperAgua);
			}
		}

		return colecaoRetorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * Totalizando os valores de água e esgoto por categoria ou subcategoria
	 * 
	 * @author Raphael Rossiter
	 * @date 28/05/2008
	 * 
	 * @param colecaoCalcularValoresAguaEsgotoHelper
	 * @return Collection<CalcularValoresAguaEsgotoHelper>
	 * @throws ControladorException
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgotoTotalizando(
			Collection colecaoCalcularValoresAguaEsgotoHelper)
			throws ControladorException {

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		Iterator colecaoCalcularValoresAguaEsgotoHelperIt = colecaoCalcularValoresAguaEsgotoHelper
				.iterator();
		CalcularValoresAguaEsgotoHelper objetoTotalizacao;
		CalcularValoresAguaEsgotoHelper objetoColecao;

		/*
		 * Alterado por Raphael Rossiter em 28/05/2008 OBJ - Utilizar o
		 * indicador em sistema_parametros para totalizar os valores por
		 * categoria ou subcategoria
		 */
		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();
		Integer qtdCategoriaOUSubcategoria = null;

		if (sistemaParametro.getIndicadorTarifaCategoria().equals(
				SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {

			qtdCategoriaOUSubcategoria = (Integer) this.getControladorImovel()
					.pesquisarObterQuantidadeCategoria();
		} else {

			qtdCategoriaOUSubcategoria = (Integer) this.getControladorImovel()
					.pesquisarObterQuantidadeSubcategoria();
		}

		Object[][] categoriasTotalizacao = new Object[qtdCategoriaOUSubcategoria
				.intValue()][12];
		Integer idCategoria;
		BigDecimal valorAgua, valorEsgoto, valorTarifaMinimaAgua, valorTarifaMinimaEsgoto;
		Collection faixaHelper = null;
		Collection faixaHelperObjetoColecao = null;
		boolean categoriaDentroArray = false;
		int controleCategoria = 0;
		// Integer consumoAgua = 0;
		// Integer consumoEsgoto = 0;

		while (colecaoCalcularValoresAguaEsgotoHelperIt.hasNext()) {

			objetoColecao = (CalcularValoresAguaEsgotoHelper) colecaoCalcularValoresAguaEsgotoHelperIt
					.next();

			if (categoriasTotalizacao[0][0] == null) {
				categoriasTotalizacao[0][0] = objetoColecao.getIdCategoria();
				categoriasTotalizacao[0][1] = objetoColecao
						.getDescricaoCategoria();
				categoriasTotalizacao[0][2] = objetoColecao
						.getValorFaturadoAguaCategoria();
				categoriasTotalizacao[0][3] = objetoColecao
						.getValorFaturadoEsgotoCategoria();
				categoriasTotalizacao[0][4] = objetoColecao
						.getQuantidadeEconomiasCategoria();
				categoriasTotalizacao[0][5] = objetoColecao
						.getConsumoFaturadoAguaCategoria();
				categoriasTotalizacao[0][6] = objetoColecao
						.getConsumoFaturadoEsgotoCategoria();
				categoriasTotalizacao[0][7] = objetoColecao
						.getFaixaTarifaConsumo();

				categoriasTotalizacao[0][8] = objetoColecao
						.getValorTarifaMinimaAguaCategoria();
				categoriasTotalizacao[0][9] = objetoColecao
						.getConsumoMinimoAguaCategoria();
				categoriasTotalizacao[0][10] = objetoColecao
						.getValorTarifaMinimaEsgotoCategoria();
				categoriasTotalizacao[0][11] = objetoColecao
						.getConsumoMinimoEsgotoCategoria();

				controleCategoria++;
			} else {

				categoriaDentroArray = false;

				for (int index = 0; index < categoriasTotalizacao.length; index++) {

					if (categoriasTotalizacao[index][0] != null) {

						idCategoria = (Integer) categoriasTotalizacao[index][0];

						if (idCategoria.intValue() == objetoColecao
								.getIdCategoria().intValue()) {

							valorAgua = (BigDecimal) categoriasTotalizacao[index][2];
							if (valorAgua != null) {
								valorAgua = valorAgua.add(objetoColecao
										.getValorFaturadoAguaCategoria());
							}
							valorEsgoto = (BigDecimal) categoriasTotalizacao[index][3];

							if (valorEsgoto != null) {

								valorEsgoto = valorEsgoto.add(objetoColecao
										.getValorFaturadoEsgotoCategoria());
							}
							categoriasTotalizacao[index][2] = valorAgua;
							categoriasTotalizacao[index][3] = valorEsgoto;

							/*
							 * Colocado por Raphael Rossiter em 09/07/2007
							 */
							valorTarifaMinimaAgua = (BigDecimal) categoriasTotalizacao[index][8];
							if (valorTarifaMinimaAgua != null) {
								valorTarifaMinimaAgua = valorTarifaMinimaAgua
										.add(objetoColecao
												.getValorTarifaMinimaAguaCategoria());
							}
							categoriasTotalizacao[index][8] = valorTarifaMinimaAgua;

							valorTarifaMinimaEsgoto = (BigDecimal) categoriasTotalizacao[index][10];
							if (valorTarifaMinimaEsgoto != null) {
								valorTarifaMinimaEsgoto = valorTarifaMinimaEsgoto
										.add(objetoColecao
												.getValorTarifaMinimaEsgotoCategoria());
							}
							categoriasTotalizacao[index][10] = valorTarifaMinimaEsgoto;

							faixaHelper = (Collection) categoriasTotalizacao[index][7];
							faixaHelperObjetoColecao = objetoColecao
									.getFaixaTarifaConsumo();

							if (faixaHelper != null && !faixaHelper.isEmpty()) {

								if (faixaHelperObjetoColecao != null
										&& !faixaHelperObjetoColecao.isEmpty()) {

									Iterator itFaixaHelper = faixaHelper
											.iterator();
									Iterator itFaixaHelperObjetoColecao = faixaHelperObjetoColecao
											.iterator();

									while (itFaixaHelper.hasNext()
											&& itFaixaHelperObjetoColecao
													.hasNext()) {

										CalcularValoresAguaEsgotoFaixaHelper objetoFaixaHelper = (CalcularValoresAguaEsgotoFaixaHelper) itFaixaHelper
												.next();

										CalcularValoresAguaEsgotoFaixaHelper objetoFaixaHelperObjetoColecao = (CalcularValoresAguaEsgotoFaixaHelper) itFaixaHelperObjetoColecao
												.next();

										if (objetoFaixaHelper
												.getValorFaturadoAguaFaixa() != null) {

											objetoFaixaHelper
													.setValorFaturadoAguaFaixa(objetoFaixaHelper
															.getValorFaturadoAguaFaixa()
															.add(objetoFaixaHelperObjetoColecao
																	.getValorFaturadoAguaFaixa()));
										}

										if (objetoFaixaHelper
												.getValorFaturadoEsgotoFaixa() != null) {

											objetoFaixaHelper
													.setValorFaturadoEsgotoFaixa(objetoFaixaHelper
															.getValorFaturadoEsgotoFaixa()
															.add(objetoFaixaHelperObjetoColecao
																	.getValorFaturadoEsgotoFaixa()));
										}

										objetoFaixaHelper
												.setValorTarifaFaixa(objetoFaixaHelper
														.getValorTarifaFaixa()
														.add(objetoFaixaHelperObjetoColecao
																.getValorTarifaFaixa()));

									}
								}
							} else if (faixaHelperObjetoColecao != null
									&& !faixaHelperObjetoColecao.isEmpty()) {

								categoriasTotalizacao[index][7] = faixaHelperObjetoColecao;
							}

							categoriaDentroArray = true;

							break;
						}
					} else {
						break;
					}
				}

				if (!categoriaDentroArray) {
					categoriasTotalizacao[controleCategoria][0] = objetoColecao
							.getIdCategoria();
					categoriasTotalizacao[controleCategoria][1] = objetoColecao
							.getDescricaoCategoria();
					categoriasTotalizacao[controleCategoria][2] = objetoColecao
							.getValorFaturadoAguaCategoria();
					categoriasTotalizacao[controleCategoria][3] = objetoColecao
							.getValorFaturadoEsgotoCategoria();
					categoriasTotalizacao[controleCategoria][4] = objetoColecao
							.getQuantidadeEconomiasCategoria();
					categoriasTotalizacao[controleCategoria][5] = objetoColecao
							.getConsumoFaturadoAguaCategoria();
					categoriasTotalizacao[controleCategoria][6] = objetoColecao
							.getConsumoFaturadoEsgotoCategoria();
					categoriasTotalizacao[controleCategoria][7] = objetoColecao
							.getFaixaTarifaConsumo();

					categoriasTotalizacao[controleCategoria][8] = objetoColecao
							.getValorTarifaMinimaAguaCategoria();
					categoriasTotalizacao[controleCategoria][9] = objetoColecao
							.getConsumoMinimoAguaCategoria();
					categoriasTotalizacao[controleCategoria][10] = objetoColecao
							.getValorTarifaMinimaEsgotoCategoria();
					categoriasTotalizacao[controleCategoria][11] = objetoColecao
							.getConsumoMinimoEsgotoCategoria();

					controleCategoria++;
				}
			}
		}

		for (int indexArray = 0; indexArray < categoriasTotalizacao.length; indexArray++) {

			if (categoriasTotalizacao[indexArray][0] != null) {

				objetoTotalizacao = new CalcularValoresAguaEsgotoHelper();

				objetoTotalizacao
						.setIdCategoria((Integer) categoriasTotalizacao[indexArray][0]);
				objetoTotalizacao
						.setDescricaoCategoria((String) categoriasTotalizacao[indexArray][1]);
				objetoTotalizacao
						.setValorFaturadoAguaCategoria((BigDecimal) categoriasTotalizacao[indexArray][2]);
				objetoTotalizacao
						.setValorFaturadoEsgotoCategoria((BigDecimal) categoriasTotalizacao[indexArray][3]);
				objetoTotalizacao
						.setQuantidadeEconomiasCategoria((Integer) categoriasTotalizacao[indexArray][4]);
				objetoTotalizacao
						.setConsumoFaturadoAguaCategoria((Integer) categoriasTotalizacao[indexArray][5]);
				objetoTotalizacao
						.setConsumoFaturadoEsgotoCategoria((Integer) categoriasTotalizacao[indexArray][6]);
				objetoTotalizacao
						.setFaixaTarifaConsumo((Collection) categoriasTotalizacao[indexArray][7]);

				if (categoriasTotalizacao[indexArray][8] != null) {
					objetoTotalizacao
							.setValorTarifaMinimaAguaCategoria((BigDecimal) categoriasTotalizacao[indexArray][8]);
				}

				if (categoriasTotalizacao[indexArray][9] != null) {
					objetoTotalizacao
							.setConsumoMinimoAguaCategoria((Integer) categoriasTotalizacao[indexArray][9]);
				}

				if (categoriasTotalizacao[indexArray][10] != null) {
					objetoTotalizacao
							.setValorTarifaMinimaEsgotoCategoria((BigDecimal) categoriasTotalizacao[indexArray][10]);
				}

				if (categoriasTotalizacao[indexArray][11] != null) {
					objetoTotalizacao
							.setConsumoMinimoEsgotoCategoria((Integer) categoriasTotalizacao[indexArray][11]);
				}

				colecaoRetorno.add(objetoTotalizacao);
			}

		}

		return colecaoRetorno;
	}

	/*
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto [SF0001] - Cálculo
	 * Simples Para Uma Única Tarifa Autor: Raphael Rossiter Data: 21/12/2005
	 */
	@SuppressWarnings("unchecked")
	protected Collection<CalcularValoresAguaEsgotoHelper> calculoSimplesUmaTarifa(
			Integer consumoFaturado,
			Collection categoriasOuSubcategoriasImovel,
			BigDecimal percentualEsgoto,
			ConsumoTarifaVigencia consumoTarifaVigencia, String tipoCalculo,
			Integer idTarifaTipoCalculo) throws ControladorException {

		/*
		 * Para campos relacionados a consumo serão atribuídos valores inteiros,
		 * já com os campos monetários serão atribuídos valores com duas casas
		 * decimais (BigDecimal).
		 * ------------------------------------------------
		 * -------------------------
		 */

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		int quantTotalEconomia = 0;
		int consumoPorEconomia = 0;
		int consumoMinimoCategoriaOuSubcategoria = 0;
		int consumoExcedenteCategoriaOuSubcategoria = 0;
		int consumoEconomiaCategoriaOuSubcategoria = 0;
		int consumoFaturadoCategoriaOuSubcategoria = 0;
		BigDecimal vlTarifaMinimaCategoriaOuSubcategoria = new BigDecimal("0");
		BigDecimal vlEconomiaCategoriaOuSubcategoria = new BigDecimal("0");
		BigDecimal vlFaturadoCategoriaOuSubcategoria = new BigDecimal("0");

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		// --------------------------------------------------------------------------

		Iterator itCategoriasOuSubcategoriasImovel = categoriasOuSubcategoriasImovel
				.iterator();
		Categoria categoria = null;
		Subcategoria subcategoria = null;
		ConsumoTarifaCategoria consumoTarifaCategoria;
		Collection colecaoConsumoTarifaCategoria = null;
		BigDecimal consumoMinimoImovel = new BigDecimal(0);

		// int excessoUsado = 0;

		// Calcula a quantidade total de economias do imóvel.
		// --------------------------------------------------------------------------
		while (itCategoriasOuSubcategoriasImovel.hasNext()) {

			int qtdEconomias = 0;

			if (sistemaParametro.getIndicadorTarifaCategoria().equals(
					ConstantesSistema.SIM)) {
				categoria = (Categoria) itCategoriasOuSubcategoriasImovel
						.next();
				qtdEconomias = getControladorCadastro()
						.obterQuantidadeEconomiasCategoria(categoria);
			} else {
				subcategoria = (Subcategoria) itCategoriasOuSubcategoriasImovel
						.next();
				qtdEconomias = getControladorCadastro()
						.obterQuantidadeEconomiasSubcategoria(subcategoria);
			}

			quantTotalEconomia = quantTotalEconomia + qtdEconomias;

			try {
				if (sistemaParametro.getIndicadorTarifaCategoria().equals(
						ConstantesSistema.SIM)) {

					colecaoConsumoTarifaCategoria = repositorioFaturamento
							.pesquisarConsumoTarifaCategoria(
									consumoTarifaVigencia, categoria);
				} else {

					colecaoConsumoTarifaCategoria = repositorioFaturamento
							.pesquisarConsumoTarifaCategoriaPorSubCategoria(
									consumoTarifaVigencia,
									subcategoria.getCategoria(), subcategoria);

					// Quando ele não achar a subcategoria procurar mais
					// acima
					// por categoria
					if (colecaoConsumoTarifaCategoria == null
							|| colecaoConsumoTarifaCategoria.isEmpty()) {

						colecaoConsumoTarifaCategoria = repositorioFaturamento
								.pesquisarConsumoTarifaCategoria(
										consumoTarifaVigencia,
										subcategoria.getCategoria());
					}
				}

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if (colecaoConsumoTarifaCategoria == null
					|| colecaoConsumoTarifaCategoria.isEmpty()) {
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.categoria_nao_existe_para_tarifa_vigente");
			}

			consumoTarifaCategoria = (ConsumoTarifaCategoria) Util
					.retonarObjetoDeColecao(colecaoConsumoTarifaCategoria);

			// ConsumoMinimoImovel = Para cada subcategoria do imóvel
			// (onde n=quantidade de subcategorias do imovel)
			// Somar (valor(1-n) = (CSTC_NNCONSUMOMINIMO(1-n) * quantidade
			// de
			// economias da subcategoria(1-n) )
			if (consumoTarifaCategoria.getNumeroConsumoMinimo() != null) {
				BigDecimal calculo = new BigDecimal(consumoTarifaCategoria
						.getNumeroConsumoMinimo().intValue() * qtdEconomias);

				consumoMinimoImovel = consumoMinimoImovel.add(calculo);
			}
		}

		// Calcula o consumo por economia (consumo faturado / quantidade total
		// de economias).

		// Pega o menor valor da divisão para o consumo de água ser o menor
		// multiplo das economias
		// Roberta Costa - 27/07/2006
		if (quantTotalEconomia != 0) {
			consumoPorEconomia = consumoFaturado.intValue()
					/ quantTotalEconomia;
		}

		// Cálculo do Excesso do Imóvel = Consumo faturado - Consumo Minimo do
		// imovel
		int calculoExcessoImovel = consumoFaturado.intValue()
				- consumoMinimoImovel.intValue();

		// Cálculo do Excesso por economia = Consumo Excedente / quantidade
		// total de economias do imóvel
		int calculoExcessoEconomia = calculoExcessoImovel / quantTotalEconomia;

		// --------------------------------------------------------------------------
		// Seleciona as tarifas de consumo por categoria
		// (CONSUMO_TARIFA_CATEGORIA).
		// --------------------------------------------------------------------------
		itCategoriasOuSubcategoriasImovel = categoriasOuSubcategoriasImovel
				.iterator();

		while (itCategoriasOuSubcategoriasImovel.hasNext()) {

			Integer qtdEconomias = null;

			try {
				if (sistemaParametro.getIndicadorTarifaCategoria().equals(
						ConstantesSistema.SIM)) {
					categoria = (Categoria) itCategoriasOuSubcategoriasImovel
							.next();

					qtdEconomias = getControladorCadastro()
							.obterQuantidadeEconomiasCategoria(categoria);

					colecaoConsumoTarifaCategoria = repositorioFaturamento
							.pesquisarConsumoTarifaCategoria(
									consumoTarifaVigencia, categoria);
				} else {
					subcategoria = (Subcategoria) itCategoriasOuSubcategoriasImovel
							.next();

					qtdEconomias = getControladorCadastro()
							.obterQuantidadeEconomiasSubcategoria(subcategoria);

					colecaoConsumoTarifaCategoria = repositorioFaturamento
							.pesquisarConsumoTarifaCategoriaPorSubCategoria(
									consumoTarifaVigencia,
									subcategoria.getCategoria(), subcategoria);

					// Quando ele não achar a subcategoria procurar mais acima
					// por categoria
					if (colecaoConsumoTarifaCategoria == null
							|| colecaoConsumoTarifaCategoria.isEmpty()) {

						colecaoConsumoTarifaCategoria = repositorioFaturamento
								.pesquisarConsumoTarifaCategoria(
										consumoTarifaVigencia,
										subcategoria.getCategoria());
					}
				}

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if (colecaoConsumoTarifaCategoria == null
					|| colecaoConsumoTarifaCategoria.isEmpty()) {
				sessionContext.setRollbackOnly();
				// ////*****//////
				throw new ControladorException(
						"atencao.categoria_nao_existe_para_tarifa_vigente");
			}

			consumoTarifaCategoria = (ConsumoTarifaCategoria) Util
					.retonarObjetoDeColecao(colecaoConsumoTarifaCategoria);

			/*
			 * Para cada tarifa de consumo por categoria selecionada serão
			 * calculados os valores (valor da tarifa mínima da categoria,
			 * consumo mínimo da categoria, valor por economia da categoria,
			 * consumo excedente da categoria)
			 * 
			 * OBS - Cada categoria só possuirá uma tarifa de consumo (Analista
			 * 15/08/2005)
			 * ------------------------------------------------------
			 * -----------------
			 */
			// ValorTarifaMinimaCategoria (CSTC_VLTARIFAMINIMA * quantidade
			// de
			// economias)
			if (consumoTarifaCategoria.getValorTarifaMinima() != null) {
				vlTarifaMinimaCategoriaOuSubcategoria = consumoTarifaCategoria
						.getValorTarifaMinima().multiply(
								new BigDecimal("" + qtdEconomias));
			} else {
				vlTarifaMinimaCategoriaOuSubcategoria = null;
			}

			// ConsumoMinimoCategoria (CSTC_NNCONSUMOMINIMO * quantidade de
			// economias)
			if (consumoTarifaCategoria.getNumeroConsumoMinimo() != null) {

				consumoMinimoCategoriaOuSubcategoria = consumoTarifaCategoria
						.getNumeroConsumoMinimo().intValue() * qtdEconomias;
			}

			// ValorEconomiaCategoria (CSTC_VLTARIFAMINIMA)
			if (consumoTarifaCategoria.getValorTarifaMinima() != null) {
				vlEconomiaCategoriaOuSubcategoria = consumoTarifaCategoria
						.getValorTarifaMinima();
			} else {
				vlEconomiaCategoriaOuSubcategoria = null;
			}

			/*
			 * Caso o consumo por economia seja maior que o CSTC_NNCONSUMOMINIMO
			 * então consumo por economia da categoria = CSTC_NNCONSUMOMINIMO,
			 * caso contrário consumo por economia da categoria = consumo por
			 * economia
			 */
			if (calculoExcessoImovel > 0) {
				consumoEconomiaCategoriaOuSubcategoria = consumoTarifaCategoria
						.getNumeroConsumoMinimo().intValue();
			} else {
				if (consumoTarifaCategoria.getNumeroConsumoMinimo() != null) {
					if (consumoPorEconomia > consumoTarifaCategoria
							.getNumeroConsumoMinimo().intValue()) {

						consumoEconomiaCategoriaOuSubcategoria = consumoTarifaCategoria
								.getNumeroConsumoMinimo().intValue();
					} else {
						consumoEconomiaCategoriaOuSubcategoria = consumoPorEconomia;
					}

				} else {

					consumoEconomiaCategoriaOuSubcategoria = consumoPorEconomia;

				}
			}

			/*
			 * Consumo excedente da categoria = consumo por economia -
			 * CSTC_NNCONSUMOMINIMO
			 */
			// 1.4.1.5. Caso o consumo excedente do imovel seja maior que zero
			if (calculoExcessoImovel > 0) {

				// Consumo excendente da categoria = Cálculo do Excesso por
				// economia * quantidade de economias da categoria
				consumoExcedenteCategoriaOuSubcategoria = calculoExcessoEconomia;

			} else if (consumoTarifaCategoria.getNumeroConsumoMinimo() != null) {

				consumoExcedenteCategoriaOuSubcategoria = consumoPorEconomia
						- consumoTarifaCategoria.getNumeroConsumoMinimo()
								.intValue();

			}

			// Objeto que irá armazenar os valores calculados referentes as
			// faixas
			Collection<CalcularValoresAguaEsgotoFaixaHelper> colecaoCalcularValoresAguaEsgotoFaixaHelper = new ArrayList();
			BigDecimal vlFaturadoFaixa = null;

			// Caso o consumo excedente da categoria seja maior que zero
			if (consumoExcedenteCategoriaOuSubcategoria > 0) {

				int faixaFimAnterior = 0;

				// Calcula a faixa fim anterior = CSTC_NNCONSUMOMINIMO
				if (consumoTarifaCategoria.getNumeroConsumoMinimo() != null) {
					faixaFimAnterior = consumoTarifaCategoria.getNumeroConsumoMinimo().intValue();
				}

				/*
				 * Seleciona as faixas para cálculo do valor faturado,
				 * classificadas pela faixa inicial de consumo
				 * (CSTI_NNCONSUMOFAIXAINICIO), (a partir da tabela
				 * CONSUMO_TARIFA_FAIXA com CSTC_ID=CSTC_ID da tabela
				 * CONSUMO_TARIFA_CATEGORIA)
				 */

				Collection colecaoConsumoTarifaFaixa = null;

				try {
					colecaoConsumoTarifaFaixa = repositorioFaturamento.pesquisarConsumoTarifaFaixa(consumoTarifaCategoria);
				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				if (colecaoConsumoTarifaFaixa == null || colecaoConsumoTarifaFaixa.isEmpty()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("");
				} else {
					int consumoFaturadoFaixa = 0;
					int limiteInicialConsumoFaixa = 0;
					int limiteFinalConsumoFaixa = 0;
					vlFaturadoFaixa = new BigDecimal("0");
					BigDecimal vlTarifaFaixa = new BigDecimal("0");

					Iterator itConsumoTarifaFaixa = colecaoConsumoTarifaFaixa.iterator();
					ConsumoTarifaFaixa consumoTarifaFaixa;

					while (itConsumoTarifaFaixa.hasNext() && consumoExcedenteCategoriaOuSubcategoria > 0) {

						consumoTarifaFaixa = (ConsumoTarifaFaixa) itConsumoTarifaFaixa.next();

						if (idTarifaTipoCalculo.intValue() == 2) {
							/*
							 * Selecione a faixa em que o consumo excedente se
							 * enquadre, (consumoFaturado menor ou igual a faixa
							 * fim)
							 */
							if (consumoTarifaFaixa.getNumeroConsumoFaixaFim() != null && consumoPorEconomia <= consumoTarifaFaixa.getNumeroConsumoFaixaFim()) {

								consumoFaturadoFaixa = consumoFaturado;

								vlFaturadoFaixa = this.calcularValorFaturadoFaixaCAER(
												consumoPorEconomia,
												vlTarifaMinimaCategoriaOuSubcategoria,
												consumoTarifaFaixa.getValorConsumoTarifa());

								limiteInicialConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaInicio();
								limiteFinalConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaFim();

								CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = getCalcularValoresAguaEsgotoFaixaHelper(
										tipoCalculo, consumoTarifaFaixa, consumoFaturadoFaixa,
										limiteInicialConsumoFaixa, limiteFinalConsumoFaixa, vlFaturadoFaixa, vlTarifaFaixa);

								colecaoCalcularValoresAguaEsgotoFaixaHelper.add(calcularValoresAguaEsgotoFaixaHelper);

								vlEconomiaCategoriaOuSubcategoria = vlFaturadoFaixa;
								consumoEconomiaCategoriaOuSubcategoria = consumoFaturadoFaixa;

								break;
							}
						} else {

							/*
							 * Calcula o consumo faturado na faixa =
							 * CSTF_NNCONSUMOFAIXAFIM - faixa fim anterior
							 */
							consumoFaturadoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaFim().intValue() - faixaFimAnterior;

							/*
							 * Caso o consumo excedente da categoria seja menor
							 * que o consumo faturado na faixa, consumo faturado
							 * na faixa = consumo excedente da categoria
							 */
							if (consumoExcedenteCategoriaOuSubcategoria < consumoFaturadoFaixa) {
								consumoFaturadoFaixa = consumoExcedenteCategoriaOuSubcategoria;
							}

							/*******************************************************
							 * Valor faturado na faixa = (consumo faturado na
							 * faixa CSTF_VLCONSUMOTARIFA).
							 */
							vlFaturadoFaixa = (new BigDecimal("" + consumoFaturadoFaixa)).multiply(consumoTarifaFaixa.getValorConsumoTarifa());

							/*
							 * Valor por economia da categoria = valor por
							 * economia da categoria + valor faturado na faixa
							 */
							vlEconomiaCategoriaOuSubcategoria = vlEconomiaCategoriaOuSubcategoria.add(vlFaturadoFaixa);

							/*
							 * Consumo por economia da categoria = consumo por
							 * economia da categoria + consumo faturado na faixa
							 */
							consumoEconomiaCategoriaOuSubcategoria = consumoEconomiaCategoriaOuSubcategoria	+ consumoFaturadoFaixa;

							// Limite inicial de consumo da faixa =
							// CSTF_NNCONSUMOFAIXAINICIO
							limiteInicialConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaInicio().intValue();

							// Limite final de consumo da faixa =
							// CSTF_NNCONSUMOFAIXAFIM
							limiteFinalConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaFim().intValue();

							// Valor da tarifa na faixa = CSTF_VLCONSUMOTARIFA
							vlTarifaFaixa = consumoTarifaFaixa.getValorConsumoTarifa();

							/*
							 * Consumo excedente da categoria = consumo
							 * excedente da categoria - consumo faturado na
							 * faixa
							 */
							consumoExcedenteCategoriaOuSubcategoria = consumoExcedenteCategoriaOuSubcategoria - consumoFaturadoFaixa;

							// Faixa fim anterior = CSTI_NNCONSUMOFAIXAFIM
							faixaFimAnterior = consumoTarifaFaixa.getNumeroConsumoFaixaFim().intValue();

							CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = getCalcularValoresAguaEsgotoFaixaHelper(
									tipoCalculo, consumoTarifaFaixa,
									consumoFaturadoFaixa,
									limiteInicialConsumoFaixa,
									limiteFinalConsumoFaixa, vlFaturadoFaixa,
									vlTarifaFaixa);

							// ------------------------------------------------------------------

							colecaoCalcularValoresAguaEsgotoFaixaHelper.add(calcularValoresAguaEsgotoFaixaHelper);
						}
					}
				}
			}

			/*
			 * Calcula o valor faturado na categoria = valor por economia da
			 * categoria quantidade de economias da categoria
			 */
			if (idTarifaTipoCalculo.intValue() == 2) {
				if (vlFaturadoFaixa != null) {
					vlFaturadoCategoriaOuSubcategoria = vlFaturadoFaixa;
				} else {
					vlFaturadoCategoriaOuSubcategoria = vlEconomiaCategoriaOuSubcategoria.multiply(new BigDecimal("" + qtdEconomias));
				}

			} else {
				vlFaturadoCategoriaOuSubcategoria = vlEconomiaCategoriaOuSubcategoria
						.multiply(new BigDecimal("" + qtdEconomias));
			}

			/*
			 * Calcula o consumo faturado na categoria = consumo por economia da
			 * categoria * quantidade de economias da categoria
			 */
			if (idTarifaTipoCalculo.intValue() == 2) {
				consumoFaturadoCategoriaOuSubcategoria = consumoEconomiaCategoriaOuSubcategoria;

			} else {
				consumoFaturadoCategoriaOuSubcategoria = consumoEconomiaCategoriaOuSubcategoria
						* qtdEconomias;
			}

			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = null;

			if (sistemaParametro.getIndicadorTarifaCategoria().equals(
					ConstantesSistema.SIM)) {
				calcularValoresAguaEsgotoHelper = getCalcularValoresAguaEsgotoHelper(
						percentualEsgoto, tipoCalculo,
						consumoMinimoCategoriaOuSubcategoria,
						consumoFaturadoCategoriaOuSubcategoria,
						vlTarifaMinimaCategoriaOuSubcategoria,
						vlFaturadoCategoriaOuSubcategoria, categoria,
						consumoTarifaCategoria,
						colecaoCalcularValoresAguaEsgotoFaixaHelper);
			} else {
				calcularValoresAguaEsgotoHelper = getCalcularValoresAguaEsgotoHelper(
						percentualEsgoto, tipoCalculo,
						consumoMinimoCategoriaOuSubcategoria,
						consumoFaturadoCategoriaOuSubcategoria,
						vlTarifaMinimaCategoriaOuSubcategoria,
						vlFaturadoCategoriaOuSubcategoria, subcategoria,
						consumoTarifaCategoria,
						colecaoCalcularValoresAguaEsgotoFaixaHelper);
			}

			colecaoRetorno.add(calcularValoresAguaEsgotoHelper);
		}

		return colecaoRetorno;
	}

	/*
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto [SF0001] - Cálculo
	 * Simples Para Uma Única Tarifa Autor: Raphael Rossiter Data: 21/12/2005
	 */
	protected Collection<CalcularValoresAguaEsgotoHelper> calculoConsumoDiretoNaFaixa(
			Integer consumoFaturado,
			Collection categoriasOuSubcategoriasImovel,
			BigDecimal percentualEsgoto,
			ConsumoTarifaVigencia consumoTarifaVigencia, String tipoCalculo,
			Integer idTarifaTipoCalculo) throws ControladorException {

		/*
		 * Para campos relacionados a consumo serão atribuídos valores inteiros,
		 * já com os campos monetários serão atribuídos valores com duas casas
		 * decimais (BigDecimal).
		 * ------------------------------------------------
		 * -------------------------
		 */

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		int quantTotalEconomia = 0;
		int consumoPorEconomia = 0;
		int consumoMinimoCategoriaOuSubcategoria = 0;
		int consumoEconomiaCategoriaOuSubcategoria = 0;
		int consumoFaturadoCategoriaOuSubcategoria = 0;
		BigDecimal vlTarifaMinimaCategoriaOuSubcategoria = new BigDecimal("0");
		BigDecimal vlEconomiaCategoriaOuSubcategoria = new BigDecimal("0");
		BigDecimal vlFaturadoCategoriaOuSubcategoria = new BigDecimal("0");

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		// --------------------------------------------------------------------------

		Iterator itCategoriasOuSubcategoriasImovel = categoriasOuSubcategoriasImovel
				.iterator();
		Categoria categoria = null;
		Subcategoria subcategoria = null;
		ConsumoTarifaCategoria consumoTarifaCategoria;
		Collection colecaoConsumoTarifaCategoria = null;

		// Calcula a quantidade total de economias do imóvel.
		// --------------------------------------------------------------------------
		while (itCategoriasOuSubcategoriasImovel.hasNext()) {

			if (sistemaParametro.getIndicadorTarifaCategoria().equals(
					ConstantesSistema.SIM)) {
				categoria = (Categoria) itCategoriasOuSubcategoriasImovel
						.next();
				quantTotalEconomia = quantTotalEconomia
						+ getControladorCadastro()
								.obterQuantidadeEconomiasCategoria(categoria);
			} else {
				subcategoria = (Subcategoria) itCategoriasOuSubcategoriasImovel
						.next();
				quantTotalEconomia = quantTotalEconomia
						+ getControladorCadastro()
								.obterQuantidadeEconomiasSubcategoria(
										subcategoria);
			}

		}

		// Calcula o consumo por economia (consumo faturado / quantidade total
		// de economias).

		// Pega o menor valor da divisão para o consumo de água ser o menor
		// multiplo das economias
		// Roberta Costa - 27/07/2006
		if (quantTotalEconomia != 0) {
			consumoPorEconomia = consumoFaturado.intValue()
					/ quantTotalEconomia;
		}

		// --------------------------------------------------------------------------
		// Seleciona as tarifas de consumo por categoria
		// (CONSUMO_TARIFA_CATEGORIA).
		// --------------------------------------------------------------------------
		itCategoriasOuSubcategoriasImovel = categoriasOuSubcategoriasImovel
				.iterator();

		while (itCategoriasOuSubcategoriasImovel.hasNext()) {
			try {
				if (sistemaParametro.getIndicadorTarifaCategoria().equals(
						ConstantesSistema.SIM)) {
					categoria = (Categoria) itCategoriasOuSubcategoriasImovel
							.next();

					colecaoConsumoTarifaCategoria = repositorioFaturamento
							.pesquisarConsumoTarifaCategoria(
									consumoTarifaVigencia, categoria);
				} else {
					subcategoria = (Subcategoria) itCategoriasOuSubcategoriasImovel
							.next();

					colecaoConsumoTarifaCategoria = repositorioFaturamento
							.pesquisarConsumoTarifaCategoriaPorSubCategoria(
									consumoTarifaVigencia,
									subcategoria.getCategoria(), subcategoria);

					// Quando ele não achar a subcategoria procurar mais acima
					// por categoria
					if (colecaoConsumoTarifaCategoria == null
							|| colecaoConsumoTarifaCategoria.isEmpty()) {

						colecaoConsumoTarifaCategoria = repositorioFaturamento
								.pesquisarConsumoTarifaCategoria(
										consumoTarifaVigencia,
										subcategoria.getCategoria());
					}
				}

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if (colecaoConsumoTarifaCategoria == null
					|| colecaoConsumoTarifaCategoria.isEmpty()) {
				sessionContext.setRollbackOnly();
				// ////*****//////
				throw new ControladorException(
						"atencao.categoria_nao_existe_para_tarifa_vigente");
			}

			consumoTarifaCategoria = (ConsumoTarifaCategoria) Util
					.retonarObjetoDeColecao(colecaoConsumoTarifaCategoria);

			/*
			 * Para cada tarifa de consumo por categoria selecionada serão
			 * calculados os valores (valor da tarifa mínima da categoria,
			 * consumo mínimo da categoria, valor por economia da categoria,
			 * consumo excedente da categoria)
			 * 
			 * OBS - Cada categoria só possuirá uma tarifa de consumo (Analista
			 * 15/08/2005)
			 * ------------------------------------------------------
			 * -----------------
			 */

			Integer qtdEconomias = null;

			if (sistemaParametro.getIndicadorTarifaCategoria().equals(
					ConstantesSistema.SIM)) {
				qtdEconomias = getControladorCadastro()
						.obterQuantidadeEconomiasCategoria(categoria);
			} else {
				qtdEconomias = getControladorCadastro()
						.obterQuantidadeEconomiasSubcategoria(subcategoria);
			}

			// ValorTarifaMinimaCategoria (CSTC_VLTARIFAMINIMA * quantidade
			// de
			// economias)
			if (consumoTarifaCategoria.getValorTarifaMinima() != null) {
				vlTarifaMinimaCategoriaOuSubcategoria = consumoTarifaCategoria
						.getValorTarifaMinima().multiply(
								new BigDecimal("" + qtdEconomias));
			} else {
				vlTarifaMinimaCategoriaOuSubcategoria = null;
			}

			// ConsumoMinimoCategoria (CSTC_NNCONSUMOMINIMO * quantidade de
			// economias)
			if (consumoTarifaCategoria.getNumeroConsumoMinimo() != null) {

				consumoMinimoCategoriaOuSubcategoria = consumoTarifaCategoria
						.getNumeroConsumoMinimo().intValue() * qtdEconomias;
			}

			// ValorEconomiaCategoria (CSTC_VLTARIFAMINIMA)
			if (consumoTarifaCategoria.getValorTarifaMinima() != null) {
				vlEconomiaCategoriaOuSubcategoria = consumoTarifaCategoria
						.getValorTarifaMinima();
			} else {
				vlEconomiaCategoriaOuSubcategoria = null;
			}

			consumoEconomiaCategoriaOuSubcategoria = consumoPorEconomia;

			// Objeto que irá armazenar os valores calculados referentes as
			// faixas
			Collection<CalcularValoresAguaEsgotoFaixaHelper> colecaoCalcularValoresAguaEsgotoFaixaHelper = new ArrayList();

			if (consumoPorEconomia > consumoTarifaCategoria
					.getNumeroConsumoMinimo().intValue()) {
				try {
					ConsumoTarifaFaixa consumoTarifaFaixa = repositorioFaturamento
							.pesquisarConsumoTarifaFaixa(
									consumoTarifaCategoria, consumoPorEconomia);

					vlEconomiaCategoriaOuSubcategoria = consumoTarifaFaixa
							.getValorConsumoTarifa().multiply(
									new BigDecimal(consumoPorEconomia));

					CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = getCalcularValoresAguaEsgotoFaixaHelper(
							tipoCalculo, consumoTarifaFaixa,
							consumoPorEconomia,
							consumoTarifaFaixa.getNumeroConsumoFaixaInicio(),
							consumoTarifaFaixa.getNumeroConsumoFaixaFim(),
							vlEconomiaCategoriaOuSubcategoria,
							consumoTarifaFaixa.getValorConsumoTarifa());
					colecaoCalcularValoresAguaEsgotoFaixaHelper
							.add(calcularValoresAguaEsgotoFaixaHelper);
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}
			}

			/*
			 * Calcula o valor faturado na categoria = valor por economia da
			 * categoria quantidade de economias da categoria
			 */
			vlFaturadoCategoriaOuSubcategoria = vlEconomiaCategoriaOuSubcategoria
					.multiply(new BigDecimal("" + qtdEconomias));

			/*
			 * Calcula o consumo faturado na categoria = consumo por economia da
			 * categoria * quantidade de economias da categoria
			 */
			consumoFaturadoCategoriaOuSubcategoria = consumoEconomiaCategoriaOuSubcategoria
					* qtdEconomias;

			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = null;
			if (sistemaParametro.getIndicadorTarifaCategoria().equals(
					ConstantesSistema.SIM)) {
				calcularValoresAguaEsgotoHelper = getCalcularValoresAguaEsgotoHelper(
						percentualEsgoto, tipoCalculo,
						consumoMinimoCategoriaOuSubcategoria,
						consumoFaturadoCategoriaOuSubcategoria,
						vlTarifaMinimaCategoriaOuSubcategoria,
						vlFaturadoCategoriaOuSubcategoria, categoria,
						consumoTarifaCategoria,
						colecaoCalcularValoresAguaEsgotoFaixaHelper);
			} else {
				calcularValoresAguaEsgotoHelper = getCalcularValoresAguaEsgotoHelper(
						percentualEsgoto, tipoCalculo,
						consumoMinimoCategoriaOuSubcategoria,
						consumoFaturadoCategoriaOuSubcategoria,
						vlTarifaMinimaCategoriaOuSubcategoria,
						vlFaturadoCategoriaOuSubcategoria, subcategoria,
						consumoTarifaCategoria,
						colecaoCalcularValoresAguaEsgotoFaixaHelper);
			}

			colecaoRetorno.add(calcularValoresAguaEsgotoHelper);
		}

		return colecaoRetorno;

	}

	private CalcularValoresAguaEsgotoHelper getCalcularValoresAguaEsgotoHelper(
			BigDecimal percentualEsgoto,
			String tipoCalculo,
			int consumoMinimoCategoriaOuSubcategoria,
			int consumoFaturadoCategoriaOuSubcategoria,
			BigDecimal vlTarifaMinimaCategoriaOuSubcategoria,
			BigDecimal vlFaturadoCategoriaOuSubcategoria,
			Object categoriaOuSubcategoria,
			ConsumoTarifaCategoria consumoTarifaCategoria,
			Collection<CalcularValoresAguaEsgotoFaixaHelper> colecaoCalcularValoresAguaEsgotoFaixaHelper) {
		// --------------------------------------------------------
		// Gerando o novo objeto
		CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = new CalcularValoresAguaEsgotoHelper();

		if (categoriaOuSubcategoria instanceof Categoria) {
			Categoria categoria = (Categoria) categoriaOuSubcategoria;

			// Carregando o id da categoria no objeto
			calcularValoresAguaEsgotoHelper.setIdCategoria(categoria.getId());

			// Carregando a descricao da categoria no objeto
			calcularValoresAguaEsgotoHelper.setDescricaoCategoria(categoria
					.getDescricao());

			// Carrega a quantidade de economias da categoria
			calcularValoresAguaEsgotoHelper
					.setQuantidadeEconomiasCategoria(categoria
							.getQuantidadeEconomiasCategoria());
		} else {
			Subcategoria subcategoria = (Subcategoria) categoriaOuSubcategoria;

			// Carregando o id da categoria no objeto
			calcularValoresAguaEsgotoHelper
					.setIdCategoria(subcategoria.getId());

			// Carregando a descricao da categoria no objeto
			calcularValoresAguaEsgotoHelper.setDescricaoCategoria(subcategoria
					.getDescricao());

			// Carrega a quantidade de economias da categoria
			calcularValoresAguaEsgotoHelper
					.setQuantidadeEconomiasCategoria(subcategoria
							.getQuantidadeEconomias());
		}

		// Carregando o id do consumoTarifaCategoria no objeto
		calcularValoresAguaEsgotoHelper
				.setIdConsumoTarifaCategoria(consumoTarifaCategoria.getId());

		if (tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)) {

			calcularValoresAguaEsgotoHelper
					.setValorFaturadoAguaCategoria(vlFaturadoCategoriaOuSubcategoria);
			calcularValoresAguaEsgotoHelper
					.setConsumoFaturadoAguaCategoria(consumoFaturadoCategoriaOuSubcategoria);
			calcularValoresAguaEsgotoHelper
					.setValorTarifaMinimaAguaCategoria(vlTarifaMinimaCategoriaOuSubcategoria);
			calcularValoresAguaEsgotoHelper
					.setConsumoMinimoAguaCategoria(consumoMinimoCategoriaOuSubcategoria);

		} else {

			// Calculando com o percentual de esgoto
			BigDecimal result = percentualEsgoto.divide(new BigDecimal("100"),
					2, BigDecimal.ROUND_HALF_UP);

			// Valor faturado de esgoto
			vlFaturadoCategoriaOuSubcategoria = vlFaturadoCategoriaOuSubcategoria
					.multiply(result);
			vlFaturadoCategoriaOuSubcategoria = vlFaturadoCategoriaOuSubcategoria
					.setScale(2, BigDecimal.ROUND_HALF_UP);

			// Valor da tarifa mínima de esgoto
			vlTarifaMinimaCategoriaOuSubcategoria = vlTarifaMinimaCategoriaOuSubcategoria
					.multiply(result);
			vlTarifaMinimaCategoriaOuSubcategoria = vlTarifaMinimaCategoriaOuSubcategoria
					.setScale(2, BigDecimal.ROUND_HALF_UP);

			calcularValoresAguaEsgotoHelper
					.setValorFaturadoEsgotoCategoria(vlFaturadoCategoriaOuSubcategoria);
			calcularValoresAguaEsgotoHelper
					.setConsumoFaturadoEsgotoCategoria(consumoFaturadoCategoriaOuSubcategoria);
			calcularValoresAguaEsgotoHelper
					.setValorTarifaMinimaEsgotoCategoria(vlTarifaMinimaCategoriaOuSubcategoria);
			calcularValoresAguaEsgotoHelper
					.setConsumoMinimoEsgotoCategoria(consumoMinimoCategoriaOuSubcategoria);

		}

		// Carregando a coleção com os valores referentes as faixas
		calcularValoresAguaEsgotoHelper
				.setFaixaTarifaConsumo(colecaoCalcularValoresAguaEsgotoFaixaHelper);
		return calcularValoresAguaEsgotoHelper;
	}

	private CalcularValoresAguaEsgotoFaixaHelper getCalcularValoresAguaEsgotoFaixaHelper(
			String tipoCalculo, ConsumoTarifaFaixa consumoTarifaFaixa,
			int consumoFaturadoFaixa, int limiteInicialConsumoFaixa,
			int limiteFinalConsumoFaixa, BigDecimal vlFaturadoFaixa,
			BigDecimal vlTarifaFaixa) {
		/*
		 * Inseri os valores calculados no objeto de faixas
		 * -----------------------------------------------------------------
		 */

		CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = new CalcularValoresAguaEsgotoFaixaHelper();

		calcularValoresAguaEsgotoFaixaHelper
				.setIdConsumoTarifaFaixa(consumoTarifaFaixa.getId());
		calcularValoresAguaEsgotoFaixaHelper
				.setLimiteInicialConsumoFaixa(limiteInicialConsumoFaixa);
		calcularValoresAguaEsgotoFaixaHelper
				.setLimiteFinalConsumoFaixa(limiteFinalConsumoFaixa);
		calcularValoresAguaEsgotoFaixaHelper.setValorTarifaFaixa(vlTarifaFaixa);

		if (tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)) {

			calcularValoresAguaEsgotoFaixaHelper
					.setConsumoFaturadoAguaFaixa(consumoFaturadoFaixa);
			calcularValoresAguaEsgotoFaixaHelper
					.setValorFaturadoAguaFaixa(vlFaturadoFaixa);

		} else {

			calcularValoresAguaEsgotoFaixaHelper
					.setConsumoFaturadoEsgotoFaixa(consumoFaturadoFaixa);
			calcularValoresAguaEsgotoFaixaHelper
					.setValorFaturadoEsgotoFaixa(vlFaturadoFaixa);

		}
		return calcularValoresAguaEsgotoFaixaHelper;
	}

	/*
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto [SF0002] - Cálculo
	 * Proporcional Para Mais de Uma Tarifa Autor: Raphael Rossiter Data:
	 * 09/01/2006
	 */
	protected Collection<CalcularValoresAguaEsgotoHelper> calculoProporcionalMaisDeUmaTarifa(
			Date dataLeituraAtual,
			Date dataLeituraAnterior,
			Collection<ConsumoTarifaVigencia> colecaoConsumoTarifaVigencia,
			Integer consumoFaturado,
			Collection categoriasOuSubcategoriasImovel,
			BigDecimal percentualEsgoto,
			String tipoCalculo,
			Integer idTarifaTipoCalculo) throws ControladorException {

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		dataLeituraAnterior = Util.formatarDataSemHora(dataLeituraAnterior);
		dataLeituraAtual = Util.formatarDataSemHora(dataLeituraAtual);

		// 1 - Calcula a quantidade de dias entre as leituras = data de leitura atual - data de leitura anterior
		long qtdDiasLeitura = IoUtil.diferencaEntreDatas(dataLeituraAnterior, dataLeituraAtual);
		
		// soma 1 dia para contar o dia inicial da leitura
		qtdDiasLeitura += 1;

		// 2 - Data da vigência inicial
		Date dataVigenciaInicial = dataLeituraAnterior;

		// 3 - Para cada tarifa vigente para o período de leitura
		List colecaoConsumoTarifaVigenciaList = new ArrayList();
		colecaoConsumoTarifaVigenciaList.addAll(colecaoConsumoTarifaVigencia);

		ListIterator colecaoConsumoTarifaVigenciaListIt = colecaoConsumoTarifaVigenciaList.listIterator();

		ConsumoTarifaVigencia consumoTarifaVigenciaColecao;
		Collection<CalcularValoresAguaEsgotoHelper> calculoSimplesUmaTarifaColecao;

		Date dataVigenciaFinal = null;
		// ConsumoTarifaVigencia consumoTarifaVigenciaColecaoPrevious = null;

		while (colecaoConsumoTarifaVigenciaListIt.hasNext()) {

			consumoTarifaVigenciaColecao = (ConsumoTarifaVigencia) colecaoConsumoTarifaVigenciaListIt.next();

			// Cálculo Simples Para Uma Única Tarifa

			if (tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)) {

				if (idTarifaTipoCalculo.intValue() == 4) {
					calculoSimplesUmaTarifaColecao = calculoConsumoDiretoNaFaixa(consumoFaturado, categoriasOuSubcategoriasImovel, percentualEsgoto,
							consumoTarifaVigenciaColecao, ConstantesSistema.CALCULAR_AGUA, idTarifaTipoCalculo);
				} else {
					calculoSimplesUmaTarifaColecao = calculoSimplesUmaTarifa(consumoFaturado, categoriasOuSubcategoriasImovel, percentualEsgoto,
							consumoTarifaVigenciaColecao, ConstantesSistema.CALCULAR_AGUA, idTarifaTipoCalculo);
				}

			} else {

				if (idTarifaTipoCalculo.intValue() == 4) {
					calculoSimplesUmaTarifaColecao = calculoConsumoDiretoNaFaixa(consumoFaturado, categoriasOuSubcategoriasImovel, percentualEsgoto,
							consumoTarifaVigenciaColecao, ConstantesSistema.CALCULAR_ESGOTO, idTarifaTipoCalculo);
				} else {
					calculoSimplesUmaTarifaColecao = calculoSimplesUmaTarifa(consumoFaturado, categoriasOuSubcategoriasImovel, percentualEsgoto,
							consumoTarifaVigenciaColecao, ConstantesSistema.CALCULAR_ESGOTO, idTarifaTipoCalculo);
				}
			}
			
			// Caso exista próxima tarifa vigente então data da vigência final = CSTV_DTVIGENCIA da próxima tarifa vigente menos um dia,
			// caso contrário, data da vigência final = data de leitura atual
			if (colecaoConsumoTarifaVigenciaListIt.hasNext()) {

				consumoTarifaVigenciaColecao = (ConsumoTarifaVigencia) colecaoConsumoTarifaVigenciaListIt.next();
				colecaoConsumoTarifaVigenciaListIt.previous();

				dataVigenciaFinal = consumoTarifaVigenciaColecao.getDataVigencia();

				// Subtraindo um dia
				Calendar dataVigenciaFinalMenosUmDia = new GregorianCalendar();
				dataVigenciaFinalMenosUmDia.setTime(dataVigenciaFinal);
				dataVigenciaFinalMenosUmDia.add(Calendar.DATE, -1);

				dataVigenciaFinal = dataVigenciaFinalMenosUmDia.getTime();

				if (consumoTarifaVigenciaColecao.getDataVigencia().before(dataLeituraAtual)
						|| consumoTarifaVigenciaColecao.getDataVigencia().equals(dataLeituraAtual)) {
                    dataVigenciaFinal = Util.adicionarNumeroDiasDeUmaData(consumoTarifaVigenciaColecao.getDataVigencia(), -1);
                } else {
                    dataVigenciaFinal = dataLeituraAtual;
                }
			} else {
				if (consumoTarifaVigenciaColecao.getDataVigencia().before(dataLeituraAtual)
						|| consumoTarifaVigenciaColecao.getDataVigencia().equals(dataLeituraAtual)) {
                    dataVigenciaFinal = dataLeituraAtual;
                } else {
                    dataVigenciaFinal = consumoTarifaVigenciaColecao.getDataVigencia();
                }
			}

			// Calcula a quantidade de dias de vigência da tarifa dentro do
			// perído de leitura =
			// data da vigência final - data da vigência inicial + 1 dia
			dataVigenciaInicial = Util.formatarDataSemHora(dataVigenciaInicial);
			dataVigenciaFinal = Util.formatarDataSemHora(dataVigenciaFinal);

			long qtdDiasVigenciaDentroPeriodo = IoUtil.diferencaEntreDatas(dataVigenciaInicial, dataVigenciaFinal);

			if (colecaoConsumoTarifaVigenciaListIt.hasNext()) {
				if (dataVigenciaFinal.after(dataVigenciaInicial) || dataVigenciaFinal.equals(dataVigenciaInicial)) {
					qtdDiasVigenciaDentroPeriodo += 1;
				} else {
					qtdDiasVigenciaDentroPeriodo = 0;
				}
			} else {
				if (dataVigenciaFinal.before(dataLeituraAtual) || dataVigenciaFinal.equals(dataLeituraAtual)) {
					qtdDiasVigenciaDentroPeriodo += 1;
				} else {
					qtdDiasVigenciaDentroPeriodo = 0;
				}
			}
			
			// Calcula o fator de vigência da tarifa =
			// qtdDiasVigenciaDentroPeriodo / qtdDiasLeitura
			// O BigDecimal será arredondado para 4 casas decimais
			BigDecimal qtdDiasVigenciaDentroPeriodoBigDecimal = new BigDecimal(qtdDiasVigenciaDentroPeriodo);
			BigDecimal qtdDiasLeituraBigDecimal = new BigDecimal(qtdDiasLeitura);

			BigDecimal fatorVigenciaTarifa = qtdDiasVigenciaDentroPeriodoBigDecimal.divide(qtdDiasLeituraBigDecimal, 4, BigDecimal.ROUND_HALF_UP);

			// Para cada Categoria, aplica o fator de vigência da tarifa.

			Iterator calculoSimplesUmaTarifaColecaoIt = calculoSimplesUmaTarifaColecao.iterator();
			CalcularValoresAguaEsgotoHelper calculoSimplesUmaTarifaColecaoObjeto;
			BigDecimal valorFaturadoNew, valorTarifaMinimaNew;

			while (calculoSimplesUmaTarifaColecaoIt.hasNext()) {

				calculoSimplesUmaTarifaColecaoObjeto = (CalcularValoresAguaEsgotoHelper) calculoSimplesUmaTarifaColecaoIt.next();

				if (tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)) {

					// Aplicando o fator de vigência da tarifa no valor faturado
					// de água da categoria
					// -----------------------------------------------------------------------------------
					valorFaturadoNew = calculoSimplesUmaTarifaColecaoObjeto.getValorFaturadoAguaCategoria().multiply(fatorVigenciaTarifa);

					// Arredondando para duas casas decimais
					valorFaturadoNew = valorFaturadoNew.setScale(2, BigDecimal.ROUND_HALF_UP);

					calculoSimplesUmaTarifaColecaoObjeto.setValorFaturadoAguaCategoria(valorFaturadoNew);
					// ------------------------------------------------------------------------------------

					// Aplicando o fator de vigência da tarifa no valor da
					// tarifa mínima de água da categoria
					// ------------------------------------------------------------------------------------
					valorTarifaMinimaNew = calculoSimplesUmaTarifaColecaoObjeto.getValorTarifaMinimaAguaCategoria().multiply(fatorVigenciaTarifa);

					// Arredondando para duas casas decimais
					valorTarifaMinimaNew = valorTarifaMinimaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

					calculoSimplesUmaTarifaColecaoObjeto.setValorTarifaMinimaAguaCategoria(valorTarifaMinimaNew);
					// ------------------------------------------------------------------------------------

					// Para cada faixa da tarifa de consumo
					BigDecimal valorFaturadoFaixaNew, valorTarifaFaixaNew;

					Collection calculoSimplesUmaTarifaFaixaColecao = calculoSimplesUmaTarifaColecaoObjeto.getFaixaTarifaConsumo();
					Iterator calculoSimplesUmaTarifaFaixaIt = calculoSimplesUmaTarifaFaixaColecao.iterator();
					CalcularValoresAguaEsgotoFaixaHelper calculoSimplesUmaTarifaFaixaColecaoObjeto;

					while (calculoSimplesUmaTarifaFaixaIt.hasNext()) {

						calculoSimplesUmaTarifaFaixaColecaoObjeto = (CalcularValoresAguaEsgotoFaixaHelper) calculoSimplesUmaTarifaFaixaIt.next();

						// Aplicando o fator de vigência da tarifa no valor
						// faturado de água na faixa
						// -----------------------------------------------------------------------------------
						valorFaturadoFaixaNew = calculoSimplesUmaTarifaFaixaColecaoObjeto.getValorFaturadoAguaFaixa().multiply(fatorVigenciaTarifa);

						// Arredondando para duas casas decimais
						valorFaturadoFaixaNew = valorFaturadoFaixaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

						calculoSimplesUmaTarifaFaixaColecaoObjeto.setValorFaturadoAguaFaixa(valorFaturadoFaixaNew);
						// ------------------------------------------------------------------------------------

						// Aplicando o fator de vigência da tarifa no valor da
						// tarifa na faixa
						// ------------------------------------------------------------------------------------

						valorTarifaFaixaNew = calculoSimplesUmaTarifaFaixaColecaoObjeto.getValorTarifaFaixa().multiply(fatorVigenciaTarifa);

						// Arredondando para duas casas decimais
						valorTarifaFaixaNew = valorTarifaFaixaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

						calculoSimplesUmaTarifaFaixaColecaoObjeto.setValorTarifaFaixa(valorTarifaFaixaNew);
						// ------------------------------------------------------------------------------------

					}
				} else {

					// Aplicando o fator de vigência da tarifa no valor faturado
					// de esgoto da categoria
					// -----------------------------------------------------------------------------------
					valorFaturadoNew = calculoSimplesUmaTarifaColecaoObjeto.getValorFaturadoEsgotoCategoria().multiply(fatorVigenciaTarifa);

					// Arredondando para duas casas decimais
					valorFaturadoNew = valorFaturadoNew.setScale(2, BigDecimal.ROUND_HALF_UP);

					calculoSimplesUmaTarifaColecaoObjeto.setValorFaturadoEsgotoCategoria(valorFaturadoNew);
					// ------------------------------------------------------------------------------------

					// Aplicando o fator de vigência da tarifa no valor da
					// tarifa mínima de esgoto da categoria
					// ------------------------------------------------------------------------------------
					valorTarifaMinimaNew = calculoSimplesUmaTarifaColecaoObjeto.getValorTarifaMinimaEsgotoCategoria().multiply(fatorVigenciaTarifa);

					// Arredondando para duas casas decimais
					valorTarifaMinimaNew = valorTarifaMinimaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

					calculoSimplesUmaTarifaColecaoObjeto.setValorTarifaMinimaEsgotoCategoria(valorTarifaMinimaNew);
					// ------------------------------------------------------------------------------------

					// Para cada faixa da tarifa de consumo
					BigDecimal valorFaturadoFaixaNew, valorTarifaFaixaNew;

					Collection calculoSimplesUmaTarifaFaixaColecao = calculoSimplesUmaTarifaColecaoObjeto.getFaixaTarifaConsumo();
					Iterator calculoSimplesUmaTarifaFaixaIt = calculoSimplesUmaTarifaFaixaColecao.iterator();
					CalcularValoresAguaEsgotoFaixaHelper calculoSimplesUmaTarifaFaixaColecaoObjeto;

					while (calculoSimplesUmaTarifaFaixaIt.hasNext()) {

						calculoSimplesUmaTarifaFaixaColecaoObjeto = (CalcularValoresAguaEsgotoFaixaHelper) calculoSimplesUmaTarifaFaixaIt.next();

						// Aplicando o fator de vigência da tarifa no valor
						// faturado de esgoto na faixa
						// -----------------------------------------------------------------------------------
						valorFaturadoFaixaNew = calculoSimplesUmaTarifaFaixaColecaoObjeto.getValorFaturadoEsgotoFaixa().multiply(fatorVigenciaTarifa);

						// Arredondando para duas casas decimais
						valorFaturadoFaixaNew = valorFaturadoFaixaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

						calculoSimplesUmaTarifaFaixaColecaoObjeto.setValorFaturadoEsgotoFaixa(valorFaturadoFaixaNew);
						// ------------------------------------------------------------------------------------

						// Aplicando o fator de vigência da tarifa no valor da
						// tarifa na faixa
						// ------------------------------------------------------------------------------------
						valorTarifaFaixaNew = calculoSimplesUmaTarifaFaixaColecaoObjeto.getValorTarifaFaixa().multiply(fatorVigenciaTarifa);

						// Arredondando para duas casas decimais
						valorTarifaFaixaNew = valorTarifaFaixaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

						calculoSimplesUmaTarifaFaixaColecaoObjeto.setValorTarifaFaixa(valorTarifaFaixaNew);
						// ------------------------------------------------------------------------------------

					}
				}

			}

			// Calcula data de vigência inicial = data da vigência final + 1 dia

			// Adicionando um dia para data da vigência final
			Calendar dataVigenciaFinalMaisUmDia = new GregorianCalendar();
			dataVigenciaFinalMaisUmDia.setTime(dataVigenciaFinal);
			dataVigenciaFinalMaisUmDia.add(Calendar.DATE, 1);

			if (dataVigenciaFinal.before(dataLeituraAnterior)) {
				dataVigenciaInicial = dataLeituraAnterior;
			} else {
				dataVigenciaInicial = dataVigenciaFinalMaisUmDia.getTime();;
			}

			// Acumulando os valores calculados
			colecaoRetorno.addAll(calculoSimplesUmaTarifaColecao);

		}

		return colecaoRetorno;

	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto - CAER
	 * 
	 * [SF0001] - Cálculo Simples Para Uma Única Tarifa
	 * 
	 * @author Raphael Rossiter
	 * @date 19/10/2006
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorFaturadoFaixaCAER(Integer consumoFaturado,
			BigDecimal valorTarifaMinimaCategoria, BigDecimal valorTarifaFaixa) {

		// Legenda: x = consumoFaturado; NI = valorTarifaMinima

		BigDecimal retorno = new BigDecimal("0");

		Integer CONSUMO_SUPERIOR = 201;

		// Consumidores Taxados
		if (consumoFaturado < CONSUMO_SUPERIOR) {

			BigDecimal divisor = new BigDecimal("10000");
			BigDecimal multiplicadorExp = new BigDecimal("7");

			// NI
			if (consumoFaturado <= 10) {
				retorno = valorTarifaMinimaCategoria;
			}
			// NI(7x² + valorTarifaFaixa * x) / 10000
			else {

				BigDecimal parcial = new BigDecimal(consumoFaturado
						* consumoFaturado);
				parcial = parcial.multiply(multiplicadorExp);

				BigDecimal parcial2 = valorTarifaFaixa.multiply(new BigDecimal(
						consumoFaturado));

				BigDecimal parcialFinal = parcial.add(parcial2);

				parcialFinal = valorTarifaMinimaCategoria
						.multiply(parcialFinal);

				retorno = parcialFinal.divide(divisor);
			}
		}
		// Consumo Superior = NI(valorTarifaFaixa * x - 11,2)
		else {

			BigDecimal valor1 = new BigDecimal("11.2");

			BigDecimal parcial = valorTarifaFaixa.multiply(new BigDecimal(
					consumoFaturado));
			parcial = parcial.subtract(valor1);

			retorno = valorTarifaMinimaCategoria.multiply(parcial);
		}

		return retorno;
	}

	/**
	 * Método utilizada para facilitar a implementação do [UC0120 - Calcular
	 * Valores de Água e/ou Esgoto]. Seleciona as tarifas vigentes para o imóvel
	 * no período de leitura. OBS - O campo tipoConsulta será utilizada para
	 * distinguir de que forma será realiza a consulta, ou seja, quais os
	 * parâmetros que serão utilizados. Legenda: Parcial = true , Final = false
	 * 
	 * @param tarifaImovel
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @param tipoConsulta
	 * @return
	 */
	protected Collection selecionaTarifasVigentesPeriodoLeituraImovel(
			Integer tarifaImovel, Date dataLeituraAnterior,
			Date dataLeituraAtual, boolean tipoConsulta)
			throws ControladorException {

		Collection retorno = new ArrayList();

		ConsumoTarifa consumoTarifa = new ConsumoTarifa();
		consumoTarifa.setId(tarifaImovel);

		/*
		 * Seleciona todas as ocorrências da tabela CONSUMO_TARIFA_VIGENCIA com
		 * CSTF_ID=Id da tarifa para o imóvel e com CSTV_DTVIGENCIA entre as
		 * datas de leitura anterior e atual, inclusive
		 */
		if (tipoConsulta) {

			try {

				// Pesquisar pela data de vigência ordenada com parametro
				// conforme descritivo acima
				Collection colecaoConsumoTarifaVigencia = repositorioFaturamento
						.pesquisarConsumoTarifaVigenciaEntreDataLeituraAnterioreDataLeituraAtual(
								consumoTarifa, dataLeituraAnterior,
								dataLeituraAtual);
				retorno = colecaoConsumoTarifaVigencia;
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Seleciona a ocorrência da tabela CONSUMO_TARIFA_VIGENCIA com
		 * CSTF_ID=Id da tarifa para o imóvel e com a maior CSTV_DTVIGENCIA que
		 * seja menor que a data de leitura anterior
		 */
		else {

			Collection colecaoConsumoTarifaVigencia = null;

			try {
				colecaoConsumoTarifaVigencia = repositorioFaturamento
						.pesquisarConsumoTarifaVigenciaMenorDataLeituraAnterior(
								consumoTarifa, dataLeituraAnterior);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			ConsumoTarifaVigencia consumoTarifaVigencia = obterConsumoTarifaVigencia(colecaoConsumoTarifaVigencia);

			if (consumoTarifaVigencia != null) {
				retorno.add(consumoTarifaVigencia);
			}

		}

		return retorno;
	}

	/*
	 * Recebe uma coleção e retorna o objeto ConsumoTarifaVigência com id e data
	 * de vigência setados Autor: Leonardo Vieira Data: 27/12/2005
	 */

	public ConsumoTarifaVigencia obterConsumoTarifaVigencia(
			Collection colecaoConsumoTarifaVigencia) {

		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		boolean parametrNulo = true;

		if (colecaoConsumoTarifaVigencia != null
				&& !colecaoConsumoTarifaVigencia.isEmpty()) {

			Object[] consumoTarifaVigenciaArray = (Object[]) Util
					.retonarObjetoDeColecaoArray(colecaoConsumoTarifaVigencia);

			// Seta o id do consumo tarifa vigência
			if (consumoTarifaVigenciaArray[0] != null) {
				consumoTarifaVigencia
						.setId((Integer) consumoTarifaVigenciaArray[0]);
				parametrNulo = false;
			}

			// Seta a data de vigência
			if (consumoTarifaVigenciaArray[1] != null) {
				consumoTarifaVigencia
						.setDataVigencia((Date) consumoTarifaVigenciaArray[1]);
				parametrNulo = false;
			}

		}

		if (parametrNulo) {
			consumoTarifaVigencia = null;
		}

		return consumoTarifaVigencia;

	}

	public Date buscarDataLeituraCronograma(Imovel imovel, boolean situacao,
			Integer anoMesReferencia) throws ControladorException {

		Date retorno = null;
		Collection colecaoFaturamentoAtividadeCronograma;

		FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

		/*
		 * Vai buscar o objeto FaturamentoGrupoCronogramaMensal com as
		 * características do imóvel recebido e o anoMes da Conta - Fernanda
		 * Paiva - 19/08/2006
		 */
		FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal = buscarFaturamentoGrupoCronogramaMensal(
				anoMesReferencia, imovel.getQuadra().getRota(), situacao);

		if (faturamentoGrupoCronogramaMensal != null) {

			// Comentado por Raphael Rossiter em 09/05/2007
			/*
			 * throw new ControladorException(
			 * "atencao.nao_realizada_atividade_leitura", null, imovel
			 * .getQuadra().getRota().getFaturamentoGrupo()
			 * .getId().toString());
			 */

			filtroFaturamentoAtividadeCronograma
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID,
							faturamentoGrupoCronogramaMensal.getId()));

			/*
			 * FTAT_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA com o valor
			 * correspondente a leitura
			 */
			filtroFaturamentoAtividadeCronograma
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID,
							FaturamentoAtividade.EFETUAR_LEITURA));

			colecaoFaturamentoAtividadeCronograma = getControladorUtil()
					.pesquisar(filtroFaturamentoAtividadeCronograma,
							FaturamentoAtividadeCronograma.class.getName());

			if (colecaoFaturamentoAtividadeCronograma != null
					&& !colecaoFaturamentoAtividadeCronograma.isEmpty()) {
				FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
						.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

				if (faturamentoAtividadeCronograma.getDataRealizacao() != null) {
					retorno = faturamentoAtividadeCronograma
							.getDataRealizacao();
				}
			}
		}

		return retorno;
	}

	/**
	 * Realiza uma pesquisa na tabela Faturamento_Grupo_Cronograma_Mensal de
	 * acordo com os dados recebidos (mês e ano de referencia anterior).
	 * 
	 * @param anoMesReferencia
	 * @param rota
	 * @return um objeto do tipo FaturamentoGrupoCronogramaMensal
	 */
	protected FaturamentoGrupoCronogramaMensal buscarFaturamentoGrupoCronogramaMensal(
			Integer anoMesReferencia, Rota rota, boolean situacao)
			throws ControladorException {

		Collection colecaoFaturamentoGrupoCronogramaMensal;
		FaturamentoGrupoCronogramaMensal retorno = null;

		FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

		/* Passa como parâmetro o id do objeto FaturamentoGrupo que está na Rota */
		filtroFaturamentoGrupoCronogramaMensal
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO,
						rota.getFaturamentoGrupo().getId()));

		// Ano e mês de referência - 1 MÊS (Testar este método)
		if (situacao) {
			int anoMesReferenciaAnterior = Util.subtrairData(anoMesReferencia
					.intValue());

			filtroFaturamentoGrupoCronogramaMensal
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA,
							new Integer(anoMesReferenciaAnterior)));
		} else {
			filtroFaturamentoGrupoCronogramaMensal
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA,
							anoMesReferencia));
		}

		colecaoFaturamentoGrupoCronogramaMensal = getControladorUtil()
				.pesquisar(filtroFaturamentoGrupoCronogramaMensal,
						FaturamentoGrupoCronogramaMensal.class.getName());

		if (colecaoFaturamentoGrupoCronogramaMensal != null
				&& !colecaoFaturamentoGrupoCronogramaMensal.isEmpty()) {
			retorno = (FaturamentoGrupoCronogramaMensal) Util
					.retonarObjetoDeColecao(colecaoFaturamentoGrupoCronogramaMensal);
		}

		return retorno;
	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [FS0003] - Verificar
	 * existência do cronograma para o grupo Verifica a existência de cronograma
	 * para o grupo de faturamento
	 * 
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	public void verificarExistenciaCronogramaGrupo(
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		Collection colecaoPesquisa;

		FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

		filtroFaturamentoGrupoCronogramaMensal
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO,
						faturamentoGrupo.getId()));

		filtroFaturamentoGrupoCronogramaMensal
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA,
						faturamentoGrupo.getAnoMesReferencia()));

		colecaoPesquisa = getControladorUtil().pesquisar(
				filtroFaturamentoGrupoCronogramaMensal,
				FaturamentoGrupoCronogramaMensal.class.getName());

		if (colecaoPesquisa == null || colecaoPesquisa.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.pesquisa.cronograma_mensal_grupo_inexistente");
		}
	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [FS0008] - Verificar
	 * existência da atividade no cronograma do grupo do mês corrente
	 * 
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	public boolean verificarExistenciaCronogramaAtividadeGrupo(
			FaturamentoAtividade faturamentoAtividade,
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		boolean retorno = false;

		Collection colecaoPesquisa;

		FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

		filtroFaturamentoAtividadeCronograma
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID,
						faturamentoAtividade.getId()));

		filtroFaturamentoAtividadeCronograma
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
						faturamentoGrupo.getId()));

		filtroFaturamentoAtividadeCronograma
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
						faturamentoGrupo.getAnoMesReferencia()));

		colecaoPesquisa = getControladorUtil().pesquisar(
				filtroFaturamentoAtividadeCronograma,
				FaturamentoAtividadeCronograma.class.getName());

		/*
		 * if (colecaoPesquisa == null || colecaoPesquisa.isEmpty()) {
		 * sessionContext.setRollbackOnly(); throw new ControladorException(
		 * "atencao.pesquisa.cronograma_atividade_mensal_grupo_inexistente"); }
		 */

		if (!Util.isVazioOrNulo(colecaoPesquisa)) {
			retorno = true;
		}

		return retorno;

	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [SB0001] - Selecionar
	 * Atividade de Faturamento O sistema seleciona as atividades que podem ser
	 * comandadas
	 * 
	 * @return uma coleção de atividades de faturamento
	 * @throws ControladorException
	 */
	public Collection selecionarAtividadeFaturamentoQuePodeSerComandada(
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {
		Collection retorno = new Vector();

		FiltroFaturamentoAtividade filtroFaturamentoAtividade = new FiltroFaturamentoAtividade(
				FiltroFaturamentoAtividade.DESCRICAO);

		filtroFaturamentoAtividade
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividade.INDICADOR_POSSIBILIDADE_COMANDO_ATIVIDADE,
						FaturamentoAtividade.ATIVIDADE_POSSIVEL_COMANDO));

		filtroFaturamentoAtividade.adicionarParametro(new ParametroSimples(
				FiltroFaturamentoAtividade.INDICADOR_USO,
				ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection colecaoFaturamentoAtividade;

		colecaoFaturamentoAtividade = getControladorUtil().pesquisar(
				filtroFaturamentoAtividade,
				FaturamentoAtividade.class.getName());

		// [FS0001] - Verificar existência de dados
		if (colecaoFaturamentoAtividade == null
				|| colecaoFaturamentoAtividade.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.pesquisa.nenhum_registro_tabela", null,
					"FATURAMENTO_ATIVIDADE");
		} else {
			FaturamentoAtividade faturamentoAtividade;
			Iterator colecaoFaturamentoAtividadeIterator = colecaoFaturamentoAtividade
					.iterator();

			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
			Collection colecaoFaturamentoAtividadeCronograma;
			FaturamentoAtividadeCronograma faturamentoAtividadeCronograma;

			boolean atividadeSelecao;
			while (colecaoFaturamentoAtividadeIterator.hasNext()) {
				atividadeSelecao = false;
				faturamentoAtividade = (FaturamentoAtividade) colecaoFaturamentoAtividadeIterator
						.next();

				// 1º Etapa
				// ==========================================================
				/*
				 * Possa ser repetida (FTAT_ICREPETICAO=1) ou não tenha sido
				 * realizada no cronograma do mês de faturamento
				 * (FTAC_DTREALIZADA com o valor nulo na tabela
				 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=FTAT_ID da
				 * tabela FATURAMENTO_ATIVIDADE e FTCM_ID=FTCM_ID da tabela
				 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com
				 * FTCM_AMREFERENCIA=FTGR_AMREFERENCIA e FTGR_ID= Grupo de
				 * faturamento selecionado).
				 * ==========================================================
				 */

				if (faturamentoAtividade
						.getIndicadorPossibilidadeRepeticaoAtividade() != null
						&& faturamentoAtividade
								.getIndicadorPossibilidadeRepeticaoAtividade()
								.equals(FaturamentoAtividade.ATIVIDADE_POSSIVEL_REPETICAO)) {
					atividadeSelecao = true;
				} else {
					filtroFaturamentoAtividadeCronograma
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID,
									faturamentoAtividade.getId()));

					filtroFaturamentoAtividadeCronograma
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
									faturamentoGrupo.getId()));

					filtroFaturamentoAtividadeCronograma
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
									faturamentoGrupo.getAnoMesReferencia()));

					colecaoFaturamentoAtividadeCronograma = getControladorUtil()
							.pesquisar(
									filtroFaturamentoAtividadeCronograma,
									FaturamentoAtividadeCronograma.class
											.getName());

					if (colecaoFaturamentoAtividadeCronograma != null
							&& !colecaoFaturamentoAtividadeCronograma.isEmpty()) {
						faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
								.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

						if (faturamentoAtividadeCronograma.getDataRealizacao() == null) {
							atividadeSelecao = true;
						}

						colecaoFaturamentoAtividadeCronograma.clear();
					}

					filtroFaturamentoAtividadeCronograma
							.limparListaParametros();
				}

				// 2º Etapa
				// ==========================================================
				/*
				 * Não tenha atividade predecessora
				 * (FTAT_IDATIVIDADEPRECEDENTE=nulo) ou tenha predecessora já
				 * realizada (FTAC_DTREALIZADA com o valor preenchido na tabela
				 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=
				 * FTAT_IDATIVIDADEPRECEDENTE e FTCM_ID=FTCM_ID da tabela
				 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com
				 * FTCM_AMREFERENCIA=FTGR_AMREFERENCIA e FTGR_ID= Grupo de
				 * faturamento selecionado).
				 * ====================================
				 * ===============================
				 */

				if (atividadeSelecao) {
					atividadeSelecao = false;

					if (faturamentoAtividade
							.getFaturamentoAtividadePrecedente() == null) {
						atividadeSelecao = true;
					} else {
						filtroFaturamentoAtividadeCronograma
								.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID,
										faturamentoAtividade
												.getFaturamentoAtividadePrecedente()
												.getId()));

						filtroFaturamentoAtividadeCronograma
								.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
										faturamentoGrupo.getId()));

						filtroFaturamentoAtividadeCronograma
								.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
										faturamentoGrupo.getAnoMesReferencia()));

						colecaoFaturamentoAtividadeCronograma = getControladorUtil()
								.pesquisar(
										filtroFaturamentoAtividadeCronograma,
										FaturamentoAtividadeCronograma.class
												.getName());

						if (colecaoFaturamentoAtividadeCronograma != null
								&& !colecaoFaturamentoAtividadeCronograma
										.isEmpty()) {
							faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
									.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

							if (faturamentoAtividadeCronograma
									.getDataRealizacao() != null) {
								atividadeSelecao = true;
							}

							colecaoFaturamentoAtividadeCronograma.clear();
						}

						filtroFaturamentoAtividadeCronograma
								.limparListaParametros();
					}

					// 3º Etapa
					// ===================================================================
					/*
					 * A atividade de faturamento esteja no cronograma de
					 * faturamento para o grupo no mês corrente (existe
					 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID = FTAT_ID
					 * da tabela FATURAMENTO_ATIVIDADE e FTCM_ID = FTCM_ID da
					 * tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL)
					 * ==============
					 * =====================================================
					 */
					if (atividadeSelecao) {
						atividadeSelecao = false;

						if (this.verificarExistenciaCronogramaAtividadeGrupo(
								faturamentoAtividade, faturamentoGrupo)) {
							atividadeSelecao = true;
						}

					}

					/*
					 * Adiciona o objeto do tipo FaturamentoAtividade na coleção
					 * de retorno, caso o mesmo tenha passado pelas duas etapas
					 */
					if (atividadeSelecao) {
						retorno.add(faturamentoAtividade);
					}

				}

				// FIM DO LOOP

			}

		}

		// [FS0002] - Verificar seleção de pelo menos uma Atividade de
		// Faturamento
		if (retorno == null || retorno.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.pesquisa.nenhuma.atividade_faturamento_grupo");
		}

		return retorno;
	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [FS0006] - Verificar
	 * existência de rotas para o grupo Verifica a existência de rotas para o
	 * grupo de faturamento
	 * 
	 * @param faturamentoGrupo
	 * 
	 * @return uma coleção de rotas pertencentes ao grupo selecionado
	 * @throws ControladorException
	 */
	public Collection verificarExistenciaRotaGrupo(
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		Collection colecaoPesquisa = null;

		FiltroRota filtroRota = new FiltroRota();

		// Retornará todas as ocorrências encontradas
		filtroRota.setConsultaSemLimites(true);

		filtroRota.setCampoOrderBy(FiltroRota.FATURAMENTO_GRUPO_ID,
				FiltroRota.GERENCIA_REGIONAL_NOME_ABREVIADO,
				FiltroRota.LOCALIDADE_DESCRICAO,
				FiltroRota.SETOR_COMERCIAL_CODIGO, FiltroRota.ID_ROTA);

		/**
		 * alterado por pedro alexandre dia 22/01/2007
		 */
		filtroRota
				.adicionarCaminhoParaCarregamentoEntidade(FiltroRota.UNIDADE_NEGOCIO);
		/*
		 * filtroRota .adicionarCaminhoParaCarregamentoEntidade(FiltroRota.
		 * UNIDADE_NEGOCIO_NOME_ABREVIADO);
		 */

		// Objetos que serão retornados pelo hibernate
		filtroRota
				.adicionarCaminhoParaCarregamentoEntidade("setorComercial.localidade.gerenciaRegional");

		filtroRota.adicionarParametro(new ParametroSimples(
				FiltroRota.FATURAMENTO_GRUPO_ID, faturamentoGrupo.getId()));

		filtroRota
				.adicionarParametro(new ParametroSimples(
						FiltroRota.INDICADOR_USO,
						ConstantesSistema.INDICADOR_USO_ATIVO));

		colecaoPesquisa = getControladorUtil().pesquisar(filtroRota,
				Rota.class.getName());

		if (colecaoPesquisa == null || colecaoPesquisa.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.pesquisa.rota_grupo_inexistente");
		}

		return colecaoPesquisa;
	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [SB0002] - Verificar
	 * Situação da Atividade para a Rota
	 * 
	 * @return uma coleção de rotas
	 */
	public Collection verificarSituacaoAtividadeRota(
			Collection colecaoRotasGrupo,
			FaturamentoAtividade faturamentoAtividade,
			FaturamentoGrupo faturamentoGrupo, boolean habilitada)
			throws ControladorException {
		Collection retorno = new Vector();

		Collection rotasHabilitadas = new Vector();
		Collection rotasNaoHabilitadas = new Vector();

		Rota rota;
		Iterator colecaoRotasGrupoIterator = colecaoRotasGrupo.iterator();

		FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();

		filtroFaturamentoAtivCronRota.setCampoOrderBy(
				FiltroFaturamentoAtivCronRota.FATURAMENTO_GRUPO_ID,
				FiltroFaturamentoAtivCronRota.GERENCIA_REGIONAL_NOME_ABREVIADO,
				FiltroFaturamentoAtivCronRota.LOCALIDADE_DESCRICAO,
				FiltroFaturamentoAtivCronRota.SETOR_COMERCIAL_CODIGO,
				FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_ID);

		filtroFaturamentoAtivCronRota
				.adicionarCaminhoParaCarregamentoEntidade(FiltroFaturamentoAtivCronRota.UNIDADE_NEGOCIO);

		filtroFaturamentoAtivCronRota.setConsultaSemLimites(true);

		Collection colecaoFaturamentoAtividadeCronogramaRota;

		boolean rotaHabilitada;
		while (colecaoRotasGrupoIterator.hasNext()) {
			rotaHabilitada = false;
			rota = (Rota) colecaoRotasGrupoIterator.next();

			// 1º Etapa
			// ==========================================================
			/*
			 * Caso a atividade possa ser repetida (FTAT_ICREPETICAO=1) ou não
			 * tenha sido realizada no mês de faturamento para a rota (inexiste
			 * ROTA_ID=rota selecionada na tabela FATURAMENTO_ATIV_CRON_ROTA
			 * para FTAC_ID=FTAC_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA
			 * com FTAT_ID=Atividade a ser comandada para FTCM_ID=FTCM_ID da
			 * tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com FTCM_AMREFERENCIA=
			 * FTGR_AMREFERENCIA)
			 * ================================================
			 * ===================
			 */

			if (faturamentoAtividade
					.getIndicadorPossibilidadeRepeticaoAtividade() != null
					&& faturamentoAtividade
							.getIndicadorPossibilidadeRepeticaoAtividade()
							.equals(FaturamentoAtividade.ATIVIDADE_POSSIVEL_REPETICAO)) {
				rotaHabilitada = true;
			} else {
				filtroFaturamentoAtivCronRota
						.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_ID,
								rota.getId()));

				filtroFaturamentoAtivCronRota
						.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_ATIVIDADE_ID,
								faturamentoAtividade.getId()));

				filtroFaturamentoAtivCronRota
						.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
								faturamentoGrupo.getAnoMesReferencia()));

				colecaoFaturamentoAtividadeCronogramaRota = getControladorUtil()
						.pesquisar(filtroFaturamentoAtivCronRota,
								FaturamentoAtivCronRota.class.getName());

				if (colecaoFaturamentoAtividadeCronogramaRota == null
						|| colecaoFaturamentoAtividadeCronogramaRota.isEmpty()) {
					rotaHabilitada = true;
					colecaoFaturamentoAtividadeCronogramaRota.clear();
				}

				filtroFaturamentoAtivCronRota.limparListaParametros();

			}

			// 2º Etapa
			// ==========================================================
			/*
			 * Não tenha atividade predecessora
			 * (FTAT_IDATIVIDADEPRECEDENTE=nulo) ou tenha predecessora já
			 * realizada (FTAC_DTREALIZADA com o valor preenchido na tabela
			 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=
			 * FTAT_IDATIVIDADEPRECEDENTE e FTCM_ID=FTCM_ID da tabela
			 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com
			 * FTCM_AMREFERENCIA=FTGR_AMREFERENCIA e FTGR_ID= Grupo de
			 * faturamento selecionado).
			 * ========================================
			 * ===========================
			 */

			if (rotaHabilitada) {
				rotaHabilitada = false;

				if (faturamentoAtividade.getFaturamentoAtividadePrecedente() == null) {
					rotaHabilitada = true;
				} else {

					// Objeto que será retornado pelo hibernate
					filtroFaturamentoAtivCronRota
							.adicionarCaminhoParaCarregamentoEntidade("faturamentoAtividadeCronograma");

					filtroFaturamentoAtivCronRota
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_ID,
									rota.getId()));

					filtroFaturamentoAtivCronRota
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_ATIVIDADE_ID,
									faturamentoAtividade
											.getFaturamentoAtividadePrecedente()
											.getId()));

					filtroFaturamentoAtivCronRota
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
									faturamentoGrupo.getAnoMesReferencia()));

					colecaoFaturamentoAtividadeCronogramaRota = getControladorUtil()
							.pesquisar(filtroFaturamentoAtivCronRota,
									FaturamentoAtivCronRota.class.getName());

					if (colecaoFaturamentoAtividadeCronogramaRota != null
							&& !colecaoFaturamentoAtividadeCronogramaRota
									.isEmpty()) {
						FaturamentoAtivCronRota faturamentoAtivCronRota = (FaturamentoAtivCronRota) Util
								.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRota);

						if (faturamentoAtivCronRota
								.getFaturamentoAtividadeCronograma()
								.getDataRealizacao() != null) {
							rotaHabilitada = true;
						}

						colecaoFaturamentoAtividadeCronogramaRota.clear();
					}

					filtroFaturamentoAtivCronRota.limparListaParametros();

				}

				/*
				 * Adiciona o objeto do tipo Rota na coleção de retorno e de
				 * acordo com a sua situação
				 */
				if (rotaHabilitada) {
					rotasHabilitadas.add(rota);
				} else {
					rotasNaoHabilitadas.add(rota);
				}
			} else {
				// Adiciona a rota na coleção das não habilitadas
				rotasNaoHabilitadas.add(rota);
			}

			// FIM DO LOOP
		}

		// Define a coleção de retorno (rotas habilitadas ou rotas não
		// habilitadas)
		if (habilitada) {
			retorno.addAll(rotasHabilitadas);
		} else {
			retorno.addAll(rotasNaoHabilitadas);
		}

		return retorno;
	}

	/**
	 * 
	 * @param faturamentoGrupo
	 * @param faturamentoAtividade
	 * @param colecaoRotas
	 * @param dataVencimentoGrupo
	 * @throws ControladorException
	 */
	public Integer inserirComandoAtividadeFaturamento(
			FaturamentoGrupo faturamentoGrupo,
			FaturamentoAtividade faturamentoAtividade, Collection colecaoRotas,
			Date dataVencimentoGrupo, Usuario usuarioLogado)
			throws ControladorException {

		/*
		 * Atualiza a data e hora do comando (FTAC_TMCOMANDO=CURRENT TIMESTAMP)
		 * na tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=Atividade a
		 * ser comandada e FTCM_ID=FTCM_ID da tabela
		 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL para FTGR_ID=Grupo selecionado e
		 * FTCM_AMREFERENCIA=FTGR_AMREFERENCIA da tabela FATURAMENTO_GRUPO para
		 * FTGR_ID=Grupo selecionado
		 * =====================================================================
		 */
		Collection colecaoFaturamentoAtividadeCronograma;

		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma;

		Integer faturamentoAtividadeCronogramaId = null;

		FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

		filtroFaturamentoAtividadeCronograma
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID,
						faturamentoAtividade.getId()));

		filtroFaturamentoAtividadeCronograma
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
						faturamentoGrupo.getId()));

		filtroFaturamentoAtividadeCronograma
				.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
						faturamentoGrupo.getAnoMesReferencia()));

		colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(
				filtroFaturamentoAtividadeCronograma,
				FaturamentoAtividadeCronograma.class.getName());

		if (colecaoFaturamentoAtividadeCronograma != null
				&& !colecaoFaturamentoAtividadeCronograma.isEmpty()) {

			faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
					.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

			faturamentoAtividadeCronograma.setComando(new Date());

			faturamentoAtividadeCronogramaId = faturamentoAtividadeCronograma
					.getId();

			faturamentoAtividadeCronograma.setDataRealizacao(null);

			faturamentoAtividadeCronograma.setUsuario(usuarioLogado);

			this.atualizarFaturamentoAtividadeCronograma(faturamentoAtividadeCronograma);

			/*
			 * Exclui todas as rotas na tabela FATURAMENTO_ATIV_CRON_ROTA para F
			 * TAC_ID=FTAC_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA
			 * atualizada
			 */
			try {
				repositorioFaturamento
						.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma
								.getId());
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
			// ====================================================================

			/*
			 * Inclui as rotas habilitadas do grupo na tabela
			 * FATURAMENTO_ATIV_CRON_ROTA para FTAC_ID=FTAC_ID da tabela
			 * FATURAMENTO_ATIVIDADE_CRONOGRAMA atualizada , ROTA_ID=Rota
			 * selecionada e FACR_DTCONTAVENCIMENTO com a data de vencimento do
			 * grupo caso a atividade de faturamento selecionada corresponda à
			 * atividade faturar grupo; caso contrário, com o valor null.
			 */
			FaturamentoAtivCronRotaPK faturamentoAtividadeCronogramaRotaPK = new FaturamentoAtivCronRotaPK();

			faturamentoAtividadeCronogramaRotaPK
					.setFaturamentoAtividadeCronogramaId(faturamentoAtividadeCronograma
							.getId());

			Iterator colecaoRotasIterator = colecaoRotas.iterator();
			Rota rotaColecao;

			FaturamentoAtivCronRota faturamentoAtividadeCronogramaRota = new FaturamentoAtivCronRota();

			faturamentoAtividadeCronogramaRota
					.setDataContaVencimento(dataVencimentoGrupo);

			while (colecaoRotasIterator.hasNext()) {
				rotaColecao = (Rota) colecaoRotasIterator.next();
				faturamentoAtividadeCronogramaRotaPK.setRotaId(rotaColecao
						.getId());

				faturamentoAtividadeCronogramaRota
						.setComp_id(faturamentoAtividadeCronogramaRotaPK);

				faturamentoAtividadeCronogramaRota
						.setUltimaAlteracao(new Date());

				getControladorUtil()
						.inserir(faturamentoAtividadeCronogramaRota);
			}

		}

		return faturamentoAtividadeCronogramaId;
	}

	public void atualizarComandoAtividadeFaturamento(
			FaturamentoAtividadeCronograma faturamentoAtividadeCronograma,
			Collection colecaoFaturamentoAtividadeCronogramaRota)
			throws ControladorException {

		/*
		 * Exclui todas as rotas na tabela FATURAMENTO_ATIV_CRON_ROTA para F
		 * TAC_ID=FTAC_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA atualizada
		 * ====================================================================
		 */
		try {
			repositorioFaturamento
					.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma
							.getId());
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		// ====================================================================

		/*
		 * Inclui as rotas habilitadas do grupo na tabela
		 * FATURAMENTO_ATIV_CRON_ROTA para FTAC_ID=FTAC_ID da tabela
		 * FATURAMENTO_ATIVIDADE_CRONOGRAMA atualizada , ROTA_ID=Rota
		 * selecionada e FACR_DTCONTAVENCIMENTO com a data de vencimento do
		 * grupo caso a atividade de faturamento selecionada corresponda à
		 * atividade faturar grupo; caso contrário, com o valor null.
		 */

		Iterator colecaoFaturamentoAtividadeCronogramaRotaIterator = colecaoFaturamentoAtividadeCronogramaRota
				.iterator();

		FaturamentoAtivCronRota faturamentoAtividadeCronogramaRota = null;

		while (colecaoFaturamentoAtividadeCronogramaRotaIterator.hasNext()) {
			faturamentoAtividadeCronogramaRota = (FaturamentoAtivCronRota) colecaoFaturamentoAtividadeCronogramaRotaIterator
					.next();
			faturamentoAtividadeCronogramaRota.setUltimaAlteracao(new Date());

			getControladorUtil().inserir(faturamentoAtividadeCronogramaRota);
		}

	}

	/**
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * 
	 * Retorna uma lista de atividades de faturamento comandadas e ainda não
	 * realizadas
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection buscarAtividadeComandadaNaoRealizada(Integer numeroPagina)
			throws ControladorException {

		Collection retorno;

		try {
			retorno = this.repositorioFaturamento
					.buscarAtividadeComandadaNaoRealizada(numeroPagina);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (retorno == null || retorno.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.pesquisa.nenhuma.atividade_faturamento_para_atualizacao");
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite alterar ou excluir um comando de atividade de
	 * faturamento
	 * 
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * 
	 * Retorna o count do resultado da pesquisa de Faturamento Atividade
	 * Cronograma não realizadas
	 * 
	 * buscarAtividadeComandadaNaoRealizadaCount
	 * 
	 * @author Roberta Costa
	 * @date 18/07/2006
	 * 
	 * @param filtroFaturamentoAtividadeCronograma
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer buscarAtividadeComandadaNaoRealizadaCount()
			throws ControladorException {

		Integer retorno = null;

		try {
			retorno = this.repositorioFaturamento
					.buscarAtividadeComandadaNaoRealizadaCount();
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	protected ControladorImovelLocal getControladorImovel() {
		ControladorImovelLocalHome localHome = null;
		ControladorImovelLocal local = null;

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorImovelLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_IMOVEL_SEJB);
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	protected ControladorMicromedicaoLocal getControladorMicromedicao() {
		ControladorMicromedicaoLocalHome localHome = null;
		ControladorMicromedicaoLocal local = null;

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorMicromedicaoLocalHome) locator.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_MICROMEDICAO_SEJB);
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	protected ControladorUtilLocal getControladorUtil() {

		ControladorUtilLocalHome localHome = null;
		ControladorUtilLocal local = null;

		ServiceLocator locator = null;
		try {
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorUtilLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_UTIL_SEJB);
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}
	
	protected ControladorRetificarContaLocal getControladorRetificarConta() {

		ControladorRetificarContaLocalHome localHome = null;
		ControladorRetificarContaLocal local = null;

		ServiceLocator locator = null;
		try {
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorRetificarContaLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_RETIFICAR_CONTA);
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	/**
	 * [UC0183 - Inserir Débito A Cobrar]
	 * 
	 * @author Rafael Santos, Pedro Alexandre, Raphael Rossiter
	 * @date 23/12/2005, 21/11/2006, 13/04/2010
	 * 
	 * @param numeroPrestacoes
	 * @param debitoACobrar
	 * @param valorTotalServico
	 * @param imovel
	 * @param percentualAbatimento
	 * @param valorEntrada
	 * @param usuarioLogado
	 * @param debitoParaPagamentoAntecipado
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer inserirDebitoACobrar(Integer numeroPrestacoes,
			DebitoACobrar debitoACobrar, BigDecimal valorTotalServico,
			Imovel imovel, BigDecimal percentualAbatimento,
			BigDecimal valorEntrada, Usuario usuarioLogado,
			boolean debitoParaPagamentoAntecipado) throws ControladorException {

		boolean temPermissaoDebitoACobrar = getControladorPermissaoEspecial()
				.verificarPermissaoInserirDebitoACobrarSemEntradaSemJuros(
						usuarioLogado);

		if (!temPermissaoDebitoACobrar) {
			if (debitoACobrar.getPercentualTaxaJurosFinanciamento() != null) {
				BigDecimal percentualTaxaJurosFinanciamento = this
						.getControladorUtil().pesquisarParametrosDoSistema()
						.getPercentualTaxaJurosFinanciamento();

				// no caso de numero de prestacões == 1 , permitir juros = 0
				if (numeroPrestacoes.intValue() != 1
						|| (debitoACobrar.getPercentualTaxaJurosFinanciamento()
								.compareTo(BigDecimal.ZERO) != 0 && numeroPrestacoes
								.intValue() == 1)) {
					if (debitoACobrar.getPercentualTaxaJurosFinanciamento()
							.compareTo(percentualTaxaJurosFinanciamento) == -1) {
						logger.info("Imóvel com taxa de juros não permitida: " + debitoACobrar.getImovel().getId());
						throw new ControladorException(
								"atencao.taxa_juros.nao.permitida", null,
								(this.getControladorUtil()
										.pesquisarParametrosDoSistema()
										.getPercentualTaxaJurosFinanciamento()
										.toString()).replace(".", ","));
					}
				}
			}
		}

		if (numeroPrestacoes.shortValue() > getControladorUtil()
				.pesquisarParametrosDoSistema()
				.getNumeroMaximoParcelasFinanciamento().shortValue()) {
			throw new ControladorException("atencao.valor_prestacoes", null,
					getControladorUtil().pesquisarParametrosDoSistema()
							.getNumeroMaximoParcelasFinanciamento().toString());
		}

		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.ID, debitoACobrar.getDebitoTipo().getId()));

		Collection colecaoDebitosTipos = getControladorUtil().pesquisar(
				filtroDebitoTipo, DebitoTipo.class.getName());

		DebitoTipo debitoTipo = (DebitoTipo) colecaoDebitosTipos.iterator()
				.next();

		if (debitoACobrar.getValorDebito().compareTo(
				debitoTipo.getValorLimite()) == 1) {
			throw new ControladorException(
					"atencao.debito_a_cobrar.valor_total_servico", null,
					debitoTipo.getValorLimite().toString().replace(".", ","));
		}

		if (percentualAbatimento != null
				&& !(percentualAbatimento.compareTo(new BigDecimal("0.00")) == 0)) {
			if ((imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPRIMIDO)
					| (imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPR_PARC)
					| (imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPR_PARC_PEDIDO)) {

				Collection colecaoCategorias = getControladorImovel()
						.obterQuantidadeEconomiasCategoria(imovel);

				Iterator colecaoCategoriasIterator = colecaoCategorias
						.iterator();

				while (colecaoCategoriasIterator.hasNext()) {
					Categoria categoria = (Categoria) colecaoCategoriasIterator
							.next();
					if (categoria.getId().compareTo(Categoria.RESIDENCIAL) != 0) {
						throw new ControladorException(
								"atencao.imovel.nao_suprimido.categoria.nao_residencial");
					}
				}
			} else {
				throw new ControladorException(
						"atencao.imovel.nao_suprimido.categoria.nao_residencial");
			}

			if (percentualAbatimento.compareTo(getControladorUtil()
					.pesquisarParametrosDoSistema()
					.getPercentualMaximoAbatimento()) == 1) {
				throw new ControladorException(
						"atencao.imovel.percentual_abatimento", null,
						getControladorUtil().pesquisarParametrosDoSistema()
								.getPercentualMaximoAbatimento().toString()
								.replace(".", ","));
			}
		}

		if (valorEntrada != null
				&& valorEntrada.compareTo(valorTotalServico) == 1) {
			throw new ControladorException(
					"atencao.debito_a_cobrar.valor_entrada.valor_total_servico");
		}

		if (!temPermissaoDebitoACobrar) {
			if (valorEntrada != null && numeroPrestacoes.intValue() > 1) {
				BigDecimal parte1 = getControladorUtil()
						.pesquisarParametrosDoSistema()
						.getPercentualFinanciamentoEntradaMinima()
						.divide(new BigDecimal(100));

				if ((valorEntrada.compareTo(valorTotalServico.multiply(parte1)) == -1)) {
					throw new ControladorException(
							"atencao.debito_a_cobrar.valor_entrada", null,
							getControladorUtil().pesquisarParametrosDoSistema()
									.getPercentualFinanciamentoEntradaMinima()
									.toString().replace(".", ",")
									+ "");
				}
			}
		}

		/*
		 * Para geração de débitos relacionados com pagamento antecipado, o
		 * sistema deverá manter as mesmas características do débito que esta
		 * sendo recebido.
		 */
		if (!debitoParaPagamentoAntecipado) {

			SistemaParametro sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			debitoACobrar.setAnoMesReferenciaDebito(null);
			debitoACobrar.setAnoMesCobrancaDebito(sistemaParametro
					.getAnoMesArrecadacao());

			int anoMesReferenciaContabil = sistemaParametro
					.getAnoMesFaturamento();
			int anoMesCorrente = Util.getAnoMesComoInt(new Date());

			if (sistemaParametro.getAnoMesFaturamento() < anoMesCorrente) {
				anoMesReferenciaContabil = anoMesCorrente;
			}

			debitoACobrar.setAnoMesReferenciaContabil(anoMesReferenciaContabil);

			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
			debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
			debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
			debitoACobrar.setParcelamentoGrupo(null);
			debitoACobrar.setUsuario(usuarioLogado);
		}

		DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
		debitoACobrarGeral.setIndicadorHistorico((short) 2);
		debitoACobrarGeral.setUltimaAlteracao(new Date());

		Integer idDebitoGerado = null;

		/**
		 * alterado por pedro alexandre dia 21/11/2006 alteração feita para
		 * acoplar o controle de abrangência de usuário
		 */
		Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

		if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.acesso.negado.abrangencia");
		} else {
			idDebitoGerado = (Integer) getControladorUtil().inserir(
					debitoACobrarGeral);
		}

		debitoACobrarGeral.setId(idDebitoGerado);

		debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);
		debitoACobrar.setId(idDebitoGerado);

		registrarTransacao(debitoACobrar,
				Operacao.OPERACAO_DEBITO_A_COBRAR_INSERIR, imovel,
				usuarioLogado, debitoACobrar.getId());

		getControladorUtil().inserir(debitoACobrar);

		inserirDebitoACobrarCategoria(debitoACobrar, imovel);

		return idDebitoGerado;
	}

	/**
	 * [UC0186 - Calcular Prestação] Author: Rafael Santos Data: 23/12/2005
	 * 
	 * @param taxaJurosFinanciamento
	 *            Taxa de Juros do Financiamento
	 * @param numeroPrestacoes
	 *            Numero de Prestacoes
	 * @param valorTotalServico
	 *            Valor Total de Servico
	 * @param valorEntrada
	 *            Valor de Entrada
	 * @return O valor da Prestacao
	 */
	public ArrayList calcularValorPrestacao(BigDecimal taxaJurosFinanciamento,
			Integer numeroPrestacoes, BigDecimal valorTotalServico,
			BigDecimal valorEntrada, BigDecimal percentualAbatimento,
			String idTipoDebito, BigDecimal valorTotalServicoAParcelar,
			Imovel imovel, Usuario usuario) throws ControladorException {

		ArrayList valores = new ArrayList();

		// -----------------------------------------------------------
		// Verificar permissão especial
		boolean temPermissaoDebitoACobrar = getControladorPermissaoEspecial()
				.verificarPermissaoInserirDebitoACobrarSemEntradaSemJuros(
						usuario);
		// -----------------------------------------------------------

		if (percentualAbatimento != null
				&& !(percentualAbatimento.compareTo(new BigDecimal("0.00")) == 0)) {
			// [FS0011] - Validar percentual de abatimento
			if ((imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPRIMIDO)
					| (imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPR_PARC)
					| (imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPR_PARC_PEDIDO)) {

				// [UC0108] - Obter Quantidade de Economias por Categoria
				Collection colecaoCategorias = getControladorImovel()
						.obterQuantidadeEconomiasCategoria(imovel);

				Iterator colecaoCategoriasIterator = colecaoCategorias
						.iterator();

				while (colecaoCategoriasIterator.hasNext()) {
					Categoria categoria = (Categoria) colecaoCategoriasIterator
							.next();
					if (categoria.getId().compareTo(Categoria.RESIDENCIAL) != 0) {
						throw new ControladorException(
								"atencao.imovel.nao_suprimido.categoria.nao_residencial");
					}
				}
			} else {
				throw new ControladorException(
						"atencao.imovel.nao_suprimido.categoria.nao_residencial");
			}

			// [FS0011] - Validar percentual de abatimento
			if (percentualAbatimento.compareTo(getControladorUtil()
					.pesquisarParametrosDoSistema()
					.getPercentualMaximoAbatimento()) == 1) {
				throw new ControladorException(
						"atencao.imovel.percentual_abatimento", null,
						getControladorUtil().pesquisarParametrosDoSistema()
								.getPercentualMaximoAbatimento().toString()
								.replace(".", ","));
			}
		}

		// validar taxa de juros
		if (!temPermissaoDebitoACobrar) {
			if (taxaJurosFinanciamento != null) {
				BigDecimal percentualTaxaJurosFinanciamento = this
						.getControladorUtil().pesquisarParametrosDoSistema()
						.getPercentualTaxaJurosFinanciamento();

				// no caso de numero de prestacões == 1 , permitir juros = 0
				if (numeroPrestacoes.intValue() != 1
						|| (taxaJurosFinanciamento.compareTo(new BigDecimal(0)) != 0 && numeroPrestacoes
								.intValue() == 1)) {
					if (taxaJurosFinanciamento
							.compareTo(percentualTaxaJurosFinanciamento) == -1) {
						// Taxa de Juros mínima permitida é de 3 casas%
						throw new ControladorException(
								"atencao.taxa_juros.nao.permitida", null,
								(this.getControladorUtil()
										.pesquisarParametrosDoSistema()
										.getPercentualTaxaJurosFinanciamento()
										.toString()).replace(".", ","));
					}
				}
			}
		}

		if (!temPermissaoDebitoACobrar) {
			if (valorEntrada != null && numeroPrestacoes.intValue() > 1) {
				BigDecimal parte1 = getControladorUtil()
						.pesquisarParametrosDoSistema()
						.getPercentualFinanciamentoEntradaMinima()
						.divide(new BigDecimal(100));

				if ((valorEntrada.compareTo(valorTotalServico.multiply(parte1)) == -1)) {
					throw new ControladorException(
							"atencao.debito_a_cobrar.valor_entrada", null,
							(getControladorUtil()
									.pesquisarParametrosDoSistema()
									.getPercentualFinanciamentoEntradaMinima()
									.toString()).replace(".", ",")
									+ "");
				}

			}
		}
		BigDecimal novoValorTotalServico = valorTotalServico;

		if (percentualAbatimento != null && !percentualAbatimento.equals("")) {
			BigDecimal parte1 = Util.dividirArredondando(percentualAbatimento,
					new BigDecimal(100));
			BigDecimal parte2 = parte1.multiply(valorTotalServico);
			novoValorTotalServico = valorTotalServico.subtract(parte2);
		}

		valores.add(valorTotalServico.setScale(2, BigDecimal.ROUND_HALF_UP));

		valorTotalServico = novoValorTotalServico;

		BigDecimal valorPrestacao = this.calcularPrestacao(
				taxaJurosFinanciamento, numeroPrestacoes, valorTotalServico,
				valorEntrada);
		valores.add(valorPrestacao.setScale(2, BigDecimal.ROUND_HALF_UP));

		BigDecimal parte3 = valorTotalServico.subtract(valorEntrada);
		BigDecimal valorPrestacaoNormal = null;
		if (numeroPrestacoes > 0) {
			valorPrestacaoNormal = Util.dividirArredondando(parte3,
					new BigDecimal(numeroPrestacoes));
		} else {
			valorPrestacaoNormal = parte3;
		}

		BigDecimal parte4 = valorPrestacao.subtract(valorPrestacaoNormal);

		BigDecimal parte5 = parte4.multiply(new BigDecimal(numeroPrestacoes));

		BigDecimal valorJuros = parte5;
		valores.add(valorJuros.setScale(2, BigDecimal.ROUND_HALF_UP));

		BigDecimal parte6 = valorTotalServico.subtract(valorEntrada);

		BigDecimal parte7 = parte6.add(valorJuros.setScale(2,
				BigDecimal.ROUND_HALF_UP));

		BigDecimal valorAParcelar = parte7;

		valores.add(valorAParcelar.setScale(2, BigDecimal.ROUND_HALF_UP));

		// [FS0010] - Validar valor total do serviço
		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(

		FiltroDebitoTipo.ID, idTipoDebito));
		Collection colecaoDebitosTipos = getControladorUtil().pesquisar(
				filtroDebitoTipo, DebitoTipo.class.getName());

		DebitoTipo debitoTipo = (DebitoTipo) colecaoDebitosTipos.iterator()
				.next();

		if (valorAParcelar.compareTo(debitoTipo.getValorLimite()) == 1) {
			throw new ControladorException(
					"atencao.debito_a_cobrar.valor_total_servico", null,
					debitoTipo.getValorLimite().toString().replace(".", ","));
		}

		return valores;
	}

	/**
	 * [UC0186 - Calcular Prestação] Author: Rafael Santos Data: 03/04/2006
	 * 
	 * @param taxaJurosFinanciamento
	 *            Taxa de Juros do Financiamento
	 * @param numeroPrestacoes
	 *            Numero de Prestacoes
	 * @param valorTotalServico
	 *            Valor Total de Servico
	 * @param valorEntrada
	 *            Valor de Entrada
	 * @return O valor da Prestacao
	 */
	public BigDecimal calcularPrestacao(BigDecimal taxaJurosFinanciamento,
			Integer numeroPrestacoes, BigDecimal valorTotalServico,
			BigDecimal valorEntrada) throws ControladorException {

		BigDecimal fatorCorrecao = null;
		BigDecimal valorPrestacao = null;

		if (taxaJurosFinanciamento.compareTo(new BigDecimal("0.00")) == 1) {
			BigDecimal parte1 = Util.dividirArredondando(
					taxaJurosFinanciamento, new BigDecimal(100));

			BigDecimal parte2 = parte1.add(new BigDecimal(1));

			BigDecimal parte3 = parte2.pow(numeroPrestacoes);

			BigDecimal parte4 = Util.dividirArredondando(new BigDecimal(1),
					parte3);

			BigDecimal parte5 = new BigDecimal(1).subtract(parte4);

			BigDecimal parte6 = Util.dividirArredondando(
					taxaJurosFinanciamento, new BigDecimal(100));

			fatorCorrecao = Util.dividirArredondando(parte5, parte6);

			BigDecimal parte7 = valorTotalServico.subtract(valorEntrada);

			valorPrestacao = Util.dividirArredondando(parte7, fatorCorrecao);

		} else {

			BigDecimal parte7 = valorTotalServico.subtract(valorEntrada);

			valorPrestacao = Util.dividirArredondando(parte7, new BigDecimal(
					numeroPrestacoes));
		}

		return valorPrestacao;
	}

	/**
	 * [UC0183 - Inserir Débito A Cobrar] Author: Rafael Santos Data: 29/12/2005
	 * Inserir Debito A Cobrar por Categoria
	 * 
	 * @param debitoACobrar
	 *            Debito A Cobrar
	 */
	public void inserirDebitoACobrarCategoria(DebitoACobrar debitoACobrar,
			Imovel imovel) throws ControladorException {

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoCategorias = getControladorImovel()
				.obterQuantidadeEconomiasCategoria(imovel);

		Collection colecaoValoresPorCategoria = getControladorImovel()
				.obterValorPorCategoria(colecaoCategorias,
						debitoACobrar.getValorDebito());
		Iterator icolecaoCategorias = colecaoCategorias.iterator();
		Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria
				.iterator();

		while (icolecaoValoresPorCategoria.hasNext()
				&& icolecaoCategorias.hasNext()) {

			DebitoACobrarCategoria debitoACobrarCategoria = new DebitoACobrarCategoria();
			Categoria categoria = (Categoria) icolecaoCategorias.next();
			BigDecimal valorPorCategoria = (BigDecimal) icolecaoValoresPorCategoria
					.next();

			debitoACobrarCategoria.setComp_id(new DebitoACobrarCategoriaPK(
					debitoACobrar, categoria));
			debitoACobrarCategoria.setQuantidadeEconomia(categoria
					.getQuantidadeEconomiasCategoria());
			debitoACobrarCategoria.setUltimaAlteracao(new Date());
			debitoACobrarCategoria.setValorCategoria(valorPorCategoria);
			getControladorUtil().inserir(debitoACobrarCategoria);
		}

	}

	/**
	 * [UC0183 - Inserir Débito A Cobrar] Author: Rafael Corrêa e Leonardo
	 * Vieira Data: 29/12/2005 Inserir Debito A Cobrar por Categoria
	 * 
	 * @param debitoACobrar
	 *            Debito A Cobrar
	 */
	public Collection inserirDebitoACobrarCategoriaBatch(DebitoACobrar debitoACobrar, Imovel imovel)
			throws ControladorException {

		Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
		Collection colecaoValoresPorCategoria = getControladorImovel().obterValorPorCategoria(colecaoCategorias,debitoACobrar.getValorDebito());
		
		Iterator icolecaoCategorias = colecaoCategorias.iterator();
		Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria.iterator();

		Collection colecaoDebitosACobrarCategorias = new ArrayList();

		while (icolecaoValoresPorCategoria.hasNext() && icolecaoCategorias.hasNext()) {

			DebitoACobrarCategoria debitoACobrarCategoria = new DebitoACobrarCategoria();
			Categoria categoria = (Categoria) icolecaoCategorias.next();
			BigDecimal valorPorCategoria = (BigDecimal) icolecaoValoresPorCategoria.next();

			debitoACobrarCategoria.setComp_id(new DebitoACobrarCategoriaPK(debitoACobrar, categoria));
			debitoACobrarCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
			debitoACobrarCategoria.setUltimaAlteracao(new Date());
			debitoACobrarCategoria.setValorCategoria(valorPorCategoria);

			colecaoDebitosACobrarCategorias.add(debitoACobrarCategoria);
		}
		return colecaoDebitosACobrarCategorias;
	}

	/**
	 * Calcula os valores da conta de acordo com os parâmetros passados
	 * 
	 * [UC0145] - Inserir Conta [SF0001] - Determinar Valores para Faturamento
	 * de Água e/ou Esgoto Author: Raphael Rossiter 05/12/2005
	 * 
	 * @param mesAnoConta
	 * @param imovelID
	 * @param situacaoAguaConta
	 * @param situacaoEsgotoConta
	 * @param colecaoCategoria
	 * @param consumoAgua
	 * @param consumoEsgoto
	 * @param percentualEsgoto
	 * @return Collection<CalcularValoresAguaEsgotoHelper>
	 * @throws ControladorException
	 */
	public Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta(
			String mesAnoConta, String imovelID, Integer situacaoAguaConta,
			Integer situacaoEsgotoConta,
			Collection colecaoCategoriaOUSubcategoria, String consumoAgua,
			String consumoEsgoto, String percentualEsgoto,
			Integer idConsumoTarifaConta, Usuario usuarioLogado)
			throws ControladorException {

		Collection<CalcularValoresAguaEsgotoHelper> helper = new ArrayList();

		if (Util.validarAnoMes(mesAnoConta)) {
			throw new ControladorException("atencao.adicionar_debito_ano_mes_referencia_invalido");
		}

		if (new Integer(mesAnoConta.substring(3, 7)).intValue() < ConstantesSistema.ANO_LIMITE.intValue()) {
			throw new ControladorException("atencao.ano_mes_referencia_menor", null, String.valueOf(ConstantesSistema.ANO_LIMITE.intValue()));
		}

		mesAnoConta = Util.formatarMesAnoParaAnoMesSemBarra(mesAnoConta);

		FiltroImovel filtroImovel = new FiltroImovel();
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("quadra.rota.faturamentoGrupo");
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("consumoTarifa");
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("ligacaoAguaSituacao");
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("ligacaoEsgotoSituacao");
		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovelID));

		Collection colecaoImovel = this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());

		if (colecaoImovel == null || colecaoImovel.isEmpty()) {
			throw new ControladorException("atencao.adicionar_debito_ano_mes_debito_invalido");
		}

		Imovel imovel = (Imovel) Util.retonarObjetoDeColecao(colecaoImovel);
		Integer mesAnoFaturamentoImovel = imovel.getQuadra().getRota().getFaturamentoGrupo().getAnoMesReferencia();

		/*
		 * [UC0157] - Simular Cálculo da Conta
		 * [FS0003] - Verificar Consumo Mínimo
		 */
		Integer idConsumoAgua = null;
		if (consumoAgua != null && !consumoAgua.equalsIgnoreCase("")) {
			idConsumoAgua = new Integer(consumoAgua);
		}

		this.verificarConsumoFaturadoAgua(situacaoAguaConta, idConsumoAgua);

		if (idConsumoAgua == null) {
			idConsumoAgua = new Integer("0");
		}

		/*
		 * [UC0157] - Simular Cálculo da Conta
		 * [FS0004] - Verificar Volume Mínimo
		 */
		Integer idConsumoEsgoto = null;
		if (consumoEsgoto != null && !consumoEsgoto.equalsIgnoreCase("")) {
			idConsumoEsgoto = new Integer(consumoEsgoto);
		}

		this.verificarConsumoFaturadoEsgoto(situacaoEsgotoConta, idConsumoEsgoto);

		if (idConsumoEsgoto == null) {
			idConsumoEsgoto = new Integer("0");
		}

		// PERCENTUAL DE ESGOTO
		FiltroLigacaoEsgotoSituacao filtroLigacaoEsgotoSituacao = new FiltroLigacaoEsgotoSituacao();
		filtroLigacaoEsgotoSituacao.adicionarParametro(new ParametroSimples(FiltroLigacaoEsgotoSituacao.ID, situacaoEsgotoConta));
		Collection colecaoLigacaoEsgotoSituacao = this.getControladorUtil().pesquisar(filtroLigacaoEsgotoSituacao, LigacaoEsgotoSituacao.class.getName());
		LigacaoEsgotoSituacao ligacaoEsgotoSituacao = (LigacaoEsgotoSituacao) Util.retonarObjetoDeColecao(colecaoLigacaoEsgotoSituacao);

		BigDecimal objPercentualEsgoto = new BigDecimal("0.00");

		if (ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao() != null 
				&& ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao().equals(ConstantesSistema.INDICADOR_USO_ATIVO)
				&& (percentualEsgoto == null || percentualEsgoto.equalsIgnoreCase(""))) {
			throw new ControladorException("atencao.informe.percentualEsgoto", null);
		} else if (percentualEsgoto != null && !percentualEsgoto.equalsIgnoreCase("")) {
			objPercentualEsgoto = Util.formatarMoedaRealparaBigDecimal(percentualEsgoto);
		}

		// [SF0001] - Determinar Valores para Faturamento de Água e/ou Esgoto.
		if (colecaoCategoriaOUSubcategoria != null && !colecaoCategoriaOUSubcategoria.isEmpty()) {

			Short indicadorFaturamentoAgua = new Short("1");
			Short indicadorFaturamentoEsgoto = new Short("1");

			// [UC0105] - Obter Consumo Mínimo da Ligação por Subcategoria
			int consumoMinimoLigacao = this.getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, colecaoCategoriaOUSubcategoria);

			boolean temPermissaoFaturamentoAntecipado = this.getControladorPermissaoEspecial().verificarPermissaoInserirContaFaturamentoAntecipado(usuarioLogado);

			Date dataLeituraAtual = null;
			Date dataLeituraAnterior = null;

			// Caso o usuário tenha permissão especial (FATURAMENTO ANTECIPADO) e o anoMes informado seja maior que o anoMes do faturamento do imóvel
			if (temPermissaoFaturamentoAntecipado && Util.compararAnoMesReferencia(new Integer(mesAnoConta), mesAnoFaturamentoImovel, ">")) {
				int mesConta = Util.obterMes(new Integer(mesAnoConta));
				int anoConta = Util.obterAno(new Integer(mesAnoConta));

				int ultimoDiaMes = new Integer(Util.obterUltimoDiaMes(mesConta, anoConta));

				dataLeituraAtual = Util.criarData(ultimoDiaMes, mesConta, anoConta);
				dataLeituraAnterior = Util.criarData(1, mesConta, anoConta);
				
			} else {

				if (Util.compararAnoMesReferencia(new Integer(mesAnoConta), mesAnoFaturamentoImovel, ">")) {
					throw new ControladorException("atencao.adicionar_debito_ano_mes_debito_invalido");
				}

				// Caso existe cronograma para o anoMes informado
				dataLeituraAnterior = this.buscarDataLeituraCronograma(imovel, true, new Integer(mesAnoConta));
				dataLeituraAtual = this.buscarDataLeituraCronograma(imovel, false, new Integer(mesAnoConta));

				// Caso NÃO existe cronograma para o anoMes informado
				if (dataLeituraAnterior == null || dataLeituraAtual == null) {

					int mesConta = Util.obterMes(new Integer(mesAnoConta));
					int anoConta = Util.obterAno(new Integer(mesAnoConta));

					int ultimoDiaMes = new Integer(Util.obterUltimoDiaMes(mesConta, anoConta));

					dataLeituraAtual = Util.criarData(ultimoDiaMes, mesConta, anoConta);
					dataLeituraAnterior = Util.criarData(1, mesConta, anoConta);
				}

				// Ajuste na Data de leitura anterior e atual.
				Integer anoMesConta = new Integer(mesAnoConta);

				// CASO O IMÓVEL SEJA PARA FATURAR ÁGUA
				if (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)) {
					MedicaoHistorico medicaoHistoricoAgua = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(imovel.getId(), anoMesConta);

					if (medicaoHistoricoAgua != null) {
						if (medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento() != null
								&& existeMedicaoHistoricoReferenciaAnterior(MedicaoTipo.LIGACAO_AGUA, imovel.getId(), anoMesConta)) {
							dataLeituraAnterior = medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento();
						}

						if (medicaoHistoricoAgua.getDataLeituraAtualFaturamento() != null) {
							dataLeituraAtual = medicaoHistoricoAgua.getDataLeituraAtualFaturamento();
						}
					}
				}

				// CASO O IMÓVEL SEJA PARA FATURAR ESGOTO
				if (imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)) {
					MedicaoHistorico medicaoHistoricoPoco = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoPoco(imovel.getId(), anoMesConta);

					if (medicaoHistoricoPoco != null) {
						if (medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento() != null
								&& existeMedicaoHistoricoReferenciaAnterior(MedicaoTipo.POCO, imovel.getId(), anoMesConta)) {
							dataLeituraAnterior = medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento();
						}

						if (medicaoHistoricoPoco.getDataLeituraAtualFaturamento() != null) {
							dataLeituraAtual = medicaoHistoricoPoco.getDataLeituraAtualFaturamento();
						}
					}
				}
			}

			if (idConsumoTarifaConta != null) {
				helper = this.calcularValoresAguaEsgoto(new Integer(mesAnoConta), situacaoAguaConta, situacaoEsgotoConta,
						indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategoriaOUSubcategoria, idConsumoAgua, 
						idConsumoEsgoto, consumoMinimoLigacao, dataLeituraAnterior, dataLeituraAtual, objPercentualEsgoto,
						idConsumoTarifaConta, null, null);

			} else {
				helper = this.calcularValoresAguaEsgoto(new Integer(mesAnoConta), situacaoAguaConta, situacaoEsgotoConta, 
						indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategoriaOUSubcategoria, idConsumoAgua, 
						idConsumoEsgoto, consumoMinimoLigacao, dataLeituraAnterior, dataLeituraAtual, objPercentualEsgoto,
						imovel.getConsumoTarifa().getId(), null, null);

			}
		}

		return helper;
	}

	private boolean existeMedicaoHistoricoReferenciaAnterior(Integer medicaoTipo, Integer idImovel, Integer anoMesConta) throws ControladorException {
		Integer anoMesAnterior = Util.subtrairMesDoAnoMes(anoMesConta.intValue(), 1);
		
		if (medicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)) {
			MedicaoHistorico medicaoHistoricoAgua = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(idImovel, anoMesAnterior);
			if (medicaoHistoricoAgua != null) {
				return true;
			}
		} else {
			MedicaoHistorico medicaoHistoricoPoco = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoPoco(idImovel, anoMesAnterior);
			if (medicaoHistoricoPoco != null) {
				return true;
			}
		}
		
		return false;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 10/01/2006
	 * Cálcula o valor total dos débitos de uma conta de acordo com o informado
	 * pelo usuário
	 * 
	 * @param colecaoDebitoCobrado
	 * @param requestMap
	 * @return BigDecimal valorTotalDebitoConta
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorTotalDebitoConta(
			Collection<DebitoCobrado> colecaoDebitoCobrado,
			Map<String, String[]> requestMap) throws ControladorException {

		BigDecimal valorTotalDebitoConta = new BigDecimal("0");

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if (colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()) {

			// Atualizando os valores dos débitos de acordo com os dados
			// informados pelo usuário
			DebitoCobrado debitoCobradoColecao;
			Iterator colecaoDebitoCobradoIt = colecaoDebitoCobrado.iterator();
			String valorDebitoColecao;

			while (colecaoDebitoCobradoIt.hasNext()) {
				debitoCobradoColecao = (DebitoCobrado) colecaoDebitoCobradoIt
						.next();

				if (requestMap.get("debitoCobrado"
						+ GcomAction
								.obterTimestampIdObjeto(debitoCobradoColecao)) != null) {

					valorDebitoColecao = (requestMap
							.get("debitoCobrado"
									+ GcomAction
											.obterTimestampIdObjeto(debitoCobradoColecao)))[0];

					if (valorDebitoColecao == null
							|| valorDebitoColecao.equalsIgnoreCase("")) {
						throw new ControladorException(
								"atencao.campo_texto.obrigatorio", null,
								"Valor do Débito");
					}

					debitoCobradoColecao
							.setValorPrestacao(Util
									.formatarMoedaRealparaBigDecimal(valorDebitoColecao));
				}

				valorTotalDebitoConta = valorTotalDebitoConta
						.add(debitoCobradoColecao.getValorPrestacao());
			}
		}

		return valorTotalDebitoConta;

	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 10/01/2006
	 * Cálcula o valor total dos créditos de uma conta de acordo com o informado
	 * pelo usuário
	 * 
	 * @param colecaoCreditoRealizado
	 * @param requestMap
	 * @return BigDecimal valorTotalCreditoConta
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorTotalCreditoConta(
			Collection<CreditoRealizado> colecaoCreditoRealizado,
			Map<String, String[]> requestMap) throws ControladorException {

		BigDecimal valorTotalCreditoConta = new BigDecimal("0.00");

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if (colecaoCreditoRealizado != null
				&& !colecaoCreditoRealizado.isEmpty()) {

			// Atualizando os valores dos créditos de acordo com os dados
			// informados pelo usuário
			CreditoRealizado creditoRealizadoColecao;
			Iterator colecaoCreditoRealizadoIt = colecaoCreditoRealizado
					.iterator();
			String valorCreditoColecao;

			while (colecaoCreditoRealizadoIt.hasNext()) {
				creditoRealizadoColecao = (CreditoRealizado) colecaoCreditoRealizadoIt
						.next();

				if (requestMap
						.get("creditoRealizado"
								+ GcomAction
										.obterTimestampIdObjeto(creditoRealizadoColecao)) != null) {

					valorCreditoColecao = (requestMap
							.get("creditoRealizado"
									+ GcomAction
											.obterTimestampIdObjeto(creditoRealizadoColecao)))[0];

					if (valorCreditoColecao == null
							|| valorCreditoColecao.equalsIgnoreCase("")) {
						throw new ControladorException(
								"atencao.campo_texto.obrigatorio", null,
								"Valor do Crédito");
					}

					creditoRealizadoColecao
							.setValorCredito(Util
									.formatarMoedaRealparaBigDecimal(valorCreditoColecao));
				}

				valorTotalCreditoConta = valorTotalCreditoConta
						.add(creditoRealizadoColecao.getValorCredito());
			}
		}

		return valorTotalCreditoConta;

	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 10/01/2006
	 * Cálcula o valor total dos créditos de uma conta de acordo com o informado
	 * pelo usuário
	 * 
	 * @param colecaoCreditoRealizado
	 * @param requestMap
	 * @return BigDecimal valorTotalCreditoConta
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorTotalCreditoConta(
			Collection<CreditoRealizado> colecaoCreditoRealizado)
			throws ControladorException {

		BigDecimal valorTotalCreditoConta = new BigDecimal("0.00");

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if (colecaoCreditoRealizado != null
				&& !colecaoCreditoRealizado.isEmpty()) {

			// Atualizando os valores dos créditos de acordo com os dados
			// informados pelo usuário
			CreditoRealizado creditoRealizadoColecao;
			Iterator colecaoCreditoRealizadoIt = colecaoCreditoRealizado
					.iterator();

			while (colecaoCreditoRealizadoIt.hasNext()) {
				creditoRealizadoColecao = (CreditoRealizado) colecaoCreditoRealizadoIt
						.next();

				valorTotalCreditoConta = valorTotalCreditoConta
						.add(creditoRealizadoColecao.getValorCredito());
			}
		}

		return valorTotalCreditoConta;

	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 10/01/2006
	 * Cálcula o valor total dos débitos de uma conta de acordo com o informado
	 * pelo usuário
	 * 
	 * @param colecaoDebitoCobrado
	 * @param requestMap
	 * @return BigDecimal valorTotalDebitoConta
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorTotalDebitoConta(
			Collection<DebitoCobrado> colecaoDebitoCobrado)
			throws ControladorException {

		BigDecimal valorTotalDebitoConta = new BigDecimal("0");

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if (colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()) {

			// Atualizando os valores dos débitos de acordo com os dados
			// informados pelo usuário
			DebitoCobrado debitoCobradoColecao;
			Iterator colecaoDebitoCobradoIt = colecaoDebitoCobrado.iterator();

			while (colecaoDebitoCobradoIt.hasNext()) {
				debitoCobradoColecao = (DebitoCobrado) colecaoDebitoCobradoIt
						.next();

				valorTotalDebitoConta = valorTotalDebitoConta
						.add(debitoCobradoColecao.getValorPrestacao());
			}
		}

		return valorTotalDebitoConta;

	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 12/01/2006
	 * Cálcula o valor total de água ou esgoto
	 * 
	 * @param calcularValoresAguaEsgotoHelper
	 * @param tipoRetorno
	 * @return valorTotalAguaOuEsgoto
	 */
	public BigDecimal calcularValorTotalAguaOuEsgotoPorCategoria(
			Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgotoHelper,
            String tipoRetorno) {

        BigDecimal retorno = new BigDecimal("0.00");

        if (calcularValoresAguaEsgotoHelper != null && !calcularValoresAguaEsgotoHelper.isEmpty()) {
            
            for (CalcularValoresAguaEsgotoHelper item : calcularValoresAguaEsgotoHelper) {
            	if (tipoRetorno.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)) {
            		if (item.getValorFaturadoAguaCategoria() != null) {
            			retorno = retorno.add(item.getValorFaturadoAguaCategoria());
            		}
            	}
            	// Valor Faturado de Esgoto
            	else {
            		if (item.getValorFaturadoEsgotoCategoria() != null) {
            			retorno = retorno.add(item.getValorFaturadoEsgotoCategoria());
            		}
            	}
            }
        }

        return retorno;
    }

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 12/01/2006
	 * Cálcula o consumo total de água ou esgoto
	 * 
	 * @param calcularValoresAguaEsgotoHelper
	 * @param tipoRetorno
	 * @return consumoTotalAguaOuEsgoto
	 */
	public Integer calcularConsumoTotalAguaOuEsgotoPorCategoria(Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgotoHelper, String tipoRetorno) {

		Integer retorno = new Integer("0");

		if (calcularValoresAguaEsgotoHelper != null && !calcularValoresAguaEsgotoHelper.isEmpty()) {

			for (CalcularValoresAguaEsgotoHelper item : calcularValoresAguaEsgotoHelper) {
				if (tipoRetorno.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)) {
					if (item.getConsumoFaturadoAguaCategoria() != null) {
						retorno = retorno + item.getConsumoFaturadoAguaCategoria();
					}
				}
				// Consumo Faturado de Esgoto
				else {
					if (item.getConsumoFaturadoEsgotoCategoria() != null) {
						retorno = retorno + item.getConsumoFaturadoEsgotoCategoria();
					}
				}
			}
		}

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta [SF002] - Gerar dados da conta [SF003] - Gerar os débitos cobrados
	 * 
	 * @param mesAnoConta
	 * @param imovel
	 * @param colecaoDebitoCobrado
	 * @param ligacaoAguaSituacao
	 * @param ligacaoEsgotoSituacao
	 * @param colecaoCategoria
	 * @param consumoAgua
	 * @param consumoEsgoto
	 * @param percentualEsgoto
	 * @param dataVencimentoConta
	 * @param calcularValoresConta
	 * @param motivoInclusaoConta
	 * @throws ControladorException
	 */
	public Integer inserirConta(Integer mesAnoConta, Imovel imovel,
			Collection colecaoDebitoCobrado,
			LigacaoAguaSituacao ligacaoAguaSituacao,
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao,
			Collection colecaoCategoria, String consumoAgua,
			String consumoEsgoto, String percentualEsgoto,
			Date dataVencimentoConta,
			Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta,
			ContaMotivoInclusao contaMotivoInclusao,
			Map<String, String[]> requestMap, Usuario usuarioLogado,
			Integer leituraAnterior, Integer leituraAtual) throws ControladorException {


		Integer retorno = new Integer("0");
		
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_INSERIR_CONTA, new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_INSERIR_CONTA);
		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		FiltroConta filtroConta = new FiltroConta();
		filtroConta.adicionarCaminhoParaCarregamentoEntidade("debitoCreditoSituacaoAtual");
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, imovel.getId()));
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, mesAnoConta));

		Collection colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());
		if (colecaoConta != null && !colecaoConta.isEmpty()) {
			Conta conta = (Conta) colecaoConta.iterator().next();

			if (conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.CANCELADA)
					|| conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)) {
				throw new ControladorException("atencao.conta_ja_existente_cancelada", null, Util.formatarMesAnoReferencia(mesAnoConta));
			} else {
				throw new ControladorException("atencao.conta_ja_existente_imovel_anomesreferencia", null, imovel.getId() + " já possui a conta com a referência " + Util.formatarMesAnoReferencia(mesAnoConta) + ".");
			}
		}

		ContaGeral contaGeralInserir = new ContaGeral();
		contaGeralInserir.setIndicadorHistorico(ConstantesSistema.NAO);
		contaGeralInserir.setUltimaAlteracao(new Date());

		Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);
		Integer id = null;
		if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.acesso.negado.abrangencia");
		} else {
			id = (Integer) this.getControladorUtil().inserir(contaGeralInserir);
		}

		contaGeralInserir.setId(id);

		Conta contaInserir = new Conta();

		contaInserir.setId(id);
		contaInserir.setContaGeral(contaGeralInserir);
		contaInserir.setImovel(imovel);
		contaInserir.setReferencia(mesAnoConta.intValue());
		contaInserir.setDataVencimentoConta(dataVencimentoConta);
		contaInserir.setDataVencimentoOriginal(dataVencimentoConta);
		contaInserir.setIndicadorAlteracaoVencimento(ConstantesSistema.NAO);

		contaInserir.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.INCLUIDA));

		contaInserir.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		contaInserir.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

		contaInserir.setLocalidade(imovel.getLocalidade());
		contaInserir.setQuadraConta(imovel.getQuadra());
		contaInserir.setLote(imovel.getLote());
		contaInserir.setSubLote(imovel.getSubLote());
		contaInserir.setCodigoSetorComercial(imovel.getQuadra().getSetorComercial().getCodigo());
		contaInserir.setQuadra(new Integer(imovel.getQuadra().getNumeroQuadra()));

		contaInserir.setDigitoVerificadorConta(new Short(String.valueOf(Util.calculoRepresentacaoNumericaCodigoBarrasModulo10(mesAnoConta))));
		contaInserir.setIndicadorCobrancaMulta(ConstantesSistema.NAO);

		Integer consumoTotalAgua = this.calcularConsumoTotalAguaOuEsgotoPorCategoria(calcularValoresConta, ConstantesSistema.CALCULAR_AGUA);
		if (consumoTotalAgua.equals(new Integer("0"))) {
			if (consumoAgua != null && !consumoAgua.trim().equalsIgnoreCase("")) {
				contaInserir.setConsumoAgua(new Integer(consumoAgua));
			} else {
				contaInserir.setConsumoAgua(new Integer("0"));
			}
		} else {
			contaInserir.setConsumoAgua(consumoTotalAgua);
		}

		this.verificarValoresLeituraAnteriorEAtual(leituraAnterior, leituraAtual, null, null, null, contaInserir.getConsumoAgua(), contaInserir.getConsumoAgua());
		contaInserir.setNumeroLeituraAnterior(leituraAnterior);
		contaInserir.setNumeroLeituraAtual(leituraAtual);

		Integer consumoTotalEsgoto = this.calcularConsumoTotalAguaOuEsgotoPorCategoria(calcularValoresConta, ConstantesSistema.CALCULAR_ESGOTO);
		if (consumoTotalEsgoto.equals(new Integer("0"))) {
			if (consumoEsgoto != null && !consumoEsgoto.trim().equalsIgnoreCase("")) {
				contaInserir.setConsumoEsgoto(new Integer(consumoEsgoto));
			} else {
				contaInserir.setConsumoEsgoto(new Integer("0"));
			}
		} else {
			contaInserir.setConsumoEsgoto(consumoTotalEsgoto);
		}

		BigDecimal valorTotalAgua = this.calcularValorTotalAguaOuEsgotoPorCategoria(calcularValoresConta, ConstantesSistema.CALCULAR_AGUA);
		contaInserir.setValorAgua(valorTotalAgua);
		BigDecimal valorTotalEsgoto = this.calcularValorTotalAguaOuEsgotoPorCategoria(calcularValoresConta, ConstantesSistema.CALCULAR_ESGOTO);
		contaInserir.setValorEsgoto(valorTotalEsgoto);

		BigDecimal valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado, requestMap);
		contaInserir.setDebitos(valorTotalDebito);

		BigDecimal valorTotalCreditos = new BigDecimal(0.00);
		contaInserir.setValorCreditos(valorTotalCreditos);

		if (percentualEsgoto != null && !percentualEsgoto.equalsIgnoreCase("")) {
			contaInserir.setPercentualEsgoto(Util.formatarMoedaRealparaBigDecimal(percentualEsgoto));
		} else {
			contaInserir.setPercentualEsgoto(new BigDecimal("0.00"));
		}

		contaInserir.setPercentualColeta(obterPercentualColetaEsgotoImovel(imovel.getId()));

		contaInserir.setDataValidadeConta(retornaDataValidadeConta(dataVencimentoConta));
		contaInserir.setDataInclusao(new GregorianCalendar().getTime());
		contaInserir.setDataEmissao(new GregorianCalendar().getTime());

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		contaInserir.setReferenciaContabil(obterReferenciaContabilConta(sistemaParametro, contaInserir.getReferencia()));

		contaInserir.setContaMotivoInclusao(contaMotivoInclusao);

		contaInserir.setConsumoTarifa(imovel.getConsumoTarifa());
		contaInserir.setImovelPerfil(imovel.getImovelPerfil());
		contaInserir.setIndicadorDebitoConta(ConstantesSistema.NAO);

		contaInserir.setUsuario(usuarioLogado);

		contaInserir.setNumeroRetificacoes(0);

		Rota rota = new Rota();
		if (imovel.getRotaAlternativa() != null) {
			rota = imovel.getRotaAlternativa();

		} else {
			rota = imovel.getQuadra().getRota();
		}

		contaInserir.setRota(rota);

		contaInserir.setFaturamentoGrupo(getControladorImovel().pesquisarGrupoImovel(imovel.getId()));
		contaInserir.setNumeroAlteracoesVencimento(0);

		GerarImpostosDeduzidosContaHelper impostosDeduzidosConta = gerarImpostosDeduzidosConta(contaInserir.getImovel().getId(), 
				mesAnoConta, valorTotalAgua, valorTotalEsgoto, valorTotalDebito, valorTotalCreditos, false);
		contaInserir.setValorImposto(impostosDeduzidosConta.getValorTotalImposto());

		contaInserir.setNumeroBoleto(verificarGeracaoBoleto(sistemaParametro, contaInserir));
		contaInserir.setUltimaAlteracao(new Date());

		contaInserir.setOperacaoEfetuada(operacaoEfetuada);
		contaInserir.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(contaInserir);

		Integer idContaGerado = (Integer) this.getControladorUtil().inserir(contaInserir);
		retorno = idContaGerado;

		inserirContaCategoria(calcularValoresConta, colecaoCategoria, contaInserir);
		inserirClienteConta(contaInserir, imovel);
		inserirDebitoCobrado(contaInserir, colecaoDebitoCobrado, imovel, colecaoCategoria);
		inserirImpostosDeduzidosConta(impostosDeduzidosConta, contaInserir);

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inclui, na tabela CONTA_CATEGORIA, a(s) categoria(s) e sua(s)
	 * respectiva(s) quantidade(s) de economia da lista do passo 5.8 do fluxo
	 * principal e os atributos retornados pelo [UC0120] para cada categoria,
	 * caso o [UC0120] não tenha sido chamado, os valores correspondentes devem
	 * ser nulos.
	 * 
	 * Caso o [UC0120] não tenha sido chamado não gravar a tabela
	 * CONTA_CATEGORIA_CONSUMO_FAIXA
	 * 
	 * @param calcularValoresConta
	 * @param colecaoCategoria
	 * @param conta
	 * @throws ControladorException
	 */
	public void inserirObjetoContaCategoria(
			Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta,
			Collection colecaoCategoria, Conta conta)
			throws ControladorException {

		Categoria categoria = new Categoria();
		Subcategoria subCategoria = new Subcategoria();
		subCategoria.setId(0);

		ContaCategoriaPK contaCategoriaPK = new ContaCategoriaPK();
		contaCategoriaPK.setConta(conta);
		contaCategoriaPK.setSubcategoria(subCategoria);

		ContaCategoria contaCategoriaInsert = null;
		calcularValoresConta = calcularValoresAguaEsgotoTotalizando(calcularValoresConta);

		// O [UC0120] não foi invocado, inserir apenas o ID da conta, ID da
		// categoria e qtd de economias da categoria
		if (calcularValoresConta == null || calcularValoresConta.isEmpty()) {

			Iterator colecaoCategoriaIt = colecaoCategoria.iterator();

			while (colecaoCategoriaIt.hasNext()) {

				categoria = (Categoria) colecaoCategoriaIt.next();

				// Adicionando a categoria no objeto ContaCategoriaPK
				contaCategoriaPK.setCategoria(categoria);

				// Gerando o objeto ContaCategoria
				contaCategoriaInsert = new ContaCategoria();

				// Comp_id
				contaCategoriaInsert.setComp_id(contaCategoriaPK);

				// Qtd economias da categoria
				contaCategoriaInsert.setQuantidadeEconomia(new Short(String
						.valueOf(categoria.getQuantidadeEconomiasCategoria()
								.intValue())).shortValue());

				// Ultima Alteração
				contaCategoriaInsert.setUltimaAlteracao(new Date());

				// Evitando que registre transacao
				contaCategoriaInsert.setUsuarioAcaoUsuarioHelp(null);
				contaCategoriaInsert.setOperacaoEfetuada(null);

				this.getControladorUtil().inserir(contaCategoriaInsert);
			}
		} else {

			Iterator calcularValoresContaIt = calcularValoresConta.iterator();
			CalcularValoresAguaEsgotoHelper calcularValoresContaObjeto = null;

			// Integer idContaCategoriaGerado = null;

			while (calcularValoresContaIt.hasNext()) {

				calcularValoresContaObjeto = (CalcularValoresAguaEsgotoHelper) calcularValoresContaIt
						.next();

				for (Iterator iter = colecaoCategoria.iterator(); iter
						.hasNext();) {
					Categoria categoriaPreenchida = (Categoria) iter.next();
					if (categoriaPreenchida.getId().intValue() == calcularValoresContaObjeto
							.getIdCategoria()) {
						categoria = categoriaPreenchida;
						break;
					}
				}
				categoria.setId(calcularValoresContaObjeto.getIdCategoria());

				// Adicionando a categoria no objeto ContaCategoriaPK
				contaCategoriaPK.setCategoria(categoria);

				// Gerando o objeto ContaCategoria
				contaCategoriaInsert = new ContaCategoria();

				// Comp_id
				contaCategoriaInsert.setComp_id(contaCategoriaPK);

				// Qtd economias da categoria
				contaCategoriaInsert.setQuantidadeEconomia(new Short(String
						.valueOf(calcularValoresContaObjeto
								.getQuantidadeEconomiasCategoria().intValue()))
						.shortValue());

				// Valores relacionados aos cálculos de água

				contaCategoriaInsert.setValorAgua(calcularValoresContaObjeto
						.getValorFaturadoAguaCategoria());
				contaCategoriaInsert.setConsumoAgua(calcularValoresContaObjeto
						.getConsumoFaturadoAguaCategoria());
				contaCategoriaInsert
						.setValorTarifaMinimaAgua(calcularValoresContaObjeto
								.getValorTarifaMinimaAguaCategoria());
				contaCategoriaInsert
						.setConsumoMinimoAgua(calcularValoresContaObjeto
								.getConsumoMinimoAguaCategoria());

				// Valores relacionados aos cálculos de esgoto

				contaCategoriaInsert.setValorEsgoto(calcularValoresContaObjeto
						.getValorFaturadoEsgotoCategoria());
				contaCategoriaInsert
						.setConsumoEsgoto(calcularValoresContaObjeto
								.getConsumoFaturadoEsgotoCategoria());
				contaCategoriaInsert
						.setValorTarifaMinimaEsgoto(calcularValoresContaObjeto
								.getValorTarifaMinimaEsgotoCategoria());
				contaCategoriaInsert
						.setConsumoMinimoEsgoto(calcularValoresContaObjeto
								.getConsumoMinimoEsgotoCategoria());

				// Ultima Alteração
				contaCategoriaInsert.setUltimaAlteracao(new Date());

				// Evitando registrar transacao
				contaCategoriaInsert.setUsuarioAcaoUsuarioHelp(null);
				contaCategoriaInsert.setOperacaoEfetuada(null);

				this.getControladorUtil().inserir(contaCategoriaInsert);

				// Inserindo na tabela CONTA_CATEGORIA_CONSUMO_FAIXA
				this.inserirContaCategoriaConsumoFaixa(contaCategoriaInsert,
						calcularValoresContaObjeto.getFaixaTarifaConsumo());

			}
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inclui a(s) faixa(s) de consumo por categoria na tabela
	 * CONTA_CATEGORIA_CONSUMO_FAIXA com os atributos retornados pelo [UC0120]
	 * por categoria e para cada faixa da categoria, caso o [UC0120] não tenha
	 * sido chamado não gravar a tabela.
	 * 
	 * @param contaCategoria
	 * @param calcularValoresContaFaixa
	 * @throws ControladorException
	 */
	public void inserirContaCategoriaConsumoFaixa(
			ContaCategoria contaCategoria,
			Collection<CalcularValoresAguaEsgotoFaixaHelper> calcularValoresContaFaixa)
			throws ControladorException {

		CalcularValoresAguaEsgotoFaixaHelper calcularValoresContaFaixaObjeto = null;
		ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixaInsert = null;

		if (calcularValoresContaFaixa != null
				&& !calcularValoresContaFaixa.isEmpty()) {
			Iterator calcularValoresContaFaixaIt = calcularValoresContaFaixa
					.iterator();
			while (calcularValoresContaFaixaIt.hasNext()) {

				calcularValoresContaFaixaObjeto = (CalcularValoresAguaEsgotoFaixaHelper) calcularValoresContaFaixaIt
						.next();

				contaCategoriaConsumoFaixaInsert = new ContaCategoriaConsumoFaixa();

				// Conta Categoria
				contaCategoriaConsumoFaixaInsert
						.setContaCategoria(contaCategoria);

				// Valores relacionados aos cálculos de água

				contaCategoriaConsumoFaixaInsert
						.setValorAgua(calcularValoresContaFaixaObjeto
								.getValorFaturadoAguaFaixa());
				contaCategoriaConsumoFaixaInsert
						.setConsumoAgua(calcularValoresContaFaixaObjeto
								.getConsumoFaturadoAguaFaixa());

				// Valores relacionados aos cálculos de esgoto

				contaCategoriaConsumoFaixaInsert
						.setValorEsgoto(calcularValoresContaFaixaObjeto
								.getValorFaturadoEsgotoFaixa());
				contaCategoriaConsumoFaixaInsert
						.setConsumoEsgoto(calcularValoresContaFaixaObjeto
								.getConsumoFaturadoEsgotoFaixa());

				// ConsumoFaixaInicio
				contaCategoriaConsumoFaixaInsert
						.setConsumoFaixaInicio(calcularValoresContaFaixaObjeto
								.getLimiteInicialConsumoFaixa());

				// ConsumoFaixaFinal
				contaCategoriaConsumoFaixaInsert
						.setConsumoFaixaFim(calcularValoresContaFaixaObjeto
								.getLimiteFinalConsumoFaixa());

				// valorTarifaFaixa
				contaCategoriaConsumoFaixaInsert
						.setValorTarifaFaixa(calcularValoresContaFaixaObjeto
								.getValorTarifaFaixa());

				// Ultima Alteração
				contaCategoriaConsumoFaixaInsert.setUltimaAlteracao(new Date());

				if (contaCategoriaConsumoFaixaInsert != null
						&& !contaCategoriaConsumoFaixaInsert.equals("")) {
					this.getControladorUtil().inserir(
							contaCategoriaConsumoFaixaInsert);
				}
			}
		}
	}

	/**
	 * [UC0145] - Inserir Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 01/04/2008
	 * 
	 * @param conta
	 * @param imovel
	 * @throws ControladorException
	 */
	public void inserirClienteConta(Conta conta, Imovel imovel)
			throws ControladorException {

		Collection colecaoClienteImovel = null;

		/*
		 * Seleciona a partir da tabela CLIENTE_IMOVEL para IMOV_ID=Id do imóvel
		 * e CLIM_DTRELACAOFIM com o valor correspondente a nulo.
		 */
		try {

			colecaoClienteImovel = this.repositorioFaturamento
					.pesquisarClienteImovelDataRelacaoFimNull(imovel);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		Iterator colecaoClienteImovelIt = colecaoClienteImovel.iterator();
		Object[] colecaoClienteImovelObjeto = null;
		ClienteConta clienteContaInsert = null;

		while (colecaoClienteImovelIt.hasNext()) {

			colecaoClienteImovelObjeto = (Object[]) colecaoClienteImovelIt
					.next();

			clienteContaInsert = new ClienteConta();
			clienteContaInsert.setConta(conta);
			clienteContaInsert
					.setCliente((Cliente) colecaoClienteImovelObjeto[0]);
			clienteContaInsert
					.setClienteRelacaoTipo((ClienteRelacaoTipo) colecaoClienteImovelObjeto[1]);
			clienteContaInsert
					.setIndicadorNomeConta((Short) colecaoClienteImovelObjeto[2]);
			clienteContaInsert.setUltimaAlteracao(new Date());

			this.getControladorUtil().inserir(clienteContaInsert);
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 */
	public void inserirDebitoCobrado(Conta conta, Collection colecaoDebitoCobrado, Imovel imovel, Collection colecaoCategoria) throws ControladorException {

		if (colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()) {

			Iterator colecaoDebitoCobradoIt = colecaoDebitoCobrado.iterator();

			while (colecaoDebitoCobradoIt.hasNext()) {

				DebitoCobrado debitoCobradoColecao = (DebitoCobrado) colecaoDebitoCobradoIt.next();

				DebitoCobrado debitoCobradoInserir = new DebitoCobrado();

				debitoCobradoInserir.setIdAntigo(debitoCobradoColecao.getId());
				debitoCobradoInserir.setDebitoTipo(debitoCobradoColecao.getDebitoTipo());
				debitoCobradoInserir.setDebitoCobrado(new Date());
				debitoCobradoInserir.setConta(conta);
				debitoCobradoInserir.setLancamentoItemContabil(debitoCobradoColecao.getDebitoTipo().getLancamentoItemContabil());
				debitoCobradoInserir.setLocalidade(imovel.getLocalidade());
				debitoCobradoInserir.setQuadra(imovel.getQuadra());
				debitoCobradoInserir.setCodigoSetorComercial(new Integer(imovel.getSetorComercial().getCodigo()));
				debitoCobradoInserir.setNumeroQuadra(new Integer(imovel.getQuadra().getNumeroQuadra()));
				debitoCobradoInserir.setNumeroLote(new Short(imovel.getLote()));
				debitoCobradoInserir.setNumeroSubLote(new Short(imovel.getSubLote()));

				if (debitoCobradoColecao.getAnoMesReferenciaDebito() != null) {
					debitoCobradoInserir.setAnoMesReferenciaDebito(debitoCobradoColecao.getAnoMesReferenciaDebito());
				}

				if (debitoCobradoColecao.getAnoMesCobrancaDebito() != null) {
					debitoCobradoInserir.setAnoMesCobrancaDebito(debitoCobradoColecao.getAnoMesCobrancaDebito());
				}

				debitoCobradoInserir.setValorPrestacao(debitoCobradoColecao.getValorPrestacao());

				if (debitoCobradoColecao.getNumeroPrestacao() == 0) {
					debitoCobradoInserir.setNumeroPrestacao(new Short("1").shortValue());
				} else {
					debitoCobradoInserir.setNumeroPrestacao(debitoCobradoColecao.getNumeroPrestacao());
				}

				if (debitoCobradoColecao.getNumeroPrestacaoDebito() == 0) {
					debitoCobradoInserir.setNumeroPrestacaoDebito(new Short("1").shortValue());
				} else {
					debitoCobradoInserir.setNumeroPrestacaoDebito(debitoCobradoColecao.getNumeroPrestacaoDebito());
				}

				if (debitoCobradoColecao.getDebitoACobrarGeral() != null) {
					debitoCobradoInserir.setDebitoACobrarGeral(debitoCobradoColecao.getDebitoACobrarGeral());
				}
				
				debitoCobradoInserir.setFinanciamentoTipo(debitoCobradoColecao.getDebitoTipo().getFinanciamentoTipo());
				debitoCobradoInserir.setNumeroParcelaBonus(debitoCobradoColecao.getNumeroParcelaBonus());
				debitoCobradoInserir.setUltimaAlteracao(new Date());
				debitoCobradoInserir.setOperacaoEfetuada(null);
				debitoCobradoInserir.setUsuarioAcaoUsuarioHelp(null);

				Integer idDebitoCobradoGerado = (Integer) this.getControladorUtil().inserir(debitoCobradoInserir);

				debitoCobradoInserir.setId(idDebitoCobradoGerado);

				this.inserirDebitoCobradoCategoria(debitoCobradoInserir, colecaoCategoria);
			}
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inseri na tabela CREDITO_REALIZADO os dados referentes aos créditos da
	 * conta
	 * 
	 * @param conta
	 * @param colecaoCreditoRealizado
	 * @param imovel
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirCreditoRealizado(Conta conta, Collection colecaoCreditoRealizado, Imovel imovel, Collection colecaoCategoria) throws ControladorException {

		if (colecaoCreditoRealizado != null && !colecaoCreditoRealizado.isEmpty()) {

			Iterator colecaoCreditoRealizadoIt = colecaoCreditoRealizado.iterator();

			while (colecaoCreditoRealizadoIt.hasNext()) {

				CreditoRealizado creditoRealizadoColecao = (CreditoRealizado) colecaoCreditoRealizadoIt.next();

				CreditoRealizado creditoRealizadoInserir = new CreditoRealizado();

				creditoRealizadoInserir.setCreditoTipo(creditoRealizadoColecao.getCreditoTipo());
				creditoRealizadoInserir.setCreditoRealizado(new Date());
				creditoRealizadoInserir.setConta(conta);
				creditoRealizadoInserir.setLancamentoItemContabil(creditoRealizadoColecao.getCreditoTipo().getLancamentoItemContabil());
				creditoRealizadoInserir.setLocalidade(imovel.getLocalidade());
				creditoRealizadoInserir.setQuadra(imovel.getQuadra());
				creditoRealizadoInserir.setCodigoSetorComercial(new Integer(imovel.getSetorComercial().getCodigo()));
				creditoRealizadoInserir.setNumeroQuadra(new Integer(imovel.getQuadra().getNumeroQuadra()));
				creditoRealizadoInserir.setNumeroLote(new Short(imovel.getLote()));
				creditoRealizadoInserir.setNumeroSubLote(new Short(imovel.getSubLote()));

				if (creditoRealizadoColecao.getAnoMesReferenciaCredito() != null) {
					creditoRealizadoInserir.setAnoMesReferenciaCredito(creditoRealizadoColecao.getAnoMesReferenciaCredito());
				}

				if (creditoRealizadoColecao.getAnoMesCobrancaCredito() != null) {
					creditoRealizadoInserir.setAnoMesCobrancaCredito(creditoRealizadoColecao.getAnoMesCobrancaCredito());
				}

				creditoRealizadoInserir.setValorCredito(creditoRealizadoColecao.getValorCredito());

				if (creditoRealizadoColecao.getNumeroPrestacao() == 0) {
					creditoRealizadoInserir.setNumeroPrestacao(new Short("1").shortValue());
				} else {
					creditoRealizadoInserir.setNumeroPrestacao(creditoRealizadoColecao.getNumeroPrestacao());
				}

				if (creditoRealizadoColecao.getNumeroPrestacaoCredito() == 0) {
					creditoRealizadoInserir.setNumeroPrestacaoCredito(new Short("1").shortValue());
				} else {
					creditoRealizadoInserir.setNumeroPrestacaoCredito(creditoRealizadoColecao.getNumeroPrestacaoCredito());
				}

				creditoRealizadoInserir.setNumeroParcelaBonus(creditoRealizadoColecao.getNumeroParcelaBonus());
				creditoRealizadoInserir.setCreditoOrigem(creditoRealizadoColecao.getCreditoOrigem());
				creditoRealizadoInserir.setUltimaAlteracao(new Date());
				creditoRealizadoInserir.setUsuarioAcaoUsuarioHelp(null);
				creditoRealizadoInserir.setOperacaoEfetuada(null);
				creditoRealizadoInserir.setCreditoARealizarGeral(creditoRealizadoColecao.getCreditoARealizarGeral());

				Integer idCreditoRealizadoGerado = (Integer) this.getControladorUtil().inserir(creditoRealizadoInserir);

				creditoRealizadoInserir.setId(idCreditoRealizadoGerado);
				this.inserirCreditoRealizadoCategoria(creditoRealizadoInserir,
						colecaoCategoria);

			}
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inclui a quantidade de economias por categoria do débito cobrado na
	 * tabela DEBITO_COBRADO_CATEGORIA
	 * 
	 * @param debitoCobrado
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirObjetoDebitoCobradoCategoria(DebitoCobrado debitoCobrado, Collection colecaoCategoria)throws ControladorException {

		Collection valorPorCategoria = this.getControladorImovel().obterValorPorCategoria(colecaoCategoria,debitoCobrado.getValorPrestacao());

		Iterator colecaoCategoriaIt = colecaoCategoria.iterator();
		Iterator colecaoValorPorCategoriaIt = valorPorCategoria.iterator();
		Categoria categoriaColecao;

		while (colecaoCategoriaIt.hasNext()) {
			categoriaColecao = (Categoria) colecaoCategoriaIt.next();

			DebitoCobradoCategoriaPK debitoCobradoCategoriaPKInserir = new DebitoCobradoCategoriaPK();
			debitoCobradoCategoriaPKInserir.setCategoriaId(categoriaColecao.getId());
			debitoCobradoCategoriaPKInserir.setDebitoCobradoId(debitoCobrado.getId());

			DebitoCobradoCategoria debitoCobradoCategoriaInserir = new DebitoCobradoCategoria();

			debitoCobradoCategoriaInserir.setComp_id(debitoCobradoCategoriaPKInserir);
			debitoCobradoCategoriaInserir.setQuantidadeEconomia(categoriaColecao.getQuantidadeEconomiasCategoria());
			debitoCobradoCategoriaInserir.setUltimaAlteracao(new Date());
			debitoCobradoCategoriaInserir.setValorCategoria((BigDecimal) colecaoValorPorCategoriaIt.next());
			this.getControladorUtil().inserir(debitoCobradoCategoriaInserir);
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inclui a quantidade de economias por categoria do crédito realizado na
	 * tabela CREDITO_REALIZADO_CATEGORIA
	 * 
	 * @param creditoRealizado
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirObjetoCreditoRealizadoCategoria(CreditoRealizado creditoRealizado, Collection colecaoCategoria) throws ControladorException {

		Collection valorPorCategoria = this.getControladorImovel().obterValorPorCategoria(colecaoCategoria,	creditoRealizado.getValorCredito());

		Iterator colecaoCategoriaIt = colecaoCategoria.iterator();
		Iterator colecaoValorPorCategoriaIt = valorPorCategoria.iterator();
		Categoria categoriaColecao;

		while (colecaoCategoriaIt.hasNext()) {
			categoriaColecao = (Categoria) colecaoCategoriaIt.next();

			CreditoRealizadoCategoriaPK creditoRealizadoCategoriaPKInserir = new CreditoRealizadoCategoriaPK();
			creditoRealizadoCategoriaPKInserir.setCategoria(categoriaColecao);
			creditoRealizadoCategoriaPKInserir.setCreditoRealizado(creditoRealizado);

			CreditoRealizadoCategoria creditoRealizadoCategoriaInserir = new CreditoRealizadoCategoria();
			creditoRealizadoCategoriaInserir.setComp_id(creditoRealizadoCategoriaPKInserir);
			creditoRealizadoCategoriaInserir.setQuantidadeEconomia(categoriaColecao.getQuantidadeEconomiasCategoria());
			creditoRealizadoCategoriaInserir.setUltimaAlteracao(new Date());
			creditoRealizadoCategoriaInserir.setValorCategoria((BigDecimal) colecaoValorPorCategoriaIt.next());

			this.getControladorUtil().inserir(creditoRealizadoCategoriaInserir);
		}
	}

	/**
	 * [UC0145] Inserir Conta [FS0021]  Verificar valores de leitura anterior e
	 * atual
	 * 
	 * @author Vivianne Sousa
	 * @date 21/09/2010
	 */
	public void verificarValoresLeituraAnteriorEAtual(Integer leituraAnterior,
			Integer leituraAtual, Integer consumoAgua)
			throws ControladorException {

		// Caso a diferença entre LEITURAANTERIOR e LEITURAATUAL seja diferente
		// do CONSUMOAGUA.
		// Exibir a seguinte mensagem: Leitura fora da faixa
		if (leituraAnterior != null && leituraAtual != null
				&& consumoAgua != null) {

			int diferencaLeituraAnteriorELeituraAtual = 0;

			if (leituraAtual.intValue() > leituraAnterior.intValue()) {
				diferencaLeituraAnteriorELeituraAtual = leituraAtual.intValue()
						- leituraAnterior.intValue();
			} else if (leituraAnterior.intValue() > leituraAtual.intValue()) {
				diferencaLeituraAnteriorELeituraAtual = leituraAnterior
						.intValue() - leituraAtual.intValue();
			}

			if (diferencaLeituraAnteriorELeituraAtual != consumoAgua.intValue()) {
				throw new ControladorException("atencao.leitura_fora_faixa");
			}
		}
	}

	/**
	 * [UC0145] Inserir Conta [FS0021]  Verificar valores de leitura anterior e
	 * atual
	 * 
	 * @author Vivianne Sousa
	 * @date 21/09/2010
	 */
	public void verificarValoresLeituraAnteriorEAtual(Integer leituraAnterior,
			Integer leituraAtual, String retorno, Integer contaID, Integer idImovel,
			Integer consumoAguaCalculado, Integer consumoAguaMedido) throws ControladorException {

		// Caso a diferença entre LEITURAANTERIOR e LEITURAATUAL seja diferente
		// do CONSUMOAGUA.
		// Exibir a seguinte mensagem: Leitura fora da faixa
		if (leituraAnterior != null && leituraAtual != null && consumoAguaCalculado != null) {

			int diferencaLeituraAnteriorELeituraAtual = 0;

			if (leituraAtual.intValue() > leituraAnterior.intValue()) {
				diferencaLeituraAnteriorELeituraAtual = leituraAtual.intValue() - leituraAnterior.intValue();
			} else if (leituraAnterior.intValue() > leituraAtual.intValue()) {
				diferencaLeituraAnteriorELeituraAtual = leituraAnterior.intValue() - leituraAtual.intValue();
			}

			if (diferencaLeituraAnteriorELeituraAtual != consumoAguaCalculado.intValue()
					&& consumoAguaMedido.intValue() != consumoAguaCalculado.intValue()) {
				if (retorno != null && retorno.equals("retificarConta")) {

					FiltroConta filtroConta = new FiltroConta();
					filtroConta.adicionarParametro(new ParametroSimples("id", contaID));

					Collection colConta = Fachada.getInstancia().pesquisar(filtroConta, Conta.class.getName());

					Conta conta = (Conta) Util.retonarObjetoDeColecao(colConta);

					if (conta.getConsumoAgua() != null && conta.getConsumoAgua() != consumoAguaCalculado) {

						throw new ControladorException("atencao.leitura_fora_faixa", "exibirRetificarContaAction.do?reloadPage=1", null);

					}

				} else {
					throw new ControladorException("atencao.leitura_fora_faixa");
				}
			}
		}
	}

	
	/**
	 * Monta uma coleção de contas categoria a partir de uma coleção de
	 * categoria recebida
	 * 
	 * @param colecaoCategoria
	 * @param conta
	 * @return
	 */
	public Collection montarColecaoObjetoContaCategoria(
			Collection colecaoCategoria, Conta conta) {
		Iterator colecaoCategoriaIt = colecaoCategoria.iterator();
		Collection<ContaCategoria> colecaoContaCategoria = new ArrayList();

		while (colecaoCategoriaIt.hasNext()) {

			Categoria categoria = new Categoria();
			Subcategoria subCategoria = new Subcategoria();
			subCategoria.setId(0);

			ContaCategoriaPK contaCategoriaPK = new ContaCategoriaPK();
			contaCategoriaPK.setConta(conta);
			contaCategoriaPK.setSubcategoria(subCategoria);

			categoria = (Categoria) colecaoCategoriaIt.next();

			// Adicionando a categoria no objeto ContaCategoriaPK
			contaCategoriaPK.setCategoria(categoria);

			// Gerando o objeto ContaCategoria
			ContaCategoria contaCategoriaInsert = new ContaCategoria();

			// Comp_id
			contaCategoriaInsert.setComp_id(contaCategoriaPK);

			// Qtd economias da categoria
			contaCategoriaInsert.setQuantidadeEconomia(new Short(String
					.valueOf(categoria.getQuantidadeEconomiasCategoria()
							.intValue())).shortValue());

			// Ultima Alteração
			contaCategoriaInsert.setUltimaAlteracao(new Date());

			colecaoContaCategoria.add(contaCategoriaInsert);
		}
		return colecaoContaCategoria;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0147] - Cancelar Conta
	 * 
	 * @author Raphael Rossiter, Raphael Rossiter
	 * @date 10/12/2005, 20/06/2008
	 * 
	 * @param colecaoContas
	 * @param identificadores
	 * @param contaMotivoCancelamento
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void cancelarConta(Collection<Conta> colecaoContas,
			String identificadores,
			ContaMotivoCancelamento contaMotivoCancelamento,
			Usuario usuarioLogado, boolean removerIdContaPagamento)
			throws ControladorException {

		Iterator colecaoContasIt = colecaoContas.iterator();
		Conta contaColecao = null;
		// Conta contaNaBase = null;
		String[] arrayIdentificadores = identificadores.split(",");
		FiltroConta filtroConta = new FiltroConta();
		Collection colecaoContaNaBase = null;

		// Verificando permissão especial do usuário logado
		boolean usuarioPermissaoCancelarSemRA = this
				.getControladorPermissaoEspecial()
				.verificarPermissaoCancelarContaSemRA(usuarioLogado);

		while (colecaoContasIt.hasNext()) {
			contaColecao = (Conta) colecaoContasIt.next();

			// Carregando a conta que está na base
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID,
					contaColecao.getId()));

			colecaoContaNaBase = this.getControladorUtil().pesquisar(
					filtroConta, Conta.class.getName());

			/* contaNaBase = (Conta) */Util
					.retonarObjetoDeColecao(colecaoContaNaBase);

			filtroConta.limparListaParametros();

			for (int index = 0; index < arrayIdentificadores.length; index++) {

				String dadosConta = arrayIdentificadores[index];
				String[] idUltimaAlteracao = dadosConta.split("-");

				// Contas que serão canceladas pelo sistema
				if (contaColecao.getId().equals(
						new Integer(idUltimaAlteracao[0]))) {

					// Verificar atualização realizada por outro usuário
					/*
					 * if ((contaNaBase.getUltimaAlteracao().after(contaColecao
					 * .getUltimaAlteracao()))) {
					 * sessionContext.setRollbackOnly(); throw new
					 * ControladorException( "erro.atualizacao.timestamp"); }
					 */

					/**
					 * Caso a situação atual da conta corresponda a normal
					 * (DCST_IDATUAL com o valor correspondente a normal da
					 * tabela DEBITO_CREDITO_SITUACAO) ou corresponda a
					 * retificada ou incluída (DCST_IDATUAL com o valor
					 * correspondente a retificada ou incluída, da tabela
					 * DEBITO_CREDITO_SITUACAO) e a retificação ou inclusão já
					 * tenha sido contabilizada (CNTA_AMREFERENCIACONTABIL menor
					 * que PARM_AMREFERENCIAFATURAMENTO da tabela
					 * SISTEMA_PARAMETROS), atualizar os seguintes atributos da
					 * conta.
					 */

					SistemaParametro sistemaParametro = this
							.getControladorUtil()
							.pesquisarParametrosDoSistema();

					if (isContaNormalIncluidaOuRetificadaEReferenciaContabilMenor(contaColecao, sistemaParametro)) {

						// Data do cancelamento
						contaColecao.setDataCancelamento(new Date());

						// Motivo do Cancelamento
						contaColecao
								.setContaMotivoCancelamento(contaMotivoCancelamento);

						// Situação Anterior
						/*
						 * Caso a situação atual da conta corresponda a normal
						 * (DCST_IDATUAL com o valor correspondente a normal da
						 * tabela DEBITO_CREDITO_SITUACAO) e a conta tenha sido
						 * faturada no mês de faturamento corrente
						 * (CNTA_AMREFERENCIACONTA= PARM_AMREFERENCIAFATURAMENTO
						 * da tabela SISTEMA_PARAMETROS)
						 * DCST_IDANTERIOR=DCST_IDATUAL, caso contrário
						 * DCST_IDANTERIOR=nulo)
						 */
						if (contaColecao.getDebitoCreditoSituacaoAtual()
								.getId().equals(DebitoCreditoSituacao.NORMAL)
								&& Util.compararAnoMesReferencia(
										new Integer(contaColecao
												.getReferencia()),
										new Integer(sistemaParametro
												.getAnoMesFaturamento()), "=")) {

							contaColecao
									.setDebitoCreditoSituacaoAnterior(contaColecao
											.getDebitoCreditoSituacaoAtual());
						} else {
							contaColecao.setDebitoCreditoSituacaoAnterior(null);
						}

						// Situação Atual
						DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
						// Situação Atual
						/**
						 * Caso motivo de retificação seja débito
						 * prescrito, alterar a situação da conta para 8.
						 * 
						 * @author Wellington Rocha
						 * @date 01/06/2012
						 * 
						 * */
						boolean contaPodeSerPrescrita = true;
						if (contaMotivoCancelamento.getId().equals(
								ContaMotivoCancelamento.DEBITO_PRESCRITO)
								|| contaMotivoCancelamento.getId().equals(
										ContaMotivoCancelamento.PRESCRICAO)) {

							contaPodeSerPrescrita = this
									.verificarPossibilidadePrescricaoConta(contaColecao
											.getId());
							if (contaPodeSerPrescrita) {
								debitoCreditoSituacao
										.setId(DebitoCreditoSituacao.DEBITO_PRESCRITO);
							}
						} else {
							debitoCreditoSituacao
									.setId(DebitoCreditoSituacao.CANCELADA);
						}

						if (!contaPodeSerPrescrita) {
							throw new ControladorException(
									"erro.conta_nao_satisfaz_criterios_para_prescricao",
									"exibirCancelarContaAction.do?contaID="
											+ contaColecao.getId()
											+ "&idImovel="
											+ contaColecao.getImovel().getId(),
									null);
						} else {

							contaColecao
									.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

							// última alteração
							contaColecao.setUltimaAlteracao(new Date());

							/*
							 * Alterado por Raphael Rossiter em 30/07/2007
							 * (Analista: Rosana Carvalho)
							 * 
							 * OBJETIVO: Quando o mes/ano de faturamento for
							 * maior que o mes/ano de faturamento atual, não
							 * alterar o mes/ano contábil
							 */

							// alterado por Vivianne Sousa 07/05/2008
							// analista :Aryed
							Integer referenciaContabil = obterReferenciaContabilConta(sistemaParametro);
							contaColecao
									.setReferenciaContabil(referenciaContabil);

							/*
							 * Colocado por Raphael Rossiter em 09/08/2007
							 * OBJETIVO: Gravar na tabela de conta o usuário que
							 * está logado no sistema
							 */

							// Usuario
							contaColecao.setUsuario(usuarioLogado);

							// UPDATE
							try {

								// ------------ <REGISTRAR
								// TRANSAÇÃO>----------------------------

								RegistradorOperacao registradorOperacao = new RegistradorOperacao(
										Operacao.OPERACAO_CANCELAR_CONTA,
										contaColecao.getImovel().getId(),
										contaColecao.getId(),
										new UsuarioAcaoUsuarioHelper(
												usuarioLogado,
												UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

								registradorOperacao
										.registrarOperacao(contaColecao);

								getControladorTransacao().registrarTransacao(
										contaColecao);

								// ------------ </REGISTRAR
								// TRANSAÇÃO>----------------------------

								if (contaColecao
										.getDebitoCreditoSituacaoAnterior() == null) {
									repositorioFaturamento
											.cancelarContaReferenciaContabilMenorSistemaParametro(
													contaColecao, null);

								} else {
									repositorioFaturamento
											.cancelarContaReferenciaContabilMenorSistemaParametro(
													contaColecao,
													contaColecao
															.getDebitoCreditoSituacaoAnterior()
															.getId());
								}

								// Colocado por Raphael Rossiter em 17/06/2008
								// Analista: Roberto Souza
								if (!usuarioPermissaoCancelarSemRA) {

									// Verificar Existência de RA
									RegistroAtendimento registroAtendimento = this
											.getControladorRegistroAtendimento()
											.verificarExistenciaRegistroAtendimentoSemLevantarExcecao(
													contaColecao.getImovel()
															.getId(),
													EspecificacaoTipoValidacao.ALTERACAO_CONTA);

									if (registroAtendimento != null) {
										// Atualizando a conta com o registro de
										// atendimento que autoriza esta ação
										repositorioFaturamento
												.atualizarContaCanceladaOuRetificada(
														contaColecao,
														registroAtendimento);
									}
								}

								// CRC2725 - alterado por Vivianne Sousa -
								// 17/09/2009 analista:Fátima
								// 1.1.2.Verificar se há relação do cancelamento
								// com
								// itens de negativação
								getControladorSpcSerasa()
										.verificarRelacaoDoCancelamentoComItensNegativacao(
												contaColecao, null);

							} catch (ErroRepositorioException ex) {
								sessionContext.setRollbackOnly();
								new ControladorException("erro.sistema", ex);
							} catch (ControladorException ex) {
								sessionContext.setRollbackOnly();
								throw ex;
							} catch (Exception ex) {
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema",
										ex);
							}
						}

					} else if (isContaIncluidaOuRetificadaEReferenciaContabilMaiorOuIgual(contaColecao, sistemaParametro)) {

						// Remoção da conta no BD
						contaColecao
								.setPercentualEsgoto(new BigDecimal("0.00"));

						// CRC2725 - alterado por Vivianne Sousa - 17/09/2009
						// analista:Fátima
						// [FS0003 - Verificar existência de itens de
						// negativação para a conta incluída]:
						getControladorSpcSerasa()
								.verificarExistenciaItensNegativacaoParaContaIncluida(
										contaColecao);
						// 1.2.4. Verificar se há relação do cancelamento com
						// itens de negativação:
						// [UC0937 - Obter Itens de Negativação Associados à
						// Conta]
						// passando o identificador do imóvel (Imóvel da Conta
						// Retificada e Cancelada)
						// e a referência (Referência da Conta Retificada e
						// Cancelada).
						Collection colecaoNegativadorMovimentoRegItem = getControladorSpcSerasa()
								.obterItensNegativacaoAssociadosAConta(
										contaColecao.getImovel().getId(),
										contaColecao.getReferencia());

						this.getControladorUtil().remover(
								new String[] { "" + contaColecao.getId() },
								contaColecao.getClass().getName(), null, null);
						// adicionado por Vivianne Sousa 21/09/2009 -
						// analista:Aryed
						atualizarIndicadorHistoricoContaGeral(
								contaColecao.getId(), new Short("3"));

						if (contaColecao.getDebitoCreditoSituacaoAtual()
								.getId()
								.equals(DebitoCreditoSituacao.RETIFICADA)) {

							// [FS0002] - Verificar existência da conta
							// cancelada por retificação

							filtroConta
									.adicionarParametro(new ParametroSimples(
											FiltroConta.IMOVEL_ID, contaColecao
													.getImovel().getId()));

							filtroConta
									.adicionarParametro(new ParametroSimples(
											FiltroConta.REFERENCIA,
											contaColecao.getReferencia()));

							filtroConta
									.adicionarParametro(new ParametroSimples(
											FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
											DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO));

							Collection colecaoContaCanceladaRetificacao = this
									.getControladorUtil().pesquisar(
											filtroConta, Conta.class.getName());

							filtroConta.limparListaParametros();

							if (colecaoContaCanceladaRetificacao == null
									|| colecaoContaCanceladaRetificacao
											.isEmpty()) {
								throw new ControladorException(
										"atencao.pesquisa.nenhuma.conta_cancelada_retificacao");
							}

							Conta contaCanceladaPorRetificacao = (Conta) Util
									.retonarObjetoDeColecao(colecaoContaCanceladaRetificacao);

							// Data do cancelamento
							contaCanceladaPorRetificacao
									.setDataCancelamento(new Date());

							// Motivo do cancelamento
							contaCanceladaPorRetificacao
									.setContaMotivoCancelamento(contaMotivoCancelamento);

							// Situação Atual
							DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
							debitoCreditoSituacao
									.setId(DebitoCreditoSituacao.CANCELADA);
							contaCanceladaPorRetificacao
									.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

							// Data da retificação = NULL
							contaCanceladaPorRetificacao
									.setDataRetificacao(null);

							// Motivo da retificação = NULL
							contaCanceladaPorRetificacao
									.setContaMotivoRetificacao(null);

							/*
							 * Alterado por Raphael Rossiter em 30/07/2007
							 * (Analista: Rosana Carvalho)
							 * 
							 * OBJETIVO: Quando o mes/ano de faturamento for
							 * maior que o mes/ano de faturamento atual, não
							 * alterar o mes/ano contábil
							 */

							// alterado por Vivianne Sousa 07/05/2008
							// analista :Aryed
							Integer referenciaContabil = obterReferenciaContabilConta(sistemaParametro);
							contaCanceladaPorRetificacao
									.setReferenciaContabil(referenciaContabil);

							// última alteração
							contaCanceladaPorRetificacao
									.setUltimaAlteracao(new Date());

							/*
							 * Colocado por Raphael Rossiter em 09/08/2007
							 * OBJETIVO: Gravar na tabela de conta o usuário que
							 * está logado no sistema
							 */

							// Usuario
							contaCanceladaPorRetificacao
									.setUsuario(usuarioLogado);

							// ------------ <REGISTRAR
							// TRANSAÇÃO>----------------------------

							RegistradorOperacao registradorOperacao = new RegistradorOperacao(
									Operacao.OPERACAO_CANCELAR_CONTA,
									contaColecao.getImovel().getId(),
									contaColecao.getId(),
									new UsuarioAcaoUsuarioHelper(
											usuarioLogado,
											UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

							registradorOperacao
									.registrarOperacao(contaCanceladaPorRetificacao);

							getControladorTransacao().registrarTransacao(
									contaCanceladaPorRetificacao);

							// ------------ </REGISTRAR
							// TRANSAÇÃO>----------------------------

							// UPDATE
							try {
								repositorioFaturamento
										.cancelarContaReferenciaContabilMaiorIgualSistemaParametro(contaCanceladaPorRetificacao);

								// Colocado por Raphael Rossiter em 17/06/2008
								// Analista: Roberto Souza
								if (!usuarioPermissaoCancelarSemRA) {

									// Verificar Existência de RA
									RegistroAtendimento registroAtendimento = this
											.getControladorRegistroAtendimento()
											.verificarExistenciaRegistroAtendimentoSemLevantarExcecao(
													contaColecao.getImovel()
															.getId(),
													EspecificacaoTipoValidacao.ALTERACAO_CONTA);

									if (registroAtendimento != null) {
										// Atualizando a conta com o registro de
										// atendimento que autoriza esta ação
										repositorioFaturamento
												.atualizarContaCanceladaOuRetificada(
														contaColecao,
														registroAtendimento);
									}
								}

								// CRC2725 - alterado por Vivianne Sousa -
								// 17/09/2009 analista:Fátima
								// 1.2.6.5. Caso existam itens de negativação
								// associados à conta (coleção de itens de
								// negativação não está vazia):
								if (colecaoNegativadorMovimentoRegItem != null
										&& !colecaoNegativadorMovimentoRegItem
												.isEmpty()) {
									// Caso existam itens de negativação
									// associados à conta:
									Iterator iterNmri = colecaoNegativadorMovimentoRegItem
											.iterator();
									while (iterNmri.hasNext()) {
										Integer idNmri = (Integer) iterNmri
												.next();
										// [SB0002 - Atualizar Item Negativação
										// - Conta Retificada].
										getControladorSpcSerasa()
												.atualizarNegativadorMovimentoRegItem(
														idNmri,
														new Date(),
														CobrancaDebitoSituacao.CANCELADO,
														contaCanceladaPorRetificacao
																.getId(),
														contaColecao.getId());
									}
								}
								// getControladorSpcSerasa().verificarRelacaoDoCancelamentoComItensNegativacao(
								// contaColecao,contaCanceladaPorRetificacao.getId());

							} catch (ErroRepositorioException ex) {
								sessionContext.setRollbackOnly();
								new ControladorException("erro.sistema", ex);
							} catch (ControladorException ex) {
								sessionContext.setRollbackOnly();
								throw ex;
							} catch (Exception ex) {
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema",
										ex);
							}
						}
					}

					// Alterado por Francisco - 26/05/08, por conta do Resumo de
					// Ações de cobrança
					// Analista: Ana Breda
					try {
						// Atualizar documento de cobranca da conta, se houver,
						// para cancelado
						repositorioCobranca
								.atualizarSituacaoCobrancaDocumentoItem(
										CobrancaDebitoSituacao.CANCELADO,
										new Date(), contaColecao.getId(), null,
										null);

						// Alterado Bruno Barros - 05/05/2009,
						// remover os conta id dos pagamentos cuja as contas
						// sejam
						// canceladas
						if (removerIdContaPagamento) {
							this.repositorioFaturamento
									.apagarIdContaPagamentos(contaColecao
											.getId());
						}
					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						new ControladorException("erro.sistema", ex);
					}
				}
			}
		}
	}

	/**
	 * Atualiza um objeto do tipo conta no BD
	 * 
	 * @param conta
	 * @throws ControladorException
	 */
	public void atualizarConta(Conta conta) throws ControladorException {

		// -----VALIDAÇÃO DOS TIMESTAMP PARA ATUALIZAÇÃO DE CADASTRO

		// Validação para conta
		if (conta != null) {
			// Cria o filtro
			FiltroConta filtroConta = new FiltroConta();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = Conta.class.getName();

			// Seta os parametros do filtro
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID,
					conta.getId()));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection contas = getControladorUtil().pesquisar(filtroConta,
					nomePacoteObjeto);
			Conta contaNaBase = (Conta) Util.retonarObjetoDeColecao(contas);

			// Verifica se a data de alteração do objeto gravado na base é
			// maior que a na instancia
			if ((contaNaBase.getUltimaAlteracao().after(conta
					.getUltimaAlteracao()))) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.atualizacao.timestamp");
			}

			// Seta a data/hora
			conta.setUltimaAlteracao(new Date());

		}

		// Atualiza objeto
		getControladorUtil().atualizar(conta);

	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0148] - Colocar Conta em Revisão
	 * 
	 * @author Raphael Rossiter, Vivianne Sousa
	 * @date 21/12/2005,19/10/2006
	 * 
	 * @param colecaoContas
	 * @param identificadores
	 * @param contaMotivoRevisao
	 * @throws ControladorException
	 */
	public void colocarRevisaoConta(Collection<Conta> colecaoContas,
			String identificadores, ContaMotivoRevisao contaMotivoRevisao,
			Usuario usuarioLogado) throws ControladorException {

		Iterator colecaoContasIt = colecaoContas.iterator();
		Conta contaColecao;
		Conta contaNaBase;
		String[] arrayIdentificadores = null;

		// Verifica se retirará todas ou uma seleção das contas da coleção de
		// revisão
		if (identificadores != null) {
			arrayIdentificadores = identificadores.split(",");
		}

		while (colecaoContasIt.hasNext()) {
			contaColecao = (Conta) colecaoContasIt.next();
			contaNaBase = contaColecao;

			if (identificadores != null) {
				for (int index = 0; index < arrayIdentificadores.length; index++) {

					String dadosConta = arrayIdentificadores[index];
					String[] idUltimaAlteracao = dadosConta.split("-");

					// Contas que serão colocadas em revisão pelo sistema
					if (contaColecao.getId().equals(
							new Integer(idUltimaAlteracao[0]))) {

						// [FS0016] - Verificar contas que estejam em revisão
						if (contaColecao.getDataRevisao() != null) {
							throw new ControladorException(
									"atencao.data_revisao_existente");
						}

						// Ultima alteração
						contaColecao.setUltimaAlteracao(new Date());

						// Data da revisão
						contaColecao.setDataRevisao(new Date());

						// Motivo da revisão
						contaColecao.setContaMotivoRevisao(contaMotivoRevisao);

						/*
						 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO:
						 * Gravar na tabela de conta o usuário que está logado
						 * no sistema
						 */

						// Usuario
						contaColecao.setUsuario(usuarioLogado);

						// Verificar atualização realizada por outro usuário
						if ((contaNaBase.getUltimaAlteracao()
								.after(contaColecao.getUltimaAlteracao()))) {
							sessionContext.setRollbackOnly();
							throw new ControladorException(
									"erro.atualizacao.timestamp");
						}

						// ------------ <REGISTRAR
						// TRANSAÇÃO>----------------------------

						RegistradorOperacao registradorOperacao = new RegistradorOperacao(
								Operacao.OPERACAO_COLOCAR_CONTA_REVISAO,
								contaColecao.getImovel().getId(),
								contaColecao.getId(),
								new UsuarioAcaoUsuarioHelper(
										usuarioLogado,
										UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						registradorOperacao.registrarOperacao(contaColecao);

						getControladorTransacao().registrarTransacao(
								contaColecao);

						// ------------ </REGISTRAR
						// TRANSAÇÃO>----------------------------

						try {
							repositorioFaturamento
									.colocarContaRevisao(contaColecao);
						} catch (ErroRepositorioException ex) {
							sessionContext.setRollbackOnly();
							new ControladorException("erro.sistema", ex);
						}
					}
				}
			} else {
				// [FS0016] - Verificar contas que estejam em revisão
				if (contaColecao.getDataRevisao() != null) {
					throw new ControladorException(
							"atencao.data_revisao_existente");
				}

				// Ultima alteração
				contaColecao.setUltimaAlteracao(new Date());

				// Data da revisão
				contaColecao.setDataRevisao(new Date());

				// Motivo da revisão
				contaColecao.setContaMotivoRevisao(contaMotivoRevisao);

				/*
				 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar
				 * na tabela de conta o usuário que está logado no sistema
				 */

				// Usuario
				contaColecao.setUsuario(usuarioLogado);

				// Verificar atualização realizada por outro usuário
				if ((contaNaBase.getUltimaAlteracao().after(contaColecao
						.getUltimaAlteracao()))) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.atualizacao.timestamp");
				}

				// ------------ <REGISTRAR
				// TRANSAÇÃO>----------------------------

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_CONTA_RETIFICAR, contaColecao
								.getImovel().getId(), contaColecao.getId(),
						new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(contaColecao);

				getControladorTransacao().registrarTransacao(contaColecao);

				// ------------ </REGISTRAR
				// TRANSAÇÃO>----------------------------

				try {
					repositorioFaturamento.colocarContaRevisao(contaColecao);
				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					new ControladorException("erro.sistema", ex);
				}
			}
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0148] - Retirar Conta de Revisão
	 * 
	 * @author Raphael Rossiter ,Vivianne Sousa, Mariana Victor
	 * @date 22/12/2005, 19/10/2006, 27/04/2011
	 * 
	 * @param colecaoContas
	 * @param identificadores
	 * @throws ControladorException
	 */
	public void retirarRevisaoConta(Collection<Conta> colecaoContas,
			String identificadores, Usuario usuarioLogado,
			boolean verificarPermissaoEspecial, Integer funcionalidade)
			throws ControladorException {

		Iterator colecaoContasIt = colecaoContas.iterator();
		Conta contaColecao;
		ContaMotivoRevisao contaMotivoRevisaoAtual = null;
		Collection colecaoContaNaBase;
		Conta contaNaBase;

		String[] arrayIdentificadores = null;
		FiltroConta filtroConta = new FiltroConta();

		// Verifica se retirará todas ou uma seleção das contas da coleção de
		// revisão
		if (identificadores != null) {
			arrayIdentificadores = identificadores.split(",");
		}

		/*
		 * Verifica se o usuário possui permissão especial para retirar contas
		 * que estão em revisão por antiguidade.
		 */
		boolean permEspecialRetirarRevisaoPorAntiguidade = true;

		if (verificarPermissaoEspecial
				&& (funcionalidade == null || (funcionalidade.intValue() != Funcionalidade.INSERIR_CONTRATO_PARCELAMENTO_POR_CLIENTE && funcionalidade
						.intValue() != Funcionalidade.MANTER_CONTRATO_PARCELAMENTO_POR_CLIENTE))) {

			permEspecialRetirarRevisaoPorAntiguidade = this
					.getControladorPermissaoEspecial()
					.verificarPermissaoEspecial(
							PermissaoEspecial.RETIRAR_CONTA_REVISAO_POR_ANTIGUIDADE,
							usuarioLogado);
		}

		while (colecaoContasIt.hasNext()) {

			contaColecao = (Conta) colecaoContasIt.next();

			// Obtendo o motivo de revisão da conta que será retirada de revisão
			try {
				contaMotivoRevisaoAtual = this.repositorioFaturamento
						.pesquisarContaMotivoRevisao(contaColecao.getId());
			} catch (ErroRepositorioException ex) {

				throw new ControladorException("erro.sistema", ex);
			}

			// Carregando a conta que está na base
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID,
					contaColecao.getId()));

			colecaoContaNaBase = this.getControladorUtil().pesquisar(
					filtroConta, Conta.class.getName());
			contaNaBase = (Conta) Util
					.retonarObjetoDeColecao(colecaoContaNaBase);

			filtroConta.limparListaParametros();

			if (identificadores != null) {

				for (int index = 0; index < arrayIdentificadores.length; index++) {

					String dadosConta = arrayIdentificadores[index];
					String[] idUltimaAlteracao = dadosConta.split("-");

					// Contas que serão retiradas de revisão pelo sistema
					if (contaColecao.getId().equals(
							new Integer(idUltimaAlteracao[0]))) {

						// [FS0015] - Verificar contas que não estejam em
						// revisão
						if (contaColecao.getDataRevisao() == null) {
							throw new ControladorException(
									"atencao.data_revisao_nao_existente");
						}

						/*
						 * [FS0002] - Verificar tipo de revisão
						 * 
						 * Caso o motivo de revisão informado seja de
						 * antiguidade e o usuário não tenha permissão especial
						 * para retirar este motivo de revisão
						 */
						if (contaMotivoRevisaoAtual != null
								&& contaMotivoRevisaoAtual
										.getId()
										.equals(ContaMotivoRevisao.REVISAO_POR_ANTIGUIDADE)
								&& !permEspecialRetirarRevisaoPorAntiguidade) {

							sessionContext.setRollbackOnly();
							throw new ControladorException(
									"atencao.necessario_permissao_especial_motivo_antiguidade");
						}

						// Data da revisão (NULL)
						contaColecao.setDataRevisao(null);

						// Motivo da revisão (NULL)
						contaColecao.setContaMotivoRevisao(null);

						// Verificar atualização realizada por outro usuário
						if ((contaNaBase.getUltimaAlteracao()
								.after(contaColecao.getUltimaAlteracao()))) {
							sessionContext.setRollbackOnly();
							throw new ControladorException(
									"erro.atualizacao.timestamp");
						}

						// Ultima alteração
						contaColecao.setUltimaAlteracao(new Date());

						// ------------ <REGISTRAR
						// TRANSAÇÃO>----------------------------

						RegistradorOperacao registradorOperacao = new RegistradorOperacao(
								Operacao.OPERACAO_RETIRAR_CONTA_REVISAO,
								contaColecao.getImovel().getId(),
								contaColecao.getId(),
								new UsuarioAcaoUsuarioHelper(
										usuarioLogado,
										UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						registradorOperacao.registrarOperacao(contaColecao);

						getControladorTransacao().registrarTransacao(
								contaColecao);

						// ------------ </REGISTRAR
						// TRANSAÇÃO>----------------------------

						// UPDATE
						try {
							repositorioFaturamento
									.retirarContaRevisao(contaColecao);
						} catch (ErroRepositorioException ex) {
							sessionContext.setRollbackOnly();
							new ControladorException("erro.sistema", ex);
						}
					}
				}
			} else {

				// [FS0015] - Verificar contas que não estejam em revisão
				if (contaColecao.getDataRevisao() == null) {
					throw new ControladorException(
							"atencao.data_revisao_nao_existente");
				}

				/*
				 * [FS0002] - Verificar tipo de revisão
				 * 
				 * Caso o motivo de revisão informado seja de antiguidade e o
				 * usuário não tenha permissão especial para retirar este motivo
				 * de revisão
				 */
				if (contaMotivoRevisaoAtual != null
						&& contaMotivoRevisaoAtual.getId().equals(
								ContaMotivoRevisao.REVISAO_POR_ANTIGUIDADE)
						&& !permEspecialRetirarRevisaoPorAntiguidade) {

					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.necessario_permissao_especial_motivo_antiguidade");
				}

				// Data da revisão (NULL)
				contaColecao.setDataRevisao(null);

				// Motivo da revisão (NULL)
				contaColecao.setContaMotivoRevisao(null);

				// Verificar atualização realizada por outro usuário
				if ((contaNaBase.getUltimaAlteracao().after(contaColecao
						.getUltimaAlteracao()))) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.atualizacao.timestamp");
				}

				// Ultima alteração
				contaColecao.setUltimaAlteracao(new Date());

				// ------------ <REGISTRAR
				// TRANSAÇÃO>----------------------------

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_RETIRAR_CONTA_REVISAO, contaColecao
								.getImovel().getId(), contaColecao.getId(),
						new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(contaColecao);

				getControladorTransacao().registrarTransacao(contaColecao);

				// ------------ </REGISTRAR
				// TRANSAÇÃO>----------------------------

				// UPDATE
				try {
					repositorioFaturamento.retirarContaRevisao(contaColecao);
				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					new ControladorException("erro.sistema", ex);
				}
			}
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0151] - Alterar Vencimento de Conta
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 22/12/2005, 22/11/2006
	 * 
	 * @param colecaoContas
	 * @param identificadores
	 * @param dataVencimento
	 * @throws ControladorException
	 */
	public void alterarVencimentoConta(Collection<Conta> colecaoContas,
			String identificadores, Date dataVencimento, Usuario usuarioLogado)
			throws ControladorException {

		Iterator colecaoContasIt = colecaoContas.iterator();
		Conta contaColecao;
		Conta contaNaBase;
		String[] arrayIdentificadores = null;

		// SistemaParametro sistemaParametro =
		// getControladorUtil().pesquisarParametrosDoSistema();

		// ==============================================================================================================
		// Verifica se retirará todas ou uma seleção das contas da coleção de
		// revisão
		if (identificadores != null) {
			arrayIdentificadores = identificadores.split(",");
		}
		while (colecaoContasIt.hasNext()) {
			contaColecao = (Conta) colecaoContasIt.next();
			contaNaBase = contaColecao;

			if (identificadores != null) {
				for (int index = 0; index < arrayIdentificadores.length; index++) {
					String dadosConta = arrayIdentificadores[index];
					String[] idUltimaAlteracao = dadosConta.split("-");

					// Contas que sofrerão alteração na sua data de vencimento
					if (contaColecao.getId().equals(
							new Integer(idUltimaAlteracao[0]))) {

						// -------------------------------------------------------------------------------------------
						// Alterado por : Hugo Leonardo - data : 18/08/2010
						// Analista : Aryed Lins
						// -------------------------------------------------------------------------------------------

						// E o usuário não tenha permissão especial.
						boolean temPermissaoParaAlterarVencimentoJaAlterado = this
								.getControladorPermissaoEspecial()
								.verificarPermissaoEspecial(
										PermissaoEspecial.ALTERAR_VENCIMENTO_JA_ALTERADO,
										usuarioLogado);

						if (!temPermissaoParaAlterarVencimentoJaAlterado) {

							if (getControladorUtil()
									.pesquisarParametrosDoSistema()
									.getIndicadorLimiteAlteracaoVencimento()
									.equals(ConstantesSistema.SIM)) {

								// Verifica a quantidade de alteralções no
								// vencimento de uma conta.
								this.verificarQuantidadeAlteracoesVencimentoConta(contaNaBase
										.getId());
							}
						}

						// ----------------------------------------------------------------------------------------------------

						// Data de Vencimento
						contaColecao.setDataVencimentoConta(dataVencimento);

						// Data de validade
						Date dataValidadeConta = this.retornaDataValidadeConta(dataVencimento);
						contaColecao.setDataValidadeConta(dataValidadeConta);

						// Indicador de alteração de vencimento da conta
						contaColecao.setIndicadorAlteracaoVencimento(Conta.INDICADOR_ALTERACAO_VENCIMENTO_ATIVO);

						// Última alteraçao
						contaColecao.setUltimaAlteracao(new Date());

						/*
						 * CRC_5002 Alterado por: Hugo Leonardo Data: 19/08/2010
						 * Analista: Nelson Carvalho
						 * 
						 * Atualiza a Quantidade de vezes que a conta teve o
						 * vencimento alterado
						 */
						// ----------------------------------------------------------------------------------------
						Integer numeroAlteracoesVencimento = 0;
						try {

							numeroAlteracoesVencimento = this.repositorioFaturamento.obterQuantidadeAlteracoesVencimentoConta(contaColecao.getId());
						} catch (ErroRepositorioException ex) {
							sessionContext.setRollbackOnly();
							new ControladorException("erro.sistema", ex);
						}

						if (numeroAlteracoesVencimento == null) {
							numeroAlteracoesVencimento = 0;
						}
						numeroAlteracoesVencimento = numeroAlteracoesVencimento + 1;

						contaColecao.setNumeroAlteracoesVencimento(numeroAlteracoesVencimento);
						// ----------------------------------------------------------------------------------------

						// Verificar atualização realizada por outro usuário
						if ((contaNaBase.getUltimaAlteracao().after(contaColecao.getUltimaAlteracao()))) {
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.atualizacao.timestamp");
						}

						atualizarColecaoComRegistrarTransacao(contaColecao, usuarioLogado);

					}
				}
			} else {
				// Data de Vencimento
				contaColecao.setDataVencimentoConta(dataVencimento);

				/*
				 * CRC_5002 Alterado por: Hugo Leonardo Data: 19/08/2010
				 * Analista: Nelson Carvalho
				 * 
				 * Atualiza a Quantidade de vezes que a conta teve o vencimento
				 * alterado
				 */
				// ----------------------------------------------------------------------------------------
				Integer numeroAlteracoesVencimento = 0;
				try {

					numeroAlteracoesVencimento = this.repositorioFaturamento.obterQuantidadeAlteracoesVencimentoConta(contaColecao.getId());
				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					new ControladorException("erro.sistema", ex);
				}

				if (numeroAlteracoesVencimento == null) {
					numeroAlteracoesVencimento = 0;
				}
				numeroAlteracoesVencimento = numeroAlteracoesVencimento + 1;

				contaColecao.setNumeroAlteracoesVencimento(numeroAlteracoesVencimento);
				// ----------------------------------------------------------------------------------------

				// Data de validade
				Date dataValidadeConta = this.retornaDataValidadeConta(dataVencimento);
				contaColecao.setDataValidadeConta(dataValidadeConta);

				// Indicador de alteração de vencimento da conta
				contaColecao.setIndicadorAlteracaoVencimento(Conta.INDICADOR_ALTERACAO_VENCIMENTO_ATIVO);

				// Última alteraçao
				contaColecao.setUltimaAlteracao(new Date());

				// Verificar atualização realizada por outro usuário
				if ((contaNaBase.getUltimaAlteracao().after(contaColecao.getUltimaAlteracao()))) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.atualizacao.timestamp");
				}

				atualizarColecaoComRegistrarTransacao(contaColecao, usuarioLogado);

			}
		}
	}

	public void atualizarColecaoComRegistrarTransacao(Conta contaColecao, Usuario usuarioLogado) throws ControladorException {
		// ------------ <REGISTRAR TRANSAÇÃO>----------------------------

		RegistradorOperacao registradorOperacao = null;
		if (usuarioLogado != null) {
			registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ALTERAR_VENCIMENTO_CONTA,
					contaColecao.getImovel() != null ? contaColecao.getImovel().getId() : contaColecao.getId(), contaColecao.getId(),
					new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			registradorOperacao.registrarOperacao(contaColecao);

			getControladorTransacao().registrarTransacao(contaColecao);
		}
		// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

		// UPDATE
		try {
			repositorioFaturamento.alterarVencimentoConta(contaColecao);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Author: Raphael Rossiter
	 * 
	 * @param dataVencimento
	 * @return data de validade da conta de acordo com a date de vencimento
	 *         recebida
	 * @throws ControladorException
	 */
	public Date retornaDataValidadeConta(Date dataVencimento) throws ControladorException {
		Date retorno = null;

		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		Calendar dataValidadeConta = new GregorianCalendar();
		dataValidadeConta.setTime(dataVencimento);

		// Último dia do mês correspondente ao mês da data de vencimento da
		// conta
		dataValidadeConta.set(Calendar.DATE, 1);
		dataValidadeConta.add(Calendar.MONTH, 1);
		dataValidadeConta.add(Calendar.DATE, -1);

		// Acrescenta o número de meses de validade da conta
		dataValidadeConta.add(Calendar.MONTH, sistemaParametro
				.getNumeroMesesValidadeConta().intValue());

		retorno = dataValidadeConta.getTime();

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 26/12/2005
	 * 
	 * @param conta
	 * @return uma coleção com os débitos cobrados de uma conta
	 * @throws ControladorException
	 * @throws
	 */
	public Collection<DebitoCobrado> obterDebitosCobradosConta(Conta conta)
			throws ControladorException {
		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDebitoCobradoArray = null;

		try {
			colecaoDebitoCobradoArray = repositorioFaturamento
					.buscarDebitosCobradosConta(conta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDebitoCobradoArray != null
				&& !colecaoDebitoCobradoArray.isEmpty()) {

			retorno = new ArrayList();

			Iterator colecaoDebitoCobradoArrayIterator = colecaoDebitoCobradoArray
					.iterator();

			while (colecaoDebitoCobradoArrayIterator.hasNext()) {

				// Obtém os dados do débito cobrado
				Object[] debitoCobradoArray = (Object[]) colecaoDebitoCobradoArrayIterator
						.next();

				DebitoCobrado debitoCobrado = new DebitoCobrado();

				// ID do débito
				debitoCobrado.setId((Integer) debitoCobradoArray[0]);

				// Tipo do débito
				FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
				financiamentoTipo.setId((Integer) debitoCobradoArray[10]);
				LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
				lancamentoItemContabil.setId((Integer) debitoCobradoArray[11]);

				DebitoTipo debitoTipo = new DebitoTipo();

				debitoTipo.setId((Integer) debitoCobradoArray[1]);
				debitoTipo.setDescricao(String.valueOf(debitoCobradoArray[2]));
				debitoTipo.setDescricaoAbreviada(String
						.valueOf(debitoCobradoArray[9]));
				debitoTipo.setFinanciamentoTipo(financiamentoTipo);
				debitoTipo.setLancamentoItemContabil(lancamentoItemContabil);

				debitoCobrado.setDebitoTipo(debitoTipo);

				// Ano e Mês do débito
				if (debitoCobradoArray[3] != null) {
					debitoCobrado
							.setAnoMesReferenciaDebito((Integer) debitoCobradoArray[3]);
				}

				// Ano e Mês de cobrança do débito
				if (debitoCobradoArray[4] != null) {
					debitoCobrado
							.setAnoMesCobrancaDebito((Integer) debitoCobradoArray[4]);
				}

				// Número de prestações
				debitoCobrado.setNumeroPrestacao((Short) debitoCobradoArray[5]);

				// Número da prestação
				debitoCobrado
						.setNumeroPrestacaoDebito((Short) debitoCobradoArray[6]);

				// Valor do débito
				debitoCobrado
						.setValorPrestacao((BigDecimal) debitoCobradoArray[7]);

				// Número de parcela bonus
				debitoCobrado
						.setNumeroParcelaBonus((Short) debitoCobradoArray[12]);

				// Ultima alteração
				String ultimaAlteracao = String.valueOf(debitoCobradoArray[8]);

				SimpleDateFormat formatoData = new SimpleDateFormat(
						"yyyy-MM-dd HH:mm:ss");

				Date dataUltimaAlteracao;

				try {
					dataUltimaAlteracao = formatoData.parse(ultimaAlteracao);
				} catch (java.text.ParseException e) {
					dataUltimaAlteracao = null;
				}

				debitoCobrado.setUltimaAlteracao(dataUltimaAlteracao);

				retorno.add(debitoCobrado);
			}
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Tiago Moreno Data: 28/07/2007
	 * 
	 * 
	 * @throws ControladorException
	 * @throws
	 */
	public Collection<DebitoCobradoAgrupadoHelper> obterDebitosCobradosContaCAERN(
			Conta conta) throws ControladorException {
		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDebitoCobradoArray = null;

		try {
			colecaoDebitoCobradoArray = repositorioFaturamento
					.buscarDebitosCobradosEmitirContaCaern(conta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDebitoCobradoArray != null
				&& !colecaoDebitoCobradoArray.isEmpty()) {

			Iterator colecaoDebitoCobradoArrayIterator = colecaoDebitoCobradoArray
					.iterator();

			while (colecaoDebitoCobradoArrayIterator.hasNext()) {

				// Obtém os dados do débito cobrado
				Object[] debitoCobradoArray = (Object[]) colecaoDebitoCobradoArrayIterator
						.next();

				DebitoCobradoAgrupadoHelper debitoCobrado = new DebitoCobradoAgrupadoHelper();

				// ID do débito
				debitoCobrado.setIdDebitoTipo((Integer) debitoCobradoArray[0]);

				debitoCobrado
						.setDescricaoDebitoTipo((String) debitoCobradoArray[1]);
				debitoCobrado.setNumeroPrestacao(new Integer(
						(Short) debitoCobradoArray[2]));
				debitoCobrado.setNumeroPrestacaoDebito(new Integer(
						(Short) debitoCobradoArray[3]));
				debitoCobrado
						.setValorDebito((BigDecimal) debitoCobradoArray[4]);

				retorno.add(debitoCobrado);
			}
		}

		return retorno;
	}

	public Collection<CreditoRealizado> obterCreditosRealizadosConta(Conta conta) throws ControladorException {
		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoCreditoRealizadoArray = null;

		try {
			colecaoCreditoRealizadoArray = repositorioFaturamento
					.buscarCreditosRealizadosConta(conta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoCreditoRealizadoArray != null
				&& !colecaoCreditoRealizadoArray.isEmpty()) {

			Iterator colecaoCreditoRealizadoArrayIterator = colecaoCreditoRealizadoArray
					.iterator();

			while (colecaoCreditoRealizadoArrayIterator.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] creditoRealizadoArray = (Object[]) colecaoCreditoRealizadoArrayIterator
						.next();

				CreditoRealizado creditoRealizado = new CreditoRealizado();

				// ID do crédito
				creditoRealizado.setId((Integer) creditoRealizadoArray[0]);

				// Tipo do crédito
				LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
				lancamentoItemContabil
						.setId((Integer) creditoRealizadoArray[10]);
				CreditoTipo creditoTipo = new CreditoTipo();

				creditoTipo.setId((Integer) creditoRealizadoArray[1]);
				creditoTipo.setDescricao(String
						.valueOf(creditoRealizadoArray[2]));
				creditoTipo.setDescricaoAbreviada(String
						.valueOf(creditoRealizadoArray[3]));

				creditoTipo.setLancamentoItemContabil(lancamentoItemContabil);

				creditoRealizado.setCreditoTipo(creditoTipo);

				// Ano e Mês do crédito
				if (creditoRealizadoArray[4] != null) {
					creditoRealizado
							.setAnoMesReferenciaCredito((Integer) creditoRealizadoArray[4]);
				}

				// Ano e Mês de cobrança do crédito
				if (creditoRealizadoArray[5] != null) {
					creditoRealizado
							.setAnoMesCobrancaCredito((Integer) creditoRealizadoArray[5]);
				}

				// Número de prestações
				creditoRealizado
						.setNumeroPrestacao((Short) creditoRealizadoArray[6]);

				// Número da prestação
				creditoRealizado
						.setNumeroPrestacaoCredito((Short) creditoRealizadoArray[7]);

				// Valor do crédito
				creditoRealizado
						.setValorCredito((BigDecimal) creditoRealizadoArray[8]);

				// Ultima alteração
				String ultimaAlteracao = String
						.valueOf(creditoRealizadoArray[9]);

				// Origem do Crédito
				if (creditoRealizadoArray[11] != null) {
					CreditoOrigem creditoOrigem = new CreditoOrigem();
					creditoOrigem.setId((Integer) creditoRealizadoArray[11]);
					creditoRealizado.setCreditoOrigem(creditoOrigem);
				}

				SimpleDateFormat formatoData = new SimpleDateFormat(
						"yyyy-MM-dd HH:mm:ss");

				Date dataUltimaAlteracao;

				try {
					dataUltimaAlteracao = formatoData.parse(ultimaAlteracao);
				} catch (java.text.ParseException e) {
					dataUltimaAlteracao = null;
				}

				creditoRealizado.setUltimaAlteracao(dataUltimaAlteracao);

				// numero de parcela bonus
				if (creditoRealizadoArray[12] != null) {
					creditoRealizado
							.setNumeroParcelaBonus((Short) creditoRealizadoArray[12]);
				}

				// Crédito a Realizar
				if (creditoRealizadoArray[13] != null) {
					CreditoARealizarGeral creditoARealizar = new CreditoARealizarGeral();
					creditoARealizar.setId((Integer) creditoRealizadoArray[13]);
					creditoRealizado.setCreditoARealizarGeral(creditoARealizar);
				}

				retorno.add(creditoRealizado);
			}
		}

		return retorno;
	}

	/**
	 * [US0184] Manter Débito A Cobrar Author: Rafael Santos Data: 30/12/2005
	 * 
	 * @param idsLista
	 *            de Id de Débito a Cobrar
	 * @throws ControladorException
	 */
	public void cancelarDebitoACobrar(String[] ids, Usuario usuarioLogado,
			Integer matriculaImovel) throws ControladorException {

		// para cada debito a cobrar
		for (int i = 0; i < ids.length; i++) {

			String id = ids[i];

			FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();

			filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
					FiltroDebitoACobrar.ID, id));

			Collection colecaoDebitosACobrar = getControladorUtil().pesquisar(
					filtroDebitoACobrar, DebitoACobrar.class.getName());

			DebitoACobrar debitoACobrar = (DebitoACobrar) colecaoDebitosACobrar
					.iterator().next();

			FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
			filtroDebitoTipo.adicionarParametro(new ParametroSimples(
					FiltroDebitoTipo.ID, debitoACobrar.getId()));

			Collection colecaoDebitosTipos = getControladorUtil().pesquisar(
					filtroDebitoTipo, DebitoTipo.class.getName());

			if (colecaoDebitosTipos != null && !colecaoDebitosTipos.isEmpty()) {

				DebitoTipo debitoTipo = (DebitoTipo) colecaoDebitosTipos
						.iterator().next();

				if (debitoACobrar.getValorDebito().compareTo(
						debitoTipo.getValorLimite()) == 1) {

					throw new ControladorException(
							"atencao.debito_a_cobrar.valor_total_servico",
							null, debitoTipo.getValorLimite().toString()
									.replace(".", ","));
				}
			}

		}

		Integer anoMesFaturamento = getControladorUtil()
				.pesquisarParametrosDoSistema().getAnoMesFaturamento();

		// para cada debito a cobrar
		for (int i = 0; i < ids.length; i++) {
			String id = ids[i];

			FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
			filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
					FiltroDebitoACobrar.ID, id));

			filtroDebitoACobrar.setInitializeLazy(true);
			filtroDebitoACobrar
					.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.DEBITO_CREDITO_SITUACAO_ATUAL);
			filtroDebitoACobrar
					.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.FINANCIAMENTO_TIPO);

			Collection colecaoDebitosACobrar = getControladorUtil().pesquisar(
					filtroDebitoACobrar, DebitoACobrar.class.getName());

			DebitoACobrar debitoACobrar = (DebitoACobrar) colecaoDebitosACobrar
					.iterator().next();
			debitoACobrar.setUsuario(usuarioLogado);

			FiltroDebitoACobrarGeral filtroDebitoACobrarGeral = new FiltroDebitoACobrarGeral();
			filtroDebitoACobrarGeral.adicionarParametro(new ParametroSimples(
					FiltroDebitoACobrarGeral.ID, id));

			Collection colecaoDebitosACobrarGeral = getControladorUtil()
					.pesquisar(filtroDebitoACobrarGeral,
							DebitoACobrarGeral.class.getName());

			DebitoACobrarGeral debitoACobrarGeral = (DebitoACobrarGeral) colecaoDebitosACobrarGeral
					.iterator().next();

			FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItem = new FiltroCobrancaDocumentoItem();
			filtroCobrancaDocumentoItem
					.adicionarParametro(new ParametroSimples(
							FiltroCobrancaDocumentoItem.DEBITO_A_COBRAR_GERAL_ID,
							debitoACobrarGeral.getId()));

			Collection colecaoCobrancaDocumentoItem = getControladorUtil()
					.pesquisar(filtroCobrancaDocumentoItem,
							CobrancaDocumentoItem.class.getName());

			/*
			 * Alterado por Raphael Rossiter em 14/09/2007 (Analista: Rosana
			 * Carvalho e Eduardo Borges) OBJ: Não permitir que um débito a
			 * cobrar de parcelamento seja cancelado.
			 */
			if (debitoACobrar.getFinanciamentoTipo() != null
					&& debitoACobrar.getFinanciamentoTipo().getId()
							.equals(FinanciamentoTipo.PARCELAMENTO_AGUA)
					&& debitoACobrar.getNumeroPrestacaoCobradas() == 0) {

				boolean temPermissaoExcluirDebitoACobrar = this
						.getControladorPermissaoEspecial()
						.verificarPermissaoExcluirDebitoACobrar(usuarioLogado);

				if (!temPermissaoExcluirDebitoACobrar) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.debito_a_cobrar.financiamento_tipo_parcelamento");
				}
			}

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(
					Operacao.OPERACAO_DEBITO_A_COBRAR_CANCELAR,
					matriculaImovel, debitoACobrar.getId(),
					new UsuarioAcaoUsuarioHelper(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			registradorOperacao.registrarOperacao(debitoACobrar);
			registradorOperacao.registrarOperacao(debitoACobrarGeral);

			// ------------ REGISTRAR TRANSAÇÃO ----------------

			// 7.1.1
			if ((debitoACobrar.getNumeroPrestacaoCobradas() == 0)
					&& (debitoACobrar.getAnoMesReferenciaContabil() >= anoMesFaturamento)
					&& (colecaoCobrancaDocumentoItem == null || colecaoCobrancaDocumentoItem
							.isEmpty())
					&& (debitoACobrar.getFinanciamentoTipo().getId()
							.equals(FinanciamentoTipo.SERVICO_NORMAL))) {

				/**
				 * alterado por pedro alexandre dia 21/11/2006 alteração feita
				 * para acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado,
						debitoACobrar.getImovel());

				if (!getControladorAcesso().verificarAcessoAbrangencia(
						abrangencia)) {

					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.acesso.negado.abrangencia");

				} else {

					FiltroDebitoACobrarCategoria filtroDebitoACobrarCategoria = new FiltroDebitoACobrarCategoria();
					filtroDebitoACobrarCategoria
							.adicionarParametro(new ParametroSimples(
									FiltroDebitoACobrarCategoria.ID_DEBITO_A_COBRAR,
									debitoACobrar.getId()));

					Collection colecaoDebitosACobrarCategoria = getControladorUtil()
							.pesquisar(filtroDebitoACobrarCategoria,
									DebitoACobrarCategoria.class.getName());

					if (colecaoDebitosACobrarCategoria != null
							&& !colecaoDebitosACobrarCategoria.isEmpty()) {

						Iterator iteratorColecaoDebitosACobrarCategoria = colecaoDebitosACobrarCategoria
								.iterator();

						while (iteratorColecaoDebitosACobrarCategoria.hasNext()) {
							DebitoACobrarCategoria debitoACobrarCategoria = (DebitoACobrarCategoria) iteratorColecaoDebitosACobrarCategoria
									.next();

							getControladorUtil()
									.remover(debitoACobrarCategoria);
						}
					}

					String[] idsDebitosACobrar = new String[1];

					idsDebitosACobrar[0] = debitoACobrarGeral.getId()
							.toString();

					try {

						this.repositorioFaturamento
								.cancelarAutosInfracao(idsDebitosACobrar);

						getControladorUtil().remover(debitoACobrar);

						getControladorUtil().remover(debitoACobrarGeral);

					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						new ControladorException("erro.sistema", ex);
					}

				}
				// ------------ FIM CONTROLE DE ABRANGENCIA ------------

			} else if (debitoACobrar.getAnoMesReferenciaContabil() >= anoMesFaturamento) {

				debitoACobrar.setDebitoCreditoSituacaoAnterior(debitoACobrar
						.getDebitoCreditoSituacaoAtual());
				DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
				debitoCreditoSituacao.setId(DebitoCreditoSituacao.CANCELADA);
				debitoACobrar
						.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
				debitoACobrar.setUltimaAlteracao(new Date());

				/**
				 * alterado por pedro alexandre dia 21/11/2006 alteração feita
				 * para acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado,
						debitoACobrar.getImovel());

				if (!getControladorAcesso().verificarAcessoAbrangencia(
						abrangencia)) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.acesso.negado.abrangencia");
				} else {

					// Esta alteracao sera registrada como exclusao
					Interceptador.getInstancia().registrarExclusao(
							debitoACobrar);

					// Para nao registrar a alteracao também, setamos a operacao
					// efetuada para nula.
					debitoACobrar.setOperacaoEfetuada(null);
					getControladorUtil().atualizar(debitoACobrar);

				}
			} else {

				debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
				DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
				debitoCreditoSituacao.setId(DebitoCreditoSituacao.CANCELADA);
				debitoACobrar
						.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
				debitoACobrar.setAnoMesReferenciaContabil(anoMesFaturamento);

				// Autor: Bruno Barros
				// Data : 12/05/2009
				// Analista Responsável: Rosana Cavalho
				// Descrição da alteração: Gravar na coluna
				// DBAC_AMREFERENCIACONTABIL o maior valor entre o ano/mes
				// da data corrente e o ano/mês da referência do faturamento (
				// PARM_AMREFERENCIAFATURAMENTO )
				Date dataAtual = new Date();
				Integer anoMesReferenciaAtual = Util
						.recuperaAnoMesDaData(dataAtual);

				SistemaParametro sistemaParametro = this.getControladorUtil()
						.pesquisarParametrosDoSistema();

				debitoACobrar.setAnoMesReferenciaContabil(

				(anoMesReferenciaAtual > sistemaParametro
						.getAnoMesFaturamento() ? anoMesReferenciaAtual
						: sistemaParametro.getAnoMesFaturamento())

				);
				// FIM ALTERAÇÃO BRUNO BARROS

				/**
				 * alterado por pedro alexandre dia 21/11/2006 alteração feita
				 * para acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado,
						debitoACobrar.getImovel());

				if (!getControladorAcesso().verificarAcessoAbrangencia(
						abrangencia)) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.acesso.negado.abrangencia");
				} else {

					// Esta alteracao sera registrada como exclusao
					Interceptador.getInstancia().registrarExclusao(
							debitoACobrar);
					// Para nao registrar a alteracao também, setamos a operacao
					// efetuada para nula.
					debitoACobrar.setOperacaoEfetuada(null);
					getControladorUtil().atualizar(debitoACobrar);
				}

			}

			// Alterado por Francisco - 26/05/08, por conta do Resumo de Ações
			// de cobrança
			// Analista: Ana Breda
			try {

				// Atualizar documento de cobranca da conta, se houver, para
				// cancelado
				repositorioCobranca.atualizarSituacaoCobrancaDocumentoItem(
						CobrancaDebitoSituacao.CANCELADO, new Date(), null,
						null, debitoACobrar.getId());

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}

		}
	}

	/**
	 * Remover Vigencias [UC0169] Manter Tarifa de Consumo
	 * 
	 * [SB0002] Excluir Tarifa de Consumo
	 * 
	 * @param ids
	 *            []String
	 * @author tiago moreno, Rafael Santos
	 * @date 04/04/2006,20/07/2006
	 * 
	 */
	public void removerTarifaConsumo(String[] ids) throws ControladorException {

		// recebe os ids das vigencias a ser excluídas do action e faz um
		// interator para fazer a verificacao de vigencia por vigencia
		for (int i = 0; i < ids.length; i++) {
			// monta o filtro pra recuperar a data da vigencia
			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia
					.adicionarParametro(new ParametroSimples(
							FiltroConsumoTarifaVigencia.ID, ids[i]));
			Collection<ConsumoTarifaVigencia> colecaoConsumoTarifaVigencia = getControladorUtil()
					.pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());

			// jogaa a data em nessa variável
			Date dataVigencia = colecaoConsumoTarifaVigencia.iterator().next()
					.getDataVigencia();

			// monta o filtro para pegar todas os FaturamentoAtividadeCronograma
			// a data de realizacao tem que ser maior ou igual a data da
			// vigencia o id da atividade tem q ser igual a 2 (EFETUAR LEITURA)

			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
			filtroFaturamentoAtividadeCronograma
					.adicionarParametro(new MaiorQue(
							FiltroFaturamentoAtividadeCronograma.DATA_REALIZADA,
							dataVigencia));
			// valor correspondente a EFETUAR LEITURA
			filtroFaturamentoAtividadeCronograma
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID,
							FaturamentoAtividade.EFETUAR_LEITURA.toString()));
			filtroFaturamentoAtividadeCronograma
					.adicionarCaminhoParaCarregamentoEntidade("faturamentoAtividade");
			filtroFaturamentoAtividadeCronograma
					.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupoCronogramaMensal");
			Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronograma = getControladorUtil()
					.pesquisar(filtroFaturamentoAtividadeCronograma,
							FaturamentoAtividadeCronograma.class.getName());

			// verifica se há dados na colecao e faz um iterator pra recuperar
			// todos que tem o id da atividade igual a 5 que a data de
			// realização
			// seja diferente de null e que o id do cronograma grupo mensal seja
			// igual a da colecao de FatAtvCronograma vigente no iterator
			// anterior
			if (colecaoFaturamentoAtividadeCronograma != null
					&& !colecaoFaturamentoAtividadeCronograma.isEmpty()) {
				for (Iterator it = colecaoFaturamentoAtividadeCronograma
						.iterator(); it.hasNext();) {
					FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) it
							.next();

					FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma2 = new FiltroFaturamentoAtividadeCronograma();
					// valor correspondente a FATURAR GRUPO
					filtroFaturamentoAtividadeCronograma2
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID,
									FaturamentoAtividade.FATURAR_GRUPO
											.toString()));
					filtroFaturamentoAtividadeCronograma2
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID,
									faturamentoAtividadeCronograma
											.getFaturamentoGrupoCronogramaMensal()
											.getId()));
					filtroFaturamentoAtividadeCronograma2
							.adicionarParametro(new ParametroNaoNulo(
									FiltroFaturamentoAtividadeCronograma.DATA_REALIZADA));
					filtroFaturamentoAtividadeCronograma2
							.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupoCronogramaMensal");

					Collection<FaturamentoAtividadeCronograma> colecaoRetornoFaturamentoAtividadeCronograma = getControladorUtil()
							.pesquisar(
									filtroFaturamentoAtividadeCronograma2,
									FaturamentoAtividadeCronograma.class
											.getName());

					// se a colecao retornar dados, jogasse a excessão
					if (colecaoRetornoFaturamentoAtividadeCronograma != null
							&& !colecaoRetornoFaturamentoAtividadeCronograma
									.isEmpty()) {
						throw new ControladorException(
								"atencao.data_vigencia_usada", null,
								Util.formatarData(dataVigencia));
					}
				}
			}

		}

	}

	/**
	 * Reajustar os dados de consumo tarifa UC169
	 * 
	 * @author tiago moreno,Rafel Santos
	 * @date 04/04/2006,11/07/2006
	 * 
	 */

	public void reajustarTarifaConsumo(
			Map<ConsumoTarifaVigencia, Map<ConsumoTarifaCategoria, BigDecimal>> mapReajuste)
			throws ControladorException {

		verificarDataVigencia(mapReajuste);

		Iterator<ConsumoTarifaVigencia> iteratorTarifaVigencia = mapReajuste
				.keySet().iterator();

		while (iteratorTarifaVigencia.hasNext()) {
			ConsumoTarifaVigencia consumoTarifaVigencia = iteratorTarifaVigencia
					.next();

			ConsumoTarifaVigencia consumoTarifaVigenciaNova = new ConsumoTarifaVigencia();

			// setando os valores para inserir uma nova Tarifa de Consumo
			// Vigencia.
			consumoTarifaVigenciaNova.setConsumoTarifa(consumoTarifaVigencia
					.getConsumoTarifa());
			consumoTarifaVigenciaNova.setDataVigencia(consumoTarifaVigencia
					.getDataVigencia());
			consumoTarifaVigenciaNova.setUltimaAlteracao(new Date());

			Integer idConsumoTarifaVigencia = (Integer) getControladorUtil()
					.inserir(consumoTarifaVigenciaNova);

			// setando o novo id para ser utilizado nas categorias
			consumoTarifaVigenciaNova.setId(idConsumoTarifaVigencia);

			Iterator iteratorConsumoTarifaCategoria = consumoTarifaVigencia
					.getConsumoTarifaCategorias().iterator();

			while (iteratorConsumoTarifaCategoria.hasNext()) {
				ConsumoTarifaCategoria consumoTarifaCategoria = (ConsumoTarifaCategoria) iteratorConsumoTarifaCategoria
						.next();

				BigDecimal percentualReajuste = ((mapReajuste
						.get(consumoTarifaVigencia))
						.get(consumoTarifaCategoria));

				BigDecimal cem = new BigDecimal("100");

				BigDecimal resultadoReajusteTarifaCategoria = consumoTarifaCategoria
						.getValorTarifaMinima();
				resultadoReajusteTarifaCategoria = resultadoReajusteTarifaCategoria
						.multiply(percentualReajuste.divide(cem));

				resultadoReajusteTarifaCategoria = resultadoReajusteTarifaCategoria
						.add(consumoTarifaCategoria.getValorTarifaMinima());

				ConsumoTarifaCategoria consumoTarifaCategoriaNova = new ConsumoTarifaCategoria();

				// setando os valores para inserir uma nova Tarifa de Consumo
				// Categoria.
				consumoTarifaCategoriaNova
						.setConsumoTarifaVigencia(consumoTarifaVigenciaNova);
				consumoTarifaCategoriaNova.setCategoria(consumoTarifaCategoria
						.getCategoria());
				consumoTarifaCategoriaNova
						.setNumeroConsumoMinimo(consumoTarifaCategoria
								.getNumeroConsumoMinimo());
				consumoTarifaCategoriaNova
						.setValorTarifaMinima(resultadoReajusteTarifaCategoria);

				Subcategoria subCategoria = new Subcategoria();
				subCategoria.setId(0);
				consumoTarifaCategoriaNova.setSubCategoria(subCategoria);

				consumoTarifaCategoriaNova.setUltimaAlteracao(new Date());

				Integer idConsumoTarifaCategoria = (Integer) getControladorUtil()
						.inserir(consumoTarifaCategoriaNova);

				// setando o novo id para ser utilizado nas faixas
				consumoTarifaCategoriaNova.setId(idConsumoTarifaCategoria);

				FiltroConsumoTarifaFaixa filtroConsumoTarifaFaixa = new FiltroConsumoTarifaFaixa();

				filtroConsumoTarifaFaixa
						.adicionarParametro(new ParametroSimples(
								FiltroConsumoTarifaFaixa.CONSUMO_TARIFA_CATEGORIA_ID,
								consumoTarifaCategoria.getId()));

				Collection<ConsumoTarifaFaixa> colecaoConsumoTarifaFaixa = getControladorUtil()
						.pesquisar(filtroConsumoTarifaFaixa,
								ConsumoTarifaFaixa.class.getName());

				Iterator iteratorConsumoTarifaFaixa = colecaoConsumoTarifaFaixa
						.iterator();

				while (iteratorConsumoTarifaFaixa.hasNext()) {
					ConsumoTarifaFaixa consumoTarifaFaixa = (ConsumoTarifaFaixa) iteratorConsumoTarifaFaixa
							.next();

					BigDecimal percentil = new BigDecimal("100");

					BigDecimal resultadoReajusteTarifaFaixa = consumoTarifaFaixa
							.getValorConsumoTarifa();
					resultadoReajusteTarifaFaixa = resultadoReajusteTarifaFaixa
							.multiply(percentualReajuste.divide(percentil));
					resultadoReajusteTarifaFaixa = resultadoReajusteTarifaFaixa
							.add(consumoTarifaFaixa.getValorConsumoTarifa());

					/*
					 * BigDecimal resultadoReajusteTarifaFaixa =
					 * consumoTarifaFaixa .getValorConsumoTarifa().multiply(
					 * percentualReajuste.divide(cem).add( consumoTarifaFaixa
					 * .getValorConsumoTarifa()));
					 */

					// setando os valores para inserir uma nova Tarifa de
					// Consumo Faixa.
					ConsumoTarifaFaixa consumoTarifaFaixaNova = new ConsumoTarifaFaixa();
					consumoTarifaFaixaNova
							.setConsumoTarifaCategoria(consumoTarifaCategoriaNova);
					consumoTarifaFaixaNova
							.setNumeroConsumoFaixaFim(consumoTarifaFaixa
									.getNumeroConsumoFaixaFim());
					consumoTarifaFaixaNova
							.setNumeroConsumoFaixaInicio(consumoTarifaFaixa
									.getNumeroConsumoFaixaInicio());
					consumoTarifaFaixaNova.setUltimaAlteracao(new Date());
					consumoTarifaFaixaNova
							.setValorConsumoTarifa(resultadoReajusteTarifaFaixa);

					getControladorUtil().inserir(consumoTarifaFaixaNova);
				}
			}

		}
	}

	/**
	 * Atualiza os dados de consumo tarifa UC169
	 * 
	 * @author tiago moreno
	 * @date 04/04/2006
	 * 
	 * @param consumoTarifaVigencia
	 */

	public void atualizarConsumoTarifa(
			ConsumoTarifaVigencia consumoTarifaVigencia,
			Collection<CategoriaFaixaConsumoTarifaHelper> colecaoCategoriaFaixaConsumoTarifaHelper,
			String func) throws ControladorException {

		// filtro ConsumoTarifaVigencia
		FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();

		// Parte de Validacao com Timestamp

		filtroConsumoTarifaVigencia.limparListaParametros();

		// Seta o ConsumoTarifaVigencia
		filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(
				FiltroConsumoTarifaVigencia.ID, consumoTarifaVigencia.getId()));

		// Procura o ConsumoTarifaVigencia
		ConsumoTarifaVigencia consumoTarifaVigenciaNaBase = (ConsumoTarifaVigencia) ((List) (getControladorUtil()
				.pesquisar(filtroConsumoTarifaVigencia,
						ConsumoTarifaVigencia.class.getName()))).get(0);

		// Verificar se o ConsumoTarifaVigencia já foi atualizado por outro
		// usuário
		// durante
		// esta atualização
		if (consumoTarifaVigenciaNaBase.getUltimaAlteracao().after(
				consumoTarifaVigencia.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		filtroConsumoTarifaVigencia.limparListaParametros();

		// Verificar se já existe uma tarifa com a mesma descricao informada

		filtroConsumoTarifaVigencia
				.adicionarParametro(new ParametroSimplesDiferenteDe(
						FiltroConsumoTarifaVigencia.CONSUMO_TARIFA_ID,
						consumoTarifaVigencia.getConsumoTarifa().getId()));

		filtroConsumoTarifaVigencia.adicionarParametro(new ComparacaoTexto(
				FiltroConsumoTarifaVigencia.CONSUMO_TARIFA_DESCRICAO,
				consumoTarifaVigencia.getConsumoTarifa().getDescricao()));

		/*
		 * Collection
		 * colecaoConsumoTarifaVigenciaExistenteDescricaoTarifaConsumo =
		 * getControladorUtil() .pesquisar(filtroConsumoTarifaVigencia,
		 * ConsumoTarifaVigencia.class.getName());
		 * 
		 * 
		 * if (colecaoConsumoTarifaVigenciaExistenteDescricaoTarifaConsumo !=
		 * null && !colecaoConsumoTarifaVigenciaExistenteDescricaoTarifaConsumo
		 * .isEmpty()) { throw new ControladorException(
		 * "atencao.descricao.tarifa_consumo.existente"); }
		 */

		consumoTarifaVigencia.setUltimaAlteracao(new Date());

		int idConsumoTarifa = consumoTarifaVigencia.getConsumoTarifa().getId();
		int idConsumoTarifaVigencia = consumoTarifaVigencia.getId();

		FiltroConsumoTarifa filtroConsumoTarifa = new FiltroConsumoTarifa();

		filtroConsumoTarifa.adicionarParametro(new ParametroSimples(
				FiltroConsumoTarifa.ID, idConsumoTarifa));
		Collection colecaoConsumoTarifa = getControladorUtil().pesquisar(
				filtroConsumoTarifa, ConsumoTarifa.class.getName());

		for (Iterator iter = colecaoConsumoTarifa.iterator(); iter.hasNext();) {
			ConsumoTarifa consumoTarifa = (ConsumoTarifa) iter.next();

			Collection colecaoDataVigenciaEmVigorArray = null;
			Collection colecaoDataVigenciaEmVigorArrayMaior = null;
			Calendar dataExistente = new GregorianCalendar();
			dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());

			try {
				colecaoDataVigenciaEmVigorArray = repositorioFaturamento
						.pesquisarMenorDataConsumoTarifaVigenciaEmVigor(
								consumoTarifa, idConsumoTarifaVigencia);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}

			try {
				colecaoDataVigenciaEmVigorArrayMaior = repositorioFaturamento
						.pesquisarMaiorDataConsumoTarifaVigenciaEmVigor(
								consumoTarifa, idConsumoTarifaVigencia);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			Date dataVigenciaEmVigor = null;
			// verifica se a data é maior que a data menor existente
			if (colecaoDataVigenciaEmVigorArray != null
					&& !colecaoDataVigenciaEmVigorArray.isEmpty()) {
				Iterator colecaoDataVigenciaEmVigorArrayIt = colecaoDataVigenciaEmVigorArray
						.iterator();
				dataVigenciaEmVigor = ((Date) colecaoDataVigenciaEmVigorArrayIt
						.next());
			}

			Date dataVigenciaEmVigorMaior = null;
			// verifica se a data é menor que a data informada da maior
			// existente
			if (colecaoDataVigenciaEmVigorArrayMaior != null
					&& !colecaoDataVigenciaEmVigorArrayMaior.isEmpty()) {
				Iterator colecaoDataVigenciaEmVigorArrayIt = colecaoDataVigenciaEmVigorArrayMaior
						.iterator();
				dataVigenciaEmVigorMaior = ((Date) colecaoDataVigenciaEmVigorArrayIt
						.next());
			}

			// verifica se a data é maior que a data menor existente
			if (dataVigenciaEmVigor != null) {
				Calendar dataVigenciaSerInserida = new GregorianCalendar();
				dataVigenciaSerInserida.setTime(dataVigenciaEmVigor);

				if ((dataExistente.compareTo(dataVigenciaSerInserida)) <= 0) {
					throw new ControladorException(
							"atencao.data_vigencia.menor.anterior_data", null,
							Util.formatarData(dataVigenciaEmVigor));
				}
			}

			// verifica se a data é menor que a data informada da maior
			// existente
			if (dataVigenciaEmVigorMaior != null) {
				Calendar dataVigenciaSerInserida = new GregorianCalendar();
				dataVigenciaSerInserida.setTime(dataVigenciaEmVigorMaior);

				if ((dataExistente.compareTo(dataVigenciaSerInserida)) >= 0) {
					throw new ControladorException(
							"atencao.data_vigencia.maior.anterior_data", null,
							Util.formatarData(dataVigenciaEmVigorMaior));
				}
			}

			// verifica a Data de Vigencia com a Ano Mes de Faturamento
			Integer anoMesFaturamento = getControladorUtil()
					.pesquisarParametrosDoSistema().getAnoMesFaturamento();

			dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());
			String anoMesDataVigenciaTarifa = null;
			if ((dataExistente.get(Calendar.MONTH) + 1) < 10) {
				anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR)
						+ "0" + (dataExistente.get(Calendar.MONTH) + 1);
			} else {
				anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR)
						+ "" + (dataExistente.get(Calendar.MONTH) + 1);
			}

			Integer anoMesVigencia = new Integer(anoMesDataVigenciaTarifa);

			if (anoMesVigencia.intValue() < anoMesFaturamento.intValue()) {
				throw new ControladorException(
						"atencao.data_vigencia.posterior.ano_mes_faturamento",
						null, Util.formatarAnoMesParaMesAno(anoMesFaturamento
								.intValue()));
			}

			// verificar se a Data de Vigencia é mario que 90 dias

			Calendar dataCorrente = new GregorianCalendar();
			dataCorrente.add(Calendar.DAY_OF_MONTH, 90);

			if ((dataExistente.compareTo(dataCorrente)) > 0) {
				throw new ControladorException(
						"atencao.data_vigencia.maior_que.90_dias");
			}

		}

		// Pesquisa o ConsumoTarifaVigencia por descrição e data
		filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
		filtroConsumoTarifaVigencia.limparListaParametros();

		filtroConsumoTarifaVigencia
				.adicionarCaminhoParaCarregamentoEntidade("consumoTarifa");

		filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(
				FiltroConsumoTarifaVigencia.ID, consumoTarifaVigencia.getId()));

		Collection colecaoConsumoTarifaVigencia = getControladorUtil()
				.pesquisar(filtroConsumoTarifaVigencia,
						ConsumoTarifaVigencia.class.getName());

		ConsumoTarifaVigencia consumoTarifaVigenciaColecao = (ConsumoTarifaVigencia) Util
				.retonarObjetoDeColecao(colecaoConsumoTarifaVigencia);

		// Atualizar o consumoTarifaVigencia no sistema
		consumoTarifaVigenciaColecao.setDataVigencia(consumoTarifaVigencia
				.getDataVigencia());
		consumoTarifaVigenciaColecao.setUltimaAlteracao(new Date());
		consumoTarifaVigenciaColecao.getConsumoTarifa().setDescricao(
				consumoTarifaVigencia.getConsumoTarifa().getDescricao());
		consumoTarifaVigenciaColecao.getConsumoTarifa()
				.setLigacaoAguaPerfil(
						consumoTarifaVigencia.getConsumoTarifa()
								.getLigacaoAguaPerfil());
		consumoTarifaVigenciaColecao.getConsumoTarifa().setUltimaAlteracao(
				new Date());

		getControladorUtil().atualizar(consumoTarifaVigenciaColecao);
		getControladorUtil().atualizar(
				consumoTarifaVigenciaColecao.getConsumoTarifa());

		// Remover todas Categorias e Faixas relacionadas com o Consumo Tarifa
		// sendo atualizado, a remoção de Faixa acontece por cascata no banco
		FiltroConsumoTarifaCategoria filtroConsumoTarifaCategoria = new FiltroConsumoTarifaCategoria();
		filtroConsumoTarifaCategoria.setConsultaSemLimites(true);

		filtroConsumoTarifaCategoria
				.adicionarCaminhoParaCarregamentoEntidade("consumoTarifaFaixas");

		filtroConsumoTarifaCategoria.adicionarParametro(new ParametroSimples(
				FiltroConsumoTarifaCategoria.CONSUMO_VIGENCIA_ID,
				consumoTarifaVigenciaColecao.getId()));

		if (func.equals("manterTarifaConsumo") && func != null) {

			Collection colecaoConsumoTarifaCategoria = getControladorUtil()
					.pesquisar(filtroConsumoTarifaCategoria,
							ConsumoTarifaCategoria.class.getName());

			Iterator iteratorColecaoConsumoTarifaCategoria = colecaoConsumoTarifaCategoria
					.iterator();
			ConsumoTarifaCategoria consumoTarifaCategoria = null;

			while (iteratorColecaoConsumoTarifaCategoria.hasNext()) {

				consumoTarifaCategoria = (ConsumoTarifaCategoria) iteratorColecaoConsumoTarifaCategoria
						.next();

				if (consumoTarifaCategoria.getSubCategoria().getId() != null
						&& consumoTarifaCategoria.getSubCategoria().getId()
								.equals(0)) {

					getControladorUtil().remover(
							new String[] { consumoTarifaCategoria.getId()
									.toString() },
							ConsumoTarifaCategoria.class.getName(), null, null);

				}

			}

		} else if (func.equals("informarTarifaConsumoPorSubCategoria")
				&& func != null) {

			Collection colecaoConsumoTarifaCategoria = getControladorUtil()
					.pesquisar(filtroConsumoTarifaCategoria,
							ConsumoTarifaCategoria.class.getName());

			Iterator iteratorColecaoConsumoTarifaCategoria = colecaoConsumoTarifaCategoria
					.iterator();
			ConsumoTarifaCategoria consumoTarifaCategoria = null;

			while (iteratorColecaoConsumoTarifaCategoria.hasNext()) {

				consumoTarifaCategoria = (ConsumoTarifaCategoria) iteratorColecaoConsumoTarifaCategoria
						.next();

				if (consumoTarifaCategoria.getSubCategoria().getId() != null
						&& !consumoTarifaCategoria.getSubCategoria().getId()
								.equals(0)) {

					getControladorUtil().remover(
							new String[] { consumoTarifaCategoria.getId()
									.toString() },
							ConsumoTarifaCategoria.class.getName(), null, null);

				}

			}

		}

		// Inserir as novas Categorias e Faixas

		if (func.equals("manterTarifaConsumo")) {

			for (CategoriaFaixaConsumoTarifaHelper helper : colecaoCategoriaFaixaConsumoTarifaHelper) {

				ConsumoTarifaCategoria tarifaCategoria = new ConsumoTarifaCategoria();
				tarifaCategoria
						.setConsumoTarifaVigencia(consumoTarifaVigenciaColecao);
				tarifaCategoria.setCategoria(helper.getConsumoTarifaCategoria()
						.getCategoria());
				tarifaCategoria.setNumeroConsumoMinimo(helper
						.getConsumoTarifaCategoria().getNumeroConsumoMinimo());
				tarifaCategoria.setValorTarifaMinima(helper
						.getConsumoTarifaCategoria().getValorTarifaMinima());

				if (helper.getConsumoTarifaCategoria().getSubCategoria() != null
						&& !helper.getConsumoTarifaCategoria()
								.getSubCategoria().equals("")) {
					tarifaCategoria.setSubCategoria(helper
							.getConsumoTarifaCategoria().getSubCategoria());
				} else {
					Subcategoria subCategoria = new Subcategoria();
					subCategoria.setId(0);
					tarifaCategoria.setSubCategoria(subCategoria);
				}

				tarifaCategoria.setUltimaAlteracao(new Date());
				getControladorUtil().inserir(tarifaCategoria);

				for (ConsumoTarifaFaixa faixa : helper.getColecaoFaixas()) {
					faixa.setConsumoTarifaCategoria(tarifaCategoria);
					getControladorUtil().inserir(faixa);
				}
			}

		} else if (func.equals("informarTarifaConsumoPorSubCategoria")) {

			for (CategoriaFaixaConsumoTarifaHelper helper : colecaoCategoriaFaixaConsumoTarifaHelper) {

				if (helper.getConsumoTarifaCategoria().getSubCategoria()
						.getId() != null
						&& !helper.getConsumoTarifaCategoria()
								.getSubCategoria().getId().equals(0)) {

					ConsumoTarifaCategoria tarifaCategoria = new ConsumoTarifaCategoria();
					tarifaCategoria
							.setConsumoTarifaVigencia(consumoTarifaVigenciaColecao);
					tarifaCategoria.setCategoria(helper
							.getConsumoTarifaCategoria().getCategoria());
					tarifaCategoria.setNumeroConsumoMinimo(helper
							.getConsumoTarifaCategoria()
							.getNumeroConsumoMinimo());
					tarifaCategoria
							.setValorTarifaMinima(helper
									.getConsumoTarifaCategoria()
									.getValorTarifaMinima());

					if (helper.getConsumoTarifaCategoria().getSubCategoria() != null
							&& !helper.getConsumoTarifaCategoria()
									.getSubCategoria().equals("")) {
						tarifaCategoria.setSubCategoria(helper
								.getConsumoTarifaCategoria().getSubCategoria());
					} else {
						Subcategoria subCategoria = new Subcategoria();
						subCategoria.setId(0);
						tarifaCategoria.setSubCategoria(subCategoria);
					}

					tarifaCategoria.setUltimaAlteracao(new Date());
					getControladorUtil().inserir(tarifaCategoria);

					for (ConsumoTarifaFaixa faixa : helper.getColecaoFaixas()) {
						faixa.setConsumoTarifaCategoria(tarifaCategoria);
						getControladorUtil().inserir(faixa);
					}
				}

			}

		}

	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo
	 * 
	 * @autor Tiago Moreno
	 * @date 05/01/2006
	 * @param consumoTarifa
	 * @param consumoTarifaVigencia
	 * @param colecaoConsumoTarifaCategoria
	 * @param colecaoConsumoTarifaFaixa
	 * @throws ControladorException
	 */
	public void inserirConsumoTarifa(ConsumoTarifa consumoTarifa,
			ConsumoTarifaVigencia consumoTarifaVigencia,
			Collection<ConsumoTarifaCategoria> colecaoConsumoTarifaCategoria)
			throws ControladorException {

		// Caso o objeto ConsumoTarifa já exista na base
		if (consumoTarifa.getId() != null) {

			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia
					.adicionarParametro(new ParametroSimples(
							FiltroConsumoTarifaVigencia.CONSUMO_TARIFA_ID,
							consumoTarifa.getId()));
			Collection colecaoConsumoVigenciaExistente = getControladorUtil()
					.pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());

			if (colecaoConsumoVigenciaExistente != null
					&& !colecaoConsumoVigenciaExistente.isEmpty()) {
				consumoTarifaVigencia.setConsumoTarifa(consumoTarifa);

				// [FS0002] - Verificar data de vigência

				// Pesquisando a data de vigência em vigor
				Collection colecaoDataVigenciaEmVigorArray = null;

				try {
					colecaoDataVigenciaEmVigorArray = repositorioFaturamento
							.pesquisarConsumoTarifaVigenciaEmVigor(consumoTarifa);
				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					new ControladorException("erro.sistema", ex);
				}

				Iterator colecaoDataVigenciaEmVigorArrayIt = colecaoDataVigenciaEmVigorArray
						.iterator();

				Date dataVigenciaEmVigor = ((Date) colecaoDataVigenciaEmVigorArrayIt
						.next());

				Calendar dataVigenciaSerInserida = new GregorianCalendar();
				dataVigenciaSerInserida.setTime(dataVigenciaEmVigor);

				Calendar dataExistente = new GregorianCalendar();
				dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());

				if ((dataExistente.compareTo(dataVigenciaSerInserida)) <= 0) {
					throw new ControladorException(
							"atencao.data_vigencia_errada", null,
							Util.formatarData(dataVigenciaEmVigor));
				}

				// verifica a Data de Vigencia com a Ano Mes de Faturamento
				Integer anoMesFaturamento = getControladorUtil()
						.pesquisarParametrosDoSistema().getAnoMesFaturamento();

				dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());
				String anoMesDataVigenciaTarifa = null;
				if ((dataExistente.get(Calendar.MONTH) + 1) < 10) {
					anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR)
							+ "0" + (dataExistente.get(Calendar.MONTH) + 1);
				} else {
					anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR)
							+ "" + (dataExistente.get(Calendar.MONTH) + 1);
				}

				Integer anoMesVigencia = new Integer(anoMesDataVigenciaTarifa);

				if (anoMesVigencia.intValue() < anoMesFaturamento.intValue()) {
					throw new ControladorException(
							"atencao.data_vigencia.posterior.ano_mes_faturamento",
							null, Util
									.formatarAnoMesParaMesAno(anoMesFaturamento
											.intValue()));
				}

				// verificar se a Data de Vigencia é mario que 90 dias
				Calendar dataHjNoventaDias = new GregorianCalendar();
				dataHjNoventaDias.add(Calendar.DAY_OF_MONTH, 90);

				if ((dataExistente.compareTo(dataHjNoventaDias)) > 0) {
					throw new ControladorException(
							"atencao.data_vigencia.maior_que.90_dias", null,
							Util.formatarData(dataVigenciaEmVigor));
				}

				// Inserindo o objeto ConsumoTarifaVigencia no BD
				this.getControladorUtil().inserir(consumoTarifaVigencia);
			} else {
				// Inserindo o objeto ConsumoTarifaVigencia no BD
				Integer i = (Integer) this.getControladorUtil().inserir(
						consumoTarifaVigencia);
				consumoTarifaVigencia.setId(i);
			}
		} else {

			// Obtendo o ID gerado pelo BD
			Integer idConsumoTarifaGerado = (Integer) this.getControladorUtil()
					.inserir(consumoTarifa);

			// Carregando o novo objeto ConsumoTarifa
			consumoTarifa.setId(idConsumoTarifaGerado);
			consumoTarifaVigencia.setConsumoTarifa(consumoTarifa);

			// Inserindo o objeto ConsumoTarifaVigencia no BD
			Integer i = (Integer) this.getControladorUtil().inserir(
					consumoTarifaVigencia);
			consumoTarifaVigencia.setId(i);
		}

		// Para cada categoria: O sistema inserir um objeto do tipo
		// ConsumoTarifaCategoria

		Iterator colecaoConsumoTarifaCategoriaIt = colecaoConsumoTarifaCategoria
				.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoriaColecao = null;

		while (colecaoConsumoTarifaCategoriaIt.hasNext()) {
			consumoTarifaCategoriaColecao = (ConsumoTarifaCategoria) colecaoConsumoTarifaCategoriaIt
					.next();

			consumoTarifaCategoriaColecao
					.setConsumoTarifaVigencia(consumoTarifaVigencia);

			Subcategoria subcategoria = new Subcategoria();
			subcategoria.setId(0);
			consumoTarifaCategoriaColecao.setSubCategoria(subcategoria);

			Integer codigoConsumoTarifaCategoriaColecao = (Integer) this
					.getControladorUtil()
					.inserir(consumoTarifaCategoriaColecao);
			consumoTarifaCategoriaColecao
					.setId(codigoConsumoTarifaCategoriaColecao);

			Collection consumoTarifaFaixa = new ArrayList(
					consumoTarifaCategoriaColecao.getConsumoTarifaFaixas());
			Collections.sort((List) consumoTarifaFaixa, new Comparator() {
				public int compare(Object a, Object b) {
					Integer numeroConsumoFaixaInicio1 = ((ConsumoTarifaFaixa) a)
							.getNumeroConsumoFaixaInicio();
					Integer numeroConsumoFaixaInicio2 = ((ConsumoTarifaFaixa) b)
							.getNumeroConsumoFaixaInicio();

					return numeroConsumoFaixaInicio1
							.compareTo(numeroConsumoFaixaInicio2);

				}
			});

			Iterator colecaoConsumoTarifaFaixaIt = consumoTarifaFaixa
					.iterator();

			while (colecaoConsumoTarifaFaixaIt.hasNext()) {
				ConsumoTarifaFaixa consumoTarifaFaixaColecao = (ConsumoTarifaFaixa) colecaoConsumoTarifaFaixaIt
						.next();

				consumoTarifaFaixaColecao
						.setConsumoTarifaCategoria(consumoTarifaCategoriaColecao);

				this.getControladorUtil().inserir(consumoTarifaFaixaColecao);
			}

		}

		// Para cada faixa informada para categori: O sistema inserir um objeto
		// do tipo ConsumoTarifaFaixa

	}

	/**
	 * [UC0187] - Inserir Guia de Pagamento
	 * 
	 * @author Rafael Corrêa, Pedro Alexandre, Ivan Sérgio, Raphael Rossiter
	 * @date 16/01/2006, 23/11/2006, 05/07/2007, 11/01/2010
	 * 
	 * @param guiaPagamento
	 * @param usuarioLogado
	 * @param qtdeDiasVencimento
	 * @param colecaoGuiaPagamentoItem
	 * @param localidadeParaCliente
	 * @param verificarPermissaoEspecial
	 * @return String[]
	 * @throws ControladorException
	 */
	public String[] inserirGuiaPagamento(GuiaPagamento guiaPagamento,
			Usuario usuarioLogado, Integer qtdeDiasVencimento,
			Collection colecaoGuiaPagamentoItem,
			Localidade localidadeParaCliente, boolean verificarPermissaoEspecial)
			throws ControladorException {

		/*
		 * Verifica se o usuário tem permissão especial para inserir Guia de
		 * Pagamento sem RA(38). Caso o parâmetro de permissão especial não
		 * estiver setado, o sistema não fará a checagem de permissão do usuário
		 * para inserção sem RA.
		 */

		boolean inserirGuiaPagamentoSemRa;
		if (verificarPermissaoEspecial) {
			inserirGuiaPagamentoSemRa = Fachada.getInstancia()
					.verificarPermissaoEspecial(
							PermissaoEspecial.INSERIR_GUIA_DE_PAGAMENTO_SEM_RA,
							usuarioLogado);
		} else {
			inserirGuiaPagamentoSemRa = true;
		}

		// MATRÍCULA DO IMÓVEL
		String idImovel = guiaPagamento.getImovel().getId() == null ? ""
				: guiaPagamento.getImovel().getId().toString();

		// CÓDIGO DO CLIENTE
		String codigoCliente = guiaPagamento.getCliente().getId() == null ? ""
				: guiaPagamento.getCliente().getId().toString();

		// O valor da guia é o somatorio de todos os valores das guias de
		// pagamento itens.
		Iterator iteratorGuiaPagamentoItemValor = colecaoGuiaPagamentoItem
				.iterator();
		BigDecimal valorTotalItens = BigDecimal.ZERO;

		while (iteratorGuiaPagamentoItemValor.hasNext()) {

			GuiaPagamentoItem guiaPagamentoItemValor = (GuiaPagamentoItem) iteratorGuiaPagamentoItemValor
					.next();

			if (guiaPagamento.getDebitoTipo() == null) {
				guiaPagamento.setDebitoTipo(guiaPagamentoItemValor
						.getDebitoTipo());
			}

			valorTotalItens = valorTotalItens.add(guiaPagamentoItemValor
					.getValorDebito());
		}

		guiaPagamento.setValorDebito(valorTotalItens);

		String valorDebito = guiaPagamento.getValorDebito().toString();

		/*
		 * Alterado para o caso em que o usuário tem permissão especial para
		 * inserir Guia de Pagamento sem RA(38).
		 * 
		 * REGISTRO DE ATENDIMENTO
		 */
		String idRegistroAtendimento = guiaPagamento.getRegistroAtendimento()
				.getId() == null ? "" : guiaPagamento.getRegistroAtendimento()
				.getId().toString();

		// OREDM DE SERVIÇO
		String idOrdemServico = guiaPagamento.getOrdemServico().getId() == null ? ""
				: guiaPagamento.getOrdemServico().getId().toString();

		// TIPO DO DÉBITO
		String idDebitoTipo = guiaPagamento.getDebitoTipo().getId().toString();

		// DATA DE VENCIMENTO DA GUIA
		Date dataVencimentoFormatada = guiaPagamento.getDataVencimento();

		// GERANDO OS OBJETOS PARA INSERÇÃO DA GUIA
		GuiaPagamento guiaPagamentoInserir = new GuiaPagamento();
		GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();

		// INDICADOR DE HISTORICO = 2
		Short indicadorHistorico = 2;

		Imovel imovel = null;

		/*
		 * VALIDAÇÕES PARA GERAÇÃO DA GUIA A PARTIR DA MATRÍCULA DE UM IMÓVEL
		 */
		if (idImovel != null && !idImovel.trim().equals("")
				&& Integer.parseInt(idImovel) > 0) {

			FiltroImovel filtroImovel = new FiltroImovel();
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroImovel
					.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("quadra");
			filtroImovel
					.adicionarCaminhoParaCarregamentoEntidade("ligacaoAguaSituacao");
			filtroImovel
					.adicionarCaminhoParaCarregamentoEntidade("ligacaoEsgotoSituacao");

			filtroImovel.adicionarParametro(new ParametroSimples(
					FiltroImovel.ID, idImovel));

			Collection imovelEncontrado = getControladorUtil().pesquisar(
					filtroImovel, Imovel.class.getName());

			// Verifica a existência do imóvel
			if (imovelEncontrado != null && !imovelEncontrado.isEmpty()) {

				imovel = (Imovel) imovelEncontrado.iterator().next();

				// Verifica se o imóvel foi excluído
				if (imovel.getIndicadorExclusao() == null ? false : imovel
						.getIndicadorExclusao().equals(Imovel.IMOVEL_EXCLUIDO)) {

					throw new ControladorException("atencao.imovel.excluido");
				}

				// MATRÍCULA DO IMÓVEL
				guiaPagamentoInserir.setImovel(imovel);

				// LOCALIDADE DO IMÓVEL
				guiaPagamentoInserir.setLocalidade(imovel.getLocalidade());

				FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();

				filtroImovelCobrancaSituacao
						.adicionarCaminhoParaCarregamentoEntidade("cobrancaSituacao");

				filtroImovelCobrancaSituacao
						.adicionarParametro(new ParametroSimples(
								FiltroImovelCobrancaSituacao.IMOVEL_ID, imovel
										.getId()));

				Collection imovelCobrancaSituacaoEncontrada = getControladorUtil()
						.pesquisar(filtroImovelCobrancaSituacao,
								ImovelCobrancaSituacao.class.getName());

				// Verifica se o imóvel tem débito em cobrança administrativa
				if (imovelCobrancaSituacaoEncontrada != null
						&& !imovelCobrancaSituacaoEncontrada.isEmpty()) {

					if (((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada)
							.get(0)).getCobrancaSituacao() != null) {

						if (((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada)
								.get(0))
								.getCobrancaSituacao()
								.getId()
								.equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
								&& ((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada)
										.get(0)).getDataRetiradaCobranca() == null) {

							throw new ControladorException(
									"atencao.pesquisa.imovel.cobranca_administrativa");
						}
					}
				}

			} else {
				throw new ControladorException(
						"atencao.pesquisa.imovel.inexistente.guia");
			}
		}

		/*
		 * Alterado para o caso em que o usuário tem permissão especial para
		 * inserir Guia de Pagamento sem RA(38).
		 * 
		 * Para os casos onde a guia de pagamento seja gerada a partir de um
		 * cliente, a permissão especial para geração de guia sem RA não será
		 * levanda em consideração. Para os casos onde a guia esteja sendo
		 * gerada para dar baixa nos pagamentos por cartão de crédito, será
		 * necessário informar a localidade para a qual será gerada a guia.
		 */
		RegistroAtendimento registroAtendimento = null;
		if (localidadeParaCliente == null
				&& (!inserirGuiaPagamentoSemRa || (codigoCliente != null
						&& !codigoCliente.trim().equals("") && Integer
						.parseInt(codigoCliente) > 0))) {

			FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();
			filtroRegistroAtendimento
					.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroRegistroAtendimento.adicionarParametro(new ParametroSimples(
					FiltroRegistroAtendimento.ID, idRegistroAtendimento));

			Collection registrosAtendimentos = getControladorUtil().pesquisar(
					filtroRegistroAtendimento,
					RegistroAtendimento.class.getName());

			if (registrosAtendimentos != null
					&& !registrosAtendimentos.isEmpty()) {

				Iterator registroAtendimentoIterator = registrosAtendimentos
						.iterator();
				registroAtendimento = (RegistroAtendimento) registroAtendimentoIterator
						.next();
			} else {
				throw new ControladorException(
						"atencao.registro_atendimento.inexistente");
			}
		}

		/*
		 * VALIDAÇÕES PARA GERAÇÃO DA GUIA A PARTIR DO CÓDIGO DO CLIENTE
		 */
		if (codigoCliente != null && !codigoCliente.trim().equals("")
				&& Integer.parseInt(codigoCliente) > 0) {

			FiltroCliente filtroCliente = new FiltroCliente();
			filtroCliente.adicionarCaminhoParaCarregamentoEntidade("profissao");
			filtroCliente
					.adicionarCaminhoParaCarregamentoEntidade("clienteTipo");
			filtroCliente
					.adicionarCaminhoParaCarregamentoEntidade("ramoAtividade");

			filtroCliente.adicionarParametro(new ParametroSimples(
					FiltroCliente.ID, codigoCliente));
			filtroCliente.adicionarParametro(new ParametroSimples(
					FiltroCliente.INDICADOR_USO,
					ConstantesSistema.INDICADOR_USO_ATIVO));

			Collection clienteEncontrado = getControladorUtil().pesquisar(
					filtroCliente, Cliente.class.getName());

			if (clienteEncontrado != null && !clienteEncontrado.isEmpty()) {

				guiaPagamentoInserir.setCliente((Cliente) clienteEncontrado
						.iterator().next());

				/*
				 * A localidade para o cliente será informada apenas quando a
				 * geração da guia de pagamento estiver relacionada com
				 * parcelamento por cartão de crédito
				 */
				if (localidadeParaCliente != null) {
					guiaPagamentoInserir.setLocalidade(localidadeParaCliente);
				}
				/*
				 * Caso contrário; a localidade será a mesma que estiver
				 * associada com o registro de atendimento que foi aberto para
				 * geração da guia de pagamento.
				 */
				else {
					guiaPagamentoInserir.setLocalidade(registroAtendimento
							.getLocalidade());
				}

				// Verifica se o cliente está inativo
				if (((Cliente) ((List) clienteEncontrado).get(0))
						.getIndicadorUso().equals(
								ConstantesSistema.INDICADOR_USO_DESATIVO)) {

					throw new ControladorException("atencao.cliente.inativo",
							null,
							""
									+ ((Cliente) ((List) clienteEncontrado)
											.get(0)).getId());
				}
			} else {
				throw new ControladorException(
						"atencao.pesquisa.cliente.inexistente.guia");
			}
		}

		// CARREGANDO OS PARÂMETROS DO SISTEMA
		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (sistemaParametro != null) {

			// alterado por: Vivianne Sousa 12/03/2008
			// analista responsavel: Aryed

			int anoMesReferenciaContabil = sistemaParametro
					.getAnoMesFaturamento();
			int anoMesCorrente = Util.getAnoMesComoInt(new Date());

			/*
			 * Maior valor entre o ano/mês da data corrente e o ano/mês de
			 * referencia do faturamento (PARM_AMREFERENCIAFATURAMENTO da tabela
			 * SISTEMA_PARAMETROS).
			 */
			if (sistemaParametro.getAnoMesFaturamento() < anoMesCorrente) {
				anoMesReferenciaContabil = anoMesCorrente;
			}

			guiaPagamentoInserir
					.setAnoMesReferenciaContabil(anoMesReferenciaContabil);

		} else {
			throw new ControladorException("erro.sistema");

		}

		// TIPO DO DÉBITO
		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
		filtroDebitoTipo
				.adicionarCaminhoParaCarregamentoEntidade("financiamentoTipo");
		filtroDebitoTipo
				.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.ID, idDebitoTipo));
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.INDICADOR_USO,
				ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection debitoTipoEncontrado = getControladorUtil().pesquisar(
				filtroDebitoTipo, DebitoTipo.class.getName());

		if (debitoTipoEncontrado != null && !debitoTipoEncontrado.isEmpty()) {

			DebitoTipo debitoTipo = (DebitoTipo) debitoTipoEncontrado
					.iterator().next();

			guiaPagamentoInserir.setDebitoTipo(debitoTipo);

			// FNTP_ID da tabela DEBITO_TIPO
			guiaPagamentoInserir.setFinanciamentoTipo(debitoTipo
					.getFinanciamentoTipo());

			// LICT_ID da tabela DEBITO_TIPO
			guiaPagamentoInserir.setLancamentoItemContabil(debitoTipo
					.getLancamentoItemContabil());
		}

		// ORDEM DE SERVIÇO
		if (idOrdemServico != null && !idOrdemServico.equals("")) {

			FiltroOrdemServico filtroOrdemServico = new FiltroOrdemServico();

			filtroOrdemServico.adicionarParametro(new ParametroSimples(
					FiltroOrdemServico.ID, idOrdemServico));

			Collection ordensServicos = getControladorUtil().pesquisar(
					filtroOrdemServico, OrdemServico.class.getName());

			OrdemServico ordemServico = null;
			if (ordensServicos != null && !(ordensServicos.isEmpty())) {
				ordemServico = (OrdemServico) ordensServicos.iterator().next();
			} else {
				throw new ControladorException(
						"atencao.ordem_servico.inexistente");
			}

			guiaPagamentoInserir.setOrdemServico(ordemServico);

		} else {
			guiaPagamentoInserir.setOrdemServico(null);
		}

		// DCST_IDANTERIOR = NULL
		guiaPagamentoInserir.setDebitoCreditoSituacaoAnterior(null);

		// DCST_IDATUAL = DCST_ID da tabela DEBITO_CREDITO_SITUACAO com o valor
		// correspondente a Normal
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

		guiaPagamentoInserir
				.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

		// GPAG_DTEMISSAO = DATA CORRENTE
		guiaPagamentoInserir.setDataEmissao(new Date());

		// REGISTRO DE ATENDIMENTO
		guiaPagamentoInserir.setRegistroAtendimento(registroAtendimento);

		// INDICADOR DE MULTA = 2
		guiaPagamentoInserir.setIndicadoCobrancaMulta(new Short("2"));

		// OBSERVAÇÃO
		guiaPagamentoInserir.setObservacao(guiaPagamento.getObservacao());

		// INDICADOR EMITIR OBSERVAÇÃO
		guiaPagamentoInserir.setIndicadorEmitirObservacao(guiaPagamento
				.getIndicadorEmitirObservacao());
		guiaPagamentoInserir.setUltimaAlteracao(new Date());

		Integer idGuiaPagamentoGerado = null;
		String[] idsGuiaPagamentoGerado = null;
		if (guiaPagamento.getNumeroPrestacaoTotal() != null) {

			// [FS0015]-Validar número de prestações
			if (sistemaParametro.getNumeroMaximoParcelasFinanciamento() != null
					&& sistemaParametro.getNumeroMaximoParcelasFinanciamento()
							.compareTo(guiaPagamento.getNumeroPrestacaoTotal()) < 0) {

				throw new ControladorException("atencao.valor_prestacoes",
						null, sistemaParametro
								.getNumeroMaximoParcelasFinanciamento()
								.toString());
			}

			BigDecimal valorDebitoBigDecimal = new BigDecimal(valorDebito);
			Short numeroPrestacaoTotal = guiaPagamento
					.getNumeroPrestacaoTotal();

			guiaPagamentoInserir.setNumeroPrestacaoTotal(numeroPrestacaoTotal);
			idsGuiaPagamentoGerado = new String[guiaPagamento
					.getNumeroPrestacaoTotal()];

			for (Short i = 1; i <= numeroPrestacaoTotal; i++) {

				guiaPagamentoGeral.setIndicadorHistorico(indicadorHistorico);
				guiaPagamentoGeral.setUltimaAlteracao(new Date());

				// INSERINDO GUIA DE PAGAMENTO GERAL
				idGuiaPagamentoGerado = (Integer) getControladorUtil().inserir(
						guiaPagamentoGeral);

				idsGuiaPagamentoGerado[i - 1] = idGuiaPagamentoGerado
						.toString();

				guiaPagamentoGeral.setId(idGuiaPagamentoGerado);
				guiaPagamentoInserir.setGuiaPagamentoGeral(guiaPagamentoGeral);
				guiaPagamentoInserir.setId(idGuiaPagamentoGerado);
				guiaPagamentoInserir.setNumeroPrestacaoDebito(i);
				guiaPagamentoInserir.setDataVencimento(dataVencimentoFormatada);

				guiaPagamentoInserir.setValorDebito(valorDebitoBigDecimal);

				guiaPagamentoInserir.setUsuario(usuarioLogado);

				// ------------ REGISTRAR TRANSAÇÃO ----------------

				/*
				 * Caso a guia depagamento seja para um imóvel tem controle de
				 * abrangêcia. Caso seja para um cliente não tem controle de
				 * abrangência.
				 */
				Integer valorArgumento = null;
				if (guiaPagamentoInserir.getImovel() != null) {
					valorArgumento = guiaPagamentoInserir.getImovel().getId();
				} else if (guiaPagamentoInserir.getCliente() != null) {
					valorArgumento = guiaPagamentoInserir.getCliente().getId();
				}

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_GUIA_PAGAMENTO_INSERIR,
						valorArgumento, idGuiaPagamentoGerado,
						new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(guiaPagamentoInserir);

				// ------------ REGISTRAR TRANSAÇÃO ----------------
				Integer idGuiaPagamento = null;

				if (guiaPagamentoInserir.getImovel() != null) {

					/**
					 * alterado por pedro alexandre dia 23/11/2006 alteração
					 * feita para acoplar o controle de abrangência de usuário
					 */
					// ------------ CONTROLE DE ABRANGENCIA ----------------
					Abrangencia abrangencia = new Abrangencia(usuarioLogado,
							guiaPagamentoInserir.getImovel());

					if (!getControladorAcesso().verificarAcessoAbrangencia(
							abrangencia)) {
						sessionContext.setRollbackOnly();
						throw new ControladorException(
								"atencao.acesso.negado.abrangencia");
					} else {

						// INSERINDO A GUIA DE PAGAMENTO
						idGuiaPagamento = (Integer) getControladorUtil()
								.inserir(guiaPagamentoInserir);
					}
					// ------------ FIM CONTROLE DE ABRANGENCIA ------------
				} else {
					idGuiaPagamento = (Integer) getControladorUtil().inserir(
							guiaPagamentoInserir);
				}

				guiaPagamentoInserir.setId(idGuiaPagamento);

				// INSERINDO GUIA DE PAGAMENTO ÍTEM
				Iterator iteratorGuiaPagamentoItem = colecaoGuiaPagamentoItem
						.iterator();
				while (iteratorGuiaPagamentoItem.hasNext()) {

					GuiaPagamentoItem guiaPagamentoItemInserir = (GuiaPagamentoItem) iteratorGuiaPagamentoItem
							.next();

					guiaPagamentoItemInserir
							.setGuiaPagamentoGeral(guiaPagamentoGeral);

					FiltroDebitoTipo filtroDebitoTipoItem = new FiltroDebitoTipo();

					filtroDebitoTipoItem
							.adicionarCaminhoParaCarregamentoEntidade("financiamentoTipo");
					filtroDebitoTipoItem
							.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");

					filtroDebitoTipoItem
							.adicionarParametro(new ParametroSimples(
									FiltroDebitoTipo.ID,
									guiaPagamentoItemInserir.getDebitoTipo()
											.getId()));

					filtroDebitoTipoItem
							.adicionarParametro(new ParametroSimples(
									FiltroDebitoTipo.INDICADOR_USO,
									ConstantesSistema.INDICADOR_USO_ATIVO));

					Collection colecaoDebitoTipoItem = getControladorUtil()
							.pesquisar(filtroDebitoTipoItem,
									DebitoTipo.class.getName());

					if (colecaoDebitoTipoItem != null
							&& !colecaoDebitoTipoItem.isEmpty()) {

						DebitoTipo debitoTipo = (DebitoTipo) colecaoDebitoTipoItem
								.iterator().next();
						BigDecimal valorLimite = debitoTipo.getValorLimite();

						if (guiaPagamentoItemInserir.getValorDebito()
								.compareTo(valorLimite) == 1) {
							String[] mensagens = new String[2];
							mensagens[0] = debitoTipo.getDescricao();
							mensagens[1] = Util.formatarMoedaReal(valorLimite);

							throw new ControladorException(
									"atencao.faturamento.inserir_guia_pagamento_debito_invalido",
									null, mensagens);
						} else {
							GuiaPagamentoItemPK guiaPagamentoItemPK = new GuiaPagamentoItemPK();
							guiaPagamentoItemPK.setDebitoTipoId(debitoTipo
									.getId());
							guiaPagamentoItemPK
									.setGuiaPagamentoId(guiaPagamentoInserir
											.getId());
							guiaPagamentoItemInserir
									.setComp_id(guiaPagamentoItemPK);

							// INSERINDO GUIA DE PAGAMENTO ITEM
							getControladorUtil().inserir(
									guiaPagamentoItemInserir);
						}
					}
				}

				GuiaPagamentoCategoria guiaPagamentoCategoria = new GuiaPagamentoCategoria();

				if (codigoCliente != null && !codigoCliente.equals("")) {

					Collection colecaoCategorias = new ArrayList();

					Categoria categoria = new Categoria();
					categoria.setId(Categoria.RESIDENCIAL);
					categoria.setQuantidadeEconomiasCategoria(new Integer("1"));

					colecaoCategorias.add(categoria);

					// [UC0185] - Obter Valor por Categoria
					Collection colecaoValoresPorCategoria = getControladorImovel()
							.obterValorPorCategoria(colecaoCategorias,
									guiaPagamento.getValorDebito());

					Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria
							.iterator();

					while (icolecaoValoresPorCategoria.hasNext()) {

						guiaPagamentoCategoria
								.setComp_id(new GuiaPagamentoCategoriaPK(
										categoria.getId(), guiaPagamentoInserir
												.getId()));

						BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria
								.next();

						guiaPagamentoCategoria
								.setComp_id(new GuiaPagamentoCategoriaPK(
										categoria.getId(), guiaPagamentoInserir
												.getId()));

						guiaPagamentoCategoria.setQuantidadeEconomia(categoria
								.getQuantidadeEconomiasCategoria());
						guiaPagamentoCategoria.setValorCategoria(valor);
						guiaPagamentoCategoria.setUltimaAlteracao(new Date());

						// INSERINDO GUIA DE PAGAMENTO CATEGORIA PARA CLIENTE
						getControladorUtil().inserir(guiaPagamentoCategoria);
					}

				}

				if (idImovel != null && !idImovel.equals("")) {

					// [UC0108] - Obter Quantidade de Economias por Categoria
					Collection colecaoCategoriasImovel = this
							.getControladorImovel()
							.obterQuantidadeEconomiasCategoria(imovel);

					// [UC0185] - Obter Valor por Categoria
					Collection colecaoValoresPorCategoria = getControladorImovel()
							.obterValorPorCategoria(colecaoCategoriasImovel,
									guiaPagamento.getValorDebito());

					Iterator icolecaoCategorias = colecaoCategoriasImovel
							.iterator();

					Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria
							.iterator();

					while (icolecaoValoresPorCategoria.hasNext()
							&& icolecaoCategorias.hasNext()) {

						Categoria categoria = (Categoria) icolecaoCategorias
								.next();

						BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria
								.next();

						guiaPagamentoCategoria
								.setComp_id(new GuiaPagamentoCategoriaPK(
										categoria.getId(), guiaPagamentoInserir
												.getId()));

						guiaPagamentoCategoria.setQuantidadeEconomia(categoria
								.getQuantidadeEconomiasCategoria());
						guiaPagamentoCategoria.setValorCategoria(valor);
						guiaPagamentoCategoria.setUltimaAlteracao(new Date());

						// INSERINDO GUIA DE PAGAMENTO CATEGORIA PARA IMÓVEL
						getControladorUtil().inserir(guiaPagamentoCategoria);
					}

					FiltroClienteImovel filtroClienteImovel = new FiltroClienteImovel();
					filtroClienteImovel
							.adicionarCaminhoParaCarregamentoEntidade("cliente");
					filtroClienteImovel
							.adicionarCaminhoParaCarregamentoEntidade("clienteRelacaoTipo");

					filtroClienteImovel
							.adicionarParametro(new ParametroSimples(
									FiltroClienteImovel.IMOVEL_ID, idImovel));
					filtroClienteImovel.adicionarParametro(new ParametroNulo(
							FiltroClienteImovel.DATA_FIM_RELACAO));

					Collection clientesImovel = getControladorUtil().pesquisar(
							filtroClienteImovel, ClienteImovel.class.getName());

					if (clientesImovel != null && !clientesImovel.isEmpty()) {

						Iterator clienteImovelIterator = clientesImovel
								.iterator();

						while (clienteImovelIterator.hasNext()) {

							ClienteImovel clienteImovel = (ClienteImovel) clienteImovelIterator
									.next();

							ClienteGuiaPagamento clienteGuiaPagamento = new ClienteGuiaPagamento();
							clienteGuiaPagamento
									.setGuiaPagamento(guiaPagamentoInserir);
							clienteGuiaPagamento.setCliente(clienteImovel
									.getCliente());
							clienteGuiaPagamento
									.setClienteRelacaoTipo(clienteImovel
											.getClienteRelacaoTipo());
							clienteGuiaPagamento.setUltimaAlteracao(new Date());

							getControladorUtil().inserir(clienteGuiaPagamento);
						}

					}
				}

				dataVencimentoFormatada = Util.adicionarNumeroDiasDeUmaData(
						dataVencimentoFormatada, qtdeDiasVencimento);
			}
		}

		return idsGuiaPagamentoGerado;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0005] - Processar Recebimento de Acrescimos por Impontualidade
	 * 
	 * @author Sávio Luiz
	 * @since 07/10/2006
	 * @param guiaPagamento
	 *            GuiaPagamento
	 * @throws ControladorException
	 */

	public Integer inserirGuiaPagamentoCodigoBarras(
			GuiaPagamento guiaPagamento, Integer idDebitoTipo)
			throws ControladorException {

		System.out.println("******************************************");
		System.out.println("INICIO INSERIR GUIA PAGAMENTO");
		System.out.println("******************************************");

		String idImovel = guiaPagamento.getImovel().getId() == null ? ""
				: guiaPagamento.getImovel().getId().toString();
		String valorDebito = guiaPagamento.getValorDebito().toString();
		Date dataVencimentoFormatada = guiaPagamento.getDataVencimento();
		GuiaPagamento guiaPagamentoInserir = new GuiaPagamento();

		GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();

		// valor fixo
		Short indicadorHistorico = 2;

		guiaPagamentoGeral.setIndicadorHistorico(indicadorHistorico);

		// Ultima Alteração
		guiaPagamentoGeral.setUltimaAlteracao(new Date());

		Integer idGuiaPagamentoGerado = (Integer) getControladorUtil().inserir(
				guiaPagamentoGeral);

		guiaPagamentoGeral.setId(idGuiaPagamentoGerado);

		guiaPagamentoInserir.setGuiaPagamentoGeral(guiaPagamentoGeral);

		guiaPagamentoInserir.setId(idGuiaPagamentoGerado);

		Imovel imovel = null;

		if (idImovel != null && !idImovel.trim().equals("")
				&& Integer.parseInt(idImovel) > 0) {

			imovel = new Imovel();

			imovel.setId(new Integer(idImovel));

			Integer idLocalidade = null;
			try {
				idLocalidade = repositorioLocalidade
						.pesquisarIdLocalidade(new Integer(idImovel));

			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}
			Localidade localidade = new Localidade();
			localidade.setId(idLocalidade);
			guiaPagamentoInserir.setLocalidade(localidade);
			guiaPagamentoInserir.setImovel(imovel);
			guiaPagamentoInserir.setCliente(null);

			SistemaParametro sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			if (sistemaParametro != null) {

				guiaPagamentoInserir.setAnoMesReferenciaContabil(new Integer(
						sistemaParametro.getAnoMesFaturamento()));
			} else {
				throw new ControladorException("erro.sistema");

			}

			DebitoTipo debitoTipo = getDebitoTipoHql(idDebitoTipo);

			if (debitoTipo != null) {
				guiaPagamentoInserir.setDebitoTipo(debitoTipo);
				guiaPagamentoInserir.setFinanciamentoTipo(debitoTipo
						.getFinanciamentoTipo());
				guiaPagamentoInserir.setLancamentoItemContabil(debitoTipo
						.getLancamentoItemContabil());

			}

			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

			guiaPagamentoInserir.setDebitoCreditoSituacaoAnterior(null);
			guiaPagamentoInserir
					.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
			guiaPagamentoInserir.setDataVencimento(dataVencimentoFormatada);
			guiaPagamentoInserir.setValorDebito(new BigDecimal(valorDebito));
			guiaPagamentoInserir.setDataEmissao(new Date());
			guiaPagamentoInserir.setRegistroAtendimento(null);
			guiaPagamentoInserir.setOrdemServico(null);
			guiaPagamentoInserir.setIndicadoCobrancaMulta(new Short("2"));
			guiaPagamentoInserir.setUltimaAlteracao(new Date());

			guiaPagamentoInserir.setNumeroPrestacaoDebito(new Short("1"));
			guiaPagamentoInserir.setNumeroPrestacaoTotal(new Short("1"));
			guiaPagamentoInserir.setIndicadorEmitirObservacao(new Short("2"));
			getControladorUtil().inserir(guiaPagamentoInserir);

			GuiaPagamentoCategoria guiaPagamentoCategoria = new GuiaPagamentoCategoria();

			// [UC0108] - Obter Quantidade de Economias por Categoria
			Collection colecaoCategoriasImovel = this.getControladorImovel()
					.obterQuantidadeEconomiasCategoria(imovel);

			// [UC0185] - Obter Valor por Categoria
			Collection colecaoValoresPorCategoria = getControladorImovel()
					.obterValorPorCategoria(colecaoCategoriasImovel,
							guiaPagamento.getValorDebito());

			Iterator icolecaoCategorias = colecaoCategoriasImovel.iterator();
			Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria
					.iterator();
			while (icolecaoValoresPorCategoria.hasNext()
					&& icolecaoCategorias.hasNext()) {
				Categoria categoria = (Categoria) icolecaoCategorias.next();
				BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria
						.next();

				guiaPagamentoCategoria.setComp_id(new GuiaPagamentoCategoriaPK(
						categoria.getId(), guiaPagamentoInserir.getId()));
				guiaPagamentoCategoria.setQuantidadeEconomia(categoria
						.getQuantidadeEconomiasCategoria());
				guiaPagamentoCategoria.setValorCategoria(valor);
				guiaPagamentoCategoria.setUltimaAlteracao(new Date());

				getControladorUtil().inserir(guiaPagamentoCategoria);
			}

			Collection colecaoParmsClienteImovel = null;
			try {
				colecaoParmsClienteImovel = repositorioClienteImovel
						.pesquisarParmsClienteImovel(new Integer(idImovel));

			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (colecaoParmsClienteImovel != null
					&& !colecaoParmsClienteImovel.isEmpty()) {

				Iterator clienteImovelIterator = colecaoParmsClienteImovel
						.iterator();

				while (clienteImovelIterator.hasNext()) {

					Object[] parmsClienteImovel = (Object[]) clienteImovelIterator
							.next();

					if (parmsClienteImovel != null) {
						Cliente cliente = null;
						ClienteRelacaoTipo clienteRelacaoTipo = null;
						if (parmsClienteImovel[0] != null) {
							cliente = new Cliente();
							cliente.setId((Integer) parmsClienteImovel[0]);
						}
						if (parmsClienteImovel[1] != null) {
							clienteRelacaoTipo = new ClienteRelacaoTipo();
							clienteRelacaoTipo
									.setId((Integer) parmsClienteImovel[1]);
						}

						ClienteGuiaPagamento clienteGuiaPagamento = new ClienteGuiaPagamento();
						clienteGuiaPagamento
								.setGuiaPagamento(guiaPagamentoInserir);
						clienteGuiaPagamento.setCliente(cliente);
						clienteGuiaPagamento
								.setClienteRelacaoTipo(clienteRelacaoTipo);
						clienteGuiaPagamento.setUltimaAlteracao(new Date());

						getControladorUtil().inserir(clienteGuiaPagamento);
					}
				}

			}
		}

		System.out.println("******************************************");
		System.out.println("FIM INSERIR GUIA PAGAMENTO");
		System.out.println("******************************************");
		return idGuiaPagamentoGerado;
	}

	/**
	 * [UC0188] - Manter Guia de Pagamento
	 * 
	 * @author Rafael Corrêa, Pedro Alexandre
	 * @since 16/01/2006, 23/11/2006
	 * @param guiaPagamento
	 *            guiaPagamento
	 * @param usuarioLogado
	 * 
	 * @throws ControladorException
	 */

	public void manterGuiaPagamento(GuiaPagamento guiaPagamento,
			Collection guiasPagamento, String[] registrosRemocao,
			ImovelCobrancaSituacao imovelCobrancaSituacao, Usuario usuarioLogado)
			throws ControladorException {
		try {
			String idCliente = guiaPagamento.getCliente().getId() == null ? ""
					: guiaPagamento.getCliente().getId().toString();
			String idImovel = guiaPagamento.getImovel().getId() == null ? ""
					: guiaPagamento.getImovel().getId().toString();

			if (registrosRemocao != null && registrosRemocao.length != 0) {

				// String[] removidos = null;

				SistemaParametro sistemaParametro = getControladorUtil()
						.pesquisarParametrosDoSistema();

				Iterator guiaPagamentoIterator = null;

				if (guiasPagamento != null) {

					guiaPagamentoIterator = guiasPagamento.iterator();

				} else {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.atualizacao.removido");
				}

				Collection colecaoGuiaPagamentoItem = null;
				while (guiaPagamentoIterator.hasNext()) {

					GuiaPagamento guiaPagamentoManter = (GuiaPagamento) guiaPagamentoIterator
							.next();

					if (idImovel != null && !idImovel.equals("")) {

						if (!idImovel.equalsIgnoreCase(guiaPagamentoManter
								.getImovel().getId().toString())) {
							throw new ControladorException(
									"atencao.imovel.alterado");
						}

						if (imovelCobrancaSituacao == null ? false
								: imovelCobrancaSituacao.getCobrancaSituacao() != null) {

							if (imovelCobrancaSituacao
									.getCobrancaSituacao()
									.getId()
									.equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
									&& imovelCobrancaSituacao
											.getDataRetiradaCobranca() == null) {
								throw new ControladorException(
										"atencao.pesquisa.imovel.cobranca_administrativa");
							}
						}

					}

					if (idCliente != null && !idCliente.equals("")) {
						// Fazer o teste de cliente com cobranca administrativa.

						if (!idCliente.equalsIgnoreCase(guiaPagamentoManter
								.getCliente().getId().toString())) {
							throw new ControladorException(
									"atencao.cliente.alterado");
						}
					}

					for (int i = 0; i < registrosRemocao.length; i++) {

						String registroRemocao = registrosRemocao[i];

						if (guiaPagamentoManter.getId().equals(
								new Integer(registroRemocao))) {

							// Verifica se o valor do débito é maior que o valor
							// limite
							FiltroGuiaPagamentoItem filtroGuiaPagamentoItem = new FiltroGuiaPagamentoItem();
							filtroGuiaPagamentoItem
									.adicionarParametro(new ParametroSimples(
											FiltroGuiaPagamentoItem.GUIA_PAGAMENTO_GERAL_ID,
											guiaPagamentoManter.getId()));
							filtroGuiaPagamentoItem
									.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");

							colecaoGuiaPagamentoItem = getControladorUtil()
									.pesquisar(filtroGuiaPagamentoItem,
											GuiaPagamentoItem.class.getName());
							Iterator iteratorGuiaPagamentoItem = colecaoGuiaPagamentoItem
									.iterator();

							while (iteratorGuiaPagamentoItem.hasNext()) {
								GuiaPagamentoItem guiaPagamentoItem = (GuiaPagamentoItem) iteratorGuiaPagamentoItem
										.next();

								BigDecimal valorDebito = guiaPagamentoItem
										.getValorDebito();
								DebitoTipo debitoTipo = guiaPagamentoItem
										.getDebitoTipo();
								BigDecimal valorLimite = debitoTipo
										.getValorLimite();
								if (valorDebito == null ? false
										: valorLimite == null ? false
												: valorDebito
														.compareTo(valorLimite) == 1) {
									throw new ControladorException(
											"atencao.faturamento.inserir_guia_pagamento_debito_invalido",
											null,
											Util.formatarMoedaReal(valorLimite));
								}

							}

							// 2.1.1 Caso a guia de pagamento não tenha sido
							// ainda
							// contabilizada
							// e não existam restrições no sistema para
							// exclusão,
							// o sistema exclui a guia de pagamento das tabelas
							// GUIA_PAGAMENTO_GERAL,
							// GUIA_PAGAMENTO, GUIA_PAGAMENTO_CATEGORIA e
							// CLIENTE_
							// GUIA_PAGAMENTO
							// e não existam restrições no sistema para exclusão
							// caso contrário,
							// o sistema atualiza a guia de pagamento na tabela
							// GUIA_PAGAMENTO

							boolean possuiRestricaoRemoverGuiaPagamento = verificarRestricoesRemoverGuiaPagamento(guiaPagamentoManter
									.getId());

							Integer valorArgumento = !idImovel.equals("") ? new Integer(
									idImovel) : new Integer(idCliente);

							// ------------ REGISTRAR TRANSAÇÃO ----------------
							RegistradorOperacao registradorOperacao = new RegistradorOperacao(
									Operacao.OPERACAO_GUIA_PAGAMENTO_CANCELAR,
									valorArgumento,
									guiaPagamento.getId(),
									new UsuarioAcaoUsuarioHelper(
											usuarioLogado,
											UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
							registradorOperacao
									.registrarOperacao(guiaPagamentoManter);
							// ------------ REGISTRAR TRANSAÇÃO ----------------

							// Verificando se a guia de pagamento não foi
							// contabilizada.
							if (!possuiRestricaoRemoverGuiaPagamento
									&& (Util.compararAnoMesReferencia(
											(new Integer(
													guiaPagamentoManter
															.getAnoMesReferenciaContabil())),
											new Integer(sistemaParametro
													.getAnoMesFaturamento()),
											">") || Util
											.compararAnoMesReferencia(
													(new Integer(
															guiaPagamentoManter
																	.getAnoMesReferenciaContabil())),
													new Integer(
															sistemaParametro
																	.getAnoMesFaturamento()),
													"="))
									&& guiaPagamentoManter
											.getFinanciamentoTipo()
											.getId()
											.equals(FinanciamentoTipo.SERVICO_NORMAL)) {

								/*
								 * Alterado por: Mariana Victor Data: 08/06/2011
								 * Alterado por conta dos seguintes casos de
								 * uso: - [UC1146] Informar Pagamento Contrato
								 * de Parcelamento por Cliente - [UC1140]
								 * Cancelar Contrato de Parcelamento por Cliente
								 */
								FiltroContratoParcelamentoItem filtroContratoParcelamentoItem = new FiltroContratoParcelamentoItem();
								filtroContratoParcelamentoItem
										.adicionarParametro(new ParametroSimples(
												FiltroContratoParcelamentoItem.GUIA_PAGAMENTO_GERAL,
												guiaPagamentoManter.getId()));
								filtroContratoParcelamentoItem
										.adicionarCaminhoParaCarregamentoEntidade(FiltroContratoParcelamentoItem.GUIA_PAGAMENTO_GERAL);

								Collection colecaoContratoParcelamentoItem = getControladorUtil()
										.pesquisar(
												filtroContratoParcelamentoItem,
												ContratoParcelamentoItem.class
														.getName());

								if (colecaoContratoParcelamentoItem != null
										&& !colecaoContratoParcelamentoItem
												.isEmpty()) {

									Iterator contratoParcelamentoItemIterator = colecaoContratoParcelamentoItem
											.iterator();

									while (contratoParcelamentoItemIterator
											.hasNext()) {
										ContratoParcelamentoItem contratoParcelamentoItem = (ContratoParcelamentoItem) contratoParcelamentoItemIterator
												.next();
										getControladorUtil().remover(
												contratoParcelamentoItem);
									}
								}

								FiltroClienteGuiaPagamento filtroClienteGuiaPagamento = new FiltroClienteGuiaPagamento();
								filtroClienteGuiaPagamento
										.adicionarCaminhoParaCarregamentoEntidade("cliente");
								filtroClienteGuiaPagamento
										.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento");
								filtroClienteGuiaPagamento
										.adicionarParametro(new ParametroSimples(
												FiltroClienteGuiaPagamento.GUIA_PAGAMENTO_ID,
												guiaPagamentoManter.getId()));

								Collection clientesGuiasPagamento = getControladorUtil()
										.pesquisar(
												filtroClienteGuiaPagamento,
												ClienteGuiaPagamento.class
														.getName());

								if (clientesGuiasPagamento != null
										&& !clientesGuiasPagamento.isEmpty()) {
									Iterator clienteGuiaPagamentoIterator = clientesGuiasPagamento
											.iterator();

									// Seta os parametros do filtro

									FiltroGuiaPagamento filtroGuiaPagamentoBase = new FiltroGuiaPagamento();
									filtroGuiaPagamentoBase
											.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamento.ID,
													guiaPagamentoManter.getId()));

									// Pesquisa a coleção de acordo com o filtro
									// passado
									Collection guiasPagamentosBase = getControladorUtil()
											.pesquisar(
													filtroGuiaPagamentoBase,
													GuiaPagamento.class
															.getName());

									GuiaPagamento guiaPagamentoBase = (GuiaPagamento) Util
											.retonarObjetoDeColecao(guiasPagamentosBase);

									if (guiasPagamentosBase != null
											&& !guiasPagamentosBase.isEmpty()) {

										// Verifica se a data de alteração do
										// objeto
										// gravado na base
										// é
										// maior que a na instancia
										if ((guiaPagamentoBase
												.getUltimaAlteracao()
												.after(guiaPagamentoManter
														.getUltimaAlteracao()))) {
											sessionContext.setRollbackOnly();
											throw new ControladorException(
													"atencao.atualizacao.timestamp");

										}

									} else {
										sessionContext.setRollbackOnly();
										throw new ControladorException(
												"atencao.atualizacao.removido");
									}

									while (clienteGuiaPagamentoIterator
											.hasNext()) {

										ClienteGuiaPagamento clienteGuiaPagamento = (ClienteGuiaPagamento) clienteGuiaPagamentoIterator
												.next();
										getControladorUtil().remover(
												clienteGuiaPagamento);

									}

								}

								if (colecaoGuiaPagamentoItem != null
										&& !colecaoGuiaPagamentoItem.isEmpty()) {

									Iterator iteratorGuiaPagamentoItemRemover = colecaoGuiaPagamentoItem
											.iterator();

									while (iteratorGuiaPagamentoItemRemover
											.hasNext()) {

										GuiaPagamentoItem guiaPagamentoItemRemover = (GuiaPagamentoItem) iteratorGuiaPagamentoItemRemover
												.next();

										GuiaPagamentoItemPK guiaPagamentoItemPK = new GuiaPagamentoItemPK();
										guiaPagamentoItemPK
												.setDebitoTipoId(guiaPagamentoItemRemover
														.getDebitoTipo()
														.getId());
										guiaPagamentoItemPK
												.setGuiaPagamentoId(guiaPagamentoItemRemover
														.getGuiaPagamentoGeral()
														.getId());
										guiaPagamentoItemRemover
												.setComp_id(guiaPagamentoItemPK);

										getControladorUtil().remover(
												guiaPagamentoItemRemover);
									}
								}

								FiltroGuiaPagamentoCategoria filtroGuiaPagamentoCategoria = new FiltroGuiaPagamentoCategoria();
								filtroGuiaPagamentoCategoria
										.adicionarParametro(new ParametroSimples(
												FiltroGuiaPagamentoCategoria.GUIA_PAGAMENTO_ID,
												guiaPagamentoManter.getId()));

								Collection guiasPagamentoCategorias = getControladorUtil()
										.pesquisar(
												filtroGuiaPagamentoCategoria,
												GuiaPagamentoCategoria.class
														.getName());

								if (guiasPagamentoCategorias != null
										&& !guiasPagamentoCategorias.isEmpty()) {
									Iterator guiaPagamentoCategoriaIterator = guiasPagamentoCategorias
											.iterator();

									while (guiaPagamentoCategoriaIterator
											.hasNext()) {
										GuiaPagamentoCategoria guiaPagamentoCategoria = (GuiaPagamentoCategoria) guiaPagamentoCategoriaIterator
												.next();

										getControladorUtil().remover(
												guiaPagamentoCategoria);
									}
								}

								guiaPagamentoManter.setUsuario(usuarioLogado);

								/**
								 * alterado por pedro alexandre dia 23/11/2006
								 * alteração feita para acoplar o controle de
								 * abrangência de usuário
								 */
								// ------------ CONTROLE DE ABRANGENCIA
								// ----------------
								Abrangencia abrangencia = new Abrangencia(
										usuarioLogado,
										guiaPagamentoManter.getImovel());

								if (!getControladorAcesso()
										.verificarAcessoAbrangencia(abrangencia)) {
									sessionContext.setRollbackOnly();
									throw new ControladorException(
											"atencao.acesso.negado.abrangencia");
								} else {
									getControladorUtil().remover(
											guiaPagamentoManter);
								}
								// ------------ FIM CONTROLE DE ABRANGENCIA
								// -------------

								FiltroGuiaPagamentoGeral filtroGuiaPagamentoGeral = new FiltroGuiaPagamentoGeral();
								filtroGuiaPagamentoGeral
										.adicionarParametro(new ParametroSimples(
												FiltroGuiaPagamentoGeral.ID,
												guiaPagamentoManter.getId()));

								// Pesquisa a coleção de acordo com o filtro
								// passado
								Collection guiasPagamentosGeralBase = getControladorUtil()
										.pesquisar(
												filtroGuiaPagamentoGeral,
												GuiaPagamentoGeral.class
														.getName());

								GuiaPagamentoGeral guiaPagamentoGeral = (GuiaPagamentoGeral) Util
										.retonarObjetoDeColecao(guiasPagamentosGeralBase);

								if (guiasPagamentosGeralBase != null
										&& !guiasPagamentosGeralBase.isEmpty()) {

									getControladorUtil().remover(
											guiaPagamentoGeral);
								}

							} else {
								atualizarGuiaPagamento(guiaPagamentoManter,
										guiaPagamentoManter
												.getOperacaoEfetuada(),
										registradorOperacao, usuarioLogado);

								/*
								 * Alterado por: Mariana Victor Data: 08/06/2011
								 * Alterado por conta dos seguintes casos de
								 * uso: - [UC1146] Informar Pagamento Contrato
								 * de Parcelamento por Cliente - [UC1140]
								 * Cancelar Contrato de Parcelamento por Cliente
								 */
								getControladorContratoParcelamento()
										.atualizarContratoParcelamentoItemDesvincularGuiaContrato(
												registrosRemocao);
							}

							// Alterado por Francisco - 26/05/08, por conta do
							// Resumo de Ações de cobrança
							// Analista: Ana Breda
							try {
								// Atualizar documento de cobranca da conta, se
								// houver, para cancelado
								repositorioCobranca
										.atualizarSituacaoCobrancaDocumentoItem(
												CobrancaDebitoSituacao.CANCELADO,
												new Date(), null,
												guiaPagamentoManter.getId(),
												null);
							} catch (ErroRepositorioException ex) {
								sessionContext.setRollbackOnly();
								new ControladorException("erro.sistema", ex);
							}

						}
					}
				}

			} else {
				throw new ControladorException(
						"atencao.nenhuma.guia.selecionada");
			}

		} catch (ControladorException e) {
			sessionContext.setRollbackOnly();
			throw e;
		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Verifica se o Mês/Ano informado é inferior ao Mês/Ano do Sistema
	 * 
	 * @param anoMesFaturamento
	 * @return
	 * @throws ControladorException
	 */
	public boolean verificarReferenciaFaturamentoCorrente(
			String anoMesFaturamento) throws ControladorException {

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		boolean verificacao = Util.compararAnoMesReferencia(
				anoMesFaturamento.substring(3, 7)
						+ anoMesFaturamento.substring(0, 2), sistemaParametro
						.getAnoMesFaturamento().toString(), ">");

		if (verificacao) {
			String anoMesSistema = sistemaParametro.toString();

			throw new ControladorException(
					"atencao.faturamento.ano_mes.inferior", null,
					anoMesSistema.substring(0, 2) + "/"
							+ anoMesSistema.substring(3, 7));

		}

		return true;

	}

	/**
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Rhawi Dantas
	 * @created 18/01/2006
	 * 
	 */
	public void inserirFaturamentoSituacaoHistorico(
			Collection collectionFaturamentoSituacaoHistorico)
			throws ControladorException {
		try {
			this.repositorioFaturamento
					.inserirFaturamentoSituacaoHistorico(collectionFaturamentoSituacaoHistorico);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa, Diogo Peixoto
	 * @created 18/01/2006, 18/06/2007, 25/04/2011
	 * 
	 * @param opcaoTotalizacao
	 * @param anoMesReferencia
	 * @param gerenciaRegional
	 * @param localidade
	 * @param municipio
	 * @param unidadeNegocio
	 * @param opcaoRelatorio
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorio(
			String opcaoTotalizacao, int mesAnoReferencia,
			Integer gerenciaRegional, Integer localidade, Integer municipio,
			Integer unidadeNegocio, String opcaoRelatorio)
			throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoResumoFaturamentoRelatorio = null;

		// Converter de mesAno para anoMes para que funcione nas consultas
		int anoMesReferencia = Util.formatarMesAnoParaAnoMes(mesAnoReferencia);
		boolean consultarResumoFaturamentoRelatorio = true;

		try {

			if (opcaoTotalizacao.equals("estado")) {
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento
						.consultarResumoFaturamentoRelatorioPorEstado(
								anoMesReferencia, opcaoRelatorio, false);

			} else if (opcaoTotalizacao.equals("estadoGerencia")) {
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento
						.consultarResumoFaturamentoRelatorioPorEstadoPorGerenciaRegional(
								anoMesReferencia, opcaoRelatorio);

			} else if (opcaoTotalizacao.equals("estadoLocalidade")) {

				consultarResumoFaturamentoRelatorio = false;

				retorno = consultarResumoFaturamentoRelatorioPorEstadoPorLocalidade(
						anoMesReferencia, opcaoRelatorio);

			} else if (opcaoTotalizacao.equals("estadoMunicipio")) {

				consultarResumoFaturamentoRelatorio = false;
				retorno = consultarResumoFaturamentoRelatorioPorEstadoPorMunicipio(
						anoMesReferencia, opcaoRelatorio);

			} else if (opcaoTotalizacao.equals("gerenciaRegional")) {
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento
						.consultarResumoFaturamentoRelatorioPorGerenciaRegional(
								anoMesReferencia, gerenciaRegional,
								opcaoRelatorio);

			} else if (opcaoTotalizacao.equals("gerenciaRegionalLocalidade")) {
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento
						.consultarResumoFaturamentoRelatorioPorGerenciaRegionalPorLocalidade(
								anoMesReferencia, gerenciaRegional,
								opcaoRelatorio);

			} else if (opcaoTotalizacao.equals("localidade")) {
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento
						.consultarResumoFaturamentoRelatorioPorLocalidade(
								anoMesReferencia, localidade, opcaoRelatorio);

			} else if (opcaoTotalizacao.equals("municipio")) {
				colecaoResumoFaturamentoRelatorio = this.repositorioFaturamento
						.consultarResumoFaturamentoRelatorioPorMunicipio(
								anoMesReferencia, municipio, opcaoRelatorio);

			} else if (opcaoTotalizacao.equals("estadoUnidadeNegocio")) {

				consultarResumoFaturamentoRelatorio = false;

				retorno = consultarResumoFaturamentoRelatorioEstadoPorUnidadeNegocio(
						anoMesReferencia, opcaoRelatorio);

			} else if (opcaoTotalizacao.equals("unidadeNegocio")) {
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento
						.consultarResumoFaturamentoRelatorioPorUnidadeNegocio(
								anoMesReferencia, unidadeNegocio,
								opcaoRelatorio);

			}

			if (consultarResumoFaturamentoRelatorio) {

				Iterator iterator = colecaoResumoFaturamentoRelatorio
						.iterator();

				// Prepara cada linha do relatório

				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String descMunicipioAnterior = null;
				String codigoCentroCusto = null;
				String idLocalidadeAnterior = null;
				String idMunicipioAnterior = null;
				String descLancamentoTipoSuperior = "";

				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				Boolean agrupaPorGerencia = false;
				if (opcaoTotalizacao.equalsIgnoreCase("estadoGerencia")
						|| opcaoTotalizacao
								.equalsIgnoreCase("gerenciaRegional")) {
					agrupaPorGerencia = true;
				}

				Boolean agrupaPorLocalidade = false;
				if (opcaoTotalizacao.equalsIgnoreCase("estadoLocalidade")
						|| opcaoTotalizacao
								.equalsIgnoreCase("gerenciaRegionalLocalidade")
						|| opcaoTotalizacao.equalsIgnoreCase("localidade")) {
					agrupaPorLocalidade = true;
				}

				Boolean agrupaPorUnidadeNegocio = false;
				if (opcaoTotalizacao.equalsIgnoreCase("unidadeNegocio")
						|| opcaoTotalizacao
								.equalsIgnoreCase("estadoUnidadeNegocio")) {
					agrupaPorUnidadeNegocio = true;
				}

				Boolean agrupaPorMunicipio = false;
				if (opcaoTotalizacao.equalsIgnoreCase("municipio")
						|| opcaoTotalizacao.equalsIgnoreCase("estadoMunicipio")) {
					agrupaPorMunicipio = true;
				}

				while (iterator.hasNext()) {
					Object[] element = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;

					element = (Object[]) iterator.next();

					if (tipoLancamento == null) {
						tipoLancamento = (String) element[1];
						itemLancamento = (String) element[2];
						itemContabel = (String) element[3];
					}

					tempTipoLancamento = (String) element[1];
					tempItemLancamento = (String) element[2];
					tempItemContabel = (String) element[3];

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if (tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)) {

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if (itemContabel == null
								&& tempItemContabel == null
								|| (itemContabel != null
										&& tempItemContabel != null && itemContabel
											.equals(tempItemContabel))) {

							// se for agrupado por gerencia
							// compara se o registro atual eh da
							// mesma gerencia regional do registro anterior
							if (!agrupaPorGerencia
									|| descGerenciaRegionalAnterior == null
									|| (agrupaPorGerencia && descGerenciaRegionalAnterior
											.equalsIgnoreCase((String) element[9]))) {

								switch (((Integer) element[8]).intValue()) {
								case 1:
									arrayValores[0] = (BigDecimal) element[0];
									break;
								case 2:
									arrayValores[1] = (BigDecimal) element[0];
									break;
								case 3:
									arrayValores[2] = (BigDecimal) element[0];
									break;
								case 4:
									arrayValores[4] = (BigDecimal) element[0];
									break;
								}
							} else {
								condicaoIgual = false;
							}

						} else {

							condicaoIgual = false;
						}

					} else {

						condicaoIgual = false;

					}

					if (!condicaoIgual) {

						ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
								(BigDecimal[]) arrayValores,
								(String) elementAnterior[1],
								(String) elementAnterior[2],
								(String) elementAnterior[3],
								(Short) elementAnterior[4],
								(Short) elementAnterior[5],
								(Integer) elementAnterior[6],
								(Integer) elementAnterior[7], false,
								descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior,
								descLocalidadeAnterior, idLocalidadeAnterior,
								descMunicipioAnterior, idMunicipioAnterior,
								descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior,
								idUnidadeNegocioAnterior, codigoCentroCusto);

						retorno.add(resumoFaturamentoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch (((Integer) element[8]).intValue()) {
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
						}

					}

					elementAnterior[1] = element[1]; // descricaoTipoLancamento
					if (((String) element[1])
							.equalsIgnoreCase((String) element[2])) {
						elementAnterior[2] = null; // descricaoItemLancamento
					} else {
						elementAnterior[2] = element[2]; // descricaoItemLancamento
					}

					elementAnterior[3] = element[3]; // descricaoItemContabil
					elementAnterior[4] = element[4]; // indicadorImpressao
					elementAnterior[5] = element[5]; // indicadorTotal
					elementAnterior[6] = element[6]; // lancamentoTipo
					elementAnterior[7] = element[7]; // lancamentoTipoSuperior

					// identifica pelo que vai ser "quebrado" o relátorio
					if (agrupaPorGerencia) {
						// quebra página por Gerência Regional e não mostra a
						// Localidade
						descGerenciaRegionalAnterior = "" + element[9];
						idGerenciaRegionalAnterior = "" + element[10];

					} else if (agrupaPorLocalidade) {
						if (opcaoTotalizacao
								.equalsIgnoreCase("estadoLocalidade")
								|| opcaoTotalizacao
										.equalsIgnoreCase("gerenciaRegionalLocalidade")) {
							// quebra a página por Localidade e mostra a
							// Gerência
							// Regional
							descGerenciaRegionalAnterior = "" + element[9];
							idGerenciaRegionalAnterior = "" + element[10];
							descLocalidadeAnterior = "" + element[11];
							idLocalidadeAnterior = "" + element[12];
							codigoCentroCusto = "" + element[15];
						} else {
							// quebra a página por Localidade e não mostra a
							// Gerência
							// Regional
							descLocalidadeAnterior = "" + element[9];
							idLocalidadeAnterior = "" + element[10];
							codigoCentroCusto = "" + element[13];
						}

					} else if (agrupaPorUnidadeNegocio) {
						descUnidadeNegocioAnterior = "" + element[9];
						idUnidadeNegocioAnterior = "" + element[10];
					} else if (agrupaPorMunicipio) {
						descMunicipioAnterior = (String) element[9];
						idMunicipioAnterior = String
								.valueOf((Integer) element[10]);
					}

					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;
				}

				if (colecaoResumoFaturamentoRelatorio != null
						&& !colecaoResumoFaturamentoRelatorio.isEmpty()) {
					// adiciona a ultima linha

					ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
							(BigDecimal[]) arrayValores,
							(String) elementAnterior[1],
							(String) elementAnterior[2],
							(String) elementAnterior[3],
							(Short) elementAnterior[4],
							(Short) elementAnterior[5],
							(Integer) elementAnterior[6],
							(Integer) elementAnterior[7], false,
							descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior,
							idLocalidadeAnterior, descMunicipioAnterior,
							idMunicipioAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior,
							idUnidadeNegocioAnterior, codigoCentroCusto);

					retorno.add(resumoFaturamentoRelatorioHelper);
				}
			}

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC0194] - Inserir Crédito a Realizar
	 * 
	 * @author Roberta Costa
	 * @since 12/01/2006
	 * @param creditoARealizar
	 *            CreditoARealizar
	 * @throws ControladorException
	 */
	public void inserirCreditoARealizar(Imovel imovel,
			CreditoARealizar creditoARealizar, Usuario usuarioLogado)
			throws ControladorException {

		creditoARealizar.setUsuario(usuarioLogado);

		// [FS0010] - Verifica usuário com débito em cobrança administrativa
		FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();

		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(
				FiltroImovelCobrancaSituacao.IMOVEL_ID, imovel.getId()));

		Collection imovelCobrancaSituacaoEncontrada = getControladorUtil()
				.pesquisar(filtroImovelCobrancaSituacao,
						ImovelCobrancaSituacao.class.getName());

		if (imovelCobrancaSituacaoEncontrada != null
				&& !imovelCobrancaSituacaoEncontrada.isEmpty()) {

			if (((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada)
					.get(0)).getCobrancaSituacao() != null) {

				if (((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada)
						.get(0)).getCobrancaSituacao().getId()
						.equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
						&& ((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada)
								.get(0)).getDataRetiradaCobranca() == null) {

					throw new ActionServletException(
							"atencao.pesquisa.imovel.cobranca_administrativa");
				}
			}
		}

		// [FS0001] - Verifica Existência da Matrícula
		FiltroClienteImovel filtroClienteImovel = new FiltroClienteImovel();

		filtroClienteImovel.adicionarParametro(new ParametroSimples(
				FiltroClienteImovel.INDICADOR_IMOVEL_EXCLUIDO,
				Imovel.IMOVEL_EXCLUIDO));

		filtroClienteImovel.adicionarParametro(new ParametroSimples(
				FiltroClienteImovel.IMOVEL_ID, imovel.getId()));

		Collection imovelExcluido = getControladorUtil().pesquisar(
				filtroClienteImovel, ClienteImovel.class.getName());

		if (imovelExcluido != null && !(imovelExcluido.isEmpty())) {
			throw new ControladorException("atencao.imovel.excluido");
		}

		// [FS0002] - Validar Registro de Atendimento
		// Tabela ainda não está completa

		// [FS0003] - Verifica Existência do Registro de Atendimento
		FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();

		filtroRegistroAtendimento.adicionarParametro(new ParametroSimples(
				FiltroRegistroAtendimento.ID, creditoARealizar
						.getRegistroAtendimento()));

		// Por equanto só tem o campo ID na tabela de Registro de Atentendimento
		// filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade(FiltroRegistroAtendimento.IMOVEL_ID);

		Collection registrosAtendimentos = getControladorUtil().pesquisar(
				filtroRegistroAtendimento, RegistroAtendimento.class.getName());

		if (registrosAtendimentos == null || (registrosAtendimentos.isEmpty())) {
			throw new ControladorException(
					"atencao.registro_atendimento.inexistente");
		}

		// [FS0004] - Verifica Existência da Ordem de Serviço
		if (creditoARealizar.getOrdemServico() != null) {
			FiltroOrdemServico filtroOrdemServico = new FiltroOrdemServico();

			filtroOrdemServico.adicionarParametro(new ParametroSimples(
					FiltroOrdemServico.ID, creditoARealizar.getOrdemServico()));

			Collection ordensServicos = getControladorUtil().pesquisar(
					filtroOrdemServico, OrdemServico.class.getName());

			OrdemServico ordemServico = null;
			if (ordensServicos != null && !(ordensServicos.isEmpty())) {
				ordemServico = (OrdemServico) ordensServicos.iterator().next();
			} else {
				throw new ControladorException(
						"atencao.ordem_servico.inexistente");
			}

			// [FS0005] - Validar Ordem de serviço
			// Tabela ainda não está completa

			creditoARealizar.setOrdemServico(ordemServico);
		} else {
			creditoARealizar.setOrdemServico(null);
		}

		// [FS0006] - Verificar existência de crédito a realizar para o registro
		// de atendimento
		// Tabela ainda não está completa

		// [FS0007] - Validar número de prestações
		// Está faltando verificar se o usuário possui senha especial - DEPOIS
		boolean permissaoQuantidadeParcelas = getControladorPermissaoEspecial()
				.verificarPermissaoIcluirCreditoARealizarQuantidadeParcelasMaximo(
						usuarioLogado);
		if (!permissaoQuantidadeParcelas) {
			if (creditoARealizar.getNumeroPrestacaoCredito() > getControladorUtil()
					.pesquisarParametrosDoSistema()
					.getNumeroMaximoParcelasFinanciamento()) {
				throw new ControladorException("atencao.valor_prestacoes",
						null, ""
								+ getControladorUtil()
										.pesquisarParametrosDoSistema()
										.getNumeroMaximoParcelasFinanciamento());
			}
		}

		FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();

		filtroCreditoTipo.adicionarParametro(new ParametroSimples(
				FiltroCreditoTipo.ID, creditoARealizar.getCreditoTipo()));

		filtroCreditoTipo
				.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoTipo.LANCAMENTO_ITEM_CONTABIL);

		Collection creditoTiposValor = getControladorUtil().pesquisar(
				filtroCreditoTipo, CreditoTipo.class.getName());

		CreditoTipo creditoTipo = (CreditoTipo) Util
				.retonarObjetoDeColecao(creditoTiposValor);

		creditoARealizar.setCreditoTipo(creditoTipo);

		// [FS0008] - Validar valor do crédito
		boolean permissaoValorLimite = getControladorPermissaoEspecial()
				.verificarPermissaoIcluirCreditoARealizarValorMaximo(
						usuarioLogado);
		if (!permissaoValorLimite) {

			if (creditoTiposValor != null && !(creditoTiposValor.isEmpty())) {
				CreditoTipo creditoTipoValorNaBase = (CreditoTipo) ((List) creditoTiposValor)
						.get(0);
				if (creditoTipoValorNaBase.getValorLimite() != null) {
					// Verifica se o valor do crédito é mairo que o valor limite
					// da
					// tabela crédito tipo
					if (creditoARealizar.getValorCredito().compareTo(
							creditoTipoValorNaBase.getValorLimite()) == 1) {
						throw new ControladorException(
								"atencao.credito_a_realizar.valor_limite",
								null,
								""
										+ Util.formatarMoedaReal(creditoTipoValorNaBase
												.getValorLimite()));
					}
				} else {
					throw new ControladorException(
							"atencao.credito_tipo.valor_limite_inexistente");
				}
			}
		}

		// [FS0011] - Validar Referência do Crédito
		FiltroCreditoARealizar filtroCreditoARealizar = new FiltroCreditoARealizar();
		filtroCreditoARealizar.adicionarParametro(new ParametroSimples(
				FiltroCreditoARealizar.ANO_MES_REFERENCIA_CREDITO,
				creditoARealizar.getAnoMesReferenciaCredito()));
		filtroCreditoARealizar.adicionarParametro(new ParametroSimples(
				FiltroCreditoARealizar.ID_CREDITO_ORIGEM, creditoARealizar
						.getCreditoOrigem().getId()));
		filtroCreditoARealizar.adicionarParametro(new ParametroSimples(
				FiltroCreditoARealizar.ID_CREDITO_TIPO, creditoARealizar
						.getCreditoTipo().getId()));
		filtroCreditoARealizar.adicionarParametro(new ParametroSimples(
				FiltroCreditoARealizar.IMOVEL_ID, creditoARealizar.getImovel()
						.getId()));

		Collection colecaoCreditosBase = getControladorUtil().pesquisar(
				filtroCreditoARealizar, CreditoARealizar.class.getName());

		if (colecaoCreditosBase != null && !colecaoCreditosBase.isEmpty()) {
			throw new ControladorException(
					"atencao.referencia.credito_a_realizar.ja.existente");
		}

		// Data de Geração do Crédito
		creditoARealizar.setGeracaoCredito(new Date());

		// Parâmetros do sistema
		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		// Autor: Bruno Barros
		// Data : 12/05/2009
		// Analista Responsável: Rosana Cavalho
		// Descrição da alteração: Gravar na coluna DBAC_AMREFERENCIACONTABIL o
		// maior valor entre o ano/mes
		// da data corrente e o ano/mês da referência do faturamento (
		// PARM_AMREFERENCIAFATURAMENTO )
		Date dataAtual = new Date();
		Integer anoMesReferenciaAtual = Util.recuperaAnoMesDaData(dataAtual);

		creditoARealizar
				.setAnoMesReferenciaContabil(

				(anoMesReferenciaAtual > sistemaParametro
						.getAnoMesFaturamento() ? anoMesReferenciaAtual
						: sistemaParametro.getAnoMesFaturamento())

				);

		// Anterior
		// creditoARealizar.setAnoMesReferenciaContabil(sistemaParametro
		// .getAnoMesFaturamento());

		// FIM ALTERAÇÃO BRUNO BARROS

		creditoARealizar.setAnoMesCobrancaCredito(sistemaParametro
				.getAnoMesArrecadacao());

		// Valor Residual Mes Anterior
		creditoARealizar.setValorResidualMesAnterior(new BigDecimal(0));

		// Prestacao Credito
		creditoARealizar.setNumeroPrestacaoCredito(creditoARealizar
				.getNumeroPrestacaoCredito());

		// Prestacao Realizada
		creditoARealizar.setNumeroPrestacaoRealizada(new Short((short) 0));

		// Imovel
		creditoARealizar.setImovel(imovel);
		creditoARealizar.setLocalidade(imovel.getLocalidade());
		creditoARealizar.setCodigoSetorComercial(imovel.getSetorComercial()
				.getCodigo());
		creditoARealizar.setNumeroLote(imovel.getLote());
		creditoARealizar.setNumeroSubLote(imovel.getSubLote());
		creditoARealizar.setQuadra(imovel.getQuadra());
		creditoARealizar.setNumeroQuadra(new Integer(imovel.getQuadra()
				.getNumeroQuadra()));

		// Registro de Atendimento
		creditoARealizar.setRegistroAtendimento(creditoARealizar
				.getRegistroAtendimento());

		// Ordem de Servico
		creditoARealizar.setOrdemServico(creditoARealizar.getOrdemServico());

		// Crédito Tipo
		creditoARealizar.setCreditoTipo(creditoARealizar.getCreditoTipo());

		// Crédito Origem
		creditoARealizar.setCreditoOrigem(creditoARealizar.getCreditoOrigem());

		// Lancamento Item Contabil
		filtroCreditoTipo.adicionarParametro(new ParametroSimples(
				FiltroCreditoTipo.ID, creditoARealizar.getCreditoTipo()));

		Collection creditoTipos = getControladorUtil().pesquisar(
				filtroCreditoTipo, CreditoTipo.class.getName());

		if (creditoTipos != null && !(creditoTipos.isEmpty())) {
			CreditoTipo creditoTipoNaBase = (CreditoTipo) creditoTipos
					.iterator().next();

			if (creditoTipoNaBase.getLancamentoItemContabil() == null) {
				throw new ControladorException(
						"atencao.lancamento_item_contabil.inexistente");
			} else {
				creditoARealizar.setLancamentoItemContabil(creditoTipoNaBase
						.getLancamentoItemContabil());
			}
		} else {
			throw new ControladorException("atencao.credito_tipo.inexistente");
		}

		// Debito Credito Situacao Atual
		DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao();
		debitoCreditoSituacaoAtual.setId(DebitoCreditoSituacao.NORMAL);
		creditoARealizar
				.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);

		// Debito Credito Situacao Anterior
		creditoARealizar.setDebitoCreditoSituacaoAnterior(null);

		// Data de Ultima Alteracao
		creditoARealizar.setUltimaAlteracao(new Date());

		/**
		 * Alterado por Hugo Leonardo. Data: 27/05/2010 [UC0194] - Inserir
		 * Crédito a realizar. [FS0013] - Verificar crédito a realizar,
		 * histórico e a guia devolução.
		 * 
		 * Analista: Ana Cristina.
		 */
		Integer existeCreditoARealizar = null;
		existeCreditoARealizar = this.getControladorArrecadacao()
				.verificarExistenciaCreditoARealizar(
						creditoARealizar.getImovel().getId(),
						creditoARealizar.getAnoMesReferenciaCredito());

		Integer existeCreditoARealizarHistorico = null;
		existeCreditoARealizarHistorico = this.getControladorArrecadacao()
				.verificarExistenciaCreditoARealizarHistorico(
						creditoARealizar.getImovel().getId(),
						creditoARealizar.getAnoMesReferenciaCredito());

		Integer existeGuiaDevolucao = null;

		existeGuiaDevolucao = this.getControladorArrecadacao()
				.verificarExistenciaGuiaDevolucao(
						creditoARealizar.getImovel().getId(),
						creditoARealizar.getAnoMesReferenciaCredito());

		if (existeCreditoARealizar != null
				|| existeCreditoARealizarHistorico != null
				|| existeGuiaDevolucao != null) {

			String msgAnoMes = Util.formatarAnoMesParaMesAno(creditoARealizar
					.getAnoMesReferenciaCredito());
			String msgValor = Util.formatarMoedaReal(creditoARealizar
					.getValorCredito());
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.conta_ja_devolvida", null,
					msgAnoMes, msgValor);
		}
		/**
		 * Fim Alteração realizada por: Hugo Leonardo. Data: 27/05/2010.
		 */

		// GERANDO O CREDITO A REALIZAR
		this.gerarCreditoARealizar(creditoARealizar, imovel, usuarioLogado);
	}

	/**
	 * [UC0195] - Manter Crédito a Realizar
	 */
	public void cancelarCreditoARealizar(String[] ids, Imovel imovel, Usuario usuarioLogado) throws ControladorException {

		FiltroClienteImovel filtroClienteImovel = new FiltroClienteImovel();
		filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.INDICADOR_IMOVEL_EXCLUIDO, Imovel.IMOVEL_EXCLUIDO));
		filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.IMOVEL_ID, imovel.getId()));

		Collection imovelExcluido = getControladorUtil().pesquisar(filtroClienteImovel, ClienteImovel.class.getName());

		if (imovelExcluido != null && !(imovelExcluido.isEmpty())) {
			throw new ControladorException("atencao.imovel.excluido");
		}

		for (int i = 0; i < ids.length; i++) {
			String id = ids[i];

			FiltroCreditoARealizar filtroCredito = new FiltroCreditoARealizar();
			filtroCredito.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID, id));
			filtroCredito.setInitializeLazy(true);
			filtroCredito.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoARealizar.CREDITO_TIPO);

			Collection colecaoCredito = getControladorUtil().pesquisar(filtroCredito, CreditoARealizar.class.getName());

			CreditoARealizar credito = (CreditoARealizar) colecaoCredito.iterator().next();
			credito.setUsuario(usuarioLogado);

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CREDITO_A_REALIZAR_CANCELAR, imovel.getId(), Integer.parseInt(id), 
					new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
			registradorOperacao.registrarOperacao(credito);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			if ((credito.getNumeroPrestacaoRealizada() == 0) && (credito.getAnoMesReferenciaContabil() >= getControladorUtil().pesquisarParametrosDoSistema().getAnoMesFaturamento())) {

				FiltroCreditoARealizarGeral filtroCreditoARealizarGeral = new FiltroCreditoARealizarGeral();
				filtroCreditoARealizarGeral.adicionarParametro(new ParametroSimples(FiltroCreditoARealizarGeral.ID, id));

				Collection colecaoCreditoARealizarGeral = getControladorUtil().pesquisar(filtroCreditoARealizarGeral, CreditoARealizarGeral.class.getName());

				CreditoARealizarGeral creditoARealizarGeral = (CreditoARealizarGeral) colecaoCreditoARealizarGeral.iterator().next();

				getControladorUtil().remover(credito);
				getControladorUtil().remover(creditoARealizarGeral);
			} else {
				// [FS0003] - Verifica usuário com débito em cobrança administrativa
				FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();

				filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, imovel.getId()));

				Collection imovelCobrancaSituacaoEncontrada = getControladorUtil().pesquisar(filtroImovelCobrancaSituacao, ImovelCobrancaSituacao.class.getName());

				if (imovelCobrancaSituacaoEncontrada != null && !imovelCobrancaSituacaoEncontrada.isEmpty()) {

					if (((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao() != null) {

						if (((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao().getId().equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
								&& ((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getDataRetiradaCobranca() == null) {
							throw new ActionServletException("atencao.pesquisa.imovel.cobranca_administrativa");
						}
					}
				}

				// [FS0004] - Validar valor do crédito
				CreditoARealizar creditoARealizarPesquisado = (CreditoARealizar) colecaoCredito.iterator().next();

				FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
				filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, creditoARealizarPesquisado.getCreditoTipo()));

				Collection creditoTiposValor = getControladorUtil().pesquisar(filtroCreditoTipo, CreditoTipo.class.getName());

				if (creditoTiposValor != null && !(creditoTiposValor.isEmpty())) {
					CreditoTipo creditoTipoValorNaBase = (CreditoTipo) ((List) creditoTiposValor).get(0);
					if (creditoTipoValorNaBase.getValorLimite() != null) {
						// Verifica se o valor do crédito é mairo que o valor limite da tabela crédito tipo
						if (creditoARealizarPesquisado.getValorCredito().compareTo(creditoTipoValorNaBase.getValorLimite()) == 1) {
							throw new ControladorException("atencao.credito_a_realizar.valor_limite", null, "" + creditoTipoValorNaBase.getValorLimite());
						}
					} else {
						throw new ControladorException("atencao.credito_tipo.valor_limite_inexistente");
					}
				}
				
				SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
				Integer anoMesFaturamento = sistemaParametro.getAnoMesFaturamento();

				if (credito.getAnoMesReferenciaContabil() >= anoMesFaturamento) {
					credito.setDebitoCreditoSituacaoAnterior(new DebitoCreditoSituacao(credito.getDebitoCreditoSituacaoAtual().getId()));
				}
				
				credito.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.CANCELADA));

				Integer anoMesReferenciaAtual = Util.recuperaAnoMesDaData(new Date());

				credito.setAnoMesReferenciaContabil(anoMesReferenciaAtual > anoMesFaturamento ? anoMesReferenciaAtual : anoMesFaturamento);

				Interceptador.getInstancia().registrarExclusao(credito);
				credito.setOperacaoEfetuada(null);

				getControladorUtil().atualizar(credito);
			}
		}
	}

	/**
	 * [UC0146] - Manter Conta Author: Raphael Rossiter Data: 21/01/2006
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 */
	public Collection obterContasImovelManter(Imovel imovel,
			Integer situacaoNormal, Integer situacaoIncluida,
			Integer situacaoRetificada) throws ControladorException {

		Collection retorno = new ArrayList();

		Collection colecaoContasManutencaoArray = null;

		try {

			colecaoContasManutencaoArray = repositorioFaturamento
					.obterContasImovelManter(imovel, situacaoNormal,
							situacaoIncluida, situacaoRetificada);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoContasManutencaoArray != null
				&& !colecaoContasManutencaoArray.isEmpty()) {

			Iterator colecaoContasManutencaoArrayIterator = colecaoContasManutencaoArray
					.iterator();

			while (colecaoContasManutencaoArrayIterator.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] contaArray = (Object[]) colecaoContasManutencaoArrayIterator
						.next();

				Conta conta = new Conta();

				// ID da conta
				conta.setId((Integer) contaArray[0]);

				// Ano Mês referencia
				conta.setReferencia((Integer) contaArray[1]);

				// Data de vencimento
				String vencimento = String.valueOf(contaArray[2]);

				SimpleDateFormat formatoData = new SimpleDateFormat(
						"yyyy-MM-dd");

				Date dataVencimento;

				try {
					dataVencimento = formatoData.parse(vencimento);
				} catch (java.text.ParseException e) {
					dataVencimento = null;
				}

				conta.setDataVencimentoConta(dataVencimento);

				// Valor de água
				conta.setValorAgua((BigDecimal) contaArray[3]);

				// Valor de esgoto
				conta.setValorEsgoto((BigDecimal) contaArray[4]);

				// Valor dos débitos
				conta.setDebitos((BigDecimal) contaArray[5]);

				// Valor dos créditos
				conta.setValorCreditos((BigDecimal) contaArray[6]);

				// Consumo de água
				conta.setConsumoAgua((Integer) contaArray[7]);

				// Consumo de esgoto
				conta.setConsumoEsgoto((Integer) contaArray[8]);

				// Data de validade
				String validade = String.valueOf(contaArray[9]);

				Date dataValidade;

				try {
					dataValidade = formatoData.parse(validade);
				} catch (java.text.ParseException e) {
					dataValidade = null;
				}

				conta.setDataValidadeConta(dataValidade);

				// Data de revisao
				String revisao = String.valueOf(contaArray[10]);

				Date dataRevisao;

				try {
					dataRevisao = formatoData.parse(revisao);
				} catch (java.text.ParseException e) {
					dataRevisao = null;
				}

				conta.setDataRevisao(dataRevisao);

				// DebitoCreditoSituacaoAtual
				conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);

				// Ano Mês referencia contábil
				conta.setReferenciaContabil((Integer) contaArray[12]);

				// ultima Alteracao

				SimpleDateFormat formatoDataEspecifico = new SimpleDateFormat(
						"yyyy-MM-dd HH:mm:ss");

				String ultimaAlteracao = String.valueOf(contaArray[13]);

				Date dataUltimaAlteracao;

				try {
					dataUltimaAlteracao = formatoDataEspecifico
							.parse(ultimaAlteracao);
				} catch (java.text.ParseException e) {
					dataUltimaAlteracao = null;
				}

				conta.setUltimaAlteracao(dataUltimaAlteracao);

				conta.setImovel(imovel);

				conta.setPercentualEsgoto((BigDecimal) contaArray[14]);

				conta.setConsumoTarifa((ConsumoTarifa) contaArray[15]);

				if (contaArray[16] != null) {
					conta.setValorImposto((BigDecimal) contaArray[16]);
				}

				retorno.add(conta);
			}
		}

		return retorno;
	}

	public void encerrarFaturamentoMes(Collection<Integer> colecaoIdsLocalidades,int idFuncionalidadeIniciada) throws ControladorException {

		SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

		final Short ZERO = 0;
		BigDecimal menosUm = new BigDecimal("-1");

		int anoMesFaturamento = sistemaParametros.getAnoMesFaturamento();
		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(
						idFuncionalidadeIniciada,
						UnidadeProcessamento.LOCALIDADE,
						((Integer) Util
								.retonarObjetoDeColecao(colecaoIdsLocalidades)));

		try {
			validarGruposFaturadosParaEncerrarFaturamentoMensal(anoMesFaturamento);

			Short maxSequencialImpressaoMais10 = repositorioFaturamento.recuperarValorMaximoSequencialImpressaoMais10();
			ResumoFaturamento resumoFaturamentoTemporario = null;

			final int indiceValorAgua = 0;

			Object[] arrayValoresAguaEsgoto = null;
			Object[] arrayValoresCurtoLongoPrazo = null;

			BigDecimal valorAgua = null;
			BigDecimal valorEsgoto = null;
			BigDecimal valorItemFaturamento = null;
			BigDecimal somaValorCurtoPrazo = BigDecimal.ZERO;
			BigDecimal somaValorLongoPrazo = BigDecimal.ZERO;

			Integer[] idsSituacaoAtual = null;
			Integer[] idsCreditosOrigem = null;
			Integer[] idsTipoFinanciamento = null;

			Collection<Object[]> colecaoDadosDebitoCobradoCategoria = null;
			Collection<Object[]> colecaoDadosDebitoACobrar = null;
			Collection<Object[]> colecaoDadosCreditoRealizado = null;
			Collection<Object[]> colecaoTemporariaCreditoARealizar = null;

			final int indiceValorEsgoto = 1;

			LancamentoTipo lancamentoTipo = new LancamentoTipo();
			LancamentoItem lancamentoItem = new LancamentoItem();

			Collection<LancamentoItemContabil> colecaoLancamentosItemContabil = getControladorFinanceiro().pesquisarLancamentoItemContabil();
			Collection<Categoria> colecaoCategorias = getControladorImovel().pesquisarCategoria();
			
			List<LancamentoAgenciaReguladora> lancamentosAgenciaReguladora= new ArrayList<LancamentoAgenciaReguladora>();

			for (Integer idLocalidade : colecaoIdsLocalidades) {

				BigDecimal valorCreditosRealizadosRecuperacaoCredito = null;

				repositorioFaturamento.excluirResumoFaturamentoPorAnoMesArrecadacaoPorLocalidade(anoMesFaturamento, idLocalidade);
				repositorioFaturamento.excluirLancamentoAgenciaReguladoraPorAnoMesArrecadacaoPorLocalidade(anoMesFaturamento, idLocalidade);

				Integer idGerenciaRegional = this.getControladorLocalidade().pesquisarIdGerenciaParaLocalidade(idLocalidade);
				Integer idUnidadeNegocio = this.getControladorLocalidade().pesquisarIdUnidadeNegocioParaLocalidade(idLocalidade);

				Localidade localidade = new Localidade(idLocalidade);
				GerenciaRegional gerenciaRegional = new GerenciaRegional(idGerenciaRegional);
				UnidadeNegocio unidadeNegocio = new UnidadeNegocio(idUnidadeNegocio);

				localidade.setGerenciaRegional(gerenciaRegional);
				localidade.setUnidadeNegocio(unidadeNegocio);

				Collection colecaoResumoFaturamento = repositorioFaturamento.pesquisarResumoFaturamentoPorAnoMes(anoMesFaturamento,idLocalidade);

				if (!colecaoResumoFaturamento.isEmpty()) {
					throw new ControladorException("atencao.resumofaturamento_ja_existente");
				}

				// declaração das variáveis que serão utilizadas nos sequencias 560 e 1050
				Collection<Object[]> colecaoDadosGuiaDevolucao = null;
				Map<Integer, BigDecimal> mapValorGuiaDevolucaoPorCategoriaSequencial560 = null;
				Map<Integer, BigDecimal> mapValorGuiaDevolucaoPorCategoriaSequencial1050 = null;
				Categoria principalCategoriaImovel = null;

				Map<Integer, BigDecimal> mapAcumularValorPorCategoriaReceitaBruta = new HashMap();
				Map<Integer, BigDecimal> mapAcumularValorPorCategoriaReceitaCancelada = new HashMap();

				for (LancamentoItemContabil lancamentoItemContabilTemp : colecaoLancamentosItemContabil) {

					mapValorGuiaDevolucaoPorCategoriaSequencial560 = new HashMap();
					mapValorGuiaDevolucaoPorCategoriaSequencial1050 = new HashMap();

					colecaoDadosGuiaDevolucao = repositorioFaturamento.acumularValorGuiaDevolucaoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,DebitoCreditoSituacao.CANCELADA,lancamentoItemContabilTemp.getId());

					// caso a coleção de dados não esteja nula acumula o valor da guia pela principal categoria do imóvel.
					if (colecaoDadosGuiaDevolucao != null && !colecaoDadosGuiaDevolucao.isEmpty()) {
						mapValorGuiaDevolucaoPorCategoriaSequencial560 = obterMapValorGuiaDevolucaoPorCategoria(colecaoDadosGuiaDevolucao);
					}

					for (Integer idCategoria : mapValorGuiaDevolucaoPorCategoriaSequencial560.keySet()) {

						Categoria categoria = new Categoria(idCategoria);
						BigDecimal valorGuiaDevolucao = mapValorGuiaDevolucaoPorCategoriaSequencial560.get(idCategoria);

						mapAcumularValorPorCategoriaReceitaBruta = acumularValorPorCategoriaReceitaBruta(
								mapAcumularValorPorCategoriaReceitaBruta,idCategoria, valorGuiaDevolucao);

						lancamentoTipo = new LancamentoTipo(LancamentoTipo.GUIAS_DEVOLUCAO_VALORES_COBRADOS_INDEVIDAMENTE_CANCELADOS);
						lancamentoItem = new LancamentoItem(LancamentoItem.GRUPO_CONTABIL);

						resumoFaturamentoTemporario = buildResumoFaturamento(valorGuiaDevolucao, anoMesFaturamento,
								categoria, localidade, lancamentoTipo,lancamentoItem, lancamentoItemContabilTemp,
								new Short("560"),lancamentoItemContabilTemp.getSequenciaImpressao());

						if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}
					}

					colecaoDadosGuiaDevolucao = repositorioFaturamento.acumularValorGuiaDevolucaoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,lancamentoItemContabilTemp.getId());

					if (colecaoDadosGuiaDevolucao != null && !colecaoDadosGuiaDevolucao.isEmpty()) {
						mapValorGuiaDevolucaoPorCategoriaSequencial1050 = obterMapValorGuiaDevolucaoPorCategoria(colecaoDadosGuiaDevolucao);
					}

					for (Integer idCategoria : mapValorGuiaDevolucaoPorCategoriaSequencial1050.keySet()) {

						Categoria categoria = new Categoria(idCategoria);
						BigDecimal valorGuiaDevolucao = mapValorGuiaDevolucaoPorCategoriaSequencial1050.get(idCategoria);

						mapAcumularValorPorCategoriaReceitaCancelada = acumularValorPorCategoriaReceitaBruta(
								mapAcumularValorPorCategoriaReceitaCancelada,idCategoria, valorGuiaDevolucao);

						lancamentoTipo = new LancamentoTipo(LancamentoTipo.GUIAS_DEVOLUCAO_VALORES_COBRADOS_INDEVIDAMENTE_INCLUIDOS);
						lancamentoItem = new LancamentoItem(LancamentoItem.GRUPO_CONTABIL);

						resumoFaturamentoTemporario = buildResumoFaturamento(valorGuiaDevolucao, anoMesFaturamento,
								categoria, localidade, lancamentoTipo,lancamentoItem, lancamentoItemContabilTemp,
								new Short("1050"),lancamentoItemContabilTemp.getSequenciaImpressao());

						if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}
					}
				}
				
				arrayValoresAguaEsgoto = null;
				arrayValoresAguaEsgoto = repositorioFaturamento.acumularValorAguaEsgotoPorSituacaoConta(
								anoMesFaturamento, idLocalidade,
								DebitoCreditoSituacao.NORMAL,
								DebitoCreditoSituacao.NORMAL);
				
				if (arrayValoresAguaEsgoto != null && (arrayValoresAguaEsgoto[0] != null || arrayValoresAguaEsgoto[1] != null)) {
					LancamentoAgenciaReguladora lar = this.buildLancamentoAgenciaReguladoraNormais(idLocalidade, anoMesFaturamento, (BigDecimal) arrayValoresAguaEsgoto[0], (BigDecimal) arrayValoresAguaEsgoto[1], LancamentoAgenciaReguladora.AGUA_ESGOTO);
					lancamentosAgenciaReguladora.add(lar);
				}
				
				// Adiciona na tabela faturamento.lanc_agencia_reguladora registros do tipo 900.
				LancamentoAgenciaReguladora lancAgReg = this.buildLancamentoAgenciaReguladoraCancelados(idLocalidade, anoMesFaturamento, LancamentoAgenciaReguladora.CANCELAMENTOS_POR_REFATURAMENTO);
				if (lancAgReg.getValorAgua() != BigDecimal.ZERO || lancAgReg.getValorEsgoto() != BigDecimal.ZERO) {
					lancamentosAgenciaReguladora.add(lancAgReg);
				}
				
				// Adiciona na tabela faturamento.lanc_agencia_reguladora registros do tipo 510.
				LancamentoAgenciaReguladora lar = this.buildLancamentoAgenciaReguladoraCancelados(idLocalidade, anoMesFaturamento, true, LancamentoAgenciaReguladora.INCLUSOES_POR_REFATURAMENTO);
				if (lar.getValorAgua() != BigDecimal.ZERO || lar.getValorEsgoto() != BigDecimal.ZERO) {
					lancamentosAgenciaReguladora.add(lar);
				}
				
				for (Categoria categoria : colecaoCategorias) {

					lancamentoTipo = new LancamentoTipo(LancamentoTipo.RECEITA_BRUTA);
					lancamentoItem = new LancamentoItem(LancamentoItem.RECEITA_BRUTA);
					ResumoFaturamento resumoFaturamentoReceitaBruta = this.buildResumoFaturamento(BigDecimal.ZERO,
									anoMesFaturamento, categoria, localidade,lancamentoTipo, lancamentoItem, null,new Short("600"), ZERO);

					lancamentoTipo = new LancamentoTipo(LancamentoTipo.TOTAL_RECEITA_CANCELADA);
					lancamentoItem = new LancamentoItem(LancamentoItem.TOTAL_RECEITA_CANCELADA);
					ResumoFaturamento resumoFaturamentoReceitaCancelada = this.buildResumoFaturamento(BigDecimal.ZERO,
									anoMesFaturamento, categoria, localidade,lancamentoTipo, lancamentoItem, null,new Short("1100"), ZERO);

					lancamentoTipo = new LancamentoTipo(LancamentoTipo.TOTAL_COBRADO_NAS_CONTAS);
					lancamentoItem = new LancamentoItem(LancamentoItem.TOTAL_COBRADO_CONTAS);
					ResumoFaturamento resumoTotalCobradoNasContas = this.buildResumoFaturamento(BigDecimal.ZERO,
									anoMesFaturamento, categoria, localidade,lancamentoTipo, lancamentoItem, null,new Short("2700"), ZERO);

					lancamentoTipo = new LancamentoTipo(LancamentoTipo.TOTAL_VALORES_DEVOLVIDOS_NAS_CONTAS);
					lancamentoItem = new LancamentoItem(LancamentoItem.TOTAL_VALORES_DEVOLVIDOS_NAS_CONTAS);
					ResumoFaturamento resumoValoresDevolvidosNasContas = this.buildResumoFaturamento(BigDecimal.ZERO,
									anoMesFaturamento, categoria, localidade,lancamentoTipo, lancamentoItem, null,new Short("2400"), ZERO);

					lancamentoTipo = new LancamentoTipo(LancamentoTipo.TOTAL_DEBITOS_CANCELADOS_POR_PRESCRICAO);
					lancamentoItem = new LancamentoItem(LancamentoItem.TOTAL_DEBITOS_CANCELADOS_POR_PRESCRICAO);
					ResumoFaturamento resumoTotalDebitosCanceladosPrescricao = this.buildResumoFaturamento(BigDecimal.ZERO,
									anoMesFaturamento, categoria, localidade,lancamentoTipo, lancamentoItem, null,new Short("4200"), ZERO);

					Integer idCategoria = categoria.getId();
					arrayValoresAguaEsgoto = null;
					arrayValoresAguaEsgoto = repositorioFaturamento.acumularValorAguaEsgotoPorSituacaoConta(
									anoMesFaturamento, idLocalidade,idCategoria, DebitoCreditoSituacao.NORMAL,DebitoCreditoSituacao.NORMAL);

					if (arrayValoresAguaEsgoto != null) {

						valorAgua = (BigDecimal) arrayValoresAguaEsgoto[0];
						valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[1];

						if (valorAgua != null && valorAgua.compareTo(BigDecimal.ZERO) != 0) {
							lancamentoTipo = new LancamentoTipo(LancamentoTipo.AGUA);
							lancamentoItem = new LancamentoItem(LancamentoItem.AGUA);

							resumoFaturamentoTemporario = buildResumoFaturamento(valorAgua, anoMesFaturamento, categoria,
									localidade, lancamentoTipo, lancamentoItem,null, new Short("100"), ZERO);

							resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaBruta,resumoFaturamentoTemporario.getValorItemFaturamento());
							
							resumoTotalCobradoNasContas = this.acumularValorResumoFaturamento(resumoTotalCobradoNasContas,resumoFaturamentoTemporario.getValorItemFaturamento());

							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}

						if (valorEsgoto != null && valorEsgoto.compareTo(BigDecimal.ZERO) != 0) {

							lancamentoTipo = new LancamentoTipo(LancamentoTipo.ESGOTO);
							lancamentoItem = new LancamentoItem(LancamentoItem.ESGOTO);

							resumoFaturamentoTemporario = buildResumoFaturamento(valorEsgoto, anoMesFaturamento, categoria,
									localidade, lancamentoTipo, lancamentoItem,null, new Short("200"), ZERO);

							resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaBruta,resumoFaturamentoTemporario.getValorItemFaturamento());
							
							resumoTotalCobradoNasContas = this.acumularValorResumoFaturamento(resumoTotalCobradoNasContas,resumoFaturamentoTemporario.getValorItemFaturamento());

							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}
					}
					
					arrayValoresCurtoLongoPrazo = repositorioFaturamento.pesquisarValorLongoECurtoPrazoDebitoACobrarPorGrupoParcelamento(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									ParcelamentoGrupo.JUROS_COBRADOS,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, true);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					if (somaValorCurtoPrazo != null&& somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {

						lancamentoTipo = new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
						lancamentoItem = new LancamentoItem(LancamentoItem.JUROS_COBRADOS);

						ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazo = buildResumoFaturamento(
								somaValorCurtoPrazo, anoMesFaturamento,
								categoria, localidade, lancamentoTipo,
								lancamentoItem, null, new Short("410"),
								new Short("0"));

						resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaBruta, somaValorCurtoPrazo);
						colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarCurtoPrazo);
					}

					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];
					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {

						lancamentoTipo = new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO);
						lancamentoItem = new LancamentoItem(LancamentoItem.JUROS_COBRADOS);

						ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazo = buildResumoFaturamento(
								somaValorLongoPrazo, anoMesFaturamento,
								categoria, localidade, lancamentoTipo,
								lancamentoItem, null, new Short("420"),
								new Short("0"));

						resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaBruta,somaValorLongoPrazo);
						
						colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarLongoPrazo);
					}

					for (LancamentoItemContabil lancamentoItemContabilTemp : colecaoLancamentosItemContabil) {

						valorItemFaturamento = repositorioFaturamento
								.acumularValorDebitoTipoFinanciamentoServicoSituacaoIncluida(
										anoMesFaturamento, idLocalidade,
										idCategoria,
										lancamentoItemContabilTemp.getId());

						lancamentoTipo = new LancamentoTipo(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO);
						lancamentoItem = new LancamentoItem(LancamentoItem.GRUPO_CONTABIL);

						resumoFaturamentoTemporario = buildResumoFaturamento(
								valorItemFaturamento, anoMesFaturamento,
								categoria, localidade, lancamentoTipo,
								lancamentoItem, lancamentoItemContabilTemp,
								new Short("510"),
								lancamentoItemContabilTemp.getSequenciaImpressao());

						Collection<Integer> colecaoFinanciamentoTipos = new ArrayList<Integer>();

						colecaoFinanciamentoTipos.add(FinanciamentoTipo.SERVICO_NORMAL);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.PARCELAMENTO_AGUA);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.PARCELAMENTO_ESGOTO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.PARCELAMENTO_SERVICO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_AGUA);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_ESGOTO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_SERVICO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.JUROS_PARCELAMENTO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ENTRADA_PARCELAMENTO);

						BigDecimal[] valoresAcumuladosCanceladosEIncluidos = this
								.obterDiferencaValoresServicoIndiretosContaRetificada(
										anoMesFaturamento, idLocalidade,
										idCategoria, colecaoFinanciamentoTipos,
										resumoFaturamentoTemporario.getLancamentoItemContabil().getId());

						resumoFaturamentoTemporario = this.acumularValorResumoFaturamento(resumoFaturamentoTemporario,valoresAcumuladosCanceladosEIncluidos[1]);
						resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaBruta, resumoFaturamentoTemporario.getValorItemFaturamento());

						if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}

						idsCreditosOrigem = obterIdsCreditosOrigemParaEncerramentoFaturamentoMensal();

						// acumula o valor por categoria do credito realizado com origem do credito igual a devolução de tarifa de água,
						// devolução de tarifa de esgoto, serviços indiretos pagos indevidamente ou devolução de juros de
						// parcelamento e com situação atual da conta igual cancelada e com ano/mês de referência contábil da conta igual ao
						// ano/mês do faturamento de sistema parâmetro.
						BigDecimal valorCreditoRealizadoOrigemCreditoSituacaoCancelada = repositorioFaturamento
								.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(
										anoMesFaturamento, idLocalidade,
										idCategoria, idsCreditosOrigem,
										DebitoCreditoSituacao.CANCELADA,
										lancamentoItemContabilTemp.getId());

						BigDecimal[] diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada = this
								.obterDiferencaValoresCreditosRealizadosContaRetificada(
										anoMesFaturamento, idLocalidade,
										idCategoria, idsCreditosOrigem,
										lancamentoItemContabilTemp.getId());

						/*
						 * Acumula o valores cancelados, a diferença entre o
						 * valor dos créditos realizados com origem do crédito
						 * igual a devolução de tarifa de água, devolução de
						 * tarifa de esgoto, serviços indiretos pagos
						 * indevidamente ou devolução de juros de parcelamento e
						 * situação atual da conta igual a cancelada por
						 * retificação e o valor do crédito realizado com
						 * situação atual ou anterior da conta igual a
						 * retificada.
						 */
						valorCreditoRealizadoOrigemCreditoSituacaoCancelada = valorCreditoRealizadoOrigemCreditoSituacaoCancelada
								.add(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada[0]);

						if (valorCreditoRealizadoOrigemCreditoSituacaoCancelada.compareTo(BigDecimal.ZERO) != 0) {

							lancamentoTipo = new LancamentoTipo(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO);
							lancamentoItem = new LancamentoItem(LancamentoItem.CREDITOS_PARA_COBRANCA_INDEVIDA_CANCELADOS);

							resumoFaturamentoTemporario = buildResumoFaturamento(
									valorCreditoRealizadoOrigemCreditoSituacaoCancelada,
									anoMesFaturamento, categoria, localidade,
									lancamentoTipo, lancamentoItem,
									lancamentoItemContabilTemp,
									new Short("520"),
									lancamentoItemContabilTemp.getSequenciaImpressao());

							resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(
											resumoFaturamentoReceitaBruta,resumoFaturamentoTemporario.getValorItemFaturamento());
							
							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}

						// acumula o valor por categoria do credito realizado
						// com origem do credito igual a devolução de tarifa de
						// água,
						// devolução de tarifa de esgoto, serviços indiretos
						// pagos indevidamente ou devolução de juros de
						// parcelamento e
						// com situação atual da conta igual incluída e com
						// ano/mês de referência contábil da conta igual ao
						// ano/mês do
						// faturamento de sistema parâmetro.
						BigDecimal valorCreditoRealizadoOrigemCreditoSituacaoIncluida = repositorioFaturamento
								.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(
										anoMesFaturamento, idLocalidade,
										idCategoria, idsCreditosOrigem,
										DebitoCreditoSituacao.INCLUIDA,
										lancamentoItemContabilTemp.getId());

						/*
						 * Acumula o valores incluidos, a diferença entre o
						 * valor dos créditos realizados com origem do crédito
						 * igual a devolução de tarifa de água, devolução de
						 * tarifa de esgoto, serviços indiretos pagos
						 * indevidamente ou devolução de juros de parcelamento e
						 * situação atual da conta igual a cancelada por
						 * retificação e o valor do crédito realizado com
						 * situação atual ou anterior da conta igual a
						 * retificada.
						 */
						valorCreditoRealizadoOrigemCreditoSituacaoIncluida = valorCreditoRealizadoOrigemCreditoSituacaoIncluida
								.add(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada[1]);

						if (valorCreditoRealizadoOrigemCreditoSituacaoIncluida.compareTo(BigDecimal.ZERO) != 0) {
							resumoFaturamentoTemporario = buildResumoFaturamento(
									valorCreditoRealizadoOrigemCreditoSituacaoIncluida,
									anoMesFaturamento, 
									categoria, 
									localidade,
									new LancamentoTipo(LancamentoTipo.CREDITOS_REALIZADOS_CONTAS_INCLUIDAS), 
									new LancamentoItem(LancamentoItem.CREDITOS_PARA_COBRANCA_INDEVIDA_INCLUIDOS),
									lancamentoItemContabilTemp, 
									new Short("1010"), 
									lancamentoItemContabilTemp.getSequenciaImpressao());

							resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaCancelada,resumoFaturamentoTemporario.getValorItemFaturamento());
							
							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}

						// acumula os valores do débito para tipo de financiamento igual a serviço e situação igual a cancelada
						colecaoFinanciamentoTipos = new ArrayList<Integer>();
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.SERVICO_NORMAL);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_AGUA);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_ESGOTO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_SERVICO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ENTRADA_PARCELAMENTO);

						valorItemFaturamento = repositorioFaturamento.acumularValorDebitoCobradoPorTipoFinanciamento(
										anoMesFaturamento, idLocalidade,
										idCategoria,
										lancamentoItemContabilTemp.getId(),
										DebitoCreditoSituacao.CANCELADA,
										colecaoFinanciamentoTipos);

						resumoFaturamentoTemporario = buildResumoFaturamento(
								valorItemFaturamento, 
								anoMesFaturamento,
								categoria, 
								localidade, 
								new LancamentoTipo(LancamentoTipo.CANCELAMENTOS_POR_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.GRUPO_CONTABIL), 
								lancamentoItemContabilTemp,
								new Short("900"), lancamentoItemContabilTemp.getSequenciaImpressao());

						// obtém o valor da guia de pagamento para situação igual a cancelada
						int[] idFinanciamentoTipo = new int[1];
						idFinanciamentoTipo[0] = FinanciamentoTipo.SERVICO_NORMAL;

						BigDecimal valorGuiaPagamentoSituacaoCancelada = repositorioFaturamento
								.acumularValorGuiaPagamentoPorTipoFinanciamento(
										anoMesFaturamento, idLocalidade,
										idCategoria, idFinanciamentoTipo,
										lancamentoItemContabilTemp.getId(),
										DebitoCreditoSituacao.CANCELADA);

						resumoFaturamentoTemporario = this.acumularValorResumoFaturamento(resumoFaturamentoTemporario,valorGuiaPagamentoSituacaoCancelada);

						// calcula a diferença entre as contas canceladas por
						// retificação e retificadas
						colecaoFinanciamentoTipos = new ArrayList<Integer>();
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.SERVICO_NORMAL);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_AGUA);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_ESGOTO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ARRASTO_SERVICO);
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.ENTRADA_PARCELAMENTO);

						valoresAcumuladosCanceladosEIncluidos = this
								.obterDiferencaValoresServicoIndiretosContaRetificada(
										anoMesFaturamento, idLocalidade,
										idCategoria, colecaoFinanciamentoTipos,
										lancamentoItemContabilTemp.getId());

						// Valor acumuludo canceldo
						resumoFaturamentoTemporario = this.acumularValorResumoFaturamento(resumoFaturamentoTemporario,valoresAcumuladosCanceladosEIncluidos[0]);
						
						resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaCancelada,resumoFaturamentoTemporario.getValorItemFaturamento());

						// caso o valor do item seja diferente de zero adiciona
						// o item a coleção para posterior inserção
						if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}

						// acumular o valor de débito para tipo de financiamento
						// igual a parcelamento de serviço e para situação igual
						// a cancelada

						colecaoFinanciamentoTipos = new ArrayList<Integer>();
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.PARCELAMENTO_SERVICO);

						valorItemFaturamento = repositorioFaturamento
								.acumularValorDebitoCobradoPorTipoFinanciamento(
										anoMesFaturamento, idLocalidade,
										idCategoria,
										lancamentoItemContabilTemp.getId(),
										DebitoCreditoSituacao.CANCELADA,
										colecaoFinanciamentoTipos);

						resumoFaturamentoTemporario = buildResumoFaturamento(
								valorItemFaturamento, 
								anoMesFaturamento,
								categoria, 
								localidade, 
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTOS_POR_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.GRUPO_CONTABIL), 
								lancamentoItemContabilTemp,
								new Short("1000"),
								lancamentoItemContabilTemp.getSequenciaImpressao());

						colecaoFinanciamentoTipos = new ArrayList<Integer>();
						colecaoFinanciamentoTipos.add(FinanciamentoTipo.PARCELAMENTO_SERVICO);

						valoresAcumuladosCanceladosEIncluidos = this
								.obterDiferencaValoresServicoIndiretosContaRetificada(
										anoMesFaturamento, idLocalidade,
										idCategoria, colecaoFinanciamentoTipos,
										resumoFaturamentoTemporario
												.getLancamentoItemContabil()
												.getId());

						resumoFaturamentoTemporario = this.acumularValorResumoFaturamento(resumoFaturamentoTemporario, valoresAcumuladosCanceladosEIncluidos[0]);
						
						resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaCancelada,resumoFaturamentoTemporario.getValorItemFaturamento());

						// caso o valor do item seja diferente de zero adiciona
						// o item a coleção para posterior inserção
						if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}

					}

					colecaoDadosDebitoACobrar = null;
					colecaoDadosDebitoACobrar = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.SERVICO_NORMAL,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (colecaoDadosDebitoACobrar != null && !colecaoDadosDebitoACobrar.isEmpty()) {
						for (Object[] arrayDadosDebitoACobrar : colecaoDadosDebitoACobrar) {
							somaValorCurtoPrazo = (BigDecimal) arrayDadosDebitoACobrar[0];
							somaValorLongoPrazo = (BigDecimal) arrayDadosDebitoACobrar[1];

							Integer idLancamentoItemContabil = (Integer) arrayDadosDebitoACobrar[2];
							Short sequencialImpressao = (Short) arrayDadosDebitoACobrar[3];

							LancamentoItemContabil lancamentoItemContabilTemp = new LancamentoItemContabil(idLancamentoItemContabil);
							lancamentoItemContabilTemp.setSequenciaImpressao(sequencialImpressao);

							if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
								ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazo = buildResumoFaturamento(
										somaValorCurtoPrazo, 
										anoMesFaturamento,
										categoria, 
										localidade, 
										new LancamentoTipo(LancamentoTipo.FINANCIAMENTOS_INCLUIDOS_CURTO_PRAZO),
										new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
										lancamentoItemContabilTemp, new Short("300"),
										lancamentoItemContabilTemp.getSequenciaImpressao());

								resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaBruta,somaValorCurtoPrazo);
								
								colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarCurtoPrazo);
							}

							if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {

								ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazo = buildResumoFaturamento(
										somaValorLongoPrazo, 
										anoMesFaturamento,
										categoria, 
										localidade, 
										new LancamentoTipo(LancamentoTipo.FINANCIAMENTOS_INCLUIDOS_LONGO_PRAZO),
										new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
										lancamentoItemContabilTemp, new Short("400"),
										lancamentoItemContabilTemp.getSequenciaImpressao());

								resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaBruta, somaValorLongoPrazo);
								
								colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarLongoPrazo);
							}
						}
					}

					// pesquisa os valores de curo e longo prazo de débitos a
					// cobrar com situação cancelado e tipo de financiamento
					// igual a serviço
					colecaoDadosDebitoACobrar = null;
					colecaoDadosDebitoACobrar = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.SERVICO_NORMAL,
									DebitoCreditoSituacao.CANCELADA);

					if (colecaoDadosDebitoACobrar != null
							&& !colecaoDadosDebitoACobrar.isEmpty()) {
						for (Object[] arrayDadosDebitoACobrar : colecaoDadosDebitoACobrar) {
							somaValorCurtoPrazo = (BigDecimal) arrayDadosDebitoACobrar[0];
							somaValorLongoPrazo = (BigDecimal) arrayDadosDebitoACobrar[1];

							Integer idLancamentoItemContabil = (Integer) arrayDadosDebitoACobrar[2];
							Short sequencialImpressao = (Short) arrayDadosDebitoACobrar[3];

							LancamentoItemContabil lancamentoItemContabilTemp = new LancamentoItemContabil(idLancamentoItemContabil);
							lancamentoItemContabilTemp.setSequenciaImpressao(sequencialImpressao);

							if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {

								ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazo = buildResumoFaturamento(
										somaValorCurtoPrazo, 
										anoMesFaturamento,
										categoria, 
										localidade, 
										new LancamentoTipo(LancamentoTipo.FINANCIAMENTOS_CANCELADOS_CURTO_PRAZO),
										new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
										lancamentoItemContabilTemp, new Short("700"),
										lancamentoItemContabilTemp.getSequenciaImpressao());

								resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaCancelada, somaValorCurtoPrazo);
								
								colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarCurtoPrazo);
							}

							// caso exista valor de longo prazo e seja diferente de zero
							if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {

								ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazo = buildResumoFaturamento(
										somaValorLongoPrazo, 
										anoMesFaturamento,
										categoria, 
										localidade, 
										new LancamentoTipo(LancamentoTipo.FINANCIAMENTOS_CANCELADOS_LONGO_PRAZO),
										new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
										lancamentoItemContabilTemp, new Short("800"),
										lancamentoItemContabilTemp.getSequenciaImpressao());

								resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaCancelada, somaValorLongoPrazo);
								colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarLongoPrazo);
							}
						}
					}

					// Linha 23 e 24
					colecaoDadosDebitoACobrar = null;
					colecaoDadosDebitoACobrar = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_SERVICO,
									DebitoCreditoSituacao.CANCELADA);

					if (colecaoDadosDebitoACobrar != null && !colecaoDadosDebitoACobrar.isEmpty()) {
						for (Object[] arrayDadosDebitoACobrar : colecaoDadosDebitoACobrar) {
							somaValorCurtoPrazo = (BigDecimal) arrayDadosDebitoACobrar[0];
							somaValorLongoPrazo = (BigDecimal) arrayDadosDebitoACobrar[1];

							Integer idLancamentoItemContabil = (Integer) arrayDadosDebitoACobrar[2];
							Short sequencialImpressao = (Short) arrayDadosDebitoACobrar[3];

							LancamentoItemContabil lancamentoItemContabilTemp = new LancamentoItemContabil(idLancamentoItemContabil);
							lancamentoItemContabilTemp.setSequenciaImpressao(sequencialImpressao);

							if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {

								ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazo = buildResumoFaturamento(
										somaValorCurtoPrazo, 
										anoMesFaturamento,
										categoria, 
										localidade, 
										new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_CANCELADOS_CURTO_PRAZO),
										new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
										lancamentoItemContabilTemp, new Short("810"),
										lancamentoItemContabilTemp.getSequenciaImpressao());

								resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaCancelada,somaValorCurtoPrazo);
								
								colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarCurtoPrazo);
							}

							if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {

								ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazo = buildResumoFaturamento(
										somaValorLongoPrazo, 
										anoMesFaturamento,
										categoria, 
										localidade, 
										new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_CANCELADOS_LONGO_PRAZO),
										new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
										lancamentoItemContabilTemp, new Short("820"),
										lancamentoItemContabilTemp.getSequenciaImpressao());

								resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaCancelada,somaValorLongoPrazo);

								colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarLongoPrazo);
							}
						}
					}

					idsTipoFinanciamento = null;
					idsTipoFinanciamento = new Integer[4];
					idsTipoFinanciamento[0] = FinanciamentoTipo.SERVICO_NORMAL;
					idsTipoFinanciamento[1] = FinanciamentoTipo.ARRASTO_AGUA;
					idsTipoFinanciamento[2] = FinanciamentoTipo.ARRASTO_ESGOTO;
					idsTipoFinanciamento[3] = FinanciamentoTipo.ARRASTO_SERVICO;

					colecaoDadosDebitoCobradoCategoria = null;
					colecaoDadosDebitoCobradoCategoria = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchidaAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsTipoFinanciamento,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					for (Object[] arrayDadosDebitoCobradoCategoria : colecaoDadosDebitoCobradoCategoria) {

						BigDecimal valor = (BigDecimal) arrayDadosDebitoCobradoCategoria[0];
						Short sequenciaImpressao = (Short) arrayDadosDebitoCobradoCategoria[1];
						Integer idLancamentoItemContabil = (Integer) arrayDadosDebitoCobradoCategoria[2];
						LancamentoItemContabil lancamentoItemContabilTemp = new LancamentoItemContabil(idLancamentoItemContabil);

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {

							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor, 
									anoMesFaturamento, 
									categoria,
									localidade, 
									new LancamentoTipo(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA), 
									new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
									lancamentoItemContabilTemp, 
									new Short("3400"), 
									sequenciaImpressao);

							resumoTotalDebitosCanceladosPrescricao = this.acumularValorResumoFaturamento(resumoTotalDebitosCanceladosPrescricao,resumoFaturamento.getValorItemFaturamento());
							
							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}

					// acumula o valor por categoria do débito cobrado com tipo
					// de financiamento igual a parcelamento de serviço e
					// situação atual da conta
					// igual a débito prescrito e com ano/mês de referência
					// contábil da conta preenchido.
					idsTipoFinanciamento = null;
					idsTipoFinanciamento = new Integer[1];
					idsTipoFinanciamento[0] = FinanciamentoTipo.PARCELAMENTO_SERVICO;

					colecaoDadosDebitoCobradoCategoria = null;
					colecaoDadosDebitoCobradoCategoria = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchidaAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsTipoFinanciamento,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					for (Object[] arrayDadosDebitoCobradoCategoria : colecaoDadosDebitoCobradoCategoria) {
						BigDecimal valor = (BigDecimal) arrayDadosDebitoCobradoCategoria[0];
						Short sequenciaImpressao = (Short) arrayDadosDebitoCobradoCategoria[1];
						Integer idLancamentoItemContabil = (Integer) arrayDadosDebitoCobradoCategoria[2];

						LancamentoItemContabil lancamentoItemContabilTemp = new LancamentoItemContabil(idLancamentoItemContabil);

						if (valor != null&& valor.compareTo(BigDecimal.ZERO) != 0) {

							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor, 
									anoMesFaturamento, 
									categoria,
									localidade, 
									new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_EXC_INADIMPLENCIA), 
									new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
									new LancamentoItemContabil(idLancamentoItemContabil), 
									new Short("3500"), 
									sequenciaImpressao);
							

							resumoTotalDebitosCanceladosPrescricao = this.acumularValorResumoFaturamento(
											resumoTotalDebitosCanceladosPrescricao,resumoFaturamento.getValorItemFaturamento());

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}

					// acumula o valor por categoria do crédito realizado com
					// origem do crédito igual a
					// devolução de tarifa de água ou devolução de tarifa de
					// esgoto ou serviços indiretos pagos
					// indevidamente ou devolução de juros de parcelamento e
					// situação atual da conta igual a débito prescrito
					// com ano/mês da baixa contábil da conta preenchido
					Integer[] idsOrigemCreditos = {
							CreditoOrigem.DEVOLUCAO_TARIFA_AGUA,
							CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO,
							CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE,
							CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO };

					colecaoDadosCreditoRealizado = null;
					colecaoDadosCreditoRealizado = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchidaAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsOrigemCreditos,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (colecaoDadosCreditoRealizado != null
							&& !colecaoDadosCreditoRealizado.isEmpty()) {

						for (Object[] arrayDadosCreditoRealizado : colecaoDadosCreditoRealizado) {

							BigDecimal valor = (BigDecimal) arrayDadosCreditoRealizado[0];
							Short sequenciaImpressao = (Short) arrayDadosCreditoRealizado[2];
							Integer idLancamentoItemContabil = (Integer) arrayDadosCreditoRealizado[1];

							if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
								ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
										valor, 
										anoMesFaturamento, 
										categoria,
										localidade, 
										new LancamentoTipo(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA), 
										new LancamentoItem(LancamentoItem.CREDITOS_PARA_COBRANCA_INDEVIDA),
										new LancamentoItemContabil(idLancamentoItemContabil), 
										new Short("3600"), 
										sequenciaImpressao);
								
								resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
										resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

								colecaoResumoFaturamento.add(resumoFaturamento);
							}
						}
					}

					// acumula o valor por categoria do débito cobrado com tipo de financiamento igual a serviço e situação atual da
					// conta igual a débito prescrito e com ano/mês de referência contábil da conta não preenchido.
					idsTipoFinanciamento = null;
					idsTipoFinanciamento = new Integer[4];
					idsTipoFinanciamento[0] = FinanciamentoTipo.SERVICO_NORMAL;
					idsTipoFinanciamento[1] = FinanciamentoTipo.ARRASTO_AGUA;
					idsTipoFinanciamento[2] = FinanciamentoTipo.ARRASTO_ESGOTO;
					idsTipoFinanciamento[3] = FinanciamentoTipo.ARRASTO_SERVICO;

					colecaoDadosDebitoCobradoCategoria = null;
					colecaoDadosDebitoCobradoCategoria = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchidaAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsTipoFinanciamento,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					for (Object[] arrayDadosDebitoCobradoCategoria : colecaoDadosDebitoCobradoCategoria) {

						BigDecimal valor = (BigDecimal) arrayDadosDebitoCobradoCategoria[0];
						Short sequenciaImpressao = (Short) arrayDadosDebitoCobradoCategoria[1];
						Integer idLancamentoItemContabil = (Integer) arrayDadosDebitoCobradoCategoria[2];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor, 
									anoMesFaturamento, 
									categoria,
									localidade, 
									new LancamentoTipo(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA), 
									new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
									new LancamentoItemContabil(idLancamentoItemContabil), 
									new Short("3800"), 
									sequenciaImpressao);
							
							resumoTotalDebitosCanceladosPrescricao = this.acumularValorResumoFaturamento(
											resumoTotalDebitosCanceladosPrescricao,resumoFaturamento.getValorItemFaturamento());
							
							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}

					// acumula o valor por categoria do débito cobrado com tipo de financiamento igual a parcelamento de serviço e
					// situação atual da conta igual a débito prescrito e com ano/mês de referência contábil da conta não preenchido.
					idsTipoFinanciamento = null;
					idsTipoFinanciamento = new Integer[1];
					idsTipoFinanciamento[0] = FinanciamentoTipo.PARCELAMENTO_SERVICO;

					colecaoDadosDebitoCobradoCategoria = null;
					colecaoDadosDebitoCobradoCategoria = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchidaAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsTipoFinanciamento,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					for (Object[] arrayDadosDebitoCobradoCategoria : colecaoDadosDebitoCobradoCategoria) {

						BigDecimal valor = (BigDecimal) arrayDadosDebitoCobradoCategoria[0];
						Short sequenciaImpressao = (Short) arrayDadosDebitoCobradoCategoria[1];
						Integer idLancamentoItemContabil = (Integer) arrayDadosDebitoCobradoCategoria[2];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {

							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor, 
									anoMesFaturamento, 
									categoria,
									localidade, 
									new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA), 
									new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
									new LancamentoItemContabil(idLancamentoItemContabil), 
									new Short("3900"), 
									sequenciaImpressao);
							
							resumoTotalDebitosCanceladosPrescricao = this.acumularValorResumoFaturamento(
											resumoTotalDebitosCanceladosPrescricao,resumoFaturamento.getValorItemFaturamento());
							
							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}

					idsOrigemCreditos = null;
					idsOrigemCreditos = obterIdsCreditosOrigemParaEncerramentoFaturamentoMensal();

					// acumula o valor por categoria do crédito realizado com
					// origem do crédito igual a devolução de tarifa de água ou
					// devolução de
					// tarifa de esgoto ou serviços indiretos pagos
					// indevidamente ou devolução de juros de parcelamento
					// e situação atual da conta igual a débito prescrito com
					// ano/mês da baixa contábil da conta não preenchido
					colecaoDadosCreditoRealizado = null;
					colecaoDadosCreditoRealizado = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchidaAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsOrigemCreditos,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (colecaoDadosCreditoRealizado != null
							&& !colecaoDadosCreditoRealizado.isEmpty()) {

						for (Object[] arrayDadosCreditoRealizado : colecaoDadosCreditoRealizado) {

							BigDecimal valor = (BigDecimal) arrayDadosCreditoRealizado[0];
							Short sequenciaImpressao = (Short) arrayDadosCreditoRealizado[2];
							Integer idLancamentoItemContabil = (Integer) arrayDadosCreditoRealizado[1];

							if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
								ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
										valor, 
										anoMesFaturamento, 
										categoria,
										localidade, 
										new LancamentoTipo(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA), 
										new LancamentoItem(LancamentoItem.CREDITOS_PARA_COBRANCA_INDEVIDA),
										new LancamentoItemContabil(idLancamentoItemContabil), 
										new Short("4000"), 
										sequenciaImpressao);
								
								resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
										resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

								colecaoResumoFaturamento.add(resumoFaturamento);
							}
						}
					}

					// acumular o valor de guia de pagamento para situação normal e tipo de financiamento igual a serviço
					Collection<Object[]> colecaoDadosGuiaPagamento = null;
					colecaoDadosGuiaPagamento = repositorioFaturamento
							.acumularValorGuiaPagamentoPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.SERVICO_NORMAL);

					for (Object[] arrayDadosGuiaPagamento : colecaoDadosGuiaPagamento) {
						BigDecimal valor = (BigDecimal) arrayDadosGuiaPagamento[0];
						Short sequenciaImpressao = (Short) arrayDadosGuiaPagamento[1];
						Integer idItemLancamentoContabil = (Integer) arrayDadosGuiaPagamento[2];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor, 
									anoMesFaturamento, 
									categoria,
									localidade, 
									new LancamentoTipo(LancamentoTipo.FATURAMENTO_ADICIONAL_GUIA_PAGAMENTO), 
									new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
									new LancamentoItemContabil(idItemLancamentoContabil), 
									new Short("500"), 
									sequenciaImpressao);
							
							resumoFaturamentoReceitaBruta.setValorItemFaturamento(
									resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}

					valorItemFaturamento = repositorioFaturamento.acumularValorAguaPorSituacaoConta(
									anoMesFaturamento, idLocalidade,idCategoria,DebitoCreditoSituacao.CANCELADA);

					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorItemFaturamento, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.CANCELAMENTOS_POR_REFATURAMENTO), 
							new LancamentoItem(LancamentoItem.AGUA),
							null, 
							new Short("900"), 
							new Short("10"));
					
					BigDecimal somaValorAguaSituacaoCanceladaPorRetificacao = null;
					BigDecimal somaValorAguaSituacaoRetificada = null;

					somaValorAguaSituacaoCanceladaPorRetificacao = repositorioFaturamento.diferencaValorAguaCanceladaRetificacao(anoMesFaturamento, idLocalidade,idCategoria);
					somaValorAguaSituacaoRetificada = repositorioFaturamento.diferencaValorAguaRetificada(anoMesFaturamento,idLocalidade, idCategoria);

					resumoFaturamentoTemporario = this.acumularValorResumoFaturamento(resumoFaturamentoTemporario, somaValorAguaSituacaoCanceladaPorRetificacao);
					
					resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(
							resumoFaturamentoReceitaCancelada,resumoFaturamentoTemporario.getValorItemFaturamento());

					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					
					
					// acumular o valor de água para situação atual ou anterior igual a incluída
					valorItemFaturamento = repositorioFaturamento
							.acumularValorAguaPorSituacaoConta(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									DebitoCreditoSituacao.INCLUIDA,
									DebitoCreditoSituacao.INCLUIDA);

					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorItemFaturamento, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO), 
							new LancamentoItem(LancamentoItem.AGUA),
							null, 
							new Short("510"), 
							new Short("10"));
					
					resumoFaturamentoTemporario = this.acumularValorResumoFaturamento(resumoFaturamentoTemporario, somaValorAguaSituacaoRetificada);

					resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaBruta, resumoFaturamentoTemporario.getValorItemFaturamento());
					
					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					
					
					// acumula os valores de esgoto para situação cancelada
					valorItemFaturamento = repositorioFaturamento.acumularValorEsgotoPorSituacaoConta(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									DebitoCreditoSituacao.CANCELADA);

					// cria o resumo de faturamento
					BigDecimal somaValorEsgotoSituacaoCanceladaPorRetificacao = repositorioFaturamento.diferencaValorEsgotoCanceladaRetificacao(
							anoMesFaturamento, idLocalidade,idCategoria);
					
					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorItemFaturamento, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.CANCELAMENTOS_POR_REFATURAMENTO), 
							new LancamentoItem(LancamentoItem.ESGOTO),
							null, 
							new Short("900"), 
							new Short("20"));
					
					resumoFaturamentoTemporario.setValorItemFaturamento(
							resumoFaturamentoTemporario.getValorItemFaturamento().add(somaValorEsgotoSituacaoCanceladaPorRetificacao));
					
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(
							resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					// acumular o valor de esgoto para situação atual ou anterior igual a incluída
					valorItemFaturamento = repositorioFaturamento
							.acumularValorEsgotoPorSituacaoConta(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									DebitoCreditoSituacao.INCLUIDA,
									DebitoCreditoSituacao.INCLUIDA);

					BigDecimal somaValorEsgotoSituacaoRetificada = repositorioFaturamento.diferencaValorEsgotoRetificada(
							anoMesFaturamento,idLocalidade, idCategoria);
					
					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorItemFaturamento, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO), 
							new LancamentoItem(LancamentoItem.ESGOTO),
							null, 
							new Short("510"), 
							new Short("20"));
					
					resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(somaValorEsgotoSituacaoRetificada));
					
					// acumula o valor do sequencial 510 a receita bruta
					resumoFaturamentoReceitaBruta.setValorItemFaturamento(
							resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 09
					
					// Linha 12
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_INCONDICIONAIS;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// descontos incondicionais
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosIncondicionais = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.CANCELADA);

					// [SB0003 - Obter diferenças de valores de créditos
					// realizados de conta retificada]
					BigDecimal[] diferencaCreditoOrigemDescontosIncondicionaisCanceladaPorRetificacaoeERetificada = this
							.obterDiferencaValoresCreditosRealizadosContaRetificada(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem);

					/*
					 * Acumula os valores cancelados, a diferença entre o valor
					 * dos créditos realizados com origem do crédito igual a
					 * descontos incondicionais e situação atual da conta igual
					 * a cancelada por retificação e o valor do crédito
					 * realizado com situação atual ou anterior da conta igual a
					 * retificada.
					 */
					valorCreditoRealizadoOrigemCreditoDescontosIncondicionais = valorCreditoRealizadoOrigemCreditoDescontosIncondicionais
							.add(diferencaCreditoOrigemDescontosIncondicionaisCanceladaPorRetificacaoeERetificada[0]);

					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorCreditoRealizadoOrigemCreditoDescontosIncondicionais, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO), 
							new LancamentoItem(LancamentoItem.DESCONTOS_INCONDICIONAIS_CANCELADOS),
							null, 
							new Short("530"), 
							new Short("0"));
					
					// acumula o valor do sequencial 530 a receita bruta
					resumoFaturamentoReceitaBruta.setValorItemFaturamento(
							resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 12
					
					// Linha 35
					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosIncondicionaisSituacaoIncluida = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.INCLUIDA);

					valorCreditoRealizadoOrigemCreditoDescontosIncondicionaisSituacaoIncluida = valorCreditoRealizadoOrigemCreditoDescontosIncondicionaisSituacaoIncluida
							.add(diferencaCreditoOrigemDescontosIncondicionaisCanceladaPorRetificacaoeERetificada[1]);

					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorCreditoRealizadoOrigemCreditoDescontosIncondicionaisSituacaoIncluida, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.CREDITOS_REALIZADOS_CONTAS_INCLUIDAS), 
							new LancamentoItem(LancamentoItem.DESCONTOS_INCONDICIONAIS_INCLUIDOS),
							null, 
							new Short("1020"), 
							new Short("0"));
					
					resumoFaturamentoTemporario.setUltimaAlteracao(new Date());

					// adiciona o sequencial 1020 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(
							resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 35
					
					// Linha 19 e 20
					arrayValoresCurtoLongoPrazo = null;
					arrayValoresCurtoLongoPrazo = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamento(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_AGUA,
									DebitoCreditoSituacao.CANCELADA);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					// caso o valor de curto prazo seja diferente de zero
					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo, 
								anoMesFaturamento, 
								categoria,
								localidade, 
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_CANCELADOS_CURTO_PRAZO), 
								new LancamentoItem(LancamentoItem.AGUA),
								null, 
								new Short("810"), 
								new Short("10"));
						
						// adiciona o sequencial 810 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(somaValorCurtoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
/* eduardo*/ 
					// caso o valor de longo prazo seja diferente de zero.
					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo, 
								anoMesFaturamento, 
								categoria,
								localidade, 
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_CANCELADOS_LONGO_PRAZO), 
								new LancamentoItem(LancamentoItem.AGUA),
								null, 
								new Short("820"), 
								new Short("10"));
						
						// adiciona o sequencial 820 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(somaValorLongoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 19 e 20
					
					// Linha 21 e 22
					arrayValoresCurtoLongoPrazo = null;
					arrayValoresCurtoLongoPrazo = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamento(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_ESGOTO,
									DebitoCreditoSituacao.CANCELADA);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					// caso o valor de curto prazo seja diferente de zero
					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo, 
								anoMesFaturamento, 
								categoria,
								localidade, 
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_CANCELADOS_CURTO_PRAZO), 
								new LancamentoItem(LancamentoItem.ESGOTO),
								null, 
								new Short("810"), 
								new Short("20"));
						
						// adiciona o sequencial 810 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(somaValorCurtoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo, 
								anoMesFaturamento, 
								categoria,
								localidade, 
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_CANCELADOS_LONGO_PRAZO), 
								new LancamentoItem(LancamentoItem.ESGOTO),
								null, 
								new Short("820"), 
								new Short("20"));
						
						// adiciona o sequencial 820 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(somaValorLongoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 21 e 22
					
					// Linha 25 e 26
					arrayValoresCurtoLongoPrazo = null;
					arrayValoresCurtoLongoPrazo = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorTipoFinanciamento(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.JUROS_PARCELAMENTO,
									DebitoCreditoSituacao.CANCELADA);

					// recupera as somas de curto e longo prazo
					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					// caso o valor de curto prazo seja diferente de zero
					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo, 
								anoMesFaturamento, 
								categoria,
								localidade, 
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_CANCELADOS_CURTO_PRAZO), 
								new LancamentoItem(LancamentoItem.JUROS),
								null, 
								new Short("810"), 
								maxSequencialImpressaoMais10);
						
						// adiciona o sequencial 810 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(somaValorCurtoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					// caso o valor de curto prazo seja diferente de zero
					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo, 
								anoMesFaturamento, 
								categoria,
								localidade, 
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_CANCELADOS_LONGO_PRAZO), 
								new LancamentoItem(LancamentoItem.JUROS),
								null, 
								new Short("820"), 
								maxSequencialImpressaoMais10);
						
						// adiciona o sequencial 810 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(somaValorLongoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 25 e 26
					
					// Linha 30
					valorItemFaturamento = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamento(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									DebitoCreditoSituacao.CANCELADA,
									FinanciamentoTipo.PARCELAMENTO_AGUA);

					// canceladas por retificação e retificadas
					BigDecimal[] valorDebitoAcumuladoCanceladoEIncluido = this
							.obterDiferencaValoresParcelamentoIndiretosContaRetificada(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_AGUA);
					
					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorItemFaturamento, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTOS_POR_REFATURAMENTO), 
							new LancamentoItem(LancamentoItem.AGUA),
							null, 
							new Short("1000"), 
							new Short("10"));
					
					resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(valorDebitoAcumuladoCanceladoEIncluido[0]));

					// adiciona o sequencial 1000 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(
							resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));
					
					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 30
					
					// Linha 31
					valorItemFaturamento = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamento(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									DebitoCreditoSituacao.CANCELADA,
									FinanciamentoTipo.PARCELAMENTO_ESGOTO);

					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorItemFaturamento, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTOS_POR_REFATURAMENTO), 
							new LancamentoItem(LancamentoItem.ESGOTO),
							null, 
							new Short("1000"), 
							new Short("20"));
					
					// calcula a diferença entre as contas canceladas por retificação e retificadas
					valorDebitoAcumuladoCanceladoEIncluido = this.obterDiferencaValoresParcelamentoIndiretosContaRetificada(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_ESGOTO);

					resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(valorDebitoAcumuladoCanceladoEIncluido[0]));

					// adiciona o sequencial 1000 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(
							resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 31
					
					// Linha 33
					valorItemFaturamento = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamento(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									DebitoCreditoSituacao.CANCELADA,
									FinanciamentoTipo.JUROS_PARCELAMENTO);

					resumoFaturamentoTemporario = buildResumoFaturamento(
							valorItemFaturamento, 
							anoMesFaturamento, 
							categoria,
							localidade, 
							new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTOS_POR_REFATURAMENTO), 
							new LancamentoItem(LancamentoItem.JUROS),
							null, 
							new Short("1000"), 
							maxSequencialImpressaoMais10);
					
					// calcula a diferença entre as contas canceladas por retificação e retificadas
					valorDebitoAcumuladoCanceladoEIncluido = this
							.obterDiferencaValoresParcelamentoIndiretosContaRetificada(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.JUROS_PARCELAMENTO);

					// Valor Acumulado Cancelado
					resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(valorDebitoAcumuladoCanceladoEIncluido[0]));

					// adiciona o sequencial 1000 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(
							resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					if (resumoFaturamentoTemporario.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 33
					
					// Linha 41
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoTipoFinanciamentoServicoSituacaoNormalNumeroPrestacoesCobradasMaiorQue11(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.SERVICO_NORMAL);

					// caso o valor do item seja diferente de zero
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento, 
								anoMesFaturamento, 
								categoria,
								localidade, 
								new LancamentoTipo(LancamentoTipo.FINANCIAMENTOS_TRANSFERIDOS_CURTO_PRAZO), 
								new LancamentoItem(LancamentoItem.FINANCIAMENTOS_TRANSFERIDOS_CURTO_PRAZO),
								null, 
								new Short("1400"), 
								ZERO);
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 41
					
					// Linha 42
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoJurosParcelamentoSituacaoNormalDiferencaPrestacoesMaiorQue11(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.JUROS_PARCELAMENTO,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento != null) {

						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_TRASFERIDOS_PARA_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.PARCELAMENTOS_TRANSFERIDOS_PARA_CURTO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1450"),
								ZERO);
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 42
					
					valorItemFaturamento = repositorioFaturamento.acumularValorTransferenciaCreditoParcelamentoLongoPrazo(
									anoMesFaturamento, idLocalidade, idCategoria, DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento != null) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_TRASFERIDOS_PARA_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.CREDITOS_DE_PARCELAMENTOS_TRANSFERIDOS_PARA_CURTO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1460"),
								ZERO);
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					
					// Linha 43 e 44
					arrayValoresCurtoLongoPrazo = null;
					arrayValoresCurtoLongoPrazo = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorGrupoParcelamento(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									ParcelamentoGrupo.DOCUMENTOS_EMITIDOS,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, true);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.DOCUMENTOS_EMITIDOS),
								new LancamentoItemContabil(null),
								new Short("1500"),
								new Short("10"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
								new LancamentoItem(LancamentoItem.DOCUMENTOS_EMITIDOS),
								new LancamentoItemContabil(null),
								new Short("1600"),
								new Short("10"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 43 e 44
					
					// Linha 45 e 46
					arrayValoresCurtoLongoPrazo = null;
					arrayValoresCurtoLongoPrazo = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorGrupoParcelamento(
									anoMesFaturamento,
									idLocalidade,
									idCategoria,
									ParcelamentoGrupo.FINANCIAMENTOS_A_COBRAR_CURTO_PRAZO,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, true);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.FINANCIAMENTOS_A_COBRAR_CURTO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1500"),
								new Short("20"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					// caso o valor de longo prazo seja diferente de zero
					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
								new LancamentoItem(LancamentoItem.FINANCIAMENTOS_A_COBRAR_CURTO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1600"),
								new Short("20"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 45 e 46
					
					// Linha 47 e 48
					arrayValoresCurtoLongoPrazo = null;
					arrayValoresCurtoLongoPrazo = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorGrupoParcelamento(
									anoMesFaturamento,
									idLocalidade,
									idCategoria,
									ParcelamentoGrupo.FINANCIAMENTOS_A_COBRAR_LONGO_PRAZO,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, true);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.FINANCIAMENTOS_A_COBRAR_LONGO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1500"),
								new Short("30"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
								new LancamentoItem(LancamentoItem.FINANCIAMENTOS_A_COBRAR_LONGO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1600"),
								new Short("30"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 47 e 48

					// Linha 49 e 50
					arrayValoresCurtoLongoPrazo = null;
					arrayValoresCurtoLongoPrazo = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorGrupoParcelamento(
									anoMesFaturamento,
									idLocalidade,
									idCategoria,
									ParcelamentoGrupo.PARCELAMENTOS_A_COBRAR_CURTO_PRAZO,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, true);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.PARCELAMENTOS_A_COBRAR_CURTO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1500"),
								new Short("40"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
								new LancamentoItem(LancamentoItem.PARCELAMENTOS_A_COBRAR_CURTO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1600"),
								new Short("40"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 49 e 50

					// Linha 51 e 52
					arrayValoresCurtoLongoPrazo = null;
					arrayValoresCurtoLongoPrazo = repositorioFaturamento
							.pesquisarValorLongoECurtoPrazoDebitoACobrarPorGrupoParcelamento(
									anoMesFaturamento,
									idLocalidade,
									idCategoria,
									ParcelamentoGrupo.PARCELAMENTOS_A_COBRAR_LONGO_PRAZO,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, true);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.PARCELAMENTOS_A_COBRAR_LONGO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1500"),
								new Short("50"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
								new LancamentoItem(LancamentoItem.PARCELAMENTOS_A_COBRAR_LONGO_PRAZO),
								new LancamentoItemContabil(null),
								new Short("1600"),
								new Short("50"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 51 e 52
					
					// Linha 54 e 55
					arrayValoresCurtoLongoPrazo = obterValorLongoECurtoPrazoCreditoARealizarPorOrigemCredito(
							CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO, anoMesFaturamento, idLocalidade, idCategoria, 
							DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.NORMAL);

					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];

					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS),
								new LancamentoItemContabil(null),
								new Short("1500"),
								new Short("90"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					// caso o valor de longo prazo seja diferente de zero
					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {

						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS),
								new LancamentoItemContabil(null),
								new Short("1600"),
								new Short("90"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					
					// Linha bbb
					arrayValoresCurtoLongoPrazo = obterValorLongoECurtoPrazoCreditoARealizarPorOrigemCredito(
							CreditoOrigem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA, anoMesFaturamento, idLocalidade, idCategoria, DebitoCreditoSituacao.NORMAL,
							DebitoCreditoSituacao.NORMAL);
					
					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];
					
					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorCurtoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA),
								new LancamentoItemContabil(null),
								new Short("1500"),
								new Short("100"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					
					
					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
						
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								somaValorLongoPrazo,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA),
								new LancamentoItemContabil(null),
								new Short("1600"),
								new Short("100"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha bbb
					
					
					arrayValoresCurtoLongoPrazo = obterValorLongoECurtoPrazoCreditoARealizarConcedidosPorOrigemCredito(
							CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_CURTO_PRAZO, anoMesFaturamento, idLocalidade, idCategoria, DebitoCreditoSituacao.NORMAL,
							DebitoCreditoSituacao.NORMAL);
					
					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];
					
					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
			            ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
			                somaValorCurtoPrazo,
			                anoMesFaturamento,
			                categoria,
			                localidade,
			                new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
			                new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_CREDITOS_ANTERIORES_CURTO_PRAZO),
			                new LancamentoItemContabil(null),
			                new Short("1500"),
			                new Short("110"));
			            
			            colecaoResumoFaturamento.add(resumoFaturamento);
			          }
					
					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
			            ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
			            	somaValorLongoPrazo,
			                anoMesFaturamento,
			                categoria,
			                localidade,
			                new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
			                new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_CREDITOS_ANTERIORES_CURTO_PRAZO),
			                new LancamentoItemContabil(null),
			                new Short("1600"),
			                new Short("110"));
			            
			            colecaoResumoFaturamento.add(resumoFaturamento);
			          }


					arrayValoresCurtoLongoPrazo = obterValorLongoECurtoPrazoCreditoARealizarConcedidosPorOrigemCredito(
							CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_LONGO_PRAZO, anoMesFaturamento, idLocalidade, idCategoria, DebitoCreditoSituacao.NORMAL,
							DebitoCreditoSituacao.NORMAL);
					
					somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
					somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];
					
					if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
			            ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
			                somaValorCurtoPrazo,
			                anoMesFaturamento,
			                categoria,
			                localidade,
			                new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
			                new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_CREDITOS_ANTERIORES_LONGO_PRAZO),
			                new LancamentoItemContabil(null),
			                new Short("1500"),
			                new Short("115"));
			            
			            colecaoResumoFaturamento.add(resumoFaturamento);
			          }
					
					if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
			            ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
			            	somaValorLongoPrazo,
			                anoMesFaturamento,
			                categoria,
			                localidade,
			                new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
			                new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_CREDITOS_ANTERIORES_LONGO_PRAZO),
			                new LancamentoItemContabil(null),
			                new Short("1600"),
			                new Short("115"));
			            
			            colecaoResumoFaturamento.add(resumoFaturamento);
			          }

					
					// fim Linha 54 e 55
					Collection<Object[]> colecaoDadosDebitoCobrado = null;
					colecaoDadosDebitoCobrado = repositorioFaturamento.acumularValorDebitoCobradoPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade, idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, FinanciamentoTipo.SERVICO_NORMAL);

					for (Object[] arrayDadosDebitoCobrado : colecaoDadosDebitoCobrado) {

						BigDecimal valor = (BigDecimal) arrayDadosDebitoCobrado[0];
						Short sequenciaImpressao = (Short) arrayDadosDebitoCobrado[1];
						Integer idItemLancamentoContabil = (Integer) arrayDadosDebitoCobrado[2];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor,
					                anoMesFaturamento,
					                categoria,
					                localidade,
					                new LancamentoTipo(LancamentoTipo.FINANCIAMENTOS_COBRADOS),
					                new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
					                new LancamentoItemContabil(idItemLancamentoContabil),
					                new Short("1700"),
					                sequenciaImpressao);
							
							// soma o sequência igual 1700 ao total cobrado nas contas
							resumoTotalCobradoNasContas.setValorItemFaturamento(
									resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}
					// fim Linha 62

					// Linha 63
					colecaoDadosDebitoCobrado = null;
					colecaoDadosDebitoCobrado = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.DOACOES);

					for (Object[] arrayDadosDebitoCobrado : colecaoDadosDebitoCobrado) {
						BigDecimal valor = (BigDecimal) arrayDadosDebitoCobrado[0];
						Short sequenciaImpressao = (Short) arrayDadosDebitoCobrado[1];
						Integer idItemLancamentoContabil = (Integer) arrayDadosDebitoCobrado[2];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor,
					                anoMesFaturamento,
					                categoria,
					                localidade,
					                new LancamentoTipo(LancamentoTipo.DOACOES_COBRADAS_EM_CONTA),
					                new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
					                new LancamentoItemContabil(idItemLancamentoContabil),
					                new Short("1800"),
					                sequenciaImpressao);
							
							colecaoResumoFaturamento.add(resumoFaturamento);

							// soma o sequência igual 1800 ao total cobrado nas contas
							resumoTotalCobradoNasContas.setValorItemFaturamento(
									resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));
						}
					}
					// fim Linha 63
					
					// Linha 66
					colecaoDadosDebitoCobrado = null;
					colecaoDadosDebitoCobrado = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.PARCELAMENTO_SERVICO);

					for (Object[] arrayDadosDebitoCobrado : colecaoDadosDebitoCobrado) {
						BigDecimal valor = (BigDecimal) arrayDadosDebitoCobrado[0];
						Short sequenciaImpressao = (Short) arrayDadosDebitoCobrado[1];
						Integer idItemLancamentoContabil = (Integer) arrayDadosDebitoCobrado[2];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor,
					                anoMesFaturamento,
					                categoria,
					                localidade,
					                new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS),
					                new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
					                new LancamentoItemContabil(idItemLancamentoContabil),
					                new Short("1900"),
					                sequenciaImpressao);
							
							// soma o sequência igual 1900 ao total cobrado nas contas
							resumoTotalCobradoNasContas.setValorItemFaturamento(
									resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}
					// fim Linha 66

					// Linha 70
					colecaoDadosDebitoCobrado = null;
					colecaoDadosDebitoCobrado = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.ARRASTO_SERVICO);

					for (Object[] arrayDadosDebitoCobrado : colecaoDadosDebitoCobrado) {
						BigDecimal valor = (BigDecimal) arrayDadosDebitoCobrado[0];
						Short sequenciaImpressao = (Short) arrayDadosDebitoCobrado[1];
						Integer idItemLancamentoContabil = (Integer) arrayDadosDebitoCobrado[2];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor,
					                anoMesFaturamento,
					                categoria,
					                localidade,
					                new LancamentoTipo(LancamentoTipo.DEBITOS_ANTERIORES_COBRADOS),
					                new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
					                new LancamentoItemContabil(idItemLancamentoContabil),
					                new Short("2100"),
					                sequenciaImpressao);
							
							// soma o sequência igual 2100 ao total cobrado nas contas
							resumoTotalCobradoNasContas.setValorItemFaturamento(
									resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}
					// fim Linha 70

					// Linha 64
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoPorReferenciaConta(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.PARCELAMENTO_AGUA);

					// se o objeto retornado não for nulo
					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS),
				                new LancamentoItem(LancamentoItem.AGUA),
				                null,
				                new Short("1900"),
				                new Short("10"));
						
						// soma o sequência igual 1900 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 64
					
					// Linha 65
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoPorReferenciaConta(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.PARCELAMENTO_ESGOTO);

					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS),
				                new LancamentoItem(LancamentoItem.ESGOTO),
				                null,
				                new Short("1900"),
				                new Short("20"));
						
						// soma o sequência igual 1900 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 65

					// Linha 67
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoPorReferenciaConta(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.JUROS_PARCELAMENTO);

					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS),
				                new LancamentoItem(LancamentoItem.JUROS),
				                null,
				                new Short("1900"),
				                maxSequencialImpressaoMais10);
						
						// soma o sequência igual 1900 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 67

					// Linha 68
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoPorReferenciaConta(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.ARRASTO_AGUA);

					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.DEBITOS_ANTERIORES_COBRADOS),
				                new LancamentoItem(LancamentoItem.AGUA),
				                null,
				                new Short("2100"),
				                new Short("10"));
						
						// soma o sequência igual 2100 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 68

					// Linha 69
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoPorReferenciaConta(
									anoMesFaturamento, idLocalidade,
									idCategoria, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL,
									FinanciamentoTipo.ARRASTO_ESGOTO);

					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.DEBITOS_ANTERIORES_COBRADOS),
				                new LancamentoItem(LancamentoItem.ESGOTO),
				                null,
				                new Short("2100"),
				                new Short("20"));
						
						// soma o sequência igual 1900 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 69

					// Linha 71
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImpostoResumoFaturamento(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.IR,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.IMPOSTOS_DEDUZIDOS_EM_CONTA),
				                new LancamentoItem(LancamentoItem.IMPOSTO_RENDA),
				                null,
				                new Short("2150"),
				                new Short("10"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);

						// subtrai o sequência igual 2150 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));
					}
					// fim Linha 71

					// Linha 72
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImpostoResumoFaturamento(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.COFINS,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.IMPOSTOS_DEDUZIDOS_EM_CONTA),
				                new LancamentoItem(LancamentoItem.COFINS),
				                null,
				                new Short("2150"),
				                new Short("20"));

						// subtrai o sequência igual 2150 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 72

					// Linha 73
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImpostoResumoFaturamento(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.CSLL,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.IMPOSTOS_DEDUZIDOS_EM_CONTA),
				                new LancamentoItem(LancamentoItem.CSLL),
				                null,
				                new Short("2150"),
				                new Short("30"));
						
						// subtrai o sequência igual 2150 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 73

					// Linha 74
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImpostoResumoFaturamento(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.PIS_PASEP,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento != null && valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
				                anoMesFaturamento,
				                categoria,
				                localidade,
				                new LancamentoTipo(LancamentoTipo.IMPOSTOS_DEDUZIDOS_EM_CONTA),
				                new LancamentoItem(LancamentoItem.PIS_PASEP),
				                null,
				                new Short("2150"),
				                new Short("40"));
						
						// subtrai o sequência igual 2150 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 74

					// Linha 75
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO;

					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaContaDuplicidade(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA),
								new LancamentoItem(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO),
								new LancamentoItemContabil(null),
								new Short("2200"),
								new Short("10"));
						
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos nas contas
						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					// fim Linha 74

					// Linha 75
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO;

					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaContaDuplicidadeAte122012(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.DEVOLUCAO_DE_VALORES_EM_CONTA_ATE_31_12_2012),
								new LancamentoItem(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO),
								new LancamentoItemContabil(null),
								new Short("2225"),
								new Short("10"));
						
						// subtrai o sequência igual 2200 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos nas contas
						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					// fim Linha 75
					
					// Linha 76
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[3];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO;
					idsCreditosOrigem[1] = CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_CURTO_PRAZO;
					idsCreditosOrigem[2] = CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_LONGO_PRAZO;
					
					valorItemFaturamento = obterValorCategoriaCreditoRealizadoCategoriaPorOrigensCreditoPorReferenciaConta(
							idsCreditosOrigem, anoMesFaturamento, idLocalidade, idCategoria);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {

						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA),
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS), 
								null, 
								new Short("2200"), 
								new Short("20"));

						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 76
					
					// Linha 77
					valorItemFaturamento = obterValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
							CreditoOrigem.DESCONTOS_CONDICIONAIS, anoMesFaturamento, idLocalidade, idCategoria);
					
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA),
								new LancamentoItem(LancamentoItem.DESCONTOS_CONDICIONAIS), 
								null, 
								new Short("2200"), 
								new Short("30"));

						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 77

					// Linha 78
					valorItemFaturamento = obterValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
							CreditoOrigem.DESCONTOS_INCONDICIONAIS, anoMesFaturamento, idLocalidade, idCategoria);
					
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {

						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA),
								new LancamentoItem(LancamentoItem.DESCONTOS_INCONDICIONAIS), 
								null, 
								new Short("2200"), 
								new Short("40"));
						
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 78
					
					// Linha 79 
					valorItemFaturamento = obterValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
							CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA, anoMesFaturamento, idLocalidade, idCategoria);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA),
								new LancamentoItem(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA), 
								null, 
								new Short("2200"), 
								new Short("50"));

						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 79
					
					// Linha ccc 
					valorItemFaturamento = obterValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
							CreditoOrigem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA, anoMesFaturamento, idLocalidade, idCategoria);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA),
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA), 
								null, 
								new Short("2200"), 
								new Short("60"));

						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha ccc

					// Linha 80
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DEVOLUCAO_TARIFA_AGUA;

					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE),
								new LancamentoItem(LancamentoItem.AGUA), 
								null, 
								new Short("2300"), 
								new Short("10"));
						
						// subtrai o sequência igual 2300 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos nas contas
						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 80
					
					// Linha 81
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO;

					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE),
								new LancamentoItem(LancamentoItem.ESGOTO), 
								null, 
								new Short("2300"), 
								new Short("20"));
						
						// subtrai o sequência igual 2300 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos nas contas
						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 81
					
					// Linha 82
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE;

					colecaoDadosCreditoRealizado = null;
					colecaoDadosCreditoRealizado = repositorioFaturamento
							.acumularValorCreditoRealizadoCategoriaPorOrigemCreditoAgrupandoPorLancamentoItemContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					for (Object[] arrayDadosCreditoRealizado : colecaoDadosCreditoRealizado) {

						BigDecimal valor = (BigDecimal) arrayDadosCreditoRealizado[0];
						Integer idLancamentoItemContabil = (Integer) arrayDadosCreditoRealizado[1];
						LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
						lancamentoItemContabil.setId(idLancamentoItemContabil);
						Short sequenciaImpressao = (Short) arrayDadosCreditoRealizado[2];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {
							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor,
									anoMesFaturamento,
									categoria,
									localidade,
									new LancamentoTipo(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE),
									new LancamentoItem(LancamentoItem.GRUPO_CONTABIL), 
									new LancamentoItemContabil(idLancamentoItemContabil), 
									new Short("2300"), 
									sequenciaImpressao);
							
							// subtrai o sequência igual 2300 ao total cobrado nas contas
							resumoTotalCobradoNasContas.setValorItemFaturamento(
									resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

							// adiciona o sequência igual 2200 ao total devolvidos nas contas
							resumoValoresDevolvidosNasContas.setValorItemFaturamento(
									resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}
					// fim Linha 82

					// Linha 83
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO;

					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE),
								new LancamentoItem(LancamentoItem.BONUS_SOCIAL), 
								null, 
								new Short("2300"), 
								maxSequencialImpressaoMais10);
						
						// subtrai o sequência igual 2300 ao total cobrado nas contas
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos nas contas
						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 83
				
					// Linha 86
					BigDecimal totalIRSituacaoCanceladaDiferencaPositiva = obterTotalIRSituacaoCanceladaDiferencaPositiva(anoMesFaturamento, idLocalidade, idCategoria);

					// caso o valor total do IR seja diferente de zero
					if (totalIRSituacaoCanceladaDiferencaPositiva.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								totalIRSituacaoCanceladaDiferencaPositiva,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_CANCELADOS_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.IMPOSTO_RENDA), 
								null, 
								new Short("2800"), 
								new Short("10"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 86

					// Linha 90
					BigDecimal totalIRSituacaoCanceladaDiferencaNegativa = obterTotalIRSituacaoCanceladaDiferencaPositiva(anoMesFaturamento, idLocalidade, idCategoria);

					BigDecimal diferencaIRSituacaoCanceladaPorRetificacaoeERetificada = obterDiferencaIRSituacaoCanceladaPorRetificacaoeERetificada(
															anoMesFaturamento, idLocalidade, idCategoria);
					BigDecimal valorIRSituacaoCancelada = obterValorIRSituacaoCancelada(anoMesFaturamento, idLocalidade, idCategoria);
					/*
					 * Acumula, quando negativa, a diferença entre o valor do imposto de renda com tipo de imposto igual a IR e
					 * situação atual da conta igual a cancelada por retificação e o valor do imposto de renda com situação atual ou
					 * anterior da conta igual a retificada.
					 */
					if (diferencaIRSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1) {
						totalIRSituacaoCanceladaDiferencaNegativa = valorIRSituacaoCancelada.add(
								diferencaIRSituacaoCanceladaPorRetificacaoeERetificada.multiply(menosUm));
					}

					// caso o valor total do IR seja diferente de zero
					if (totalIRSituacaoCanceladaDiferencaNegativa.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								totalIRSituacaoCanceladaDiferencaNegativa,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_INCLUIDOS_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.IMPOSTO_RENDA), 
								null, 
								new Short("2900"), 
								new Short("10"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 90

					// Linha 87
					BigDecimal valorCOFINSSituacaoCancelada = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImposto(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.COFINS,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal valorCOFINSSituacaoCanceladaPorRetificacao = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImposto(
									anoMesFaturamento,
									idLocalidade,
									idCategoria,
									ImpostoTipo.COFINS,
									DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

					BigDecimal valorCOFINSSituacaoRetificada = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImpostoReferenciaContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.COFINS,
									DebitoCreditoSituacao.RETIFICADA,
									DebitoCreditoSituacao.RETIFICADA);

					BigDecimal diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada = valorCOFINSSituacaoCanceladaPorRetificacao.subtract(valorCOFINSSituacaoRetificada);

					BigDecimal totalCOFINSSituacaoCanceladaDiferencaPositiva = BigDecimal.ZERO;

					/*
					 * Acumula, quando positiva, a diferença entre o valor do
					 * imposto de renda com tipo de imposto igual a COFINS e
					 * situação atual da conta igual a cancelada por retificação
					 * e o valor do imposto de renda com situação atual ou
					 * anterior da conta igual a retificada.
					 */
					if (diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1) {
						totalCOFINSSituacaoCanceladaDiferencaPositiva = valorCOFINSSituacaoCancelada.add(diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada);
					}

					// caso o valor total do COFINS seja diferente de zero
					if (totalCOFINSSituacaoCanceladaDiferencaPositiva.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								totalCOFINSSituacaoCanceladaDiferencaPositiva,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_CANCELADOS_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.COFINS), 
								null, 
								new Short("2800"), 
								new Short("20"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 87

					// Linha 91
					BigDecimal totalCOFINSSituacaoCanceladaDiferencaNegativa = BigDecimal.ZERO;

					/*
					 * Acumula, quando negativa, a diferença entre o valor do
					 * imposto de renda com tipo de imposto igual a COFINS e
					 * situação atual da conta igual a cancelada por retificação
					 * e o valor do imposto de renda com situação atual ou
					 * anterior da conta igual a retificada.
					 */
					if (diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1) {
						totalCOFINSSituacaoCanceladaDiferencaNegativa = valorCOFINSSituacaoCancelada.add(
								diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada.multiply(menosUm));
					}

					// caso o valor total do COFINS seja diferente de zero
					if (totalCOFINSSituacaoCanceladaDiferencaNegativa.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								totalCOFINSSituacaoCanceladaDiferencaNegativa,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_INCLUIDOS_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.COFINS), 
								null, 
								new Short("2900"), 
								new Short("20"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 91

					// Linha 88
					BigDecimal valorCSLLSituacaoCancelada = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImposto(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.CSLL,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal valorCSLLSituacaoCanceladaPorRetificacao = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImposto(
									anoMesFaturamento,
									idLocalidade,
									idCategoria,
									ImpostoTipo.CSLL,
									DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

					BigDecimal valorCSLLSituacaoRetificada = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImpostoReferenciaContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.CSLL,
									DebitoCreditoSituacao.RETIFICADA,
									DebitoCreditoSituacao.RETIFICADA);

					BigDecimal diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada = valorCSLLSituacaoCanceladaPorRetificacao
							.subtract(valorCSLLSituacaoRetificada);

					BigDecimal totalCSLLSituacaoCanceladaDiferencaPositiva = BigDecimal.ZERO;

					if (diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada
							.compareTo(BigDecimal.ZERO) != -1) {
						totalCSLLSituacaoCanceladaDiferencaPositiva = valorCSLLSituacaoCancelada
								.add(diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada);
					}

					if (totalCSLLSituacaoCanceladaDiferencaPositiva.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								totalCSLLSituacaoCanceladaDiferencaPositiva,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_CANCELADOS_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.CSLL), 
								null, 
								new Short("2800"), 
								new Short("30"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 88

					// Linha 92
					BigDecimal totalCSLLSituacaoCanceladaDiferencaNegativa = BigDecimal.ZERO;

					/*
					 * Acumula, quando negativa, a diferença entre o valor do
					 * imposto de renda com tipo de imposto igual a CSLL e
					 * situação atual da conta igual a cancelada por retificação
					 * e o valor do imposto de renda com situação atual ou
					 * anterior da conta igual a retificada.
					 */
					if (diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1) {
						totalCSLLSituacaoCanceladaDiferencaNegativa = valorCSLLSituacaoCancelada
								.add(diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada
										.multiply(menosUm));
					}

					// caso o valor total do CSLL seja diferente de zero
					if (totalCSLLSituacaoCanceladaDiferencaNegativa.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								totalCSLLSituacaoCanceladaDiferencaNegativa,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_INCLUIDOS_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.CSLL), 
								null, 
								new Short("2900"), 
								new Short("30"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 92

					// Linha 89
					BigDecimal valorPIS_PASEPSituacaoCancelada = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImposto(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.PIS_PASEP,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal valorPIS_PASEPSituacaoCanceladaPorRetificacao = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImposto(
									anoMesFaturamento,
									idLocalidade,
									idCategoria,
									ImpostoTipo.PIS_PASEP,
									DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

					BigDecimal valorPIS_PASEPSituacaoRetificada = repositorioFaturamento
							.acumularValorContaCategoriaPorTipoImpostoReferenciaContabil(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.PIS_PASEP,
									DebitoCreditoSituacao.RETIFICADA,
									DebitoCreditoSituacao.RETIFICADA);

					BigDecimal diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada = valorPIS_PASEPSituacaoCanceladaPorRetificacao
							.subtract(valorPIS_PASEPSituacaoRetificada);

					BigDecimal totalPIS_PASEPSituacaoCanceladaDiferencaPositiva = BigDecimal.ZERO;

					if (diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1) {
						totalPIS_PASEPSituacaoCanceladaDiferencaPositiva = valorPIS_PASEPSituacaoCancelada
								.add(diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada);
					}

					if (totalPIS_PASEPSituacaoCanceladaDiferencaPositiva.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								totalPIS_PASEPSituacaoCanceladaDiferencaPositiva,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_CANCELADOS_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.PIS_PASEP), 
								null, 
								new Short("2800"), 
								new Short("40"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 89

					// Linha 93
					BigDecimal totalPIS_PASEPSituacaoCanceladaDiferencaNegativa = BigDecimal.ZERO;

					if (diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1) {
						totalPIS_PASEPSituacaoCanceladaDiferencaNegativa = valorPIS_PASEPSituacaoCancelada
								.add(diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada
										.multiply(menosUm));
					}

					if (totalPIS_PASEPSituacaoCanceladaDiferencaNegativa.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								totalPIS_PASEPSituacaoCanceladaDiferencaNegativa,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_INCLUIDOS_REFATURAMENTO),
								new LancamentoItem(LancamentoItem.PIS_PASEP), 
								null, 
								new Short("2900"), 
								new Short("40"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 93

					// Linha 94
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO;

					BigDecimal valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal[] diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada = this
							.obterDiferencaValoresCreditosRealizadosContaRetificadaDuplicidade(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem);

					BigDecimal[] diferencaCreditoOrigemDuplicidadeAte201212CanceladaPorRetificacaoeERetificada = this
							.obterDiferencaValoresCreditosRealizadosContaRetificadaDuplicidadeAte201212(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem);

					valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso = valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso
							.add(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada[0]);
					valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso = valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso
							.add(diferencaCreditoOrigemDuplicidadeAte201212CanceladaPorRetificacaoeERetificada[0]);

					if (valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO), 
								null, new Short("3000"), new Short("10"));
								
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 94
					
					// Linha 95
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO;

					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal[] diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada = this
							.obterDiferencaValoresCreditosRealizadosContaRetificada(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem);

					valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento = valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento
							.add(diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada[0]);

					if (valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO), 
								null, new Short("3000"), new Short("20"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 95
					
					// Linha 96
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONDICIONAIS;

					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosCondicionais = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal[] diferencaCreditoOrigemDescontosCondicionaisCanceladaPorRetificacaoeERetificada = this
							.obterDiferencaValoresCreditosRealizadosContaRetificada(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem);

					valorCreditoRealizadoOrigemCreditoDescontosCondicionais = valorCreditoRealizadoOrigemCreditoDescontosCondicionais
							.add(diferencaCreditoOrigemDescontosCondicionaisCanceladaPorRetificacaoeERetificada[0]);

					if (valorCreditoRealizadoOrigemCreditoDescontosCondicionais.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoDescontosCondicionais, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.DESCONTOS_CONDICIONAIS), 
								null, new Short("3000"), new Short("30"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 96
					
					// Linha 97
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA;

					BigDecimal valorCreditoRealizadoOrigemCreditoAjustesParaZerarConta = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal[] diferencaCreditoOrigemAjustesParaZerarContaCanceladaPorRetificacaoeERetificada = this
							.obterDiferencaValoresCreditosRealizadosContaRetificada(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem);

					valorCreditoRealizadoOrigemCreditoAjustesParaZerarConta = valorCreditoRealizadoOrigemCreditoDescontosCondicionais
							.add(diferencaCreditoOrigemAjustesParaZerarContaCanceladaPorRetificacaoeERetificada[0]);

					if (valorCreditoRealizadoOrigemCreditoAjustesParaZerarConta.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoAjustesParaZerarConta, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA), 
								null, new Short("3000"), new Short("40"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 97
					
					// Linha xx
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA;

					BigDecimal valorCredito = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,idCategoria, idsCreditosOrigem,DebitoCreditoSituacao.CANCELADA);

					BigDecimal[] diferencaCreditoOrigemDescontosParcelamentoFaixaContaCanceladaPorRetificacaoeERetificada = this.obterDiferencaValoresCreditosRealizadosContaRetificada(anoMesFaturamento, idLocalidade,idCategoria, idsCreditosOrigem);
					
					valorCredito = valorCredito.add(diferencaCreditoOrigemDescontosParcelamentoFaixaContaCanceladaPorRetificacaoeERetificada[0]);

					if (valorCredito.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCredito, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA), 
								null, new Short("3000"), new Short("50"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha xx

					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_CURTO_PRAZO;

					BigDecimal valorCreditosRealizadosCreditosAnterioresCurtoPrazo = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,idCategoria, idsCreditosOrigem,DebitoCreditoSituacao.CANCELADA);

					BigDecimal[] diferencaRetificacaoCreditosRealizadosCreditosAnterioresCurtoPrazo = this.obterDiferencaValoresCreditosRealizadosContaRetificada(
										anoMesFaturamento, idLocalidade,idCategoria, idsCreditosOrigem);

					valorCreditosRealizadosCreditosAnterioresCurtoPrazo = valorCreditosRealizadosCreditosAnterioresCurtoPrazo.add(diferencaRetificacaoCreditosRealizadosCreditosAnterioresCurtoPrazo[0]);

					
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_LONGO_PRAZO;

					BigDecimal valorCreditosRealizadosCreditosAnterioresLongoPrazo = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,idCategoria, idsCreditosOrigem,DebitoCreditoSituacao.CANCELADA);

					BigDecimal[] diferencaRetificacaoCreditosRealizadosCreditosAnterioresLongoPrazo = this.obterDiferencaValoresCreditosRealizadosContaRetificada(
										anoMesFaturamento, idLocalidade,idCategoria, idsCreditosOrigem);

					valorCreditosRealizadosCreditosAnterioresLongoPrazo = valorCreditosRealizadosCreditosAnterioresLongoPrazo.add(diferencaRetificacaoCreditosRealizadosCreditosAnterioresLongoPrazo[0]);

					BigDecimal valorCreditosAnteriores = valorCreditosRealizadosCreditosAnterioresCurtoPrazo.add(valorCreditosRealizadosCreditosAnterioresLongoPrazo);
					
					if (valorCreditosAnteriores.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditosAnteriores, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.DESCONTOS_CREDITOS_ANTERIORES), 
								null, new Short("3000"), new Short("60"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					
					// Linha 98
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO;

					BigDecimal valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoDuplicidade(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.INCLUIDA);

					valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida = valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida
							.add(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada[1]);

					if (valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida
							.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO), 
								null, new Short("3100"), new Short("10"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}


					BigDecimal valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeAte122012SituacaoIncluida = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoDuplicidadeAte201212(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.INCLUIDA);

					valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeAte122012SituacaoIncluida = valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeAte122012SituacaoIncluida
							.add(diferencaCreditoOrigemDuplicidadeAte201212CanceladaPorRetificacaoeERetificada[1]);

					if (valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeAte122012SituacaoIncluida.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeAte122012SituacaoIncluida, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO_ATE_31_12_2012), 
								new LancamentoItem(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO), 
								null, new Short("3105"), new Short("10"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 98
					
					// Linha 99
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO;

					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.INCLUIDA);

					valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida = valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida
							.add(diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada[1]);

					if (valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO), 
								null, new Short("3100"), new Short("20"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 99
					
					// Linha 100
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONDICIONAIS;

					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.INCLUIDA);

					valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida = valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida
							.add(diferencaCreditoOrigemDescontosCondicionaisCanceladaPorRetificacaoeERetificada[0]);

					if (valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.DESCONTOS_CONDICIONAIS), 
								null, new Short("3100"), new Short("30"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 100
					
					// Linha 101
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA;

					BigDecimal valorCreditoRealizadoOrigemCreditoAjustesParaZerarContaSituacaoIncluida = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.INCLUIDA);

					valorCreditoRealizadoOrigemCreditoAjustesParaZerarContaSituacaoIncluida = valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida
							.add(diferencaCreditoOrigemAjustesParaZerarContaCanceladaPorRetificacaoeERetificada[0]);

					if (valorCreditoRealizadoOrigemCreditoAjustesParaZerarContaSituacaoIncluida
							.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorCreditoRealizadoOrigemCreditoAjustesParaZerarContaSituacaoIncluida, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA), 
								null, new Short("3100"), new Short("40"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 101

					// Linha yy
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA;

					BigDecimal valorDescontosFaixaContaContaIncluida = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.INCLUIDA);

					valorDescontosFaixaContaContaIncluida = valorDescontosFaixaContaContaIncluida
							.add(diferencaCreditoOrigemDescontosParcelamentoFaixaContaCanceladaPorRetificacaoeERetificada[1]);

					if (valorDescontosFaixaContaContaIncluida.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumo = buildResumoFaturamento(valorDescontosFaixaContaContaIncluida, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA), 
								null, new Short("3100"), new Short("50"));
						colecaoResumoFaturamento.add(resumo);
					} 
					// fim Linha yy
					
					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_CURTO_PRAZO;

					BigDecimal valorCreditosRealizadosRefaturamentoCreditosAnterioresCurtoPrazo = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,idCategoria, idsCreditosOrigem,DebitoCreditoSituacao.INCLUIDA);

					valorCreditosRealizadosRefaturamentoCreditosAnterioresCurtoPrazo = valorCreditosRealizadosRefaturamentoCreditosAnterioresCurtoPrazo
							.add(diferencaRetificacaoCreditosRealizadosCreditosAnterioresCurtoPrazo[1]);

					
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_LONGO_PRAZO;

					BigDecimal valorCreditosRealizadosRefaturamentoCreditosAnterioresLongoPrazo = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamento, idLocalidade,idCategoria, idsCreditosOrigem,DebitoCreditoSituacao.INCLUIDA);

					valorCreditosRealizadosRefaturamentoCreditosAnterioresLongoPrazo = valorCreditosRealizadosRefaturamentoCreditosAnterioresLongoPrazo
							.add(diferencaRetificacaoCreditosRealizadosCreditosAnterioresLongoPrazo[1]);

					BigDecimal valorOutrosCreditosConcedidosCreditosAnteriores = valorCreditosRealizadosRefaturamentoCreditosAnterioresCurtoPrazo
							.add(valorCreditosRealizadosRefaturamentoCreditosAnterioresLongoPrazo);

					if (valorOutrosCreditosConcedidosCreditosAnteriores.compareTo(BigDecimal.ZERO) != 0) {

						resumoFaturamentoTemporario = buildResumoFaturamento(valorOutrosCreditosConcedidosCreditosAnteriores, 
								anoMesFaturamento, categoria, localidade, 
								new LancamentoTipo(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO), 
								new LancamentoItem(LancamentoItem.DESCONTOS_CREDITOS_ANTERIORES), 
								null, new Short("3100"), new Short("20"));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					
					BigDecimal valorParcelamentoConcedidoBonus = this.obterValorParcelamentoConcedidoBonus(idLocalidade,idCategoria);

					if (valorParcelamentoConcedidoBonus.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorParcelamentoConcedidoBonus,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.BONUS_CONCEDIDOS_PARCELAMENTO),
								new LancamentoItem(LancamentoItem.BONUS_CONCEDIDOS_PARCELAMENTO), 
								null, 
								new Short("3200"), 
								new Short("0"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					// Linha 102
					idsSituacaoAtual = null;
					idsSituacaoAtual = new Integer[2];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.CANCELADA;
					idsSituacaoAtual[1] = DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO;

					arrayValoresAguaEsgoto = null;
					arrayValoresAguaEsgoto = repositorioFaturamento
							.acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsSituacaoAtual);

					valorAgua = (BigDecimal) arrayValoresAguaEsgoto[indiceValorAgua];
					valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[indiceValorEsgoto];

					if (valorAgua == null) {
						valorAgua = BigDecimal.ZERO;
					}

					if (valorEsgoto == null) {
						valorEsgoto = BigDecimal.ZERO;
					}

					idsSituacaoAtual = null;
					idsSituacaoAtual = new Integer[2];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.CANCELADA;
					idsSituacaoAtual[1] = DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO;

					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsSituacaoAtual);

					// adiciona o valor de água e esgoto ao valor do débito cobrado
					valorItemFaturamento = valorItemFaturamento.add(valorAgua)
							.add(valorEsgoto);

					// caso o valor do item seja diferente de zero
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.EXCLUSAO_INADIMPLENCIA_RECUPERADA),
								new LancamentoItem(LancamentoItem.POR_REFATURAMENTO), 
								null, 
								new Short("3300"), 
								new Short("10"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 102

					// Linha 103
					idsSituacaoAtual = null;
					idsSituacaoAtual = new Integer[1];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.PARCELADA;

					arrayValoresAguaEsgoto = repositorioFaturamento
							.acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsSituacaoAtual);

					valorAgua = (BigDecimal) arrayValoresAguaEsgoto[indiceValorAgua];
					valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[indiceValorEsgoto];

					if (valorAgua == null) {
						valorAgua = BigDecimal.ZERO;
					}

					if (valorEsgoto == null) {
						valorEsgoto = BigDecimal.ZERO;
					}

					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsSituacaoAtual);

					// adiciona o valor de água e esgoto ao do débito cobrado
					valorItemFaturamento = valorItemFaturamento.add(valorAgua).add(valorEsgoto);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.EXCLUSAO_INADIMPLENCIA_RECUPERADA),
								new LancamentoItem(LancamentoItem.POR_PARCELAMENTO), 
								null, 
								new Short("3300"), 
								new Short("20"));
						
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 103

					// Linha 104 e 105
					idsSituacaoAtual = null;
					idsSituacaoAtual = new Integer[2];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.DEBITO_PRESCRITO;
					idsSituacaoAtual[1] = DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS;

					arrayValoresAguaEsgoto = repositorioFaturamento
							.acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsSituacaoAtual);

					valorAgua = (BigDecimal) arrayValoresAguaEsgoto[indiceValorAgua];
					valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[indiceValorEsgoto];

					if (valorAgua == null) {
						valorAgua = BigDecimal.ZERO;
					}

					if (valorEsgoto == null) {
						valorEsgoto = BigDecimal.ZERO;
					}

					if (valorAgua.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorAgua,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.AGUA), 
								null, 
								new Short("3400"), 
								new Short("10"));
						
						// acumula o valor do sequencial 3400 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					if (valorEsgoto.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorEsgoto,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.ESGOTO), 
								null, 
								new Short("3400"), 
								new Short("20"));
						
						// acumula o valor do sequencial 3400 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 104 e 105

					// Linha 120 e 121
					idsSituacaoAtual = null;
					idsSituacaoAtual = new Integer[2];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.DEBITO_PRESCRITO;
					idsSituacaoAtual[1] = DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS;

					arrayValoresAguaEsgoto = repositorioFaturamento
							.acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilNaoPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, idsSituacaoAtual);

					valorAgua = (BigDecimal) arrayValoresAguaEsgoto[indiceValorAgua];
					valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[indiceValorEsgoto];

					if (valorAgua == null) {
						valorAgua = BigDecimal.ZERO;
					}

					if (valorEsgoto == null) {
						valorEsgoto = BigDecimal.ZERO;
					}

					if (valorAgua.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorAgua,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.AGUA), 
								null, 
								new Short("3800"), 
								new Short("10"));
						
						// acumula o valor do sequencial 3800 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					if (valorEsgoto.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorEsgoto,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.ESGOTO), 
								null, 
								new Short("3800"), 
								new Short("20"));
						
						// acumula o valor do sequencial 3800 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 120 e 121

					// Linha 107
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_AGUA,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.AGUA), 
								null, 
								new Short("3500"), 
								new Short("10"));
						
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 107
					
					// Linha 108
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_ESGOTO,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.ESGOTO), 
								null, 
								new Short("3500"), 
								new Short("20"));
						
						// acumula o valor do sequencial 3500 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 108

					// Linha 110
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.JUROS_PARCELAMENTO,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.JUROS), 
								null, 
								new Short("3500"), 
								maxSequencialImpressaoMais10);
						
						// acumula o valor do sequencial 3500 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 110
					
					// Linha 111
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA,
							LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO,
							new Short("3600"), new Short("10"));

					if (resumoFaturamentoTemporario != null) {
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
								.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA,
							LancamentoItem.DESCONTOS_CONCEDIDOS,
							new Short("3600"), (short) (maxSequencialImpressaoMais10 + 30));

					if (resumoFaturamentoTemporario != null) {
					
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 111
					
					// Linha 113
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.DESCONTOS_CONDICIONAIS,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA,
							LancamentoItem.DESCONTOS_CONDICIONAIS,
							new Short("3600"), (short) (maxSequencialImpressaoMais10));

					if (resumoFaturamentoTemporario != null) {
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 113
					
					// Linha 114
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.DESCONTOS_INCONDICIONAIS,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA,
							LancamentoItem.DESCONTOS_INCONDICIONAIS,
							new Short("3600"), (short) (maxSequencialImpressaoMais10 + 10));

					if (resumoFaturamentoTemporario != null) {
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 114
					
					// Linha 115
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA,
							LancamentoItem.AJUSTES_PARA_ZERAR_CONTA,
							new Short("3600"), (short) (maxSequencialImpressaoMais10 + 20));

					if (resumoFaturamentoTemporario != null) {
						
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 115

					// Linha zzz
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA,
							LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA,
							new Short("3600"), (short) (maxSequencialImpressaoMais10 + 40));

					if (resumoFaturamentoTemporario != null) {
						
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha zzz

					
					// Linha 116
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.IR,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.IMPOSTO_RENDA), 
								null, 
								new Short("3700"), 
								new Short("10"));
						
						// subtrai o valor do sequencial 3700 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);

					}
					// fim Linha 116

					// Linha 117
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.COFINS,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.COFINS), 
								null, 
								new Short("3700"), 
								new Short("20"));
						
						// subtrai o valor do sequencial 3700 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 117
					
					// Linha 118
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.CSLL,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.CSLL), 
								null, 
								new Short("3700"), 
								new Short("30"));
						
						// subtrai o valor do sequencial 3700 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);

					}
					// fim Linha 118

					// Linha 119
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.PIS_PASEP,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.PIS_PASEP), 
								null, 
								new Short("3700"), 
								new Short("40"));
						
						// subtrai o valor do sequencial 3700 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 119

					// Linha 123
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_AGUA,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.AGUA), 
								null, 
								new Short("3900"), 
								new Short("10"));
						
						// acumula o valor do sequencial 3900 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 123

					// Linha 124
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.PARCELAMENTO_ESGOTO,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					// caso o valor do item seja diferente de zero
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.ESGOTO), 
								null, 
								new Short("3900"), 
								new Short("20"));
						
						// acumula o valor do sequencial 3900 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 124

					// Linha 126
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria,
									FinanciamentoTipo.JUROS_PARCELAMENTO,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					// caso o valor do item seja diferente de zero
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.ESGOTO), 
								null, 
								new Short("3900"), 
								maxSequencialImpressaoMais10);
						
						// acumula o valor do sequencial 3900 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 126

					// Linha 127
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA,
							LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO,
							new Short("4000"), new Short("10"));

					if (resumoFaturamentoTemporario != null) {
						
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					idsCreditosOrigem = null;
					idsCreditosOrigem = new Integer[3];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO;
					idsCreditosOrigem[1] = CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_CURTO_PRAZO;
					idsCreditosOrigem[2] = CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_LONGO_PRAZO;
					
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigensCreditoComBaixaContabilNaoPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							idsCreditosOrigem,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA,
							LancamentoItem.DESCONTOS_CONCEDIDOS,
							new Short("4000"), (short) (maxSequencialImpressaoMais10 + 30));

					if (resumoFaturamentoTemporario != null) {
						
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 127

					// Linha 129
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.DESCONTOS_CONDICIONAIS,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA,
							LancamentoItem.DESCONTOS_CONDICIONAIS,
							new Short("4000"), (short) (maxSequencialImpressaoMais10));

					if (resumoFaturamentoTemporario != null) {

						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 129
					
					// Linha 130
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.DESCONTOS_INCONDICIONAIS,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA,
							LancamentoItem.DESCONTOS_INCONDICIONAIS,
							new Short("4000"), (short) (maxSequencialImpressaoMais10 + 10));

					if (resumoFaturamentoTemporario != null) {

						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 130

					// Linha 131
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA,
							LancamentoItem.AJUSTES_PARA_ZERAR_CONTA,
							new Short("4000"), (short) (maxSequencialImpressaoMais10 + 20));

					if (resumoFaturamentoTemporario != null) {

						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 131
					
					// Linha aaa
					resumoFaturamentoTemporario = obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
							anoMesFaturamento,
							localidade,
							categoria,
							CreditoOrigem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA,
							DebitoCreditoSituacao.DEBITO_PRESCRITO,
							LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA,
							LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA,
							new Short("4000"), (short) (maxSequencialImpressaoMais10 + 40));

					if (resumoFaturamentoTemporario != null) {

						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(resumoTotalDebitosCanceladosPrescricao
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha aaa
					
					// Linha 132
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.IR,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					// caso o valor do item seja diferente de zero
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.IMPOSTO_RENDA), 
								null, 
								new Short("4100"), 
								new Short("10"));
						
						// subtrai o valor do sequencial 4100 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 132

					// Linha 133
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.COFINS,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					// caso o valor do item seja diferente de zero
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.COFINS), 
								null, 
								new Short("4100"), 
								new Short("20"));
						
						// subtrai o valor do sequencial 4100 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 133
					
					// Linha 134
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.CSLL,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					// caso o valor do item seja diferente de zero
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.CSLL), 
								null, 
								new Short("4100"), 
								new Short("30"));
						
						// subtrai o valor do sequencial 4100 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);

					}
					// fim Linha 134

					// Linha 135
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
									anoMesFaturamento, idLocalidade,
									idCategoria, ImpostoTipo.PIS_PASEP,
									DebitoCreditoSituacao.DEBITO_PRESCRITO);

					// caso o valor do item seja diferente de zero
					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA),
								new LancamentoItem(LancamentoItem.PIS_PASEP), 
								null, 
								new Short("4100"), 
								new Short("40"));
						
						// subtrai o valor do sequencial 4100 ao total de débitos cancelados por prescrição
						resumoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(
								resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 135
					
					// Linha 13
					idsCreditosOrigem = null;
					idsCreditosOrigem = obterIdsCreditosOrigemParaEncerramentoFaturamentoMensal();

					colecaoTemporariaCreditoARealizar = null;

					colecaoTemporariaCreditoARealizar = repositorioFaturamento
							.acumularValorCreditoARealizarPorOrigemCredito(
									anoMesFaturamento, localidade.getId(),
									idsCreditosOrigem,
									DebitoCreditoSituacao.CANCELADA, categoria);

					for (Object[] arrayDadosCreditoARealizar : colecaoTemporariaCreditoARealizar) {

						BigDecimal valor = (BigDecimal) arrayDadosCreditoARealizar[0];
						Integer idLancamentoItemContabil = (Integer) arrayDadosCreditoARealizar[2];
						Short sequenciaImpressao = (Short) arrayDadosCreditoARealizar[1];

						if (valor != null && valor.compareTo(BigDecimal.ZERO) != 0) {

							ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
									valor,
									anoMesFaturamento,
									categoria,
									localidade,
									new LancamentoTipo(LancamentoTipo.CREDITOS_A_REALIZAR_POR_COBRANCA_INDEVIDA_CONCELADO),
									new LancamentoItem(LancamentoItem.GRUPO_CONTABIL), 
									new LancamentoItemContabil(idLancamentoItemContabil), 
									new Short("540"), 
									sequenciaImpressao);
							
							// adiciona o valor do sequencial 540 a receitambruta
							resumoFaturamentoReceitaBruta.setValorItemFaturamento(
									resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
					}
					// fim Linha 13
					
					// Linha 14
					valorItemFaturamento = null;
					valorItemFaturamento = repositorioFaturamento
							.acumularValorCreditoARealizarPorOrigemCredito(
									anoMesFaturamento, localidade.getId(),
									CreditoOrigem.DESCONTOS_INCONDICIONAIS,
									DebitoCreditoSituacao.CANCELADA, categoria);

					if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
						ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
								valorItemFaturamento,
								anoMesFaturamento,
								categoria,
								localidade,
								new LancamentoTipo(LancamentoTipo.DESCONTOS_INCONDICIONAIS_A_REALIZAR_CANCELADOS),
								new LancamentoItem(LancamentoItem.DESCONTOS_INCONDICIONAIS_CANCELADOS), 
								null, 
								new Short("550"), 
								new Short("0"));

						// adiciona o valor do sequencial 550 a receita bruta
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(
								resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}

					idsCreditosOrigem = obterIdsCreditosOrigemParaEncerramentoFaturamentoMensal();
					colecaoTemporariaCreditoARealizar = repositorioFaturamento
							.acumularValorCreditoARealizarPorOrigemCredito(
									anoMesFaturamento, localidade.getId(),
									idsCreditosOrigem,
									DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, categoria);

					for (Object[] arrayDadosCreditoARealizar : colecaoTemporariaCreditoARealizar) {
						BigDecimal valor = (BigDecimal) arrayDadosCreditoARealizar[0];
						Integer idLancamentoItemContabil = (Integer) arrayDadosCreditoARealizar[2];
						Short sequenciaImpressao = (Short) arrayDadosCreditoARealizar[1];

						if (valor != null&& valor.compareTo(BigDecimal.ZERO) != 0) {
							resumoFaturamentoTemporario = buildResumoFaturamento(
									valor, 
									anoMesFaturamento, 
									categoria,
									localidade, 
									new LancamentoTipo(LancamentoTipo.CREDITOS_A_REALIZAR_POR_COBRANCA_INDEVIDA_INCLUIDOS), 
									new LancamentoItem(LancamentoItem.GRUPO_CONTABIL),
									new LancamentoItemContabil(idLancamentoItemContabil), 
									new Short("1030"),
									sequenciaImpressao);

							resumoFaturamentoReceitaCancelada.setValorItemFaturamento(
									resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}
					}

					resumoFaturamentoTemporario = this
							.contabilizarCreditosRealizadosCanceladosRecuperacaoCredito(
									anoMesFaturamento,
									localidade,
									categoria,
									CreditoOrigem.RECUPERACAO_CREDITO_CONTA_CANCELADA,
									LancamentoItem.RECUPERACAO_CREDITO_CONTA_CANCELADA);

					if (resumoFaturamentoTemporario != null) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					resumoFaturamentoTemporario = this
							.contabilizarCreditosRealizadosCanceladosRecuperacaoCredito(
									anoMesFaturamento,
									localidade,
									categoria,
									CreditoOrigem.RECUPERACAO_CREDITO_CONTA_PARCELADA,
									LancamentoItem.RECUPERACAO_CREDITO_CONTA_PARCELADA);

					if (resumoFaturamentoTemporario != null) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					resumoFaturamentoTemporario = this
							.contabilizarCreditosRealizadosRecuperacaoDeCredito(
									anoMesFaturamento,
									localidade,
									categoria,
									CreditoOrigem.RECUPERACAO_CREDITO_CONTA_CANCELADA,
									LancamentoItem.RECUPERACAO_CREDITO_CONTA_CANCELADA);

					if (resumoFaturamentoTemporario != null) {
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));
						
						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					resumoFaturamentoTemporario = this.contabilizarCreditosRealizadosRecuperacaoDeCredito(
											anoMesFaturamento,
											localidade,
											categoria,
											CreditoOrigem.RECUPERACAO_CREDITO_CONTA_PARCELADA,
											LancamentoItem.RECUPERACAO_CREDITO_CONTA_PARCELADA);

					if (resumoFaturamentoTemporario != null) {
						resumoTotalCobradoNasContas.setValorItemFaturamento(
								resumoTotalCobradoNasContas.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));
						
						resumoValoresDevolvidosNasContas.setValorItemFaturamento(
								resumoValoresDevolvidosNasContas.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					colecaoResumoFaturamento.addAll(this.contabilizarCreditosARealizarRecuperacaoDeCredito(
													anoMesFaturamento,
													localidade,
													categoria,
													CreditoOrigem.RECUPERACAO_CREDITO_CONTA_CANCELADA,
													LancamentoItem.RECUPERACAO_CREDITO_CONTA_CANCELADA));

					colecaoResumoFaturamento
							.addAll(this
									.contabilizarCreditosARealizarRecuperacaoDeCredito(
											anoMesFaturamento,
											localidade,
											categoria,
											CreditoOrigem.RECUPERACAO_CREDITO_CONTA_PARCELADA,
											LancamentoItem.RECUPERACAO_CREDITO_CONTA_PARCELADA));

					// LANCAMENTO TIPO: DESCONTOS_INCONDICIONAIS_INCLUIDOS - ITEM 1040
					resumoFaturamentoTemporario = obterResumoValorCreditoARealizarPorOrigemCreditoSituacoesConta(
							anoMesFaturamento, localidade, categoria,
							CreditoOrigem.DESCONTOS_INCONDICIONAIS,
							DebitoCreditoSituacao.NORMAL,
							DebitoCreditoSituacao.NORMAL,
							LancamentoTipo.DESCONTOS_INCONDICIONAIS_INCLUIDOS,
							LancamentoItem.DESCONTOS_INCONDICIONAIS_INCLUIDOS,
							new Short("1040"), new Short("0"));

					if (resumoFaturamentoTemporario != null) {
						resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(resumoFaturamentoReceitaCancelada,resumoFaturamentoTemporario.getValorItemFaturamento());
						
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					if (mapAcumularValorPorCategoriaReceitaBruta.containsKey(categoria.getId())) {
						resumoFaturamentoReceitaBruta = this.acumularValorResumoFaturamento(
								resumoFaturamentoReceitaBruta,mapAcumularValorPorCategoriaReceitaBruta.get(categoria.getId()));
					}

					if (resumoFaturamentoReceitaBruta.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoReceitaBruta);
					}

					if (mapAcumularValorPorCategoriaReceitaCancelada.containsKey(categoria.getId())) {
						resumoFaturamentoReceitaCancelada = this.acumularValorResumoFaturamento(
								resumoFaturamentoReceitaCancelada,mapAcumularValorPorCategoriaReceitaCancelada.get(categoria.getId()));
					}

					if (resumoFaturamentoReceitaCancelada.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoFaturamentoReceitaCancelada);
					}

					if (resumoValoresDevolvidosNasContas.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoValoresDevolvidosNasContas);
					}

					if (resumoTotalCobradoNasContas.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoTotalCobradoNasContas);
					}

					if (resumoTotalDebitosCanceladosPrescricao.getValorItemFaturamento().compareTo(BigDecimal.ZERO) != 0) {
						colecaoResumoFaturamento.add(resumoTotalDebitosCanceladosPrescricao);
					}

					// LANCAMENTO TIPO: PARCELAMENTOS_REALIZADOS_CURTO_PRAZO - ITEM 1500
					resumoFaturamentoTemporario = obterResumoDebitoACobrarCategoriaPorTipoFinanciamento(anoMesFaturamento, localidade, categoria);
					if (resumoFaturamentoTemporario != null) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					// LANCAMENTO TIPO: OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS - ITEM 1610
					Collection resumosCreditosIncluidos = this.obterResumosOutrosCreditosARealizarIncluidos(anoMesFaturamento, localidade, categoria);
					if (resumosCreditosIncluidos != null && !resumosCreditosIncluidos.isEmpty()) {
						colecaoResumoFaturamento.addAll(resumosCreditosIncluidos);
					}
					
					// LANCAMENTO TIPO: OUTROS_CREDITOS_A_REALIZAR_CANCELADOS - ITEM 1620
					Collection resumosCreditosCancelados = this.obterResumosOutrosCreditosARealizarCancelados(anoMesFaturamento, localidade, categoria);
					if (resumosCreditosCancelados != null && !resumosCreditosCancelados.isEmpty()) {
						colecaoResumoFaturamento.addAll(resumosCreditosCancelados);
					}
					
					// LANCAMENTO TIPO: OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS_ATE_31_12_2012 - ITEM 1615
					resumoFaturamentoTemporario = obterResumoCreditoARealizarPorOrigemCreditoDuplicidadeAte122012(anoMesFaturamento, localidade, categoria);
					if (resumoFaturamentoTemporario != null) {
						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
				}

				//for 
				Iterator itt = colecaoResumoFaturamento.iterator();
				
				while (itt.hasNext()) {
					ResumoFaturamento resumo = (ResumoFaturamento) itt.next();
					
					if (resumo.getLocalidade() == null) {
						System.out.println("idLancamentoTipo: " + resumo.getLancamentoTipo().getId());
						System.out.println("idLancamentoItem: " + resumo.getLancamentoItem().getId());
						System.out.println("seqTipoLancamento: " + resumo.getSequenciaTipoLancamento());
						System.out.println("seqItemTipoLancamento: " + resumo.getSequenciaItemTipoLancamento());
					}
				}
				if (colecaoResumoFaturamento != null && !colecaoResumoFaturamento.isEmpty()) {
					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoResumoFaturamento);
				}
			}
			
			if (lancamentosAgenciaReguladora != null && !lancamentosAgenciaReguladora.isEmpty()) {
				getControladorBatch().inserirColecaoObjetoParaBatch(lancamentosAgenciaReguladora);
			}

			this.calcularValorReceitaLiquida(anoMesFaturamento, colecaoCategorias, colecaoIdsLocalidades);
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);

		} catch (Exception e) {
			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}
	
	private Collection obterResumosOutrosCreditosARealizarIncluidos(Integer anoMesFaturamento, Localidade localidade, Categoria categoria) throws NumberFormatException, ErroRepositorioException {
		ResumoFaturamento resumo = null;
		Collection colecaoResumos = new ArrayList();

		resumo = obterResumoValorCreditoARealizarPorOrigemCreditoDuplicidade(
				anoMesFaturamento,
				localidade,
				categoria,
				CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO,
				DebitoCreditoSituacao.NORMAL,
				DebitoCreditoSituacao.NORMAL,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS,
				LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO,
				new Short("1610"), new Short("10"));

		if (resumo != null) {
			colecaoResumos.add(resumo);
		}

		resumo = obterResumoValorCreditoARealizarPorOrigemCreditoSituacoesConta(
				anoMesFaturamento,
				localidade,
				categoria,
				CreditoOrigem.DESCONTOS_CONDICIONAIS,
				DebitoCreditoSituacao.NORMAL,
				DebitoCreditoSituacao.NORMAL,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS,
				LancamentoItem.DESCONTOS_CONDICIONAIS, 
				new Short("1610"), new Short("20"));

		if (resumo != null) {
			colecaoResumos.add(resumo);
		}

		resumo = obterResumoValorCreditoARealizarPorOrigemCreditoSituacoesConta(
				anoMesFaturamento,
				localidade,
				categoria,
				CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA,
				DebitoCreditoSituacao.NORMAL,
				DebitoCreditoSituacao.NORMAL,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS,
				LancamentoItem.AJUSTES_PARA_ZERAR_CONTA, 
				new Short("1610"), new Short("30"));

		if (resumo != null) {
			colecaoResumos.add(resumo);
		}

		return colecaoResumos;
	}
	private Collection obterResumosOutrosCreditosARealizarCancelados(Integer anoMesFaturamento, Localidade localidade, Categoria categoria) throws NumberFormatException, ErroRepositorioException {
		ResumoFaturamento resumo = null;
		Collection colecaoResumos = new ArrayList();
		
		resumo = obterResumoValorCreditoARealizarPorOrigemCredito(
				anoMesFaturamento,
				localidade,
				categoria,
				CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO,
				DebitoCreditoSituacao.CANCELADA,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_CANCELADOS,
				LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO,
				new Short("1620"), new Short("10"));

		if (resumo != null) {
			colecaoResumos.add(resumo);
		}

		resumo = obterResumoValorCreditoARealizarPorOrigemCredito(
				anoMesFaturamento,
				localidade,
				categoria,
				CreditoOrigem.DESCONTOS_CONDICIONAIS,
				DebitoCreditoSituacao.CANCELADA,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_CANCELADOS,
				LancamentoItem.DESCONTOS_CONDICIONAIS, 
				new Short("1620"), new Short("20"));

		if (resumo != null) {
			colecaoResumos.add(resumo);
		}

		resumo = obterResumoValorCreditoARealizarPorOrigemCredito(
				anoMesFaturamento,
				localidade,
				categoria,
				CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA,
				DebitoCreditoSituacao.CANCELADA,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_CANCELADOS,
				LancamentoItem.AJUSTES_PARA_ZERAR_CONTA, 
				new Short("1620"), new Short("30"));

		if (resumo != null) {
			colecaoResumos.add(resumo);
		}

		resumo = obterResumoValorCreditoARealizarDescontosParcelamento(
				anoMesFaturamento,
				localidade,
				categoria,
				DebitoCreditoSituacao.CANCELADA,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_CANCELADOS,
				LancamentoItem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO,
				new Short("1620"), new Short("40"));

		if (resumo != null) {
			colecaoResumos.add(resumo);
		}
		
		resumo = obterResumoValorCreditoARealizarPorOrigemCredito(
				anoMesFaturamento,
				localidade,
				categoria,
				CreditoOrigem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA,
				DebitoCreditoSituacao.CANCELADA,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_CANCELADOS,
				LancamentoItem.DESCONTOS_CONCEDIDOS_PARCELAMENTO_FAIXA_CONTA,
				new Short("1620"), new Short("50"));

		if (resumo != null) {
			colecaoResumos.add(resumo);
		}
		
		return colecaoResumos;
	}

	private BigDecimal obterTotalIRSituacaoCanceladaDiferencaPositiva(int anoMesFaturamento, Integer idLocalidade, Integer idCategoria) throws ErroRepositorioException {
		BigDecimal totalIRSituacaoCanceladaDiferencaPositiva = BigDecimal.ZERO;
		
		BigDecimal valorIRSituacaoCancelada = obterValorIRSituacaoCancelada(anoMesFaturamento, idLocalidade, idCategoria);
		
		BigDecimal diferencaIRSituacaoCanceladaPorRetificacaoeERetificada = obterDiferencaIRSituacaoCanceladaPorRetificacaoeERetificada(anoMesFaturamento, idLocalidade, idCategoria);
		/*
		 * Acumula, quando positiva, a diferença entre o valor do imposto de renda com tipo de imposto igual a IR e situação atual
		 * da conta igual a cancelada por retificação e o valor do imposto de renda com situação atual ou anterior da conta igual a retificada.
		 */
		if (diferencaIRSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1) {
			totalIRSituacaoCanceladaDiferencaPositiva = valorIRSituacaoCancelada.add(diferencaIRSituacaoCanceladaPorRetificacaoeERetificada);
		}

		return totalIRSituacaoCanceladaDiferencaPositiva;
	}

	private BigDecimal obterValorIRSituacaoCancelada(int anoMesFaturamento, Integer idLocalidade, Integer idCategoria) throws ErroRepositorioException {
		BigDecimal valorIRSituacaoCancelada = repositorioFaturamento
				.acumularValorContaCategoriaPorTipoImposto(
						anoMesFaturamento, idLocalidade,
						idCategoria, ImpostoTipo.IR,
						DebitoCreditoSituacao.CANCELADA);
		return valorIRSituacaoCancelada;
	}
	
	private BigDecimal obterDiferencaIRSituacaoCanceladaPorRetificacaoeERetificada(int anoMesFaturamento, Integer idLocalidade, Integer idCategoria) throws ErroRepositorioException {
		BigDecimal valorIRSituacaoCanceladaPorRetificacao = repositorioFaturamento
				.acumularValorContaCategoriaPorTipoImposto(
						anoMesFaturamento,
						idLocalidade,
						idCategoria,
						ImpostoTipo.IR,
						DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

		BigDecimal valorIRSituacaoRetificada = repositorioFaturamento
				.acumularValorContaCategoriaPorTipoImpostoReferenciaContabil(
						anoMesFaturamento, idLocalidade,
						idCategoria, ImpostoTipo.IR,
						DebitoCreditoSituacao.RETIFICADA,
						DebitoCreditoSituacao.RETIFICADA);
		
		return valorIRSituacaoCanceladaPorRetificacao.subtract(valorIRSituacaoRetificada);

	}

	private Collection<ResumoFaturamento> buildLancamentosParcelamentosRealizadosCurtoLongoPrazo(Integer idCreditoOrigem, Integer anoMesFaturamento, 
			Localidade localidade, Categoria categoria, Integer idLancamentoItem, Short seqItemTipoLancamento ) 
			throws ErroRepositorioException {
		
		Object[] arrayValoresCurtoLongoPrazo = obterValorLongoECurtoPrazoCreditoARealizarPorOrigemCredito(
				idCreditoOrigem, anoMesFaturamento, localidade.getId(), categoria.getId(), DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.NORMAL);
		
		BigDecimal somaValorCurtoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[0];
		BigDecimal somaValorLongoPrazo = (BigDecimal) arrayValoresCurtoLongoPrazo[1];
		Collection<ResumoFaturamento> resumos = new ArrayList<ResumoFaturamento>();
		
		if (somaValorCurtoPrazo != null && somaValorCurtoPrazo.compareTo(BigDecimal.ZERO) != 0) {
			
			ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
					somaValorCurtoPrazo,
					anoMesFaturamento,
					categoria,
					localidade,
					new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
					new LancamentoItem(idLancamentoItem),
					new LancamentoItemContabil(null),
					new Short("1500"),
					seqItemTipoLancamento);
			
			resumos.add(resumoFaturamento);
		}
		
		
		if (somaValorLongoPrazo != null && somaValorLongoPrazo.compareTo(BigDecimal.ZERO) != 0) {
			
			ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
					somaValorLongoPrazo,
					anoMesFaturamento,
					categoria,
					localidade,
					new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO),
					new LancamentoItem(idLancamentoItem),
					new LancamentoItemContabil(null),
					new Short("1600"),
					seqItemTipoLancamento);
			
			resumos.add(resumoFaturamento);
		}
		
		return resumos;
	}
	private BigDecimal obterValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(Integer idCreditoOrigem, int anoMesFaturamento, Integer idLocalidade,
			Integer idCategoria) throws ErroRepositorioException {
		BigDecimal valorItemFaturamento;
		
		Integer[] idsCreditosOrigem = new Integer[] { idCreditoOrigem };

		valorItemFaturamento = null;
		valorItemFaturamento = repositorioFaturamento
				.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
						anoMesFaturamento, idLocalidade,
						idCategoria, idsCreditosOrigem,
						DebitoCreditoSituacao.NORMAL,
						DebitoCreditoSituacao.NORMAL);
		return valorItemFaturamento;
	}
	
	private BigDecimal obterValorCategoriaCreditoRealizadoCategoriaPorOrigensCreditoPorReferenciaConta(Integer[] idsCreditoOrigem, int anoMesFaturamento, Integer idLocalidade,
			Integer idCategoria) throws ErroRepositorioException {
		BigDecimal valorItemFaturamento;
		
		valorItemFaturamento = null;
		valorItemFaturamento = repositorioFaturamento
				.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
						anoMesFaturamento, idLocalidade,
						idCategoria, idsCreditoOrigem,
						DebitoCreditoSituacao.NORMAL,
						DebitoCreditoSituacao.NORMAL);
		return valorItemFaturamento;
	}
	

	private Object[] obterValorLongoECurtoPrazoCreditoARealizarPorOrigemCredito(Integer idCreditoOrigem, int anoMesFaturamento, Integer idLocalidade, Integer idCategoria,
			Integer idSituacaoAnterior, Integer idSituacaoAtual)
			throws ErroRepositorioException {
		Object[] arrayValoresCurtoLongoPrazo;
		
		Integer[] idsCreditosOrigem = new Integer[] { idCreditoOrigem };
		
		arrayValoresCurtoLongoPrazo = null;
		arrayValoresCurtoLongoPrazo = repositorioFaturamento
				.pesquisarValorLongoECurtoPrazoCreditoARealizarPorOrigemCredito(
						anoMesFaturamento, idLocalidade,
						idCategoria, idsCreditosOrigem,
						idSituacaoAtual, idSituacaoAnterior);
		return arrayValoresCurtoLongoPrazo;
	}
	
	private Object[] obterValorLongoECurtoPrazoCreditoARealizarConcedidosPorOrigemCredito(Integer idCreditoOrigem, int anoMesFaturamento, Integer idLocalidade, Integer idCategoria,
			Integer idSituacaoAnterior, Integer idSituacaoAtual)
			throws ErroRepositorioException {
		Object[] arrayValoresCurtoLongoPrazo;
		
		Integer[] idsCreditosOrigem = new Integer[] { idCreditoOrigem };
		
		arrayValoresCurtoLongoPrazo = null;
		arrayValoresCurtoLongoPrazo = repositorioFaturamento
				.pesquisarValorLongoECurtoPrazoCreditoARealizarConcedidoPorOrigemCredito(
						anoMesFaturamento, idLocalidade,
						idCategoria, idsCreditosOrigem,
						idSituacaoAtual, idSituacaoAnterior);
		return arrayValoresCurtoLongoPrazo;
	}

	private ResumoFaturamento contabilizarCreditosRealizadosCanceladosRecuperacaoCredito(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idCreditoOrigem, Integer idLancamentoItem)
			throws ErroRepositorioException, ControladorException {

		Integer[] idsCreditosOrigem = new Integer[] { idCreditoOrigem };
		ResumoFaturamento resumoFaturamento = null;

		BigDecimal valorCreditoRealizadoOrigemCredito = repositorioFaturamento
				.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(), idsCreditosOrigem,
						DebitoCreditoSituacao.CANCELADA);

		BigDecimal[] diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada = this
				.obterDiferencaValoresCreditosRealizadosContaRetificada(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(), idsCreditosOrigem);

		valorCreditoRealizadoOrigemCredito = valorCreditoRealizadoOrigemCredito
				.add(diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada[0]);

		if (valorCreditoRealizadoOrigemCredito.compareTo(BigDecimal.ZERO) != 0) {

			resumoFaturamento = buildResumoFaturamento(
					valorCreditoRealizadoOrigemCredito,
					anoMesFaturamento,
					categoria,
					localidade,
					new LancamentoTipo(
							LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_RECUPERACAO_CREDITO),
					new LancamentoItem(idLancamentoItem), null, null, null);
		}

		return resumoFaturamento;
	}

	private Collection contabilizarCreditosARealizarRecuperacaoDeCredito(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idCreditoOrigem, Integer idLancamentoItem)
			throws ErroRepositorioException, ControladorException {

		Collection<ResumoFaturamento> colecaoResumoFaturamento = new ArrayList<ResumoFaturamento>();

		ResumoFaturamento resumoFaturamentoTemporario = obterResumoValorCreditoARealizarPorOrigemCreditoSituacoesConta(
				anoMesFaturamento,
				localidade,
				categoria,
				idCreditoOrigem,
				DebitoCreditoSituacao.NORMAL,
				DebitoCreditoSituacao.NORMAL,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_POR_RECUPERACAO_CREDITO_INCLUIDOS,
				idLancamentoItem, null, null);

		if (resumoFaturamentoTemporario != null) {
			colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
		}

		resumoFaturamentoTemporario = obterResumoValorCreditoARealizarPorOrigemCredito(
				anoMesFaturamento,
				localidade,
				categoria,
				idCreditoOrigem,
				DebitoCreditoSituacao.CANCELADA,
				LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_POR_RECUPERACAO_CREDITO_CANCELADOS,
				idLancamentoItem, null, null);

		if (resumoFaturamentoTemporario != null) {
			colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
		}

		return colecaoResumoFaturamento;
	}

	private ResumoFaturamento contabilizarCreditosRealizadosRecuperacaoDeCredito(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idCreditoOrigem, Integer idLancamentoItem)
			throws ErroRepositorioException, ControladorException {

		ResumoFaturamento resumoFaturamento = null;

		Integer[] idsCreditosOrigem = new Integer[] { idCreditoOrigem };

		BigDecimal valorItemFaturamento = repositorioFaturamento
				.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoPorReferenciaConta(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(), idsCreditosOrigem,
						DebitoCreditoSituacao.NORMAL,
						DebitoCreditoSituacao.NORMAL);

		if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
			resumoFaturamento = buildResumoFaturamento(
					valorItemFaturamento,
					anoMesFaturamento,
					categoria,
					localidade,
					new LancamentoTipo(LancamentoTipo.DEVOLUCAO_VALORES_RECUPERACAO_CREDITO),
					new LancamentoItem(idLancamentoItem),
					new LancamentoItemContabil(LancamentoItemContabil.ACRESCIMOS_POR_IMPONTUALIDADE),
					null,
					null);
		}

		return resumoFaturamento;
	}
	
	private BigDecimal obterValorCreditosRealizadosRecuepracaoCredito(
			Integer idLancamentoTipo, Collection<ResumoFaturamento> colecaoReumo) {
		BigDecimal valorCreditos = null;

		return valorCreditos;
	}

//	private ResumoFaturamento preencherDadosLocalizacaoResumoFaturamento(Localidade localidade, Categoria categoria,ResumoFaturamento resumoFaturamento) {
//		resumoFaturamento.setGerenciaRegional(localidade.getGerenciaRegional());
//		resumoFaturamento.setUnidadeNegocio(localidade.getUnidadeNegocio());
//		resumoFaturamento.setLocalidade(localidade);
//		resumoFaturamento.setCategoria(categoria);
//
//		return resumoFaturamento;
//	}

	private ResumoFaturamento obterResumoDebitoACobrarCategoriaPorTipoFinanciamento(
			int anoMesFaturamento, Localidade localidade, Categoria categoria)
			throws ErroRepositorioException {

		Integer[] idsTipoFinanciamento = new Integer[3];
		idsTipoFinanciamento[0] = FinanciamentoTipo.ARRASTO_AGUA;
		idsTipoFinanciamento[1] = FinanciamentoTipo.ARRASTO_ESGOTO;
		idsTipoFinanciamento[2] = FinanciamentoTipo.ARRASTO_SERVICO;

		BigDecimal valorItemFaturamento = repositorioFaturamento
				.acumularValorDebitoACobrarCategoriaPorTipoFinanciamento(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(), idsTipoFinanciamento,
						DebitoCreditoSituacao.NORMAL,
						DebitoCreditoSituacao.NORMAL);

		if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
			ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
					valorItemFaturamento,
					anoMesFaturamento,
					categoria,
					localidade,
					new LancamentoTipo(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO),
					new LancamentoItem(LancamentoItem.DEBITOS_ANTERIORES_PARA_RECOBRANCA),
					null, new Short("1500"), new Short("80"));

			return resumoFaturamento;
		} else {
			return null;
		}
	}

	private ResumoFaturamento obterResumoCreditoARealizarPorOrigemCreditoDuplicidadeAte122012(
			int anoMesFaturamento, Localidade localidade, Categoria categoria)
			throws ErroRepositorioException {

		BigDecimal valorItemFaturamento = repositorioFaturamento
				.acumularValorCreditoARealizarPorOrigemCreditoDuplicidadeAte122012(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(),
						CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO,
						DebitoCreditoSituacao.NORMAL,
						DebitoCreditoSituacao.NORMAL);

		if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
			ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
					valorItemFaturamento,
					anoMesFaturamento,
					categoria,
					localidade,
					new LancamentoTipo(
							LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS_ATE_31_12_2012),
					new LancamentoItem(
							LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO),
					null, new Short("1615"), new Short("10"));

			return resumoFaturamento;
		} else {
			return null;
		}
	}

	private ResumoFaturamento obterResumoValorCreditoARealizarPorOrigemCreditoSituacoesConta(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idCreditoOrigem, Integer idSituacaoAtualConta,
			Integer idSituacaoAnteriorConta, Integer idLancamentoTipo,
			Integer idLancamentoItem, Short seqTipoLancamento,
			Short seqItemTipoLancamento) throws ErroRepositorioException {

		BigDecimal valorItemFaturamento = repositorioFaturamento
				.acumularValorCreditoARealizarPorOrigemCredito(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(), idCreditoOrigem,
						idSituacaoAtualConta, idSituacaoAnteriorConta);

		if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
			ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
					valorItemFaturamento, anoMesFaturamento, categoria,
					localidade, new LancamentoTipo(idLancamentoTipo),
					new LancamentoItem(idLancamentoItem), null,
					seqTipoLancamento, seqItemTipoLancamento);

			return resumoFaturamento;
		} else {
			return null;
		}
	}

	private ResumoFaturamento obterResumoValorCreditoARealizarPorOrigemCreditoDuplicidade(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idCreditoOrigem, Integer idSituacaoAtualConta,
			Integer idSituacaoAnteriorConta, Integer idLancamentoTipo,
			Integer idLancamentoItem, Short seqTipoLancamento,
			Short seqItemTipoLancamento) throws ErroRepositorioException {

		BigDecimal valorItemFaturamento = repositorioFaturamento
				.acumularValorCreditoARealizarPorOrigemCreditoDuplicidade(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(), idCreditoOrigem,
						idSituacaoAtualConta, idSituacaoAnteriorConta);

		if (valorItemFaturamento.compareTo(BigDecimal.ZERO) != 0) {
			ResumoFaturamento resumoFaturamento = buildResumoFaturamento(
					valorItemFaturamento, anoMesFaturamento, categoria,
					localidade, new LancamentoTipo(idLancamentoTipo),
					new LancamentoItem(idLancamentoItem), null,
					seqTipoLancamento, seqItemTipoLancamento);

			return resumoFaturamento;
		} else {
			return null;
		}
	}

	private ResumoFaturamento obterResumoValorCreditoARealizarPorOrigemCredito(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idCreditoOrigem, Integer idSituacaoConta,
			Integer idLancamentoTipo, Integer idLancamentoItem,
			Short seqTipoLancamento, Short seqItemTipoLancamento)
			throws ErroRepositorioException {

		BigDecimal valor = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(
						anoMesFaturamento, localidade.getId(),categoria.getId(), idCreditoOrigem, idSituacaoConta);

		if (valor.compareTo(BigDecimal.ZERO) != 0) {
			ResumoFaturamento resumo = buildResumoFaturamento(valor, anoMesFaturamento, categoria,
					localidade, new LancamentoTipo(idLancamentoTipo),new LancamentoItem(idLancamentoItem), 
					null, seqTipoLancamento, seqItemTipoLancamento);
			return resumo;
		} else {
			return null;
		}
	}
	
	private ResumoFaturamento obterResumoValorCreditoARealizarDescontosParcelamento(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idSituacaoConta,
			Integer idLancamentoTipo, Integer idLancamentoItem,
			Short seqTipoLancamento, Short seqItemTipoLancamento)
			throws ErroRepositorioException {

		BigDecimal valor = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(
				anoMesFaturamento, localidade.getId(),categoria.getId(), CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO, idSituacaoConta);
		
		BigDecimal valorCurtoPrazo = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(
						anoMesFaturamento, localidade.getId(),categoria.getId(), CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_CURTO_PRAZO, idSituacaoConta);
		
		BigDecimal valorLongoPrazo = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(
				anoMesFaturamento, localidade.getId(),categoria.getId(), CreditoOrigem.DESCONTOS_CREDITOS_ANTERIORES_LONGO_PRAZO, idSituacaoConta);
		
		BigDecimal valorTotal = valor.add(valorCurtoPrazo).add(valorLongoPrazo);
		
		if (valorTotal.compareTo(BigDecimal.ZERO) != 0) {
			ResumoFaturamento resumo = buildResumoFaturamento(valorTotal, anoMesFaturamento, categoria,
					localidade, new LancamentoTipo(idLancamentoTipo),new LancamentoItem(idLancamentoItem), 
					null, seqTipoLancamento, seqItemTipoLancamento);
			return resumo;
		} else {
			return null;
		}
	}
	

	private ResumoFaturamento obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idCreditoOrigem, Integer idSituacaoConta,
			Integer idLancamentoTipo, Integer idLancamentoItem,
			Short seqTipoLancamento, Short seqItemTipoLancamento) 
					throws ErroRepositorioException{

		BigDecimal valor = repositorioFaturamento
				.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(), idCreditoOrigem, idSituacaoConta);

		if (valor.compareTo(BigDecimal.ZERO) != 0) {

			ResumoFaturamento resumo = buildResumoFaturamento(valor, anoMesFaturamento, categoria, 
					localidade, new LancamentoTipo(idLancamentoTipo),new LancamentoItem(idLancamentoItem), 
					null, seqTipoLancamento, seqItemTipoLancamento);
			return resumo;
		} else {
			return null;
		}
	}
	
	private ResumoFaturamento obterResumoCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer idCreditoOrigem, Integer idSituacaoConta,
			Integer idLancamentoTipo, Integer idLancamentoItem,
			Short seqTipoLancamento, Short seqItemTipoLancamento) 
					throws ErroRepositorioException{

		ResumoFaturamento resumoFaturamentoTemporario = repositorioFaturamento
				.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(),idCreditoOrigem, idSituacaoConta);

		if (resumoFaturamentoTemporario != null) {

			resumoFaturamentoTemporario = buildResumoFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento(), 
					anoMesFaturamento, categoria, localidade, new LancamentoTipo(idLancamentoTipo),
					new LancamentoItem(idLancamentoItem), null, seqTipoLancamento, seqItemTipoLancamento);
			
			return resumoFaturamentoTemporario;
		} else {
			return null;
		}
	}
	
	private ResumoFaturamento obterResumoCreditoRealizadoCategoriaPorOrigensCreditoComBaixaContabilNaoPreenchida(
			int anoMesFaturamento, Localidade localidade, Categoria categoria,
			Integer[] idsCreditoOrigem, Integer idSituacaoConta,
			Integer idLancamentoTipo, Integer idLancamentoItem,
			Short seqTipoLancamento, Short seqItemTipoLancamento) 
					throws ErroRepositorioException{

		ResumoFaturamento resumoFaturamentoTemporario = repositorioFaturamento
				.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigensCreditoComBaixaContabilNaoPreenchida(
						anoMesFaturamento, localidade.getId(),
						categoria.getId(),idsCreditoOrigem, idSituacaoConta);
		
		if (resumoFaturamentoTemporario != null) {

			resumoFaturamentoTemporario = buildResumoFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento(), 
					anoMesFaturamento, categoria, localidade, new LancamentoTipo(idLancamentoTipo),
					new LancamentoItem(idLancamentoItem), null, seqTipoLancamento, seqItemTipoLancamento);
			
			return resumoFaturamentoTemporario;
		} else {
			return null;
		}
	}
	
	
	private ResumoFaturamento buildResumoFaturamento(BigDecimal valorFaturamento, Integer anoMesFaturamento, Categoria categoria,
			Localidade localidade, LancamentoTipo lancamentoTipo, LancamentoItem lancamentoItem, 
			LancamentoItemContabil lancamentoItemContabil, Short seqTipoLancamento, Short seqItemTipoLancamento) {
		
		ResumoFaturamento resumoFaturamento = new ResumoFaturamento();
		resumoFaturamento.setValorItemFaturamento(valorFaturamento);
		resumoFaturamento.setAnoMesReferencia(anoMesFaturamento);
		resumoFaturamento.setCategoria(categoria);
		resumoFaturamento.setLancamentoTipo(lancamentoTipo);
		resumoFaturamento.setLancamentoItem(lancamentoItem);
		resumoFaturamento.setLancamentoItemContabil(lancamentoItemContabil);
		resumoFaturamento.setSequenciaTipoLancamento(seqTipoLancamento);
		resumoFaturamento.setSequenciaItemTipoLancamento(seqItemTipoLancamento);
		resumoFaturamento.setUltimaAlteracao(new Date());

		if (localidade != null) {
			resumoFaturamento.setLocalidade(localidade);
			resumoFaturamento.setUnidadeNegocio(localidade.getUnidadeNegocio());
			resumoFaturamento.setGerenciaRegional(localidade.getGerenciaRegional());
		}

		return resumoFaturamento;
	}

	private ResumoFaturamento acumularValorResumoFaturamento(
			ResumoFaturamento resumoFaturamento, BigDecimal valor) {
		resumoFaturamento.setValorItemFaturamento(resumoFaturamento
				.getValorItemFaturamento().add(valor));
		return resumoFaturamento;

	}

	private Integer[] obterIdsCreditosOrigemParaEncerramentoFaturamentoMensal() {
		Integer[] idsCreditosOrigem;
		idsCreditosOrigem = new Integer[4];
		idsCreditosOrigem[0] = CreditoOrigem.DEVOLUCAO_TARIFA_AGUA;
		idsCreditosOrigem[1] = CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO;
		idsCreditosOrigem[2] = CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE;
		idsCreditosOrigem[3] = CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO;
		return idsCreditosOrigem;
	}

	private Map<Integer, BigDecimal> acumularValorPorCategoriaReceitaBruta(
			Map<Integer, BigDecimal> mapValorPorCategoriaReceitaBruta,
			Integer idCategoria, BigDecimal valorGuiaDevolucao) {
		if (mapValorPorCategoriaReceitaBruta.containsKey(idCategoria)) {
			mapValorPorCategoriaReceitaBruta.put(idCategoria,
					((BigDecimal) mapValorPorCategoriaReceitaBruta
							.get(idCategoria)).add(valorGuiaDevolucao));
		} else {
			mapValorPorCategoriaReceitaBruta.put(idCategoria,
					valorGuiaDevolucao);
		}

		return mapValorPorCategoriaReceitaBruta;
	}

	private Map<Integer, BigDecimal> obterMapValorGuiaDevolucaoPorCategoria(
			Collection<Object[]> colecaoDadosGuiaDevolucao)
			throws ControladorException {

		Map<Integer, BigDecimal> mapValorGuiaDevolucao = new HashMap();

		for (Object[] dadosGuiaDevolucao : colecaoDadosGuiaDevolucao) {
			Integer idImovel = (Integer) dadosGuiaDevolucao[0];
			BigDecimal valorGuiaDevolucao = (BigDecimal) dadosGuiaDevolucao[1];

			Categoria principalCategoriaImovel = this.getControladorImovel()
					.obterPrincipalCategoriaImovel(idImovel);

			Integer idCategoria = principalCategoriaImovel.getId();
			acumularValorPorCategoriaReceitaBruta(mapValorGuiaDevolucao,
					idCategoria, valorGuiaDevolucao);
		}

		return mapValorGuiaDevolucao;
	}

	private void validarGruposFaturadosParaEncerrarFaturamentoMensal(
			int anoMesFaturamentoSistemaParametro)
			throws ErroRepositorioException, ControladorException {
		Collection<FaturamentoGrupo> colecaoFaturamentoGrupoNaoFaturados = this.repositorioFaturamento
				.pesquisarFaturamentoGrupoNaoFaturados(anoMesFaturamentoSistemaParametro);

		if (colecaoFaturamentoGrupoNaoFaturados != null
				&& !colecaoFaturamentoGrupoNaoFaturados.isEmpty()) {
			throw new ControladorException(
					"atencao.existemGruposFaturamentoNaoFaturados", null,
					"grupo(s)");
		}
	}

	/**
	 * 
	 * Metodo para calculo da receita liquida.
	 * 
	 * @author Hugo Amorim
	 * @analista Ana Cristina
	 * @since 04/06/2010
	 * @param colecaoCategorias
	 * @param colecaoIdsLocalidades
	 * @throws ErroRepositorioException
	 */
	private void calcularValorReceitaLiquida(
			Integer anoMesFaturamentoSistemaParametro,
			Collection<Categoria> colecaoCategorias,
			Collection<Integer> colecaoIdsLocalidades) {
		try {

			Collection colecaoResumoFaturamento = null;

			// laço para construir os resumos de faturamento liquido
			// Agua,Esgoto,Total
			// por localidade
			for (Integer idLocalidade : colecaoIdsLocalidades) {

				colecaoResumoFaturamento = new ArrayList<ResumoFaturamento>();

				Integer idGerenciaRegional = this.getControladorLocalidade()
						.pesquisarIdGerenciaParaLocalidade(idLocalidade);
				GerenciaRegional gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setId(idGerenciaRegional);

				Integer idUnidadeNegocio = this.getControladorLocalidade()
						.pesquisarIdUnidadeNegocioParaLocalidade(idLocalidade);
				UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(idUnidadeNegocio);

				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);

				// laço para construir os resumos de faturamento liquido
				// Agua,Esgoto,Total
				// por categoria
				for (Categoria categoria : colecaoCategorias) {

					// Object[] dadosReceitaLiquidaAguaEsgoto
					// dadosReceitaLiquidaAguaEsgoto[0] = Valor Agua
					// dadosReceitaLiquidaAguaEsgoto[1] = Valor Esgoto
					// dadosReceitaLiquidaAguaEsgoto[2] = Valor Total
					Object[] dadosReceitaLiquidaAguaEsgoto = this.repositorioFaturamento
							.pesquisarDadosReceitaLiquidaAguaEsgoto(
									anoMesFaturamentoSistemaParametro,
									idLocalidade, categoria.getId());

					if (dadosReceitaLiquidaAguaEsgoto != null
							&& dadosReceitaLiquidaAguaEsgoto[0] != null) {

						LancamentoTipo lancamentoTipoAgua = new LancamentoTipo();
						lancamentoTipoAgua
								.setId(LancamentoTipo.RECEITA_LIQUIDA);
						LancamentoItem lancamentoItemAgua = new LancamentoItem();
						lancamentoItemAgua.setId(LancamentoItem.AGUA);

						ResumoFaturamento resumoFaturamentoAgua = new ResumoFaturamento();
						resumoFaturamentoAgua
								.setValorItemFaturamento((BigDecimal) dadosReceitaLiquidaAguaEsgoto[0]);
						resumoFaturamentoAgua
								.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoAgua.setCategoria(categoria);
						resumoFaturamentoAgua.setLocalidade(localidade);
						resumoFaturamentoAgua.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoAgua
								.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoAgua
								.setLancamentoTipo(lancamentoTipoAgua);
						resumoFaturamentoAgua
								.setLancamentoItem(lancamentoItemAgua);
						resumoFaturamentoAgua.setLancamentoItemContabil(null);
						resumoFaturamentoAgua
								.setSequenciaTipoLancamento(new Short("1110"));
						resumoFaturamentoAgua
								.setSequenciaItemTipoLancamento(new Short("0"));
						resumoFaturamentoAgua.setUltimaAlteracao(new Date());

						colecaoResumoFaturamento.add(resumoFaturamentoAgua);

					}

					if (dadosReceitaLiquidaAguaEsgoto != null
							&& dadosReceitaLiquidaAguaEsgoto[1] != null) {

						LancamentoTipo lancamentoTipoEsgoto = new LancamentoTipo();
						lancamentoTipoEsgoto
								.setId(LancamentoTipo.RECEITA_LIQUIDA);
						LancamentoItem lancamentoItemEsgoto = new LancamentoItem();
						lancamentoItemEsgoto.setId(LancamentoItem.ESGOTO);

						ResumoFaturamento resumoFaturamentoEsgoto = new ResumoFaturamento();
						resumoFaturamentoEsgoto
								.setValorItemFaturamento((BigDecimal) dadosReceitaLiquidaAguaEsgoto[1]);
						resumoFaturamentoEsgoto
								.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoEsgoto.setCategoria(categoria);
						resumoFaturamentoEsgoto.setLocalidade(localidade);
						resumoFaturamentoEsgoto
								.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoEsgoto
								.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoEsgoto
								.setLancamentoTipo(lancamentoTipoEsgoto);
						resumoFaturamentoEsgoto
								.setLancamentoItem(lancamentoItemEsgoto);
						resumoFaturamentoEsgoto.setLancamentoItemContabil(null);
						resumoFaturamentoEsgoto
								.setSequenciaTipoLancamento(new Short("1120"));
						resumoFaturamentoEsgoto
								.setSequenciaItemTipoLancamento(new Short("0"));
						resumoFaturamentoEsgoto.setUltimaAlteracao(new Date());

						colecaoResumoFaturamento.add(resumoFaturamentoEsgoto);

					}

					if (dadosReceitaLiquidaAguaEsgoto != null
							&& dadosReceitaLiquidaAguaEsgoto[2] != null) {

						LancamentoTipo lancamentoTipoTotal = new LancamentoTipo();
						lancamentoTipoTotal
								.setId(LancamentoTipo.RECEITA_LIQUIDA);
						LancamentoItem lancamentoItemTotal = new LancamentoItem();
						lancamentoItemTotal.setId(LancamentoItem.TOTAL);

						ResumoFaturamento resumoFaturamentoTotal = new ResumoFaturamento();
						resumoFaturamentoTotal
								.setValorItemFaturamento((BigDecimal) dadosReceitaLiquidaAguaEsgoto[2]);
						resumoFaturamentoTotal
								.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTotal.setCategoria(categoria);
						resumoFaturamentoTotal.setLocalidade(localidade);
						resumoFaturamentoTotal
								.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTotal
								.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoTotal
								.setLancamentoTipo(lancamentoTipoTotal);
						resumoFaturamentoTotal
								.setLancamentoItem(lancamentoItemTotal);
						resumoFaturamentoTotal.setLancamentoItemContabil(null);
						resumoFaturamentoTotal
								.setSequenciaTipoLancamento(new Short("1200"));
						resumoFaturamentoTotal
								.setSequenciaItemTipoLancamento(new Short("0"));
						resumoFaturamentoTotal.setUltimaAlteracao(new Date());

						colecaoResumoFaturamento.add(resumoFaturamentoTotal);
					}

				}// fim CATEGORIA

				/*
				 * Caso a coleção de resumo de faturamento para inserção não
				 * esteja vazia manda inserir todos os resumo de faturamento.
				 */
				if (colecaoResumoFaturamento != null
						&& !colecaoResumoFaturamento.isEmpty()) {
					getControladorBatch().inserirColecaoObjetoParaBatch(
							colecaoResumoFaturamento);
				}
			}// fim LOCALIDADE

			// laço para construir os resumos de faturamento liquido indireto
			// por localidade
			for (Integer idLocalidade : colecaoIdsLocalidades) {

				colecaoResumoFaturamento = new ArrayList<ResumoFaturamento>();

				Integer idGerenciaRegional = this.getControladorLocalidade()
						.pesquisarIdGerenciaParaLocalidade(idLocalidade);
				GerenciaRegional gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setId(idGerenciaRegional);

				Integer idUnidadeNegocio = this.getControladorLocalidade()
						.pesquisarIdUnidadeNegocioParaLocalidade(idLocalidade);
				UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(idUnidadeNegocio);

				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);

				// laço para construir os resumos de faturamento liquido
				// indireto
				// por categoria
				for (Categoria categoria : colecaoCategorias) {

					// Object[] dadosReceitaLiquidaAguaEsgoto
					// dadosReceitaLiquidaAguaEsgoto[0] = Valor Receita indireta
					BigDecimal dadoReceitaLiquidaIndireta = this.repositorioFaturamento
							.pesquisarDadosReceitaLiquidaIndireta(
									anoMesFaturamentoSistemaParametro,
									idLocalidade, categoria.getId());

					if (dadoReceitaLiquidaIndireta != null) {

						LancamentoTipo lancamentoTipoAgua = new LancamentoTipo(
								LancamentoTipo.RECEITA_LIQUIDA);
						LancamentoItem lancamentoItemAgua = new LancamentoItem(
								LancamentoItem.INDIRETA);

						ResumoFaturamento resumoFaturamentoAgua = new ResumoFaturamento();
						resumoFaturamentoAgua
								.setValorItemFaturamento(dadoReceitaLiquidaIndireta);
						resumoFaturamentoAgua
								.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoAgua.setCategoria(categoria);
						resumoFaturamentoAgua.setLocalidade(localidade);
						resumoFaturamentoAgua.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoAgua
								.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoAgua
								.setLancamentoTipo(lancamentoTipoAgua);
						resumoFaturamentoAgua
								.setLancamentoItem(lancamentoItemAgua);
						resumoFaturamentoAgua.setLancamentoItemContabil(null);
						resumoFaturamentoAgua
								.setSequenciaTipoLancamento(new Short("1130"));
						resumoFaturamentoAgua
								.setSequenciaItemTipoLancamento(new Short("0"));
						resumoFaturamentoAgua.setUltimaAlteracao(new Date());

						colecaoResumoFaturamento.add(resumoFaturamentoAgua);
					}

				}// fim CATEGORIA

				/*
				 * Caso a coleção de resumo de faturamento para inserção não
				 * esteja vazia manda inserir todos os resumo de faturamento.
				 */
				if (colecaoResumoFaturamento != null
						&& !colecaoResumoFaturamento.isEmpty()) {
					getControladorBatch().inserirColecaoObjetoParaBatch(
							colecaoResumoFaturamento);
				}
			}// fim LOCALIDADE
		} catch (Exception ex) {
			ex.printStackTrace();
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0819] Gerar Historico do Encerramento do Faturamento
	 * 
	 * Metodo responsável pela transferência das contas, débito a cobrar e
	 * crédito a realizar para o histórico, assim com a atualizaçaõ dos imóveis.
	 * 
	 * @author Pedro Alexandre, Raphael Rossiter
	 * @date 06/02/2007, 10/02/2009
	 * 
	 * @param anoMesFaturamento
	 * @param idSetorComercial
	 * @throws ControladorException
	 */
	public void gerarHistoricoParaEncerrarFaturamento(
			int anoMesFaturamento, Integer idSetorComercial,
			int idFuncionalidadeIniciada) throws ControladorException {

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,UnidadeProcessamento.SETOR_COMERCIAL, idSetorComercial);
		try {

			SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

			Integer resumoFaturamento = repositorioFaturamento.pesquisarResumoFaturamento(sistemaParametro.getAnoMesFaturamento());

			if (resumoFaturamento != null && resumoFaturamento.intValue() > 0) {

				repositorioFaturamento.atualizarImoveisSituacaoEspecialFaturamentoFinalizada(anoMesFaturamento,idSetorComercial);
				repositorioFaturamento.atualizarImoveisSituacaoEspecialCobrancaFinalizada(anoMesFaturamento, idSetorComercial);

				boolean flagTerminou = false;
				final int quantidadeRegistros = 1000;
				int numeroIndice = 0;

				while (!flagTerminou) {
					List contasCanceladas = (List) repositorioFaturamento.pesquisarContasCanceladasPorMesAnoReferenciaContabil(
									anoMesFaturamento,
									idSetorComercial, 
									numeroIndice,
									quantidadeRegistros);

					if (contasCanceladas == null || contasCanceladas.size() < quantidadeRegistros) {
						flagTerminou = true;
					}

					this.gerarHistoricoDeContasCanceladasParaEncerrarFaturamento(contasCanceladas, anoMesFaturamento);
					contasCanceladas = null;
				}

				List debitosACobrar = (List) repositorioFaturamento.pesquisarDebitosACobrarCanceladosPorMesAnoReferenciaContabil(anoMesFaturamento, idSetorComercial);

				int limiteSuperiorDebito;
				int limiteInferiorDebito;
				int limiteMaximoDebito = debitosACobrar.size();
				int quantidadeMaximaPorColecaoDebito = 50;

				for (int i = 0; i < limiteMaximoDebito; i = i + quantidadeMaximaPorColecaoDebito) {

					if (limiteMaximoDebito < quantidadeMaximaPorColecaoDebito) {
						limiteInferiorDebito = 0;
						limiteSuperiorDebito = limiteMaximoDebito;
					} else {
						limiteInferiorDebito = i;
						limiteSuperiorDebito = i + quantidadeMaximaPorColecaoDebito;

						if (limiteSuperiorDebito > limiteMaximoDebito) {
							limiteSuperiorDebito = limiteMaximoDebito;
						}
					}

					List colecaoDebitosTemporaria = new ArrayList();
					colecaoDebitosTemporaria.addAll(debitosACobrar.subList(limiteInferiorDebito, limiteSuperiorDebito));

					this.gerarHistoricoDeDebitosACobrarCanceladosParaEncerrarFaturamento(colecaoDebitosTemporaria);

					colecaoDebitosTemporaria = null;
				}
				debitosACobrar = null;

				List creditosARealizar = (List) repositorioFaturamento.pesquisarCreditosARealizarCanceladosPorMesAnoReferenciaContabil(anoMesFaturamento, idSetorComercial);

				int limiteSuperiorCredito;
				int limiteInferiorCredito;
				int limiteMaximoCredito = creditosARealizar.size();
				int quantidadeMaximaPorColecaoCredito = 50;

				for (int i = 0; i < limiteMaximoCredito; i = i + quantidadeMaximaPorColecaoCredito) {

					if (limiteMaximoCredito < quantidadeMaximaPorColecaoCredito) {
						limiteInferiorCredito = 0;
						limiteSuperiorCredito = limiteMaximoCredito;
					} else {
						limiteInferiorCredito = i;
						limiteSuperiorCredito = i
								+ quantidadeMaximaPorColecaoCredito;

						if (limiteSuperiorCredito > limiteMaximoCredito) {
							limiteSuperiorCredito = limiteMaximoCredito;
						}
					}

					List colecaoCreditosTemporaria = new ArrayList();
					colecaoCreditosTemporaria.addAll(creditosARealizar.subList(limiteInferiorCredito, limiteSuperiorCredito));

					this.gerarHistoricoDeCreditosARealizarCanceladosParaEncerrarFaturamento(colecaoCreditosTemporaria);

					colecaoCreditosTemporaria = null;
				}
				creditosARealizar = null;

				getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);
			} else {
				throw new ControladorException("atencao.resumo_faturamento_inexistente");
			}

		} catch (Exception e) {
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e, idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	public BigDecimal[] obterValorCurtoELongoPrazo(short numeroPrestacoes, short numeroPrestacoesCobradas, BigDecimal valorCategoria) throws ControladorException {

		final int curtoPrazo = 0;
		final int longoPrazo = 1;

		BigDecimal valorPrestacao = null;

		BigDecimal[] valores = new BigDecimal[2];

		if (numeroPrestacoes < numeroPrestacoesCobradas) {
			return null;
		} else {
			if (numeroPrestacoes == 0) {
				return null;
			} else {
				if ((numeroPrestacoes - numeroPrestacoesCobradas) < 13) {
					valores[curtoPrazo] = valorCategoria;
					valores[longoPrazo] = new BigDecimal(0.0);
				} else {
					valorPrestacao = valorCategoria.divide(new BigDecimal(numeroPrestacoes), 2, BigDecimal.ROUND_DOWN);

					valores[curtoPrazo] = valorPrestacao.multiply(new BigDecimal("12"));

					valores[longoPrazo] = valorCategoria.subtract(valores[curtoPrazo]);
				}

				if (valores[0] == null) {
					valores[0] = BigDecimal.ZERO;
				}

				if (valores[1] == null) {
					valores[1] = BigDecimal.ZERO;
				}

				return valores;
			}
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * <[UC0155] - Encerrar Faturamento do Mês
	 * 
	 * [SB0002] - Obter Diferenças de Valores de Parcelamentos de Conta
	 * Retificada
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 20/01/2006,12/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idTipoFinanciamento
	 * @return
	 * @throws ControladorException
	 */
	private BigDecimal[] obterDiferencaValoresParcelamentoIndiretosContaRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer idTipoFinanciamento) throws ControladorException {

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal[] retorno = new BigDecimal[2];

		BigDecimal valorDebitoCobradoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorDebitoCobradoSituacaoRetificado = null;

		Localidade localidade = new Localidade();
		localidade.setId(idLocalidade);

		try {
			// obtém o valor dos débitos cobrados cancelados do retificação
			valorDebitoCobradoSituacaoCanceladoPorRetificacao = repositorioFaturamento
					.acumularValorDebitoCobradoPorTipoFinanciamentoCanceladaPorRetificacao(
							anoMesReferencia, idLocalidade, idCategoria,
							idTipoFinanciamento);

			// obtém o valor dos débitos cobrados retificados
			valorDebitoCobradoSituacaoRetificado = repositorioFaturamento
					.acumularValorDebitoCobradoPorTipoFinanciamentoRetificada(
							anoMesReferencia, localidade, idCategoria,
							idTipoFinanciamento);

			// erro no hibernate
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (valorDebitoCobradoSituacaoCanceladoPorRetificacao == null) {
			valorDebitoCobradoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
		}

		if (valorDebitoCobradoSituacaoRetificado == null) {
			valorDebitoCobradoSituacaoRetificado = BigDecimal.ZERO;
		}

		// Valor Acumulados Cancelados
		retorno[0] = valorDebitoCobradoSituacaoCanceladoPorRetificacao;

		// Valor Incluidos Cancelados
		retorno[1] = valorDebitoCobradoSituacaoRetificado;

		// retorna a diferença entre os valores dos débitos cobrados
		return retorno;
	}

	/**
	 * [SB0001] - Obter Diferenças de Valores de Serviços Indiretos de Conta
	 * Retificada
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 20/01/2006, 06/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param tipoFinaciamento
	 * @param itemContabil
	 * @return
	 * @throws ControladorException
	 */
	private BigDecimal[] obterDiferencaValoresServicoIndiretosContaRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Collection<Integer> tipoFinanciamento, Integer itemContabil)
			throws ControladorException {

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal[] retorno = new BigDecimal[2];

		BigDecimal valorDebitoCobradoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
		BigDecimal valorDebitoCobradoSituacaoRetificado = BigDecimal.ZERO;

		try {
			// obtém o valor dos débitos cobrados cancelados do retificação
			valorDebitoCobradoSituacaoCanceladoPorRetificacao = repositorioFaturamento
					.acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaCanceladaPorRetificacao(
							anoMesReferencia, idLocalidade, idCategoria,
							tipoFinanciamento, itemContabil);

			// obtém o valor dos débitos cobrados retificados
			valorDebitoCobradoSituacaoRetificado = repositorioFaturamento
					.acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaRetificada(
							anoMesReferencia, idLocalidade, idCategoria,
							tipoFinanciamento, itemContabil);

			if (valorDebitoCobradoSituacaoCanceladoPorRetificacao == null) {
				valorDebitoCobradoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
			}
			if (valorDebitoCobradoSituacaoRetificado == null) {
				valorDebitoCobradoSituacaoRetificado = BigDecimal.ZERO;
			}
			// erro no hibernate
		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Valor Acumulados Cancelados
		retorno[0] = valorDebitoCobradoSituacaoCanceladoPorRetificacao;

		// Valor Acumulados Incluidos
		retorno[1] = valorDebitoCobradoSituacaoRetificado;

		// retorna a diferença entre os valores dos débitos cobrados
		return retorno;
	}

	/**
	 * Obtem os Debitos A Cobrar do Imovel
	 * 
	 * @param imovelID
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualID
	 *            ID do Debito Credito Situação
	 * @return Coleção de Debitos a Cobrar
	 */
	public Collection obterDebitoACobrarImovel(Integer imovelID,
			Integer debitoCreditoSituacaoAtualID, int anoMesFaturamento)
			throws ControladorException {

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		// lista de debitos a cobrar
		Collection debitosACobrar = null;
		Collection colecaoDebitosACobrar = null;

		// Pesquisa débitos a cobrar
		try {
			colecaoDebitosACobrar = repositorioFaturamento
					.pesquisarDebitosACobrar(imovelID,
							debitoCreditoSituacaoAtualID);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe débitos a cobrar
		if (colecaoDebitosACobrar != null && !colecaoDebitosACobrar.isEmpty()) {

			Iterator iteratorColecaoDebitosACobrar = colecaoDebitosACobrar
					.iterator();

			DebitoACobrar debitoACobrar = null;
			debitosACobrar = new ArrayList();

			while (iteratorColecaoDebitosACobrar.hasNext()) {

				Object[] arrayDebitosACobrar = (Object[]) iteratorColecaoDebitosACobrar
						.next();

				debitoACobrar = new DebitoACobrar();
				// id do Debito a Cobrar - Item 0
				if (arrayDebitosACobrar[0] != null) {
					debitoACobrar.setId((Integer) arrayDebitosACobrar[0]);
				}

				// id do financimento tipo - tem 1
				if (arrayDebitosACobrar[1] != null) {
					FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
					financiamentoTipo.setId((Integer) arrayDebitosACobrar[1]);
					debitoACobrar.setFinanciamentoTipo(financiamentoTipo);
				}

				// id do lancamento item contabil - tem 2
				if (arrayDebitosACobrar[2] != null) {
					LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
					lancamentoItemContabil
							.setId((Integer) arrayDebitosACobrar[2]);
					debitoACobrar
							.setLancamentoItemContabil(lancamentoItemContabil);
				}

				// valor de debito - tem 3
				if (arrayDebitosACobrar[3] != null) {
					debitoACobrar
							.setValorDebito((BigDecimal) arrayDebitosACobrar[3]);
				}
				// numero de prestações de debito - item 4
				if (arrayDebitosACobrar[4] != null) {
					debitoACobrar
							.setNumeroPrestacaoDebito(((Short) arrayDebitosACobrar[4])
									.shortValue());
				}
				// numero de prestações cobradas - item 5
				if (arrayDebitosACobrar[5] != null) {
					debitoACobrar
							.setNumeroPrestacaoCobradas(((Short) arrayDebitosACobrar[5])
									.shortValue());
				}

				// id do debito tipo - item 6
				if (arrayDebitosACobrar[6] != null) {
					DebitoTipo debitoTipo = new DebitoTipo();
					debitoTipo.setId((Integer) arrayDebitosACobrar[6]);
					debitoACobrar.setDebitoTipo(debitoTipo);
				}

				// id da localidade - item 7
				if (arrayDebitosACobrar[7] != null) {
					Localidade localidade = new Localidade();
					localidade.setId((Integer) arrayDebitosACobrar[7]);
					debitoACobrar.setLocalidade(localidade);
				}

				// id da Quadra - item 8
				if (arrayDebitosACobrar[8] != null) {
					Quadra quadra = new Quadra();
					quadra.setId((Integer) arrayDebitosACobrar[8]);
					debitoACobrar.setQuadra(quadra);
				}

				// codigo Setor Comercial - item 9
				if (arrayDebitosACobrar[9] != null) {
					debitoACobrar
							.setCodigoSetorComercial((Integer) arrayDebitosACobrar[9]);
				}

				// Número da Quadra - item 10
				if (arrayDebitosACobrar[10] != null) {
					debitoACobrar
							.setNumeroQuadra((Integer) arrayDebitosACobrar[10]);
				}

				// Número do Lote - item 11
				if (arrayDebitosACobrar[11] != null) {
					debitoACobrar
							.setNumeroLote(((Short) arrayDebitosACobrar[11])
									.shortValue());
				}

				// Número do Sub Lote - item 12
				if (arrayDebitosACobrar[12] != null) {
					debitoACobrar
							.setNumeroSubLote(((Short) arrayDebitosACobrar[12])
									.shortValue());
				}

				// Ano Mês Referencia Debito - item 13
				if (arrayDebitosACobrar[13] != null) {
					debitoACobrar
							.setAnoMesReferenciaDebito((Integer) arrayDebitosACobrar[13]);
				}

				// Ano Mês Cobrança de Debito - item 14
				if (arrayDebitosACobrar[14] != null) {
					debitoACobrar
							.setAnoMesCobrancaDebito((Integer) arrayDebitosACobrar[14]);
				}

				/*
				 * Alterado por Vivianne Sousa em 20/12/2007 - Analista: Adriano
				 * criação do bonus para parcelamento com RD especial
				 */
				// numero de parcelas bonus - item 17
				if (arrayDebitosACobrar[17] != null) {
					debitoACobrar
							.setNumeroParcelaBonus(((Short) arrayDebitosACobrar[17]));
				}

				/*
				 * [UC0113] - Faturar Grupo de Faturamento [FS0005] - Verificar
				 * Débitos a cobrar de parcelamento
				 */
				if (!(arrayDebitosACobrar[16] != null
						&& debitoACobrar.getNumeroPrestacaoCobradas() == 0 && (arrayDebitosACobrar[15] != null && ((Integer) arrayDebitosACobrar[15])
						.intValue() >= sistemaParametro.getAnoMesFaturamento()))) {
					/*
					 * [UC0113] - Faturar Grupo de Faturamento [FS0007] -
					 * Verificar pagamentos para débitos a cobrar
					 */
					Integer qtdPagamentos = this.getControladorArrecadacao()
							.pesquisarQuantidadePagamentosPorDebitoACobrar(
									debitoACobrar.getId());

					if (qtdPagamentos == null || qtdPagamentos.intValue() == 0) {
						debitosACobrar.add(debitoACobrar);
					}
				}
			}
		}

		return debitosACobrar;
	}

	/**
	 * Obtem os Debitos A Cobrar Categoria do Debito a Cobrar
	 * 
	 * @param debitoACobrarID
	 *            Id do Debito A Cobrar
	 * @return Coleção de Debitos a Cobrar Categoria
	 */
	public Collection obterDebitoACobrarCategoria(Integer debitoACobrarID)
			throws ControladorException {

		Collection debitosACobrarCategoria = null;
		Collection colecaoCreditosACobrarCategoria = null;

		// Pesquisa créditos a cobrar categoria
		try {
			colecaoCreditosACobrarCategoria = repositorioFaturamento
					.pesquisarDebitosACobrarCategoria(debitoACobrarID);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe débitos a cobrar
		if (colecaoCreditosACobrarCategoria != null
				&& !colecaoCreditosACobrarCategoria.isEmpty()) {

			Iterator iteratorColecaoCreditosACobrarCategoria = colecaoCreditosACobrarCategoria
					.iterator();
			DebitoACobrarCategoria debitoACobrarCategoria = null;
			debitosACobrarCategoria = new ArrayList();
			while (iteratorColecaoCreditosACobrarCategoria.hasNext()) {

				Object[] arrayDebitosACobrarCategoria = (Object[]) iteratorColecaoCreditosACobrarCategoria
						.next();

				debitoACobrarCategoria = new DebitoACobrarCategoria();

				// id da categoria - tem 0
				if (arrayDebitosACobrarCategoria[0] != null) {
					Categoria categoria = new Categoria();
					categoria.setId((Integer) arrayDebitosACobrarCategoria[0]);
					debitoACobrarCategoria.setCategoria(categoria);
				}

				// Quantidade de Economias - Item 1
				if (arrayDebitosACobrarCategoria[1] != null) {
					debitoACobrarCategoria
							.setQuantidadeEconomia((Integer) arrayDebitosACobrarCategoria[1]);
				}

				debitosACobrarCategoria.add(debitoACobrarCategoria);
			}

		}
		return debitosACobrarCategoria;
	}

	/**
	 * Obtem os Credito A Realizar do Imovel
	 * 
	 * @param imovelID
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualID
	 *            ID do Debito Credito Situação
	 * @return Coleção de Creditos a Realizar
	 */
	public Collection obterCreditoARealizarImovelPorSituacao(Integer imovelID,
			Integer debitoCreditoSituacaoAtualID, int anoMesFaturamentoGrupo, boolean preFaturamento)
			throws ControladorException {

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		Collection creditosARealizar = null;
		Collection colecaoCreditosARealizar = null;
		
		/**
		 * @autor Adriana Muniz
		 * @date 25/09/2013
		 * 
		 * Troca da referência de faturamento do grupo para a referencia
		 * de faturamento do sistema de parametro.
		 */
		
		try {
			colecaoCreditosARealizar = repositorioFaturamento.pesquisarCreditoARealizar(imovelID, debitoCreditoSituacaoAtualID, anoMesFaturamentoGrupo, sistemaParametro);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoCreditosARealizar != null && !colecaoCreditosARealizar.isEmpty()) {

			creditosARealizar = new ArrayList();

			Iterator iteratorColecaoCreditosARealizar = colecaoCreditosARealizar.iterator();
			
			CreditoARealizar creditoARealizar = null;
			while (iteratorColecaoCreditosARealizar.hasNext()) {

				Object[] arrayCreditosACobrar = (Object[]) iteratorColecaoCreditosARealizar.next();

				creditoARealizar = new CreditoARealizar();

				if (arrayCreditosACobrar[0] != null) {
					creditoARealizar.setId((Integer) arrayCreditosACobrar[0]);
					CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
					creditoARealizarGeral.setId((Integer) arrayCreditosACobrar[0]);
					creditoARealizar.setCreditoARealizarGeral(creditoARealizarGeral);
				}

				if (arrayCreditosACobrar[1] != null) {
					creditoARealizar.setNumeroPrestacaoRealizada((Short) arrayCreditosACobrar[1]);
				}

				if (arrayCreditosACobrar[2] != null) {
					creditoARealizar.setNumeroPrestacaoCredito((Short) arrayCreditosACobrar[2]);
				}

				if (arrayCreditosACobrar[3] != null) {
					creditoARealizar.setValorCredito((BigDecimal) arrayCreditosACobrar[3]);
				}

				if (arrayCreditosACobrar[4] != null) {
					creditoARealizar.setValorResidualMesAnterior((BigDecimal) arrayCreditosACobrar[4]);
				}

				if (arrayCreditosACobrar[5] != null) {
					CreditoTipo creditoTipo = new CreditoTipo((Integer) arrayCreditosACobrar[5]);
					creditoARealizar.setCreditoTipo(creditoTipo);
				}

				if (arrayCreditosACobrar[6] != null) {
					LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil((Integer) arrayCreditosACobrar[6]);
					creditoARealizar.setLancamentoItemContabil(lancamentoItemContabil);
				}

				if (arrayCreditosACobrar[7] != null) {
					Localidade localidade = new Localidade((Integer) arrayCreditosACobrar[7]);
					creditoARealizar.setLocalidade(localidade);
				}

				if (arrayCreditosACobrar[8] != null) {
					Quadra quadra = new Quadra((Integer) arrayCreditosACobrar[8]);
					creditoARealizar.setQuadra(quadra);
				}

				if (arrayCreditosACobrar[9] != null) {
					creditoARealizar.setCodigoSetorComercial((Integer) arrayCreditosACobrar[9]);
				}

				if (arrayCreditosACobrar[10] != null) {
					creditoARealizar.setNumeroQuadra((Integer) arrayCreditosACobrar[10]);
				}

				if (arrayCreditosACobrar[11] != null) {
					creditoARealizar.setNumeroLote((Short) arrayCreditosACobrar[11]);
				}

				if (arrayCreditosACobrar[12] != null) {
					creditoARealizar.setNumeroSubLote((Short) arrayCreditosACobrar[12]);
				}

				if (arrayCreditosACobrar[13] != null) {
					creditoARealizar.setAnoMesReferenciaCredito((Integer) arrayCreditosACobrar[13]);
				}

				if (arrayCreditosACobrar[14] != null) {
					creditoARealizar.setAnoMesCobrancaCredito((Integer) arrayCreditosACobrar[14]);
				}

				if (arrayCreditosACobrar[15] != null) {
					CreditoOrigem creditoOrigem = new CreditoOrigem((Integer) arrayCreditosACobrar[15]);
					creditoARealizar.setCreditoOrigem(creditoOrigem);
				}

				if (arrayCreditosACobrar[16] != null) {
					creditoARealizar.setNumeroParcelaBonus((Short) arrayCreditosACobrar[16]);
				}

				if (arrayCreditosACobrar[17] != null) {
					creditoARealizar.setGeracaoCredito((Date) arrayCreditosACobrar[17]);
				}
				
				if (arrayCreditosACobrar[18] != null) {
					creditoARealizar.setAnoMesReferenciaPrestacao((Integer) arrayCreditosACobrar[18]);
				}
				creditosARealizar.add(creditoARealizar);
			}
		}
		return creditosARealizar;
	}

	/**
	 * Obtem os Creditos Realizado Categoria
	 * 
	 * @param creditoARealizarID
	 *            Id do Creditoa A Realizar
	 * @return Coleção de Creditos Realizados Categoria
	 */
	public Collection obterCreditoRealizarCategoria(Integer creditoARealizarID)
			throws ControladorException {

		Collection creditosARealizarCategoria = null;
		Collection colecaoCreditoRealizarCategoria = null;

		// Pesquisa credito realizar categoria
		try {
			colecaoCreditoRealizarCategoria = repositorioFaturamento
					.pesquisarCreditoRealizarCategoria(creditoARealizarID);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe credito realizar categoria
		if (colecaoCreditoRealizarCategoria != null
				&& !colecaoCreditoRealizarCategoria.isEmpty()) {

			Iterator iteratorColecaoCreditoRealizarCategoria = colecaoCreditoRealizarCategoria
					.iterator();

			CreditoARealizarCategoria creditoARealizarCategoria = null;
			creditosARealizarCategoria = new ArrayList();
			while (iteratorColecaoCreditoRealizarCategoria.hasNext()) {

				Object[] arrayDebitosACobrarCategoria = (Object[]) iteratorColecaoCreditoRealizarCategoria
						.next();

				creditoARealizarCategoria = new CreditoARealizarCategoria();

				// id da categoria - item 0
				if (arrayDebitosACobrarCategoria[0] != null) {

					Categoria categoria = new Categoria();
					categoria.setId((Integer) arrayDebitosACobrarCategoria[0]);
					creditoARealizarCategoria.setCategoria(categoria);

				}
				// id do Credito A Realizar - item 1
				if (arrayDebitosACobrarCategoria[1] != null) {
					CreditoARealizar creditoARealizar = new CreditoARealizar();
					creditoARealizar
							.setId((Integer) arrayDebitosACobrarCategoria[1]);

					creditoARealizarCategoria
							.setCreditoARealizar(creditoARealizar);
				}

				// quantidade de economia - item 2
				if (arrayDebitosACobrarCategoria[2] != null) {
					creditoARealizarCategoria
							.setQuantidadeEconomia((Integer) arrayDebitosACobrarCategoria[2]);

				}

				creditosARealizarCategoria.add(creditoARealizarCategoria);
			}
		}

		return creditosARealizarCategoria;
	}

	/**
	 * Pesquisa os dados dos imóveis que serão faturados
	 * 
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * @author Rafael Santos, Raphael Rossiter, Raphael Rossiter
	 * @date 16/02/2006, 26/03/2008, 16/08/2011
	 * 
	 * @param idRota
	 * @param numeroPaginas
	 * @param quantidadeRegistros
	 * @param preFaturar
	 * @param resumo
	 * @throws ErroRepositorioException
	 */
	protected Collection pesquisarImovelGrupoFaturamento(Rota rota,
			int numeroIndice, int quantidadeRegistros, boolean preFaturar,
			boolean resumo) throws ControladorException {

		Collection colecaoImoveis = null;
		Collection imoveis;

		try {
			/*
			 * Caso a rota não esteja com o indicador de rota alternativa ativo;
			 * a pesquisa dos imóveis será feita a partir de sua quadra.
			 */
			if (!rota.getIndicadorRotaAlternativa().equals(
					ConstantesSistema.SIM)) {

				imoveis = repositorioFaturamento.pesquisarImovelFaturarGrupo(
						rota.getId(), numeroIndice, quantidadeRegistros,
						preFaturar, resumo);

			}
			/*
			 * Caso contrário; a pesquisa dos imóveis será feita a partir da
			 * rota alternativa que estará associada ao mesmo.
			 */
			else {

				imoveis = repositorioFaturamento
						.pesquisarImovelFaturarGrupoPorRotaAlternativa(
								rota.getId(), numeroIndice,
								quantidadeRegistros, preFaturar, resumo);

			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Carregando os dados dos imóveis selecionados
		if (imoveis != null && !imoveis.isEmpty()) {

			Iterator iteratorImoveis = imoveis.iterator();

			colecaoImoveis = new ArrayList();

			Imovel imovel = null;

			while (iteratorImoveis.hasNext()) {

				Object[] arrayImovel = (Object[]) iteratorImoveis.next();

				imovel = obterImovel(arrayImovel);

				// adiciona o imovel
				colecaoImoveis.add(imovel);
			}
		}

		return colecaoImoveis;
	}

	/*
	 *  Refatoração feita pela cosanpa, para melhorar a leitura do
	 * código.
	 */
	/**
	 * Metodo que obtem um array, com informações de um imóvel, e converte em um
	 * objeto Imovel.
	 * 
	 * @author Pamela Gatinho
	 * @date 16/12/2010
	 * 
	 * @param arrayImovel
	 * @return Imovel
	 */
	private Imovel obterImovel(Object[] arrayImovel) {
		Imovel imovel = new Imovel();

		// ligacaoAguaSituacao.id
		if (arrayImovel[0] != null) {
			LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
			ligacaoAguaSituacao.setId((Integer) arrayImovel[0]);
			ligacaoAguaSituacao
					.setIndicadorFaturamentoSituacao((Short) arrayImovel[20]);
			ligacaoAguaSituacao
					.setConsumoMinimoFaturamento((Integer) arrayImovel[22]);
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		}

		// ligacaoEsgotoSituacao.id
		if (arrayImovel[1] != null) {
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
			ligacaoEsgotoSituacao.setId((Integer) arrayImovel[1]);
			ligacaoEsgotoSituacao
					.setIndicadorFaturamentoSituacao((Short) arrayImovel[21]);
			ligacaoEsgotoSituacao
					.setVolumeMinimoFaturamento((Integer) arrayImovel[23]);
			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
		}

		// consumoTarifa.id
		if (arrayImovel[2] != null) {
			ConsumoTarifa consumoTarifa = new ConsumoTarifa();
			consumoTarifa.setId((Integer) arrayImovel[2]);
			imovel.setConsumoTarifa(consumoTarifa);
		}

		// localidade.id
		Localidade localidade = null;
		if (arrayImovel[3] != null) {
			localidade = new Localidade();
			localidade.setId((Integer) arrayImovel[3]);
			imovel.setLocalidade(localidade);

			if (arrayImovel[28] != null) {
				UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId((Integer) arrayImovel[28]);
				imovel.getLocalidade().setUnidadeNegocio(unidadeNegocio);
			}

		}

		Quadra quadra = null;

		// quadra.id
		if (arrayImovel[4] != null) {
			quadra = new Quadra();
			quadra.setId((Integer) arrayImovel[4]);
			imovel.setQuadra(quadra);
		}

		// quadra.numeroQuadra
		if (arrayImovel[5] != null) {
			quadra.setNumeroQuadra(((Integer) arrayImovel[5]).intValue());
			imovel.setQuadra(quadra);
		}

		// imovel.lote
		if (arrayImovel[6] != null) {
			imovel.setLote(((Short) arrayImovel[6]).shortValue());
		}

		// setorComercial.codigo
		SetorComercial setorComercial = null;
		if (arrayImovel[7] != null) {
			setorComercial = new SetorComercial();
			setorComercial.setCodigo(((Integer) arrayImovel[7]).intValue());
			imovel.setSetorComercial(setorComercial);

		}

		// faturamentoTipo.id
		if (arrayImovel[8] != null) {
			FaturamentoTipo faturamentoTipo = new FaturamentoTipo();
			faturamentoTipo.setId((Integer) arrayImovel[8]);
			imovel.setFaturamentoTipo(faturamentoTipo);
		}

		// imovelPerfil.id
		if (arrayImovel[9] != null) {
			ImovelPerfil imovelPerfil = new ImovelPerfil();
			imovelPerfil.setId((Integer) arrayImovel[9]);
			imovel.setImovelPerfil(imovelPerfil);
		}

		// imovel.indicadorDebitoConta
		if (arrayImovel[10] != null) {
			imovel.setIndicadorDebitoConta(((Short) arrayImovel[10])
					.shortValue());
		}

		// imovel.indicadorConta
		if (arrayImovel[11] != null) {
			ImovelContaEnvio imovelContaEnvio = new ImovelContaEnvio();
			imovelContaEnvio.setId((Integer) arrayImovel[11]);
			imovel.setImovelContaEnvio(imovelContaEnvio);
		}

		// imovel.subLote
		if (arrayImovel[12] != null) {
			imovel.setSubLote(((Short) arrayImovel[12]).shortValue());
		}

		// imovel.indicadorEmissaoExtratoFaturamento
		if (arrayImovel[13] != null) {
			imovel.setIndicadorEmissaoExtratoFaturamento((Short) arrayImovel[13]);
		}

		// imovel.localidade.gerenciaRegional
		if (arrayImovel[14] != null) {
			if (localidade == null) {
				localidade = new Localidade();
			}
			GerenciaRegional gerenciaRegional = new GerenciaRegional();
			gerenciaRegional.setId((Integer) arrayImovel[14]);
			localidade.setGerenciaRegional(gerenciaRegional);
			imovel.setLocalidade(localidade);
		}

		// imovel.setorComercial
		if (arrayImovel[15] != null) {
			if (setorComercial == null) {
				setorComercial = new SetorComercial();
			}
			setorComercial.setId((Integer) arrayImovel[15]);
			imovel.setSetorComercial(setorComercial);
		}

		// imovel.quadra.rota
		if (arrayImovel[16] != null) {
			if (quadra == null) {
				quadra = new Quadra();
			}
			Rota rotaDaQuadra = new Rota();
			rotaDaQuadra.setId((Integer) arrayImovel[16]);
			quadra.setRota(rotaDaQuadra);
			imovel.setQuadra(quadra);
		}

		if (arrayImovel[17] != null) {

			HashSet clientes = new HashSet();

			EsferaPoder esferaPoder = new EsferaPoder();
			esferaPoder.setId((Integer) arrayImovel[17]);
			ClienteTipo clienteTipo = new ClienteTipo();
			clienteTipo.setEsferaPoder(esferaPoder);
			Cliente cliente = new Cliente();
			cliente.setClienteTipo(clienteTipo);
			clientes.add(cliente);
			imovel.setClienteImoveis(clientes);

		}

		// id do imovel
		if (arrayImovel[18] != null) {
			imovel.setId((Integer) arrayImovel[18]);
		}

		// dia vencimento
		if (arrayImovel[19] != null) {
			imovel.setDiaVencimento((Short) arrayImovel[19]);
		}

		// FATURAMENTO_SITUACAO_TIPO
		if (arrayImovel[24] != null) {
			FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
			faturamentoSituacaoTipo.setId((Integer) arrayImovel[24]);

			if (arrayImovel[26] != null) {
				faturamentoSituacaoTipo
						.setIndicadorParalisacaoFaturamento((Short) arrayImovel[26]);
			}

			if (arrayImovel[27] != null) {
				faturamentoSituacaoTipo
						.setIndicadorValidoAgua((Short) arrayImovel[27]);
			}

			imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
		}

		// indicador vencimento mês seguinte
		if (arrayImovel[25] != null) {
			imovel.setIndicadorVencimentoMesSeguinte((Short) arrayImovel[25]);
		}

		// Hidrômetro Água
		if (arrayImovel[29] != null) {
			LigacaoAgua ligacaoAgua = new LigacaoAgua();
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
			hidrometroInstalacaoHistorico.setId((Integer) arrayImovel[29]);
			ligacaoAgua
					.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
			imovel.setLigacaoAgua(ligacaoAgua);
		}

		// Hidrômetro Poço
		if (arrayImovel[30] != null) {
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
			hidrometroInstalacaoHistorico.setId((Integer) arrayImovel[30]);
			imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
		}

		// Id imóvel condominio
		if (arrayImovel[31] != null) {
			try {

				Imovel imovelCondominio = getControladorImovel()
						.pesquisarImovel((Integer) arrayImovel[31]);

				imovel.setImovelCondominio(imovelCondominio);

			} catch (ControladorException e) {
				e.printStackTrace();
			}
		}

		// Quantidade de economias
		if (arrayImovel[32] != null) {
			imovel.setQuantidadeEconomias((Short) arrayImovel[32]);
		}

		/**
		 * data:08/08/2012 Adicionando parametros do array ao
		 * objeto imovel Inclusão para atender as alterações no calculo do
		 * condominio
		 * */
		if (arrayImovel[33] != null) {
			imovel.setIndicadorImovelCondominio((Short) arrayImovel[33]);
		}

		return imovel;
	}

	public void removerFaturamentoCronograma(String[] ids,
			String pacoteNomeObjeto) throws ControladorException {
		// se for selecionado alguma unidade executora pelo usuário
		if (ids != null && ids.length != 0) {

			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
			Collection colecaoFaturamentoAtividadeCronograma = null;
			// remove todas as unidade executoras informadas
			for (int i = 0; i < ids.length; i++) {
				// atribui a variável "id" o código da unidade executora para
				// remoção
				int id = Integer.parseInt(ids[i]);

				filtroFaturamentoAtividadeCronograma
						.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID,
								ids[i]));
				filtroFaturamentoAtividadeCronograma
						.adicionarParametro(new ParametroNaoNulo(
								FiltroFaturamentoAtividadeCronograma.DATA_REALIZADA));

				colecaoFaturamentoAtividadeCronograma = getControladorUtil()
						.pesquisar(filtroFaturamentoAtividadeCronograma,
								FaturamentoAtividadeCronograma.class.getName());
				if (!colecaoFaturamentoAtividadeCronograma.isEmpty()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.faturamento.exclusao_nao_permitida");
				} else {
					// chama o metódo de remover do util
					try {
						repositorioFaturamento
								.removerFaturamentoGrupoAtividades(id);
					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						e.printStackTrace();
					}

					/*
					 * FaturamentoGrupoCronogramaMensal
					 * faturamentoGrupoCronogramaMensal = new
					 * FaturamentoGrupoCronogramaMensal();
					 * faturamentoGrupoCronogramaMensal
					 * .setFaturamentoAtividadeCronogramas
					 * (Collections.EMPTY_SET);
					 * faturamentoGrupoCronogramaMensal.setId(id);
					 * getControladorUtil
					 * ().remover(faturamentoGrupoCronogramaMensal);
					 */
				}
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Pesquisa a conta do imóvel com a referência informada pelo usuário
	 * 
	 * [FS0012] - Verificar existência da conta
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param idImovel
	 * @param referenciaConta
	 * @return
	 * @throws ControladorException
	 */
	public Conta pesquisarContaDigitada(String idImovel, String referenciaConta)
			throws ControladorException {

		// Variável que vai armazenar a conta pesquisada
		Conta contaDigitada = null;
		Object[] dadosConta = null;

		// Formata a referência da conta informada para o formato (AAAAMM) sem a
		// barra
		String anoMesConta = Util
				.formatarMesAnoParaAnoMesSemBarra(referenciaConta);

		// Cria o filtro de conta e seta todos os parâmetros para pesquisar a
		// conta do imóvel
		// Pesquisa imovel
		try {
			dadosConta = repositorioFaturamento.pesquisarContaDigitada(
					idImovel, anoMesConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (dadosConta != null) {

			contaDigitada = new Conta();

			// Id da Conta
			if (dadosConta[0] != null) {
				contaDigitada.setId((Integer) dadosConta[0]);
			}

			// Referência
			if (dadosConta[1] != null) {
				contaDigitada.setReferencia((Integer) dadosConta[1]);
			}

			// Valor da Água
			if (dadosConta[2] != null) {
				contaDigitada.setValorAgua((BigDecimal) dadosConta[2]);
			}

			// Valor de Esgoto
			if (dadosConta[3] != null) {
				contaDigitada.setValorEsgoto((BigDecimal) dadosConta[3]);
			}

			// Débitos
			if (dadosConta[4] != null) {
				contaDigitada.setDebitos((BigDecimal) dadosConta[4]);
			}

			// Valor Créditos
			if (dadosConta[5] != null) {
				contaDigitada.setValorCreditos((BigDecimal) dadosConta[5]);
			}

			// Valor Imposto
			if (dadosConta[6] != null) {
				contaDigitada.setValorImposto((BigDecimal) dadosConta[6]);
			}

			// Localidade
			if (dadosConta[7] != null) {
				Localidade localidade = new Localidade();
				localidade.setId((Integer) dadosConta[7]);
				contaDigitada.setLocalidade(localidade);
			}

			// Débito Crédito Situação
			if (dadosConta[8] != null && dadosConta[9] != null) {
				DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
				debitoCreditoSituacao.setId((Integer) dadosConta[8]);
				debitoCreditoSituacao
						.setDescricaoAbreviada((String) dadosConta[9]);
				contaDigitada
						.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
			}

			// Valor Imposto
			if (dadosConta[10] != null) {
				contaDigitada.setDataVencimentoConta((Date) dadosConta[10]);
			}

		}

		// FiltroConta filtroConta = new FiltroConta();
		// filtroConta.adicionarParametro(new ParametroSimples(
		// FiltroConta.IMOVEL_ID, idImovel));
		// filtroConta.adicionarParametro(new ParametroSimples(
		// FiltroConta.REFERENCIA, anoMesConta));
		// filtroConta.adicionarParametro(new ParametroSimples(
		// FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL,
		// DebitoCreditoSituacao.NORMAL, ParametroSimples.CONECTOR_OR, 3));
		// filtroConta
		// .adicionarParametro(new ParametroSimples(
		// FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL,
		// DebitoCreditoSituacao.RETIFICADA,
		// ParametroSimples.CONECTOR_OR));
		// filtroConta.adicionarParametro(new ParametroSimples(
		// FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL,
		// DebitoCreditoSituacao.INCLUIDA));
		// Collection colecaoContas =
		// getControladorUtil().pesquisar(filtroConta,
		// Conta.class.getName());
		//
		// // Caso exista a conta para a referência informada cadastrada no
		// sistema
		// // Retorna para o usuário a conta retornada pela pesquisa
		// // Caso contrário retorna um objeto nulo
		// if (colecaoContas != null && !colecaoContas.isEmpty()) {
		// contaDigitada = (Conta) Util.retonarObjetoDeColecao(colecaoContas);
		// }

		// Retorna a conta encontrada ou nulo se não existir a conta
		return contaDigitada;
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Pesquisa o tipo de débito informado pelo usuário
	 * 
	 * [FS0020] - Verificar existência do tipo de débito
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param idTipoDebitoDigitado
	 * @return
	 * @throws ControladorException
	 */
	public DebitoTipo pesquisarTipoDebitoDigitado(Integer idTipoDebitoDigitado)
			throws ControladorException {

		// Cria a variável que vai armazenar o tipo de débito pesquisado
		DebitoTipo tipoDebitoDigitado = null;

		// Pesquisa o tipo de débito informado pelo usuário no sistema
		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.ID, idTipoDebitoDigitado));
		Collection<DebitoTipo> colecaoDebitoTipo = getControladorUtil()
				.pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

		// Caso exista o tipo de débito no sistema
		// Retorna para o usuário o tipo de débito retornado pela pesquisa
		// Caso contrário retorna um objeto nulo
		if (colecaoDebitoTipo != null && !colecaoDebitoTipo.isEmpty()) {
			tipoDebitoDigitado = (DebitoTipo) Util
					.retonarObjetoDeColecao(colecaoDebitoTipo);
		}

		// Retorna o cliente encontrado ou nulo se não existir
		return tipoDebitoDigitado;
	}

	/**
	 * Permite executar as atividades do faturamento previamente comandadas
	 * 
	 * [UC0111] Executar Atividade do Faturamento
	 * 
	 * Lista as atividades de faturamento do cronograma que foram comandadas
	 * 
	 * obterAtividadesFaturamentoCronogramaComandada
	 * 
	 * @author Raphael Rossiter, Roberta Costa
	 * @date 29/03/2006, 29/04/20004
	 * 
	 * @return Collection<ExecutarAtividadeFaturamentoHelper>
	 * @throws ControladorException
	 */
	public Collection<ExecutarAtividadeFaturamentoHelper> obterAtividadesFaturamentoCronogramaComandada(
			Integer numeroPagina) throws ControladorException {

		Collection retorno = new ArrayList();

		/*
		 * 2. Para cada grupo de faturamento (a partir da tabela
		 * FATURAMENTO_GRUPO) o sistema seleciona o cronograma de faturamento do
		 * mês corrente (a partir da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL
		 * com FTCM_AMREFERENCIA = FTGR_AMREFERENCIA e FTGR_ID = FTGR_ID da
		 * tabela FATURAMENTO_GRUPO)
		 */
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo(
				FiltroFaturamentoGrupo.ID);
		filtroFaturamentoGrupo.setConsultaSemLimites(true);

		Collection colecaoFaturamentoGrupo = getControladorUtil().pesquisar(
				filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

		// [FS0001] - Verificar existência de dados
		/*
		 * if (colecaoFaturamentoGrupo == null ||
		 * colecaoFaturamentoGrupo.isEmpty()) { throw new ControladorException(
		 * "atencao.pesquisa.nenhum_registro_tabela", null,
		 * "FATURAMENTO_GRUPO"); }
		 */
		// [FS0002] - Verificar existência do cronograma
		if (colecaoFaturamentoGrupo == null
				|| colecaoFaturamentoGrupo.isEmpty()) {
			throw new ControladorException(
					"atencao.pesquisa.cronograma_mensal_grupo_mes_corrente_inexistente",
					null);
		}

		// Faz a consulta das Atividades
		Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada = null;
		boolean existeAtividadeFaturamentoComandada = false;
		ExecutarAtividadeFaturamentoHelper executarAtividadeFaturamentoHelper = null;
		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = null;
		try {
			colecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada = repositorioFaturamento
					.pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizada(numeroPagina);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		// A partir da consulta montar a coleção de Atividades não realizadas
		if (colecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada != null) {
			existeAtividadeFaturamentoComandada = true;
			Iterator iteratorColecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada = colecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada
					.iterator();

			while (iteratorColecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada
					.hasNext()) {

				faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iteratorColecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada
						.next();

				executarAtividadeFaturamentoHelper = new ExecutarAtividadeFaturamentoHelper();

				executarAtividadeFaturamentoHelper
						.setIdFaturamentoAtividadeCronograma(faturamentoAtividadeCronograma
								.getId());
				executarAtividadeFaturamentoHelper
						.setIdGrupoFaturamento(faturamentoAtividadeCronograma
								.getFaturamentoGrupoCronogramaMensal()
								.getFaturamentoGrupo().getId());
				executarAtividadeFaturamentoHelper
						.setAnoMesFaturamento(faturamentoAtividadeCronograma
								.getFaturamentoGrupoCronogramaMensal()
								.getFaturamentoGrupo().getAnoMesReferencia());
				executarAtividadeFaturamentoHelper
						.setDescricaoAtividade(faturamentoAtividadeCronograma
								.getFaturamentoAtividade().getDescricao());
				executarAtividadeFaturamentoHelper
						.setDataPrevista(faturamentoAtividadeCronograma
								.getDataPrevista());
				executarAtividadeFaturamentoHelper
						.setComando(faturamentoAtividadeCronograma.getComando());

				retorno.add(executarAtividadeFaturamentoHelper);
			}
		}

		// [FS0003] - Verificar existência de atividade comandada
		if (!existeAtividadeFaturamentoComandada) {
			throw new ControladorException(
					"atencao.pesquisa.cronograma_atividade_mes_corrente_inexistente",
					null, String.valueOf(faturamentoAtividadeCronograma
							.getFaturamentoGrupoCronogramaMensal()
							.getFaturamentoGrupo().getId()));
		}

		return retorno;
	}

	/**
	 * Retorna o count do resultado da pesquisa de Faturamento Atividade
	 * Cronograma
	 * 
	 * pesquisarFaturamentoAtividadeCronogramaCount
	 * 
	 * @author Roberta Costa
	 * @date 05/05/2006
	 * 
	 * @param FaturamentoGrupoCronogramaMensal
	 *            faturamentoGrupoCronogramaMensal
	 * @param Integer
	 *            numeroPagina
	 * @return Integer retorno
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizadaCount()
			throws ControladorException {
		Integer totalRegistros = null;
		try {
			totalRegistros = repositorioFaturamento
					.pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizadaCount();
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return totalRegistros;
	}

	/**
	 * Permite executar as atividades do faturamento previamente comandadas
	 * 
	 * [UC0111] Executar Atividade do Faturamento
	 * 
	 * Executa as atividade do Faturamento
	 * 
	 * executarAtividadeFaturamento
	 * 
	 * @author Roberta Costa
	 * @date 03/05/20006
	 * 
	 * @param idsFaturamentoAtividadeCronograma
	 * @throws ControladorException
	 */
	public void executarAtividadeFaturamento(String[] idsFaturamentoAtividadeCronograma) throws ControladorException {
		// Caso alguma atividade de faturamento tenha sido maracada
		if (idsFaturamentoAtividadeCronograma != null) {

			getControladorUtil().pesquisarParametrosDoSistema();

			// 6. Para cada atividade de faturamento do cronograma selecionada
			for (int i = 0; idsFaturamentoAtividadeCronograma.length > i; i++) {
				// 6.1. Seleciona as rotas que foram comandadas para esta
				// atividade ( a partir
				// da tabela FATURAMENTO_ATIV_CRON_ROTA com FTAC_ID = FTAC_ID da
				// tabela
				// FATURAMENTO_ATIVIDADE_CRONOGRAMA
				FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();

				filtroFaturamentoAtivCronRota.adicionarParametro(
						new ParametroSimples(FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_ID,
								idsFaturamentoAtividadeCronograma[i]));
				Collection<FaturamentoAtivCronRota> colecaoFaturamentoAtivCronRota = getControladorUtil()
						.pesquisar(filtroFaturamentoAtivCronRota, FaturamentoAtivCronRota.class.getName());

				Collection<Rota> colecaoRotasFaturamento = new ArrayList();
				if (colecaoFaturamentoAtivCronRota != null && !colecaoFaturamentoAtivCronRota.equals("")) {
					Iterator faturamentoAtivCronRotaValores = colecaoFaturamentoAtivCronRota.iterator();

					while (faturamentoAtivCronRotaValores.hasNext()) {
						FaturamentoAtivCronRota faturamentoAtivCronRota = (FaturamentoAtivCronRota) faturamentoAtivCronRotaValores.next();
						FiltroRota filtroRota = new FiltroRota();

						filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.ID_ROTA, faturamentoAtivCronRota.getRota().getId()));

						Collection<Rota> colecaoRotas = getControladorUtil().pesquisar(filtroRota, Rota.class.getName());
						if (colecaoRotas != null && !colecaoRotas.equals("")) {
							Rota rota = (Rota) Util.retonarObjetoDeColecao(colecaoRotas);
							colecaoRotasFaturamento.add(rota);
						}
					}
				}

				FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

				filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtividadeCronograma.ID, idsFaturamentoAtividadeCronograma[i]));

				Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronograma = getControladorUtil()
						.pesquisar(filtroFaturamentoAtividadeCronograma, FaturamentoAtividadeCronograma.class.getName());

				if (colecaoFaturamentoAtividadeCronograma != null && !colecaoFaturamentoAtividadeCronograma.isEmpty()) {
					Iterator faturamentoAtividadeCronogramaValores = colecaoFaturamentoAtividadeCronograma.iterator();

					while (faturamentoAtividadeCronogramaValores.hasNext()) {

						FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) faturamentoAtividadeCronogramaValores
								.next();

						// Faturamento Grupo Cronograma Mensal
						FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

						filtroFaturamentoGrupoCronogramaMensal
								.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupoCronogramaMensal.ID,
										faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal().getId()));

						Collection<FaturamentoGrupoCronogramaMensal> colecaoFaturamentoGrupoCronogramaMensal = getControladorUtil()
								.pesquisar(filtroFaturamentoGrupoCronogramaMensal,
										FaturamentoGrupoCronogramaMensal.class.getName());

						FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal = null;

						if (colecaoFaturamentoGrupoCronogramaMensal != null
								&& !colecaoFaturamentoGrupoCronogramaMensal.isEmpty()) {
							faturamentoGrupoCronogramaMensal = (FaturamentoGrupoCronogramaMensal) Util
									.retonarObjetoDeColecao(colecaoFaturamentoGrupoCronogramaMensal);
						}

						// 6.2. Chama o Caso de Uso responsável pela atividade e
						// passando os parâmetros de
						// acordo com as atividades abaixo, passando a lista de
						// rotas selecionadas, ano/mês
						// do faturamento corrente (FTCM_AMREFERENCIA), grupo de
						// faturamento e atividade a
						// ser executada
						if (faturamentoAtividadeCronograma.getFaturamentoAtividade().getId().equals(FaturamentoAtividade.GERAR_ARQUIVO_LEITURA)) {
							atualizarDataHoraRealizacaoAtividadeFaturamento(faturamentoAtividadeCronograma,
									faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
									FaturamentoAtividade.GERAR_ARQUIVO_LEITURA);
						} else if (faturamentoAtividadeCronograma.getFaturamentoAtividade().getId().equals(FaturamentoAtividade.CONSISTIR_LEITURAS_E_CALCULAR_CONSUMOS)) {
							atualizarDataHoraRealizacaoAtividadeFaturamento(faturamentoAtividadeCronograma,
									faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
									FaturamentoAtividade.CONSISTIR_LEITURAS_E_CALCULAR_CONSUMOS);
						} else if (faturamentoAtividadeCronograma.getFaturamentoAtividade().getId().equals(FaturamentoAtividade.SIMULAR_FATURAMENTO)) {
							atualizarDataHoraRealizacaoAtividadeFaturamento(faturamentoAtividadeCronograma,
									faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
									FaturamentoAtividade.SIMULAR_FATURAMENTO);
						} else if (faturamentoAtividadeCronograma.getFaturamentoAtividade().getId().equals(FaturamentoAtividade.FATURAR_GRUPO)) {
							atualizarDataHoraRealizacaoAtividadeFaturamento(faturamentoAtividadeCronograma,
									faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
									FaturamentoAtividade.FATURAR_GRUPO);
						}
					}
				}
			}
		}
	}

	/**
	 * Permite executar as atividades do faturamento previamente comandadas
	 * 
	 * [UC0111] Executar Atividade do Faturamento
	 * 
	 * Atualiza Data Hora da Realização da Atividade de Faturamento
	 * 
	 * atualizarDataHoraRealizacaoAtividadeFaturamento
	 * 
	 * @author Roberta Costa
	 * @date 03/05/20006
	 * 
	 * @param faturamentoAtividadeCronograma
	 * @param faturamentoAtividadeId
	 * @throws ControladorException
	 */
	public void atualizarDataHoraRealizacaoAtividadeFaturamento(
			FaturamentoAtividadeCronograma faturamentoAtividadeCronograma,
			FaturamentoGrupo faturamentoGrupo, Integer faturamentoAtividadeId)
			throws ControladorException {

		faturamentoAtividadeCronograma.setDataRealizacao(new Date());
		faturamentoAtividadeCronograma.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(faturamentoAtividadeCronograma);

		if (faturamentoAtividadeId.equals(FaturamentoAtividade.FATURAR_GRUPO)) {
			// Util.obterMes()
			faturamentoGrupo.setAnoMesReferencia(faturamentoGrupo
					.getAnoMesReferencia());
			faturamentoGrupo.setUltimaAlteracao(new Date());

			getControladorUtil().atualizar(
					Util.somaUmMesAnoMesReferencia(faturamentoGrupo
							.getAnoMesReferencia()));
		}
	}

	/**
	 * 
	 * Inserir Debito A Cobrar para o Imovel
	 * 
	 * [UC0183] - Inserir Debito a Cobrar
	 * 
	 * @author Rafael Santos
	 * @date 01/04/2006
	 * 
	 * @param idDebitoTipo
	 * @return
	 */
	public DebitoTipo pesquisarDebitoTipo(String idDebitoTipo)
			throws ControladorException {
		DebitoTipo debitoTipo = null;
		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.ID, idDebitoTipo));

		Collection colecaoDebitoTipo = this.getControladorUtil().pesquisar(
				filtroDebitoTipo, DebitoTipo.class.getName());
		if (colecaoDebitoTipo != null && !colecaoDebitoTipo.isEmpty()) {
			debitoTipo = (DebitoTipo) colecaoDebitoTipo.iterator().next();
		}

		return debitoTipo;
	}

	/**
	 * O sistema seleciona os grupos de faturamento que possuem cronograma para
	 * o mês corrente * [UC0144] Inserir Comando Atividade de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 03/03/2006
	 * 
	 * @return Collection<FaturamentoGrupo>
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoGrupo> pesquisarFaturamentoGrupoComCronogramaMensalParaMesCorrente()
			throws ControladorException {

		Collection<FaturamentoGrupo> retorno = new ArrayList();

		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo(
				FiltroFaturamentoGrupo.DESCRICAO);

		filtroFaturamentoGrupo.setConsultaSemLimites(true);

		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
				FiltroFaturamentoGrupo.INDICADOR_USO,
				ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection colecaoFaturamentoGrupo = this.getControladorUtil()
				.pesquisar(filtroFaturamentoGrupo,
						FaturamentoGrupo.class.getName());

		// [FS0001] - Verificar existência de dados
		if (colecaoFaturamentoGrupo == null
				|| colecaoFaturamentoGrupo.isEmpty()) {
			throw new ControladorException(
					"atencao.pesquisa.nenhum_registro_tabela", null,
					"FATURAMENTO_GRUPO");
		}

		Iterator iteratorColecaoFaturamentoGrupo = colecaoFaturamentoGrupo
				.iterator();
		FaturamentoGrupo faturamentoGrupo = null;
		Integer idFaturamentoGrupoCronogramaMensal;

		while (iteratorColecaoFaturamentoGrupo.hasNext()) {

			faturamentoGrupo = (FaturamentoGrupo) iteratorColecaoFaturamentoGrupo
					.next();
			idFaturamentoGrupoCronogramaMensal = null;

			try {

				idFaturamentoGrupoCronogramaMensal = repositorioFaturamento
						.pesquisarFaturamentoGrupoCronogramaMensal(
								faturamentoGrupo.getId(),
								faturamentoGrupo.getAnoMesReferencia());

			} catch (ErroRepositorioException ex) {
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}

			if (idFaturamentoGrupoCronogramaMensal != null) {
				retorno.add(faturamentoGrupo);
			}

		}

		// [FS0003] - Verificar seleção de pelo menos um grupo de faturamento
		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException(
					"atencao.pesquisa.nenhum.faturamento_grupo_com_cronograma_mensal");
		}

		return retorno;
	}

	/**
	 * Este caso de uso inicia um processo para o mecanismo batch
	 * 
	 * [UC0111] - Iniciar Processo
	 * 
	 * Este subfluxo tem o papel de iniciar um processo de faturamento
	 * comandado, neste método é feita uma busca para obter as atividades
	 * comandadas e não realizadas
	 * 
	 * [SB0001] - Iniciar Processo de Faturamento Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 14/08/2006
	 * 
	 * @return
	 * @throws ControladorException
	 */

	public Collection<FaturamentoAtividadeCronograma> pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadas(
			int numeroPagina) throws ControladorException {

		Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramas = null;
		try {
			colecaoFaturamentoAtividadeCronogramas = this.repositorioFaturamento
					.pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadas(numeroPagina);

			// [FS0003] - Verificar existência de Atividade Comandada
			if (colecaoFaturamentoAtividadeCronogramas == null
					|| colecaoFaturamentoAtividadeCronogramas.isEmpty()) {
				throw new ControladorException(
						"atencao.pesquisa.atividade_comandada_inexistente");
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoFaturamentoAtividadeCronogramas;
	}

	/**
	 * Este caso de uso inicia um processo para o mecanismo batch
	 * 
	 * [UC0111] - Iniciar Processo
	 * 
	 * Este subfluxo tem o papel de iniciar um processo de faturamento
	 * comandado, neste método é feita uma busca para obter as atividades
	 * comandadas e não realizadas
	 * 
	 * [SB0001] - Iniciar Processo de Faturamento Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 14/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadasCount()
			throws ControladorException {
		int retorno = 0;
		try {
			retorno = this.repositorioFaturamento
					.pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadasCount();

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * O sistema seleciona os grupos de faturamento que possuem cronograma para
	 * o mês corrente
	 * 
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * 
	 * Caso esteja no atualizar pode escolher todos os grupos exceto o
	 * selecionado para atualização
	 * 
	 * pesquisarFaturamentoGrupoComCronogramaMensalParaMesCorrenteSemGupoSelecionado
	 * 
	 * @author Roberta Costa
	 * @date 20/07/2006
	 * 
	 * @return Collection<FaturamentoGrupo>
	 * @throws ControladorException
	 */
	public Collection<FaturamentoGrupo> pesquisarFaturamentoGrupoComCronogramaMensalParaMesCorrenteSemGupoSelecionado(
			Integer grupoSelecionado) throws ControladorException {

		Collection<FaturamentoGrupo> retorno = new ArrayList();

		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo(
				FiltroFaturamentoGrupo.DESCRICAO);

		filtroFaturamentoGrupo.setConsultaSemLimites(true);

		filtroFaturamentoGrupo
				.adicionarParametro(new ParametroSimplesDiferenteDe(
						FiltroFaturamentoGrupo.ID, grupoSelecionado));

		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
				FiltroFaturamentoGrupo.INDICADOR_USO,
				ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection colecaoFaturamentoGrupo = this.getControladorUtil()
				.pesquisar(filtroFaturamentoGrupo,
						FaturamentoGrupo.class.getName());

		// [FS0001] - Verificar existência de dados
		if (colecaoFaturamentoGrupo == null
				|| colecaoFaturamentoGrupo.isEmpty()) {
			throw new ControladorException(
					"atencao.pesquisa.nenhum_registro_tabela", null,
					"FATURAMENTO_GRUPO");
		}

		Iterator iteratorColecaoFaturamentoGrupo = colecaoFaturamentoGrupo
				.iterator();
		FaturamentoGrupo faturamentoGrupo = null;
		Integer idFaturamentoGrupoCronogramaMensal;

		while (iteratorColecaoFaturamentoGrupo.hasNext()) {

			faturamentoGrupo = (FaturamentoGrupo) iteratorColecaoFaturamentoGrupo
					.next();
			idFaturamentoGrupoCronogramaMensal = null;

			try {

				idFaturamentoGrupoCronogramaMensal = repositorioFaturamento
						.pesquisarFaturamentoGrupoCronogramaMensal(
								faturamentoGrupo.getId(),
								faturamentoGrupo.getAnoMesReferencia());

			} catch (ErroRepositorioException ex) {
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}

			if (idFaturamentoGrupoCronogramaMensal != null) {
				retorno.add(faturamentoGrupo);
			}

		}

		// [FS0003] - Verificar seleção de pelo menos um grupo de faturamento
		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException(
					"atencao.pesquisa.nenhum.faturamento_grupo_com_cronograma_mensal");
		}

		return retorno;
	}

	/**
	 * [UC0209] Gerar Taxa de Entrega de Conta em Outro Endereço
	 * 
	 * @author Pedro Alexandre, Raphael Rossiter
	 * @date 12/02/2007, 26/08/2009
	 * 
	 * @param rota
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection<Imovel> obterImoveisPorRotasComContaEntregaEmOutroEndereco(Rota rota) throws ControladorException {
		if (!rota.getIndicadorRotaAlternativa().equals(ConstantesSistema.SIM)) {
			try {
				return repositorioFaturamento.obterImoveisPorRotasComContaEntregaEmOutroEndereco(rota.getId());
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}
		else {
			try {
				return repositorioFaturamento.obterImoveisPorRotasComContaEntregaEmOutroEnderecoPorRotaAlternativa(rota.getId());
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}
	}

	public DebitoTipo getDebitoTipoHql(Integer idDebitoTipo)
			throws ControladorException {

		Object[] dados = null;

		try {

			dados = this.repositorioFaturamento.getDebitoTipoHql(idDebitoTipo);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		DebitoTipo debitoTipo = new DebitoTipo();

		if (dados != null) {

			// Id Débito Tipo
			if (dados[0] != null) { // 0
				debitoTipo.setId(((Integer) dados[0]));
			}

			// Id Financiamento Tipo
			if (dados[1] != null) { // 1
				FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
				financiamentoTipo.setId(((Integer) dados[1]));
				debitoTipo.setFinanciamentoTipo(financiamentoTipo);
			}

			// Id Lançamento Item Contábil
			if (dados[2] != null) { // 2
				LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
				lancamentoItemContabil.setId(((Integer) dados[2]));
				debitoTipo.setLancamentoItemContabil(lancamentoItemContabil);
			}

			// Valor Sugerido do DebitoTipo - Alterado Por Tiago Moreno -
			// 22/12/2009
			if (dados[3] != null) { // 3
				debitoTipo.setValorSugerido((BigDecimal) dados[3]);
			}
		}

		return debitoTipo;
	}

	/**
	 * 
	 * Este caso de uso permite gerar taxa de entrega de conta em outro endereço
	 * para os imóveis das quadras pertencentes às rotas de um grupo de
	 * faturamento.
	 * 
	 * [UC0209] Gerar Taxa de Entrega de Conta em Outro Endereço
	 * 
	 * @author Thiago Toscano, Pedro Alexandre, Tiago Moreno
	 * @date 03/04/2006, 30/08/2006, 22/12/2009
	 * 
	 * @param rotas
	 * @throws ControladorException
	 */
	public void gerarTaxaEntregaDeContaEmOutroEndereco(Collection<Rota> rotas, Integer anoMesFaturamento, int idFuncionalidadeIniciada) throws ControladorException {
		int idUnidadeIniciada = 0;
		
		try {

			idUnidadeIniciada = getControladorBatch()
					.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.ROTA,
							((Rota) Util.retonarObjetoDeColecao(rotas)).getId());

			// Cria o iterator para rotas
			Iterator colecaoRotaIterator = rotas.iterator();

			// Obtém o valor da Tarifa Normal
			BigDecimal valorMinimaTarifaNormal = this.repositorioFaturamento.obterValorTarifa(ConsumoTarifa.CONSUMO_NORMAL);

			// Caso o valor da tarifa normal esteja nulo seta o valor para zero
			if (valorMinimaTarifaNormal == null) {
				valorMinimaTarifaNormal = new BigDecimal("0");
			}

			// Obtém o valor da Tarifa Social
			BigDecimal valorMinimaTarifaSocial = this.repositorioFaturamento.obterValorTarifa(ConsumoTarifa.CONSUMO_SOCIAL);

			// Caso o valor da tarifa social esteja nulo seta o valor para zero
			if (valorMinimaTarifaSocial == null) {
				valorMinimaTarifaSocial = new BigDecimal("0");
			}

			// Recupera os parametros do sistema
			SistemaParametro sistema = getControladorUtil().pesquisarParametrosDoSistema();

			// Instância a forma de cobrança para cobrança em conta
			CobrancaForma cobrancaForma = new CobrancaForma();
			cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

			// Instância a situação do débito para normal
			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

			// Recupera o tipo de débito referente a despesa postal
			DebitoTipo debitoTipo = this.getDebitoTipoHql(DebitoTipo.DESPESA_POSTAL);

			// Cria as coleções que iram armazenar os débitos a cobrar e os
			// débitos a cobrar por categoria
			Collection colecaoDebitosACobrarAtualizar = new ArrayList();
			Collection colecaoDebitosACobrarInserir = new ArrayList();
			Collection colecaoDebitosACobrarCategoriasInserir = new ArrayList();

			// Laço para recuperar todos os imóveis de cada rota informada
			while (colecaoRotaIterator.hasNext()) {

				// Recupera a rota
				Rota rota = (Rota) colecaoRotaIterator.next();
				
				// Obtém os imóveis pertencentes a rota
				Collection<Imovel> colecaoImoveis = this.obterImoveisPorRotasComContaEntregaEmOutroEndereco(rota);

				/*
				 * Caso exista algum imóvel com entrega em outro endereço
				 * cadastrado para a rota cria o débito para o imóvel. Caso
				 * contrário verifica a próxima rota.
				 */
				Date dataAtual = new Date(System.currentTimeMillis());

				for (Imovel imovel : colecaoImoveis) {

					// LIGACAO_TIPO_AGUA
					LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
					ligacaoTipoAgua.setId(LigacaoTipo.LIGACAO_AGUA);

					// CONSUMO_HISTORICO_AGUA
					ConsumoHistorico consumoHistoricoAgua = this.getControladorMicromedicao()
							.obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipoAgua, anoMesFaturamento);

					Integer consumoAgua = null;
					ConsumoTipo consumoTipoAgua = null;

					if (consumoHistoricoAgua != null) {
						consumoAgua = consumoHistoricoAgua.getNumeroConsumoFaturadoMes();
						consumoTipoAgua = consumoHistoricoAgua.getConsumoTipo();
					}

					// LIGACAO_TIPO_ESGOTO
					LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
					ligacaoTipoEsgoto.setId(LigacaoTipo.LIGACAO_ESGOTO);

					// CONSUMO_HISTORICO_ESGOTO
					ConsumoHistorico consumoHistoricoEsgoto = this.getControladorMicromedicao()
							.obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipoEsgoto, anoMesFaturamento);

					Integer consumoEsgoto = null;
					ConsumoTipo consumoTipoEsgoto = null;

					if (consumoHistoricoEsgoto != null) {
						consumoEsgoto = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
						consumoTipoEsgoto = consumoHistoricoEsgoto.getConsumoTipo();
					}

					if (imovel.paralizadoSemRealizacaoLeitura()) {
						continue;
					}

					if (!this.permiteFaturamentoParaAgua(imovel.getLigacaoAguaSituacao(), consumoAgua, consumoTipoAgua)
							&& !this.permiteFaturamentoParaEsgoto(imovel.getLigacaoEsgotoSituacao(), consumoEsgoto, consumoTipoEsgoto)) {
						if (!this.verificarNaoGeracaoConta(imovel, BigDecimal.ZERO, BigDecimal.ZERO, anoMesFaturamento, false)) {
							continue;
						}
					}
					// //////////////////////////////////////////////////////

					// Verifica se já existe débito para este imóvel
					Object[] dadoDebitoACobrar = this.repositorioFaturamento.pesquisarDebitoACobrar(imovel.getId(),	debitoTipo.getId(), anoMesFaturamento);

					BigDecimal valorFinal = BigDecimal.ZERO;

					// Seleciona o DebitoTipo da constante 11
					FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.CODIGO_CONSTANTE, 11));

					DebitoTipo debitoTipo2 = (DebitoTipo) Util.retonarObjetoDeColecao(
							getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName()));

					if (debitoTipo2 != null) {
						// Seleciona o Debito Tipo Vigencia
						FiltroDebitoTipoVigencia filtroDebitoTipoVigencia = new FiltroDebitoTipoVigencia();
						filtroDebitoTipoVigencia.adicionarParametro(
								new ParametroSimples(FiltroDebitoTipoVigencia.DEBITO_TIPO_ID, debitoTipo2.getId()));
						filtroDebitoTipoVigencia
								.setCampoOrderBy(FiltroDebitoTipoVigencia.DATA_VIGENCIA_FINAL + " DESC");

						DebitoTipoVigencia debitoTipoVigencia = (DebitoTipoVigencia) Util.retonarObjetoDeColecao(
								this.getControladorUtil().limiteMaximoFiltroPesquisa(filtroDebitoTipoVigencia,
										DebitoTipoVigencia.class.getName(), 1));

						if (debitoTipoVigencia != null) {
							valorFinal = debitoTipoVigencia.getValorDebito();
						} else {
							if (debitoTipo.getValorSugerido() != null
									&& !debitoTipo.getValorSugerido().equals(ConstantesSistema.VALOR_ZERO)) {
								valorFinal = debitoTipo.getValorSugerido();
							} else {
								valorFinal = BigDecimal.ZERO;
							}
						}
					}

					if (valorFinal != null && valorFinal.compareTo(BigDecimal.ZERO) == 1) {

						// Cria uma instância de débito a cobrar
						DebitoACobrar debitoACobrar = new DebitoACobrar();

						// Seta o Imóvel
						debitoACobrar.setImovel(imovel);

						// Seta o Débito Tipo
						debitoACobrar.setDebitoTipo(debitoTipo);

						// Seta Data e Hora Atual
						debitoACobrar.setGeracaoDebito(dataAtual);

						// Seta Ano/Mês do Faturamento Corrente
						debitoACobrar.setAnoMesReferenciaDebito(anoMesFaturamento);

						// Seta Ano/Mês de Cobrança
						debitoACobrar.setAnoMesCobrancaDebito(sistema.getAnoMesArrecadacao());

						// Seta Ano/Mês Referência do Faturamento
						Integer anoMesAtual = Util.getAnoMesComoInteger(new Date());
						Integer anoMesParametros = sistema.getAnoMesFaturamento();
						if (anoMesParametros > anoMesAtual) {
							debitoACobrar.setAnoMesReferenciaContabil(anoMesParametros);
						} else {
							debitoACobrar.setAnoMesReferenciaContabil(anoMesAtual);
						}

						// Seta Valor do Débito
						debitoACobrar.setValorDebito(valorFinal);

						// Seta Número de Prestações do Débito
						debitoACobrar.setNumeroPrestacaoDebito(new Short("1"));

						// Seta Número de Prestações Cobradas
						debitoACobrar.setNumeroPrestacaoCobradas(new Short("0"));

						// Seta Localidade
						debitoACobrar.setLocalidade(imovel.getLocalidade());

						// Seta Quadra
						debitoACobrar.setQuadra(imovel.getQuadra());

						// Seta Código do Setor Comercial
						debitoACobrar.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());

						// Seta Número Quadra
						debitoACobrar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());

						// Seta Lote
						debitoACobrar.setNumeroLote(imovel.getLote());

						// Seta SubLote
						debitoACobrar.setNumeroSubLote(imovel.getSubLote());

						// Seta Taxa de Juros do Financiamento
						debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);

						// Seta Financiamento Tipo
						debitoACobrar.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());

						// Seta Lançamento Item Contábil
						debitoACobrar.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());

						// Seta Débito Crédito Situação
						debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

						// Seta Cobrança Forma
						debitoACobrar.setCobrancaForma(cobrancaForma);

						// Seta a data de ultima alteração
						debitoACobrar.setUltimaAlteracao(new Date());

						/*
						 * Caso já exista o débito a cobrar para o imóvel
						 * recupera o id do débito a cobrar e deleta todos os
						 * débitos a cobrar por categoria e adiciona o débito a
						 * coleção de atualização Caso contrário adiciona o
						 * débito a cobrar geral e o débito a cobrar a coleção
						 * de inserir.
						 */
						if (dadoDebitoACobrar != null && dadoDebitoACobrar[0] != null) {

							debitoACobrar.setId(((Integer) dadoDebitoACobrar[0]));

							this.repositorioFaturamento.deletarDebitoACobrarCategoria(debitoACobrar.getId());

							colecaoDebitosACobrarAtualizar.add(debitoACobrar);
							colecaoDebitosACobrarCategoriasInserir.addAll(
									inserirDebitoACobrarCategoriaBatch(debitoACobrar, debitoACobrar.getImovel()));
						} else {
							/*
							 * Inserir o débito a cobrar geral na base de dados
							 * e recupera o id gerado para setar no débito a
							 * cobrar.
							 */
							DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
							debitoACobrarGeral.setIndicadorHistorico(ConstantesSistema.NAO);
							debitoACobrarGeral.setUltimaAlteracao(new Date());

							Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);

							debitoACobrarGeral.setId(idDebitoACobrarGeral);
							debitoACobrar.setId(idDebitoACobrarGeral);
							debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);

							colecaoDebitosACobrarInserir.add(debitoACobrar);
							colecaoDebitosACobrarCategoriasInserir.addAll(
									inserirDebitoACobrarCategoriaBatch(debitoACobrar, debitoACobrar.getImovel()));
						}
					}
				}
			}// laço rotas

			/*
			 * Caso tenha gerado débito a cobrar para inserir para algum imóvel
			 * cria os débitos a cobrar por na base de dados.
			 */
			if (colecaoDebitosACobrarInserir != null
					&& !colecaoDebitosACobrarInserir.isEmpty()) {
				this.getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoDebitosACobrarInserir);
			}

			/*
			 * Caso tenha gerado débito a cobrar para atualizar para algum
			 * imóvel atualiza os dados dos débitos a cobrar na base de dados e
			 * a data de última alteração do débito a cobrar geral.
			 */
			if (colecaoDebitosACobrarAtualizar != null
					&& !colecaoDebitosACobrarAtualizar.isEmpty()) {
				this.repositorioFaturamento
						.atualizaDebitoACobrar(colecaoDebitosACobrarAtualizar);
			}

			/*
			 * Caso gere algum débito a cobrar por categoria inserir todos de
			 * uma vez na base de dados
			 */
			if (!colecaoDebitosACobrarCategoriasInserir.isEmpty()) {
				this.repositorioFaturamento
						.inserirDebitoACobrarCategoria(colecaoDebitosACobrarCategoriasInserir);
			}

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) {
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos A Cobrar de Acrescimos por Impontualidade
	 * Author: Fernanda Paiva Data: 24/04/2006
	 * 
	 * Obtém as contas de um imóvel com ano/mes da data de vencimento menor ou
	 * igual ao ano/mes de referencia da arrecadacao corrente e com situacao
	 * atual correspondente a normal, retificada ou incluida.
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection obterContasImovel(Integer imovel, Integer situacaoNormal,
			Integer situacaoIncluida, Integer situacaoRetificada,
			Integer anoMesReferenciaArrecadacao) throws ControladorException {

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoContasManutencaoArray = null;

		try {

			colecaoContasManutencaoArray = repositorioFaturamento
					.obterContasImovel(imovel, situacaoNormal,
							situacaoIncluida, situacaoRetificada,
							anoMesReferenciaArrecadacao);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoContasManutencaoArray != null
				&& !colecaoContasManutencaoArray.isEmpty()) {

			Iterator colecaoContasManutencaoArrayIterator = colecaoContasManutencaoArray
					.iterator();

			while (colecaoContasManutencaoArrayIterator.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] contaArray = (Object[]) colecaoContasManutencaoArrayIterator
						.next();

				Conta conta = new Conta();

				// ID da conta
				conta.setId((Integer) contaArray[0]);

				// Ano Mês referencia
				conta.setReferencia((Integer) contaArray[1]);

				// Data de vencimento
				String vencimento = String.valueOf(contaArray[2]);

				SimpleDateFormat formatoData = new SimpleDateFormat(
						"yyyy-MM-dd");

				Date dataVencimento;

				try {
					dataVencimento = formatoData.parse(vencimento);
				} catch (java.text.ParseException e) {
					dataVencimento = null;
				}

				conta.setDataVencimentoConta(dataVencimento);

				// Valor de água
				conta.setValorAgua((BigDecimal) contaArray[3]);

				// Valor de esgoto
				conta.setValorEsgoto((BigDecimal) contaArray[4]);

				// Valor dos débitos
				conta.setDebitos((BigDecimal) contaArray[5]);

				// Valor dos créditos
				conta.setValorCreditos((BigDecimal) contaArray[6]);

				// Consumo de água
				conta.setConsumoAgua((Integer) contaArray[7]);

				// Consumo de esgoto
				conta.setConsumoEsgoto((Integer) contaArray[8]);

				// Data de validade
				String validade = String.valueOf(contaArray[9]);

				Date dataValidade;

				try {
					dataValidade = formatoData.parse(validade);
				} catch (java.text.ParseException e) {
					dataValidade = null;
				}

				conta.setDataValidadeConta(dataValidade);

				// Data de revisao
				String revisao = String.valueOf(contaArray[10]);

				Date dataRevisao;

				try {
					dataRevisao = formatoData.parse(revisao);
				} catch (java.text.ParseException e) {
					dataRevisao = null;
				}

				conta.setDataRevisao(dataRevisao);

				// DebitoCreditoSituacaoAtual
				conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);

				// Ano Mês referencia contábil
				conta.setReferenciaContabil((Integer) contaArray[12]);

				// ultima Alteracao

				SimpleDateFormat formatoDataEspecifico = new SimpleDateFormat(
						"yyyy-MM-dd HH:mm:ss");

				String ultimaAlteracao = String.valueOf(contaArray[13]);

				Date dataUltimaAlteracao;

				try {
					dataUltimaAlteracao = formatoDataEspecifico
							.parse(ultimaAlteracao);
				} catch (java.text.ParseException e) {
					dataUltimaAlteracao = null;
				}

				conta.setUltimaAlteracao(dataUltimaAlteracao);

				retorno.add(conta);
			}
		}

		return retorno;
	}

	/**
	 * [UC0302] - Gerar Debitos A Cobrar de Acrescimos por Impontualidade
	 * Author: Fernanda Paiva Data: 24/04/2006
	 * 
	 * Obtém as contas de um imóvel com ano/mes da data de vencimento menor ou
	 * igual ao ano/mes de referencia da arrecadacao corrente e com situacao
	 * atual correspondente a normal, retificada ou incluida.
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection obterGuiasPagamentoImovel(Integer imovel,
			Integer situacaoNormal, Integer situacaoIncluida,
			Integer situacaoRetificada, Integer anoMesReferenciaArrecadacao)
			throws ControladorException {

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoGuiasManutencaoArray = null;

		try {

			colecaoGuiasManutencaoArray = repositorioFaturamento
					.obterGuiasPagamentoImovel(imovel, situacaoNormal,
							situacaoIncluida, situacaoRetificada,
							anoMesReferenciaArrecadacao);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoGuiasManutencaoArray != null
				&& !colecaoGuiasManutencaoArray.isEmpty()) {

			Iterator colecaoGuiasManutencaoArrayIterator = colecaoGuiasManutencaoArray
					.iterator();

			while (colecaoGuiasManutencaoArrayIterator.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] guiaArray = (Object[]) colecaoGuiasManutencaoArrayIterator
						.next();

				GuiaPagamento guiaPagamento = new GuiaPagamento();

				// ID da conta
				guiaPagamento.setId((Integer) guiaArray[0]);

				// Ano Mês referencia
				guiaPagamento
						.setAnoMesReferenciaContabil((Integer) guiaArray[1]);

				// Data de vencimento
				String vencimento = String.valueOf(guiaArray[2]);

				SimpleDateFormat formatoData = new SimpleDateFormat(
						"yyyy-MM-dd");

				Date dataVencimento;

				try {
					dataVencimento = formatoData.parse(vencimento);
				} catch (java.text.ParseException e) {
					dataVencimento = null;
				}

				guiaPagamento.setDataVencimento(dataVencimento);

				// Valor dos débitos
				guiaPagamento.setValorDebito((BigDecimal) guiaArray[3]);

				retorno.add(guiaPagamento);
			}
		}

		return retorno;
	}

	/**
	 * Insere Mensagem na Conta
	 * 
	 * [UC0330] Inserir Mensagem da Conta
	 * 
	 * @author Tiago Moreno
	 * @date 03/05/2006
	 * 
	 * @throws ControladorException
	 */

	public void atualizarMensagemConta(ContaMensagem contaMensagem)
			throws ControladorException {

		FiltroContaMensagem filtroContaMensagem = new FiltroContaMensagem();

		filtroContaMensagem.adicionarParametro(new ParametroSimples(
				FiltroContaMensagem.ID, contaMensagem.getId()));
		Collection colecaoContaMensagem = getControladorUtil().pesquisar(
				filtroContaMensagem, ContaMensagem.class.getName());

		ContaMensagem contaMensagemNaBase = (ContaMensagem) Util
				.retonarObjetoDeColecao(colecaoContaMensagem);

		if (contaMensagemNaBase.getUltimaAlteracao().after(
				contaMensagem.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		contaMensagem.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(contaMensagem);

	}

	/**
	 * [UC0330] Inserir Mensagem da Conta
	 * 
	 * @author Tiago Moreno, Raphael Rossiter
	 * @date 08/05/2006, 02/07/2008
	 * 
	 * @param contaMensagem
	 * @param setorComercial
	 * @throws ControladorException
	 */
	public void inserirMensagemConta(ContaMensagem contaMensagem,
			String[] setorComercial, String[] quadra)
			throws ControladorException {

		if (contaMensagem != null) {

			FiltroContaMensagem filtroContaMensagem = new FiltroContaMensagem();

			// ANO_MES_REFERENCIA
			if (contaMensagem.getAnoMesRreferenciaFaturamento() != null) {

				filtroContaMensagem.adicionarParametro(new ParametroSimples(
						FiltroContaMensagem.ANO_MES_REFERECIA_FATURAMENTO,
						contaMensagem.getAnoMesRreferenciaFaturamento()));
			}

			// FATURAMENTO_GRUPO
			if (contaMensagem.getFaturamentoGrupo() != null
					&& contaMensagem.getFaturamentoGrupo().getId() != null) {

				filtroContaMensagem
						.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupo");

				filtroContaMensagem.adicionarParametro(new ParametroSimples(
						FiltroContaMensagem.GRUPO_FATURAMENTO_ID, contaMensagem
								.getFaturamentoGrupo().getId()));

			} else {

				filtroContaMensagem.adicionarParametro(new ParametroNulo(
						FiltroContaMensagem.GRUPO_FATURAMENTO_ID));

			}

			// GERENCIA_REGIONAL
			if (contaMensagem.getGerenciaRegional() != null
					&& contaMensagem.getGerenciaRegional().getId() != null) {

				filtroContaMensagem
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");

				filtroContaMensagem.adicionarParametro(new ParametroSimples(
						FiltroContaMensagem.GERENCIA_REGIONAL_ID, contaMensagem
								.getGerenciaRegional().getId()));

			} else {

				filtroContaMensagem.adicionarParametro(new ParametroNulo(
						FiltroContaMensagem.GERENCIA_REGIONAL_ID));

			}

			// LOCALIDADE
			if (contaMensagem.getLocalidade() != null
					&& contaMensagem.getLocalidade().getId() != null) {

				filtroContaMensagem
						.adicionarCaminhoParaCarregamentoEntidade("localidade");

				filtroContaMensagem.adicionarParametro(new ParametroSimples(
						FiltroContaMensagem.LOCALIDADE_ID, contaMensagem
								.getLocalidade().getId()));

			} else {

				filtroContaMensagem.adicionarParametro(new ParametroNulo(
						FiltroContaMensagem.LOCALIDADE_ID));

			}

			// SETOR_COMERCIAL
			if (setorComercial != null) {

				for (int i = 0; i < setorComercial.length; i++) {

					if (!setorComercial[i].equals("")) {

						filtroContaMensagem
								.adicionarParametro(new ParametroSimples(
										FiltroContaMensagem.SETOR_COMERCIAL_ID,
										setorComercial[i]));

						filtroContaMensagem
								.adicionarCaminhoParaCarregamentoEntidade("setorComercial");

						Collection colecaoContaMenssagem = getControladorUtil()
								.pesquisar(filtroContaMensagem,
										ContaMensagem.class.getName());

						if (colecaoContaMenssagem != null
								&& !colecaoContaMenssagem.isEmpty()) {

							ContaMensagem contaMensagemExistente = (ContaMensagem) Util
									.retonarObjetoDeColecao(colecaoContaMenssagem);
							if (quadra == null || quadra.equals("")) {
								sessionContext.setRollbackOnly();
								throw new ControladorException(
										"atencao.mensagem_setor_ja_existe",
										null, contaMensagemExistente
												.getSetorComercial()
												.getDescricao());
							}
						} else {

							FiltroSetorComercial filtroSetorComercial = new FiltroSetorComercial();

							filtroSetorComercial
									.adicionarCaminhoParaCarregamentoEntidade("localidade");

							filtroSetorComercial
									.adicionarParametro(new ParametroSimples(
											FiltroSetorComercial.ID,
											new Integer(setorComercial[i])));

							Collection colecaoSetorComercial = this
									.getControladorUtil().pesquisar(
											filtroSetorComercial,
											SetorComercial.class.getName());

							SetorComercial setorComercialNaBase = (SetorComercial) Util
									.retonarObjetoDeColecao(colecaoSetorComercial);

							contaMensagem.setLocalidade(setorComercialNaBase
									.getLocalidade());
							contaMensagem
									.setSetorComercial(setorComercialNaBase);

							// INSERINDO NA BASE
							if (quadra == null || quadra.equals("")) {
								getControladorUtil().inserir(contaMensagem);
							}
						}
					}
				}
			} else {

				filtroContaMensagem.adicionarParametro(new ParametroNulo(
						FiltroContaMensagem.SETOR_COMERCIAL_ID));

				Collection colecaoContaMenssagem = getControladorUtil()
						.pesquisar(filtroContaMensagem,
								ContaMensagem.class.getName());

				if (colecaoContaMenssagem != null
						&& !colecaoContaMenssagem.isEmpty()) {

					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.mensagem_ja_existe");
				} else {

					// INSERINDO CONTA_MENSAGEM
					if (quadra == null || quadra.equals("")) {

						filtroContaMensagem
								.adicionarParametro(new ParametroNulo(
										FiltroContaMensagem.QUADRA_ID));

						Collection colecaoContaMenssagemquadra = getControladorUtil()
								.pesquisar(filtroContaMensagem,
										ContaMensagem.class.getName());

						if (colecaoContaMenssagemquadra != null
								&& !colecaoContaMenssagemquadra.isEmpty()) {

							sessionContext.setRollbackOnly();
							throw new ControladorException(
									"atencao.mensagem_quadra_ja_existe");
						}

						getControladorUtil().inserir(contaMensagem);
					}
				}
			}

			// QUADRA
			if (quadra != null && !quadra.equals("")) {

				for (int i = 0; i < quadra.length; i++) {

					if (!quadra[i].equals("")) {
						filtroContaMensagem
								.adicionarParametro(new ParametroSimples(
										FiltroContaMensagem.QUADRA_ID,
										quadra[i]));

						filtroContaMensagem
								.adicionarCaminhoParaCarregamentoEntidade("quadra");

						Collection colecaoContaMenssagem = getControladorUtil()
								.pesquisar(filtroContaMensagem,
										ContaMensagem.class.getName());
						if (colecaoContaMenssagem != null
								&& !colecaoContaMenssagem.isEmpty()) {

							ContaMensagem contaMensagemExistente = (ContaMensagem) Util
									.retonarObjetoDeColecao(colecaoContaMenssagem);

							sessionContext.setRollbackOnly();
							throw new ControladorException(
									"atencao.mensagem_quadra_ja_existe", null,
									contaMensagemExistente.getQuadra()
											.getDescricao());
						} else {

							FiltroQuadra filtroQuadra = new FiltroQuadra();

							filtroQuadra
									.adicionarCaminhoParaCarregamentoEntidade("setorComercial");

							filtroQuadra
									.adicionarParametro(new ParametroSimples(
											FiltroQuadra.ID, new Integer(
													quadra[i])));

							Collection colecaoQuadra = this
									.getControladorUtil().pesquisar(
											filtroQuadra,
											Quadra.class.getName());

							Quadra quadraNaBase = (Quadra) Util
									.retonarObjetoDeColecao(colecaoQuadra);

							contaMensagem.setLocalidade(quadraNaBase
									.getSetorComercial().getLocalidade());
							contaMensagem.setQuadra(quadraNaBase);

							// INSERINDO NA BASE]
							if (quadra != null && !quadra.equals("")) {
								getControladorUtil().inserir(contaMensagem);
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Excluir Mensagem na Conta
	 * 
	 * [UC0332] Manter Mensagem da Conta
	 * 
	 * @author Tiago Moreno
	 * @date 08/05/2006
	 * 
	 * @throws ControladorException
	 */

	// public void excluirMensagemConta(ContaMensagem contaMensagem, String
	// setorComercial)
	// throws ControladorException {
	//
	// //verifica se o grupo de faturamento ja foi faturado
	//
	// if (contaMensagem.getFaturamentoGrupo() != null){
	// FiltroFaturamentoGrupo filtroFaturamentoGrupo = new
	// FiltroFaturamentoGrupo();
	//
	// filtroFaturamentoGrupo.adicionarParametro(new
	// MaiorQue(FiltroFaturamentoGrupo.ANO_MES_REFERENCIA,
	// contaMensagem.getAnoMesRreferenciaFaturamento()));
	// filtroFaturamentoGrupo.adicionarParametro(new
	// ParametroSimples(FiltroFaturamentoGrupo.ID,
	// contaMensagem.getFaturamentoGrupo().getId()));
	//
	// Collection colecaoFaturamentoGrupo =
	// getControladorUtil().pesquisar(filtroFaturamentoGrupo,
	// FaturamentoGrupo.class.getName());
	//
	// if (colecaoFaturamentoGrupo != null &&
	// !colecaoFaturamentoGrupo.isEmpty()){
	// throw new ControladorException(
	// "atencao.mensagem_em_uso");
	// }
	// }
	//
	// if(contaMensagem.get)
	//
	// }
	/**
	 * Gera as faturas das contas dos imóveis para o cliente responsável pelo
	 * imóvel
	 * 
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 25/04/2006, 03/01/2007
	 * 
	 * @throws ControladorException
	 */
	public void gerarFaturaClienteResponsavel(int idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, 0);
		try {
			// Recupera os parâmetros do sistema
			SistemaParametro sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			// Recupera o ano/mês de faturamento corrente
			Integer anoMesFaturamentoCorrente = sistemaParametro.getAnoMesFaturamento();
			// Se o mês de faturamento for igual a 11 e o indicador
			// faturamento
			// antecipado for igual a 1, então seta o mes de faturamento
			// igual a
			// 12 em conta impressão,e imprime as contas no mes 12 também.

			Integer anoMesFaturamentoAntecipado = null;
			if (Util.obterMes(anoMesFaturamentoCorrente) == 11) {
				if (sistemaParametro.getIndicadorFaturamentoAntecipado()
						.equals(ConstantesSistema.SIM)) {
					anoMesFaturamentoAntecipado = Util
							.somarData(anoMesFaturamentoCorrente);
				}
			}

			// Cria a variável que vai armazenar a coleção de faturas
			Collection<Fatura> colecaoFatura = new ArrayList();
			Collection<Fatura> colecaoFaturaDez = new ArrayList();
			Collection colecaoFaturaItem = new ArrayList();

			/**
			 * Variáveis da paginação
			 */
			boolean flagTerminou = false;
			boolean flagPrimeiraVez = true;
			final int quantidadeRegistros = 500;
			int numeroIndice = 0;
			Collection<Integer> colecaoClientesResponsaveis = null;

			// REMOVER ISSO DEPOIS
			int quantidadeFatura = 0;

			while (!flagTerminou) {

				// Pesquisa na base de dados os clientes responsáveis pelos
				// imóveis
				// pesquisa os grupos de faturamentos
				Collection<FaturamentoGrupo> colecaoFaturamentoGrupoNaoFaturados = this.repositorioFaturamento
						.pesquisarGrupoFaturamentoNaoFaturados(anoMesFaturamentoCorrente);

				if (colecaoFaturamentoGrupoNaoFaturados != null
						&& !colecaoFaturamentoGrupoNaoFaturados.isEmpty()) {
					colecaoClientesResponsaveis = repositorioFaturamento
							.pesquisarClientesResponsaveisFaturamentoAntecipado(
									sistemaParametro, numeroIndice,
									quantidadeRegistros);
				} else {
					colecaoClientesResponsaveis = repositorioFaturamento
							.pesquisarClientesResponsaveis(sistemaParametro,
									numeroIndice, quantidadeRegistros);
				}

				if (flagPrimeiraVez) {
					flagPrimeiraVez = false;

					// [FS0001] Verificar Existência de Cliente Responsável
					if (colecaoClientesResponsaveis == null
							|| colecaoClientesResponsaveis.isEmpty()) {
						throw new ControladorException(
								"atencao.nao.existe.cliente.responsavel");
					}
				}

				// Caso exista clientes responsáveis cadastrados gera as faturas
				// das
				// contas dos imóveis para cada cliente
				// Caso contrário levanta uma exeção para o usuário informando
				// que
				// não existe clientes responsáveis
				if (colecaoClientesResponsaveis != null
						&& !colecaoClientesResponsaveis.isEmpty()) {

					// Laço para gerar as faturas das contas de cada cliente
					// retornado
					for (Integer idCliente : colecaoClientesResponsaveis) {

						Cliente cliente = new Cliente();
						cliente.setId(idCliente);

						/**
						 * Deleta as faturas existentes do cliente reponsável
						 * por ano/mês de referência do faturamento e seus items
						 * de fatura.
						 */
						// this.repositorioFaturamento
						// .deletarFaturaClienteResponsavel(idCliente,
						// anoMesFaturamentoCorrente,anoMesFaturamentoAntecipado);

						// Pesquisa os imóveis de responsabilidade do cliente
						Collection<Integer> colecaoIdsImoveisPorClienteResponsavel = repositorioFaturamento
								.pesquisarClienteImovelPorClienteResponsavel(idCliente);

						// Caso exista imóvel sobre a responsabilidade do
						// cliente
						if (colecaoIdsImoveisPorClienteResponsavel != null
								&& !colecaoIdsImoveisPorClienteResponsavel
										.isEmpty()) {

							// Alterado por Sávio Luiz Data:19/11/2007
							// Analista:Aryed Lins
							// O do...while foi feito para rodar os 2
							// meses(11,12) no caso de o mês de
							// referencia for 11.
							int quantidadeMeses = 1;
							do {
								Object[] resumoContas = null;
								Collection<Conta> colecaoContas = null;
								// caso o mes corrente seja 11, então roda
								// também o mês 12.
								if (quantidadeMeses == 2) {
									// Pesquisa o resumo das contas dos imóveis
									// do
									// cliente
									// o metódo retorna um array de object
									// contendo
									// na
									// primeira posição a soma do valor total
									// das
									// contas,
									// na segunda posição contém a maior data de
									// vencimento
									// e na terceira posição a maior data de
									// validade
									resumoContas = (Object[]) repositorioFaturamento
											.pesquisarResumoContasClienteResponsavel(
													colecaoIdsImoveisPorClienteResponsavel,
													anoMesFaturamentoAntecipado);

									// Recupera todas as contas dos imóveis
									// sobre
									// responsabilidade do cliente
									colecaoContas = repositorioFaturamento
											.pesquisarContaImovelResponsabilidadeCliente(
													colecaoIdsImoveisPorClienteResponsavel,
													anoMesFaturamentoAntecipado);

								} else {
									// Pesquisa o resumo das contas dos imóveis
									// do
									// cliente
									// o metódo retorna um array de object
									// contendo
									// na
									// primeira posição a soma do valor total
									// das
									// contas,
									// na segunda posição contém a maior data de
									// vencimento
									// e na terceira posição a maior data de
									// validade
									resumoContas = (Object[]) repositorioFaturamento
											.pesquisarResumoContasClienteResponsavel(
													colecaoIdsImoveisPorClienteResponsavel,
													anoMesFaturamentoCorrente);

									// Recupera todas as contas dos imóveis
									// sobre
									// responsabilidade do cliente
									colecaoContas = repositorioFaturamento
											.pesquisarContaImovelResponsabilidadeCliente(
													colecaoIdsImoveisPorClienteResponsavel,
													anoMesFaturamentoCorrente);
								}

								// Caso exista contas para os imóveis sobre
								// responsabilidade do cliente
								// Gera a fatura e os items de fatura para cada
								// conta
								if (colecaoContas != null
										&& !colecaoContas.isEmpty()) {

									// Recupera as informações sobre o resumo
									// das
									// contas
									// dos imóveis
									BigDecimal valorDebito = (BigDecimal) resumoContas[0];

									// Caso o valor do débito seja nulo atribuir
									// o
									// valor
									// zero
									if (valorDebito == null) {
										valorDebito = new BigDecimal("0.00");
									}

									// Recupera as maiores datas de vencimento e
									// resumo
									// do array retornado
									Date dataVencimento = (Date) resumoContas[1];
									Date dataValidade = (Date) resumoContas[2];

									// Gera a fatura para o resumo das contas
									// dos
									// imóveis sobre responsabilidade do cliente
									Fatura fatura = new Fatura();
									// caso o mes corrente seja 11, então roda
									// também o mês 12.
									if (quantidadeMeses == 2) {
										fatura.setAnoMesReferencia(anoMesFaturamentoAntecipado);
									} else {
										fatura.setAnoMesReferencia(anoMesFaturamentoCorrente);
									}
									fatura.setSequencial(0);
									fatura.setEmissao(new Date());
									fatura.setVencimento(dataVencimento);
									fatura.setValidade(dataValidade);
									fatura.setDebito(valorDebito);
									fatura.setTaxa(BigDecimal.ZERO);
									fatura.setCliente(cliente);
									fatura.setUltimaAlteracao(new Date());

									// Caso o valor do débito da fatura seja
									// menor
									// que
									// um centavo
									// não gera a fatura
									if (fatura.getDebito().compareTo(
											new BigDecimal("0.01")) != -1) {

										// Inseri a fatura na base e recupera o
										// código
										// gerado
										Integer idFatura = (Integer) getControladorUtil()
												.inserir(fatura);

										// Incrementa a quantidade de faturas
										// geradas
										quantidadeFatura++;

										// Atualiza o código da fatura e o
										// sequêncial
										// setndo o códigoda fatura gerada
										fatura.setId(idFatura);
										fatura.setSequencial(idFatura);
										getControladorUtil().atualizar(fatura);

										// caso o mes corrente seja 11, então
										// roda também o mês 12.
										// e adiciona em outra coleção para
										// emitir separado
										if (quantidadeMeses == 2) {
											// Adiciona a fatura a coleção
											colecaoFaturaDez.add(fatura);
										} else {
											// Adiciona a fatura a coleção
											colecaoFatura.add(fatura);
										}

										// Gera os items da fatura para cada
										// conta
										// Cria a variável que vai armazenar o
										// sequêncial do
										// item da fatura
										Integer itemSequencial = 1;

										// Laço para gerar os items da fatura
										// para
										// cada
										// conta
										for (Conta conta : colecaoContas) {

											Short ligacaoAguaSituacaoIndicadorFaturamento = conta
													.getLigacaoAguaSituacao()
													.getIndicadorFaturamentoSituacao();

											// Cria a varável que vai armazenar
											// o
											// número
											// de
											// consumo
											Integer numeroConsumo = 0;

											// Caso a situação da ligação de
											// água
											// seja
											// igual
											// a ligado ou cortado o nº de
											// consumo
											// vai
											// ser o
											// nº
											// de consumo da água
											// Caso contrário e caso a situação
											// da
											// ligação
											// de esgoto for igual a ligado
											// o nº de consumo vai receber o nº
											// de
											// consumo
											// de esgoto

											/*
											 * alterado por pedro alexandre dia
											 * 12/12/2007 para ser feito agora
											 * pelo indicador de faturamento.
											 * Alteração solicitada por leonardo
											 * vieira.
											 */
											/*
											 * if
											 * (conta.getLigacaoAguaSituacao()
											 * .getId().intValue() ==
											 * LigacaoAguaSituacao.LIGADO
											 * .intValue() || conta
											 * .getLigacaoAguaSituacao()
											 * .getId().intValue() ==
											 * LigacaoAguaSituacao.CORTADO
											 * .intValue()) {
											 */
											if (ligacaoAguaSituacaoIndicadorFaturamento
													.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)) {
												numeroConsumo = conta
														.getConsumoAgua();
											} else if (conta
													.getLigacaoEsgotoSituacao()
													.getId().intValue() == LigacaoEsgotoSituacao.LIGADO
													.intValue()) {
												numeroConsumo = conta
														.getConsumoEsgoto();
											}

											// Cria o item da fatura
											FaturaItem faturaItem = new FaturaItem();
											faturaItem.setFatura(fatura);
											faturaItem
													.setItemSequencia(itemSequencial);
											faturaItem.setImovel(conta
													.getImovel());
											ContaGeral contaGeral = new ContaGeral();
											contaGeral.setId(conta.getId());
											faturaItem
													.setContaGeral(contaGeral);
											faturaItem.setValorConta(conta
													.getValorTotal());

											// Alterado por Sávio Luiz
											// Data:19/11/2007 Analista:Rosana
											faturaItem.setValorImposto(conta
													.getValorImposto());

											faturaItem
													.setNumeroConsumo(numeroConsumo);
											faturaItem
													.setUltimaAlteracao(new Date());

											// Gera o item da fatura
											// getControladorUtil().inserir(faturaItem);
											colecaoFaturaItem.add(faturaItem);

											// Incrementa o sequêncial do item
											itemSequencial++;
										}
									}
								}

								// caso n exista mes ano antecipado então não
								// roda outra vez.
								if (anoMesFaturamentoAntecipado == null) {
									quantidadeMeses = 3;
								} else {
									quantidadeMeses++;
								}

							} while (quantidadeMeses <= 2);

						}
					}
				}

				/**
				 * Incrementa o nº do indice da páginação
				 */
				numeroIndice = numeroIndice + quantidadeRegistros;

				/**
				 * Caso a coleção de clientes responsáveis retornados for menor
				 * que a quantidade de registros seta a flag indicando que a
				 * paginação terminou.
				 */
				if (colecaoClientesResponsaveis != null
						&& colecaoClientesResponsaveis.size() < quantidadeRegistros) {
					flagTerminou = true;
				}
				colecaoClientesResponsaveis = null;

				/**
				 * Inseri todos os itens de fatura criados.
				 */
				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoFaturaItem);
				colecaoFaturaItem = null;
				colecaoFaturaItem = new ArrayList();

			}// while da paginação

			// [UC0321] Emitir Fatura de Cliente Responsável
			if (colecaoFatura != null && !colecaoFatura.isEmpty()) {
				this.emitirFaturaClienteResponsavel(colecaoFatura,
						anoMesFaturamentoCorrente);
			}
			// caso o mes corrente seja 11, então roda também o mês 12.
			// Caso a coleção de dezembro tenha dados, então chama o emitir
			// passando os dados de dezembro
			if (colecaoFaturaDez != null && !colecaoFaturaDez.isEmpty()) {
				// [UC0321] Emitir Fatura de Cliente Responsável
				this.emitirFaturaClienteResponsavel(colecaoFaturaDez,
						anoMesFaturamentoAntecipado);
			}

			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

			// Erro no repositório
		} catch (Exception ex) {

			ex.printStackTrace();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(ex,
					idUnidadeIniciada, true);

			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Metódo responsável por emitir as faturas geradas pelo [UC0320]
	 * 
	 * [UC0321] Emitir Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 27/04/2006, 03/01/2007, 15/03/2007
	 * 
	 * @param colecaoFatura
	 * @throws ControladorException
	 */
	public void emitirFaturaClienteResponsavel(
			Collection<Fatura> colecaoFatura, Integer anoMesFaturamentoCorrente)
			throws ControladorException, IOException {

		// Ordena a coleção de faturas pelo código do cliente responsável
		Collections.sort((List) colecaoFatura, new Comparator() {
			public int compare(Object a, Object b) {
				Integer cliente1 = ((Fatura) a).getCliente().getId();
				Integer cliente2 = ((Fatura) b).getCliente().getId();

				return cliente1.compareTo(cliente2);
			}
		});

		// Cria a variável que vai armazenar o txt de fatura
		StringBuilder arquivoFaturaTXT = new StringBuilder();

		// Caso a coleção de faturas esteja preenchida
		// Emiti todas as faturas informadas
		if (colecaoFatura != null) {

			// Cria o sequêncial da fatura
			int sequencialFatura = 1;
			int quantidadeFaturas = 0;
			// Laço para emitir todas as faturas
			for (Fatura fatura : colecaoFatura) {
				try {

					quantidadeFaturas++;

					// Obtém a coleção dos itens da fatura atual
					ArrayList<FaturaItem> colecaoFaturaItem = (ArrayList) repositorioFaturamento
							.pesquisarItemsFatura(fatura.getId());

					// Caso a coleção de itens da fatura estejam preenchidos
					if (colecaoFaturaItem != null
							&& colecaoFaturaItem.size() > 0) {

						// Armazena a quantidade de itens
						String quantidadeItemFatura = ""
								+ colecaoFaturaItem.size();

						// Armazena a quantidade limite de itens por página
						Integer quantidadeItemLimite = 100;

						// Calcula a quantidade de páginas
						Integer quantidadePaginas = ((Double) Math.ceil(Double
								.parseDouble(quantidadeItemFatura)
								/ quantidadeItemLimite)).intValue();

						// Cria os arrays que iram armazenar os itens da
						// primeira e segunda colunas respectivamente
						FaturaItem[] colecaoFaturaItemColuna1 = null;
						FaturaItem[] colecaoFaturaItemColuna2 = null;

						// Cria o indice atual da coleção de itens
						int indiceAtual = 0;

						// Laço para gerar todas as páginas da fatura atual
						for (int i = 1; i <= quantidadePaginas; i++) {

							// Recupera o cliente responsável pela fatura
							Cliente cliente = getControladorCliente()
									.pesquisarCliente(
											fatura.getCliente().getId());

							// Linha 1
							// Linha 1 é composta só pela canal=1
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 2
							// Linha 2 é composta pelo canal=- e fonte=1 e pelo
							// nome do cliente
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(cliente.getNome());
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 3
							// Linha 3 é composta pelo código do cliente e pelo
							// mês/ano de referência da conta
							String codigoClienteFormatado = Util
									.adicionarZerosEsquedaNumero(8, ""
											+ cliente.getId());
							codigoClienteFormatado = codigoClienteFormatado
									.substring(0, 7)
									+ "."
									+ codigoClienteFormatado.substring(7, 8);

							arquivoFaturaTXT.append("+");
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT
									.append(Util.completaString("", 61));
							arquivoFaturaTXT.append(codigoClienteFormatado);
							arquivoFaturaTXT
									.append(Util.completaString("", 19));
							arquivoFaturaTXT.append(Util
									.formatarAnoMesParaMesAno(fatura
											.getAnoMesReferencia()));
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 4
							String enderecoCorrespondencia = getControladorEndereco()
									.pesquisarEnderecoClienteAbreviado(
											cliente.getId());
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(enderecoCorrespondencia);
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 5
							// Linha 5 é composta pelo sequêncial da fatura
							arquivoFaturaTXT.append(" ");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT
									.append(Util.completaString("", 91));
							arquivoFaturaTXT.append(Util
									.adicionarZerosEsquedaNumero(6,
											"" + fatura.getSequencial()));
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 6
							// Linha 6 é uma linha em branco
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 7
							// Linha 7 é composta pela descrição do tipo do
							// cliente e pela quantidade de itens da fatura
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString(cliente
									.getClienteTipo().getDescricao(), 91));
							arquivoFaturaTXT.append(Util
									.completaStringComEspacoAEsquerda(
											quantidadeItemFatura, 5));
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 8
							// Linha 8 é uma linha em branco
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 9
							// Linha 9 é composta só pelo canal=-
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 10
							// Linha 10 é composta pelos itens da fatura da
							// página atual

							// Caso seja a última página da fatura
							if (i == quantidadePaginas) {
								// Calcula a quantidade de itens da última
								// página
								int quantidadeItemsUltimaPagina = Integer
										.parseInt(quantidadeItemFatura)
										- ((quantidadePaginas - 1) * 100);

								// Caso a quantidade de itens da última página
								// seja maior que 50(cinquenta)
								// Recupera os itens restantes para a primeira
								// coluna
								// Caso contrário recupera os 50 primeiros itens
								// para a primeira coluna
								// e os itens restantes para a segunda coluna
								if (quantidadeItemsUltimaPagina <= 50) {
									// Cria o array de itens da fatura da
									// primeira coluna
									// com o tamanho igual a quantidade de itens
									// da última página
									colecaoFaturaItemColuna1 = new FaturaItem[quantidadeItemsUltimaPagina];

									// Recupera da coleção principal os itens da
									// fatura
									// para os itens da primeira coluna
									(colecaoFaturaItem
											.subList(
													indiceAtual,
													indiceAtual
															+ quantidadeItemsUltimaPagina))
											.toArray(colecaoFaturaItemColuna1);

									// Cria um array de nulos para a segunda
									// coluna
									colecaoFaturaItemColuna2 = new FaturaItem[quantidadeItemsUltimaPagina];

								} else {
									// Cria o array de itens da fatura da
									// primeira coluna
									// com o tamanho igual a 50(cinquenta)
									colecaoFaturaItemColuna1 = new FaturaItem[50];

									// Recupera da coleção principal os itens da
									// fatura
									// para os itens da primeira coluna
									(colecaoFaturaItem.subList(indiceAtual,
											indiceAtual + 50))
											.toArray(colecaoFaturaItemColuna1);

									// Incrementa o indice atual em cinquenta
									// posições
									indiceAtual = indiceAtual + 50;

									// Cria o array da segunda coluna com o
									// tamanho das quantidades de itens
									// restantes
									// colecaoFaturaItemColuna2 = new
									// FaturaItem[quantidadeItemsUltimaPagina -
									// 50];
									colecaoFaturaItemColuna2 = new FaturaItem[50];

									// Recupera os itens restantes para asegunda
									// coluna
									(colecaoFaturaItem
											.subList(
													indiceAtual,
													(indiceAtual + (quantidadeItemsUltimaPagina - 50))))
											.toArray(colecaoFaturaItemColuna2);
								}

							} else {
								colecaoFaturaItemColuna1 = new FaturaItem[50];
								colecaoFaturaItemColuna2 = new FaturaItem[50];

								// Recupera os 50 itens para a primeira coluna
								(colecaoFaturaItem.subList(indiceAtual,
										indiceAtual + 50))
										.toArray(colecaoFaturaItemColuna1);

								// Incrementa o indice atual
								indiceAtual = indiceAtual + 50;

								// Recupera os 50 itens da segunda coluna
								(colecaoFaturaItem.subList(indiceAtual,
										indiceAtual + 50))
										.toArray(colecaoFaturaItemColuna2);

								// Incrementa o indice atual
								indiceAtual = indiceAtual + 50;
							}

							// Adiciona a linha dez gerada ao txt
							arquivoFaturaTXT
									.append(gerarLinha10FaturaClienteResponsavel(
											colecaoFaturaItemColuna1,
											colecaoFaturaItemColuna2));

							// Linha 11
							// Linha 11 é composta das datas de emissão
							// ,vencimento e do valor do débito da fatura
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append(Util.completaString("", 8));
							arquivoFaturaTXT
									.append(Util.completaString(Util
											.formatarData(fatura.getEmissao()),
											34));
							arquivoFaturaTXT.append(Util.completaString(
									Util.formatarData(fatura.getVencimento()),
									38));
							arquivoFaturaTXT.append(Util
									.completaStringComEspacoAEsquerda(Util
											.formatarMoedaReal(fatura
													.getDebito()), 14));
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 12
							// Linha 12 é composta por apenas o canal=0
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 13
							// Linha 13 é composta por apenas o canal=-
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 14
							// Linha 14 é composta pelo sequêncial da fatura
							String sequencialFaturaFormatado = Util
									.adicionarZerosEsquedaNumero(6, ""
											+ sequencialFatura);
							sequencialFaturaFormatado = sequencialFaturaFormatado
									.substring(0, 3)
									+ "."
									+ sequencialFaturaFormatado.substring(3, 6);
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util
									.completaString("", 100));
							arquivoFaturaTXT.append(sequencialFaturaFormatado);
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 15
							// Linha 15 é composta pelo canal=1, fonte=1
							// e pela representação numérica do código de barras
							// Formata o ano/mês em mês/ano de referência da
							// conta no formato MM/AAAA
							String mesAnoReferenciaConta = Util
									.formatarAnoMesParaMesAno(fatura
											.getAnoMesReferencia());

							// Formata o ano/mês em mês/ano de referência da
							// conta no formato MMAAAA(sem a barra)
							String mesAnoReferenciaContaSemABarra = mesAnoReferenciaConta
									.substring(0, 2)
									+ mesAnoReferenciaConta.substring(3, 7);

							// Obtémo dígito verificador da referência da conta
							// no modulo 10(dez)
							Integer digitoVerificadorReferenciaContaModulo10 = Util
									.obterDigitoVerificadorModulo10(new Long(
											mesAnoReferenciaContaSemABarra));

							// Variável que vai armazenar a representação
							// numérica do código de barras
							String representacaoNumericaCodBarra = "";

							// Obtém a representação numérica do códigode
							// barra
							representacaoNumericaCodBarra = this
									.getControladorArrecadacao()
									.obterRepresentacaoNumericaCodigoBarra(
											7,
											fatura.getDebito(),
											null,
											null,
											mesAnoReferenciaContaSemABarra,
											digitoVerificadorReferenciaContaModulo10,
											null, null, null, null,
											cliente.getId(),
											fatura.getSequencial(), null);

							// Formata a representação númerica do código de
							// barras
							String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra
									.substring(0, 11)
									+ " "
									+ representacaoNumericaCodBarra.substring(
											11, 12)
									+ " "
									+ representacaoNumericaCodBarra.substring(
											12, 23)
									+ " "
									+ representacaoNumericaCodBarra.substring(
											23, 24)
									+ " "
									+ representacaoNumericaCodBarra.substring(
											24, 35)
									+ " "
									+ representacaoNumericaCodBarra.substring(
											35, 36)
									+ " "
									+ representacaoNumericaCodBarra.substring(
											36, 47)
									+ " "
									+ representacaoNumericaCodBarra.substring(
											47, 48);

							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT
									.append(Util.completaString("", 23));
							arquivoFaturaTXT
									.append(representacaoNumericaCodBarraFormatada);
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 16 é composta por apenas o canal=1
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 17 é composta pelo canal=1 pela fonte=2 e
							// pela representação do código de barras em
							// caracter
							// Cria o objeto para gerar o códigode barras no
							// padrão intercalado 2 de 5
							Interleaved2of5 codigoBarraIntercalado2de5 = new Interleaved2of5();

							// Recupera a representação númerica do código de
							// barras sem os dígitos verificadores
							String representacaoCodigoBarrasSemDigitoVerificador = representacaoNumericaCodBarra
									.substring(0, 11)
									+ representacaoNumericaCodBarra.substring(
											12, 23)
									+ representacaoNumericaCodBarra.substring(
											24, 35)
									+ representacaoNumericaCodBarra.substring(
											36, 47);

							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("2");
							arquivoFaturaTXT
									.append(Util.completaStringComEspacoAEsquerda(
											codigoBarraIntercalado2de5
													.encodeValue(representacaoCodigoBarrasSemDigitoVerificador),
											142));
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 18 é composta por apenas o canal=0
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 19 é composta pelo canal=- pela fonte=2,
							// pela data de validade,
							// pelo código do cliente pelo sequencial da fatura
							// e pelo mês/ano de referência
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString("", 4));
							arquivoFaturaTXT
									.append(Util.completaString(
											Util.formatarData(fatura
													.getValidade()), 30));
							arquivoFaturaTXT.append(Util.completaString(
									codigoClienteFormatado, 30));
							arquivoFaturaTXT.append(Util.completaString(
									Util.adicionarZerosEsquedaNumero(6, ""
											+ fatura.getSequencial()), 24));
							arquivoFaturaTXT.append(Util.completaString(Util
									.formatarAnoMesParaMesAno(fatura
											.getAnoMesReferencia()), 29));
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 20 é composta pelo canal=- pela fonte=1 e
							// pelas datas de emissão e vencimento
							// e pelo valor do débito da fatura
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString("", 8));
							arquivoFaturaTXT
									.append(Util.completaString(Util
											.formatarData(fatura.getEmissao()),
											34));
							arquivoFaturaTXT.append(Util.completaString(
									Util.formatarData(fatura.getVencimento()),
									40));
							arquivoFaturaTXT.append(Util
									.completaStringComEspacoAEsquerda(Util
											.formatarMoedaReal(fatura
													.getDebito()), 22));
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 21 é composta somente pelo canal=-
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 22 é composta somente pelo canal=-
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 23 é composta somente pelo sequêncial de
							// impressão da fatura
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util
									.completaString("", 100));
							arquivoFaturaTXT.append(sequencialFaturaFormatado);
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));

							// Linha 24 é composta pela canal=0, fonte=1 e pela
							// representação do número de páginas
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append("1");

							// Caso a página atual não seja a última página
							if (i != quantidadePaginas.intValue()) {
								// Imprime a menssagem que ocntinua a impressão
								// na próxima página
								arquivoFaturaTXT.append(Util.completaString("",
										30));
								arquivoFaturaTXT.append(Util.completaString(
										"(CONTINUA)", 64));
								arquivoFaturaTXT.append("PAGINA  "
										+ Util.adicionarZerosEsquedaNumero(2,
												"" + i)
										+ "/"
										+ Util.adicionarZerosEsquedaNumero(2,
												"" + quantidadePaginas));
							} else {
								arquivoFaturaTXT.append(Util.completaString("",
										94));
								arquivoFaturaTXT.append("PAGINA  "
										+ Util.adicionarZerosEsquedaNumero(2,
												"" + i)
										+ "/"
										+ Util.adicionarZerosEsquedaNumero(2,
												"" + quantidadePaginas));
							}
							arquivoFaturaTXT.append(System
									.getProperty("line.separator"));
						}
					}

					// Incrementa o sequêncial da fatura para a nova fatura
					sequencialFatura++;

					// Erro no repositório
				} catch (ErroRepositorioException ex) {
					// Seta o roolback na base
					// sessionContext.setRollbackOnly();

					// Levanta a exceção para o usuário
					throw new ControladorException("erro.sistema", ex);
				}
			}

			String mesReferencia = anoMesFaturamentoCorrente.toString()
					.substring(4, 6);
			String anoReferencia = anoMesFaturamentoCorrente.toString()
					.substring(0, 4);

			String nomeZip = "Faturas_Cliente_Responsavel_" + mesReferencia
					+ "_" + anoReferencia;

			BufferedWriter out = null;
			ZipOutputStream zos = null;
			
			File compactadoTipo = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".zip");
			File leituraTipo = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".txt");

			if (arquivoFaturaTXT != null && arquivoFaturaTXT.length() != 0) {
				try {

					zos = new ZipOutputStream(new FileOutputStream(compactadoTipo));

					out = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(
									leituraTipo.getAbsolutePath())));
					out.write(arquivoFaturaTXT.toString());
					out.flush();
					ZipUtil.adicionarArquivo(zos, leituraTipo);
					leituraTipo.delete();
				} catch (IOException ex) {
					throw new ControladorException("erro.sistema", ex);
				} catch (Exception e) {
					throw new ControladorException("erro.sistema", e);

				} finally {
					IoUtil.fecharStream(out);
					IoUtil.fecharStream(zos);
				}

				nomeZip = null;
				out = null;
				zos = null;
				compactadoTipo = null;
				leituraTipo = null;
			}
		}
	}

	/**
	 * Este metódo é especifíco para gerar a linha 10(dez) do txt de fatura ele
	 * cria os itens da fatura em duas ou uma coluna dependendo da quantidade de
	 * itens
	 * 
	 * [UC0321] Emitir Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 29/04/2006
	 * 
	 * @param colecaoFaturaItemColuna1
	 * @param colecaoFaturaItemColuna2
	 * @return
	 */
	protected StringBuffer gerarLinha10FaturaClienteResponsavel(
			FaturaItem[] colecaoFaturaItemColuna1,
			FaturaItem[] colecaoFaturaItemColuna2) {
		// Cria a variável que vai armazenar a linha 10(dez) gerada
		StringBuffer linha10 = new StringBuffer();

		// Cria as variáveis que iram armazenar as colunas 1 e 2
		String coluna1 = new String();
		String coluna2 = new String();

		// Laço para gerar as colunas 1 e 2 dependendo da quantidade de itens
		for (int i = 0; i < colecaoFaturaItemColuna1.length; i++) {

			// Recupera o item de fatura da coluna 1 e 2
			FaturaItem faturaItemColuna1 = colecaoFaturaItemColuna1[i];
			FaturaItem faturaItemColuna2 = colecaoFaturaItemColuna2[i];

			// Recupera a matrícula do imóvel da coluna 1 e formata a matrícula
			// (ex:500000001 em 5000000.1)
			String matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(
					8, "" + faturaItemColuna1.getImovel().getId());
			matriculaImovelFormatada = matriculaImovelFormatada.substring(0, 7)
					+ "." + matriculaImovelFormatada.substring(7, 8);

			// Caso o consumo do item da fatura não esteja nulo
			// Recupera o consumo do item da fatura
			// Caso contrário atribui 0(zero)
			String consumoFormatado = "";
			if (faturaItemColuna1.getNumeroConsumo() != null) {
				consumoFormatado = faturaItemColuna1.getNumeroConsumo() + " M3";
			} else {
				consumoFormatado = "0 M3";
			}

			// Recupera o valor do item da fatura
			String valorFormatado = (Util.formatarMoedaReal(faturaItemColuna1
					.getValorConta()));

			// Cria a coluna 1(um)
			coluna1 = " "
					+ "3"
					+ matriculaImovelFormatada
					+ Util.completaStringComEspacoAEsquerda(consumoFormatado,
							17)
					+ Util.completaStringComEspacoAEsquerda(valorFormatado, 24);

			// Caso exista o item da fatura para a coluna 2(dois)
			if (faturaItemColuna2 != null) {
				// Recupera a matrícula do imóvel da coluna 2(dois) e formata a
				// matrícula (ex:500000001 em 5000000.1)

				String matriculaImovelFormatadaColuna2 = Util
						.adicionarZerosEsquedaNumero(8, ""
								+ faturaItemColuna2.getImovel().getId());

				matriculaImovelFormatadaColuna2 = matriculaImovelFormatadaColuna2
						.substring(0, 7)
						+ "."
						+ matriculaImovelFormatadaColuna2.substring(7, 8);

				// Caso o consumo do item da fatura não esteja nulo
				// Recupera o consumo do item da fatura
				// Caso contrário atribui 0(zero)
				if (faturaItemColuna2.getNumeroConsumo() != null) {
					consumoFormatado = faturaItemColuna2.getNumeroConsumo()
							+ " M3";
				} else {
					consumoFormatado = "0 M3";
				}

				// Recupera o valor do item da fatura
				valorFormatado = (Util.formatarMoedaReal(faturaItemColuna2
						.getValorConta()));

				// Cria a coluna 2(dois)
				coluna2 = matriculaImovelFormatadaColuna2
						+ Util.completaStringComEspacoAEsquerda(
								consumoFormatado, 17)
						+ Util.completaStringComEspacoAEsquerda(valorFormatado,
								24);
			}

			// Adiciona na linha 10 as colunas 1 e 2
			linha10.append(coluna1 + Util.completaString("", 17) + coluna2);

			coluna1 = "";
			coluna2 = "";

			// Adiciona uma linha em branco na string
			linha10.append(System.getProperty("line.separator"));
		}

		// Retorna a linha 10(dez) do txt
		return linha10;
	}

	/**
	 * [UC0329] - Restabelecer Situação Anterior de Conta
	 * 
	 * @author Fernanda Paiva
	 * @date 05/05/2006
	 * 
	 * @param registrosRemocao
	 * @throws ControladorException
	 */

	public void restabelecerSituacaoAnteriorConta(Collection colecaoContas,
			Usuario usuarioLogado) throws ControladorException {

		try {

			Iterator iteratorContas = colecaoContas.iterator();

			while (iteratorContas.hasNext()) {
				Conta conta = (Conta) iteratorContas.next();
				Conta contaParaExcluir = null;
				// ------------ <REGISTRAR
				// TRANSAÇÃO>----------------------------

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_CANCELAMENTO_RETIFICACAO_CONTA_DESFAZER,
						conta.getImovel().getId(), conta.getId(),
						new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(conta);

				// ------------ </REGISTRAR
				// TRANSAÇÃO>----------------------------

				Integer situacaoAtualConta = conta
						.getDebitoCreditoSituacaoAtual().getId();
				// CRC2725 - alterado por Vivianne Sousa - 21/09/2009
				// analista:Fátima
				// 1.2. Verificar se há relação do desfazer cancelamento ou
				// retificação com itens de negativação:
				// 1.2.1. Verificar se existem itens de negativação associados à
				// conta
				// [UC0937 - Obter Itens de Negativação Associados à Conta]
				// passando o identificador do imóvel (IMOV_ID da tabela CONTA)
				// e a referência (CNTA_AMREFERENCIACONTA da tabela CONTA).
				Collection colecaoNegativadorMovimentoRegItem = getControladorSpcSerasa()
						.obterItensNegativacaoAssociadosAConta(
								conta.getImovel().getId(),
								conta.getReferencia());

				// filtro conta
				FiltroConta filtroConta = new FiltroConta();

				// Parte de Validacao com Timestamp

				// Seta o filtro para buscar o cliente na base
				filtroConta.adicionarParametro(new ParametroSimples(
						FiltroConta.ID, conta.getId()));

				// Procura o conta na base
				Conta contaNaBase = (Conta) ((List) (getControladorUtil()
						.pesquisar(filtroConta, Conta.class.getName()))).get(0);

				// Verificar se o conta já foi atualizado por outro usuário
				// durante
				// esta atualização
				if (contaNaBase.getUltimaAlteracao() != null) {
					if (contaNaBase.getUltimaAlteracao().after(
							conta.getUltimaAlteracao())) {
						sessionContext.setRollbackOnly();
						throw new ControladorException(
								"atencao.atualizacao.timestamp");
					}
				}
				if (conta.getDebitoCreditoSituacaoAtual().getId().equals(3)) {
					// altera a data e o motivo do cancelamento
					try {
						/*
						 * Inicio: Registrar Transacao de Desfazer Cancelamento
						 */

						conta.setDataCancelamento(null);
						conta.setContaMotivoCancelamento(null);
						getControladorTransacao().registrarTransacao(conta);
						/*
						 * Fim: Registrar Transacao de Desfazer Cancelamento
						 */

						repositorioFaturamento
								.restabelecerSituacaoAnteriorContaCancelada(conta
										.getId().toString());

						// CRC2725 - alterado por Vivianne Sousa - 21/09/2009
						// analista:Fátima
						getControladorSpcSerasa()
								.verificarRelacaoDoDesfazerCancelamentoOuRetificacaoComItensNegativacao(
										colecaoNegativadorMovimentoRegItem,
										situacaoAtualConta, conta,
										contaParaExcluir);

					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				}

				if (conta
						.getDebitoCreditoSituacaoAtual()
						.getId()
						.equals(DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO
								.intValue())) {

					FiltroConta filtroContaRetificada = new FiltroConta();

					filtroContaRetificada
							.adicionarParametro(new ParametroSimples(
									FiltroConta.IMOVEL_ID, conta.getImovel()
											.getId()));

					filtroContaRetificada
							.adicionarParametro(new ParametroSimples(
									FiltroConta.REFERENCIA, conta
											.getReferencia()));

					filtroContaRetificada
							.adicionarParametro(new ParametroSimples(
									FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
									DebitoCreditoSituacao.RETIFICADA.intValue()));

					Collection contasParaExcluir = getControladorUtil()
							.pesquisar(filtroContaRetificada,
									Conta.class.getName());

					if (contasParaExcluir != null
							&& !contasParaExcluir.isEmpty()) {

						contaParaExcluir = (Conta) contasParaExcluir.iterator()
								.next();

						FiltroEmpresaCobrancaConta filtroEmpresaCobrancaConta = new FiltroEmpresaCobrancaConta();
						filtroEmpresaCobrancaConta
								.adicionarParametro(new ParametroSimples(
										FiltroEmpresaCobrancaConta.CONTA_ID,
										contaParaExcluir.getId()));

						Collection colecaoEmpresaCobranca = getControladorUtil()
								.pesquisar(filtroEmpresaCobrancaConta,
										EmpresaCobrancaConta.class.getName());

						if (colecaoEmpresaCobranca != null
								&& !colecaoEmpresaCobranca.isEmpty()) {
							EmpresaCobrancaConta empresaCobrancaConta = (EmpresaCobrancaConta) Util
									.retonarObjetoDeColecao(colecaoEmpresaCobranca);

							ContaGeral contaGeral = new ContaGeral();
							contaGeral.setId(conta.getId());

							empresaCobrancaConta.setContaGeral(contaGeral);

							getControladorUtil()
									.atualizar(empresaCobrancaConta);
						}

						// -----------------------------------------------------------
						// atualizar na tabela PAGAMENTO a coluna CNTA_ID
						// com id da conta cancelada por retificação
						// onde CNTA_ID=Id da conta retificada
						Pagamento pagamento = null;

						pagamento = getControladorArrecadacao()
								.pesquisarPagamentoDeConta(
										contaParaExcluir.getId());

						if (pagamento != null) {
							try {
								repositorioArrecadacao
										.atualizarContaEmPagamento(
												pagamento.getId(),
												conta.getId());
							} catch (ErroRepositorioException e) {
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema",
										e);
							}
						}
						// -----------------------------------------------------------

						// CRC2725 - alterado por Vivianne Sousa - 21/09/2009
						// analista:Fátima
						getControladorSpcSerasa()
								.verificarRelacaoDoDesfazerCancelamentoOuRetificacaoComItensNegativacao(
										colecaoNegativadorMovimentoRegItem,
										situacaoAtualConta, conta,
										contaParaExcluir);

						FiltroContaGeral filtroContaGeral = new FiltroContaGeral();

						filtroContaGeral
								.adicionarParametro(new ParametroSimples(
										FiltroContaGeral.ID, contaParaExcluir
												.getId()));

						Collection contasGeralParaExcluir = getControladorUtil()
								.pesquisar(filtroContaGeral,
										ContaGeral.class.getName());

						this.getControladorUtil()
								.remover(
										new String[] { ""
												+ contaParaExcluir.getId()
														.toString() },
										Conta.class.getName(), null, null);

						if (contasGeralParaExcluir != null
								&& !contasGeralParaExcluir.isEmpty()) {
							ContaGeral contaGeralParaExcluir = (ContaGeral) contasGeralParaExcluir
									.iterator().next();
							this.getControladorUtil().remover(
									new String[] { ""
											+ contaGeralParaExcluir.getId()
													.toString() },
									ContaGeral.class.getName(), null, null);
						}

					}
				}
				if (conta.getDebitoCreditoSituacaoAnterior() != null) {
					// altera as situações anterior e atual da conta
					Integer situacaoAtual = conta
							.getDebitoCreditoSituacaoAnterior().getId();
					Integer situacaoAnterior = null;

					try {
						/*
						 * Inicio: Registrar Transacao de Desfazer Cancelamento
						 */
						// conta.setDataCancelamento(null);
						// conta.setContaMotivoCancelamento(null);
						conta.setDebitoCreditoSituacaoAtual(conta
								.getDebitoCreditoSituacaoAnterior());
						conta.setDebitoCreditoSituacaoAnterior(null);
						getControladorTransacao().registrarTransacao(conta);
						/*
						 * Fim: Registrar Transacao de Desfazer Cancelamento
						 */

						repositorioFaturamento
								.alterarSituacaoAnteriorAtualConta(conta
										.getId().toString(), situacaoAnterior,
										situacaoAtual);
					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				} else {
					if (conta.getDataRetificacao() == null
							&& conta.getDataInclusao() == null) {
						// altera as situações anterior e atual da conta
						try {
							/*
							 * Inicio: Registrar Transacao de Desfazer
							 * Cancelamento
							 */
							// conta.setDataCancelamento(null);
							// conta.setContaMotivoCancelamento(null);
							conta.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(
									DebitoCreditoSituacao.NORMAL));
							// conta.setDebitoCreditoSituacaoAnterior(null);
							getControladorTransacao().registrarTransacao(conta);
							/*
							 * Fim: Registrar Transacao de Desfazer Cancelamento
							 */
							repositorioFaturamento.alterarSituacaoConta(conta
									.getId().toString(),
									DebitoCreditoSituacao.NORMAL);
						} catch (ErroRepositorioException e) {
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", e);
						}
					} else {
						if (conta.getDataRetificacao() != null) {
							// altera as situações anterior e atual da conta

							try {

								/*
								 * Inicio: Registrar Transacao de Desfazer
								 * Cancelamento
								 */
								// conta.setDataCancelamento(null);
								// conta.setContaMotivoCancelamento(null);
								conta.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(
										DebitoCreditoSituacao.RETIFICADA));
								// conta.setDebitoCreditoSituacaoAnterior(null);
								getControladorTransacao().registrarTransacao(
										conta);
								/*
								 * Fim: Registrar Transacao de Desfazer
								 * Cancelamento
								 */
								repositorioFaturamento.alterarSituacaoConta(
										conta.getId().toString(),
										DebitoCreditoSituacao.RETIFICADA);
							} catch (ErroRepositorioException e) {
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema",
										e);
							}
						} else {
							// altera as situações anterior e atual da conta

							try {
								repositorioFaturamento.alterarSituacaoConta(
										conta.getId().toString(),
										DebitoCreditoSituacao.INCLUIDA);
							} catch (ErroRepositorioException e) {
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema",
										e);
							}
						}
					}
				}

				// Alterado por Francisco - 26/05/08, por conta do Resumo de
				// Ações de cobrança
				// Analista: Ana Breda
				try {
					// Atualizar documento de cobranca da conta, se houver, para
					// cancelado
					repositorioCobranca.atualizarSituacaoCobrancaDocumentoItem(
							CobrancaDebitoSituacao.PENDENTE, new Date(),
							conta.getId(), null, null);
				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					new ControladorException("erro.sistema", ex);
				}

			}

		} catch (ControladorException e) {
			sessionContext.setRollbackOnly();
			throw e;
		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0113] - Gerar Faturamento Grupo Author: Rafael Santos Data: 05/05/2006
	 * 
	 * Dados da Ligacao Esgoto do Imovel
	 * 
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public LigacaoEsgoto obterLigacaoEsgotoImovel(Integer idImovel)
			throws ControladorException {

		LigacaoEsgoto ligacaoEsgoto = new LigacaoEsgoto();

		// Pesquisa LigacaoEsgoto
		try {
			ligacaoEsgoto = repositorioFaturamento
					.obterLigacaoEsgotoImovel(idImovel);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return ligacaoEsgoto;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * Pesquisa o valor do percentual de esgoto para o imóvel informado.
	 * 
	 * @author Pedro Alexandre
	 * @date 18/09/2006
	 * 
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	protected BigDecimal obterPercentualLigacaoEsgotoImovel(Integer idImovel)
			throws ControladorException {

		// Pesquisa LigacaoEsgoto
		try {
			return repositorioFaturamento
					.obterPercentualLigacaoEsgotoImovel(idImovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Sávio Luiz, Pedro Alexandre,Vivianne Sousa, Ivan Sergio, Mariana
	 *         Victor
	 * @date 15/05/2006, 19/09/2006, 10/12/2007, 19/08/2009, 11/03/2011
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	public void emitirContas(Integer anoMesReferenciaFaturamento,
			FaturamentoGrupo faturamentoGrupo, int idFuncionalidadeIniciada,
			int tipoConta, Integer idEmpresa,
			Short indicadorEmissaoExtratoFaturamento)
			throws ControladorException {

		int idUnidadeIniciada = 0;
		// emitir contas

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------

		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE,
						(idEmpresa == null ? 0 : idEmpresa));

		try {

			// Collection colecaoContasImpressao = null;
			SistemaParametro sistemaParametro = null;

			int quantidadeContas = 0;
			int numeroPart = 0;

			final int quantidadeRegistros = 1000;
			int numeroIndice = 0;

			try {

				sistemaParametro = getControladorUtil()
						.pesquisarParametrosDoSistema();

				// Alterado por Sávio Luiz Data:12/11/2007 Analista:Aryed Lins
				// Se o mês de faturamento for igual a 11 e o indicador
				// faturamento
				// antecipado for igual a 1, então seta o mes de faturamento
				// igual a
				// 12 em conta impressão,e imprime as contas no mes 12 também.

				Integer anoMesReferenciaFaturamentoAntecipado = null;
				if (Util.obterMes(anoMesReferenciaFaturamento) == 11) {
					if (sistemaParametro.getIndicadorFaturamentoAntecipado()
							.equals(ConstantesSistema.SIM)) {
						anoMesReferenciaFaturamentoAntecipado = Util
								.somarData(anoMesReferenciaFaturamento);
					}
				}

				// i=0;Coleção de contas com estouros de consumo
				// i=1;Coleção de contas com baixo consumo
				// i=2;Coleção de contas com débito automático
				// i=3;Coleção de contas com entrega para o cliente
				// responsável
				// i=4;Coleção de contas com entrega para o cliente
				// responsável
				// i=5;Coleção de contas normais

				ZipOutputStream zosCartas = null;
				ZipOutputStream zosContas = null;
				File compactadoTipoCarta = null;

				String idGrupoFaturamento = null;

				if (faturamentoGrupo == null) {
					idGrupoFaturamento = "G40";
				} else {
					idGrupoFaturamento = "G" + faturamentoGrupo.getId();
				}

				String mesReferencia = "_Fat"
						+ anoMesReferenciaFaturamento.toString()
								.substring(4, 6);
				String nomeZip = null;
				String nomeZipCartaConta = null;

				switch (tipoConta) {
				case 0:
					nomeZip = "CONTA_E" + "_" + idGrupoFaturamento
							+ mesReferencia + "_Emp" + idEmpresa + "-";
					nomeZipCartaConta = "CARTA_CONTA_ESTOURO" + "_"
							+ idGrupoFaturamento + mesReferencia + "_Emp"
							+ idEmpresa + "-";
					break;
				case 1:
					nomeZip = "CONTA_A" + "_" + idGrupoFaturamento
							+ mesReferencia + "_Emp" + idEmpresa + "-";
					nomeZipCartaConta = "CARTA_BAIXO_CONSUMO" + "_"
							+ idGrupoFaturamento + mesReferencia + "_Emp"
							+ idEmpresa + "-";
					break;
				case 2:
					nomeZip = "CONTA_D" + "_" + idGrupoFaturamento
							+ mesReferencia + "_Emp" + idEmpresa + "-";
					break;
				case 3:
					nomeZip = "CONTA_N_R" + "_" + idGrupoFaturamento
							+ mesReferencia + "-";
					break;
				case 4:
					nomeZip = "CONTA_D_R" + "_" + idGrupoFaturamento
							+ mesReferencia + "-";
					break;

				case 5:
					nomeZip = "CONTA_N" + "_" + idGrupoFaturamento
							+ mesReferencia + "_Emp" + idEmpresa + "-";
					break;

				case 6:
					nomeZip = "CONTA_D_B" + "_" + mesReferencia + "-";
					break;

				case 7:
					nomeZip = "CONTA_N_R_B" + "_" + mesReferencia + "-";
					break;

				case 8:
					nomeZip = "CONTA_D_R_B" + "_" + mesReferencia + "-";
					break;

				case 9:
					nomeZip = "CONTA_N_B" + "_" + mesReferencia + "-";
					break;

				}

				File compactadoTipo = new File(nomeZip + ".zip");
				if (nomeZipCartaConta != null) {
					compactadoTipoCarta = new File(nomeZipCartaConta + ".zip");
				}

				BufferedWriter outCartas = null;

				File leituraTipo = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".txt");
				File leituraTipoCarta = null;
				if (nomeZipCartaConta != null) {
					leituraTipoCarta = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZipCartaConta + ".txt");
					outCartas = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipoCarta.getAbsolutePath())));

				}

				BufferedWriter outContas = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipo.getAbsolutePath())));

				try {

					numeroIndice = 0;
					Integer sequencialImpressao = 0;
					Integer sequencialCarta = 0;
					Integer sequencialEmpresa = 0;

					boolean flagTerminou = false;
					boolean flagPesquisarFichaCompensacao = true;
					boolean geraArquivo = false;

					while (!flagTerminou) {
						// recebe todos as contas da lista
						StringBuilder contasTxtLista = null;
						StringBuilder cartasTxtListaConta = null;
						Map<Integer, Integer> mapAtualizaSequencial = null;

						Collection colecaoConta = null;
						Collection colecaoContaFichaCompensacao = null;

						contasTxtLista = new StringBuilder();
						cartasTxtListaConta = new StringBuilder();
						Collection<Integer> colecaoContaTipo = new ArrayList<Integer>();

						// map que armazena o sequencial e o numero da
						// conta para no final atualizar todos os
						// sequencias
						mapAtualizaSequencial = new HashMap();
						Collection colecaoContaParms = null;
						Collection colecaoContaParmsFichaCompensacao = null;
						switch (tipoConta) {
						case 0:

							System.out
									.println("*********************************");
							System.out.println("PESQUISA ESTOURO CONSUMO");
							System.out
									.println("*********************************");

							if (flagPesquisarFichaCompensacao) {
								flagPesquisarFichaCompensacao = false;

								colecaoContaParmsFichaCompensacao = repositorioFaturamento
										.pesquisarContasFichaCompensacao(
												ContaTipo.CONTA_RETIDA_POR_EC,
												idEmpresa,
												numeroIndice,
												anoMesReferenciaFaturamento,
												faturamentoGrupo.getId(),
												anoMesReferenciaFaturamentoAntecipado,
												ImovelContaEnvio.ENVIAR_CONTA_BRAILLE);
								System.out.println("QTDE FICHA "
										+ colecaoContaParmsFichaCompensacao
												.size());
								colecaoContaFichaCompensacao = formatarEmitirContasHelperOuFichaCompensacao(
										colecaoContaParmsFichaCompensacao,
										tipoConta);
								colecaoContaParmsFichaCompensacao = null;

								if (colecaoContaFichaCompensacao != null
										&& !colecaoContaFichaCompensacao
												.isEmpty()) {

									emitirFichaCompensacao(
											colecaoContaFichaCompensacao,
											tipoConta, faturamentoGrupo,
											idEmpresa,
											anoMesReferenciaFaturamento);

									colecaoContaFichaCompensacao = null;

								}
							}

							colecaoContaParms = repositorioFaturamento
									.pesquisarContasNaoFichaCompensacao(
											ContaTipo.CONTA_RETIDA_POR_EC,
											idEmpresa,
											numeroIndice,
											anoMesReferenciaFaturamento,
											faturamentoGrupo.getId(),
											anoMesReferenciaFaturamentoAntecipado,
											ImovelContaEnvio.ENVIAR_CONTA_BRAILLE);

							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());

							colecaoConta = formatarEmitirContasHelperOuFichaCompensacao(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;
							/*
							 * dadosContas = this
							 * .pesquisarColecaoContasEstouroConsumo
							 * (colecaoContasImpressao); colecaoConta = (List)
							 * dadosContas[0];
							 * colecaoContasImpressao.removeAll(dadosContas[1]);
							 */

							break;
						case 1:
							System.out
									.println("*********************************");
							System.out.println("PESQUISA BAIXO CONSUMO");
							System.out
									.println("*********************************");

							if (flagPesquisarFichaCompensacao) {
								flagPesquisarFichaCompensacao = false;

								colecaoContaParmsFichaCompensacao = repositorioFaturamento
										.pesquisarContasFichaCompensacao(
												ContaTipo.CONTA_RETIDA_POR_BC,
												idEmpresa,
												numeroIndice,
												anoMesReferenciaFaturamento,
												faturamentoGrupo.getId(),
												anoMesReferenciaFaturamentoAntecipado,
												ImovelContaEnvio.ENVIAR_CONTA_BRAILLE);
								System.out.println("QTDE FICHA "
										+ colecaoContaParmsFichaCompensacao
												.size());
								colecaoContaFichaCompensacao = formatarEmitirContasHelperOuFichaCompensacao(
										colecaoContaParmsFichaCompensacao,
										tipoConta);
								colecaoContaParmsFichaCompensacao = null;

								if (colecaoContaFichaCompensacao != null
										&& !colecaoContaFichaCompensacao
												.isEmpty()) {

									emitirFichaCompensacao(
											colecaoContaFichaCompensacao,
											tipoConta, faturamentoGrupo,
											idEmpresa,
											anoMesReferenciaFaturamento);

									colecaoContaFichaCompensacao = null;

								}
							}

							colecaoContaParms = repositorioFaturamento
									.pesquisarContasNaoFichaCompensacao(
											ContaTipo.CONTA_RETIDA_POR_BC,
											idEmpresa,
											numeroIndice,
											anoMesReferenciaFaturamento,
											faturamentoGrupo.getId(),
											anoMesReferenciaFaturamentoAntecipado,
											ImovelContaEnvio.ENVIAR_CONTA_BRAILLE);

							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());

							colecaoConta = formatarEmitirContasHelperOuFichaCompensacao(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;

							break;
						case 2:
							System.out
									.println("*********************************");
							System.out.println("PESQUISA DEBITO AUTOMATICO");
							System.out
									.println("*********************************");

							colecaoContaTipo
									.add(ContaTipo.CONTA_DEBITO_AUTOMATICO);

							colecaoContaParms = repositorioFaturamento
									.pesquisarContasEmitir(
											colecaoContaTipo,
											idEmpresa,
											numeroIndice,
											anoMesReferenciaFaturamento,
											faturamentoGrupo.getId(),
											anoMesReferenciaFaturamentoAntecipado,
											ImovelContaEnvio.ENVIAR_CONTA_BRAILLE);

							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());

							colecaoConta = formatarEmitirContasHelper(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;
							break;
						case 3:
							System.out
									.println("*********************************");
							System.out.println("PESQUISA CLIENTE RESPONSAVEL");
							System.out
									.println("*********************************");

							if (flagPesquisarFichaCompensacao) {
								flagPesquisarFichaCompensacao = false;

								if (faturamentoGrupo != null) {
									colecaoContaParmsFichaCompensacao = repositorioFaturamento
											.pesquisarContasClienteResponsavelFichaCompensacao(
													ContaTipo.CONTA_CLIENTE_RESPONSAVEL,
													numeroIndice,
													anoMesReferenciaFaturamento,
													faturamentoGrupo.getId(),
													indicadorEmissaoExtratoFaturamento,
													anoMesReferenciaFaturamentoAntecipado,
													ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL);
								} else {
									colecaoContaParmsFichaCompensacao = repositorioFaturamento
											.pesquisarContasClienteResponsavelFichaCompensacao(
													ContaTipo.CONTA_CLIENTE_RESPONSAVEL,
													numeroIndice,
													anoMesReferenciaFaturamento,
													indicadorEmissaoExtratoFaturamento,
													anoMesReferenciaFaturamentoAntecipado,
													ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL);
								}
								System.out.println("QTDE FICHA "
										+ colecaoContaParmsFichaCompensacao
												.size());
								colecaoContaFichaCompensacao = formatarEmitirContasHelperOuFichaCompensacao(
										colecaoContaParmsFichaCompensacao,
										tipoConta);
								colecaoContaParmsFichaCompensacao = null;

								if (colecaoContaFichaCompensacao != null
										&& !colecaoContaFichaCompensacao
												.isEmpty()) {

									emitirFichaCompensacao(
											colecaoContaFichaCompensacao,
											tipoConta, faturamentoGrupo,
											idEmpresa,
											anoMesReferenciaFaturamento);

									colecaoContaFichaCompensacao = null;

								}
							}

							if (faturamentoGrupo != null) {
								colecaoContaParms = repositorioFaturamento
										.pesquisarContasClienteResponsavelNaoFichaCompensacao(
												ContaTipo.CONTA_CLIENTE_RESPONSAVEL,
												numeroIndice,
												anoMesReferenciaFaturamento,
												faturamentoGrupo.getId(),
												indicadorEmissaoExtratoFaturamento,
												anoMesReferenciaFaturamentoAntecipado,
												ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL);
							} else {
								colecaoContaParms = repositorioFaturamento
										.pesquisarContasClienteResponsavelNaoFichaCompensacao(
												ContaTipo.CONTA_CLIENTE_RESPONSAVEL,
												numeroIndice,
												anoMesReferenciaFaturamento,
												indicadorEmissaoExtratoFaturamento,
												anoMesReferenciaFaturamentoAntecipado,
												ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL);
							}

							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());
							colecaoConta = formatarEmitirContasHelperOuFichaCompensacao(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;

							break;
						case 4:
							System.out
									.println("*********************************");
							System.out
									.println("PESQUISA DEBITO AUTOMATICO COM CLIENTE RESPONSAVEL");
							System.out
									.println("*********************************");

							colecaoContaTipo
									.add(ContaTipo.CONTA_DEBITO_AUTO_COM_CLIENTE_RESP);

							if (faturamentoGrupo != null) {
								colecaoContaParms = repositorioFaturamento
										.pesquisarContasClienteResponsavel(
												colecaoContaTipo,
												numeroIndice,
												anoMesReferenciaFaturamento,
												faturamentoGrupo.getId(),
												indicadorEmissaoExtratoFaturamento,
												anoMesReferenciaFaturamentoAntecipado,
												ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL);
							} else {
								colecaoContaParms = repositorioFaturamento
										.pesquisarContasClienteResponsavel(
												colecaoContaTipo,
												numeroIndice,
												anoMesReferenciaFaturamento,
												indicadorEmissaoExtratoFaturamento,
												anoMesReferenciaFaturamentoAntecipado,
												ImovelContaEnvio.ENVIAR_CONTA_BRAILLE_RESPONSAVEL);
							}

							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());
							colecaoConta = formatarEmitirContasHelper(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;

							break;
						case 5:
							System.out
									.println("*********************************");
							System.out.println("PESQUISA CONTAS NORMAIS");
							System.out
									.println("*********************************");

							if (flagPesquisarFichaCompensacao) {
								flagPesquisarFichaCompensacao = false;

								colecaoContaParmsFichaCompensacao = repositorioFaturamento
										.pesquisarContasFichaCompensacao(
												ContaTipo.CONTA_NORMAL,
												idEmpresa,
												numeroIndice,
												anoMesReferenciaFaturamento,
												faturamentoGrupo.getId(),
												anoMesReferenciaFaturamentoAntecipado,
												ImovelContaEnvio.ENVIAR_CONTA_BRAILLE);

								System.out.println("QTDE FICHA "
										+ colecaoContaParmsFichaCompensacao
												.size());
								colecaoContaFichaCompensacao = formatarEmitirContasHelperOuFichaCompensacao(
										colecaoContaParmsFichaCompensacao,
										tipoConta);
								colecaoContaParmsFichaCompensacao = null;

								if (colecaoContaFichaCompensacao != null
										&& !colecaoContaFichaCompensacao
												.isEmpty()) {

									emitirFichaCompensacao(
											colecaoContaFichaCompensacao,
											tipoConta, faturamentoGrupo,
											idEmpresa,
											anoMesReferenciaFaturamento);

									colecaoContaFichaCompensacao = null;

								}
							}
							colecaoContaParms = repositorioFaturamento
									.pesquisarContasNaoFichaCompensacao(
											ContaTipo.CONTA_NORMAL,
											idEmpresa,
											numeroIndice,
											anoMesReferenciaFaturamento,
											faturamentoGrupo.getId(),
											anoMesReferenciaFaturamentoAntecipado,
											ImovelContaEnvio.ENVIAR_CONTA_BRAILLE);

							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());
							colecaoConta = formatarEmitirContasHelperOuFichaCompensacao(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;

							break;

						case 6:
							System.out
									.println("*********************************");
							System.out
									.println("PESQUISA CONTAS DÉBITO AUTOMÁTICO E ENVIO BRAILLE");
							System.out
									.println("*********************************");

							colecaoContaTipo
									.add(ContaTipo.CONTA_DEBITO_AUTOMATICO);

							colecaoContaParms = repositorioFaturamento
									.pesquisarContasBrailleEmitir(
											colecaoContaTipo,
											anoMesReferenciaFaturamento,
											anoMesReferenciaFaturamentoAntecipado);
							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());
							colecaoConta = formatarEmitirContasHelper(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;
							break;

						case 7:
							System.out
									.println("*********************************");
							System.out
									.println("PESQUISA CONTAS COM CLIENTE RESPONSÁVEL E ENVIO BRAILLE");
							System.out
									.println("*********************************");

							if (flagPesquisarFichaCompensacao) {
								flagPesquisarFichaCompensacao = false;

								colecaoContaParmsFichaCompensacao = repositorioFaturamento
										.pesquisarContasBrailleClienteResponsavelFichaCompensacao(
												ContaTipo.CONTA_CLIENTE_RESPONSAVEL,
												anoMesReferenciaFaturamento,
												indicadorEmissaoExtratoFaturamento,
												anoMesReferenciaFaturamentoAntecipado);

								System.out.println("QTDE FICHA "
										+ colecaoContaParmsFichaCompensacao
												.size());
								colecaoContaFichaCompensacao = formatarEmitirContasHelperOuFichaCompensacao(
										colecaoContaParmsFichaCompensacao,
										tipoConta);
								colecaoContaParmsFichaCompensacao = null;

								if (colecaoContaFichaCompensacao != null
										&& !colecaoContaFichaCompensacao
												.isEmpty()) {

									emitirFichaCompensacao(
											colecaoContaFichaCompensacao,
											tipoConta, faturamentoGrupo,
											idEmpresa,
											anoMesReferenciaFaturamento);

									colecaoContaFichaCompensacao = null;

								}
							}

							colecaoContaParms = repositorioFaturamento
									.pesquisarContasBrailleClienteResponsavelNaoFichaCompensacao(
											ContaTipo.CONTA_CLIENTE_RESPONSAVEL,
											anoMesReferenciaFaturamento,
											indicadorEmissaoExtratoFaturamento,
											anoMesReferenciaFaturamentoAntecipado);

							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());
							colecaoConta = formatarEmitirContasHelperOuFichaCompensacao(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;
							break;
						case 8:
							System.out
									.println("*********************************");
							System.out
									.println("PESQUISA CONTAS DE DÉBITO AUTOMÁTICO COM CLIENTE RESPONSÁVEL E ENVIO BRAILLE");
							System.out
									.println("*********************************");

							colecaoContaTipo
									.add(ContaTipo.CONTA_DEBITO_AUTO_COM_CLIENTE_RESP);

							colecaoContaParms = repositorioFaturamento
									.pesquisarContasBrailleClienteResponsavel(
											colecaoContaTipo,
											anoMesReferenciaFaturamento,
											indicadorEmissaoExtratoFaturamento,
											anoMesReferenciaFaturamentoAntecipado);
							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());
							colecaoConta = formatarEmitirContasHelper(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;

							break;

						case 9:
							System.out
									.println("*********************************");
							System.out
									.println("PESQUISA CONTAS NORMAIS BRAILLE");
							System.out
									.println("*********************************");

							if (flagPesquisarFichaCompensacao) {
								flagPesquisarFichaCompensacao = false;

								colecaoContaParmsFichaCompensacao = repositorioFaturamento
										.pesquisarContasBrailleFichaCompensacao(
												ContaTipo.CONTA_NORMAL,
												anoMesReferenciaFaturamento,
												anoMesReferenciaFaturamentoAntecipado);
								System.out.println("QTDE FICHA "
										+ colecaoContaParmsFichaCompensacao
												.size());
								colecaoContaFichaCompensacao = formatarEmitirContasHelperOuFichaCompensacao(
										colecaoContaParmsFichaCompensacao,
										tipoConta);
								colecaoContaParmsFichaCompensacao = null;

								if (colecaoContaFichaCompensacao != null
										&& !colecaoContaFichaCompensacao
												.isEmpty()) {

									emitirFichaCompensacao(
											colecaoContaFichaCompensacao,
											tipoConta, faturamentoGrupo,
											idEmpresa,
											anoMesReferenciaFaturamento);

									colecaoContaFichaCompensacao = null;

								}
							}
							colecaoContaParms = repositorioFaturamento
									.pesquisarContasBrailleNaoFichaCompensacao(
											ContaTipo.CONTA_NORMAL,
											anoMesReferenciaFaturamento,
											anoMesReferenciaFaturamentoAntecipado);
							System.out.println("QTDE CONTA "
									+ colecaoContaParms.size());
							colecaoConta = formatarEmitirContasHelperOuFichaCompensacao(
									colecaoContaParms, tipoConta);
							colecaoContaParms = null;

							break;

						}

						if (colecaoConta != null && !colecaoConta.isEmpty()) {

							geraArquivo = true;

							int metadeColecao = 0;
							if (colecaoConta.size() % 2 == 0) {
								metadeColecao = colecaoConta.size() / 2;
							} else {
								metadeColecao = (colecaoConta.size() / 2) + 1;
							}

							Map<Integer, Map<EmitirContaHelper, EmitirContaHelper>> mapContasDivididasOrdenada = dividirColecao(colecaoConta);

							// colecaoConta = null;

							EmitirContaHelper emitirContaHelper = null;

							if (mapContasDivididasOrdenada != null) {
								int countOrdem = 0;
								while (countOrdem < mapContasDivididasOrdenada
										.size()) {
									Map<EmitirContaHelper, EmitirContaHelper> mapContasDivididas = mapContasDivididasOrdenada
											.get(countOrdem);

									Iterator iteratorConta = mapContasDivididas
											.keySet().iterator();

									// int count = 0;
									while (iteratorConta.hasNext()) {

										emitirContaHelper = null;
										/*
										 * if(quantidadeContas == 48){
										 * System.out.println(""); }
										 */

										int situacao = 0;

										emitirContaHelper = (EmitirContaHelper) iteratorConta
												.next();
										while (situacao < 2) {
											if (situacao == 0) {
												situacao = 1;
												// [SB0020] - Gerar
												// Arquivo
												// TXT
												// das
												// Cartas
												if (tipoConta == 0
														|| tipoConta == 1) {
													sequencialCarta += 1;
												}
												sequencialImpressao += 1;
											} else {
												emitirContaHelper = mapContasDivididas
														.get(emitirContaHelper);
												situacao = 2;
											}

											quantidadeContas++;
											// Só para exibir no console
											// a
											// quantidade de
											// contas

											if (emitirContaHelper != null) {

												/*
												 * Integer idEmpresa =
												 * emitirContaHelper
												 * .getIdEmpresa();
												 */

												// [SB0020] - Gerar
												// Arquivo
												// TXT
												// das
												// Cartas
												if (tipoConta == 0
														|| tipoConta == 1) {

													sequencialCarta = atualizaSequencial(
															sequencialCarta,
															situacao,
															metadeColecao);

													cartasTxtListaConta
															.append(gerarArquivoTxtCartas(
																	emitirContaHelper,
																	sequencialCarta,
																	situacao));
													cartasTxtListaConta
															.append(System
																	.getProperty("line.separator"));
												}

												/*
												 * switch (i) { case 0: //
												 * [SB0020] - Gerar Arquivo TXT
												 * // das // Cartas
												 * sequencialCarta += 1;
												 * 
												 * sequencialCarta =
												 * atualizaSequencial(
												 * sequencialCarta, situacao,
												 * metadeColecao);
												 * cartasTxtListaConta
												 * .append(gerarArquivoTxtCartas
												 * ( emitirContaHelper,
												 * sequencialCarta));
												 * cartasTxtListaConta
												 * .append(System
												 * .getProperty("line.separator"
												 * )); break; case 1: //
												 * [SB0020] - Gerar Arquivo TXT
												 * // das // Cartas
												 * sequencialCarta += 1;
												 * sequencialCarta =
												 * atualizaSequencial(
												 * sequencialCarta, situacao,
												 * metadeColecao);
												 * cartasTxtListaConta
												 * .append(gerarArquivoTxtCartas
												 * ( emitirContaHelper,
												 * sequencialCarta));
												 * cartasTxtListaConta
												 * .append(System
												 * .getProperty("line.separator"
												 * )); break;
												 */
												/*
												 * case 2: if
												 * (sequencialEmpresaAnteriorDebito
												 * == 0) {
												 * sequencialEmpresaAnteriorDebito
												 * = idEmpresa; } if
												 * (!sequencialEmpresaAnteriorDebito
												 * .equals(idEmpresa)) {
												 * sequencialEmpresaDebito = 0;
												 * sequencialEmpresaAnteriorDebito
												 * = idEmpresa; } break; case 3:
												 * if
												 * (sequencialEmpresaAnteriorEntrega
												 * == 0) {
												 * sequencialEmpresaAnteriorEntrega
												 * = idEmpresa; } if (!
												 * sequencialEmpresaAnteriorEntrega
												 * .equals(idEmpresa)) {
												 * sequencialEmpresaEntrega = 0;
												 * sequencialEmpresaAnteriorEntrega
												 * = idEmpresa; } break; case 4:
												 * if
												 * (sequencialEmpresaAnteriorNormal
												 * == 0) {
												 * sequencialEmpresaAnteriorNormal
												 * = idEmpresa; } if
												 * (!sequencialEmpresaAnteriorNormal
												 * .equals(idEmpresa)) {
												 * sequencialEmpresaNormal = 0;
												 * sequencialEmpresaAnteriorNormal
												 * = idEmpresa; } break;
												 */

												// }
												StringBuilder contaTxt = new StringBuilder();
												// count = count + 1;
												// caso o [FS0006 -
												// Verificar
												// espaços
												// para
												// descrição
												// dos
												// serviços e
												// tarifas totalmente
												// preenchido]
												StringBuilder parteInicialcontaTxt = new StringBuilder();
												// --Linha 1-- //
												// Canal
												contaTxt.append("1");
												// Fonte
												contaTxt.append("1");
												// determinar Mensagem
												String mensagemConta = determinarMensagem(tipoConta);
												contaTxt.append(Util
														.completaString(
																mensagemConta,
																129));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 2-- //
												// Canal
												contaTxt.append("1");
												// Fonte
												contaTxt.append(Util
														.completaString("1", 33));
												// nome da localidade
												String descricaoLocalidade = emitirContaHelper
														.getDescricaoLocalidade();
												contaTxt.append(Util
														.completaString(
																descricaoLocalidade,
																97));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 3-- //
												// Canal
												contaTxt.append("0");
												// Fonte
												contaTxt.append("2");
												// matricula do imóvel
												// Recupera a matrícula
												// do
												// imóvel da
												// coluna
												// 1 e
												// formata
												// a
												// matrícula
												// (ex:500000001 em
												// 5000000.1)
												String matriculaImovelFormatada = Util
														.retornaMatriculaImovelFormatada(emitirContaHelper
																.getIdImovel());
												contaTxt.append(Util
														.completaString(
																matriculaImovelFormatada,
																62));

												// data de vencimento da
												// conta
												String dataVencimento = Util
														.formatarData(emitirContaHelper
																.getDataVencimentoConta());
												contaTxt.append(Util
														.completaString(
																dataVencimento,
																67));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 4-- //
												// Canal
												contaTxt.append("+");
												// Fonte
												contaTxt.append(Util
														.completaString("1", 18));
												// caso a coleção de
												// contas
												// seja
												// de
												// entrega
												// para
												// o
												// cliente
												// responsável
												if (tipoConta == 3
														|| tipoConta == 4
														|| tipoConta == 7
														|| tipoConta == 8) {
													String nomeClienteUsuario = null;
													if (emitirContaHelper
															.getNomeImovel() != null
															&& !emitirContaHelper
																	.getNomeImovel()
																	.equals("")) {
														nomeClienteUsuario = emitirContaHelper
																.getNomeImovel();

													} else {
														/*
														 * Alterado por: Mariana
														 * Victor Data:
														 * 11/03/2011
														 */
														nomeClienteUsuario = this
																.obterNomeCliente(emitirContaHelper
																		.getIdConta());

													}
													contaTxt.append(Util
															.completaString(
																	nomeClienteUsuario,
																	112));
												} else {
													/*
													 * Alterado por: Mariana
													 * Victor Data: 11/03/2011
													 */
													String nomeClienteUsuario = this
															.obterNomeCliente(emitirContaHelper
																	.getIdConta());

													contaTxt.append(Util
															.completaString(
																	nomeClienteUsuario,
																	112));
												}

												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 5-- //
												// Canal
												contaTxt.append("-");
												// Fonte
												contaTxt.append(Util
														.completaString("1", 22));
												// recupera endereco do
												// imóvel
												String enderecoImovel = getControladorEndereco()
														.pesquisarEnderecoFormatado(
																emitirContaHelper
																		.getIdImovel());
												contaTxt.append(Util
														.completaString(
																enderecoImovel == null ? ""
																		: enderecoImovel,
																50));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 6));
												// Mês/Ano referência da
												// conta
												// digito
												// verificador
												String mesAnoReferencia = Util
														.formatarAnoMesParaMesAno(emitirContaHelper
																.getAmReferencia());
												// Dígito verificador da
												// conta
												String digitoVerificador = ""
														+ emitirContaHelper
																.getDigitoVerificadorConta();
												contaTxt.append(Util
														.completaString(
																mesAnoReferencia
																		+ "-"
																		+ digitoVerificador,
																52));
												contaTxt.append(System
														.getProperty("line.separator"));

												// ********************************************************
												// Autor: Ivan Sergio
												// Data: 27/05/2009
												// CRC1815
												// Adicionado uma nova linha
												// para o endereco do Imovel
												// ********************************************************
												// --Linha 6-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append(Util
														.completaString("1", 22));

												String enderecoImovelComplemento = "";
												if (enderecoImovel != null) {
													if (enderecoImovel.length() > 50) {
														enderecoImovelComplemento = enderecoImovel
																.substring(50);
													}
												}
												contaTxt.append(Util
														.completaString(
																enderecoImovelComplemento,
																50));
												contaTxt.append(System
														.getProperty("line.separator"));
												// ********************************************************

												// --Linha 6-- //
												// Canal
												contaTxt.append("+");
												// Fonte
												contaTxt.append("7");
												// instância um imovel
												// com
												// os
												// dados
												// da
												// conta
												// para
												// recuperar
												// a
												// inscrição que está np
												// objeto
												// imovel
												Imovel imovel = new Imovel();
												Localidade localidade = new Localidade();
												localidade
														.setId(emitirContaHelper
																.getIdLocalidade());
												imovel.setLocalidade(localidade);
												SetorComercial setorComercial = new SetorComercial();
												setorComercial
														.setCodigo(emitirContaHelper
																.getCodigoSetorComercialConta());
												imovel.setSetorComercial(setorComercial);
												Quadra quadra = new Quadra();
												quadra.setNumeroQuadra(emitirContaHelper
														.getIdQuadraConta());
												imovel.setQuadra(quadra);
												imovel.setLote(emitirContaHelper
														.getLoteConta());
												imovel.setSubLote(emitirContaHelper
														.getSubLoteConta());
												// Inscrição do imóvel
												String inscricao = imovel
														.getInscricaoFormatada();

												imovel = null;
												localidade = null;
												setorComercial = null;
												quadra = null;

												contaTxt.append(Util
														.completaString(
																inscricao, 129));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 7-- //
												// Canal
												contaTxt.append("-");
												// Fonte
												contaTxt.append("7");
												// caso a coleção de
												// contas
												// seja
												// de
												// entrega
												// para
												// o
												// cliente
												// responsável
												String enderecoClienteResponsavel = null;

												// Comentado por Sávio Luiz em
												// 08/01/2008 (Analista
												// Responsável: Aryed)
												// o tipo da conta(igual a 3 ou
												// 4)
												if (emitirContaHelper
														.getIdClienteResponsavel() != null
														&& !emitirContaHelper
																.getIdClienteResponsavel()
																.equals("")) {
													// [UC0085]Obter
													// Endereco
													enderecoClienteResponsavel = getControladorEndereco()
															.pesquisarEnderecoClienteAbreviado(
																	new Integer(
																			emitirContaHelper
																					.getIdClienteResponsavel()));
													// id do cliente
													contaTxt.append(Util
															.completaString(
																	""
																			+ emitirContaHelper
																					.getIdClienteResponsavel(),
																	7));
													if (enderecoClienteResponsavel != null) {
														// endereco
														// cliente
														// responsável
														contaTxt.append(Util
																.completaString(
																		enderecoClienteResponsavel,
																		50));
													} else {
														// endereco
														// cliente
														// responsável
														contaTxt.append(Util
																.completaString(
																		"", 50));
													}
													// completa com
													// espaços
													// em
													// branco
													contaTxt.append(Util
															.completaString("",
																	9));
												} else {
													// completa com
													// espaços
													// em
													// branco
													contaTxt.append(Util
															.completaString("",
																	66));
												}

												// descrição da situação
												// da
												// agua
												// na
												// conta
												String descricaoAguaSituacao = emitirContaHelper
														.getDescricaoLigacaoAguaSituacao();
												contaTxt.append(Util
														.completaString(
																descricaoAguaSituacao,
																16));
												// descrição da situação
												// de
												// esgoto
												// na
												// conta
												String descricaoEsgotoSituacao = emitirContaHelper
														.getDescricaoLigacaoEsgotoSituacao();
												contaTxt.append(Util
														.completaString(
																descricaoEsgotoSituacao,
																47));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 7.A-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("7");
												if (enderecoClienteResponsavel != null
														&& enderecoClienteResponsavel
																.length() > 50) {
													int quantidadePosicoes = enderecoClienteResponsavel
															.length();
													// Recupera o fim do
													// endereço do
													// cliente
													// responsável
													contaTxt.append(Util.completaString(
															enderecoClienteResponsavel
																	.substring(
																			50,
																			quantidadePosicoes),
															60));
													// compleca com
													// espaços
													// em
													// brancos
													contaTxt.append(Util
															.completaString("",
																	69));

												} else {
													// compleca com
													// espaços
													// em
													// brancos
													contaTxt.append(Util
															.completaString("",
																	129));
												}

												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 8-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("7");
												// compleca com espaços
												// em
												// brancos
												contaTxt.append(Util
														.completaString("", 129));
												contaTxt.append(System
														.getProperty("line.separator"));

												// [SB0002] - Determinar
												// tipo de
												// ligação
												// e
												// tipo
												// de
												// Medição
												Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
												Integer tipoLigacao = parmSituacao[0];
												Integer tipoMedicao = parmSituacao[1];

												// --Linha 9-- //
												// Canal
												contaTxt.append("0");
												// Fonte
												contaTxt.append("1");
												// cria uma
												// stringBuilder
												// para
												// recuperar
												// o
												// resultado
												// do
												// [SB0004]
												// o tamanho da string
												// que
												// vem
												// como
												// resultado é
												// de
												// 20
												// posições
												StringBuilder obterDadosConsumoMedicaoAnterior = null;
												// chama o [SB0004]
												// -Obter
												// Dados
												// do
												// Consumo
												// e
												// Medição
												// Anterior
												// passando a quantidade
												// de
												// Meses
												// Igual
												// a 1
												// e o
												// tipo
												// de
												// ligação
												// e medição
												// recuperados
												// anteriormente
												obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
														emitirContaHelper, 1,
														tipoLigacao,
														tipoMedicao);
												contaTxt.append(obterDadosConsumoMedicaoAnterior);
												// chama o [SB0004]
												// -Obter
												// Dados
												// do
												// Consumo
												// e
												// Medição
												// Anterior
												// passando a quantidade
												// de
												// Meses
												// Igual
												// a 4
												// e o
												// tipo
												// de
												// ligação
												// e medição
												// recuperados
												// anteriormente
												obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
														emitirContaHelper, 4,
														tipoLigacao,
														tipoMedicao);
												contaTxt.append(obterDadosConsumoMedicaoAnterior);
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 89));

												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 10-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("1");
												// chama o [SB0004]
												// -Obter
												// Dados
												// do
												// Consumo
												// e
												// Medição
												// Anterior
												// passando a quantidade
												// de
												// Meses
												// Igual
												// a 1
												// e o
												// tipo
												// de
												// ligação
												// e medição
												// recuperados
												// anteriormente
												obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
														emitirContaHelper, 2,
														tipoLigacao,
														tipoMedicao);
												contaTxt.append(obterDadosConsumoMedicaoAnterior);
												// chama o [SB0004]
												// -Obter
												// Dados
												// do
												// Consumo
												// e
												// Medição
												// Anterior
												// passando a quantidade
												// de
												// Meses
												// Igual
												// a 4
												// e o
												// tipo
												// de
												// ligação
												// e medição
												// recuperados
												// anteriormente
												obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
														emitirContaHelper, 5,
														tipoLigacao,
														tipoMedicao);
												contaTxt.append(obterDadosConsumoMedicaoAnterior);
												// Inicio Chamar
												// Sub-Fluxo
												// recupera os
												// parametros da
												// medição
												// historico
												// do
												// [SB0005] - Obter
												// Dados da
												// Medição
												// da
												// Conta
												Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(
														emitirContaHelper,
														tipoMedicao);
												// Leitura Anterior
												String leituraAnterior = "";
												// Leitura Atual
												String leituraAtual = "";
												// Data Leitura Anterior
												String dataLeituraAnterior = "";
												// Leitura Anterior
												String dataLeituraAtual = "";
												// Leitura Situação
												// Atual
												String leituraSituacaoAtual = "";
												// Leitura Anormalidade
												// Faturamento
												String leituraAnormalidadeFaturamento = "";
												if (parmsMedicaoHistorico != null) {

													if (parmsMedicaoHistorico[0] != null) {
														leituraAnterior = ""
																+ (Integer) parmsMedicaoHistorico[0];
													}

													if (parmsMedicaoHistorico[1] != null) {
														leituraAtual = ""
																+ (Integer) parmsMedicaoHistorico[1];
													}

													if (parmsMedicaoHistorico[3] != null) {
														dataLeituraAnterior = Util
																.formatarData((Date) parmsMedicaoHistorico[3]);
													}

													if (parmsMedicaoHistorico[2] != null) {
														dataLeituraAtual = Util
																.formatarData((Date) parmsMedicaoHistorico[2]);
													}

													if (parmsMedicaoHistorico[4] != null) {
														leituraSituacaoAtual = ""
																+ (Integer) parmsMedicaoHistorico[4];
													}

													if (parmsMedicaoHistorico[5] != null) {
														leituraAnormalidadeFaturamento = ""
																+ (Integer) parmsMedicaoHistorico[5];
													}
												}
												String diasConsumo = "";
												if (!dataLeituraAnterior
														.equals("")
														&& !dataLeituraAtual
																.equals("")) {
													// calcula a
													// quantidade
													// de
													// dias
													// de
													// consumo
													// que é
													// a
													// quantidade de
													// dias
													// entre a data de
													// leitura
													// anterior(parmsMedicaoHistorico[2])
													// e
													// a
													// data
													// de
													// leitura
													// atual(parmsMedicaoHistorico[3])
													diasConsumo = ""
															+ Util.obterQuantidadeDiasEntreDuasDatas(
																	(Date) parmsMedicaoHistorico[3],
																	(Date) parmsMedicaoHistorico[2]);
												}

												// recupera os
												// parametros de
												// consumo
												// faturamento
												// e
												// consumo
												// médio
												// diário
												// [SB0005] - Obter
												// Consumo
												// Faturado
												// e
												// Consumo
												// Médio
												// Diário
												String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(
														emitirContaHelper,
														tipoMedicao,
														diasConsumo);
												String consumoFaturamento = parmsConsumo[0];
												String consumoMedioDiario = parmsConsumo[1];
												// Fim Chamar Sub-Fluxo
												// completa com 3
												// espaços em
												// branco
												contaTxt.append(Util
														.completaString("", 3));
												// Leitura Anterior
												contaTxt.append(Util
														.completaString(
																leituraAnterior,
																7));
												// completa com 6
												// espaços em
												// branco
												contaTxt.append(Util
														.completaString("", 6));
												// Leitura Atual
												contaTxt.append(Util
														.completaString(
																leituraAtual, 7));
												// Consumo faturado
												contaTxt.append(Util
														.completaStringComEspacoAEsquerda(
																consumoFaturamento,
																6));
												// completa com 3
												// espaços em
												// branco
												contaTxt.append(Util
														.completaString("", 3));
												// Dias de consumo
												contaTxt.append(Util
														.completaString(
																diasConsumo, 2));
												// Consumo médio diário
												contaTxt.append(Util
														.completaStringComEspacoAEsquerda(
																consumoMedioDiario,
																8));
												// completa com 47
												// espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 47));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 11-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("1");
												// chama o [SB0004]
												// -Obter
												// Dados
												// do
												// Consumo
												// e
												// Medição
												// Anterior
												// passando a quantidade
												// de
												// Meses
												// Igual
												// a 3
												// e o
												// tipo
												// de
												// ligação
												// e medição
												// recuperados
												// anteriormente
												obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
														emitirContaHelper, 3,
														tipoLigacao,
														tipoMedicao);
												contaTxt.append(obterDadosConsumoMedicaoAnterior);
												// chama o [SB0004]
												// -Obter
												// Dados
												// do
												// Consumo
												// e
												// Medição
												// Anterior
												// passando a quantidade
												// de
												// Meses
												// Igual
												// a 6
												// e o
												// tipo
												// de
												// ligação
												// e medição
												// recuperados
												// anteriormente
												obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
														emitirContaHelper, 6,
														tipoLigacao,
														tipoMedicao);
												contaTxt.append(obterDadosConsumoMedicaoAnterior);
												// completa com 4
												// espaços em
												// branco
												contaTxt.append(Util
														.completaString("", 2));
												// Data Leitura Anterior
												contaTxt.append(Util
														.completaString(
																dataLeituraAnterior,
																10));
												// completa com 3
												// espaços em
												// branco
												contaTxt.append(Util
														.completaString("", 3));
												// Data Leitura Atual
												contaTxt.append(Util
														.completaString(
																dataLeituraAtual,
																10));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 64));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 12-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("1");
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 42));

												// Inicio Chamar
												// Sub-Fluxo
												// recupera os
												// parametros do
												// consumo
												// historico
												// da
												// conta
												// [SB0007] - Obter
												// Dados de
												// Consumo
												// da
												// Conta
												Object[] parmsConsumoHistorico = null;
												String descricaoAbreviadaTipoConsumo = "";
												String descricaoTipoConsumo = "";
												String consumoMedio = "";
												String descricaoAbreviadaAnormalidadeConsumo = "";
												String descricaoAnormalidadeConsumo = "";
												String consumoRateio = "";
												// caso o tipo de
												// ligacao
												// for
												// diferente
												// de
												// nulo
												if (tipoLigacao != null) {
													try {
														parmsConsumoHistorico = repositorioMicromedicao
																.obterDadosConsumoConta(
																		emitirContaHelper
																				.getIdImovel(),
																		emitirContaHelper
																				.getAmReferencia(),
																		tipoLigacao);

													} catch (ErroRepositorioException e) {
														sessionContext
																.setRollbackOnly();
														throw new ControladorException(
																"erro.sistema",
																e);
													}

													if (parmsConsumoHistorico != null) {
														// descrição
														// abreviada
														// tipo
														// de
														// consumo
														if (parmsConsumoHistorico[0] != null) {
															descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
														}
														// descrição
														// tipo de
														// consumo
														if (parmsConsumoHistorico[1] != null) {
															descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
														}
														// Consumo médio
														if (parmsConsumoHistorico[2] != null) {
															consumoMedio = ""
																	+ (Integer) parmsConsumoHistorico[2];
														}
														// descrição
														// abreviada
														// anormalidade
														// de
														// consumo
														if (parmsConsumoHistorico[3] != null) {
															descricaoAbreviadaAnormalidadeConsumo = (String) parmsConsumoHistorico[3];
														}
														// descrição
														// anormalidade
														// de
														// consumo
														if (parmsConsumoHistorico[4] != null) {
															descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
														}
														// Consumo médio
														if (parmsConsumoHistorico[5] != null) {
															consumoRateio = ""
																	+ (Integer) parmsConsumoHistorico[5];
														}
													}
												}
												// Fim Chamar Sub-Fluxo

												// constante
												contaTxt.append("CONSUMO ");

												// descrição tipo
												// consumo
												contaTxt.append(Util
														.completaString(
																descricaoTipoConsumo,
																21));
												// descrição da
												// Anormalidade
												// de
												// consumo
												contaTxt.append(Util
														.completaString(
																descricaoAnormalidadeConsumo,
																25));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 34));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 13-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("1");

												// Inicio Chamar
												// Sub-Fluxo
												// soma a quantidades de
												// economias
												// da
												// tabela
												// contaCategoria
												// [SB0007] - Obter
												// Dados da
												// Medição
												// da
												// Conta
												Short quantidadeEconomiaConta = 0;
												try {
													quantidadeEconomiaConta = repositorioFaturamento
															.obterQuantidadeEconomiasConta(emitirContaHelper
																	.getIdConta());
												} catch (ErroRepositorioException e) {
													sessionContext
															.setRollbackOnly();
													throw new ControladorException(
															"erro.sistema", e);
												}
												// Fim Chamar Sub-Fluxo

												// Quantidade de
												// economias
												// da
												// conta
												contaTxt.append(Util
														.completaStringComEspacoAEsquerda(
																""
																		+ quantidadeEconomiaConta,
																4));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 5));
												// Consumo por Economia
												// transforma o
												// consumoFaturamento
												// para
												// um
												// bigDecimal
												BigDecimal consumoFaturadoBigDecimal = null;
												if (consumoFaturamento != null
														&& !consumoFaturamento
																.equals("")) {
													consumoFaturadoBigDecimal = Util
															.formatarMoedaRealparaBigDecimal(consumoFaturamento);
												}
												// transforma a
												// quantidade
												// de
												// economias
												// da
												// conta
												// para um
												// bigDecimal
												BigDecimal qtdEconomiasBigDecimal = null;
												if (quantidadeEconomiaConta != null
														&& !quantidadeEconomiaConta
																.equals("")) {
													qtdEconomiasBigDecimal = Util
															.formatarMoedaRealparaBigDecimal(""
																	+ quantidadeEconomiaConta);
												}

												String consumoEconomia = "";
												if (consumoFaturadoBigDecimal != null
														&& qtdEconomiasBigDecimal != null) {
													BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal
															.divide(qtdEconomiasBigDecimal,
																	2,
																	RoundingMode.UP);
													consumoEconomia = Util
															.formatarMoedaReal(consumoEconomiaBigDecimal);
													if (consumoEconomia != null) {
														consumoEconomia = consumoEconomia
																.substring(
																		0,
																		consumoEconomia
																				.length() - 3);
													}
												}

												// consumo por economia
												contaTxt.append(Util
														.completaStringComEspacoAEsquerda(
																consumoEconomia,
																6));

												// Inicio Chamar
												// Sub-Fluxo
												// concatena os campos
												// dos
												// sub-fluxos
												// anteriores
												// [SB0009] - Obter
												// Código auxiliar
												StringBuilder codigoAuxiliar = new StringBuilder();
												// leitura situação
												// atual
												codigoAuxiliar
														.append(Util
																.adicionarZerosEsquedaNumero(
																		1,
																		leituraSituacaoAtual));
												// tipo de consumo
												codigoAuxiliar
														.append(Util
																.adicionarZerosEsquedaNumero(
																		1,
																		descricaoAbreviadaTipoConsumo));
												// tipo de contrato
												codigoAuxiliar
														.append(Util
																.adicionarZerosEsquedaNumero(
																		1, ""));
												// anormalidade de
												// leitura
												codigoAuxiliar
														.append(Util
																.adicionarZerosEsquedaNumero(
																		2,
																		leituraAnormalidadeFaturamento));
												// anormalidade de
												// consumo
												codigoAuxiliar
														.append(Util
																.adicionarZerosEsquedaNumero(
																		2,
																		descricaoAbreviadaAnormalidadeConsumo));
												// perfil do imóvel
												if (emitirContaHelper
														.getIdImovelPerfil() != null) {
													codigoAuxiliar
															.append(Util
																	.adicionarZerosEsquedaNumero(
																			1,
																			""
																					+ emitirContaHelper
																							.getIdImovelPerfil()));
												} else {
													codigoAuxiliar
															.append(Util
																	.adicionarZerosEsquedaNumero(
																			1,
																			""));
												}
												// dias do consumo
												codigoAuxiliar
														.append(Util
																.adicionarZerosEsquedaNumero(
																		2,
																		diasConsumo));
												// Consumo medio do
												// imóvel
												codigoAuxiliar
														.append(Util
																.adicionarZerosEsquedaNumero(
																		6,
																		consumoMedio));
												// Fim Chamar Sub-Fluxo
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 9));
												// codigo auxiliar
												contaTxt.append(codigoAuxiliar);
												codigoAuxiliar = null;
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 5));
												// chama o [SB0009] -
												// Obter
												// Mensagem
												// de
												// Rateio
												// de
												// Consumo
												// Fixo
												// de Esgoto
												StringBuilder mesagemConsumo = obterMensagemRateioConsumo(
														emitirContaHelper,
														consumoRateio,
														parmsMedicaoHistorico,
														tipoMedicao);
												// mensagem de rateio de
												// consumo
												// ou
												// consumo
												// fixo
												// de
												// esgoto
												contaTxt.append(mesagemConsumo);
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 52));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 14-- //
												// Canal
												contaTxt.append("0");
												// Fonte
												contaTxt.append("1");
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 129));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 15-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("1");
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 129));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 16-- //
												// o canal e a fonte é
												// feito
												// nos
												// subFluxos
												// chama o [SB0010] -
												// Gerar
												// Linhas
												// da
												// Descrição
												// dos
												// Sreviços
												// e
												// Tarifas
												StringBuilder linhasDescricaoServicosTarifasTotal = gerarLinhasDescricaoServicoTarifas(
														emitirContaHelper,
														consumoRateio,
														parmsMedicaoHistorico,
														tipoMedicao);
												StringBuilder linhasDescricaoServicosTarifas = new StringBuilder();
												int posicaoAtual = 0;

												// divide a
												// stringBuilder em
												// linhas
												// dividido
												// em
												// System.getProperty("line.separator")
												String[] posicoesString = linhasDescricaoServicosTarifasTotal
														.toString()
														.split(System
																.getProperty("line.separator"));
												int posicaoLimite = 0;
												// caso a quantidade de
												// linhas
												// seja
												// menor ou
												// igual a
												// zero,pois
												// na conta
												// só cabe 15 linhas,
												// passando
												// isso
												// é
												// preciso
												// gerar
												// outra
												// folha
												// para a
												// conta
												if (posicoesString.length <= 15) {
													// caso esteja vazio
													// o
													// array
													// então
													// completa
													// com
													// espaços
													// em
													// branco
													if (posicoesString.length == 0) {
														// Canal
														contaTxt.append(" ");
														// Fonte
														contaTxt.append("1");
														// completa com
														// espaços
														// em
														// branco
														contaTxt.append(Util
																.completaString(
																		consumoEconomia,
																		129));
														contaTxt.append(System
																.getProperty("line.separator"));
													} else {
														posicaoAtual = 0;
														linhasDescricaoServicosTarifas = linhasDescricaoServicosTarifasTotal;
														linhasDescricaoServicosTarifasTotal = new StringBuilder();
													}
													// caso contrario
													// [FS0006 -
													// Verificar
													// espaços
													// para
													// descrição
													// dos serviços e
													// tarifas
													// totalmente
													// preenchido]
												} else {
													posicaoLimite = posicaoAtual + 15;
													parteInicialcontaTxt = new StringBuilder(
															contaTxt);
													int posicaoInicial = 0;
													for (posicaoInicial = posicaoAtual; posicaoInicial < posicaoLimite; posicaoInicial++) {
														linhasDescricaoServicosTarifas
																.append(posicoesString[posicaoInicial]);
														// verifica se
														// não é
														// a
														// ultima
														// posicao do
														// for
														if (posicaoInicial != posicaoLimite - 1) {
															linhasDescricaoServicosTarifas
																	.append(System
																			.getProperty("line.separator"));
														}
													}
													// posição atual
													// recebe
													// a
													// posição
													// inicial
													posicaoAtual = posicaoInicial;
												}
												// caso a posicao limite
												// seja
												// maior
												// que
												// o
												// tamanho do
												// array,
												// significa
												// que todas as strings
												// já
												// foram
												// atualizadas
												// na
												// conta.
												if (posicoesString.length <= posicaoLimite) {
													// Limpa os campos
													// para
													// mandar
													// para
													// o
													// método
													// que
													// o
													// chamou
													posicaoAtual = 0;
													linhasDescricaoServicosTarifasTotal = null;
												}
												if (linhasDescricaoServicosTarifas != null
														&& linhasDescricaoServicosTarifas
																.length() != 0) {
													contaTxt.append(linhasDescricaoServicosTarifas);
													contaTxt.append(System
															.getProperty("line.separator"));
												}
												linhasDescricaoServicosTarifas = null;
												// --Linha 17-- //
												// Canal
												contaTxt.append("1");
												// Fonte
												contaTxt.append("2");
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 58));
												// cria um objeto conta
												// para
												// calcular o
												// valor da
												// conta
												Conta conta = new Conta();
												conta.setValorAgua(emitirContaHelper
														.getValorAgua());
												conta.setValorEsgoto(emitirContaHelper
														.getValorEsgoto());
												conta.setValorCreditos(emitirContaHelper
														.getValorCreditos());
												conta.setDebitos(emitirContaHelper
														.getDebitos());
												conta.setValorImposto(emitirContaHelper
														.getValorImpostos());
												BigDecimal valorConta = conta
														.getValorTotalContaBigDecimal();
												conta = null;

												String valorContaString = Util
														.formatarMoedaReal(valorConta);
												// valor da conta
												contaTxt.append(Util
														.completaStringComEspacoAEsquerda(
																valorContaString,
																17));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 54));
												contaTxt.append(System
														.getProperty("line.separator"));
												// chama o [SB0016] -
												// Obter
												// Mensagem
												// da
												// Conta em
												// 3
												// Partes
												if (faturamentoGrupo != null
														&& faturamentoGrupo
																.getAnoMesReferencia() != null) {
													emitirContaHelper
															.setAnoMesFaturamentoGrupo(faturamentoGrupo
																	.getAnoMesReferencia());
												}

												String primeiraParte = "";
												String segundaParte = "";
												String terceiraParte = "";

												/*
												 * try{ //Condição adicionada
												 * para situação estpecífica da
												 * COMPESA if
												 * (emitirContaHelper.
												 * getIdImovelPerfil().equals(
												 * ImovelPerfil.TARIFA_SOCIAL)
												 * && emitirContaHelper.getCpf()
												 * == null) {
												 * 
												 * primeiraParte =
												 * "SR(A)  CLIENTE,  FAVOR  COMPARECER   A   UM"
												 * ; segundaParte =
												 * "ATENDIMENTO AO CLIENTE PARA RECADASTRAMENTO"
												 * ; terceiraParte =
												 * "NA TARIFA SOCIAL, NO PRAZO DE 30 DIAS."
												 * ;
												 * 
												 * }else{
												 */
												String[] parmsPartesConta = obterMensagemConta3Partes(
														emitirContaHelper,
														sistemaParametro);
												primeiraParte = parmsPartesConta[0];
												segundaParte = parmsPartesConta[1];
												terceiraParte = parmsPartesConta[2];
												// }

												/*
												 * }catch(NullPointerException
												 * n){ System.out.println(
												 * "Imovel Tarifa: " +
												 * imovel.getMatriculaFormatada
												 * ()); System.out.println(
												 * "Perfil Imovel: " +
												 * imovel.getImovelPerfil
												 * ().getId());
												 * n.printStackTrace(); }
												 */

												// --Linha 18-- //
												// Canal
												contaTxt.append("0");
												// Fonte
												contaTxt.append("7");
												// completa com a
												// primeira
												// parte
												// do
												// [SB0016]
												contaTxt.append(Util
														.completaString(
																primeiraParte,
																129));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 19-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("7");
												// completa com a
												// segunda
												// parte
												// do
												// [SB0016]
												contaTxt.append(Util
														.completaString(
																segundaParte,
																129));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 20-- //
												// Canal
												contaTxt.append(" ");
												// Fonte
												contaTxt.append("7");
												// completa com a
												// terceira
												// parte
												// do
												// [SB0016]
												contaTxt.append(Util
														.completaString(
																terceiraParte,
																129));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 21-- //
												// Canal
												contaTxt.append("1");
												// Fonte
												contaTxt.append("1");
												// Constante
												contaTxt.append(" ");
												// nome da gerencia
												// regional
												contaTxt.append(Util.completaString(
														emitirContaHelper
																.getNomeGerenciaRegional(),
														49));
												int anoMesReferenciaSubtraido = Util
														.subtrairMesDoAnoMes(
																emitirContaHelper
																		.getAmReferencia(),
																1);
												String mesAnoFormatado = Util
														.formatarAnoMesParaMesAno(anoMesReferenciaSubtraido);
												// mes/ano da referencia
												// da
												// conta
												contaTxt.append(Util
														.completaString(
																mesAnoFormatado,
																7));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 72));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 22-- //
												// Canal
												contaTxt.append("0");
												// Fonte
												contaTxt.append("1");
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 18));
												Object[] parmsQualidadeAgua = null;
												try {
													parmsQualidadeAgua = repositorioFaturamento
															.pesquisarParmsQualidadeAgua(emitirContaHelper);
												} catch (ErroRepositorioException e) {
													sessionContext
															.setRollbackOnly();
													throw new ControladorException(
															"erro.sistema", e);
												}

												// numero indice
												// turbidez da
												// qualidade
												// agua
												String numeroIndiceTurbidez = "";
												// numero cloro residual
												// da
												// qualidade
												// agua
												String numeroCloroResidual = "";
												if (parmsQualidadeAgua != null) {
													if (parmsQualidadeAgua[0] != null) {
														numeroIndiceTurbidez = Util
																.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]);
													}

													if (parmsQualidadeAgua[1] != null) {
														numeroCloroResidual = Util
																.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]);
													}
												}
												contaTxt.append(Util
														.completaStringComEspacoAEsquerda(
																numeroIndiceTurbidez,
																6));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 18));
												contaTxt.append(Util
														.completaStringComEspacoAEsquerda(
																numeroCloroResidual,
																6));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 81));
												contaTxt.append(System
														.getProperty("line.separator"));

												// --Linha 23-- //
												// Canal
												contaTxt.append("1");
												// Fonte
												contaTxt.append("1");
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 67));
												// incrementa o
												// sequencial
												// de
												// impressao

												sequencialImpressao = atualizaSequencial(
														sequencialImpressao,
														situacao, metadeColecao);
												// System.out
												// .println("***************************");
												// System.out
												// .println("SEQUENCIAL IMPRESSAO"
												// + sequencialImpressao);
												// System.out
												// .println("***************************");
												// caso seja conta do
												// cliente
												// responsável então o
												// sequencial
												// fica nulo
												if (tipoConta == 3
														|| tipoConta == 4
														|| tipoConta == 7
														|| tipoConta == 8) {
													sequencialEmpresa = null;
												} else {
													sequencialEmpresa = sequencialImpressao;
												}

												/*
												 * switch (i) { case 0:
												 * sequencialImpressaoBaixo++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialImpressaoBaixo,
												 * situacao, metadeColecao);
												 * break; case 1:
												 * sequencialImpressaoEstouro++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialImpressaoEstouro,
												 * situacao, metadeColecao);
												 * break; case 2:
												 * sequencialImpressaoDebito++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialImpressaoDebito,
												 * situacao, metadeColecao);
												 * break; case 3:
												 * sequencialImpressaoEntrega++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialImpressaoEntrega,
												 * situacao, metadeColecao);
												 * break; case 4:
												 * sequencialImpressaoNormal++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialImpressaoNormal,
												 * situacao, metadeColecao);
												 * break; }
												 */

												// incrementa o
												// sequencial
												// de
												// impressao
												/*
												 * switch (i) { case 0:
												 * sequencialEmpresaBaixo++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialEmpresaBaixo,
												 * situacao, metadeColecao);
												 * sequencialEmpresa =
												 * sequencialEmpresaBaixo;
												 * break; case 1:
												 * sequencialEmpresaEstouro++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialEmpresaEstouro,
												 * situacao, metadeColecao);
												 * sequencialEmpresa =
												 * sequencialEmpresaEstouro;
												 * break; case 2:
												 * sequencialEmpresaDebito++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialEmpresaDebito,
												 * situacao, metadeColecao);
												 * sequencialEmpresa =
												 * sequencialEmpresaDebito;
												 * break;
												 * 
												 * case 3:
												 * sequencialEmpresaEntrega++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialEmpresaEntrega,
												 * situacao, metadeColecao);
												 * sequencialEmpresa =
												 * sequencialEmpresaEntrega;
												 * break;
												 * 
												 * case 4:
												 * sequencialEmpresaNormal++;
												 * sequencialImpressao =
												 * atualizaSequencial(
												 * sequencialEmpresaNormal,
												 * situacao, metadeColecao);
												 * sequencialEmpresa =
												 * sequencialEmpresaNormal;
												 * break; }
												 */
												// sequencial impressão
												String sequencialImpressaoFormatada = Util
														.adicionarZerosEsquedaNumero(
																6,
																""
																		+ sequencialImpressao);
												sequencialImpressaoFormatada = sequencialImpressaoFormatada
														.substring(0, 3)
														+ "."
														+ sequencialImpressaoFormatada
																.substring(3, 6);

												// adiciona o sequencial
												// ao
												// txt
												contaTxt.append(Util
														.completaString(
																""
																		+ sequencialImpressaoFormatada,
																7));
												// completa com espaços
												// em
												// branco
												contaTxt.append(Util
														.completaString("", 55));
												contaTxt.append(System
														.getProperty("line.separator"));

												// incrementa o
												// sequencial
												// de
												// impressao
												// e o
												// sequencial
												// de
												// empresa

												// caso a lista de
												// contas
												// seja
												// debito
												// automático
												// i=2;Coleção de contas
												// com
												// débito
												// automático
												StringBuilder[] linhasContas = null;
												if (tipoConta == 2
														|| tipoConta == 4
														|| tipoConta == 6
														|| tipoConta == 8) {
													// [SB0017 - Gerar
													// Linhas
													// das
													// Contas
													// com
													// Débito
													// Automático]
													linhasContas = gerarLinhasContaDebitoAutomatico(
															emitirContaHelper,
															sequencialEmpresa);
												} else {
													// [SB0018 - Gerar
													// Linhas
													// das
													// DemaisContas]
													linhasContas = gerarLinhasDemaisContas(
															emitirContaHelper,
															sequencialEmpresa,
															valorConta);
												}
												// recupera as linhas do
												// subFluxo ou
												// SB0017
												// ou
												// SB0018
												// menos a ultima linha
												// que
												// vai
												// depender
												// da
												// descrição de
												// serviço
												// e tarifas
												StringBuilder linhasConta = linhasContas[0];
												// completa com as
												// linhas
												// menos
												// a
												// ultima
												contaTxt.append(linhasConta);

												StringBuilder ultimaLinhasConta = linhasContas[1];

												// recupera todas as
												// linhas
												// do
												// while
												StringBuilder todasPaginasContaTxt = new StringBuilder();
												// se é a primeira vez
												// que
												// entra
												// no
												// while
												// então
												// recupera o final da
												// linha
												// colocando o
												// continua
												// para depois criar as
												// proximas
												// paginas
												boolean primeiraVez = true;
												// --Linha Ultima(OU
												// OUTRA
												// PAGINA)--
												// //
												// responsável de criar
												// outra
												// pagina
												// para a
												// conta
												// caso a
												// descrição dos
												// serviços e
												// tarifas
												// exceda
												// as 15
												// linhas
												while (posicaoAtual != 0) {
													// é criado para
													// criar a
													// stringBuilder
													// da
													// ultima
													// linha
													// no
													// caso
													// da primeira
													// vez,no
													// caso
													// da
													// segunda
													// vez em
													// diante
													// é
													// criado
													// para criar a
													// proxima
													// pagina
													// da
													// mesma
													// conta
													StringBuilder paginaTxt = new StringBuilder();
													if (primeiraVez) {
														paginaTxt
																.append(ultimaLinhasConta);
														// completa com
														// espaços
														// em
														// branco
														paginaTxt
																.append(Util
																		.completaString(
																				"         ",
																				25));
														// imprime o
														// sequencial
														// de
														// impressão
														paginaTxt
																.append(sequencialImpressaoFormatada);
														// completa com
														// espaços
														// em
														// branco
														paginaTxt
																.append(Util
																		.completaString(
																				"",
																				41));
														primeiraVez = false;
													} else {
														// caso a
														// quantidade
														// de
														// linhas
														// seja
														// menor ou
														// igual a
														// zero,pois na
														// conta só
														// cabe 15
														// linhas,
														// passando
														// isso é
														// preciso gerar
														// outra
														// folha
														// para a
														// conta
														int posicaoInicial = 0;

														// caso o
														// tamanho do
														// array
														// seja
														// maior
														// que a
														// posição
														// atual + 15
														// ex.
														// tamanhoArray(TA)
														// posição
														// Limite
														// (PL)
														// se PA = 15 e
														// TA =
														// 16
														// então PL
														// =
														// 16(TA)
														// senao PA = 15
														// e
														// TA =
														// 32
														// então
														// PL
														// =
														// (15(PA) +
														// 15)
														if (posicoesString.length <= posicaoAtual + 15) {
															posicaoLimite = posicoesString.length;
														} else {
															posicaoLimite = posicaoAtual + 15;
														}
														linhasDescricaoServicosTarifas = new StringBuilder();
														for (posicaoInicial = posicaoAtual; posicaoInicial < posicaoLimite; posicaoInicial++) {
															linhasDescricaoServicosTarifas
																	.append(posicoesString[posicaoInicial]);
															// verifica
															// se
															// não é
															// a
															// ultima
															// posicao
															// do
															// for
															if (posicaoInicial != posicaoLimite - 1) {
																linhasDescricaoServicosTarifas
																		.append(System
																				.getProperty("line.separator"));
															}
														}
														// posição atual
														// recebe
														// a
														// posição
														// inicial
														posicaoAtual = posicaoInicial;

														// caso a
														// posicao
														// limite
														// seja
														// maior
														// que
														// o
														// tamanho do
														// array,
														// significa
														// que todas as
														// strings
														// já
														// foram
														// atualizadas
														// na
														// conta.
														if (posicoesString.length <= posicaoInicial) {
															// Limpa os
															// campos
															// para
															// mandar
															// para
															// o
															// método
															// que
															// o
															// chamou
															posicaoAtual = 0;
															linhasDescricaoServicosTarifasTotal = null;
														}
														paginaTxt
																.append(parteInicialcontaTxt);
														paginaTxt
																.append(linhasDescricaoServicosTarifas);
														paginaTxt
																.append(System
																		.getProperty("line.separator"));
														// completa com
														// 5
														// linhas
														// em
														// branco
														for (int linha = 0; linha < 5; linha++) {
															// --Linha
															// COMPLEMENTAR--
															// //
															// Canal
															paginaTxt
																	.append("1");
															// Fonte
															paginaTxt
																	.append("1");
															// completa
															// com
															// espaços
															// em
															// branco
															paginaTxt
																	.append(Util
																			.completaString(
																					"",
																					129));
															paginaTxt
																	.append(System
																			.getProperty("line.separator"));
														}
														// recupera a
														// ultima
														// linha
														paginaTxt
																.append(ultimaLinhasConta);
														if (posicaoAtual != 0) {
															// completa
															// com
															// espaços
															// em
															// branco
															paginaTxt
																	.append(Util
																			.completaString(
																					"         ",
																					25));
															// imprime o
															// sequencial
															// de
															// impressão
															paginaTxt
																	.append(sequencialImpressaoFormatada);
															// completa
															// com
															// espaços
															// em
															// branco
															paginaTxt
																	.append(Util
																			.completaString(
																					"",
																					41));

															paginaTxt
																	.append(System
																			.getProperty("line.separator"));
														} else {
															// completa
															// com
															// espaços
															// em
															// branco
															paginaTxt
																	.append(Util
																			.completaString(
																					"",
																					25));
															// imprime o
															// sequencial
															// de
															// impressão
															paginaTxt
																	.append(sequencialImpressaoFormatada);
															// completa
															// com
															// espaços
															// em
															// branco
															paginaTxt
																	.append(Util
																			.completaString(
																					"",
																					41));
														}

													}
													todasPaginasContaTxt
															.append(paginaTxt);
													// PEDRO 19/10/2006
													paginaTxt = null;
													if (posicaoAtual != 0) {
														todasPaginasContaTxt
																.append(System
																		.getProperty("line.separator"));
													}
												}

												// coloca a ultima linha
												// ou
												// a
												// outra(s)
												// parte(s)
												// da
												// conta(outra
												// pagina caso a
												// descrição
												// de
												// serviços e
												// tarifas
												// exeda
												// as 15
												// linhas) no txt da
												// conta
												if (todasPaginasContaTxt != null
														&& todasPaginasContaTxt
																.length() != 0) {
													contaTxt.append(todasPaginasContaTxt);
													// PEDRO 19/10/2006
													todasPaginasContaTxt = null;
												} else {
													contaTxt.append(ultimaLinhasConta);
													// completa com
													// espaços
													// em
													// branco
													contaTxt.append(Util
															.completaString("",
																	25));
													// imprime o
													// sequencial
													// de
													// impressão
													contaTxt.append(sequencialImpressaoFormatada);
													// completa com
													// espaços
													// em
													// branco
													contaTxt.append(Util
															.completaString("",
																	41));
												}
												// txt recupera a string
												// builder
												// da
												// conta da
												// lista
												// de
												// contas
												contasTxtLista.append(contaTxt
														.toString());

												// PEDRO 19/10/2006
												contaTxt = null;
												// enquanto estiver
												// proximo
												// if
												// (iteratorConta.hasNext())
												// {
												contasTxtLista
														.append(System
																.getProperty("line.separator"));

												// adiciona o id da
												// conta e o sequencial
												// no para serem
												// atualizados
												mapAtualizaSequencial.put(
														emitirContaHelper
																.getIdConta(),
														sequencialImpressao);

											}// fim do laço que
												// verifica
												// se o
												// helper é diferente de
												// nulo
										}// fim do laço que verifica
											// as 2
											// contas
									}// fim laço while do iterator do
										// objeto
										// helper
									countOrdem++;
									mapContasDivididas = null;
								}// fim do while que pega os Map
									// ordenados
							}// fim do laço que verifica se o Map
								// está
								// nula
								// fim do laço que verifica se a coleção é
								// nula

							if (colecaoConta.size() < quantidadeRegistros) {
								flagTerminou = true;

								if (cartasTxtListaConta != null
										&& cartasTxtListaConta.length() != 0) {
									cartasTxtListaConta.append("\u0004");
									outCartas.write(cartasTxtListaConta
											.toString());
									outCartas.flush();
								}

								if (contasTxtLista != null
										&& contasTxtLista.length() != 0) {
									// fim de arquivo
									contasTxtLista.append("\u0004");
									outContas.write(contasTxtLista.toString());
									outContas.flush();
								}
							} else {
								// **********************************************************
								// Autor: Ivan Sergio
								// Data: 20/08/2009
								// CRC2470
								// Quebra o arquivo em partes determinadas.
								// **********************************************************
								if (quantidadeContas == 20000) {
									quantidadeContas = 0;
									numeroPart++;

									if (cartasTxtListaConta != null
											&& cartasTxtListaConta.length() != 0) {
										cartasTxtListaConta.append("\u0004");
										outCartas.write(cartasTxtListaConta
												.toString());
										outCartas.flush();
									}

									if (contasTxtLista != null
											&& contasTxtLista.length() != 0) {
										// fim de arquivo
										contasTxtLista.append("\u0004");
										outContas.write(contasTxtLista
												.toString());
										outContas.flush();
									}

									ZipOutputStream zosCartasPart = null;
									ZipOutputStream zosContasPart = null;
									File compactadoTipoPart = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip+ "Part_" + numeroPart + ".zip");
									File compactadoTipoCartaPart = null;

									if (nomeZipCartaConta != null) {
										compactadoTipoCartaPart = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZipCartaConta + "Part_"+ numeroPart + ".zip");

										zosCartasPart = new ZipOutputStream(new FileOutputStream(compactadoTipoCartaPart));

										ZipUtil.adicionarArquivo(zosCartasPart,leituraTipoCarta);
										zosCartasPart.close();

										outCartas.close();
										leituraTipoCarta.delete();

										leituraTipoCarta = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZipCartaConta + "Part_"+ (numeroPart + 1)+ ".txt");
										outCartas = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipoCarta.getAbsolutePath())));
									}

									if (geraArquivo) {
										zosContasPart = new ZipOutputStream(new FileOutputStream(compactadoTipoPart));
										ZipUtil.adicionarArquivo(zosContasPart,leituraTipo);
										zosContasPart.close();

										outContas.close();
										leituraTipo.delete();

										leituraTipo = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + "Part_" + (numeroPart + 1) + ".txt");
										outContas = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipo.getAbsolutePath())));
									}
								} else {
									if (cartasTxtListaConta != null && cartasTxtListaConta.length() != 0) {
										outCartas.write(cartasTxtListaConta.toString());
										outCartas.flush();
									}

									if (contasTxtLista != null
											&& contasTxtLista.length() != 0) {
										outContas.write(contasTxtLista
												.toString());
										outContas.flush();
									}
								}
								// **********************************************************
							}
						} else {
							flagTerminou = true;
						}

						numeroIndice = numeroIndice + quantidadeRegistros;

						repositorioFaturamento
								.atualizarSequencialContaImpressao(mapAtualizaSequencial);
						mapAtualizaSequencial = null;

					}// fim laço if da paginação

					if (outCartas != null) {
						if (leituraTipoCarta.length() > 0) {
							// **********************************************************
							// Autor: Ivan Sergio
							// Data: 20/08/2009
							// CRC2470
							// Verifica se o arquivo foi quebrado em partes e
							// renomea
							// **********************************************************
							if (numeroPart > 0) {
								compactadoTipoCarta = new File(
										nomeZipCartaConta + "Part_"
												+ (numeroPart + 1) + ".zip");
							}
							// **********************************************************
							zosCartas = new ZipOutputStream(new FileOutputStream(compactadoTipoCarta));

							ZipUtil.adicionarArquivo(zosCartas,
									leituraTipoCarta);
							zosCartas.close();
							outCartas.close();
							leituraTipoCarta.delete();
						} else {
							outCartas.close();
							leituraTipoCarta.delete();
						}
					}

					if (geraArquivo) {
						if (leituraTipo.length() > 0) {
							// **********************************************************
							// Autor: Ivan Sergio
							// Data: 20/08/2009
							// CRC2470
							// Verifica se o arquivo foi quebrado em partes e
							// renomea
							// **********************************************************
							if (numeroPart > 0) {
								compactadoTipo = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + "Part_" + (numeroPart + 1) + ".zip");
							}
							// **********************************************************
							zosContas = new ZipOutputStream(new FileOutputStream(compactadoTipo));

							ZipUtil.adicionarArquivo(zosContas, leituraTipo);
							zosContas.close();
							outContas.close();
							leituraTipo.delete();
						} else {
							outContas.close();
							leituraTipo.delete();
						}
					} else {
						outContas.close();
						leituraTipo.delete();
					}

					// limpa todos os campos
					/*
					 * nomeZip = null; nomeZipCartaConta = null; compactadoTipo
					 * = null; compactadoTipoCarta = null; leituraTipo = null;
					 * leituraTipoCarta = null; cartasTxtListaConta = null;
					 * contasTxtLista = null;
					 */
					tipoConta++;
				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}

			} catch (IOException e) {
				String mensagem = e.getMessage();
				String[] inicioMensagem = mensagem.split("\\.");
				if (inicioMensagem != null
						&& (inicioMensagem[0].equals("erro") || inicioMensagem[0]
								.equals("atencao"))) {
					throw new ControladorException(mensagem);
				} else {
					throw new ControladorException("erro.sistema", e);
				}
			} catch (Exception e) {
				e.printStackTrace();
				String mensagem = e.getMessage();
				if (mensagem != null) {
					String[] inicioMensagem = mensagem.split("\\.");
					if (inicioMensagem != null
							&& (inicioMensagem[0].equals("erro") || inicioMensagem[0]
									.equals("atencao"))) {
						throw new ControladorException(mensagem);
					} else {
						throw new ControladorException("erro.sistema", e);
					}
				} else {
					throw new ControladorException("erro.sistema", e);
				}
			}

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------

			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) {
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido

			e.printStackTrace();
			// sessionContext.setRollbackOnly();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);

			throw new EJBException(e);
		}

	}

	protected Map<Integer, Map<EmitirContaHelper, EmitirContaHelper>> dividirColecao(
			Collection colecaoContas) {

		Map<Integer, Map<EmitirContaHelper, EmitirContaHelper>> mapContasOrdenada = new HashMap();
		List listColecaoContas = new ArrayList();
		listColecaoContas.addAll(colecaoContas);
		int quantidadeContas = 0;
		int quantidadeContasColecao = listColecaoContas.size();
		int metadeColecao = 0;
		if (quantidadeContasColecao % 2 == 0) {
			metadeColecao = quantidadeContasColecao / 2;
		} else {
			metadeColecao = (quantidadeContasColecao / 2) + 1;
		}
		while (quantidadeContas < metadeColecao) {
			Map<EmitirContaHelper, EmitirContaHelper> mapContas = new HashMap();
			EmitirContaHelper emitirContaHelperPrimeiraParte = (EmitirContaHelper) listColecaoContas
					.get(quantidadeContas);
			EmitirContaHelper emitirContaHelperSegundaParte = null;
			if (metadeColecao + quantidadeContas < quantidadeContasColecao) {
				emitirContaHelperSegundaParte = (EmitirContaHelper) listColecaoContas
						.get(metadeColecao + quantidadeContas);
			}
			mapContas.put(emitirContaHelperPrimeiraParte,
					emitirContaHelperSegundaParte);
			mapContasOrdenada.put(quantidadeContas, mapContas);
			// mapContas.clear();
			mapContas = null;

			quantidadeContas++;
		}
		quantidadeContasColecao = 0;
		// listColecaoContas.clear();
		listColecaoContas = null;

		return mapContasOrdenada;
	}

	protected int atualizaSequencial(int sequencial, int situacao,
			int metadeColecao) {

		int moduloSequencial = sequencial;
		if (sequencial > 1000) {
			moduloSequencial = sequencial % 1000;
			if (moduloSequencial == 0) {
				moduloSequencial = sequencial;
			}
		}
		if (situacao == 1 && moduloSequencial > metadeColecao) {
			sequencial = sequencial - metadeColecao;
		} else {
			if (situacao == 2 && moduloSequencial <= metadeColecao) {
				sequencial = sequencial + metadeColecao;
			}
		}
		return sequencial;
	}

	/**
	 * Metódo que separa a coleção de contas em 5 listas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 * 
	 *             private Collection[] separarListaContas(Collection
	 *             colecaoContas) throws ControladorException {
	 * 
	 *             Collection[] colecaoListas = new Collection[5]; // cria as
	 *             coleções para as divisões das contas Collection
	 *             colecaoContaEstouroConsumo = new ArrayList(); Collection
	 *             colecaoContaBaixoConsumo = new ArrayList(); Collection
	 *             colecaoContaDebitoAutomatico = new ArrayList(); Collection
	 *             colecaoContaEntregaClienteResponsavel = new ArrayList();
	 *             Collection colecaoContaNormal = new ArrayList();
	 * 
	 *             Collection colecaoContaEstouroConsumoTemporaria = new
	 *             ArrayList(); Collection colecaoContaBaixoConsumoTemporaria =
	 *             new ArrayList(); Collection
	 *             colecaoContaDebitoAutomaticoTemporaria = new ArrayList();
	 *             Collection colecaoContaEntregaClienteResponsavelTemporaria =
	 *             new ArrayList(); Collection colecaoContaNormalTemporaria =
	 *             new ArrayList();
	 * 
	 *             List colecaoTotalContas = (List) colecaoContas;
	 * 
	 *             int limiteSuperior; int limiteInferior; int limiteMaximo =
	 *             colecaoTotalContas.size(); int quantidadeMaximaPorColecao =
	 *             100; for (int i = 0; i < limiteMaximo; i = i + 100) {
	 * 
	 *             int totalContas = colecaoContaEstouroConsumo.size() +
	 *             colecaoContaBaixoConsumo.size() +
	 *             colecaoContaDebitoAutomatico.size() +
	 *             colecaoContaEntregaClienteResponsavel.size() +
	 *             colecaoContaNormal.size();
	 * 
	 *             if (limiteMaximo < quantidadeMaximaPorColecao) {
	 *             limiteInferior = 0; limiteSuperior = limiteMaximo; } else {
	 *             limiteInferior = i; limiteSuperior = i + 100;
	 * 
	 *             if (limiteSuperior > limiteMaximo) { limiteSuperior =
	 *             limiteMaximo; } }
	 * 
	 *             List colecaoContasTemporaria = new ArrayList();
	 *             colecaoContasTemporaria.addAll(colecaoTotalContas.subList(
	 *             limiteInferior, limiteSuperior)); // vai adicionando as
	 *             contas que já foram inseridas nas coleções // anteriores para
	 *             não entrar // na próxima consulta(cada conta só pode estar em
	 *             umas dessas // coleções // anteriores) Collection
	 *             idsContasJaUsadas = new ArrayList();
	 * 
	 *             try { // ********************** CONTAS ESTOURO CONSUMO //
	 *             ************************************************** // recebe
	 *             uma coleção de emitir contas helper com // estouros // de
	 *             consumo colecaoContaEstouroConsumoTemporaria =
	 *             repositorioFaturamento .pesquisarContasEstouroOuBaixoConsumo(
	 *             colecaoContasTemporaria,
	 *             ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO);
	 *             Iterator iteratorEstouroConsumoAux =
	 *             colecaoContaEstouroConsumoTemporaria .iterator(); while
	 *             (iteratorEstouroConsumoAux.hasNext()) { EmitirContaHelper
	 *             emitirContaHelper = (EmitirContaHelper)
	 *             iteratorEstouroConsumoAux .next(); // inseri o id da conta
	 *             para não entrar o id da conta na // proxima // consulta
	 *             idsContasJaUsadas.add(emitirContaHelper.getIdConta()); }
	 *             colecaoContaEstouroConsumo
	 *             .addAll(colecaoContaEstouroConsumoTemporaria); // retira os
	 *             ids da conta que já foram inseridos na coleção de // contas
	 *             com estouro de consumo
	 *             colecaoContasTemporaria.removeAll(idsContasJaUsadas);
	 *             idsContasJaUsadas = new ArrayList(); //
	 *             ********************** CONTAS ESTOURO CONSUMO //
	 *             ************************************************** //
	 *             ********************** CONTAS BAIXO CONSUMO //
	 *             ************************************************** // recebe
	 *             uma coleção de parametros(Object[]) das contas com // baixo
	 *             // consumo colecaoContaBaixoConsumoTemporaria =
	 *             repositorioFaturamento .pesquisarContasEstouroOuBaixoConsumo(
	 *             colecaoContasTemporaria,
	 *             ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO);
	 *             Iterator iteratorBaixoConsumoAux =
	 *             colecaoContaBaixoConsumoTemporaria .iterator(); while
	 *             (iteratorBaixoConsumoAux.hasNext()) { EmitirContaHelper
	 *             emitirContaHelper = (EmitirContaHelper)
	 *             iteratorBaixoConsumoAux .next(); // inseri o id da conta para
	 *             não entrar o id da conta na // proxima // consulta
	 *             idsContasJaUsadas.add(emitirContaHelper.getIdConta()); }
	 *             colecaoContaBaixoConsumo
	 *             .addAll(colecaoContaBaixoConsumoTemporaria); // retira os ids
	 *             da conta que já foram inseridos na coleção de // contas com
	 *             baixo de consumo
	 *             colecaoContasTemporaria.removeAll(idsContasJaUsadas);
	 *             idsContasJaUsadas = new ArrayList(); //
	 *             ********************** FIM CONTAS BAIXO CONSUMO //
	 *             ************************************************ //
	 *             ********************** CONTAS DEBITO AUTOMATICO //
	 *             ********************************************************** //
	 *             recebe uma coleção de emitir contas helper com // Dédito
	 *             automático colecaoContaDebitoAutomaticoTemporaria =
	 *             repositorioFaturamento
	 *             .pesquisarContasDebitoAutomatico(colecaoContasTemporaria);
	 *             Iterator iteratorDebitoAutomaticoAux =
	 *             colecaoContaDebitoAutomaticoTemporaria .iterator(); while
	 *             (iteratorDebitoAutomaticoAux.hasNext()) { EmitirContaHelper
	 *             emitirContaHelper = (EmitirContaHelper)
	 *             iteratorDebitoAutomaticoAux .next(); // inseri o id da conta
	 *             para não entrar o id da conta na // proxima // consulta
	 *             idsContasJaUsadas.add(emitirContaHelper.getIdConta()); }
	 *             colecaoContaDebitoAutomatico
	 *             .addAll(colecaoContaDebitoAutomaticoTemporaria); // retira os
	 *             ids da conta que já foram inseridos na coleção de // contas
	 *             com débito automático
	 *             colecaoContasTemporaria.removeAll(idsContasJaUsadas);
	 *             idsContasJaUsadas = new ArrayList(); //
	 *             ********************** FIM CONTAS DEBITO AUTOMATICO //
	 *             ********************************************************** //
	 *             ********************** CONTAS ENTREGA CLIENTE RESPONSAVEL //
	 *             ********************************************************** //
	 *             recebe uma coleção de emitir contas helper com // entrega
	 *             cliente responsável
	 *             colecaoContaEntregaClienteResponsavelTemporaria =
	 *             repositorioFaturamento
	 *             .pesquisarContasClienteResponsavel(colecaoContasTemporaria);
	 *             Iterator iteratorEntregaClienteRespAux =
	 *             colecaoContaEntregaClienteResponsavelTemporaria .iterator();
	 *             while (iteratorEntregaClienteRespAux.hasNext()) {
	 *             EmitirContaHelper emitirContaHelper = (EmitirContaHelper)
	 *             iteratorEntregaClienteRespAux .next(); // inseri o id da
	 *             conta para não entrar o id da conta na // proxima // consulta
	 *             idsContasJaUsadas.add(emitirContaHelper.getIdConta()); }
	 *             colecaoContaEntregaClienteResponsavel
	 *             .addAll(colecaoContaEntregaClienteResponsavelTemporaria); //
	 *             retira os ids da conta que já foram inseridos na coleção de
	 *             // contas com entrega para o cliente responsável
	 *             colecaoContasTemporaria.removeAll(idsContasJaUsadas);
	 *             idsContasJaUsadas = new ArrayList(); //
	 *             ********************** FIM CONTAS ENTREGA CLIENTE RESPONSAVEL
	 *             // ****************************************************** //
	 *             ********************** CONTAS NORMAIS //
	 *             ********************************************************** //
	 *             recebe uma coleção de emitir contas helper normais(que // não
	 *             atenderam a nenhuma condição acima)
	 *             colecaoContaNormalTemporaria = repositorioFaturamento
	 *             .pesquisarContasNormais(colecaoContasTemporaria);
	 *             colecaoContaNormal.addAll(colecaoContaNormalTemporaria); //
	 *             ********************** FIM CONTAS NORMAIS //
	 *             ********************************************************** }
	 *             catch (ErroRepositorioException e) { throw new
	 *             ControladorException("erro.sistema", e); } }
	 * 
	 *             colecaoListas[0] = colecaoContaEstouroConsumo;
	 *             colecaoListas[1] = colecaoContaBaixoConsumo; colecaoListas[2]
	 *             = colecaoContaDebitoAutomatico; colecaoListas[3] =
	 *             colecaoContaEntregaClienteResponsavel; colecaoListas[4] =
	 *             colecaoContaNormal;
	 * 
	 *             return colecaoListas; }
	 */

	protected Collection[] pesquisarColecaoContasEstouroConsumo(
			Collection colecaoContas) throws ControladorException {

		Collection colecaoContaEstouroConsumo = new ArrayList();

		// Collection colecaoContaEstouroConsumoTemporaria = new ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo =
		 * colecaoTotalContas.size(); int quantidadeMaximaPorColecao = 100;
		 */
		Collection idsContasJaUsadas = new ArrayList();
		// for (int i = 0; i < limiteMaximo; i = i + 100) {

		// int totalContas = colecaoContaEstouroConsumo.size();

		// System.out.println("################### PESQUISANDO CONTAS ESTOURO :"
		// + totalContas + "#########################");

		/*
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0;
		 * limiteSuperior = limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * 
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; }
		 * }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		// try {
		/*
		 * colecaoContaEstouroConsumo = repositorioFaturamento
		 * .pesquisarContasEstouroOuBaixoConsumo( colecaoContas,
		 * ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO);
		 */
		Iterator iteratorEstouroConsumoAux = colecaoContaEstouroConsumo
				.iterator();
		while (iteratorEstouroConsumoAux.hasNext()) {
			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) iteratorEstouroConsumoAux
					.next();
			// inseri o id da conta para não entrar o id da conta na
			// proxima
			// consulta
			idsContasJaUsadas.add(emitirContaHelper.getIdConta());
		}
		// colecaoContaEstouroConsumo.addAll(colecaoContaEstouroConsumoTemporaria);
		// colecaoContaEstouroConsumoTemporaria = null;

		// ********************** CONTAS ESTOURO CONSUMO
		// **************************************************

		/*
		 * } catch (ErroRepositorioException e) { throw new
		 * ControladorException("erro.sistema", e); }
		 */
		// }
		// colecaoContas.removeAll(idsContasJaUsadas);
		Collection[] retorno = new Collection[2];
		retorno[0] = colecaoContaEstouroConsumo;
		retorno[1] = idsContasJaUsadas;

		// idsContasJaUsadas = null;
		return retorno;
	}

	protected Collection[] pesquisarColecaoContasBaixoConsumo(
			Collection colecaoContas) throws ControladorException {

		Collection colecaoContaBaixoConsumo = new ArrayList();

		// Collection colecaoContaBaixoConsumoTemporaria = new ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo =
		 * colecaoTotalContas.size(); int quantidadeMaximaPorColecao = 100;
		 */
		Collection idsContasJaUsadas = new ArrayList();
		// for (int i = 0; i < limiteMaximo; i = i + 100) {

		// int totalContas = colecaoContaBaixoConsumo.size();

		// System.out.println("################### PESQUISANDO CONTAS BAIXO
		// CONSUMO :" + totalContas + "#########################");

		/*
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0;
		 * limiteSuperior = limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * 
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; }
		 * }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		// try {
		// ********************** CONTAS BAIXO CONSUMO
		// **************************************************
		// recebe uma coleção de parametros(Object[]) das contas com
		// baixo
		// consumo
		/*
		 * colecaoContaBaixoConsumo = repositorioFaturamento
		 * .pesquisarContasEstouroOuBaixoConsumo(colecaoContas,
		 * ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO);
		 */
		Iterator iteratorBaixoConsumoAux = colecaoContaBaixoConsumo.iterator();
		while (iteratorBaixoConsumoAux.hasNext()) {
			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) iteratorBaixoConsumoAux
					.next();
			// inseri o id da conta para não entrar o id da conta na
			// proxima
			// consulta
			idsContasJaUsadas.add(emitirContaHelper.getIdConta());
		}

		// colecaoContaBaixoConsumo.addAll(colecaoContaBaixoConsumoTemporaria);
		// colecaoContaBaixoConsumoTemporaria = null;

		// ********************** FIM CONTAS BAIXO CONSUMO
		// ************************************************

		/*
		 * } catch (ErroRepositorioException e) { throw new
		 * ControladorException("erro.sistema", e); }
		 */
		// }
		// colecaoContas.removeAll(idsContasJaUsadas);
		Collection[] retorno = new Collection[2];
		retorno[0] = colecaoContaBaixoConsumo;
		retorno[1] = idsContasJaUsadas;

		// idsContasJaUsadas = null;
		return retorno;
	}

	protected Collection[] pesquisarColecaoContasDebitoAutomatico(
			Collection colecaoContas) throws ControladorException {

		Collection colecaoContaDebitoAutomatico = new ArrayList();

		// Collection colecaoContaDebitoAutomaticoTemporaria = new ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo =
		 * colecaoTotalContas.size(); int quantidadeMaximaPorColecao = 100;
		 */
		Collection idsContasJaUsadas = new ArrayList();

		// for (int i = 0; i < limiteMaximo; i = i + 100) {

		// int totalContas = colecaoContaDebitoAutomatico.size();
		// System.out.println("################### PESQUISANDO CONTAS DEBITO
		// AUTOMATICO :" + totalContas + "#########################");

		/*
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0;
		 * limiteSuperior = limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * 
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; }
		 * }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		try {
			// ********************** CONTAS DEBITO AUTOMATICO
			// **********************************************************
			// recebe uma coleção de emitir contas helper com
			// Dédito automático
			colecaoContaDebitoAutomatico = repositorioFaturamento
					.pesquisarContasDebitoAutomatico(colecaoContas);
			Iterator iteratorDebitoAutomaticoAux = colecaoContaDebitoAutomatico
					.iterator();
			while (iteratorDebitoAutomaticoAux.hasNext()) {
				EmitirContaHelper emitirContaHelper = (EmitirContaHelper) iteratorDebitoAutomaticoAux
						.next();

				// inseri o id da conta para não entrar o id da conta na
				// proxima
				// consulta
				idsContasJaUsadas.add(emitirContaHelper.getIdConta());
			}
			// colecaoContaDebitoAutomatico.addAll(colecaoContaDebitoAutomaticoTemporaria);

			// colecaoContaDebitoAutomaticoTemporaria = null;

			// ********************** FIM CONTAS DEBITO AUTOMATICO
			// **********************************************************

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		// }
		Collection[] retorno = new Collection[2];
		retorno[0] = colecaoContaDebitoAutomatico;
		retorno[1] = idsContasJaUsadas;

		// idsContasJaUsadas = null;
		return retorno;
	}

	protected Collection[] pesquisarColecaoContasEntregaClienteResponsavel(
			Collection colecaoContas) throws ControladorException {

		Collection colecaoContaEntregaClienteResponsavel = new ArrayList();

		// Collection colecaoContaEntregaClienteResponsavelTemporaria = new
		// ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo =
		 * colecaoTotalContas.size(); int quantidadeMaximaPorColecao = 100;
		 */
		Collection idsContasJaUsadas = new ArrayList();
		// for (int i = 0; i < limiteMaximo; i = i + 100) {

		/*
		 * int totalContas = colecaoContaEntregaClienteResponsavel.size();
		 * System.out.println("################### PESQUISANDO CONTAS CLIENTE
		 * RESPONSAVEL:" + totalContas + "#########################");
		 * 
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0;
		 * limiteSuperior = limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * 
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; }
		 * }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		/*
		 * try { // ********************** CONTAS ENTREGA CLIENTE RESPONSAVEL //
		 * ********************************************************** // recebe
		 * uma coleção de emitir contas helper com // entrega cliente
		 * responsável colecaoContaEntregaClienteResponsavel =
		 * repositorioFaturamento
		 * .pesquisarContasClienteResponsavel(colecaoContas); Iterator
		 * iteratorEntregaClienteRespAux = colecaoContaEntregaClienteResponsavel
		 * .iterator(); while (iteratorEntregaClienteRespAux.hasNext()) {
		 * EmitirContaHelper emitirContaHelper = (EmitirContaHelper)
		 * iteratorEntregaClienteRespAux .next(); // inseri o id da conta para
		 * não entrar o id da conta na // proxima // consulta
		 * idsContasJaUsadas.add(emitirContaHelper.getIdConta()); } //
		 * colecaoContaEntregaClienteResponsavel
		 * .addAll(colecaoContaEntregaClienteResponsavelTemporaria); //
		 * colecaoContaEntregaClienteResponsavelTemporaria = null; } catch
		 * (ErroRepositorioException e) { throw new
		 * ControladorException("erro.sistema", e); }
		 */
		// }
		Collection[] retorno = new Collection[2];
		retorno[0] = colecaoContaEntregaClienteResponsavel;
		retorno[1] = idsContasJaUsadas;

		// idsContasJaUsadas = null;
		return retorno;
	}

	protected Collection pesquisarColecaoContasNormais(Collection colecaoContas)
			throws ControladorException {

		Collection colecaoContaNormal = new ArrayList();

		// Collection colecaoContaNormalTemporaria = new ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo =
		 * colecaoTotalContas.size(); int quantidadeMaximaPorColecao = 100;
		 */
		// for (int i = 0; i < limiteMaximo; i = i + 100) {
		/*
		 * int totalContas = colecaoContaNormal.size();
		 * System.out.println("################### PESQUISANDO CONTAS NORMAIS :"
		 * + totalContas + "#########################");
		 * 
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0;
		 * limiteSuperior = limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * 
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; }
		 * }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		try {

			// ********************** CONTAS NORMAIS
			// **********************************************************
			// recebe uma coleção de emitir contas helper normais(que
			// não atenderam a nenhuma condição acima)
			colecaoContaNormal = repositorioFaturamento
					.pesquisarContasNormais(colecaoContas);
			// colecaoContaNormal.addAll(colecaoContaNormalTemporaria);
			// colecaoContaNormalTemporaria = null;
			// ********************** FIM CONTAS NORMAIS
			// **********************************************************

			// colecaoContas = null;
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		// }

		return colecaoContaNormal;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0001] Determinar Mensagem de Acordo com o Tipo de Conta
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected String determinarMensagem(int tipoConta)
			throws ControladorException {

		String mensagem = "";

		switch (tipoConta) {
		// Caso a conta seja com estouro de consumo
		case 0:
			mensagem = "CONTA RETIDA - CONSUMO MUITO SUPERIOR A MEDIA";
			break;
		// Caso a conta seja de baixo consumo
		case 1:
			mensagem = "CONTA RETIDA - CONSUMO MUITO INFERIOR A MEDIA";
		}

		return mensagem;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0002] Determinar tipo de ligação e tipo de medição
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Integer[] determinarTipoLigacaoMedicao(
			EmitirContaHelper emitirContaHelper) throws ControladorException {

		Integer[] parmSitLigacao = new Integer[2];
		Integer tipoLigacao = null;
		Integer tipoMedicao = null;

		// se a situação de agua da conta for ligado ou cortado
		if (emitirContaHelper.getIdLigacaoAguaSituacao().equals(
				LigacaoAguaSituacao.LIGADO)
				|| emitirContaHelper.getIdLigacaoAguaSituacao().equals(
						LigacaoAguaSituacao.CORTADO)
				|| emitirContaHelper.getIdLigacaoAguaSituacao().equals(
						LigacaoAguaSituacao.LIGADO_A_REVELIA)) {

			tipoLigacao = LigacaoTipo.LIGACAO_AGUA;
			tipoMedicao = MedicaoTipo.LIGACAO_AGUA;
		} else {
			// caso contrário se ligação esgoto situação for iguaç a ligado
			if (emitirContaHelper.getIdLigacaoEsgotoSituacao().equals(
					LigacaoEsgotoSituacao.LIGADO)) {
				tipoLigacao = LigacaoTipo.LIGACAO_ESGOTO;
				tipoMedicao = MedicaoTipo.POCO;
			}
		}
		parmSitLigacao[0] = tipoLigacao;
		parmSitLigacao[1] = tipoMedicao;

		return parmSitLigacao;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0003] Obter Dados do Consumo e Medicao Anterior
	 * 
	 * @author Sávio Luiz
	 * @date 17/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder obterDadosConsumoAnterior(
			EmitirContaHelper emitirConta, int qtdMeses, Integer tipoLigacao,
			Integer tipoMedicao) throws ControladorException {

		StringBuilder dadosConsumoAnterior = new StringBuilder();

		int anoMesSubtraido = Util.subtrairMesDoAnoMes(
				emitirConta.getAmReferencia(), qtdMeses);
		String mesAnoFormatado = Util.formatarAnoMesParaMesAno(anoMesSubtraido)
				+ " -";

		// adiciona o mes/ano formatado com o traço
		dadosConsumoAnterior.append(Util.completaString(mesAnoFormatado, 9));
		// caso o tipo de ligação e medição seja diferente de nulo
		if (tipoLigacao != null && tipoMedicao != null) {
			Object[] parmsConsumoHistorico = null;
			Integer idLeituraAnormalidade = null;
			parmsConsumoHistorico = getControladorMicromedicao()
					.obterConsumoAnteriorAnormalidadeDoImovel(
							emitirConta.getIdImovel(), anoMesSubtraido,
							tipoLigacao);
			Integer numeroConsumoFaturadoMes = null;
			String descricaoAbreviadaAnormalidadeAnterior = null;
			if (parmsConsumoHistorico != null) {
				if (parmsConsumoHistorico[0] != null) {
					numeroConsumoFaturadoMes = (Integer) parmsConsumoHistorico[0];
				}
				if (parmsConsumoHistorico[1] != null) {
					descricaoAbreviadaAnormalidadeAnterior = (String) parmsConsumoHistorico[1];
				}
			}
			try {

				// caso o tipo de medição seja agua
				if (tipoLigacao.equals(MedicaoTipo.LIGACAO_AGUA)) {
					idLeituraAnormalidade = repositorioMicromedicao
							.pesquisarIdLeituraAnormalidadeTipoAgua(
									emitirConta.getIdImovel(), anoMesSubtraido);
				} else {
					// senão caso o tipo de medição seja poco
					if (tipoMedicao.equals(MedicaoTipo.POCO)) {
						idLeituraAnormalidade = repositorioMicromedicao
								.pesquisarIdLeituraAnormalidadeTipoEsgoto(
										emitirConta.getIdImovel(),
										anoMesSubtraido);
					}
				}
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}
			// caso o numero consumo faturado do mes for diferente de nulo
			if (numeroConsumoFaturadoMes != null) {
				dadosConsumoAnterior.append(Util
						.completaStringComEspacoAEsquerda(""
								+ numeroConsumoFaturadoMes, 6));
			} else {
				dadosConsumoAnterior.append(Util
						.completaStringComEspacoAEsquerda("", 6));
			}
			// caso o id dos dados do consumo anterior for diferente de nulo
			if (idLeituraAnormalidade != null) {
				dadosConsumoAnterior.append(Util.completaString("-"
						+ idLeituraAnormalidade, 5));
			} else {
				if (descricaoAbreviadaAnormalidadeAnterior != null) {
					dadosConsumoAnterior.append(Util.completaString("-"
							+ descricaoAbreviadaAnormalidadeAnterior, 5));
				} else {
					dadosConsumoAnterior.append(Util.completaString("", 5));
				}
			}
		} else {
			// senão completa com espaços em branco
			dadosConsumoAnterior.append(Util.completaString("", 11));
		}

		return dadosConsumoAnterior;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0004] Obter Dados da Medição da Conta
	 * 
	 * @author Sávio Luiz
	 * @date 17/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Object[] obterDadosMedicaoConta(EmitirContaHelper emitirContaHelper,
			Integer tipoMedicao) throws ControladorException {
		Object[] parmsMedicao = null;
		try {

			/**
			 * Inclusao de um campo no retorno do método.
			 * Melhorias na 2 via da conta impressa.
			 */
			// caso o tipo de medição seja agua
			if (tipoMedicao != null
					&& tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
				parmsMedicao = repositorioMicromedicao
						.obterDadosMedicaoContaTipoAgua(
								emitirContaHelper.getIdImovel(),
								emitirContaHelper.getAmReferencia());

				if (parmsMedicao == null) {
					parmsMedicao = new Object[9];
				}

				// CRC4202 - adicionado por Vivianne Sousa 20/09/2010 -
				// analista: Adriana Ribeiro
				if (emitirContaHelper.getIdConta() != null) {
					Object[] dadosLeituraAnteriorEAtualDaConta = this
							.obterLeituraAnteriorEAtualDaConta(emitirContaHelper
									.getIdConta());
					if (dadosLeituraAnteriorEAtualDaConta != null) {
						if (dadosLeituraAnteriorEAtualDaConta[0] != null) {
							parmsMedicao[0] = dadosLeituraAnteriorEAtualDaConta[0];
						}
						if (dadosLeituraAnteriorEAtualDaConta[1] != null) {
							parmsMedicao[1] = dadosLeituraAnteriorEAtualDaConta[1];
						}
					}
				}

			} else {
				// senão caso o tipo de medição seja poco
				if (tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO)) {
					parmsMedicao = repositorioMicromedicao
							.obterDadosMedicaoContaTipoPoco(
									emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia());
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return parmsMedicao;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0005] Obter Consumo Faturado e Consumo médio Diário
	 * 
	 * @author Sávio Luiz
	 * @date 17/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public String[] obterConsumoFaturadoConsumoMedioDiario(
			EmitirContaHelper emitirContaHelper, Integer tipoMedicao,
			String diasConsumo) throws ControladorException {
		String[] parmsConsumo = new String[2];
		String consumoFaturado = "";
		String consumoMedioDiario = "";
		// caso o tipo de medição seja agua
		if (tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)) {
			consumoFaturado = "" + emitirContaHelper.getConsumoAgua();
		} else {
			// senão caso o tipo de medição seja poco
			if (tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO)) {
				consumoFaturado = "" + emitirContaHelper.getConsumoEsgoto();
			}
		}
		// se o consumo faturado e o dias consumo não estiver vazio
		if (consumoFaturado != null && !consumoFaturado.equals("")
				&& diasConsumo != null && !diasConsumo.equals("")
				&& !diasConsumo.equals("0")) {
			BigDecimal consumoMedioBigDecimal = Util
					.formatarMoedaRealparaBigDecimal(consumoFaturado);
			BigDecimal diasConsumoBigDecimal = Util
					.formatarMoedaRealparaBigDecimal(diasConsumo);
			if (consumoMedioBigDecimal != null && diasConsumoBigDecimal != null) {
				BigDecimal consumoMedioDiarioBigDecimal = consumoMedioBigDecimal
						.divide(diasConsumoBigDecimal, 2, RoundingMode.UP);
				consumoMedioDiario = consumoMedioDiarioBigDecimal.toString()
						.replace(".", ",");
			}

		}
		parmsConsumo[0] = consumoFaturado;
		parmsConsumo[1] = consumoMedioDiario;

		return parmsConsumo;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0009] Obter Mensagem de Rateio de Consumo ou Consumo fixo de Esgoto
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder obterMensagemRateioConsumo(EmitirContaHelper emitirContaHelper, String consumoRateio, Object[] parmsMedicaoHistorico, 
			Integer tipoMedicao) throws ControladorException {
		
		StringBuilder mensagemConsumo = new StringBuilder();

		if (!consumoRateio.equals("") && !consumoRateio.equals("0")) {
			mensagemConsumo.append("CONSUMO DO RATEIO - ");
			mensagemConsumo.append(Util.completaStringComEspacoAEsquerda(consumoRateio, 6));
			mensagemConsumo.append("M3");
			mensagemConsumo.append(Util.completaString("", 4));
		} else {
			if (tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO) && parmsMedicaoHistorico == null) {
				mensagemConsumo.append("VOLUME FIXO DE ESGOTO - ");
				mensagemConsumo.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 6));
				mensagemConsumo.append("M3");
			} else {
				if (tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA) && emitirContaHelper.getConsumoEsgoto() != null
						&& emitirContaHelper.getConsumoEsgoto() > emitirContaHelper.getConsumoAgua()) {

					mensagemConsumo.append("VOLUME FIXO DE ESGOTO - ");
					mensagemConsumo.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 6));
					mensagemConsumo.append("M3");

				} else {
					mensagemConsumo.append(Util.completaString("", 32));
				}
			}
		}

		return mensagemConsumo;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00010] Gerar Linhas da Descrição dos Serviços e Tarifas
	 * 
	 * @author Sávio Luiz
	 * @date 26/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder gerarLinhasDescricaoServicoTarifas(
			EmitirContaHelper emitirContaHelper, String consumoRateio,
			Object[] parmsMedicaoHistorico, Integer tipoMedicao)
			throws ControladorException {

		StringBuilder linhasDescricaoServicosTarifasTotal = new StringBuilder();
		// caso o valor da agua da conta seja maior que zero
		if (emitirContaHelper.getValorAgua() != null
				&& emitirContaHelper.getValorAgua().compareTo(
						new BigDecimal("0.00")) == 1) {
			// [SB0011] - Gerar Linhas da Tarifa de Água
			StringBuilder linhasTarifaAgua = gerarLinhasTarifaAgua(
					emitirContaHelper, consumoRateio, parmsMedicaoHistorico,
					tipoMedicao);
			linhasDescricaoServicosTarifasTotal.append(linhasTarifaAgua);
		}
		// caso o valor de água de esgoto seja maior que zero
		if (emitirContaHelper.getValorEsgoto() != null
				&& emitirContaHelper.getValorEsgoto().compareTo(
						new BigDecimal("0.00")) == 1) {

			// [SB0012] - Gerar Linhas da tarifa de Esgoto
			StringBuilder linhasTarifaEsgoto = gerarLinhasTarifaEsgoto(emitirContaHelper);
			// caso a stringBuilder já esteja preenchida
			if (linhasDescricaoServicosTarifasTotal != null
					&& linhasDescricaoServicosTarifasTotal.length() != 0) {
				// caso a stringBuilder já esteja preenchida
				if (linhasTarifaEsgoto != null
						&& linhasTarifaEsgoto.length() != 0) {
					linhasDescricaoServicosTarifasTotal.append(System
							.getProperty("line.separator"));
					linhasDescricaoServicosTarifasTotal
							.append(linhasTarifaEsgoto);
				}
			} else {
				linhasDescricaoServicosTarifasTotal.append(linhasTarifaEsgoto);
			}

		}
		// caso o valor de debitos cobrados da conta seja maior que zero
		if (emitirContaHelper.getDebitos() != null
				&& emitirContaHelper.getDebitos().compareTo(
						new BigDecimal("0.00")) == 1) {
			// [SB0013] - Gerar Linhas de Débitos Cobrados
			StringBuilder linhasDebitoCobrados = gerarLinhasDebitoCobrados(emitirContaHelper);
			// caso a stringBuilder já esteja preenchida
			if (linhasDescricaoServicosTarifasTotal != null
					&& linhasDescricaoServicosTarifasTotal.length() != 0) {
				// caso a stringBuilder já esteja preenchida
				if (linhasDebitoCobrados != null
						&& linhasDebitoCobrados.length() != 0) {
					linhasDescricaoServicosTarifasTotal.append(System
							.getProperty("line.separator"));
					linhasDescricaoServicosTarifasTotal
							.append(linhasDebitoCobrados);
				}
			} else {
				linhasDescricaoServicosTarifasTotal
						.append(linhasDebitoCobrados);
			}

		}
		// caso o valor de créditos realizados seja maior que zero
		if (emitirContaHelper.getValorCreditos() != null
				&& emitirContaHelper.getValorCreditos().compareTo(
						new BigDecimal("0.00")) == 1) {
			// [SB0014] - Gerar Linhas de Crédito Realizado
			StringBuilder linhasCreditoRealizados = gerarLinhasCreditosRealizados(emitirContaHelper);

			// caso a stringBuilder já esteja preenchida
			if (linhasDescricaoServicosTarifasTotal != null
					&& linhasDescricaoServicosTarifasTotal.length() != 0) {
				if (linhasCreditoRealizados != null
						&& linhasCreditoRealizados.length() != 0) {
					linhasDescricaoServicosTarifasTotal.append(System
							.getProperty("line.separator"));
					linhasDescricaoServicosTarifasTotal
							.append(linhasCreditoRealizados);
				}
			} else {
				linhasDescricaoServicosTarifasTotal
						.append(linhasCreditoRealizados);
			}

		}
		// caso o valor dos impostos retidos seja maior que zero
		if (emitirContaHelper.getValorImpostos() != null
				&& emitirContaHelper.getValorImpostos().compareTo(
						new BigDecimal("0.00")) == 1) {
			// [SB0015] - Gerar Linhas dos Impostos Retidos
			StringBuilder linhasImpostosRetidos = gerarLinhasImpostosRetidos(emitirContaHelper);

			// caso a stringBuilder já esteja preenchida
			if (linhasDescricaoServicosTarifasTotal != null
					&& linhasDescricaoServicosTarifasTotal.length() != 0) {
				// caso a stringBuilder já esteja preenchida
				if (linhasImpostosRetidos != null
						&& linhasImpostosRetidos.length() != 0) {
					linhasDescricaoServicosTarifasTotal.append(System
							.getProperty("line.separator"));
					linhasDescricaoServicosTarifasTotal
							.append(linhasImpostosRetidos);
				}
			} else {
				linhasDescricaoServicosTarifasTotal
						.append(linhasImpostosRetidos);
			}

		}

		return linhasDescricaoServicosTarifasTotal;

	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00011] Gerar Linhas da Tarifa de Água
	 * 
	 * @author Sávio Luiz
	 * @date 22/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasTarifaAgua(
			EmitirContaHelper emitirContaHelper, String consumoRateio,
			Object[] parmsMedicaoHistorico, Integer tipoMedicao)
			throws ControladorException {
		StringBuilder linhasTarifaAgua = new StringBuilder();
		// -- Linha 1 --//
		// Canal
		linhasTarifaAgua.append(" ");
		// Fonte
		linhasTarifaAgua.append("1");
		linhasTarifaAgua.append("AGUA");
		linhasTarifaAgua.append(Util.completaString("", 125));

		Collection colecaoContaCategoriaComFaixas = null;
		try {
			colecaoContaCategoriaComFaixas = repositorioFaturamento
					.pesquisarContaCategoria(emitirContaHelper.getIdConta());
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (colecaoContaCategoriaComFaixas != null
				&& !colecaoContaCategoriaComFaixas.isEmpty()) {
			Iterator iteratorContaCategoriaComFaixas = colecaoContaCategoriaComFaixas
					.iterator();
			while (iteratorContaCategoriaComFaixas.hasNext()) {
				ContaCategoria contaCategoria = (ContaCategoria) iteratorContaCategoriaComFaixas
						.next();
				linhasTarifaAgua.append(System.getProperty("line.separator"));

				// -- Linha 2 --//
				// Canal
				linhasTarifaAgua.append(" ");
				// Fonte
				linhasTarifaAgua.append("1");
				linhasTarifaAgua.append(" ");
				// descricao da categoria
				linhasTarifaAgua.append(Util.completaString(contaCategoria
						.getComp_id().getCategoria().getDescricao(), 13));
				// quantidade de economias
				linhasTarifaAgua.append(Util.adicionarZerosEsquedaNumero(3, ""
						+ contaCategoria.getQuantidadeEconomia()));
				// completa com espaços em branco
				linhasTarifaAgua.append(Util.completaString("", 2));
				if (contaCategoria.getQuantidadeEconomia() == 1) {
					linhasTarifaAgua.append("UNIDADE ");
				} else {
					linhasTarifaAgua.append("UNIDADES");
				}
				// completa com espaços em branco
				linhasTarifaAgua.append(Util.completaString("", 102));
				linhasTarifaAgua.append(System.getProperty("line.separator"));

				// -- Linha 3 --//
				// Canal
				linhasTarifaAgua.append(" ");
				// Fonte
				linhasTarifaAgua.append("1");
				// completa com espaços em branco
				linhasTarifaAgua.append(" ");
				// caso não existam dados de medição
				if (parmsMedicaoHistorico == null) {
					// Constante
					linhasTarifaAgua.append("TARIFA MÍNIMA");

					// Valor da tarifa mínima de água para a categoria por
					// economia
					BigDecimal qtdEconomia = Util
							.formatarMoedaRealparaBigDecimal(""
									+ contaCategoria.getQuantidadeEconomia());
					String valorTarifaMinima = "";
					if (contaCategoria.getValorTarifaMinimaAgua() != null
							&& qtdEconomia != null) {
						BigDecimal valorTarifaMinimaBigDecimal = contaCategoria
								.getValorTarifaMinimaAgua().divide(qtdEconomia,
										2, RoundingMode.UP);
						valorTarifaMinima = Util
								.formatarMoedaReal(valorTarifaMinimaBigDecimal);
					}

					linhasTarifaAgua.append(Util
							.completaStringComEspacoAEsquerda(
									valorTarifaMinima, 6));
					// completa com espaços em branco
					linhasTarifaAgua.append(" ");
					// Constante
					linhasTarifaAgua.append("POR UNIDADE");
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 18));
					// Constante
					linhasTarifaAgua.append("MINIMO");
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 11));
					// valor da água para categoria
					String valorAgua = Util.formatarMoedaReal(contaCategoria
							.getValorAgua());
					linhasTarifaAgua.append(Util
							.completaStringComEspacoAEsquerda(valorAgua, 17));
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 45));
				} else {
					// recupera a coleção de conta categoria consumo faixa
					Collection colecaoContaCategoriaConsumoFaixa = null;
					try {
						colecaoContaCategoriaConsumoFaixa = repositorioFaturamento
								.pesquisarContaCategoriaFaixas(
										emitirContaHelper.getIdConta(),
										contaCategoria.getComp_id()
												.getCategoria().getId());
					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}

					if (colecaoContaCategoriaConsumoFaixa != null
							&& !colecaoContaCategoriaConsumoFaixa.isEmpty()) {

						// Constante
						linhasTarifaAgua.append("ATE");
						// Constante
						linhasTarifaAgua.append(" ");
						// Consumo mínimo de água para a categoria por
						// economia

						BigDecimal qtdEconomia = Util
								.formatarMoedaRealparaBigDecimal(""
										+ contaCategoria
												.getQuantidadeEconomia());

						BigDecimal consumoMinimoAgua = null;
						if (contaCategoria.getConsumoMinimoAgua() != null) {
							consumoMinimoAgua = Util
									.formatarMoedaRealparaBigDecimal(""
											+ contaCategoria
													.getConsumoMinimoAgua());
						}

						BigDecimal consumoMinimaBigDecimal = new BigDecimal(
								"0.00");
						if (consumoMinimoAgua != null && qtdEconomia != null) {
							consumoMinimaBigDecimal = consumoMinimoAgua.divide(
									qtdEconomia, 2, RoundingMode.UP);
						}

						String consumoMinima = ""
								+ consumoMinimaBigDecimal.intValue();

						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(
										consumoMinima, 2));
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append("M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 7));
						// Constante
						linhasTarifaAgua.append("- R$");
						// valor da tarifa minima de agua para a categoria por
						// economia
						BigDecimal valorTarifaMinimaBigDecimal = null;
						if (contaCategoria.getValorTarifaMinimaAgua() != null
								&& qtdEconomia != null) {
							valorTarifaMinimaBigDecimal = contaCategoria
									.getValorTarifaMinimaAgua().divide(
											qtdEconomia, 2, RoundingMode.UP);
						}
						String valorTarifaMinima = Util
								.formatarMoedaReal(valorTarifaMinimaBigDecimal);
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(
										valorTarifaMinima, 6));
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append(" (POR UNIDADE)");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 8));
						// Consumo mínimo de água
						if (contaCategoria.getConsumoMinimoAgua() != null
								&& !contaCategoria.getConsumoMinimoAgua()
										.equals("")) {
							linhasTarifaAgua
									.append(Util.completaStringComEspacoAEsquerda(
											""
													+ contaCategoria
															.getConsumoMinimoAgua(),
											4));
						} else {
							linhasTarifaAgua.append(Util
									.completaStringComEspacoAEsquerda("", 4));
						}
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append("M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 10));
						// valor agua para categoria
						String valorAguaCategoria = "";
						if (contaCategoria.getValorTarifaMinimaAgua() != null) {
							valorAguaCategoria = Util
									.formatarMoedaReal(contaCategoria
											.getValorTarifaMinimaAgua());
						}
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(
										valorAguaCategoria, 17));
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 45));

						Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa
								.iterator();
						while (iteratorContaCategoriaConsumoFaixa.hasNext()) {
							ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) iteratorContaCategoriaConsumoFaixa
									.next();

							linhasTarifaAgua.append(System
									.getProperty("line.separator"));

							// -- Linha 4 --//
							// Canal
							linhasTarifaAgua.append(" ");
							// Fonte
							linhasTarifaAgua.append("1");
							// completa com espaços em branco
							linhasTarifaAgua.append(" ");
							// caso a faixa seja a ultima ta tarifa de consumo
							if (contaCategoriaConsumoFaixa.getConsumoFaixaFim()
									.equals(999999)) {
								// Constante
								linhasTarifaAgua.append("ACIMA DE");
								// Consumo inicial da faixa menos 1 m3
								String consumoInicialFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaInicio() - 1);
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												consumoInicialFaixa, 3));
								// Constante
								linhasTarifaAgua.append(" M3  - R$");
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorTarifaFaixa());
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												valorTarifaFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" POR M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										14));

								// consumo da agua
								linhasTarifaAgua
										.append(Util
												.completaStringComEspacoAEsquerda(
														""
																+ contaCategoriaConsumoFaixa
																		.getConsumoAgua()
																* qtdEconomia
																		.intValue(),
														6));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										10));
								// valor da agua na faixa
								String valorAguaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorAgua().multiply(
														qtdEconomia));
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												valorAguaFaixa, 17));
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										45));

							} else {
								// Consumo inicial da faixa
								String consumoInicialFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaInicio());
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												consumoInicialFaixa, 2));
								// Constante
								linhasTarifaAgua.append(" M3 A");
								// consumo final da faixa
								String consumoFinalFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaFim());
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												consumoFinalFaixa, 3));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										3));
								// Constante
								linhasTarifaAgua.append("- R$");
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorTarifaFaixa());
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												valorTarifaFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" POR M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										14));
								// consumo de Agua na faixa
								linhasTarifaAgua
										.append(Util
												.completaStringComEspacoAEsquerda(
														""
																+ contaCategoriaConsumoFaixa
																		.getConsumoAgua()
																* qtdEconomia
																		.intValue(),
														6));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										10));
								// valor da agua na faixa
								String valorAguaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorAgua().multiply(
														qtdEconomia));
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												valorAguaFaixa, 17));
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										45));

							}
						}
					} else {
						linhasTarifaAgua.append("CONSUMO DE ÁGUA");
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(""
										+ contaCategoria.getConsumoAgua(), 6)
								+ " M3");
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(Util
										.formatarMoedaReal(contaCategoria
												.getValorAgua()), 59));

						linhasTarifaAgua.append(Util.completaString("", 45));

					}

				}
			}
		}

		return linhasTarifaAgua;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00012] Gerar Linhas da Tarifa de Esgoto
	 * 
	 * @author Sávio Luiz
	 * @date 23/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasTarifaEsgoto(
			EmitirContaHelper emitirContaHelper) throws ControladorException {
		StringBuilder linhasTarifaEsgoto = new StringBuilder();
		// -- Linha 1 --//
		// Canal
		linhasTarifaEsgoto.append(" ");
		// Fonte
		linhasTarifaEsgoto.append("1");
		// Constante
		linhasTarifaEsgoto.append("ESGOTO ");
		// caso o consumo de agua seja igual ao volume coletado de esgoto e o
		// valor de agua seja diferente de 0
		if (emitirContaHelper.getConsumoAgua().equals(
				emitirContaHelper.getConsumoEsgoto())
				&& emitirContaHelper.getValorAgua() != null
				&& !emitirContaHelper.getValorAgua().equals("0.00")) {
			// Percentual esgoto
			String percentualEsgoto = Util.formatarMoedaReal(emitirContaHelper
					.getPercentualEsgotoConta());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(
					percentualEsgoto, 6));
			// Constante
			linhasTarifaEsgoto.append(" % DO VALOR DA ÁGUA");
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 35));
			// Percentual esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper
					.getValorEsgoto());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(
					valorEsgoto, 17));
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 45));

		} else {
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 42));
			// Volume coletado de esgoto
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(""
					+ emitirContaHelper.getConsumoEsgoto(), 6));
			// Constante
			linhasTarifaEsgoto.append(" M3");
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 9));
			// Percentual esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper
					.getValorEsgoto());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(
					valorEsgoto, 17));
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 45));
		}

		return linhasTarifaEsgoto;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00013] Gerar Linhas de Débitos Cobrados
	 * 
	 * @author Sávio Luiz
	 * @date 23/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasDebitoCobrados(
			EmitirContaHelper emitirContaHelper) throws ControladorException {
		StringBuilder linhasDebitosCobrados = new StringBuilder();

		// CRC4428 - Vivianne Sousa - 14/06/2010
		// Collection<Object[]> collectionParmsDebitoAutomatico = null;
		// try {
		Collection<Object[]> collectionParmsDebitoAutomatico = this
				.pesquisarParmsDebitoAutomatico(emitirContaHelper.getIdConta());
		// } catch (ErroRepositorioException e) {
		// sessionContext.setRollbackOnly();
		// throw new ControladorException("erro.sistema", e);
		// }

		if (collectionParmsDebitoAutomatico != null) {

			Iterator iter = collectionParmsDebitoAutomatico.iterator();

			while (iter.hasNext()) {
				Object[] parmsDebitoAutomatico = (Object[]) iter.next();

				// caso a consulta retorne algum resultado
				if (parmsDebitoAutomatico != null) {
					String valorDebitosCobrados = "";
					String numeroPrestacao = "";
					Short numeroTotalPrestacao = 0;
					Short numeroParcelaBonus = 0;
					String totalPrestacaoMenosBonus = "";
					// valor acumulado dos debitos cobrados
					if (parmsDebitoAutomatico[0] != null) {
						valorDebitosCobrados = Util
								.formatarMoedaReal((BigDecimal) parmsDebitoAutomatico[0]);
					}
					// numero de prestação do débito
					if (parmsDebitoAutomatico[1] != null) {
						numeroPrestacao = ""
								+ ((Short) parmsDebitoAutomatico[1]);
					}
					// valor acumulado dos debitos cobrados
					if (parmsDebitoAutomatico[2] != null) {
						numeroTotalPrestacao = (Short) parmsDebitoAutomatico[2];
					}
					/*
					 * Alterado por Vivianne Sousa em 11/02/2008 - Analista:
					 * Adriano criação do bonus para parcelamento com RD
					 * especial
					 */
					// numero parcela bonus
					if (parmsDebitoAutomatico[3] != null) {
						numeroParcelaBonus = (Short) parmsDebitoAutomatico[3];
					}
					totalPrestacaoMenosBonus = ""
							+ (numeroTotalPrestacao.intValue() - numeroParcelaBonus
									.intValue());

					if (!valorDebitosCobrados.equals("0,00")) {

						if (linhasDebitosCobrados != null
								&& linhasDebitosCobrados.length() != 0) {
							linhasDebitosCobrados.append(System
									.getProperty("line.separator"));
						}

						// -- Linha 1 --//
						// Canal
						linhasDebitosCobrados.append(" ");
						// Fonte
						linhasDebitosCobrados.append("1");
						// Constante
						linhasDebitosCobrados.append("PARCELAMENTO DE DÉBITOS");
						// Completa com espaços em branco
						linhasDebitosCobrados
								.append(Util.completaString("", 2));
						// Constante
						linhasDebitosCobrados.append("PARCELA ");
						// numero da prestação do débito
						linhasDebitosCobrados.append(Util
								.completaStringComEspacoAEsquerda(
										numeroPrestacao, 3));
						// Constante
						linhasDebitosCobrados.append("/");
						// numero total da prestação do débito
						linhasDebitosCobrados.append(Util.completaString(
								totalPrestacaoMenosBonus, 3));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util
								.completaString("", 27));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util
								.completaStringComEspacoAEsquerda(
										valorDebitosCobrados, 17));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util
								.completaString("", 45));
					}
				}

			}

		}

		// CRC4428 - Vivianne Sousa - 14/06/2010
		// List colecaoDebitoCobradoPorTipo = null;
		// try {
		List colecaoDebitoCobradoPorTipo = this
				.pesquisarParmsDebitoCobradoPorTipo(emitirContaHelper
						.getIdConta());

		// } catch (ErroRepositorioException e) {
		// sessionContext.setRollbackOnly();
		// throw new ControladorException("erro.sistema", e);
		// }
		if (colecaoDebitoCobradoPorTipo != null
				&& !colecaoDebitoCobradoPorTipo.isEmpty()) {
			ListIterator iteratorDebitoCobradoPorTipo = (ListIterator) colecaoDebitoCobradoPorTipo
					.listIterator();
			// variável responsável para controle de mudança do tipo de
			// débito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// débito,que entra para ser escrito
			// no txt só uma vez a descrição do tipo do debito
			boolean primeiraVez = true;
			boolean entrouPrimeiraVez = false;
			Integer idDebitoTipoVerificador = null;
			BigDecimal valorTotalPrestacoes = new BigDecimal("0.00");
			String totalPrestacaoMenosBonus = "";
			// valor da pretação
			BigDecimal valorPrestacao = null;
			// numero da pretação atual
			Integer numeroPrestacaoDebito = null;
			// numero total de prestações
			Integer numeroPrestacaoTotal = null;
			// colecao para guardar os ano/mes referencia do débito cobrado
			Collection colecaoAnoMesReferenciaDebito = new ArrayList();
			// cria um int que vai ver o tamanho da string builder
			// dependendo da quantidade
			// de mes/ano referencia calcula os espaços em brancos
			// para o valor ficar no lugar certo
			int tamanhoAnoMesReferencia = 0;
			while (iteratorDebitoCobradoPorTipo.hasNext()) {
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoCobradoPorTipo
						.next();

				// recupera os parametros da coleção
				// valor da pretação
				if (parmsDebitoCobradoPorTipo[0] != null) {
					valorPrestacao = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if (parmsDebitoCobradoPorTipo[1] != null) {
					numeroPrestacaoDebito = new Integer(""
							+ (Short) parmsDebitoCobradoPorTipo[1]);
				}
				// numero total de prestações
				if (parmsDebitoCobradoPorTipo[2] != null) {
					numeroPrestacaoTotal = new Integer(""
							+ (Short) parmsDebitoCobradoPorTipo[2]);
				}
				// ano Mes Referência do débito
				Integer anoMesReferencia = null;
				if (parmsDebitoCobradoPorTipo[3] != null) {
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idDebitoTipo = null;
				if (parmsDebitoCobradoPorTipo[4] != null) {
					idDebitoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do débito
				String descricaoDebitoTipo = null;
				if (parmsDebitoCobradoPorTipo[5] != null) {
					descricaoDebitoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}

				/*
				 * Alterado por Vivianne Sousa em 21/12/2007 - Analista: Adriano
				 * criação do bonus para parcelamento com RD especial
				 */
				Short numeroParcelaBonus = 0;
				// numero parcela bonus
				if (parmsDebitoCobradoPorTipo[6] != null) {
					numeroParcelaBonus = (Short) parmsDebitoCobradoPorTipo[6];
				}
				totalPrestacaoMenosBonus = ""
						+ (numeroPrestacaoTotal.intValue() - numeroParcelaBonus
								.intValue());

				// muda o estado do boolean e o valor do débito tipo
				// verificador
				// na primeira vez ou quando mudar o tipo
				if (mudou) {
					idDebitoTipoVerificador = idDebitoTipo;
					mudou = false;
					tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if (idDebitoTipo.equals(idDebitoTipoVerificador)) {
					if (primeiraVez) {
						if (linhasDebitosCobrados != null
								&& linhasDebitosCobrados.length() != 0) {
							linhasDebitosCobrados.append(System
									.getProperty("line.separator"));
						}
						// -- Linha 2 --//
						// Canal
						linhasDebitosCobrados.append(" ");
						// Fonte
						linhasDebitosCobrados.append("1");
						// descrição do tipo de débito
						linhasDebitosCobrados.append(Util.completaString(
								descricaoDebitoTipo, 30));
						primeiraVez = false;
						entrouPrimeiraVez = true;
					} else {
						entrouPrimeiraVez = false;
					}
					// adiciona o valor da prestação ao total
					valorTotalPrestacoes = valorTotalPrestacoes
							.add(valorPrestacao);
					// adiciona o ano/mes referencia na coleção
					if (anoMesReferencia != null) {
						colecaoAnoMesReferenciaDebito.add(anoMesReferencia);
					} else {
						if (!entrouPrimeiraVez) {
							if (linhasDebitosCobrados != null
									&& linhasDebitosCobrados.length() != 0) {
								linhasDebitosCobrados.append(System
										.getProperty("line.separator"));
							}

							// -- Linha 2 --//
							// Canal
							linhasDebitosCobrados.append(" ");
							// Fonte
							linhasDebitosCobrados.append("1");
							// descrição do tipo de débito
							linhasDebitosCobrados.append(Util.completaString(
									descricaoDebitoTipo, 30));
						}
						// Constante
						linhasDebitosCobrados.append("PARCELA ");
						// numero da prestação do débito
						linhasDebitosCobrados.append(Util
								.completaStringComEspacoAEsquerda(""
										+ numeroPrestacaoDebito, 3));
						// Constante
						linhasDebitosCobrados.append("/");
						// numero total da prestação do débito
						linhasDebitosCobrados.append(Util.completaString(
								totalPrestacaoMenosBonus, 3));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util
								.completaString("", 22));
						// Valor da pretação
						String valorPrestacaoString = Util
								.formatarMoedaReal(valorPrestacao);
						linhasDebitosCobrados.append(Util
								.completaStringComEspacoAEsquerda(
										valorPrestacaoString, 17));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util
								.completaString("", 45));
					}

				} else {
					// caso a coleção dos meses de referência do grupo do
					// tipo de débito esteja preenchida
					if (colecaoAnoMesReferenciaDebito != null
							&& !colecaoAnoMesReferenciaDebito.isEmpty()) {
						Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito
								.iterator();
						int i = 1;
						while (iteratorAnoMesReferenciaDebito.hasNext()) {
							Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito
									.next();
							String anoMesReferenciaDebitoString = null;
							if (i == 1) {
								// mes/ano referencia do débito
								anoMesReferenciaDebitoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								linhasDebitosCobrados
										.append(Util
												.completaString(
														anoMesReferenciaDebitoString,
														7));
								// caso exita somente um mes/ano de
								// referencia na lista
								if (colecaoAnoMesReferenciaDebito.size() == 1) {
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("", 30));
									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 17));
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("", 45));

								} else {

									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("", 92));
								}
							} else {
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if (i == 2) {
									linhasDebitosCobrados.append(System
											.getProperty("line.separator"));
									// -- Linha 3 --//
									// Canal
									linhasDebitosCobrados.append(" ");
									// Fonte
									linhasDebitosCobrados.append("1");
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
									// mes/ano referencia do debito
									anoMesReferenciaDebitoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									linhasDebitosCobrados
											.append(Util
													.completaString(
															anoMesReferenciaDebitoString,
															7));
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
									// adiciona o tamanho do mes/ano
									// referencia
									tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
									// caso exita somente um mes/ano de
									// referencia na lista
									if (colecaoAnoMesReferenciaDebito.size() == 2) {
										// o tamanho de espaços em
										// branco vai ser o tamanho sem
										// os mes/ano - os meses/anos
										// colocados na
										// stringbuilder.ex.:76-15=61
										// espaços em brancos
										int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
										// completa espaços em brancos
										linhasDebitosCobrados.append(Util
												.completaString("",
														tamanhoEspacosBrancos));
										// valor acumulado do tipo do débito
										String valorAcumulado = Util
												.formatarMoedaReal(valorTotalPrestacoes);
										linhasDebitosCobrados
												.append(Util
														.completaStringComEspacoAEsquerda(
																valorAcumulado,
																17));
										// completa espaços em brancos
										linhasDebitosCobrados.append(Util
												.completaString("", 45));
									} /*
									 * else { // completa espaços em brancos
									 * linhasDebitosCobrados.append(" "); }
									 */

								} else {
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o
									// ultimo anoMes
									if ((colecaoAnoMesReferenciaDebito.size() - 1) <= 6) {

										// mes/ano referencia do debito
										anoMesReferenciaDebitoString = Util
												.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
										linhasDebitosCobrados
												.append(Util
														.completaString(
																anoMesReferenciaDebitoString,
																7));
										// completa espaços em brancos
										linhasDebitosCobrados.append(" ");
										// adiciona o tamanho do mes/ano
										// referencia + o espaço em branco
										tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

										// caso não tenha outro ano mes na
										// coleção então
										// completa a linha com o valor
										if (!iteratorAnoMesReferenciaDebito
												.hasNext()) {
											// o tamanho de espaços em
											// branco vai ser o tamanho sem
											// os mes/ano - os meses/anos
											// colocados na
											// stringbuilder.ex.:76-15=61
											// espaços em brancos
											int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
											// completa espaços em brancos
											linhasDebitosCobrados
													.append(Util
															.completaString("",
																	tamanhoEspacosBrancos));
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalPrestacoes);
											linhasDebitosCobrados
													.append(Util
															.completaStringComEspacoAEsquerda(
																	valorAcumulado,
																	17));
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util
													.completaString("", 45));
										}

									} else {
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if (i < 7) {
											// mes/ano referencia do débito
											anoMesReferenciaDebitoString = Util
													.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
											linhasDebitosCobrados
													.append(Util
															.completaString(
																	anoMesReferenciaDebitoString,
																	7));
											// completa espaços em brancos
											linhasDebitosCobrados.append(" ");
										} else {
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util
													.completaString("E OUTRAS",
															18));
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalPrestacoes);
											linhasDebitosCobrados
													.append(Util
															.completaStringComEspacoAEsquerda(
																	valorAcumulado,
																	25));
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util
													.completaString("", 45));
											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					} /*
					 * else { // -- Linha 2 (CONTINUAÇÂO)--// // Constante
					 * linhasDebitosCobrados.append("PARCELA "); // numero da
					 * prestação do débito
					 * linhasDebitosCobrados.append(Util.completaString("" +
					 * numeroPrestacaoDebito, 2)); // Constante
					 * linhasDebitosCobrados.append("/"); // numero total da
					 * prestação do débito
					 * linhasDebitosCobrados.append(Util.completaString("" +
					 * numeroPrestacaoTotal, 2)); // Completa com espaços em
					 * branco linhasDebitosCobrados.append(Util
					 * .completaString("", 24)); // Valor da pretação //
					 * Vivianne Sousa // String valorPrestacaoString = Util //
					 * .formatarMoedaReal(valorPrestacao); String
					 * valorPrestacaoString = Util
					 * .formatarMoedaReal(valorTotalPrestacoes);
					 * 
					 * linhasDebitosCobrados.append(Util
					 * .completaStringComEspacoAEsquerda( valorPrestacaoString,
					 * 17)); // Completa com espaços em branco
					 * linhasDebitosCobrados.append(Util .completaString("",
					 * 45)); }
					 */// limpa os campos
					valorTotalPrestacoes = new BigDecimal("0.00");
					colecaoAnoMesReferenciaDebito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoCobradoPorTipo.previous();
				}
			}

			// no caso de ser o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de débito esteja preenchida
			if (colecaoAnoMesReferenciaDebito != null
					&& !colecaoAnoMesReferenciaDebito.isEmpty()) {
				Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito
						.iterator();
				int i = 1;
				while (iteratorAnoMesReferenciaDebito.hasNext()) {
					Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito
							.next();
					String anoMesReferenciaDebitoString = null;
					if (i == 1) {
						// mes/ano referencia do débito
						anoMesReferenciaDebitoString = Util
								.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
						linhasDebitosCobrados.append(Util.completaString(
								anoMesReferenciaDebitoString, 7));
						// caso exita somente um mes/ano de
						// referencia na lista
						if (colecaoAnoMesReferenciaDebito.size() == 1) {
							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString(
									"", 30));
							// valor acumulado do tipo do débito
							String valorAcumulado = Util
									.formatarMoedaReal(valorTotalPrestacoes);
							linhasDebitosCobrados.append(Util
									.completaStringComEspacoAEsquerda(
											valorAcumulado, 17));
							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString(
									"", 45));

						} else {
							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString(
									"", 92));
						}
					} else {
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if (i == 2) {
							// -- Linha 3 --//
							linhasDebitosCobrados.append(System
									.getProperty("line.separator"));
							// Canal
							linhasDebitosCobrados.append(" ");
							// Fonte
							linhasDebitosCobrados.append("1");
							// completa espaços em brancos
							linhasDebitosCobrados.append(" ");
							// mes/ano referencia do debito
							anoMesReferenciaDebitoString = Util
									.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
							linhasDebitosCobrados.append(Util.completaString(
									anoMesReferenciaDebitoString, 7));

							// completa espaços em brancos
							linhasDebitosCobrados.append(" ");

							// adiciona o tamanho do mes/ano
							// referencia
							tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
							// caso exita somente um mes/ano de
							// referencia na lista
							if (colecaoAnoMesReferenciaDebito.size() == 2) {
								// o tamanho de espaços em
								// branco vai ser o tamanho sem
								// os mes/ano - os meses/anos
								// colocados na
								// stringbuilder.ex.:76-15=61
								// espaços em brancos
								int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
								// completa espaços em brancos
								linhasDebitosCobrados.append(Util
										.completaString("",
												tamanhoEspacosBrancos));
								// valor acumulado do tipo do débito
								String valorAcumulado = Util
										.formatarMoedaReal(valorTotalPrestacoes);
								linhasDebitosCobrados.append(Util
										.completaStringComEspacoAEsquerda(
												valorAcumulado, 17));
								// completa espaços em brancos
								linhasDebitosCobrados.append(Util
										.completaString("", 45));

							}
						} else {
							// caso exista até mais 6 ocorrências na
							// lista de meses
							// -1 pq já foi colocado na string o
							// ultimo anoMes
							if ((colecaoAnoMesReferenciaDebito.size() - 1) <= 6) {

								// mes/ano referencia do credito
								anoMesReferenciaDebitoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								linhasDebitosCobrados
										.append(Util
												.completaString(
														anoMesReferenciaDebitoString,
														7));
								// completa espaços em brancos
								linhasDebitosCobrados.append(" ");
								// adiciona o tamanho do mes/ano
								// referencia + o espaço em branco
								tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
								// caso não tenha outro ano mes na
								// coleção então
								// completa a linha com o valor
								if (!iteratorAnoMesReferenciaDebito.hasNext()) {
									// o tamanho de espaços em
									// branco vai ser o tamanho sem
									// os mes/ano - os meses/anos
									// colocados na
									// stringbuilder.ex.:76-15=61
									// espaços em brancos
									int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("",
													tamanhoEspacosBrancos));
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 17));
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("", 45));
								}

							} else {
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if (i < 7) {
									// mes/ano referencia do débito
									anoMesReferenciaDebitoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									linhasDebitosCobrados
											.append(Util
													.completaString(
															anoMesReferenciaDebitoString,
															7));
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
								} else {
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("E OUTRAS", 18));
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 25));
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("", 45));

									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}

		}

		return linhasDebitosCobrados;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00014] Gerar Linhas de Créditos Realizados
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasCreditosRealizados(
			EmitirContaHelper emitirContaHelper) throws ControladorException {
		StringBuilder linhasCreditosRealizados = new StringBuilder();
		List colecaoCreditoRealizadoPorTipo = null;
		try {
			colecaoCreditoRealizadoPorTipo = repositorioFaturamento
					.pesquisarParmsCreditoRealizadoPorTipo(emitirContaHelper
							.getIdConta());
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		if (colecaoCreditoRealizadoPorTipo != null
				&& !colecaoCreditoRealizadoPorTipo.isEmpty()) {
			ListIterator iteratorDebitoRealizadoPorTipo = (ListIterator) colecaoCreditoRealizadoPorTipo
					.listIterator();
			// variável responsável para controle de mudança do tipo de
			// credito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// credito,que entra para ser escrito
			// no txt só uma vez a descrição do tipo do credito
			boolean primeiraVez = true;
			boolean entrouPrimeiraVez = false;
			Integer idCreditoTipoVerificador = null;
			BigDecimal valorTotalCredito = new BigDecimal("0.00");
			BigDecimal valorCredito = null;
			Short numeroCredito = null;
			// numero total de créditos
			Short numeroCreditoTotal = null;
			String numeroCreditoTotalMenosBonus = "";
			// cria um int que vai ver o tamanho da string builder
			// dependendo da quantidade
			// de mes/ano referencia calcula os espaços em brancos
			// para o valor ficar no lugar certo
			int tamanhoAnoMesReferencia = 0;
			// caso não seja a primeira vez que entre no boolean primeira
			// vez(que nesse caso é quando troca o tipo de credito)
			boolean primeiraVezIndependenteTipo = false;
			// colecao para guardar os ano/mes referencia do credito realizado
			Collection colecaoAnoMesReferenciaCredito = new ArrayList();
			while (iteratorDebitoRealizadoPorTipo.hasNext()) {
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoRealizadoPorTipo
						.next();

				// recupera os parametros da coleção
				// valor do crédito
				if (parmsDebitoCobradoPorTipo[0] != null) {
					valorCredito = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if (parmsDebitoCobradoPorTipo[1] != null) {
					numeroCredito = (Short) parmsDebitoCobradoPorTipo[1];
				}

				if (parmsDebitoCobradoPorTipo[2] != null) {
					numeroCreditoTotal = (Short) parmsDebitoCobradoPorTipo[2];
				}
				// ano Mes Referência do crédito
				Integer anoMesReferencia = null;
				if (parmsDebitoCobradoPorTipo[3] != null) {
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idCreditoTipo = null;
				if (parmsDebitoCobradoPorTipo[4] != null) {
					idCreditoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do credito
				String descricaoCreditoTipo = null;
				if (parmsDebitoCobradoPorTipo[5] != null) {
					descricaoCreditoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}
				/*
				 * Alterado por Vivianne Sousa em 21/12/2007 - Analista: Adriano
				 * criação do bonus para parcelamento com RD especial
				 */
				Short numeroParcelaBonus = 0;
				// numero parcela bonus
				if (parmsDebitoCobradoPorTipo[6] != null) {
					numeroParcelaBonus = (Short) parmsDebitoCobradoPorTipo[6];
				}
				numeroCreditoTotalMenosBonus = ""
						+ (numeroCreditoTotal.intValue() - numeroParcelaBonus
								.intValue());

				// muda o estado do boolean e o valor do credito tipo
				// verificador
				// na primeira vez ou quando mudar o tipo
				if (mudou) {
					idCreditoTipoVerificador = idCreditoTipo;
					mudou = false;
					tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if (idCreditoTipo.equals(idCreditoTipoVerificador)) {
					if (primeiraVez) {
						// proxima linha
						if (primeiraVezIndependenteTipo) {
							linhasCreditosRealizados.append(System
									.getProperty("line.separator"));
						}
						// -- Linha 1 --//
						// Canal
						linhasCreditosRealizados.append(" ");
						// Fonte
						linhasCreditosRealizados.append("1");
						// descrição do tipo de credito
						linhasCreditosRealizados.append(Util.completaString(
								descricaoCreditoTipo, 30));
						primeiraVez = false;
						entrouPrimeiraVez = true;
						primeiraVezIndependenteTipo = true;
					} else {
						entrouPrimeiraVez = false;
					}

					// adiciona o valor do credito ao total
					valorTotalCredito = valorTotalCredito.add(valorCredito);
					// adiciona o ano/mes referencia na coleção
					if (anoMesReferencia != null) {
						colecaoAnoMesReferenciaCredito.add(anoMesReferencia);
					} else {
						if (!entrouPrimeiraVez) {
							// proxima linha
							if (primeiraVezIndependenteTipo) {
								linhasCreditosRealizados.append(System
										.getProperty("line.separator"));
							}
							// -- Linha 1 --//
							// Canal
							linhasCreditosRealizados.append(" ");
							// Fonte
							linhasCreditosRealizados.append("1");
							// descrição do tipo de credito
							linhasCreditosRealizados.append(Util
									.completaString(descricaoCreditoTipo, 30));
							primeiraVez = false;
						}
						// Constante
						linhasCreditosRealizados.append("PARCELA ");
						// numero da prestação do débito
						linhasCreditosRealizados.append(Util
								.completaStringComEspacoAEsquerda(""
										+ numeroCredito, 3));
						// Constante
						linhasCreditosRealizados.append("/");
						// numero total da prestação do débito
						linhasCreditosRealizados.append(Util.completaString(
								numeroCreditoTotalMenosBonus, 3));
						// Completa com espaços em branco
						linhasCreditosRealizados.append(Util.completaString("",
								22));
						// Valor da pretação
						String valorCreditoString = Util
								.formatarMoedaReal(valorCredito);
						linhasCreditosRealizados.append(Util
								.completaStringComEspacoAEsquerda(
										valorCreditoString, 17));
						// Completa com espaços em branco
						linhasCreditosRealizados.append(Util.completaString("",
								45));

					}

				} else {
					// caso a coleção dos meses de referência do grupo do
					// tipo de credito esteja preenchida
					if (colecaoAnoMesReferenciaCredito != null
							&& !colecaoAnoMesReferenciaCredito.isEmpty()) {
						Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito
								.iterator();
						int i = 1;
						while (iteratorAnoMesReferenciaCredito.hasNext()) {
							Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito
									.next();
							String anoMesReferenciaCreditoString = null;
							if (i == 1) {
								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								linhasCreditosRealizados.append(Util
										.completaString(
												anoMesReferenciaCreditoString,
												7));
								// caso exita somente um mes/ano de
								// referencia na lista
								if (colecaoAnoMesReferenciaCredito.size() == 1) {
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("", 30));
									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 17));
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("", 45));

								} else {
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("", 92));
								}
							} else {
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if (i == 2) {
									// -- Linha 3 --//
									linhasCreditosRealizados.append(System
											.getProperty("line.separator"));
									// Canal
									linhasCreditosRealizados.append(" ");
									// Fonte
									linhasCreditosRealizados.append("1");
									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");
									// mes/ano referencia do credito
									anoMesReferenciaCreditoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaCredito);

									linhasCreditosRealizados
											.append(Util
													.completaString(
															anoMesReferenciaCreditoString,
															7));

									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");

									// adiciona o tamanho do mes/ano
									// referencia
									tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
									// caso exita somente um mes/ano de
									// referencia na lista
									if (colecaoAnoMesReferenciaCredito.size() == 2) {
										// o tamanho de espaços em
										// branco vai ser o tamanho sem
										// os mes/ano - os meses/anos
										// colocados na
										// stringbuilder.ex.:76-15=61
										// espaços em brancos
										int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
										// completa espaços em brancos
										linhasCreditosRealizados.append(Util
												.completaString("",
														tamanhoEspacosBrancos));
										// valor acumulado do tipo do débito
										String valorAcumulado = Util
												.formatarMoedaReal(valorTotalCredito);
										linhasCreditosRealizados
												.append(Util
														.completaStringComEspacoAEsquerda(
																valorAcumulado,
																17));
										// completa espaços em brancos
										linhasCreditosRealizados.append(Util
												.completaString("", 45));

									} /*
									 * else { // completa espaços em brancos
									 * linhasCreditosRealizados.append(" "); }
									 */
								} else {
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o
									// ultimo anoMes
									if ((colecaoAnoMesReferenciaCredito.size() - 1) <= 6) {

										// mes/ano referencia do credito
										anoMesReferenciaCreditoString = Util
												.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
										linhasCreditosRealizados
												.append(Util
														.completaString(
																anoMesReferenciaCreditoString,
																7));
										// completa espaços em brancos
										linhasCreditosRealizados.append(" ");
										// adiciona o tamanho do mes/ano
										// referencia + o espaço em branco
										tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
										// caso não tenha outro ano mes na
										// coleção então
										// completa a linha com o valor
										if (!iteratorAnoMesReferenciaCredito
												.hasNext()) {
											// o tamanho de espaços em
											// branco vai ser o tamanho sem
											// os mes/ano - os meses/anos
											// colocados na
											// stringbuilder.ex.:76-15=61
											// espaços em brancos
											int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
											// completa espaços em brancos
											linhasCreditosRealizados
													.append(Util
															.completaString("",
																	tamanhoEspacosBrancos));
											// valor acumulado do tipo do débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalCredito);
											linhasCreditosRealizados
													.append(Util
															.completaStringComEspacoAEsquerda(
																	valorAcumulado,
																	17));
											// completa espaços em brancos
											linhasCreditosRealizados
													.append(Util
															.completaString("",
																	45));
										}

									} else {
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if (i < 7) {
											// mes/ano referencia do débito
											anoMesReferenciaCreditoString = Util
													.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
											linhasCreditosRealizados
													.append(Util
															.completaString(
																	anoMesReferenciaCreditoString,
																	7));
											// completa espaços em brancos
											linhasCreditosRealizados
													.append(" ");
										} else {
											// completa espaços em brancos
											linhasCreditosRealizados
													.append(Util
															.completaString(
																	"E OUTRAS",
																	18));
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalCredito);
											linhasCreditosRealizados
													.append(Util
															.completaStringComEspacoAEsquerda(
																	valorAcumulado,
																	25));
											// completa espaços em brancos
											linhasCreditosRealizados
													.append(Util
															.completaString("",
																	45));
											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					}
					// limpa os campos
					valorTotalCredito = new BigDecimal("0.00");
					colecaoAnoMesReferenciaCredito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoRealizadoPorTipo.previous();
				}
			}
			// No caso de ter o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de credito esteja preenchida
			if (colecaoAnoMesReferenciaCredito != null
					&& !colecaoAnoMesReferenciaCredito.isEmpty()) {
				Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito
						.iterator();
				int i = 1;
				while (iteratorAnoMesReferenciaCredito.hasNext()) {
					Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito
							.next();
					String anoMesReferenciaCreditoString = null;
					if (i == 1) {
						// mes/ano referencia do credito
						anoMesReferenciaCreditoString = Util
								.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
						linhasCreditosRealizados.append(Util.completaString(
								anoMesReferenciaCreditoString, 7));
						// caso exita somente um mes/ano de
						// referencia na lista
						if (colecaoAnoMesReferenciaCredito.size() == 1) {
							// completa espaços em brancos
							linhasCreditosRealizados.append(Util
									.completaString("", 30));
							// valor acumulado do tipo do débito
							String valorAcumulado = Util
									.formatarMoedaReal(valorTotalCredito);
							linhasCreditosRealizados.append(Util
									.completaStringComEspacoAEsquerda(
											valorAcumulado, 17));
							// completa espaços em brancos
							linhasCreditosRealizados.append(Util
									.completaString("", 45));

						} else {
							// completa espaços em brancos
							linhasCreditosRealizados.append(Util
									.completaString("", 92));
						}
					} else {
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if (i == 2) {
							// -- Linha 3 --//
							linhasCreditosRealizados.append(System
									.getProperty("line.separator"));
							// Canal
							linhasCreditosRealizados.append(" ");
							// Fonte
							linhasCreditosRealizados.append("1");
							// completa espaços em brancos
							linhasCreditosRealizados.append(" ");
							// mes/ano referencia do credito
							anoMesReferenciaCreditoString = Util
									.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
							linhasCreditosRealizados.append(Util
									.completaString(
											anoMesReferenciaCreditoString, 7));

							// completa espaços em brancos
							linhasCreditosRealizados.append(" ");
							// adiciona o tamanho do mes/ano
							// referencia
							tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
							// caso exita somente um mes/ano de
							// referencia na lista
							if (colecaoAnoMesReferenciaCredito.size() == 2) {
								// o tamanho de espaços em
								// branco vai ser o tamanho sem
								// os mes/ano - os meses/anos
								// colocados na
								// stringbuilder.ex.:76-15=61
								// espaços em brancos
								int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
								// completa espaços em brancos
								linhasCreditosRealizados.append(Util
										.completaString("",
												tamanhoEspacosBrancos));
								// valor acumulado do tipo do débito
								String valorAcumulado = Util
										.formatarMoedaReal(valorTotalCredito);
								linhasCreditosRealizados.append(Util
										.completaStringComEspacoAEsquerda(
												valorAcumulado, 17));
								// completa espaços em brancos
								linhasCreditosRealizados.append(Util
										.completaString("", 45));

							}/*
							 * else { // completa espaços em brancos
							 * linhasCreditosRealizados.append(" "); }
							 */
						} else {
							// caso exista até mais 6 ocorrências na
							// lista de meses
							// -1 pq já foi colocado na string o
							// ultimo anoMes
							if ((colecaoAnoMesReferenciaCredito.size() - 1) <= 6) {

								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								linhasCreditosRealizados.append(Util
										.completaString(
												anoMesReferenciaCreditoString,
												7));
								// completa espaços em brancos
								linhasCreditosRealizados.append(" ");
								// adiciona o tamanho do mes/ano
								// referencia + o espaço em branco
								tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
								// caso não tenha outro ano mes na
								// coleção então
								// completa a linha com o valor
								if (!iteratorAnoMesReferenciaCredito.hasNext()) {
									// o tamanho de espaços em
									// branco vai ser o tamanho sem
									// os mes/ano - os meses/anos
									// colocados na
									// stringbuilder.ex.:76-15=61
									// espaços em brancos
									int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("",
													tamanhoEspacosBrancos));
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 17));
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("", 45));
								}

							} else {
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if (i < 7) {
									// mes/ano referencia do débito
									anoMesReferenciaCreditoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									linhasCreditosRealizados
											.append(Util
													.completaString(
															anoMesReferenciaCreditoString,
															7));
									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");
								} else {
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString(" E OUTRAS", 18));
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 25));
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("", 45));
									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}

		}

		return linhasCreditosRealizados;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0015] Gerar Linhas de Impostos Retidos
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasImpostosRetidos(
			EmitirContaHelper emitirContaHelper) throws ControladorException {

		StringBuilder linhasImpostosRetidos = new StringBuilder();
		// -- Linha 1 --//
		// Canal
		linhasImpostosRetidos.append(" ");
		// Fonte
		linhasImpostosRetidos.append("1");
		// Constante
		linhasImpostosRetidos
				.append("DEDUCAO IMPOSTOS LEI FEDERAL N.9430 DE 27/12/1996");
		// Completa com espaços em branco
		linhasImpostosRetidos.append(Util.completaString("", 80));
		linhasImpostosRetidos.append(System.getProperty("line.separator"));

		// -- Linha 2 --//
		// Canal
		linhasImpostosRetidos.append(" ");
		// Fonte
		linhasImpostosRetidos.append("1");
		// Completa com espaços em branco
		linhasImpostosRetidos.append(Util.completaString("", 2));

		Collection colecaoParmsImpostosDeduzidos = null;
		try {
			colecaoParmsImpostosDeduzidos = repositorioFaturamento
					.pesquisarParmsContaImpostosDeduzidos(emitirContaHelper
							.getIdConta());
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		StringBuilder descricaoAbreviadaImposto = new StringBuilder();
		BigDecimal valorImpostosTotal = new BigDecimal("0.00");
		// verifica se a coleção é diferente de nulo
		if (colecaoParmsImpostosDeduzidos != null
				&& !colecaoParmsImpostosDeduzidos.isEmpty()) {
			Iterator iteratorParmsImpostosDeduzidos = colecaoParmsImpostosDeduzidos
					.iterator();
			while (iteratorParmsImpostosDeduzidos.hasNext()) {
				Object[] parmsImpostoDeduzido = (Object[]) iteratorParmsImpostosDeduzidos
						.next();
				String descricaoTipoImposto = "";
				if (parmsImpostoDeduzido[0] != null) {
					descricaoTipoImposto = (String) parmsImpostoDeduzido[0];
				}
				String percentualAliquota = "";
				if (parmsImpostoDeduzido[1] != null) {
					percentualAliquota = Util
							.formatarMoedaReal((BigDecimal) parmsImpostoDeduzido[1]);
				}
				BigDecimal valorImpostos = null;
				if (parmsImpostoDeduzido[2] != null) {
					valorImpostos = (BigDecimal) parmsImpostoDeduzido[2];
				}
				// concatena a descrição abreviada do tipo de imposto com o
				// precentual de aliquota
				descricaoAbreviadaImposto.append(descricaoTipoImposto + "-"
						+ percentualAliquota + "%");
				// Completa com espaços em branco
				descricaoAbreviadaImposto.append(" ");
				// adiciona o valor dos impostos
				valorImpostosTotal = valorImpostosTotal.add(valorImpostos);
			}
		}
		// recupera a descrição abreviada concatenada com a aliquota
		String descricaoAbreviadaConcatenada = "";
		if (descricaoAbreviadaImposto != null
				&& !descricaoAbreviadaImposto.equals("")) {
			descricaoAbreviadaConcatenada = descricaoAbreviadaImposto
					.toString();
		}
		linhasImpostosRetidos.append(Util.completaString(
				descricaoAbreviadaConcatenada, 65));
		String valorImpostosTotalString = Util
				.formatarMoedaReal(valorImpostosTotal);
		linhasImpostosRetidos.append(Util.completaStringComEspacoAEsquerda(
				valorImpostosTotalString, 17));
		// Completa com espaços em branco
		linhasImpostosRetidos.append(Util.completaString("", 45));

		return linhasImpostosRetidos;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00016] Obter Mensagem da Conta em 3 Partes
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public String[] obterMensagemConta3Partes(
			EmitirContaHelper emitirContaHelper,
			SistemaParametro sistemaParametro) throws ControladorException {

		String[] linhasImpostosRetidos = new String[3];

		// mensagem da conta para a anormalidade de consumo (Baixo Consumo,Auto
		// Consumo e Estouro de Consumo)

		linhasImpostosRetidos = obterMensagemAnormalidadeConsumo(emitirContaHelper);

		if (linhasImpostosRetidos == null || linhasImpostosRetidos.equals("")) {

			linhasImpostosRetidos = new String[3];

			Integer anoMesReferenciaFinal = sistemaParametro
					.getAnoMesFaturamento();
			int anoMesSubtraido = Util.subtrairMesDoAnoMes(
					anoMesReferenciaFinal, 1);
			Integer dataVencimentoFinalInteger = sistemaParametro
					.getAnoMesArrecadacao();
			String anoMesSubtraidoString = ""
					+ Util.subtrairMesDoAnoMes(dataVencimentoFinalInteger, 1);
			int ano = Integer.parseInt(anoMesSubtraidoString.substring(0, 4));
			int mes = Integer.parseInt(anoMesSubtraidoString.substring(4, 6));

			// recupera o ultimo dia do anomes e passa a data como parametro
			Calendar dataVencimentoFinal = GregorianCalendar.getInstance();
			dataVencimentoFinal.set(Calendar.YEAR, ano);
			dataVencimentoFinal.set(Calendar.MONTH, (mes - 1));
			dataVencimentoFinal
					.set(Calendar.DAY_OF_MONTH, dataVencimentoFinal
							.getActualMaximum(Calendar.DAY_OF_MONTH));

			Date dataFinalDate = dataVencimentoFinal.getTime();

			// converte String em data
			Date dataVencimento = Util.converteStringParaDate("01/01/1900");

			ObterDebitoImovelOuClienteHelper debitoImovelClienteHelper = getControladorCobranca()
					.obterDebitoImovelOuCliente(1,
							"" + emitirContaHelper.getIdImovel(), null, null,
							"190001", "" + anoMesSubtraido, dataVencimento,
							dataFinalDate, 1, 2, 2, 2, 2, 1, 2, null);
			// se o imovel possua débito(debitoImovelCobrança for diferente de
			// nulo)
			if (debitoImovelClienteHelper != null
					&& ((debitoImovelClienteHelper
							.getColecaoGuiasPagamentoValores() != null && !debitoImovelClienteHelper
							.getColecaoGuiasPagamentoValores().isEmpty()) || (debitoImovelClienteHelper
							.getColecaoContasValores() != null && !debitoImovelClienteHelper
							.getColecaoContasValores().isEmpty()))) {
				String dataVencimentoFinalString = Util
						.formatarData(dataFinalDate);
				linhasImpostosRetidos[0] = "SR. USUÁRIO: EM  "
						+ dataVencimentoFinalString
						+ ",    REGISTRAMOS QUE V.SA. ESTAVA EM DÉBITO COM A "
						+ sistemaParametro.getNomeAbreviadoEmpresa() + ".";
				linhasImpostosRetidos[1] = "COMPAREÇA A UM DOS NOSSOS POSTOS DE ATENDIMENTO PARA REGULARIZAR SUA SITUACAO.EVITE O CORTE.";
				linhasImpostosRetidos[2] = "CASO O SEU DÉBITO TENHA SIDO PAGO APÓS A DATA INDICADA,DESCONSIDERE ESTE AVISO.";

			} else {
				Object[] mensagensConta = null;
				// recupera o id do grupo de faturamento da conta
				Integer idFaturamentoGrupo = emitirContaHelper
						.getIdFaturamentoGrupo();
				// recupera o id da gerencia regional da conta
				Integer idGerenciaRegional = emitirContaHelper
						.getIdGerenciaRegional();
				// recupera o id da localidade da conta
				Integer idLocalidade = emitirContaHelper.getIdLocalidade();
				// recupera o id do setor comercial da conta
				Integer idSetorComercial = emitirContaHelper
						.getIdSetorComercial();
				// caso entre em alguma condição então não entra mais nas outras
				boolean achou = false;

				try {

					// o sistema obtem a mensagem para a conta
					// Caso seja a condição 1
					// (FaturamentoGrupo =null, GerenciaRegional=parmConta,
					// Localidade=parmConta, SetorComercial=parmConta)
					mensagensConta = repositorioFaturamento
							.pesquisarParmsContaMensagem(emitirContaHelper,
									null, idGerenciaRegional, idLocalidade,
									idSetorComercial);
					if (mensagensConta != null) {
						// Conta Mensagem 1
						if (mensagensConta[0] != null) {
							linhasImpostosRetidos[0] = (String) mensagensConta[0];
						} else {
							linhasImpostosRetidos[0] = "";
						}
						// Conta Mensagem 2
						if (mensagensConta[1] != null) {
							linhasImpostosRetidos[1] = (String) mensagensConta[1];
						} else {
							linhasImpostosRetidos[1] = "";
						}
						// Conta Mensagem 3
						if (mensagensConta[2] != null) {
							linhasImpostosRetidos[2] = (String) mensagensConta[2];
						} else {
							linhasImpostosRetidos[2] = "";
						}
						achou = true;
					}

					if (!achou) {

						// Caso seja a condição 2
						// (FaturamentoGrupo =null, GerenciaRegional=parmConta,
						// Localidade=null, SetorComercial=null)
						// Conta Mensagem 1
						mensagensConta = repositorioFaturamento
								.pesquisarParmsContaMensagem(emitirContaHelper,
										null, idGerenciaRegional, idLocalidade,
										null);
						if (mensagensConta != null) {
							if (mensagensConta[0] != null) {
								linhasImpostosRetidos[0] = (String) mensagensConta[0];
							} else {
								linhasImpostosRetidos[0] = "";
							}
							// Conta Mensagem 2
							if (mensagensConta[1] != null) {
								linhasImpostosRetidos[1] = (String) mensagensConta[1];
							} else {
								linhasImpostosRetidos[1] = "";
							}
							// Conta Mensagem 3
							if (mensagensConta[2] != null) {
								linhasImpostosRetidos[2] = (String) mensagensConta[2];
							} else {
								linhasImpostosRetidos[2] = "";
							}
							achou = true;
						}
					}
					if (!achou) {
						// Caso seja a condição 3
						// (FaturamentoGrupo =null, GerenciaRegional=parmConta,
						// Localidade=null, SetorComercial=null)
						// Conta Mensagem 1
						mensagensConta = repositorioFaturamento
								.pesquisarParmsContaMensagem(emitirContaHelper,
										null, idGerenciaRegional, null, null);

						if (mensagensConta != null) {

							if (mensagensConta[0] != null) {
								linhasImpostosRetidos[0] = (String) mensagensConta[0];
							} else {
								linhasImpostosRetidos[0] = "";
							}
							// Conta Mensagem 2
							if (mensagensConta[1] != null) {
								linhasImpostosRetidos[1] = (String) mensagensConta[1];
							} else {
								linhasImpostosRetidos[1] = "";
							}
							// Conta Mensagem 3
							if (mensagensConta[2] != null) {
								linhasImpostosRetidos[2] = (String) mensagensConta[2];
							} else {
								linhasImpostosRetidos[2] = "";
							}
							achou = true;
						}
					}
					if (!achou) {
						// Caso seja a condição 4
						// (FaturamentoGrupo =parmConta, GerenciaRegional=null,
						// Localidade=null, SetorComercial=null)
						// Conta Mensagem 1
						mensagensConta = repositorioFaturamento
								.pesquisarParmsContaMensagem(emitirContaHelper,
										idFaturamentoGrupo, null, null, null);

						if (mensagensConta != null) {
							if (mensagensConta[0] != null) {
								linhasImpostosRetidos[0] = (String) mensagensConta[0];
							} else {
								linhasImpostosRetidos[0] = "";
							}
							// Conta Mensagem 2
							if (mensagensConta[1] != null) {
								linhasImpostosRetidos[1] = (String) mensagensConta[1];
							} else {
								linhasImpostosRetidos[1] = "";
							}
							// Conta Mensagem 3
							if (mensagensConta[2] != null) {
								linhasImpostosRetidos[2] = (String) mensagensConta[2];
							} else {
								linhasImpostosRetidos[2] = "";
							}
							achou = true;
						}
					}
					if (!achou) {
						// Caso seja a condição 5
						// (FaturamentoGrupo =null, GerenciaRegional=null,
						// Localidade=null, SetorComercial=null)
						// Conta Mensagem 1
						mensagensConta = repositorioFaturamento
								.pesquisarParmsContaMensagem(emitirContaHelper,
										null, null, null, null);
						if (mensagensConta != null) {
							if (mensagensConta[0] != null) {
								linhasImpostosRetidos[0] = (String) mensagensConta[0];
							} else {
								linhasImpostosRetidos[0] = "";
							}
							// Conta Mensagem 2
							if (mensagensConta[1] != null) {
								linhasImpostosRetidos[1] = (String) mensagensConta[1];
							} else {
								linhasImpostosRetidos[1] = "";
							}
							// Conta Mensagem 3
							if (mensagensConta[2] != null) {
								linhasImpostosRetidos[2] = (String) mensagensConta[2];
							} else {
								linhasImpostosRetidos[2] = "";
							}
							achou = true;
						}
					}
					// caso não tenha entrado em nenhuma das opções acima
					// então completa a string com espaçõs em branco
					if (!achou) {
						linhasImpostosRetidos[0] = "";
						linhasImpostosRetidos[1] = "";
						linhasImpostosRetidos[2] = "";
					}

				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

			}
		}
		return linhasImpostosRetidos;
	}

	/**
	 * Metódo responsável pra verificar se a Mensagem da Conta esta sendo
	 * Faturada.
	 * 
	 * Manter Mensagem Conta
	 * 
	 * 
	 * @author Tiago Moreno
	 * @date 23/05/2006
	 * 
	 * @param String
	 *            [] ids
	 * @throws ControladorException
	 */

	public void verificarUtilizacaoMensagemConta(String[] ids)
			throws ControladorException {

	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00017] Gerar Linhas das Contas com Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder[] gerarLinhasContaDebitoAutomatico(
			EmitirContaHelper emitirContaHelper, Integer sequencialEmpresa)
			throws ControladorException {
		StringBuilder[] linhasContaDebitoAutomaticoArray = new StringBuilder[2];
		StringBuilder linhasContaDebitoAutomatico = new StringBuilder();
		// ultima linha que pode ter o continua ou não dependendo da descrição
		// de serviços e tarifas
		StringBuilder ultimaLinhaContaDebitoAutomatico = new StringBuilder();
		// -- Linha 24 --//
		// Canal
		linhasContaDebitoAutomatico.append("1");
		// Fonte
		linhasContaDebitoAutomatico.append("4");
		// parametros debito automatico
		Object[] parmsDebitoAutomatico = null;
		try {
			parmsDebitoAutomatico = repositorioArrecadacao
					.pesquisarParmsDebitoAutomatico(emitirContaHelper
							.getIdImovel());
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		String nomeBanco = "";
		String codigoAgencia = "";
		if (parmsDebitoAutomatico != null) {
			// nome do banco
			if (parmsDebitoAutomatico[0] != null) {
				nomeBanco = (String) parmsDebitoAutomatico[0];
			}
			// codigo Agencia
			if (parmsDebitoAutomatico[1] != null) {
				codigoAgencia = ((String) parmsDebitoAutomatico[1]);
			}
		}
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 45));
		// nome do banco
		linhasContaDebitoAutomatico.append(Util.completaString(nomeBanco, 40));
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 44));
		linhasContaDebitoAutomatico
				.append(System.getProperty("line.separator"));

		// -- Linha 25 --//
		// Canal
		linhasContaDebitoAutomatico.append(" ");
		// Fonte
		linhasContaDebitoAutomatico.append("4");
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 13));
		// codigo agencia
		linhasContaDebitoAutomatico.append(Util.adicionarZerosEsquedaNumero(5,
				codigoAgencia));
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 111));
		linhasContaDebitoAutomatico
				.append(System.getProperty("line.separator"));

		// -- Linha 26 --//
		// Canal
		linhasContaDebitoAutomatico.append("1");
		// Fonte
		linhasContaDebitoAutomatico.append("1");
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 23));
		// Constante
		linhasContaDebitoAutomatico.append(Util.completaString("MATRICULA - ",
				15));
		// matricula do imóvel
		// Recupera a matrícula do imóvel da coluna 1 e formata a matrícula
		// (ex:500000001 em 5000000.1)
		String matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(9,
				"" + emitirContaHelper.getIdImovel());
		matriculaImovelFormatada = matriculaImovelFormatada.substring(0, 8)
				+ "." + matriculaImovelFormatada.substring(8, 9);
		linhasContaDebitoAutomatico.append(Util.completaString(
				matriculaImovelFormatada, 10));
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(" ");
		// Constante
		linhasContaDebitoAutomatico
				.append(Util.completaString("FATURA - ", 15));
		// mes e ano de referencia da conta
		String mesAnoFormatado = Util
				.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia());
		linhasContaDebitoAutomatico.append(Util.completaString(mesAnoFormatado,
				7));
		String digitoVerificador = ""
				+ emitirContaHelper.getDigitoVerificadorConta();
		linhasContaDebitoAutomatico.append(Util.completaString(
				("-" + digitoVerificador), 3));
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 55));
		linhasContaDebitoAutomatico
				.append(System.getProperty("line.separator"));

		// -- Linha 27 --//
		// Canal
		ultimaLinhaContaDebitoAutomatico.append("1");
		// Fonte
		ultimaLinhaContaDebitoAutomatico.append("1");
		// completa com espaços em branco
		ultimaLinhaContaDebitoAutomatico.append(Util.completaString("", 13));
		// id faturamento grupo
		ultimaLinhaContaDebitoAutomatico.append(Util.completaString(""
				+ emitirContaHelper.getIdFaturamentoGrupo(), 4));
		// completa com espaços em branco
		ultimaLinhaContaDebitoAutomatico.append(Util.completaString("", 27));
		// codigo empresa
		if (emitirContaHelper.getIdEmpresa() != null) {
			ultimaLinhaContaDebitoAutomatico.append(Util.completaString(""
					+ emitirContaHelper.getIdEmpresa(), 4));
		} else {
			ultimaLinhaContaDebitoAutomatico.append(Util.completaString("", 4));
		}
		// sequencial empresa
		String sequencialEmpresaFormatada = "";
		if (sequencialEmpresa != null) {
			sequencialEmpresaFormatada = Util.adicionarZerosEsquedaNumero(6, ""
					+ sequencialEmpresa);
			sequencialEmpresaFormatada = sequencialEmpresaFormatada.substring(
					0, 3) + "." + sequencialEmpresaFormatada.substring(3, 6);
			ultimaLinhaContaDebitoAutomatico.append("-"
					+ sequencialEmpresaFormatada);
		} else {
			ultimaLinhaContaDebitoAutomatico.append(Util.completaString("", 8));
		}

		// na ultimaLinhaContaDebitoAutomatico falta ainda o continua ou não
		// assim como o sequencial

		linhasContaDebitoAutomaticoArray[0] = linhasContaDebitoAutomatico;
		linhasContaDebitoAutomaticoArray[1] = ultimaLinhaContaDebitoAutomatico;

		return linhasContaDebitoAutomaticoArray;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00018] Gerar Linhas das Contas com Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder[] gerarLinhasDemaisContas(
			EmitirContaHelper emitirContaHelper, Integer sequencialEmpresa,
			BigDecimal valorConta) throws ControladorException {
		StringBuilder[] linhasDemaisContaArray = new StringBuilder[2];
		StringBuilder linhasDemaisConta = new StringBuilder();
		// ultima linha que pode ter o continua ou não dependendo da descrição
		// de serviços e tarifas
		StringBuilder ultimaLinhaDemaisContas = new StringBuilder();

		// -- Linha 24 --//
		// Canal
		linhasDemaisConta.append("1");
		// Fonte
		linhasDemaisConta.append("1");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 12));
		String anoMesString = "" + emitirContaHelper.getAmReferencia();
		// formata ano mes para mes ano
		String mesAnoFormatado = anoMesString.substring(4, 6)
				+ anoMesString.substring(0, 4);
		Integer digitoVerificadorConta = new Integer(""
				+ emitirContaHelper.getDigitoVerificadorConta());

		// Representação numérica código de barras
		String representacaoNumericaCodBarra = null;

		representacaoNumericaCodBarra = this.getControladorArrecadacao()
				.obterRepresentacaoNumericaCodigoBarra(3, valorConta,
						emitirContaHelper.getIdLocalidade(),
						emitirContaHelper.getIdImovel(), mesAnoFormatado,
						digitoVerificadorConta, null, null, null, null, null,
						null, null);

		String representacaoNumericaCodBarraSemDigito = "";
		String representacaoNumericaCodBarraFormatada = "";
		if (representacaoNumericaCodBarra != null) {
			// Formata a representação númerica do código de
			// barras
			representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra
					.substring(0, 11)
					+ "-"
					+ representacaoNumericaCodBarra.substring(11, 12)
					+ " "
					+ representacaoNumericaCodBarra.substring(12, 23)
					+ "-"
					+ representacaoNumericaCodBarra.substring(23, 24)
					+ " "
					+ representacaoNumericaCodBarra.substring(24, 35)
					+ "-"
					+ representacaoNumericaCodBarra.substring(35, 36)
					+ " "
					+ representacaoNumericaCodBarra.substring(36, 47)
					+ "-"
					+ representacaoNumericaCodBarra.substring(47, 48);

			representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra
					.substring(0, 11)
					+ representacaoNumericaCodBarra.substring(12, 23)
					+ representacaoNumericaCodBarra.substring(24, 35)
					+ representacaoNumericaCodBarra.substring(36, 47);
		}

		// adiciona a representacao codigoBarras
		linhasDemaisConta.append(Util.completaString(
				representacaoNumericaCodBarraFormatada, 55));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 62));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 25 --//
		// Canal
		linhasDemaisConta.append("-");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 130));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 26 --//
		// Canal
		linhasDemaisConta.append("-");
		// Fonte
		linhasDemaisConta.append("3");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 13));

		// Cria o objeto para gerar o códigode barras no
		// padrão intercalado 2 de 5
		Interleaved2of5 codigoBarraIntercalado2de5 = new Interleaved2of5();
		// Recupera a representação númerica do código de
		// barras sem os dígitos verificadores
		if (representacaoNumericaCodBarraSemDigito != null
				&& !representacaoNumericaCodBarraSemDigito.equals("")) {
			linhasDemaisConta
					.append(Util.completaString(
							codigoBarraIntercalado2de5
									.encodeValue(representacaoNumericaCodBarraSemDigito),
							116));
		} else {
			linhasDemaisConta.append(Util.completaString("", 116));
		}
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 27 --//
		// Canal
		linhasDemaisConta.append("1");
		// Fonte
		linhasDemaisConta.append("2");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 4));
		// matricula do imóvel
		// Recupera a matrícula do imóvel da coluna 1 e formata a matrícula
		// (ex:500000001 em 5000000.1)
		String matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(9,
				"" + emitirContaHelper.getIdImovel());
		matriculaImovelFormatada = matriculaImovelFormatada.substring(0, 8)
				+ "." + matriculaImovelFormatada.substring(8, 9);
		linhasDemaisConta.append(Util.completaString(matriculaImovelFormatada,
				10));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 115));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 28 --//
		// Canal
		linhasDemaisConta.append("+");
		// Fonte
		linhasDemaisConta.append("1");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 25));
		// instância um imovel com os dados da conta para recuperar a
		// inscrição que está np objeto imovel
		Imovel imovel = new Imovel();
		Localidade localidade = new Localidade();
		localidade.setId(emitirContaHelper.getIdLocalidade());
		imovel.setLocalidade(localidade);
		SetorComercial setorComercial = new SetorComercial();
		setorComercial.setCodigo(emitirContaHelper
				.getCodigoSetorComercialConta());
		imovel.setSetorComercial(setorComercial);
		Quadra quadra = new Quadra();
		quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
		imovel.setQuadra(quadra);
		imovel.setLote(emitirContaHelper.getLoteConta());
		imovel.setSubLote(emitirContaHelper.getSubLoteConta());
		// Inscrição do imóvel
		String inscricao = imovel.getInscricaoFormatada();
		linhasDemaisConta.append(Util.completaString(inscricao, 22));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 16));
		String mesAnoString = Util.formatarAnoMesParaMesAno(emitirContaHelper
				.getAmReferencia());
		// mes e ano de referencia da conta
		linhasDemaisConta.append(mesAnoString);
		String digitoVerificador = ""
				+ emitirContaHelper.getDigitoVerificadorConta();
		linhasDemaisConta.append(Util.completaString(("-" + digitoVerificador),
				3));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 7));
		// data de validade da conta
		String dataValidade = Util.formatarData(emitirContaHelper
				.getDataValidadeConta());
		linhasDemaisConta.append(Util.completaString(dataValidade, 10));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 39));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 29 --//
		// Canal
		linhasDemaisConta.append(" ");
		// Fonte
		linhasDemaisConta.append("1");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 129));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 30 --//
		// Canal
		linhasDemaisConta.append("-");
		// Fonte
		linhasDemaisConta.append("2");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 15));
		// data de vencimento da conta
		String dataVencimento = Util.formatarData(emitirContaHelper
				.getDataVencimentoConta());
		linhasDemaisConta.append(Util.completaString(dataVencimento, 10));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 35));
		// valor da conta
		String valorContaString = Util.formatarMoedaReal(valorConta);
		linhasDemaisConta.append(Util.completaStringComEspacoAEsquerda(
				valorContaString, 17));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 52));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 31 --//
		// ultima linha depende da quantidade linhas da descrição de serviços e
		// tarifas(Para saber se vai colocar continua ou não)
		// Canal
		ultimaLinhaDemaisContas.append("-");
		// Fonte
		ultimaLinhaDemaisContas.append("1");
		// completa com espaços em branco
		ultimaLinhaDemaisContas.append(Util.completaString("", 13));
		// id faturamento grupo
		ultimaLinhaDemaisContas.append(Util.completaString(""
				+ emitirContaHelper.getIdFaturamentoGrupo(), 4));
		// completa com espaços em branco
		ultimaLinhaDemaisContas.append(Util.completaString("", 27));
		// codigo empresa
		if (emitirContaHelper.getIdEmpresa() != null) {
			ultimaLinhaDemaisContas.append(Util
					.completaStringComEspacoAEsquerda(
							"" + emitirContaHelper.getIdEmpresa(), 4));
		} else {
			ultimaLinhaDemaisContas.append(Util
					.completaStringComEspacoAEsquerda("", 4));
		}
		// sequencial empresa
		String sequencialEmpresaFormatada = "";
		if (sequencialEmpresa != null) {
			sequencialEmpresaFormatada = Util.adicionarZerosEsquedaNumero(6, ""
					+ sequencialEmpresa);
			sequencialEmpresaFormatada = sequencialEmpresaFormatada.substring(
					0, 3) + "." + sequencialEmpresaFormatada.substring(3, 6);
			ultimaLinhaDemaisContas.append("-" + sequencialEmpresaFormatada);
		} else {
			ultimaLinhaDemaisContas.append(Util.completaString("", 8));
		}
		// na ultimaLinhaContaDebitoAutomatico falta ainda o continua ou não
		// assim como o sequencial

		linhasDemaisContaArray[0] = linhasDemaisConta;
		linhasDemaisContaArray[1] = ultimaLinhaDemaisContas;

		return linhasDemaisContaArray;
	}

	/**
	 * Pesquisa todas as contas para testar o batch
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 02/06/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsTodasConta() throws ControladorException {
		try {
			return repositorioFaturamento.pesquisarIdsTodasConta();
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Gerar relatorio acompanhamento faturamento
	 * 
	 * 
	 * @author Fernanda Paiva
	 * @date 02/06/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection gerarRelacaoAcompanhamentoFaturamento(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,

			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal,

			String idImovelPerfil, String idPocoTipo,
			String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo,
			String idSituacaoEspecialCobranca, String idEloAnormalidade,
			String areaConstruidaInicial, String areaConstruidaFinal,
			String idCadastroOcorrencia, String idConsumoTarifa,
			String idGerenciaRegional, String idLocalidadeInicial,
			String idLocalidadeFinal, String setorComercialInicial,
			String setorComercialFinal, String quadraInicial,
			String quadraFinal, String loteOrigem, String loteDestno,
			String cep, String logradouro, String bairro, String municipio,
			String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa,
			int anoMesReferencia) throws ControladorException {

		Collection colecaoImoveis = null;

		try {
			// remove primeiro as linhas do critério cobrança
			colecaoImoveis = repositorioFaturamento
					.gerarRelacaoAcompanhamentoFaturamento(idImovelCondominio,
							idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
							consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto,
							consumoMinimoFinalEsgoto,
							intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal,

							intervaloMediaMinimaImovelInicial,
							intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal,

							idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
							idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal,
							idCadastroOcorrencia, idConsumoTarifa,
							idGerenciaRegional, idLocalidadeInicial,
							idLocalidadeFinal, setorComercialInicial,
							setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro,
							municipio, idTipoMedicao, indicadorMedicao,
							idSubCategoria, idCategoria,
							quantidadeEconomiasInicial,
							quantidadeEconomiasFinal, diaVencimento, idCliente,
							idClienteTipo, idClienteRelacaoTipo,
							numeroPontosInicial, numeroPontosFinal,
							numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		// colecao com os dados para o relatorio
		Collection colecaoGerarRelacaoAcompanhamentoFaturamento = null;

		// para cada imovel pega as conta, debitos, creditos e guias
		if (colecaoImoveis != null && !colecaoImoveis.isEmpty()) {

			Iterator iteratorColecaoImoveis = colecaoImoveis.iterator();
			colecaoGerarRelacaoAcompanhamentoFaturamento = new ArrayList();

			// GerarRelacaoDebitosImovelHelper gerarRelacaoDebitosImovelHelper =
			// null;
			GerarRelacaoAcompanhamentoFaturamentoHelper gerarRelacaoAcompanhamentoFaturamentoHelper = null;
			while (iteratorColecaoImoveis.hasNext()) {

				Object[] contasDadosRelatorio = (Object[]) iteratorColecaoImoveis
						.next();

				Imovel imovel = new Imovel();

				gerarRelacaoAcompanhamentoFaturamentoHelper = new GerarRelacaoAcompanhamentoFaturamentoHelper();

				// parte do caso de uso
				// id gerencia regional
				if (contasDadosRelatorio[0] != null) { // 0
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setIdGerenciaRegional(((Integer) contasDadosRelatorio[0])
									.toString());
				}
				// nome abreviado gerencia regional
				if (contasDadosRelatorio[1] != null) { // 1
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setNomeAbreviadoGerencia((String) contasDadosRelatorio[1]);
				}
				// id localidade
				if (contasDadosRelatorio[2] != null) { // 2
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setIdLocalidade(((Integer) contasDadosRelatorio[2])
									.toString());
				}
				// descricao localidade
				if (contasDadosRelatorio[3] != null) { // 3
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setNomeLocalidade((String) contasDadosRelatorio[3]);
				}
				// id imovel
				if (contasDadosRelatorio[4] != null) { // 4
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setCodigoImovel(((Integer) contasDadosRelatorio[4])
									.toString());
				}
				// quantidade de economias
				if (contasDadosRelatorio[5] != null) { // 5
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setQuantidadeEconomias(((Short) contasDadosRelatorio[5])
									.toString());
				}
				// codigo setor comercial
				if (contasDadosRelatorio[6] != null) { // 6
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setCodigoSetorComercial(((Integer) contasDadosRelatorio[6])
									.toString());
				}
				// numero quadra
				if (contasDadosRelatorio[7] != null) { // 7
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setNumeroQuadra(((Integer) contasDadosRelatorio[7])
									.toString());
				}
				// lote
				if (contasDadosRelatorio[8] != null) { // 8
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setLote(((Short) contasDadosRelatorio[8])
									.toString());
				}
				// sub lote
				if (contasDadosRelatorio[9] != null) { // 9
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setSubLote(((Short) contasDadosRelatorio[9])
									.toString());
				}
				// descricao ligacao agua situacao
				if (contasDadosRelatorio[10] != null) { // 10
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setSituacaoAgua((String) contasDadosRelatorio[10]);
				}
				// descricao ligacao esgoto situacao
				if (contasDadosRelatorio[11] != null) { // 11
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setSituacaoEsgoto((String) contasDadosRelatorio[11]);
				}
				// percentual
				if (contasDadosRelatorio[12] != null) { // 12
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setPercentualEsgoto(Util
									.formatarMoedaReal((BigDecimal) contasDadosRelatorio[12]));
				}
				// data corte
				if (contasDadosRelatorio[13] != null) { // 13
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setDataCorte(Util
									.formatarData((Date) contasDadosRelatorio[13]));
				}
				// gerencia regional - nome
				if (contasDadosRelatorio[14] != null) { // 14
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setNomeGerenciaRegional((String) contasDadosRelatorio[14]);
				}
				// Esgoto Fixado
				if (contasDadosRelatorio[15] != null) { // 14
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setEsgotoFixado((String) contasDadosRelatorio[15]
									.toString());
				}
				// Nome Usuário
				if (contasDadosRelatorio[16] != null) { // 14
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setNomeClienteUsuario((String) contasDadosRelatorio[16]
									.toString());
				}
				Localidade localidadeImovel = new Localidade();
				localidadeImovel.setId(new Integer(
						gerarRelacaoAcompanhamentoFaturamentoHelper
								.getIdLocalidade()));
				SetorComercial setorComercialImovel = new SetorComercial();
				setorComercialImovel.setCodigo(new Integer(
						gerarRelacaoAcompanhamentoFaturamentoHelper
								.getCodigoSetorComercial()).intValue());
				Quadra quadraImovel = new Quadra();
				quadraImovel.setNumeroQuadra(new Integer(
						gerarRelacaoAcompanhamentoFaturamentoHelper
								.getNumeroQuadra()).intValue());

				imovel.setLocalidade(localidadeImovel);
				imovel.setSetorComercial(setorComercialImovel);
				imovel.setQuadra(quadraImovel);
				imovel.setLote(new Short(
						gerarRelacaoAcompanhamentoFaturamentoHelper.getLote())
						.shortValue());
				imovel.setSubLote(new Short(
						gerarRelacaoAcompanhamentoFaturamentoHelper
								.getSubLote()).shortValue());

				gerarRelacaoAcompanhamentoFaturamentoHelper
						.setMesAnoFaturamento(Util
								.formatarAnoMesParaMesAno(anoMesReferencia));
				// Pesquisa as contas para calcular o valor total da conta
				Collection contas = null;
				try {
					contas = repositorioFaturamento
							.pesquisarContasDoImovelPorMesAnoReferencia(
									anoMesReferencia,
									gerarRelacaoAcompanhamentoFaturamentoHelper
											.getCodigoImovel());
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}

				BigDecimal valorFatura = new BigDecimal("0.00");
				BigDecimal valorTotalDebito = new BigDecimal("0.00");
				if (contas != null && !contas.isEmpty()) {
					Conta dadosDaConta = (Conta) contas.iterator().next();

					valorFatura = dadosDaConta.getValorTotal();
				}

				// fatura
				gerarRelacaoAcompanhamentoFaturamentoHelper
						.setValorFatura(valorFatura);
				// inscricao formatada do imovel
				gerarRelacaoAcompanhamentoFaturamentoHelper.setInscricao(imovel
						.getInscricaoFormatada());

				Calendar dataInicio = new GregorianCalendar();
				dataInicio.set(Calendar.YEAR, 1900);
				dataInicio.set(Calendar.MONTH, 0);
				dataInicio.set(Calendar.DAY_OF_MONTH, 1);

				Calendar dataFim = new GregorianCalendar();
				dataFim.set(Calendar.YEAR, 9999);
				dataFim.set(Calendar.MONTH, 11);
				dataFim.set(Calendar.DAY_OF_MONTH, 31);

				ObterDebitoImovelOuClienteHelper obterDebitoImovelOuClienteHelper = this
						.getControladorCobranca().obterDebitoImovelOuCliente(
								1,
								gerarRelacaoAcompanhamentoFaturamentoHelper
										.getCodigoImovel(), null, null,
								"190001", "999912", dataInicio.getTime(),
								dataFim.getTime(), 1, 1, 1, 1, 1, 1, 1, null);

				// obter endereco
				gerarRelacaoAcompanhamentoFaturamentoHelper
						.setEndereco(getControladorEndereco()
								.pesquisarEndereco(
										new Integer(
												gerarRelacaoAcompanhamentoFaturamentoHelper
														.getCodigoImovel())));

				// obter categoria do imovel
				gerarRelacaoAcompanhamentoFaturamentoHelper
						.setCategoriaPrincipal(getControladorImovel()
								.obterPrincipalCategoriaImovel(
										new Integer(
												gerarRelacaoAcompanhamentoFaturamentoHelper
														.getCodigoImovel()))
								.getDescricaoAbreviada());

				// pega as colecoes do retorno do método obter débito e calcula
				// o valor total do débito
				if (obterDebitoImovelOuClienteHelper.getColecaoContasValores() != null
						&& !obterDebitoImovelOuClienteHelper
								.getColecaoContasValores().isEmpty()) {

					Iterator contaValores = obterDebitoImovelOuClienteHelper
							.getColecaoContasValores().iterator();
					while (contaValores.hasNext()) {
						ContaValoresHelper contaValoresHelper = (ContaValoresHelper) contaValores
								.next();

						valorTotalDebito = valorTotalDebito
								.add(contaValoresHelper.getConta()
										.getValorTotal());
					}
				}
				if (obterDebitoImovelOuClienteHelper.getColecaoDebitoACobrar() != null
						&& !obterDebitoImovelOuClienteHelper
								.getColecaoDebitoACobrar().isEmpty()) {

					Iterator debitoACobrarIterator = obterDebitoImovelOuClienteHelper
							.getColecaoDebitoACobrar().iterator();
					while (debitoACobrarIterator.hasNext()) {
						DebitoACobrar debitoACobrar = (DebitoACobrar) debitoACobrarIterator
								.next();
						// alterado por Vivianne Sousa data:11/04/2008
						// analista :Adriano
						valorTotalDebito = valorTotalDebito.add(debitoACobrar
								.getValorTotalComBonus());
					}
				}
				if (obterDebitoImovelOuClienteHelper
						.getColecaoCreditoARealizar() != null
						&& !obterDebitoImovelOuClienteHelper
								.getColecaoCreditoARealizar().isEmpty()) {

					Iterator creditoARealizarIterator = obterDebitoImovelOuClienteHelper
							.getColecaoCreditoARealizar().iterator();
					while (creditoARealizarIterator.hasNext()) {
						CreditoARealizar creditoARealizar = (CreditoARealizar) creditoARealizarIterator
								.next();

						// alterado por Vivianne Sousa data:11/04/2008
						// analista :Adriano
						valorTotalDebito = valorTotalDebito
								.add(creditoARealizar.getValorTotalComBonus());
					}
				}
				if (obterDebitoImovelOuClienteHelper
						.getColecaoGuiasPagamentoValores() != null
						&& !obterDebitoImovelOuClienteHelper
								.getColecaoGuiasPagamentoValores().isEmpty()) {

					Iterator guiaPagamentoValoresIterator = obterDebitoImovelOuClienteHelper
							.getColecaoGuiasPagamentoValores().iterator();
					while (guiaPagamentoValoresIterator.hasNext()) {
						GuiaPagamentoValoresHelper guiaPagamentoValores = (GuiaPagamentoValoresHelper) guiaPagamentoValoresIterator
								.next();

						valorTotalDebito = valorTotalDebito
								.add(guiaPagamentoValores.getGuiaPagamento()
										.getValorDebito());
					}
				}
				gerarRelacaoAcompanhamentoFaturamentoHelper.setValorDebito(Util
						.formatarMoedaReal(valorTotalDebito));
				// Pesquisa o consumo médio de água ou esgoto
				Collection colecaoConsumoMedioAgua = null;
				Collection colecaoConsumoMedioEsgoto = null;

				String consumoMedio = null;
				try {
					colecaoConsumoMedioAgua = repositorioFaturamento
							.pesquisarConsumoMedioLigacaoAgua(
									gerarRelacaoAcompanhamentoFaturamentoHelper
											.getCodigoImovel(),
									anoMesReferencia);
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}
				if (colecaoConsumoMedioAgua != null) {

					Iterator consumoHistoricoIterator = colecaoConsumoMedioAgua
							.iterator();
					while (consumoHistoricoIterator.hasNext()) {
						ConsumoHistorico consumoHistorico = (ConsumoHistorico) consumoHistoricoIterator
								.next();
						if (consumoHistorico.getConsumoMedio() != null) {
							consumoMedio = consumoHistorico.getConsumoMedio()
									.toString();
						}
					}
				} else {
					try {
						colecaoConsumoMedioEsgoto = repositorioFaturamento
								.pesquisarConsumoMedioLigacaoEsgoto(
										gerarRelacaoAcompanhamentoFaturamentoHelper
												.getCodigoImovel(),
										anoMesReferencia);
					} catch (ErroRepositorioException e) {
						e.printStackTrace();
					}
					if (colecaoConsumoMedioEsgoto != null) {

						Iterator consumoHistoricoIterator = colecaoConsumoMedioEsgoto
								.iterator();
						while (consumoHistoricoIterator.hasNext()) {
							ConsumoHistorico consumoHistoricoEsgoto = (ConsumoHistorico) consumoHistoricoIterator
									.next();
							if (consumoHistoricoEsgoto.getConsumoMedio() != null) {
								consumoMedio = consumoHistoricoEsgoto
										.getConsumoMedio().toString();
							}
						}
					}
				}
				if (consumoMedio != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setConsumoMedio(consumoMedio.toString());
				}

				// pesquisa o consumo do mes de agua ou esgoto
				String consumoMes = null;
				String consumoAnormalidade = null;
				Collection colecaoConsumoMesAgua = null;
				Collection colecaoConsumoMesEsgoto = null;

				try {
					colecaoConsumoMesAgua = repositorioFaturamento
							.pesquisarConsumoMesLigacaoAgua(
									gerarRelacaoAcompanhamentoFaturamentoHelper
											.getCodigoImovel(),
									anoMesReferencia);
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}
				if (colecaoConsumoMesAgua != null) {

					Iterator consumoHistoricoMesIterator = colecaoConsumoMesAgua
							.iterator();
					while (consumoHistoricoMesIterator.hasNext()) {
						Object[] consumoHistoricoMes = (Object[]) consumoHistoricoMesIterator
								.next();
						if (consumoHistoricoMes[0] != null) {
							consumoMes = ((Integer) consumoHistoricoMes[0])
									.toString();
						}
						if (consumoHistoricoMes[1] != null) {
							consumoAnormalidade = (String) consumoHistoricoMes[1];
						}
					}
				} else {
					try {
						colecaoConsumoMesEsgoto = repositorioFaturamento
								.pesquisarConsumoMesLigacaoEsgoto(
										gerarRelacaoAcompanhamentoFaturamentoHelper
												.getCodigoImovel(),
										anoMesReferencia);
					} catch (ErroRepositorioException e) {
						e.printStackTrace();
					}
					if (colecaoConsumoMesEsgoto != null) {

						Iterator consumoMesIterator = colecaoConsumoMesEsgoto
								.iterator();
						while (consumoMesIterator.hasNext()) {
							Object[] consumoHistoricoEsgotoMes = (Object[]) consumoMesIterator
									.next();
							if (consumoHistoricoEsgotoMes[0] != null) {
								consumoMes = ((Integer) consumoHistoricoEsgotoMes[0])
										.toString();
							}
							if (consumoHistoricoEsgotoMes[1] != null) {
								consumoAnormalidade = (String) consumoHistoricoEsgotoMes[1];
							}
						}
					}
				}

				if (consumoMes != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setConsumoMes(consumoMes.toString());
				}
				if (consumoAnormalidade != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setConsumoAnormalidade(consumoAnormalidade);
				}

				// pesquisa o leitura faturada de agua ou esgoto
				String fatura = null;
				Collection colecaoFaturaMesAgua = null;
				Collection colecaoFaturaMesEsgoto = null;
				Integer idLeituraAnormalidadeFaturamento = null;
				String anormalidadeLeitura = null;

				try {
					colecaoFaturaMesAgua = repositorioFaturamento
							.pesquisarLeituraFaturadaLigacaoAgua(
									gerarRelacaoAcompanhamentoFaturamentoHelper
											.getCodigoImovel(),
									anoMesReferencia);
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}
				if (colecaoFaturaMesAgua != null) {

					Iterator medicaoHistoricoMesIterator = colecaoFaturaMesAgua
							.iterator();
					while (medicaoHistoricoMesIterator.hasNext()) {
						Object[] medicaoHistoricoMes = (Object[]) medicaoHistoricoMesIterator
								.next();
						if (medicaoHistoricoMes[0] != null) {
							fatura = "" + (Integer) medicaoHistoricoMes[0];
						}
						if (medicaoHistoricoMes[1] != null) {
							idLeituraAnormalidadeFaturamento = (Integer) medicaoHistoricoMes[1];
						}
					}
				} else {
					try {
						colecaoFaturaMesEsgoto = repositorioFaturamento
								.pesquisarLeituraFaturadaLigacaoEsgoto(
										gerarRelacaoAcompanhamentoFaturamentoHelper
												.getCodigoImovel(),
										anoMesReferencia);
					} catch (ErroRepositorioException e) {
						e.printStackTrace();
					}
					if (colecaoFaturaMesEsgoto != null) {

						Iterator faturaMesIterator = colecaoFaturaMesEsgoto
								.iterator();
						while (faturaMesIterator.hasNext()) {
							MedicaoHistorico medicaoHistoricoEsgotoMes = (MedicaoHistorico) faturaMesIterator
									.next();
							fatura = new Integer(
									medicaoHistoricoEsgotoMes
											.getLeituraAtualFaturamento())
									.toString();

							idLeituraAnormalidadeFaturamento = medicaoHistoricoEsgotoMes
									.getLeituraAnormalidadeFaturamento()
									.getId();
						}
					}
				}

				if (fatura != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setFatura(fatura);
				}

				// pesquisa a leitura anormalidade
				if (idLeituraAnormalidadeFaturamento != null) {
					try {
						anormalidadeLeitura = repositorioFaturamento
								.pesquisarAnormalidadeLeitura(idLeituraAnormalidadeFaturamento);
					} catch (ErroRepositorioException e) {
						e.printStackTrace();
					}
					if (anormalidadeLeitura != null) {
						gerarRelacaoAcompanhamentoFaturamentoHelper
								.setAnormalidade(anormalidadeLeitura);
					}
				}
				// Consumo de seis periodos
				int mesAnoFaturamentoDiferenca = 0;
				String[] consumoSeisMeses = new String[6];
				for (int i = 0; i < 6; i++) {
					mesAnoFaturamentoDiferenca = i + 1;

					mesAnoFaturamentoDiferenca = Util
							.subtraiAteSeisMesesAnoMesReferencia(
									anoMesReferencia,
									mesAnoFaturamentoDiferenca);

					// Pesquisa o consumo de seis meses de água ou esgoto
					Collection colecaoConsumoSeisMesesAgua = null;
					Collection colecaoConsumoSeisMesesEsgoto = null;

					try {
						colecaoConsumoSeisMesesAgua = repositorioFaturamento
								.pesquisarConsumoMedioLigacaoAgua(
										gerarRelacaoAcompanhamentoFaturamentoHelper
												.getCodigoImovel(),
										mesAnoFaturamentoDiferenca);
					} catch (ErroRepositorioException e) {
						e.printStackTrace();
					}
					if (colecaoConsumoSeisMesesAgua != null) {

						Iterator consumoHistoricoSeisMesesIterator = colecaoConsumoSeisMesesAgua
								.iterator();
						while (consumoHistoricoSeisMesesIterator.hasNext()) {
							ConsumoHistorico consumoHistoricoSeisMeses = (ConsumoHistorico) consumoHistoricoSeisMesesIterator
									.next();
							if (consumoHistoricoSeisMeses
									.getNumeroConsumoFaturadoMes() != null) {
								consumoSeisMeses[i] = consumoHistoricoSeisMeses
										.getNumeroConsumoFaturadoMes()
										.toString();
							}
						}
					} else {
						try {
							colecaoConsumoSeisMesesEsgoto = repositorioFaturamento
									.pesquisarConsumoMedioLigacaoEsgoto(
											gerarRelacaoAcompanhamentoFaturamentoHelper
													.getCodigoImovel(),
											mesAnoFaturamentoDiferenca);
						} catch (ErroRepositorioException e) {
							e.printStackTrace();
						}
						if (colecaoConsumoSeisMesesEsgoto != null) {

							Iterator consumoHistoricoSeisMesesIterator = colecaoConsumoSeisMesesEsgoto
									.iterator();
							while (consumoHistoricoSeisMesesIterator.hasNext()) {
								ConsumoHistorico consumoHistoricoSeisMesesEsgoto = (ConsumoHistorico) consumoHistoricoSeisMesesIterator
										.next();
								if (consumoHistoricoSeisMesesEsgoto
										.getNumeroConsumoFaturadoMes() != null) {
									consumoSeisMeses[i] = consumoHistoricoSeisMesesEsgoto
											.getNumeroConsumoFaturadoMes()
											.toString();
								}
							}
						}
					}
				}
				if (consumoSeisMeses[0] != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setMesUm(consumoSeisMeses[0]);
				}
				if (consumoSeisMeses[1] != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setMesDois(consumoSeisMeses[1]);
				}
				if (consumoSeisMeses[2] != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setMesTres(consumoSeisMeses[2]);
				}
				if (consumoSeisMeses[3] != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setMesQuatro(consumoSeisMeses[3]);
				}
				if (consumoSeisMeses[4] != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setMesCinco(consumoSeisMeses[4]);
				}
				if (consumoSeisMeses[5] != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setMesSeis(consumoSeisMeses[5]);
				}

				// pesquisa o leitura faturada de agua ou esgoto
				Collection colecaoInstacaoHidrometroLigacaoAgua = null;
				Collection colecaoInstacaoHidrometroLigacaoEsgoto = null;
				String dataInstalacaoHidrometro = null;

				try {
					colecaoInstacaoHidrometroLigacaoAgua = repositorioFaturamento
							.pesquisarDataHidrometroLigacaoAgua(gerarRelacaoAcompanhamentoFaturamentoHelper
									.getCodigoImovel());
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}
				if (colecaoInstacaoHidrometroLigacaoAgua != null) {

					Iterator instalacaoHidrometroIterator = colecaoInstacaoHidrometroLigacaoAgua
							.iterator();
					while (instalacaoHidrometroIterator.hasNext()) {
						HidrometroInstalacaoHistorico instalacaoHidrometro = (HidrometroInstalacaoHistorico) instalacaoHidrometroIterator
								.next();
						dataInstalacaoHidrometro = Util
								.formatarData(instalacaoHidrometro
										.getDataInstalacao());
					}
				} else {
					try {
						colecaoInstacaoHidrometroLigacaoEsgoto = repositorioFaturamento
								.pesquisarDataHidrometroLigacaoEsgoto(gerarRelacaoAcompanhamentoFaturamentoHelper
										.getCodigoImovel());
					} catch (ErroRepositorioException e) {
						e.printStackTrace();
					}
					if (colecaoInstacaoHidrometroLigacaoEsgoto != null) {

						Iterator instalacaoHidrometroEsgotoIterator = colecaoInstacaoHidrometroLigacaoEsgoto
								.iterator();
						while (instalacaoHidrometroEsgotoIterator.hasNext()) {
							HidrometroInstalacaoHistorico instalacaoHidrometroEsgoto = (HidrometroInstalacaoHistorico) instalacaoHidrometroEsgotoIterator
									.next();
							dataInstalacaoHidrometro = Util
									.formatarData(instalacaoHidrometroEsgoto
											.getDataInstalacao());
						}
					}
				}
				if (dataInstalacaoHidrometro != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setDataInstalacaoHidrometro(dataInstalacaoHidrometro);
				}

				Collection colecaoConsumoFaturadoMes = null;
				String percentualVariacao = null;
				Integer numeroConsumoFaturadoMes = 0;

				try {
					colecaoConsumoFaturadoMes = repositorioFaturamento
							.pesquisarConsumoFaturadoMes(
									gerarRelacaoAcompanhamentoFaturamentoHelper
											.getCodigoImovel(),
									anoMesReferencia);
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}
				if (colecaoConsumoFaturadoMes != null) {

					Iterator consumoFaturadoMesIterator = colecaoConsumoFaturadoMes
							.iterator();
					while (consumoFaturadoMesIterator.hasNext()) {
						ConsumoHistorico consumoHistoricoMes = (ConsumoHistorico) consumoFaturadoMesIterator
								.next();
						numeroConsumoFaturadoMes = consumoHistoricoMes
								.getNumeroConsumoFaturadoMes();
					}
					if (numeroConsumoFaturadoMes != 0 && consumoMedio != null) {
						percentualVariacao = Calculos
								.obterPercentualVariacaoConsumoFaturado(
										numeroConsumoFaturadoMes,
										Integer.parseInt(consumoMedio));
					}
				}
				if (percentualVariacao != null) {
					gerarRelacaoAcompanhamentoFaturamentoHelper
							.setVariacao(percentualVariacao);
				}

				colecaoGerarRelacaoAcompanhamentoFaturamento
						.add(gerarRelacaoAcompanhamentoFaturamentoHelper);

			}// fim while
		}// fim if

		return colecaoGerarRelacaoAcompanhamentoFaturamento;
	}

	public Collection<FaturamentoAtividadeCronograma> pesquisarRelacaoAtividadesGrupo(
			Integer faturamentoGrupoId) throws ControladorException {

		Collection<FaturamentoAtividadeCronograma> retorno = null;

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		try {
			retorno = repositorioFaturamento
					.pesquisarRelacaoAtividadesGrupo(faturamentoGrupoId,
							sistemaParametro.getAnoMesFaturamento());
		} catch (ErroRepositorioException e) {

			e.printStackTrace();
		}
		return retorno;
	}

	/**
	 * [UC0169] Manter Taraifa de Consumo Prepara a Vigência para Ser reajustada
	 * 
	 * @author Rafel Santos
	 * @date 21/07/2006
	 * 
	 */
	public void iniciarProcessoReajustarTarifaConsumo(
			Map listaParametrosValoresCategoria, Date dataNovaVigencia,
			String[] idsRecuperados) throws ControladorException {

		for (int i = 0; i < idsRecuperados.length; i++) {
			Map<ConsumoTarifaVigencia, Map<ConsumoTarifaCategoria, BigDecimal>> mapFachada = new HashMap();

			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia
					.adicionarCaminhoParaCarregamentoEntidade("consumoTarifaCategorias");
			filtroConsumoTarifaVigencia
					.adicionarParametro(new ParametroSimples(
							FiltroConsumoTarifaVigencia.ID, idsRecuperados[i]));
			Collection colecaoConsumoTarifaVigencia = getControladorUtil()
					.pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());
			ConsumoTarifaVigencia consumoTarifaVigencia = (ConsumoTarifaVigencia) Util
					.retonarObjetoDeColecao(colecaoConsumoTarifaVigencia);

			consumoTarifaVigencia.setDataVigencia(dataNovaVigencia);

			Iterator iteratorConsumoTarifaCategorias = consumoTarifaVigencia
					.getConsumoTarifaCategorias().iterator();

			Map tempMap = new HashMap();
			while (iteratorConsumoTarifaCategorias.hasNext()) {
				ConsumoTarifaCategoria consumoTarifaCategoria = (ConsumoTarifaCategoria) iteratorConsumoTarifaCategorias
						.next();
				Categoria categoria = consumoTarifaCategoria.getCategoria();

				if (listaParametrosValoresCategoria.get(categoria.getId()) != null) {
					BigDecimal percentualReajuste = (BigDecimal) listaParametrosValoresCategoria
							.get(categoria.getId());

					tempMap.put(consumoTarifaCategoria, percentualReajuste);

				}

			}
			mapFachada.put(consumoTarifaVigencia, tempMap);

			reajustarTarifaConsumo(mapFachada);

		}
	}

	/**
	 * 
	 * [UC0169] Manter Tarifa de Consumo
	 * 
	 * 
	 * [FS0002] Verificar Data de Vigencia
	 * 
	 * @author Rafael Santos
	 * @date 21/07/2006
	 * 
	 * @param mapReajuste
	 * @throws ControladorException
	 */
	protected void verificarDataVigencia(
			Map<ConsumoTarifaVigencia, Map<ConsumoTarifaCategoria, BigDecimal>> mapReajuste)
			throws ControladorException {

		Iterator<ConsumoTarifaVigencia> iteratorTarifaVigencia2 = mapReajuste
				.keySet().iterator();

		while (iteratorTarifaVigencia2.hasNext()) {
			ConsumoTarifaVigencia consumoTarifaVigencia = iteratorTarifaVigencia2
					.next();

			// testar a data de vigência se é posterior
			// [FS0002] - Verificar data de vigência
			int idConsumoTarifa = consumoTarifaVigencia.getConsumoTarifa()
					.getId();
			// int idConsumoTarifaVigencia = consumoTarifaVigencia.getId();

			// pesquisa
			FiltroConsumoTarifa filtroConsumoTarifa = new FiltroConsumoTarifa();
			filtroConsumoTarifa.adicionarParametro(new ParametroSimples(
					FiltroConsumoTarifa.ID, idConsumoTarifa));
			Collection colecaoConsumoTarifa = getControladorUtil().pesquisar(
					filtroConsumoTarifa, ConsumoTarifa.class.getName());

			for (Iterator iter = colecaoConsumoTarifa.iterator(); iter
					.hasNext();) {
				ConsumoTarifa consumoTarifa = (ConsumoTarifa) iter.next();

				Collection colecaoDataVigenciaEmVigorArray = null;

				try {
					colecaoDataVigenciaEmVigorArray = repositorioFaturamento
							.pesquisarMaiorDataConsumoTarifaVigencia(consumoTarifa);
				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					new ControladorException("erro.sistema", ex);
				}

				Iterator colecaoDataVigenciaEmVigorArrayIt = colecaoDataVigenciaEmVigorArray
						.iterator();

				Date dataVigenciaEmVigor = ((Date) colecaoDataVigenciaEmVigorArrayIt
						.next());

				// verificando a Data de Vigencia com a Maior data exisente
				Calendar dataExistente = new GregorianCalendar();
				dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());

				if (dataVigenciaEmVigor != null) {

					Calendar dataVigenciaSerInserida = new GregorianCalendar();
					dataVigenciaSerInserida.setTime(dataVigenciaEmVigor);

					if ((dataExistente.compareTo(dataVigenciaSerInserida)) <= 0) {
						throw new ControladorException(
								"atencao.data_vigencia_errada", null,
								Util.formatarData(dataVigenciaEmVigor));
					}
				}

				// verifica a Data de Vigencia com a Ano Mes de Faturamento
				Integer anoMesFaturamento = getControladorUtil()
						.pesquisarParametrosDoSistema().getAnoMesFaturamento();

				dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());
				String anoMesDataVigenciaTarifa = null;
				if ((dataExistente.get(Calendar.MONTH) + 1) < 10) {
					anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR)
							+ "0" + (dataExistente.get(Calendar.MONTH) + 1);
				} else {
					anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR)
							+ "" + (dataExistente.get(Calendar.MONTH) + 1);
				}

				Integer anoMesVigencia = new Integer(anoMesDataVigenciaTarifa);

				if (anoMesVigencia.intValue() < anoMesFaturamento.intValue()) {
					throw new ControladorException(
							"atencao.data_vigencia.posterior.ano_mes_faturamento",
							null, Util
									.formatarAnoMesParaMesAno(anoMesFaturamento
											.intValue()));
				}

				// verificar se a Data de Vigencia é mario que 90 dias
				Calendar dataCorrente = new GregorianCalendar();
				dataCorrente.add(Calendar.DAY_OF_MONTH, 90);

				if ((dataExistente.compareTo(dataCorrente)) > 0) {
					throw new ControladorException(
							"atencao.data_vigencia.maior_que.90_dias", null,
							Util.formatarData(dataVigenciaEmVigor));
				}
			}

		}
	}

	/**
	 * Este caso de uso calcula a tarifa miníma de água para um imóvel
	 * 
	 * [UC0451] Obter Tarifa Miníma de Água para um Imóvel
	 * 
	 * @author Roberta Costa
	 * @date 09/08/2006
	 * 
	 * @param imovel
	 * @param colecaoCategorias
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	public BigDecimal obterTarifaMinimaAguaImovel(Imovel imovel)
			throws ControladorException {

		// Declaração de variáveis
		BigDecimal tarifaMinimaAguaImovel = new BigDecimal("0.00");
		BigDecimal resultadoTarifaMinimaAguaImovel = new BigDecimal("0.00");

		// Declaração de objetos
		Collection colecaoDataVigencia = null;

		// Obtém o id da tarifa vigência da maior data de vigência da tarifa do
		// imóvel
		try {
			colecaoDataVigencia = repositorioMicromedicao
					.pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(),
							imovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		// Obtém o id do array e atribui na variável
		Object[] consumoTarifaVigenciaIdArray = (Object[]) Util
				.retonarObjetoDeColecaoArray(colecaoDataVigencia);
		Integer consumoTarifaVigenciaId = null;

		if (consumoTarifaVigenciaIdArray == null) {
			throw new ControladorException(
					"erro.nao_cadastrada_consumo_tarifa_vigencia", null,
					String.valueOf(imovel.getId()));
		}

		if (consumoTarifaVigenciaIdArray[0] != null) {
			consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0];
		}

		// Cria o objeto consumo tarifa vigência e seta o id
		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		consumoTarifaVigencia.setId(consumoTarifaVigenciaId);

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoCategorias = getControladorImovel()
				.obterQuantidadeEconomiasCategoria(imovel);

		Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();

		while (colecaoCategoriasIterator.hasNext()) {

			Categoria categoria = (Categoria) colecaoCategoriasIterator.next();

			Integer idSubCategoria = 0;

			try {
				// Obtém a tarifa mínima da categoria do imóvel
				tarifaMinimaAguaImovel = (BigDecimal) repositorioFaturamento
						.pesquisarTarifaMinimaCategoriaVigencia(categoria,
								consumoTarifaVigencia, idSubCategoria);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}

			// Multiplica a quantidade de economias da categoria pelo consumo
			// mínimo e acumula
			resultadoTarifaMinimaAguaImovel = resultadoTarifaMinimaAguaImovel
					.add(tarifaMinimaAguaImovel.multiply(new BigDecimal(
							categoria.getQuantidadeEconomiasCategoria())));

		}

		// Retorna o consumo mínimo da ligação
		return resultadoTarifaMinimaAguaImovel;
	}

	/**
	 * Pesquisa a existencia de uma conta pelo id da conta e pela data da ultima
	 * alteracao
	 * 
	 * @param id
	 *            Descrição do parâmetro
	 * @param ultimaAlteracao
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public Integer pesquisarExistenciaContaParaConcorrencia(String idConta,
			String ultimaAlteracao) throws ControladorException {
		Integer retornoIdConta = null;
		try {
			retornoIdConta = repositorioFaturamento
					.pesquisarExistenciaContaParaConcorrencia(idConta,
							ultimaAlteracao);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retornoIdConta;
	}

	public Integer verificarExistenciaDebitoTipo(Integer idDebitoTipo)
			throws ControladorException {

		// Retorna o cliente encontrado ou vazio se não existir
		try {
			return repositorioFaturamento
					.verificarExistenciaDebitoTipo(idDebitoTipo);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * 
	 * [UC0410] - Inserir Tipo de Serviço
	 * 
	 * @author lms
	 * @date 01/08/2006
	 */
	public DebitoTipo pesquisarDebitoTipo(Integer idDebitoTipo)
			throws ControladorException {
		DebitoTipo debitoTipo = pesquisarDebitoTipo(idDebitoTipo.toString());
		if (debitoTipo == null) {
			throw new ControladorException("atencao.pesquisa_inexistente",
					null, "Tipo de Débito");
		}
		return debitoTipo;
	}

	/**
	 * 
	 * [UC0410] - Inserir Tipo de Serviço
	 * 
	 * @author lms
	 * @date 07/08/2006
	 */
	public CreditoTipo pesquisarCreditoTipo(Integer idCreditoTipo)
			throws ControladorException {
		CreditoTipo creditoTipo = null;
		FiltroCreditoTipo filtro = new FiltroCreditoTipo();
		filtro.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID,
				idCreditoTipo));
		filtro.adicionarParametro(new ParametroSimples(
				FiltroCreditoTipo.INDICADOR_USO,
				ConstantesSistema.INDICADOR_USO_ATIVO));
		Collection colecao = getControladorUtil().pesquisar(filtro,
				CreditoTipo.class.getName());
		if (colecao == null || colecao.isEmpty()) {
			throw new ControladorException("atencao.pesquisa_inexistente",
					null, "Crédito Tipo");
		} else {
			creditoTipo = (CreditoTipo) colecao.iterator().next();
		}
		return creditoTipo;
	}

	/**
	 * Consulta os dados da conta
	 * 
	 * @param idConta
	 *            Id da Conta
	 * @author Fernanda Paiva
	 * @date 04/09/2006
	 * 
	 * @return uma colecao de conta
	 */
	public Collection consultarConta(Integer idConta)
			throws ControladorException {

		Collection colecaoConta = null;
		Collection contas = null;
		// Pesquisa conta
		try {
			colecaoConta = repositorioFaturamento.consultarConta(idConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe conta
		if (colecaoConta != null && !colecaoConta.isEmpty()) {

			Iterator iteratorColecaoConta = colecaoConta.iterator();
			Conta conta = null;
			contas = new ArrayList();
			while (iteratorColecaoConta.hasNext()) {

				Object[] arrayConta = (Object[]) iteratorColecaoConta.next();

				conta = new Conta();
				// id do imovel - Item [0]
				if (arrayConta[0] != null) {
					Imovel imovel = new Imovel();
					imovel.setId((Integer) arrayConta[0]);
					conta.setImovel(imovel);
				}

				// referencia da conta - Item [1]
				if (arrayConta[1] != null) {
					conta.setReferencia((Integer) arrayConta[1]);
				}

				// debito credito situação atual - Item [2]
				if (arrayConta[2] != null) {
					conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) arrayConta[2]);
				}

				// ligação de água - Item 3
				if (arrayConta[3] != null) {
					conta.setLigacaoAguaSituacao((LigacaoAguaSituacao) arrayConta[3]);
				}
				// ligacao de esgoto - Item [4]
				if (arrayConta[4] != null) {

					conta.setLigacaoEsgotoSituacao((LigacaoEsgotoSituacao) arrayConta[4]);
				}
				// indicador de cobranca de multa - item [5]
				if (arrayConta[5] != null) {
					conta.setIndicadorCobrancaMulta(((Short) arrayConta[5])
							.shortValue());
				}
				// indicador de alteracao de vencimento - item [6]
				if (arrayConta[6] != null) {
					conta.setIndicadorAlteracaoVencimento((Short) arrayConta[6]);
				}
				// consumo de agua - item [7]
				if (arrayConta[7] != null) {
					conta.setConsumoAgua((Integer) arrayConta[7]);
				}
				// consumo de esgoto - item [8]
				if (arrayConta[8] != null) {
					conta.setConsumoEsgoto((Integer) arrayConta[8]);
				}
				// percentual esgoto - item [9]
				if (arrayConta[9] != null) {
					conta.setPercentualEsgoto((BigDecimal) arrayConta[9]);
				}
				// Valor Agua - item [10]
				if (arrayConta[10] != null) {
					conta.setValorAgua((BigDecimal) arrayConta[10]);
				}
				// Valor Esgoto - item [11]
				if (arrayConta[11] != null) {
					conta.setValorEsgoto((BigDecimal) arrayConta[11]);
				}
				// Debitos - item [12]
				if (arrayConta[12] != null) {
					conta.setDebitos((BigDecimal) arrayConta[12]);
				}
				// valorCreditos - item [13]
				if (arrayConta[13] != null) {
					conta.setValorCreditos((BigDecimal) arrayConta[13]);
				}
				// indicador debito conta - item [14]
				if (arrayConta[14] != null) {
					conta.setIndicadorDebitoConta(((Short) arrayConta[14])
							.shortValue());
				}

				// id conta - item [15]
				if (arrayConta[15] != null) {
					conta.setId((Integer) arrayConta[15]);
				}
				// data vencimento conta - item [16]
				if (arrayConta[16] != null) {
					conta.setDataVencimentoConta((Date) arrayConta[16]);
				}
				// data validade conta - item [17]
				if (arrayConta[17] != null) {
					conta.setDataValidadeConta((Date) arrayConta[17]);
				}
				// data inclusao conta - item [18]
				if (arrayConta[18] != null) {
					conta.setDataInclusao((Date) arrayConta[18]);
				}
				// data retificacao conta - item [19]
				if (arrayConta[19] != null) {
					conta.setDataRetificacao((Date) arrayConta[19]);
				}
				// data cancelamento conta - item [20]
				if (arrayConta[20] != null) {
					conta.setDataCancelamento((Date) arrayConta[20]);
				}
				// data revisao conta - item [21]
				if (arrayConta[21] != null) {
					conta.setDataRevisao((Date) arrayConta[21]);
				}

				// motivo nao entrega documento - item [22]
				if (arrayConta[22] != null) {

					MotivoNaoEntregaDocumento motivoNaoEntregaDocumento = new MotivoNaoEntregaDocumento();

					motivoNaoEntregaDocumento.setId((Integer) arrayConta[22]);
					motivoNaoEntregaDocumento
							.setMotivoNaoeEntregaDocumento((String) arrayConta[23]);
					motivoNaoEntregaDocumento
							.setAbreviado((String) arrayConta[24]);
					motivoNaoEntregaDocumento
							.setIndicadorUso((Short) arrayConta[25]);
					motivoNaoEntregaDocumento
							.setUltimaAlteracao((Date) arrayConta[26]);

					conta.setMotivoNaoEntregaDocumento(motivoNaoEntregaDocumento);
				}

				// contaMotivoInclusao - item [27]
				if (arrayConta[27] != null) {

					ContaMotivoInclusao contaMotivoInclusao = new ContaMotivoInclusao();

					contaMotivoInclusao.setId((Integer) arrayConta[27]);
					contaMotivoInclusao
							.setDescricaoMotivoInclusaoConta((String) arrayConta[28]);
					contaMotivoInclusao.setIndicadorUso((Short) arrayConta[29]);
					contaMotivoInclusao
							.setUltimaAlteracao((Date) arrayConta[30]);

					conta.setContaMotivoInclusao(contaMotivoInclusao);
				}

				// contaMotivoRetificacao - item [31]
				if (arrayConta[31] != null) {

					ContaMotivoRetificacao contaMotivoRetificacao = new ContaMotivoRetificacao();

					contaMotivoRetificacao.setId((Integer) arrayConta[31]);
					contaMotivoRetificacao
							.setDescricao((String) arrayConta[32]);
					contaMotivoRetificacao
							.setIndicadorUso((Short) arrayConta[33]);
					contaMotivoRetificacao
							.setUltimaAlteracao((Date) arrayConta[34]);

					conta.setContaMotivoRetificacao(contaMotivoRetificacao);
				}

				// contaMotivoCancelamento - item [35]
				if (arrayConta[35] != null) {

					ContaMotivoCancelamento contaMotivoCancelamento = new ContaMotivoCancelamento();

					contaMotivoCancelamento.setId((Integer) arrayConta[35]);
					contaMotivoCancelamento
							.setDescricaoMotivoCancelamentoConta((String) arrayConta[36]);
					contaMotivoCancelamento
							.setIndicadorUso((Short) arrayConta[37]);
					contaMotivoCancelamento
							.setUltimaAlteracao((Date) arrayConta[38]);

					conta.setContaMotivoCancelamento(contaMotivoCancelamento);
				}

				// contaMotivoRevisao - item [39]
				if (arrayConta[39] != null) {

					ContaMotivoRevisao contaMotivoRevisao = new ContaMotivoRevisao();

					contaMotivoRevisao.setId((Integer) arrayConta[39]);
					contaMotivoRevisao
							.setDescricaoMotivoRevisaoConta((String) arrayConta[40]);
					contaMotivoRevisao.setIndicadorUso((Short) arrayConta[41]);
					contaMotivoRevisao
							.setUltimaAlteracao((Date) arrayConta[42]);

					conta.setContaMotivoRevisao(contaMotivoRevisao);
				}

				// CONTA_ORIGEM
				if (arrayConta[43] != null) {

					ContaGeral contaGeralOrigem = new ContaGeral();
					contaGeralOrigem.setId((Integer) arrayConta[43]);

					Conta contaOrigem = new Conta();
					contaOrigem.setId((Integer) arrayConta[43]);

					Imovel imovelOrigem = new Imovel();
					imovelOrigem.setId((Integer) arrayConta[44]);

					contaOrigem.setImovel(imovelOrigem);
					contaGeralOrigem.setConta(contaOrigem);

					conta.setOrigem(contaGeralOrigem);

				} else {
					if (arrayConta[47] != null) {

						ContaGeral contaGeralOrigem = new ContaGeral();
						contaGeralOrigem.setId((Integer) arrayConta[47]);

						Conta contaOrigem = new Conta();
						contaOrigem.setId((Integer) arrayConta[47]);

						Imovel imovelOrigem = new Imovel();
						imovelOrigem.setId((Integer) arrayConta[48]);

						contaOrigem.setImovel(imovelOrigem);
						contaGeralOrigem.setConta(contaOrigem);

						conta.setOrigem(contaGeralOrigem);

					}
				}

				// Referencia Contabil
				if (arrayConta[45] != null) {
					conta.setReferenciaContabil((Integer) arrayConta[45]);
				}
				// Referencia Baixa Contabil
				if (arrayConta[46] != null) {
					conta.setReferenciaBaixaContabil((Integer) arrayConta[46]);
				}

				// Usuário
				if (arrayConta[49] != null) {
					Usuario usuario = new Usuario();
					usuario.setNomeUsuario((String) arrayConta[49]);
					conta.setUsuario(usuario);
				}

				// Valor dos impostos
				if (arrayConta[50] != null) {

					conta.setValorImposto((BigDecimal) arrayConta[50]);
				}

				// Ultima alteração
				if (arrayConta[51] != null) {

					conta.setUltimaAlteracao((Date) arrayConta[51]);
				}

				// Valor Rateio agua
				if (arrayConta[52] != null) {
					conta.setValorRateioAgua((BigDecimal) arrayConta[52]);
				}else{
					conta.setValorRateioAgua(new BigDecimal("0.00"));
				}

				// Valor Rateio Esgoto
				if (arrayConta[53] != null) {
					conta.setValorRateioEsgoto((BigDecimal) arrayConta[53]);
				}else{
					conta.setValorRateioEsgoto(new BigDecimal("0.00"));
				}

				contas.add(conta);
			}
		}

		return contas;
	}
	
	/**
	 * Consulta os dados da conta
	 * 
	 * @param idConta
	 *            Id da Conta
	 * 
	 * @return uma colecao de conta
	 */
	public Collection consultarContaHistorico(Integer idConta)
			throws ControladorException {

		Collection colecaoConta = null;
		Collection contas = null;
		// Pesquisa conta
		try {
			colecaoConta = repositorioFaturamento.consultarContaHistorico(idConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe conta
		if (colecaoConta != null && !colecaoConta.isEmpty()) {

			Iterator iteratorColecaoConta = colecaoConta.iterator();
			ContaHistorico contaHistorico = null;
			contas = new ArrayList();
			while (iteratorColecaoConta.hasNext()) {

				Object[] arrayConta = (Object[]) iteratorColecaoConta.next();

				contaHistorico = new ContaHistorico();
				// id do imovel - Item [0]
				if (arrayConta[0] != null) {
					Imovel imovel = new Imovel();
					imovel.setId((Integer) arrayConta[0]);
					contaHistorico.setImovel(imovel);
				}

				// referencia da conta - Item [1]
				if (arrayConta[1] != null) {
					contaHistorico.setReferencia((Integer) arrayConta[1]);
				}

				// debito credito situaï¿½ï¿½o atual - Item [2]
				if (arrayConta[2] != null) {
					contaHistorico.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) arrayConta[2]);
				}

				// ligaï¿½ï¿½o de ï¿½gua - Item 3
				if (arrayConta[3] != null) {
					contaHistorico.setLigacaoAguaSituacao((LigacaoAguaSituacao) arrayConta[3]);
				}
				// ligacao de esgoto - Item [4]
				if (arrayConta[4] != null) {

					contaHistorico.setLigacaoEsgotoSituacao((LigacaoEsgotoSituacao) arrayConta[4]);
				}
				// indicador de cobranca de multa - item [5]
				if (arrayConta[5] != null) {
					contaHistorico.setIndicadorCobrancaMulta(((Short) arrayConta[5])
							.shortValue());
				}
				// indicador de alteracao de vencimento - item [6]
				if (arrayConta[6] != null) {
					contaHistorico.setIndicadorAlteracaoVencimento((Short) arrayConta[6]);
				}
				// consumo de agua - item [7]
				if (arrayConta[7] != null) {
					contaHistorico.setConsumoAgua((Integer) arrayConta[7]);
				}
				// consumo de esgoto - item [8]
				if (arrayConta[8] != null) {
					contaHistorico.setConsumoEsgoto((Integer) arrayConta[8]);
				}
				// percentual esgoto - item [9]
				if (arrayConta[9] != null) {
					contaHistorico.setPercentualEsgoto((BigDecimal) arrayConta[9]);
				}
				// Valor Agua - item [10]
				if (arrayConta[10] != null) {
					contaHistorico.setValorAgua((BigDecimal) arrayConta[10]);
				}
				// Valor Esgoto - item [11]
				if (arrayConta[11] != null) {
					contaHistorico.setValorEsgoto((BigDecimal) arrayConta[11]);
				}
				// Debitos - item [12]
				if (arrayConta[12] != null) {
					contaHistorico.setDebitos((BigDecimal) arrayConta[12]);
				}
				// valorCreditos - item [13]
				if (arrayConta[13] != null) {
					contaHistorico.setValorCreditos((BigDecimal) arrayConta[13]);
				}
				// indicador debito conta - item [14]
				if (arrayConta[14] != null) {
					contaHistorico.setIndicadorDebitoConta(((Short) arrayConta[14])
							.shortValue());
				}

				// id conta - item [15]
				if (arrayConta[15] != null) {
					contaHistorico.setId((Integer) arrayConta[15]);
				}
				// data vencimento conta - item [16]
				if (arrayConta[16] != null) {
					contaHistorico.setDataVencimentoConta((Date) arrayConta[16]);
				}
				// data validade conta - item [17]
				if (arrayConta[17] != null) {
					contaHistorico.setDataValidadeConta((Date) arrayConta[17]);
				}
				// data inclusao conta - item [18]
				if (arrayConta[18] != null) {
					contaHistorico.setDataInclusao((Date) arrayConta[18]);
				}
				// data retificacao conta - item [19]
				if (arrayConta[19] != null) {
					contaHistorico.setDataRetificacao((Date) arrayConta[19]);
				}
				// data cancelamento conta - item [20]
				if (arrayConta[20] != null) {
					contaHistorico.setDataCancelamento((Date) arrayConta[20]);
				}
				// data revisao conta - item [21]
				if (arrayConta[21] != null) {
					contaHistorico.setDataRevisao((Date) arrayConta[21]);
				}

				// motivo nao entrega documento - item [22]
				if (arrayConta[22] != null) {

					MotivoNaoEntregaDocumento motivoNaoEntregaDocumento = new MotivoNaoEntregaDocumento();

					motivoNaoEntregaDocumento.setId((Integer) arrayConta[22]);
					motivoNaoEntregaDocumento
							.setMotivoNaoeEntregaDocumento((String) arrayConta[23]);
					motivoNaoEntregaDocumento
							.setAbreviado((String) arrayConta[24]);
					motivoNaoEntregaDocumento
							.setIndicadorUso((Short) arrayConta[25]);
					motivoNaoEntregaDocumento
							.setUltimaAlteracao((Date) arrayConta[26]);

					contaHistorico.setMotivoNaoEntregaDocumento(motivoNaoEntregaDocumento);
				}

				// contaMotivoInclusao - item [27]
				if (arrayConta[27] != null) {

					ContaMotivoInclusao contaMotivoInclusao = new ContaMotivoInclusao();

					contaMotivoInclusao.setId((Integer) arrayConta[27]);
					contaMotivoInclusao
							.setDescricaoMotivoInclusaoConta((String) arrayConta[28]);
					contaMotivoInclusao.setIndicadorUso((Short) arrayConta[29]);
					contaMotivoInclusao
							.setUltimaAlteracao((Date) arrayConta[30]);

					contaHistorico.setContaMotivoInclusao(contaMotivoInclusao);
				}

				// contaMotivoRetificacao - item [31]
				if (arrayConta[31] != null) {

					ContaMotivoRetificacao contaMotivoRetificacao = new ContaMotivoRetificacao();

					contaMotivoRetificacao.setId((Integer) arrayConta[31]);
					contaMotivoRetificacao
							.setDescricao((String) arrayConta[32]);
					contaMotivoRetificacao
							.setIndicadorUso((Short) arrayConta[33]);
					contaMotivoRetificacao
							.setUltimaAlteracao((Date) arrayConta[34]);

					contaHistorico.setContaMotivoRetificacao(contaMotivoRetificacao);
				}

				// contaMotivoCancelamento - item [35]
				if (arrayConta[35] != null) {

					ContaMotivoCancelamento contaMotivoCancelamento = new ContaMotivoCancelamento();

					contaMotivoCancelamento.setId((Integer) arrayConta[35]);
					contaMotivoCancelamento
							.setDescricaoMotivoCancelamentoConta((String) arrayConta[36]);
					contaMotivoCancelamento
							.setIndicadorUso((Short) arrayConta[37]);
					contaMotivoCancelamento
							.setUltimaAlteracao((Date) arrayConta[38]);

					contaHistorico.setContaMotivoCancelamento(contaMotivoCancelamento);
				}

				// contaMotivoRevisao - item [39]
				if (arrayConta[39] != null) {

					ContaMotivoRevisao contaMotivoRevisao = new ContaMotivoRevisao();

					contaMotivoRevisao.setId((Integer) arrayConta[39]);
					contaMotivoRevisao
							.setDescricaoMotivoRevisaoConta((String) arrayConta[40]);
					contaMotivoRevisao.setIndicadorUso((Short) arrayConta[41]);
					contaMotivoRevisao
							.setUltimaAlteracao((Date) arrayConta[42]);

					contaHistorico.setContaMotivoRevisao(contaMotivoRevisao);
				}

				// CONTA_ORIGEM
				if (arrayConta[43] != null) {

					ContaGeral contaGeralOrigem = new ContaGeral();
					contaGeralOrigem.setId((Integer) arrayConta[43]);

					Conta contaOrigem = new Conta();
					contaOrigem.setId((Integer) arrayConta[43]);

					Imovel imovelOrigem = new Imovel();
					imovelOrigem.setId((Integer) arrayConta[44]);

					contaOrigem.setImovel(imovelOrigem);
					contaGeralOrigem.setConta(contaOrigem);

					contaHistorico.setOrigem(contaGeralOrigem);

				} else {
					if (arrayConta[47] != null) {

						ContaGeral contaGeralOrigem = new ContaGeral();
						contaGeralOrigem.setId((Integer) arrayConta[47]);

						Conta contaOrigem = new Conta();
						contaOrigem.setId((Integer) arrayConta[47]);

						Imovel imovelOrigem = new Imovel();
						imovelOrigem.setId((Integer) arrayConta[48]);

						contaOrigem.setImovel(imovelOrigem);
						contaGeralOrigem.setConta(contaOrigem);

						contaHistorico.setOrigem(contaGeralOrigem);

					}
				}

				// Referencia Contabil
				if (arrayConta[45] != null) {
					contaHistorico.setAnoMesReferenciaContabil((Integer) arrayConta[45]);
				}
				// Referencia Baixa Contabil
				if (arrayConta[46] != null) {
					contaHistorico.setAnoMesReferenciaBaixaContabil((Integer) arrayConta[46]);
				}

				// Usuario
				if (arrayConta[49] != null) {
					Usuario usuario = new Usuario();
					usuario.setNomeUsuario((String) arrayConta[49]);

					contaHistorico.setUsuario(usuario);
				}

				// Valor dos impostos
				if (arrayConta[50] != null) {

					contaHistorico.setValorImposto((BigDecimal) arrayConta[50]);
				}

				// Ultima alteracao
				if (arrayConta[51] != null) {

					contaHistorico.setUltimaAlteracao((Date) arrayConta[51]);
				}

				// Valor Rateio Agua
				if (arrayConta[52] != null) {
					contaHistorico.setValorRateioAgua((BigDecimal) arrayConta[52]);
				}else{
					contaHistorico.setValorRateioAgua(new BigDecimal("0.00"));
				}
				
				// Valor Rateio Esgoto
				if (arrayConta[53] != null) {
					contaHistorico.setValorRateioEsgoto((BigDecimal) arrayConta[53]);
				}else{
					contaHistorico.setValorRateioEsgoto(new BigDecimal("0.00"));
				}

				contas.add(contaHistorico);
			}
		}

		return contas;
	}	

	
	
	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Pedro Alexandre
	 * @date 19/09/2006
	 * 
	 * @param idConta
	 * @return
	 * @throws ControladorException
	 */
	public BigDecimal pesquisarValorMultasCobradas(int idConta)
			throws ControladorException {

		BigDecimal valorMultasCobradas = null;

		try {
			valorMultasCobradas = repositorioFaturamento
					.pesquisarValorMultasCobradas(idConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return valorMultasCobradas;
	}

	/**
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa, Mariana Victor
	 * @date 15/09/2006, 11/03/2011
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Collection<EmitirContaHelper> emitir2ViaContas(
			Collection idsContaEP, boolean cobrarTaxaEmissaoConta,
			Short contaSemCodigoBarras) throws ControladorException {

		Collection<EmitirContaHelper> colecaoEmitirContaHelper = new ArrayList();

		Iterator iter = idsContaEP.iterator();

		while (iter.hasNext()) {
			Integer idContaEP = (Integer) iter.next();

			Collection colectionConta;
			try {
				colectionConta = this.repositorioFaturamento
						.pesquisarConta(idContaEP);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) colectionConta
					.iterator().next();

			SistemaParametro sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			String nomeCliente = "";

			/*
			 * Adicionado por: Mariana Victor Data: 11/03/2011
			 */

			if (emitirContaHelper.getNomeImovel() != null
					&& !emitirContaHelper.getNomeImovel().equals("")) {

				emitirContaHelper.setNomeCliente(emitirContaHelper
						.getNomeImovel());
			} else {

				if (emitirContaHelper.getIdConta() != null
						&& !emitirContaHelper.getIdConta().equals("")) {
					nomeCliente = this.obterNomeCliente(emitirContaHelper
							.getIdConta());
					emitirContaHelper.setNomeCliente(nomeCliente);
				}

			}

			// Linha 5
			// --------------------------------------------------------------
			// recupera endereco do imóvel
			String enderecoImovel = "";
			try {
				enderecoImovel = getControladorEndereco()
						.pesquisarEnderecoFormatado(
								emitirContaHelper.getIdImovel());
			} catch (ControladorException e1) {
				e1.printStackTrace();
			}
			emitirContaHelper.setEnderecoImovel(enderecoImovel);

			// Linha 6
			// --------------------------------------------------------------
			// instância um imovel com os dados da conta para recuperar a
			// inscrição que está no objeto imovel
			Imovel imovel = new Imovel();
			Localidade localidade = new Localidade();
			localidade.setId(emitirContaHelper.getIdLocalidade());
			imovel.setLocalidade(localidade);
			SetorComercial setorComercial = new SetorComercial();
			setorComercial.setCodigo(emitirContaHelper
					.getCodigoSetorComercialConta());
			imovel.setSetorComercial(setorComercial);
			Quadra quadra = new Quadra();
			quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
			imovel.setQuadra(quadra);
			imovel.setLote(emitirContaHelper.getLoteConta());
			imovel.setSubLote(emitirContaHelper.getSubLoteConta());
			// Inscrição do imóvel
			emitirContaHelper
					.setInscricaoImovel(imovel.getInscricaoFormatada());

			// Linha 7
			// --------------------------------------------------------------
			String idClienteResponsavel = "";
			String enderecoClienteResponsavel = "";
			Integer idImovelContaEnvio = emitirContaHelper
					.getIdImovelContaEnvio();
			// caso a coleção de contas seja de entrega para o cliente
			// responsável
			if (idImovelContaEnvio != null
					&& (idImovelContaEnvio
							.equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL) || idImovelContaEnvio
							.equals(ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL))) {

				Integer idClienteResponsavelInteger = null;
				idClienteResponsavelInteger = pesquisarIdClienteResponsavelConta(
						emitirContaHelper.getIdConta(), false);

				if (idClienteResponsavelInteger != null
						&& !idClienteResponsavelInteger.equals("")) {
					idClienteResponsavel = idClienteResponsavelInteger
							.toString();
					// [UC0085]Obter Endereco
					enderecoClienteResponsavel = getControladorEndereco()
							.pesquisarEnderecoClienteAbreviado(
									idClienteResponsavelInteger);
				}

			}
			emitirContaHelper.setIdClienteResponsavel(idClienteResponsavel);
			emitirContaHelper
					.setEnderecoClienteResponsavel(enderecoClienteResponsavel);

			// Linha 8
			// --------------------------------------------------------------

			// [SB0002] - Determinar tipo de ligação e tipo de Medição
			Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
			Integer tipoLigacao = parmSituacao[0];
			Integer tipoMedicao = parmSituacao[1];

			// Linha 9
			// --------------------------------------------------------------
			// cria uma stringBuilder para recuperar o resultado do [SB0003]
			// o tamanho da string que vem como resultado é de 20 posições
			StringBuilder obterDadosConsumoMedicaoAnterior = null;

			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 1
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 1, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes1(obterDadosConsumoMedicaoAnterior
							.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 4
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 4, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes4(obterDadosConsumoMedicaoAnterior
							.toString());

			// Linha 10
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 2
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 2, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes2(obterDadosConsumoMedicaoAnterior
							.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 5
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 5, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes5(obterDadosConsumoMedicaoAnterior
							.toString());
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros da medição historico do
			// [SB0004] - Obter Dados da Medição da Conta
			Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(
					emitirContaHelper, tipoMedicao);
			// Leitura Anterior
			String leituraAnterior = "";
			// Leitura Atual
			String leituraAtual = "";
			// Data Leitura Anterior
			String dataLeituraAnterior = "";
			// Leitura Anterior
			String dataLeituraAtual = "";
			// Leitura Situação Atual
			// String leituraSituacaoAtual = "";
			// Leitura Anormalidade Faturamento
			String leituraAnormalidadeFaturamento = "";
			if (parmsMedicaoHistorico != null) {

				if (parmsMedicaoHistorico[0] != null) {
					leituraAnterior = "" + (Integer) parmsMedicaoHistorico[0];
				}

				if (parmsMedicaoHistorico[1] != null) {
					leituraAtual = "" + (Integer) parmsMedicaoHistorico[1];
				}

				if (parmsMedicaoHistorico[3] != null) {
					dataLeituraAnterior = Util
							.formatarData((Date) parmsMedicaoHistorico[3]);
				}

				if (parmsMedicaoHistorico[2] != null) {
					dataLeituraAtual = Util
							.formatarData((Date) parmsMedicaoHistorico[2]);
				}

				if (parmsMedicaoHistorico[4] != null) {
					// leituraSituacaoAtual = ""
					// + (Integer) parmsMedicaoHistorico[4];
				}

				if (parmsMedicaoHistorico[5] != null) {
					leituraAnormalidadeFaturamento = ""
							+ (Integer) parmsMedicaoHistorico[5];
				}
			}
			emitirContaHelper.setDataLeituraAnterior(dataLeituraAnterior);
			emitirContaHelper.setDataLeituraAtual(dataLeituraAtual);
			String diasConsumo = "";
			if (!dataLeituraAnterior.equals("") && !dataLeituraAtual.equals("")) {
				// calcula a quantidade de dias de consumo que é a
				// quantidade de dias
				// entre a data de leitura
				// anterior(parmsMedicaoHistorico[2]) e a data de leitura
				// atual(parmsMedicaoHistorico[3])
				diasConsumo = ""
						+ Util.obterQuantidadeDiasEntreDuasDatas(
								(Date) parmsMedicaoHistorico[3],
								(Date) parmsMedicaoHistorico[2]);
			}
			// recupera os parametros de consumo faturamento e consumo médio
			// diário
			// [SB0005] - Obter Consumo Faturado e Consumo Médio Diário
			String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(
					emitirContaHelper, tipoMedicao, diasConsumo);
			String consumoFaturamento = parmsConsumo[0];
			emitirContaHelper.setConsumoFaturamento(consumoFaturamento);

			String consumoMedioDiario = parmsConsumo[1];
			emitirContaHelper.setConsumoMedioDiario(consumoMedioDiario);
			// Fim Chamar Sub-Fluxo
			// Leitura Anterior
			leituraAnterior = Util.completaString(leituraAnterior, 7);
			emitirContaHelper.setLeituraAnterior(leituraAnterior);
			// Leitura Atual
			leituraAtual = Util.completaString(leituraAtual, 7);
			emitirContaHelper.setLeituraAtual(leituraAtual);
			// Dias de consumo
			diasConsumo = Util.completaString(diasConsumo, 2);
			emitirContaHelper.setDiasConsumo(diasConsumo);

			// Linha 11
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 3
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 3, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes3(obterDadosConsumoMedicaoAnterior
							.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 6
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 6, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes6(obterDadosConsumoMedicaoAnterior
							.toString());

			// Linha 12
			// --------------------------------------------------------------
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros do consumo historico da conta
			// [SB0006] - Obter Dados de Consumo da Conta
			Object[] parmsConsumoHistorico = null;
			String descricaoAbreviadaTipoConsumo = "";
			String descricaoTipoConsumo = "";
			String consumoMedio = "";
			String descricaoAbreviadaAnormalidadeConsumo = "";
			String descricaoAnormalidadeConsumo = "";
			String consumoRateio = "";
			// caso o tipo de ligacao for diferente de nulo
			if (tipoLigacao != null) {
				try {
					parmsConsumoHistorico = getControladorMicromedicao()
							.obterDadosConsumoConta(
									emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia(),
									tipoLigacao);
				} catch (ControladorException e) {
					e.printStackTrace();
				}

				if (parmsConsumoHistorico != null) {
					// descrição abreviada tipo de consumo
					if (parmsConsumoHistorico[0] != null) {
						descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
					}
					// descrição tipo de consumo
					if (parmsConsumoHistorico[1] != null) {
						descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
					}
					// Consumo médio
					if (parmsConsumoHistorico[2] != null) {
						consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
					}
					// descrição abreviada anormalidade de consumo
					if (parmsConsumoHistorico[3] != null) {
						descricaoAbreviadaAnormalidadeConsumo = (String) parmsConsumoHistorico[3];
					}
					// descrição anormalidade de consumo
					if (parmsConsumoHistorico[4] != null) {
						descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
					}
					// Consumo médio
					if (parmsConsumoHistorico[5] != null) {
						consumoRateio = "" + (Integer) parmsConsumoHistorico[5];
					}
				}
			}

			// Consumo de rateio
			// transforma o consumoRateio para um bigDecimal
			BigDecimal consumoRateioBigDecimal = null;
			if (consumoRateio != null && !consumoRateio.equals("")) {
				consumoRateioBigDecimal = Util
						.formatarMoedaRealparaBigDecimal(consumoRateio);
			}

			emitirContaHelper.setDescricaoTipoConsumo(descricaoTipoConsumo);
			emitirContaHelper
					.setDescricaoAnormalidadeConsumo(descricaoAnormalidadeConsumo);

			// Fim Chamar Sub-Fluxo

			// Linha 13
			// --------------------------------------------------------------

			// Inicio Chamar Sub-Fluxo
			// soma a quantidades de economias da tabela contaCategoria
			// [SB0007] - Obter Dados da Medição da Conta
			Short quantidadeEconomiaConta = 0;
			quantidadeEconomiaConta = obterQuantidadeEconomiasConta(
					emitirContaHelper.getIdConta(), false);
			emitirContaHelper.setQuantidadeEconomiaConta(""
					+ quantidadeEconomiaConta);
			// Fim Chamar Sub-Fluxo

			// Consumo por Economia
			// transforma o consumoFaturamento para um bigDecimal
			BigDecimal consumoFaturadoBigDecimal = null;
			if (consumoFaturamento != null && !consumoFaturamento.equals("")) {
				consumoFaturadoBigDecimal = Util
						.formatarMoedaRealparaBigDecimal(consumoFaturamento);

			}
			// transforma a quantidade de economias da conta para um
			// bigDecimal
			BigDecimal qtdEconomiasBigDecimal = null;
			if (quantidadeEconomiaConta != null
					&& !quantidadeEconomiaConta.equals("")) {
				qtdEconomiasBigDecimal = Util
						.formatarMoedaRealparaBigDecimal(""
								+ quantidadeEconomiaConta);
			}
			String consumoEconomia = "";
			if (consumoFaturadoBigDecimal != null
					&& qtdEconomiasBigDecimal != null) {
				if (consumoRateioBigDecimal == null) {
					BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal
							.divide(qtdEconomiasBigDecimal, 2, RoundingMode.UP);
					consumoEconomia = Util
							.formatarMoedaReal(consumoEconomiaBigDecimal);
					emitirContaHelper.setConsumoEconomia(consumoEconomia
							.substring(0, (consumoEconomia.length() - 3)));
				} else {
					BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal
							.subtract(consumoRateioBigDecimal);
					consumoEconomiaBigDecimal = consumoEconomiaBigDecimal
							.divide(qtdEconomiasBigDecimal, 2, RoundingMode.UP);
					consumoEconomia = Util
							.formatarMoedaReal(consumoEconomiaBigDecimal);
					emitirContaHelper.setConsumoEconomia(consumoEconomia
							.substring(0, (consumoEconomia.length() - 3)));
				}
			}

			// Inicio Chamar Sub-Fluxo
			// concatena os campos dos sub-fluxos anteriores
			// [SB0008] - Obter Dados da Medição da Conta
			StringBuilder codigoAuxiliar = new StringBuilder();
			// leitura situação atual
			// tipo de consumo
			codigoAuxiliar.append(Util.completaString(
					descricaoAbreviadaTipoConsumo, 1));
			// tipo de contrato
			codigoAuxiliar.append(Util.completaString("", 1));
			// anormalidade de leitura
			codigoAuxiliar.append(Util.completaString(
					leituraAnormalidadeFaturamento, 2));
			// anormalidade de consumo
			codigoAuxiliar.append(Util.completaString(
					descricaoAbreviadaAnormalidadeConsumo, 2));

			// perfil do imóvel
			if (emitirContaHelper.getIdImovelPerfil() != null) {
				codigoAuxiliar.append(Util.completaString(""
						+ emitirContaHelper.getIdImovelPerfil(), 1));
			} else {
				codigoAuxiliar.append(Util.completaString("", 1));
			}
			// dias do consumo
			codigoAuxiliar.append(Util.completaString(diasConsumo, 2));
			// Consumo medio do imóvel
			codigoAuxiliar.append(Util.completaString(consumoMedio, 6));
			// Fim Chamar Sub-Fluxo
			emitirContaHelper
					.setCodigoAuxiliarString(codigoAuxiliar.toString());

			// chama o [SB0009] - Obter Mensagem de Rateio de Consumo Fixo
			// de Esgoto
			StringBuilder mesagemConsumo = obterMensagemRateioConsumo(
					emitirContaHelper, consumoRateio, parmsMedicaoHistorico,
					tipoMedicao);
			// mensagem de rateio de consumo ou consumo fixo de esgoto
			emitirContaHelper.setMensagemConsumoString(mesagemConsumo
					.toString());

			// Linha 16
			// --------------------------------------------------------------
			// chama o [SB0010] - Gerar Linhas da Descrição dos Serviços e
			// Tarifas

			Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = gerarLinhasDescricaoServicoTarifasRelatorio(
					emitirContaHelper, consumoRateio, parmsMedicaoHistorico,
					tipoMedicao, false);
			emitirContaHelper
					.setColecaoContaLinhasDescricaoServicosTarifasTotalHelper(colecaoContaLinhasDescricaoServicosTarifasTotalHelper);

			// Linha 17
			// --------------------------------------------------------------
			// cria um objeto conta para calcular o valor da conta
			Conta conta = new Conta();
			conta.setValorAgua(emitirContaHelper.getValorAgua());
			conta.setValorEsgoto(emitirContaHelper.getValorEsgoto());
			conta.setValorCreditos(emitirContaHelper.getValorCreditos());
			conta.setDebitos(emitirContaHelper.getDebitos());
			conta.setValorImposto(emitirContaHelper.getValorImpostos());
			BigDecimal valorConta = conta.getValorTotalContaBigDecimal();

			emitirContaHelper.setValorContaString(Util
					.formatarMoedaReal(valorConta));
			emitirContaHelper.setValorConta(valorConta);

			if (valorConta.compareTo(new BigDecimal("0.00")) == 0) {
				emitirContaHelper.setContaSemCodigoBarras("1");
			} else {
				emitirContaHelper.setContaSemCodigoBarras("2");
			}

			if (contaSemCodigoBarras.equals(ConstantesSistema.NAO)) {

				FiltroPagamento filtroPagamento = new FiltroPagamento();
				filtroPagamento.adicionarParametro(new ParametroSimples(
						FiltroPagamento.CONTA_ID, idContaEP));
				Collection colecaoPagamentos = Fachada.getInstancia()
						.pesquisar(filtroPagamento, Pagamento.class.getName());

				if (colecaoPagamentos != null && !colecaoPagamentos.isEmpty()) {

					emitirContaHelper.setContaSemCodigoBarras("1");
				}

			}
			/*
			 * if (idTarifaImovel == ImovelPerfil.TARIFA_SOCIAL.intValue() &&
			 * emitirContaHelper.getCpf() == null) {
			 * 
			 * //Linha 18 //
			 * --------------------------------------------------------------
			 * emitirContaHelper
			 * .setPrimeiraParte("SR(A)  CLIENTE,  FAVOR  COMPARECER   A   UM");
			 * 
			 * // Linha 19 //
			 * --------------------------------------------------------------
			 * emitirContaHelper
			 * .setSegundaParte("ATENDIMENTO AO CLIENTE PARA RECADASTRAMENTO");
			 * 
			 * // Linha 20 //
			 * --------------------------------------------------------------
			 * emitirContaHelper
			 * .setTerceiraParte("NA TARIFA SOCIAL, NO PRAZO DE 30 DIAS.");
			 * 
			 * }else{
			 */
			// chama o [SB0016] - Obter Mensagem da Conta em 3 Partes
			String[] parmsPartesConta = obterMensagemConta3Partes(
					emitirContaHelper, sistemaParametro);

			// Linha 18
			// --------------------------------------------------------------
			emitirContaHelper.setPrimeiraParte(parmsPartesConta[0]);

			// Linha 19
			// --------------------------------------------------------------
			emitirContaHelper.setSegundaParte(parmsPartesConta[1]);

			// Linha 20
			// --------------------------------------------------------------
			emitirContaHelper.setTerceiraParte(parmsPartesConta[2]);
			// }

			// Linha 21
			// --------------------------------------------------------------
			int anoMesReferenciaSubtraido = Util.subtrairMesDoAnoMes(
					emitirContaHelper.getAmReferencia(), 1);
			emitirContaHelper.setMesAnoFormatado(Util
					.formatarAnoMesParaMesAno(anoMesReferenciaSubtraido));

			// Linha 22
			// --------------------------------------------------------------
			Object[] parmsQualidadeAgua = null;
			parmsQualidadeAgua = pesquisarParmsQualidadeAgua(emitirContaHelper);

			// numero indice turbidez da qualidade agua
			String numeroIndiceTurbidez = "";
			// numero cloro residual da qualidade agua
			String numeroCloroResidual = "";
			if (parmsQualidadeAgua != null) {
				if (parmsQualidadeAgua[0] != null) {
					numeroIndiceTurbidez = Util
							.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]);
				}

				if (parmsQualidadeAgua[1] != null) {
					numeroCloroResidual = Util
							.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]);
				}
			}
			emitirContaHelper.setNumeroIndiceTurbidez(numeroIndiceTurbidez);
			emitirContaHelper.setNumeroCloroResidual(numeroCloroResidual);

			// Linha 23
			// --------------------------------------------------------------
			// Considerar as contas do tipo débito automático como tipo de conta
			// normal
			// [SB0018 - Gerar Linhas das DemaisContas]
			Integer digitoVerificadorConta = new Integer(""
					+ emitirContaHelper.getDigitoVerificadorConta());
			// formata ano mes para mes ano
			String anoMes = "" + emitirContaHelper.getAmReferencia();
			String mesAno = anoMes.substring(4, 6) + anoMes.substring(0, 4);

			String representacaoNumericaCodBarra = "";

			// Linha28
			Date dataValidade = obterDataValidade2ViaConta(emitirContaHelper);
			emitirContaHelper.setDataValidade(Util.formatarData(dataValidade));

			// Se valor da conta maior que o valor limite
			// emite uma Ficha de Compensação(Boleto bancario)
			if (valorConta
					.compareTo(EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO) == 1) {
				// representação numérica do código de barras
				// [SB0030 - Obter representação numérica do código de barras da
				// Ficha de Compensação]
				StringBuilder nossoNumero = obterNossoNumeroFichaCompensacao(
						"1", emitirContaHelper.getIdConta().toString());
				String nossoNumeroSemDV = nossoNumero.toString().substring(0,
						17);

				emitirContaHelper.setNossoNumero(nossoNumero.toString());

				Date dataVencimentoMais90 = Util.adicionarNumeroDiasDeUmaData(
						new Date(), 90);
				String fatorVencimento = CodigoBarras.obterFatorVencimento(dataVencimentoMais90);

				String especificacaoCodigoBarra = CodigoBarras.obterEspecificacaoCodigoBarraFichaCompensacao(
								ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO,
								ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO,
								emitirContaHelper.getValorConta(),
								nossoNumeroSemDV.toString(),
								ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO,
								fatorVencimento);

				emitirContaHelper
						.setRepresentacaoNumericaCodBarraSemDigito(especificacaoCodigoBarra);

				String representacaoNumericaCodigoBarraFichaCompensacao = CodigoBarras.obterRepresentacaoNumericaCodigoBarraFichaCompensacao(especificacaoCodigoBarra);

				emitirContaHelper
						.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodigoBarraFichaCompensacao);
			} else {
				if (valorConta.compareTo(new BigDecimal("0.00")) != 0) {

					representacaoNumericaCodBarra = this
							.getControladorArrecadacao()
							.obterRepresentacaoNumericaCodigoBarra(3,
									valorConta,
									emitirContaHelper.getIdLocalidade(),
									emitirContaHelper.getIdImovel(), mesAno,
									digitoVerificadorConta, null, null, null,
									null, null, null, null);

					// Linha 24
					// Formata a representação númerica do código de barras
					String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra
							.substring(0, 11)
							+ "-"
							+ representacaoNumericaCodBarra.substring(11, 12)
							+ " "
							+ representacaoNumericaCodBarra.substring(12, 23)
							+ "-"
							+ representacaoNumericaCodBarra.substring(23, 24)
							+ " "
							+ representacaoNumericaCodBarra.substring(24, 35)
							+ "-"
							+ representacaoNumericaCodBarra.substring(35, 36)
							+ " "
							+ representacaoNumericaCodBarra.substring(36, 47)
							+ "-"
							+ representacaoNumericaCodBarra.substring(47, 48);
					emitirContaHelper
							.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

					// Linha 25
					String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra
							.substring(0, 11)
							+ representacaoNumericaCodBarra.substring(12, 23)
							+ representacaoNumericaCodBarra.substring(24, 35)
							+ representacaoNumericaCodBarra.substring(36, 47);
					emitirContaHelper
							.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);

				}
			}

			colecaoEmitirContaHelper.add(emitirContaHelper);

			if (cobrarTaxaEmissaoConta) {
				this.gerarDebitoACobrarTaxaEmissaoConta(
						emitirContaHelper.getIdImovel(),
						emitirContaHelper.getAmReferencia());
			}

		}

		return colecaoEmitirContaHelper;
	}

	/**
	 * Recupera o id do cliente responsável pela conta
	 * 
	 * [UC0348] - Emitir Contas [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006 , 22/05/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Integer pesquisarIdClienteResponsavelConta(Integer idConta,
			boolean contaHistorico) throws ControladorException {

		try {
			if (!contaHistorico) {

				return repositorioFaturamento
						.pesquisarIdClienteResponsavelConta(idConta);
			} else {

				return repositorioFaturamento
						.pesquisarIdClienteResponsavelContaHistorico(idConta);
			}
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	public Short obterQuantidadeEconomiasConta(Integer idConta,
			boolean contaHistorico) throws ControladorException {

		try {
			if (!contaHistorico) {
				return repositorioFaturamento
						.obterQuantidadeEconomiasConta(idConta);
			} else {
				return repositorioFaturamento
						.obterQuantidadeEconomiasContaHistorico(idConta);
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	public Object[] pesquisarParmsQualidadeAgua(
			EmitirContaHelper emitirContaHelper) throws ControladorException {

		try {
			return repositorioFaturamento
					.pesquisarParmsQualidadeAgua(emitirContaHelper);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00020] Gerar Arquivo TXT das Cartas
	 * 
	 * @author Sávio Luiz
	 * @date 05/12/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder gerarArquivoTxtCartas(
			EmitirContaHelper emitirContaHelper, Integer sequencial,
			int situacao) throws ControladorException {

		StringBuilder linhasArquivoTxtCartas = new StringBuilder();

		// cria uma stringBuilder para recuperar o resultado
		// do
		// [SB0004]
		// o tamanho da string que vem como resultado é de
		// 20
		// posições
		StringBuilder obterDadosConsumoMedicaoAnterior = null;
		// Caso a situação da conta esteja na primeira parte(=1) e seja
		// diferente de 1
		if (sequencial != 1 && (situacao == 1)) {
			// gerar 2 linhas com canal 1
			// Canal
			linhasArquivoTxtCartas.append("1");
			linhasArquivoTxtCartas.append(Util.completaString("", 60));
			linhasArquivoTxtCartas.append(System.getProperty("line.separator"));
			// Canal
			linhasArquivoTxtCartas.append("1");
			linhasArquivoTxtCartas.append(Util.completaString("", 60));
			linhasArquivoTxtCartas.append(System.getProperty("line.separator"));
		}

		// --Linha 1-- //
		// Canal
		linhasArquivoTxtCartas.append("1");
		// mes/ano referencia e o digito verificador
		String formatarMesAnoComDigito = Util
				.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia())
				+ "-" + emitirContaHelper.getDigitoVerificadorConta();
		linhasArquivoTxtCartas.append(Util.completaString(
				formatarMesAnoComDigito, 35));

		// matricula do imóvel
		// Recupera a matrícula do imóvel da coluna 1 e
		// formata
		// a
		// matrícula
		// (ex:500000001 em 5000000.1)
		String matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(9,
				"" + emitirContaHelper.getIdImovel());
		matriculaImovelFormatada = matriculaImovelFormatada.substring(0, 8)
				+ "." + matriculaImovelFormatada.substring(8, 9);
		linhasArquivoTxtCartas.append(Util.completaString(
				matriculaImovelFormatada, 25));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));
		// --Linha 2-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// mes/ano referencia e o digito verificador
		// instância um imovel com os dados da conta para
		// recuperar
		// a
		// inscrição que está np objeto imovel
		Imovel imovel = new Imovel();
		Localidade localidade = new Localidade();
		localidade.setId(emitirContaHelper.getIdLocalidade());
		imovel.setLocalidade(localidade);
		SetorComercial setorComercial = new SetorComercial();
		setorComercial.setCodigo(emitirContaHelper
				.getCodigoSetorComercialConta());
		imovel.setSetorComercial(setorComercial);
		Quadra quadra = new Quadra();
		quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
		imovel.setQuadra(quadra);
		imovel.setLote(emitirContaHelper.getLoteConta());
		imovel.setSubLote(emitirContaHelper.getSubLoteConta());
		// Inscrição do imóvel
		String inscricao = imovel.getInscricaoFormatada();

		imovel = null;
		localidade = null;
		setorComercial = null;
		quadra = null;
		linhasArquivoTxtCartas.append(Util.completaString(inscricao, 60));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 3-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		linhasArquivoTxtCartas.append(Util.completaString(
				emitirContaHelper.getNomeCliente(), 60));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 4-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// [UC0085]Obter Endereco
		String enderecoImovel = getControladorEndereco()
				.pesquisarEnderecoFormatado(emitirContaHelper.getIdImovel());
		linhasArquivoTxtCartas.append(Util.completaString(enderecoImovel, 60));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 5-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 3));

		Object[] parmsClienteResponsavel = null;
		try {
			parmsClienteResponsavel = repositorioFaturamento
					.pesquisarParmsClienteResponsavelConta(emitirContaHelper
							.getIdConta());

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		Integer idClienteResponsavel = null;
		String nomeClienteResponsavel = "";
		String codigoCliente = "";
		if (parmsClienteResponsavel != null) {

			if (parmsClienteResponsavel[0] != null) {
				idClienteResponsavel = (Integer) parmsClienteResponsavel[0];
			}
			if (parmsClienteResponsavel[1] != null) {
				nomeClienteResponsavel = (String) parmsClienteResponsavel[1];
			}

			if (idClienteResponsavel != null) {
				codigoCliente = idClienteResponsavel.toString();
				// formata o valor de 12345 para 1234.5
				codigoCliente = codigoCliente
						.substring(0, codigoCliente.length() - 1)
						.concat(".")
						.concat(codigoCliente.substring(
								codigoCliente.length() - 1,
								codigoCliente.length()));
			}
		}
		// seta o id do cliente responsável
		linhasArquivoTxtCartas.append(Util.completaString(codigoCliente, 12));

		linhasArquivoTxtCartas.append(Util.completaString(
				nomeClienteResponsavel, 45));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 6-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 3));
		if (idClienteResponsavel != null) {
			// [UC0085]Obter Endereco
			String enderecoClienteResponsavel = getControladorEndereco()
					.pesquisarEnderecoClienteAbreviado(idClienteResponsavel);
			if (enderecoClienteResponsavel != null) {
				// endereco cliente responsável
				linhasArquivoTxtCartas.append(Util.completaString(
						enderecoClienteResponsavel, 57));
			} else {
				// endereco cliente responsável
				linhasArquivoTxtCartas.append(Util.completaString("", 57));
			}

		} else {
			// completa com espaços em branco
			linhasArquivoTxtCartas.append(Util.completaString("", 57));
		}
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 7-- //
		// Canal
		linhasArquivoTxtCartas.append("1");

		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 5));
		// [SB0002] - Determinar tipo de ligação e tipo de
		// Medição
		Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
		Integer tipoLigacao = parmSituacao[1];
		Integer tipoMedicao = parmSituacao[1];

		// recupera os parametros da medição historico do
		// [SB0005] - Obter Dados da Medição da Conta
		Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(
				emitirContaHelper, tipoMedicao);
		// Leitura Atual
		String leituraAtual = "";
		// Leitura Anterior
		String dataLeituraAtual = "";
		// consumo medido do mês
		String consumoMedidoMes = "";
		if (parmsMedicaoHistorico != null) {

			if (parmsMedicaoHistorico[1] != null) {
				leituraAtual = "" + (Integer) parmsMedicaoHistorico[1];
			}

			if (parmsMedicaoHistorico[2] != null) {
				dataLeituraAtual = Util
						.formatarData((Date) parmsMedicaoHistorico[2]);
			}

			if (parmsMedicaoHistorico[6] != null) {
				consumoMedidoMes = "" + (Integer) parmsMedicaoHistorico[6];
			}
		}
		// completa com espaços em branco
		linhasArquivoTxtCartas
				.append(Util.completaString(dataLeituraAtual, 10));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaStringComEspacoAEsquerda(
				leituraAtual, 39));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 6));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 8-- //
		// Canal
		linhasArquivoTxtCartas.append("1");

		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaStringComEspacoAEsquerda(
				consumoMedidoMes, 26));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 34));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 9-- //
		// Canal
		linhasArquivoTxtCartas.append("0");

		// Inicio Chamar Sub-Fluxo
		// recupera os parametros do consumo historico da
		// conta
		// [SB0007] - Obter Dados de Consumo da Conta
		Object[] parmsConsumoHistorico = null;
		String consumoMedio = "";
		// caso o tipo de ligacao for diferente de nulo
		if (tipoLigacao != null) {
			try {
				parmsConsumoHistorico = repositorioMicromedicao
						.obterDadosConsumoConta(
								emitirContaHelper.getIdImovel(),
								emitirContaHelper.getAmReferencia(),
								tipoLigacao);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			if (parmsConsumoHistorico != null) {
				// Consumo médio
				if (parmsConsumoHistorico[2] != null) {
					consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
				}
			}

		}
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaStringComEspacoAEsquerda(
				consumoMedio, 42));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 18));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 10-- //
		// Canal
		linhasArquivoTxtCartas.append("1");

		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 14));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString(
				emitirContaHelper.getDescricaoLocalidade(), 46));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 11-- //
		// Canal
		linhasArquivoTxtCartas.append("1");

		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 6 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
				emitirContaHelper, 6, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 4 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
				emitirContaHelper, 4, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 2 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
				emitirContaHelper, 2, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 12-- //
		// Canal
		linhasArquivoTxtCartas.append(" ");

		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 5 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
				emitirContaHelper, 5, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 3 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
				emitirContaHelper, 3, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 1 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
				emitirContaHelper, 1, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 13-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 42));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append("SEQ.  ");
		// sequencial impressão
		String sequencialImpressaoFormatada = Util.adicionarZerosEsquedaNumero(
				6, "" + sequencial);
		sequencialImpressaoFormatada = sequencialImpressaoFormatada.substring(
				0, 3) + "." + sequencialImpressaoFormatada.substring(3, 6);
		linhasArquivoTxtCartas.append(Util.completaString(
				sequencialImpressaoFormatada, 12));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 14-- //
		// Canal
		linhasArquivoTxtCartas.append(" ");
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 42));
		linhasArquivoTxtCartas.append("GRUPO - ");
		linhasArquivoTxtCartas.append(Util.completaStringComEspacoAEsquerda(""
				+ emitirContaHelper.getIdFaturamentoGrupo(), 5));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 5));

		return linhasArquivoTxtCartas;

	}

	/**
	 * [UC0351 - Calcular Impostos Deduzidos da Conta
	 * 
	 * @author Fernanda Paiva, Raphael Rossiter
	 * @date 21/09/2006, 04/04/2008
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @param valorAgua
	 * @param valorEsgoto
	 * @param valorDebito
	 * @param valorCredito
	 * @return GerarImpostosDeduzidosContaHelper
	 * @throws ControladorException
	 */
	public GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosConta(
			Integer idImovel, Integer anoMesReferencia, BigDecimal valorAgua,
			BigDecimal valorEsgoto, BigDecimal valorDebito,
			BigDecimal valorCredito, boolean preFaturamento)
			throws ControladorException {

		GerarImpostosDeduzidosContaHelper retorno = new GerarImpostosDeduzidosContaHelper();

		Integer idCliente = null;

		try {

			/*
			 * Pesquisa um cliente Federal para este imovel e com relação tipo
			 * igual a Responsável.
			 */
			idCliente = this.repositorioFaturamento
					.pesquisarClienteResponsavelImovel(idImovel);

			if (idCliente != null) {

				ImpostoDeduzidoHelper impostoDeduzidoHelper = null;
				Collection<ImpostoDeduzidoHelper> colecaoHelper = null;

				BigDecimal baseCalculo = new BigDecimal("0.00");
				ImpostoTipoAliquota impostoTipoAliquota = null;
				BigDecimal valorImpostoDeduzido = new BigDecimal("0.00");
				BigDecimal percetagemAliquota = new BigDecimal("0.00");
				BigDecimal valorImpostoDeduzidoFinal = new BigDecimal("0.00");

				BigDecimal percetagemTotalAliquota = new BigDecimal("0.00");
				BigDecimal valorImpostoDeduzidoTotal = new BigDecimal("0.00");

				/*
				 * Determina a base de calculo dos impostos deduzido = (valor de
				 * água + valor de esgoto + valor dos débitos cobrados - valor
				 * dos créditos realizados).
				 */
				baseCalculo = valorAgua.add(valorEsgoto);
				baseCalculo = baseCalculo.add(valorDebito);
				baseCalculo = baseCalculo.subtract(valorCredito);

				baseCalculo = baseCalculo.setScale(2, BigDecimal.ROUND_DOWN);

				if (preFaturamento) {
					baseCalculo = ConstantesSistema.VALOR_ZERO;
				}

				// Recupera a colecao dos tipos de imposto
				FiltroImpostoTipo filtroImpostoTipo = new FiltroImpostoTipo();

				// Colocado por Raphael Rossiter em 13/11/2008 - Analista:
				// Eduardo Borges
				filtroImpostoTipo.adicionarParametro(new ParametroSimples(
						FiltroImpostoTipo.INDICADOR_USO,
						ConstantesSistema.INDICADOR_USO_ATIVO));

				Collection colecaoImpostoTipo = getControladorUtil().pesquisar(
						filtroImpostoTipo, ImpostoTipo.class.getName());

				ImpostoTipo impostoTipo = null;
				if (colecaoImpostoTipo != null && !colecaoImpostoTipo.isEmpty()) {

					/*
					 * Para cada tipo de imposto calcula o valor do imposto
					 * deduzido e acumula um valor total.
					 */
					colecaoHelper = new ArrayList();

					Iterator iteratorImpostoTipo = colecaoImpostoTipo
							.iterator();

					while (iteratorImpostoTipo.hasNext()) {

						impostoTipo = (ImpostoTipo) iteratorImpostoTipo.next();
						impostoDeduzidoHelper = new ImpostoDeduzidoHelper();

						// Pesquisa a aliquota para cada tipo de imposto
						impostoTipoAliquota = this.repositorioFaturamento
								.pesquisarAliquotaImposto(impostoTipo.getId(),
										anoMesReferencia);

						// TOTAL PERCENTAGEM IMPOSTOS
						// ===========================================
						percetagemTotalAliquota = percetagemTotalAliquota
								.add(impostoTipoAliquota
										.getPercentualAliquota());
						// =======================================================================

						/*
						 * Colocado por Raphael Rossiter em 04/06/2007
						 * 
						 * O valor do último imposto não será mais calculado,
						 * será a diferença entre o valor total do imposto com o
						 * valor dos impostos calculados.
						 */
						if (iteratorImpostoTipo.hasNext()) {

							percetagemAliquota = Util
									.dividirArredondando(impostoTipoAliquota
											.getPercentualAliquota(),
											new BigDecimal("100.00"));

							valorImpostoDeduzido = baseCalculo
									.multiply(percetagemAliquota);

							// ARREDONDAMENTO
							valorImpostoDeduzido = valorImpostoDeduzido
									.setScale(2, BigDecimal.ROUND_HALF_DOWN);

							/*
							 * Se o valor deduzido for maior que zero, cria uma
							 * colecao com o tipo, o valor e a aliquota do
							 * imposto e guarda um valor total de todos os
							 * impostos.
							 */
							if (valorImpostoDeduzido
									.compareTo(ConstantesSistema.VALOR_ZERO) == 1
									|| preFaturamento) {

								// IMPOSTO_TIPO
								impostoDeduzidoHelper
										.setIdImpostoTipo(impostoTipoAliquota
												.getImpostoTipoAliquota()
												.getId());

								// VALOR_IMPOSTO
								impostoDeduzidoHelper
										.setValor(valorImpostoDeduzido);

								// ALIGUOTA
								impostoDeduzidoHelper
										.setPercentualAliquota(impostoTipoAliquota
												.getPercentualAliquota());

								// VALOR_IMPOSTO_TOTAL
								valorImpostoDeduzidoFinal = valorImpostoDeduzidoFinal
										.add(valorImpostoDeduzido);

								colecaoHelper.add(impostoDeduzidoHelper);
							}
						} else {

							// TOTAL
							// =================================================
							percetagemTotalAliquota = Util.dividirArredondando(
									percetagemTotalAliquota, new BigDecimal(
											"100.00"));

							valorImpostoDeduzidoTotal = baseCalculo
									.multiply(percetagemTotalAliquota);

							valorImpostoDeduzidoTotal = valorImpostoDeduzidoTotal
									.setScale(2, BigDecimal.ROUND_HALF_DOWN);
							// =======================================================

							// ÚLTIMO IMPOSTO
							// ========================================
							valorImpostoDeduzido = valorImpostoDeduzidoTotal
									.subtract(valorImpostoDeduzidoFinal);

							valorImpostoDeduzido = valorImpostoDeduzido
									.setScale(2, BigDecimal.ROUND_DOWN);
							// =======================================================

							/*
							 * Se o valor deduzido for maior que zero, cria uma
							 * colecao com o tipo, o valor e a aliquota do
							 * imposto e guarda um valor total de todos os
							 * impostos.
							 */
							if (valorImpostoDeduzido
									.compareTo(ConstantesSistema.VALOR_ZERO) == 1
									|| preFaturamento) {

								// IMPOSTO_TIPO
								impostoDeduzidoHelper
										.setIdImpostoTipo(impostoTipoAliquota
												.getImpostoTipoAliquota()
												.getId());

								// VALOR_IMPOSTO
								impostoDeduzidoHelper
										.setValor(valorImpostoDeduzido);

								// ALIGUOTA
								impostoDeduzidoHelper
										.setPercentualAliquota(impostoTipoAliquota
												.getPercentualAliquota());

								// VALOR_IMPOSTO_TOTAL
								valorImpostoDeduzidoFinal = valorImpostoDeduzidoTotal;

								colecaoHelper.add(impostoDeduzidoHelper);
							}
						}
					}

					retorno.setListaImpostosDeduzidos(colecaoHelper);

					valorImpostoDeduzidoFinal = valorImpostoDeduzidoFinal
							.setScale(2, BigDecimal.ROUND_DOWN);

					retorno.setValorTotalImposto(valorImpostoDeduzidoFinal);
					retorno.setValorBaseCalculo(baseCalculo);
				}
			} else {
				retorno.setListaImpostosDeduzidos(null);
				retorno.setValorTotalImposto(ConstantesSistema.VALOR_ZERO);
				retorno.setValorBaseCalculo(ConstantesSistema.VALOR_ZERO);
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Fernanda Paiva Data: 25/09/2006
	 * 
	 * Inseri na tabela ClienteConta os dados referentes aos clientes do imovel
	 * 
	 * @param conta
	 * @param colecaoCreditoRealizado
	 * @param imovel
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirClienteImovel(Imovel imovel, Conta contaAtual)
			throws ControladorException {

		if (imovel.getId() != null && !imovel.getId().equals("")) {

			Collection clientesImovel = new ArrayList();
			try {
				clientesImovel = repositorioFaturamento
						.pesquisarClienteImovelDataRelacaoFimNull(imovel);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			Iterator clientesImovelIt = clientesImovel.iterator();

			while (clientesImovelIt.hasNext()) {

				Object[] array = (Object[]) clientesImovelIt.next();

				ClienteConta clienteContaInserir = new ClienteConta();

				// Id da Conta Selecionada
				clienteContaInserir.setConta(contaAtual);

				// carrega o objeto cliente
				Cliente cliente = (Cliente) array[0];

				// Id do cliente Selecionada
				clienteContaInserir.setCliente(cliente);

				// carrega o objeto cliente relacao tipo
				ClienteRelacaoTipo clienteRelacaoTipo = (ClienteRelacaoTipo) array[1];

				// Cliente Relacao Tipo
				clienteContaInserir.setClienteRelacaoTipo(clienteRelacaoTipo);

				// Cliente Relacao Tipo
				clienteContaInserir.setIndicadorNomeConta((Short) array[2]);

				// Última alteração
				clienteContaInserir.setUltimaAlteracao(new Date());

				// -------------------------------------------------------
				// Inserindo no BD
				this.getControladorUtil().inserir(clienteContaInserir);
			}
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Fernanda Paiva Data: 25/09/2006
	 * 
	 * Inseri na tabela impostos deduzidos da conta
	 * 
	 * @param conta
	 * @param colecaoCreditoRealizado
	 * @param imovel
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirImpostosDeduzidosConta(
			GerarImpostosDeduzidosContaHelper impostosDeduzidosConta,
			Conta contaAtual) throws ControladorException {

		if (impostosDeduzidosConta.getListaImpostosDeduzidos() != null
				&& !impostosDeduzidosConta.getListaImpostosDeduzidos()
						.isEmpty()) {

			FiltroImpostoTipo filtroImpostoTipo = new FiltroImpostoTipo();

			Collection<ImpostoDeduzidoHelper> impostosDeduzidos = new ArrayList();

			impostosDeduzidos = impostosDeduzidosConta
					.getListaImpostosDeduzidos();

			Iterator impostosDeduzidoIt = impostosDeduzidos.iterator();

			ImpostoTipo impostoTipo = new ImpostoTipo();

			while (impostosDeduzidoIt.hasNext()) {

				ImpostoDeduzidoHelper impostosDeduzidoColecao = (ImpostoDeduzidoHelper) impostosDeduzidoIt
						.next();

				ContaImpostosDeduzidos impostoDeduzidoInserir = new ContaImpostosDeduzidos();

				// Id da Conta Selecionada
				impostoDeduzidoInserir.setConta(contaAtual);

				// pesquisa o objeto imposto tipo a partir do id do imposto tipo
				filtroImpostoTipo.limparListaParametros();

				filtroImpostoTipo.adicionarParametro(new ParametroSimples(
						FiltroImpostoTipo.ID, impostosDeduzidoColecao
								.getIdImpostoTipo()));

				Collection colecaoImpostoTipo;

				colecaoImpostoTipo = getControladorUtil().pesquisar(
						filtroImpostoTipo, ImpostoTipo.class.getName());

				impostoTipo = (ImpostoTipo) Util
						.retonarObjetoDeColecao(colecaoImpostoTipo);

				// imposto Tipo
				impostoDeduzidoInserir.setImpostoTipo(impostoTipo);

				// Valor do Imposto
				impostoDeduzidoInserir.setValorImposto(impostosDeduzidoColecao
						.getValor());

				// Percentual da Aliquota
				impostoDeduzidoInserir
						.setPercentualAliquota(impostosDeduzidoColecao
								.getPercentualAliquota());

				// Base de cálculo
				BigDecimal valorBase = contaAtual.getValorAgua().add(
						contaAtual.getValorEsgoto());
				valorBase = valorBase.add(contaAtual.getDebitos());
				valorBase = valorBase.subtract(contaAtual.getValorCreditos());

				impostoDeduzidoInserir.setValorBaseCalculo(valorBase);

				// Data da ultima alteracao
				impostoDeduzidoInserir.setUltimaAlteracao(new Date());

				// -------------------------------------------------------
				// Inserindo no BD
				this.getControladorUtil().inserir(impostoDeduzidoInserir);
			}
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Tarnsfere para o histórico de contas
	 * 
	 * @author Pedro Alexandre
	 * @date 09/10/2006
	 * 
	 * @param contas
	 * @param anoMesFaturamentoSistemaParametro
	 * @throws ControladorException
	 */
	public void transferirContasParaHistorico(Collection<Conta> contas, int anoMesFaturamentoSistemaParametro) throws ControladorException {

		try {
			ContaHistorico contaHistoricoTemp = null;
			Collection colecaoContasRemover = new ArrayList();

			if (contas != null && !contas.isEmpty()) {

				colecaoContasRemover.addAll(contas);
				int cont = 0;

				for (Conta conta : contas) {
					cont++;

					Integer idConta = conta.getId();

					contaHistoricoTemp = new ContaHistorico();
					contaHistoricoTemp.setId(idConta);
					contaHistoricoTemp.setAnoMesReferenciaConta(conta.getReferencia());
					contaHistoricoTemp.setContaHistorico(new Date());
					contaHistoricoTemp.setImovel(conta.getImovel());
					contaHistoricoTemp.setLote(conta.getLote());
					contaHistoricoTemp.setSubLote(conta.getSubLote());
					contaHistoricoTemp.setSetorComercial(conta.getCodigoSetorComercial());
					contaHistoricoTemp.setNumeroQuadra(conta.getQuadra());
					contaHistoricoTemp.setVerificadorConta(conta.getDigitoVerificadorConta());
					contaHistoricoTemp.setIndicadorCobrancaMulta(conta.getIndicadorCobrancaMulta());
					contaHistoricoTemp.setIndicadorAlteracaoVencimento(conta.getIndicadorAlteracaoVencimento());
					contaHistoricoTemp.setConsumoAgua(conta.getConsumoAgua());
					contaHistoricoTemp.setConsumoEsgoto(conta.getConsumoEsgoto());
					contaHistoricoTemp.setConsumoRateioAgua(conta.getConsumoRateioAgua());
					contaHistoricoTemp.setConsumoRateioEsgoto(conta.getConsumoRateioEsgoto());
					contaHistoricoTemp.setValorAgua(conta.getValorAgua());
					contaHistoricoTemp.setValorEsgoto(conta.getValorEsgoto());
					contaHistoricoTemp.setValorDebitos(conta.getDebitos());
					contaHistoricoTemp.setValorCreditos(conta.getValorCreditos());
					contaHistoricoTemp.setPercentualEsgoto(conta.getPercentualEsgoto());
					contaHistoricoTemp.setDataVencimentoConta(conta.getDataVencimentoConta());
					contaHistoricoTemp.setDataValidadeConta(conta.getDataValidadeConta());
					contaHistoricoTemp.setDataInclusao(conta.getDataInclusao());
					contaHistoricoTemp.setDataRevisao(conta.getDataRevisao());
					contaHistoricoTemp.setDataRetificacao(conta.getDataRetificacao());
					contaHistoricoTemp.setDataCancelamento(conta.getDataCancelamento());
					contaHistoricoTemp.setDataEmissao(conta.getDataEmissao());
					contaHistoricoTemp.setAnoMesReferenciaContabil(conta.getReferenciaContabil());
					contaHistoricoTemp.setAnoMesReferenciaBaixaContabil(conta.getReferenciaBaixaContabil());
					contaHistoricoTemp.setLigacaoEsgotoSituacao(conta.getLigacaoEsgotoSituacao());
					contaHistoricoTemp.setLigacaoAguaSituacao(conta.getLigacaoAguaSituacao());
					contaHistoricoTemp.setMotivoNaoEntregaDocumento(conta.getMotivoNaoEntregaDocumento());
					contaHistoricoTemp.setLocalidade(conta.getLocalidade());
					contaHistoricoTemp.setQuadra(conta.getQuadraConta());
					contaHistoricoTemp.setContaMotivoInclusao(conta.getContaMotivoInclusao());
					contaHistoricoTemp.setContaMotivoRevisao(conta.getContaMotivoRevisao());
					contaHistoricoTemp.setContaMotivoRetificacao(conta.getContaMotivoRetificacao());
					contaHistoricoTemp.setContaMotivoCancelamento(conta.getContaMotivoCancelamento());
					contaHistoricoTemp.setFaturamentoTipo(conta.getFaturamentoTipo());
					contaHistoricoTemp.setImovelPerfil(conta.getImovelPerfil());
					contaHistoricoTemp.setRegistroAtendimento(conta.getRegistroAtendimento());
					contaHistoricoTemp.setConsumoTarifa(conta.getConsumoTarifa());
					contaHistoricoTemp.setIndicadorDebitoConta(conta.getIndicadorDebitoConta());
					contaHistoricoTemp.setFuncionarioEntrega(conta.getFuncionarioEntrega());
					contaHistoricoTemp.setFuncionarioLeitura(conta.getFuncionarioLeitura());
					contaHistoricoTemp.setUltimaAlteracao(new Date());
					contaHistoricoTemp.setDebitoCreditoSituacaoAtual(conta.getDebitoCreditoSituacaoAtual());
					contaHistoricoTemp.setDebitoCreditoSituacaoAnterior(conta.getDebitoCreditoSituacaoAnterior());
					contaHistoricoTemp.setDocumentoTipo(conta.getDocumentoTipo());
					contaHistoricoTemp.setContaBancaria(conta.getContaBancaria());
					contaHistoricoTemp.setDataVencimentoOriginal(conta.getDataVencimentoOriginal());
					contaHistoricoTemp.setParcelamento(conta.getParcelamento());
					contaHistoricoTemp.setValorImposto(conta.getValorImposto());
					contaHistoricoTemp.setUsuario(conta.getUsuario());
					contaHistoricoTemp.setNumeroRetificacoes(conta.getNumeroRetificacoes());
					contaHistoricoTemp.setNumeroFatura(conta.getNumeroFatura());
					contaHistoricoTemp.setFaturamentoGrupo(conta.getFaturamentoGrupo());
					contaHistoricoTemp.setRota(conta.getRota());
					contaHistoricoTemp.setNumeroLeituraAnterior(conta.getNumeroLeituraAnterior());
					contaHistoricoTemp.setNumeroLeituraAtual(conta.getNumeroLeituraAtual());
					contaHistoricoTemp.setNumeroLeituraAtualPoco(conta.getNumeroLeituraAtualPoco());
					contaHistoricoTemp.setNumeroLeituraAnteriorPoco(conta.getNumeroLeituraAnteriorPoco());
					contaHistoricoTemp.setPercentualColeta(conta.getPercentualColeta());
					contaHistoricoTemp.setNumeroVolumePoco(conta.getNumeroVolumePoco());
					contaHistoricoTemp.setNumeroBoleto(conta.getNumeroBoleto());
					contaHistoricoTemp.setDataEnvioEmailConta(conta.getDataEnvioEmailConta());
					contaHistoricoTemp.setValorRateioAgua(conta.getValorRateioAgua());
					contaHistoricoTemp.setValorRateioEsgoto(conta.getValorRateioEsgoto());

					getControladorUtil().inserir(contaHistoricoTemp);

					this.enviarContaCategoriaParaHistorico(contaHistoricoTemp, idConta);
					this.enviarDebitoCobradoParaHistorico(anoMesFaturamentoSistemaParametro, contaHistoricoTemp, idConta);
					this.enviarCreditoRealizadoParaHistorico(anoMesFaturamentoSistemaParametro, contaHistoricoTemp, idConta);
					this.enviarContaImpostosDeduzidosParaHistorico(contaHistoricoTemp, idConta);
					this.enviarClienteContaParaHistorico(contaHistoricoTemp,idConta);

					getControladorSpcSerasa().verificarRelacaoDaTransfereciaPHistoricoComItensNegativacao(contaHistoricoTemp);
				}
			}
			getControladorBatch().removerColecaoContaParaBatch(colecaoContasRemover);

			colecaoContasRemover = null;

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Transfere para o histórico os débitos a cobrar.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/10/2006
	 * 
	 * @param debitosACobrar
	 * @throws ControladorException
	 */
	public void transferirDebitosACobrarParaHistorico(
			Collection<DebitoACobrar> debitosACobrar)
 throws ControladorException {

		try {

			Collection colecaoDebitoACobrarHistoricoInserir = new ArrayList();
			Collection colecaoDebitoACobrarCategoriaHistoricoInserir = new ArrayList();

			Collection colecaoDebitoACobrarRemover = new ArrayList();
			Collection colecaoDebitoACobrarCategoriaRemover = new ArrayList();

			DebitoACobrarHistorico debitoACobrarHistoricoTemp = null;

			if (debitosACobrar != null && !debitosACobrar.isEmpty()) {

				int cont = 0;
				for (DebitoACobrar debitoACobrar : debitosACobrar) {
					cont++;

					debitoACobrarHistoricoTemp = new DebitoACobrarHistorico();
					debitoACobrarHistoricoTemp.setId(debitoACobrar.getId());
					debitoACobrarHistoricoTemp.setDebitoGeradoRealizar(debitoACobrar.getGeracaoDebito());
					debitoACobrarHistoricoTemp.setAnoMesReferenciaDebito(debitoACobrar.getAnoMesReferenciaDebito());
					debitoACobrarHistoricoTemp.setAnoMesCobrancaDebito(debitoACobrar.getAnoMesCobrancaDebito());
					debitoACobrarHistoricoTemp.setAnoMesReferenciaContabil(debitoACobrar.getAnoMesReferenciaContabil());
					debitoACobrarHistoricoTemp.setValorDebito(debitoACobrar.getValorDebito());
					debitoACobrarHistoricoTemp.setPrestacaoDebito(debitoACobrar.getNumeroPrestacaoDebito());
					debitoACobrarHistoricoTemp.setPrestacaoCobradas(debitoACobrar.getNumeroPrestacaoCobradas());
					debitoACobrarHistoricoTemp.setCodigoSetorComercial(debitoACobrar.getCodigoSetorComercial());
					debitoACobrarHistoricoTemp.setNumeroQuadra(debitoACobrar.getNumeroQuadra());
					debitoACobrarHistoricoTemp.setLote(debitoACobrar.getNumeroLote());
					debitoACobrarHistoricoTemp.setSublote(debitoACobrar.getNumeroSubLote());
					debitoACobrarHistoricoTemp.setUltimaAlteracao(new Date());
					debitoACobrarHistoricoTemp.setLancamentoItemContabil(debitoACobrar.getLancamentoItemContabil());
					debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAtual(debitoACobrar.getDebitoCreditoSituacaoAtual());
					debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAnterior(debitoACobrar.getDebitoCreditoSituacaoAnterior());
					debitoACobrarHistoricoTemp.setRegistroAtendimento(debitoACobrar.getRegistroAtendimento());
					debitoACobrarHistoricoTemp.setImovel(debitoACobrar.getImovel());
					debitoACobrarHistoricoTemp.setFinanciamentoTipo(debitoACobrar.getFinanciamentoTipo());
					debitoACobrarHistoricoTemp.setOrdemServico(debitoACobrar.getOrdemServico());
					debitoACobrarHistoricoTemp.setCobrancaForma(debitoACobrar.getCobrancaForma());
					debitoACobrarHistoricoTemp.setQuadra(debitoACobrar.getQuadra());
					debitoACobrarHistoricoTemp.setLocalidade(debitoACobrar.getLocalidade());
					debitoACobrarHistoricoTemp.setParcelamentoGrupo(debitoACobrar.getParcelamentoGrupo());
					debitoACobrarHistoricoTemp.setDocumentoTipo(debitoACobrar.getDocumentoTipo());
					debitoACobrarHistoricoTemp.setParcelamento(debitoACobrar.getParcelamento());
					debitoACobrarHistoricoTemp.setDebitoTipo(debitoACobrar.getDebitoTipo());
					debitoACobrarHistoricoTemp.setPercentualTaxaJurosFinanciamento(debitoACobrar.getPercentualTaxaJurosFinanciamento());
					debitoACobrarHistoricoTemp.setUsuario(debitoACobrar.getUsuario());

					colecaoDebitoACobrarHistoricoInserir.add(debitoACobrarHistoricoTemp);

					Collection<DebitoACobrarCategoria> colecaoDebitoACobrarCategoria = this.repositorioFaturamento.pesquisarDebitosACobrarCategoria(debitoACobrar);

					if (colecaoDebitoACobrarCategoria != null && !colecaoDebitoACobrarCategoria.isEmpty()) {

						colecaoDebitoACobrarCategoriaRemover = new ArrayList();
						colecaoDebitoACobrarCategoriaRemover.addAll(colecaoDebitoACobrarCategoria);

						for (DebitoACobrarCategoria debitoACobrarCategoria : colecaoDebitoACobrarCategoria) {

							DebitoACobrarCategoriaHistorico debitoACobrarCategoriaHistorico = new DebitoACobrarCategoriaHistorico();
							debitoACobrarCategoriaHistorico.setComp_id(new DebitoACobrarCategoriaHistoricoPK(debitoACobrarHistoricoTemp.getId(),
									debitoACobrarCategoria.getCategoria().getId()));
							debitoACobrarCategoriaHistorico.setCategoria(debitoACobrarCategoria.getCategoria());
							debitoACobrarCategoriaHistorico.setDebitoACobrarHistorico(debitoACobrarHistoricoTemp);
							debitoACobrarCategoriaHistorico.setQuantidadeEconomia(debitoACobrarCategoria.getQuantidadeEconomia());
							debitoACobrarCategoriaHistorico.setUltimaAlteracao(new Date());
							debitoACobrarCategoriaHistorico.setValorCategoria(debitoACobrarCategoria.getValorCategoria());

							colecaoDebitoACobrarCategoriaHistoricoInserir.add(debitoACobrarCategoriaHistorico);
						}
						getControladorBatch().removerColecaoDebitoACobrarCategoriaParaBatch(colecaoDebitoACobrarCategoriaRemover);
						colecaoDebitoACobrarCategoriaRemover = null;
					}
				}

				colecaoDebitoACobrarRemover.addAll(debitosACobrar);
				debitosACobrar = null;
				getControladorBatch().removerColecaoDebitoACobrarParaBatch(colecaoDebitoACobrarRemover);

				colecaoDebitoACobrarRemover = null;

				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoACobrarHistoricoInserir);
				colecaoDebitoACobrarHistoricoInserir = null;
				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoACobrarCategoriaHistoricoInserir);
				colecaoDebitoACobrarCategoriaHistoricoInserir = null;
			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Transfere para o histórico os créditos a realizar.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/10/2006
	 * 
	 * @param creditosARealizar
	 * @throws ControladorException
	 */
	public void transferirCreditoARealizarParaHistorico(
			Collection<CreditoARealizar> creditosARealizar)
			throws ControladorException {

		try {

			Collection<Integer> colecaoIdsCreditoARealizar = new ArrayList();

			Collection colecaoCreditoARealizarHistoricoInserir = new ArrayList();
			Collection colecaoCreditoARealizarCategoriaHistoricoInserir = new ArrayList();

			Collection colecaoCreditoARealizarRemover = new ArrayList();
			Collection colecaoCreditoARealizarCategoriaRemover = new ArrayList();

			// cria o histórico de crédito a realizar
			CreditoARealizarHistorico creditoARealizarHistoricoTemp = null;

			if (creditosARealizar != null && !creditosARealizar.isEmpty()) {

				int cont = 0;
				// laço para criar todos os históricos de créditos a realizar
				for (CreditoARealizar creditoARealizar : creditosARealizar) {
					cont++;

					// seta os dados do histórico de crédito a realizar
					creditoARealizarHistoricoTemp = new CreditoARealizarHistorico();
					creditoARealizarHistoricoTemp.setId(creditoARealizar
							.getId());
					creditoARealizarHistoricoTemp
							.setGeracaoCreditoARealizar(creditoARealizar
									.getGeracaoCredito());
					creditoARealizarHistoricoTemp
							.setAnoMesReferenciaCredito(creditoARealizar
									.getAnoMesReferenciaCredito());
					creditoARealizarHistoricoTemp
							.setAnoMesCobrancaCredito(creditoARealizar
									.getAnoMesCobrancaCredito());
					creditoARealizarHistoricoTemp
							.setValorResidualMesAnterior(creditoARealizar
									.getValorResidualMesAnterior());
					creditoARealizarHistoricoTemp
							.setValorCredito(creditoARealizar.getValorCredito());
					creditoARealizarHistoricoTemp
							.setPrestacaoCredito(creditoARealizar
									.getNumeroPrestacaoCredito());
					creditoARealizarHistoricoTemp
							.setPrestacaoRealizadas(creditoARealizar
									.getNumeroPrestacaoRealizada());
					creditoARealizarHistoricoTemp
							.setCodigoSetorComercial(creditoARealizar
									.getCodigoSetorComercial());
					creditoARealizarHistoricoTemp
							.setNumeroQuadra(creditoARealizar.getNumeroQuadra());
					creditoARealizarHistoricoTemp.setLote(creditoARealizar
							.getNumeroLote());
					creditoARealizarHistoricoTemp.setSubLote(creditoARealizar
							.getNumeroSubLote());
					creditoARealizarHistoricoTemp
							.setAnoMesReferenciaContabil(creditoARealizar
									.getAnoMesReferenciaContabil());
					creditoARealizarHistoricoTemp
							.setUltimaAlteracao(new Date());
					creditoARealizarHistoricoTemp
							.setLancamentoItemContabil(creditoARealizar
									.getLancamentoItemContabil());
					creditoARealizarHistoricoTemp
							.setDebitoCreditoSituacaoAtual(creditoARealizar
									.getDebitoCreditoSituacaoAtual());
					creditoARealizarHistoricoTemp
							.setDebitoCreditoSituacaoAnterior(creditoARealizar
									.getDebitoCreditoSituacaoAnterior());
					creditoARealizarHistoricoTemp
							.setRegistroAtendimento(creditoARealizar
									.getRegistroAtendimento());
					creditoARealizarHistoricoTemp.setImovel(creditoARealizar
							.getImovel());
					creditoARealizarHistoricoTemp
							.setOrdemServico(creditoARealizar.getOrdemServico());
					creditoARealizarHistoricoTemp.setQuadra(creditoARealizar
							.getQuadra());
					creditoARealizarHistoricoTemp
							.setLocalidade(creditoARealizar.getLocalidade());
					creditoARealizarHistoricoTemp
							.setCreditoTipo(creditoARealizar.getCreditoTipo());
					creditoARealizarHistoricoTemp
							.setCreditoOrigem(creditoARealizar
									.getCreditoOrigem());
					creditoARealizarHistoricoTemp
							.setParcelamento(creditoARealizar.getParcelamento());
					creditoARealizarHistoricoTemp
							.setDocumentoTipo(creditoARealizar
									.getDocumentoTipo());
					creditoARealizarHistoricoTemp.setUsuario(creditoARealizar
							.getUsuario());

					colecaoCreditoARealizarHistoricoInserir
							.add(creditoARealizarHistoricoTemp);

					// adicona o id do crédito a realizar para coleção
					colecaoIdsCreditoARealizar.add(creditoARealizar.getId());

					Collection<CreditoARealizarCategoria> colecaoCreditoARealizarCategoria = this.repositorioFaturamento
							.pesquisarCreditoARealizarCategoria(creditoARealizar);

					if (colecaoCreditoARealizarCategoria != null
							&& !colecaoCreditoARealizarCategoria.isEmpty()) {

						colecaoCreditoARealizarCategoriaRemover
								.addAll(colecaoCreditoARealizarCategoria);

						for (CreditoARealizarCategoria creditoARealizarCategoria : colecaoCreditoARealizarCategoria) {

							CreditoARealizarCategoriaHistorico creditoARealizarCategoriaHistorico = new CreditoARealizarCategoriaHistorico();
							creditoARealizarCategoriaHistorico
									.setComp_id(new CreditoARealizarCategoriaHistoricoPK(
											creditoARealizarHistoricoTemp
													.getId(),
											creditoARealizarCategoria
													.getCategoria().getId()));
							creditoARealizarCategoriaHistorico
									.setCategoria(creditoARealizarCategoria
											.getCategoria());
							creditoARealizarCategoriaHistorico
									.setCreditoARealizarHistorico(creditoARealizarHistoricoTemp);
							creditoARealizarCategoriaHistorico
									.setQuantidadeEconomia(creditoARealizarCategoria
											.getQuantidadeEconomia());
							creditoARealizarCategoriaHistorico
									.setUltimaAlteracao(new Date());
							creditoARealizarCategoriaHistorico
									.setValorCategoria(creditoARealizarCategoria
											.getValorCategoria());

							colecaoCreditoARealizarCategoriaHistoricoInserir
									.add(creditoARealizarCategoriaHistorico);

							System.out.println("credito a realizar:"
									+ creditoARealizarCategoriaHistorico
											.getComp_id()
											.getCreditoARealizarHistoricoId());
						}
					}
				}

				// Inserindo no histórico
				colecaoCreditoARealizarRemover.addAll(creditosARealizar);
				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoCreditoARealizarHistoricoInserir);
				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoCreditoARealizarCategoriaHistoricoInserir);

				// Removendo das tabelas principais
				getControladorBatch()
						.removerColecaoCreditoARealizarCategoriaParaBatch(
								colecaoIdsCreditoARealizar);
				getControladorBatch().removerColecaoCreditoARealizarParaBatch(
						colecaoCreditoARealizarRemover);

				// liberando a memória
				creditosARealizar = null;
				colecaoCreditoARealizarCategoriaRemover = null;
				colecaoCreditoARealizarRemover = null;
				colecaoCreditoARealizarHistoricoInserir = null;
				colecaoCreditoARealizarCategoriaHistoricoInserir = null;

			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Para cada conta transferida para o histórico, atualiza o indicador de que
	 * a conta está no histórico na tabela ContaGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * 
	 * @param colecaoContas
	 * @throws ControladorException
	 */
	public void atualizarIndicadorContaNoHistorico(Collection colecaoContas) throws ControladorException {
		List colecaoTotalContas = (List) colecaoContas;
		int limiteSuperior;
		int limiteInferior;
		int limiteMaximo = colecaoTotalContas.size();
		int quantidadeMaximaPorColecao = 100;

		try {

			for (int i = 0; i < limiteMaximo; i = i + 100) {

				if (limiteMaximo < quantidadeMaximaPorColecao) {
					limiteInferior = 0;
					limiteSuperior = limiteMaximo;
				} else {
					limiteInferior = i;
					limiteSuperior = i + 100;

					if (limiteSuperior > limiteMaximo) {
						limiteSuperior = limiteMaximo;
					}
				}

				List colecaoContasTemporaria = new ArrayList();
				colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior, limiteSuperior));

				this.repositorioFaturamento.atualizarIndicadorContaNoHistorico(colecaoContasTemporaria);

			}

		} catch (Exception e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Para cada débito a cobrar transferido para o histórico, atualiza o
	 * indicador de que o débito a cobrar está no histórico na tabela
	 * DebitoACobrarGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * 
	 * @param colecaoDebitosACobrar
	 * @throws ControladorException
	 */
	public void atualizarIndicadorDebitoACobrarNoHistorico(
			Collection colecaoDebitosACobrar) throws ControladorException {

		try {
			List colecaoTotalDebitosACobrar = (List) colecaoDebitosACobrar;
			int limiteSuperior;
			int limiteInferior;
			int limiteMaximo = colecaoTotalDebitosACobrar.size();
			int quantidadeMaximaPorColecao = 100;

			for (int i = 0; i < limiteMaximo; i = i + 100) {

				if (limiteMaximo < quantidadeMaximaPorColecao) {
					limiteInferior = 0;
					limiteSuperior = limiteMaximo;
				} else {
					limiteInferior = i;
					limiteSuperior = i + 100;

					if (limiteSuperior > limiteMaximo) {
						limiteSuperior = limiteMaximo;
					}
				}

				List colecaoDebitosACobrarTemporaria = new ArrayList();
				colecaoDebitosACobrarTemporaria
						.addAll(colecaoTotalDebitosACobrar.subList(
								limiteInferior, limiteSuperior));

				this.repositorioFaturamento
						.atualizarIndicadorDebitoACobrarNoHistorico(colecaoDebitosACobrarTemporaria);

			}

		} catch (Exception e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Para cada crédito a realizar transferido para o histórico, atualiza o
	 * indicador de que o crédito a realizar está no histórico na tabela
	 * CreditoARealizarGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * 
	 * @param colecaoCreditosARealizar
	 * @throws ControladorException
	 */
	public void atualizarIndicadorCreditosARealizarNoHistorico(
			Collection colecaoCreditosARealizar) throws ControladorException {

		try {

			List colecaoTotalCreditosARealizar = (List) colecaoCreditosARealizar;
			int limiteSuperior;
			int limiteInferior;
			int limiteMaximo = colecaoTotalCreditosARealizar.size();
			int quantidadeMaximaPorColecao = 100;

			for (int i = 0; i < limiteMaximo; i = i + 100) {

				if (limiteMaximo < quantidadeMaximaPorColecao) {
					limiteInferior = 0;
					limiteSuperior = limiteMaximo;
				} else {
					limiteInferior = i;
					limiteSuperior = i + 100;

					if (limiteSuperior > limiteMaximo) {
						limiteSuperior = limiteMaximo;
					}
				}

				List colecaoCreditosARealizarTemporaria = new ArrayList();
				colecaoCreditosARealizarTemporaria
						.addAll(colecaoTotalCreditosARealizar.subList(
								limiteInferior, limiteSuperior));

				this.repositorioFaturamento
						.atualizarIndicadorCreditoARealizarNoHistorico(colecaoCreditosARealizarTemporaria);

			}

		} catch (Exception e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * 
	 * Este método se destina a validar todas as situações e particularidades da
	 * inserir guia de pagamento no momento da exibição.
	 * 
	 * [FS0003] Validar registro de atendimento [FS0007] Validar ordem de
	 * servico.
	 * 
	 * @author Rafael Pinto
	 * @date 02/11/2006
	 * 
	 * @param RegistroAtendimento
	 *            ,OrdemServico,idImovel,idCliente
	 */
	public void validarExibirInserirGuiaPagamento(RegistroAtendimento ra,
			OrdemServico ordemServico, Integer idImovel, Integer idCliente)
			throws ControladorException {

		// [FS0003] Validar registro de atendimento
		if (ra != null) {

			Imovel imovel = ra.getImovel();

			// Caso tenha informado o imóvel e não exista imóvel associado ao
			// Registro Atendimento
			if (idImovel != null && imovel == null) {
				throw new ControladorException(
						"atencao.registro_atendimento.nao.associado.imovel");
			}

			// Caso tenha informado o imóvel e o imóvel que esteja associado ao
			// Registro Atendimento
			// seja diferente do imóvel informado
			if (idImovel != null && imovel != null
					&& imovel.getId().intValue() != idImovel.intValue()) {
				throw new ControladorException(
						"atencao.registro_atendimento.associado.imovel", null,
						"" + imovel.getId());
			}

			// Caso tenha informado o cliente e o cliente informado não conste
			// na relação
			// de clientes do Registro Atendimento
			if (idCliente != null) {

				FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();

				filtro.adicionarParametro(new ParametroSimples(
						FiltroRegistroAtendimentoSolicitante.CLIENTE_ID,
						idCliente));

				filtro.adicionarParametro(new ParametroSimples(
						FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
						ra.getId()));

				// Pesquisa de acordo com os parâmetros informados no filtro
				Collection colecaoRegistros = this.getControladorUtil()
						.pesquisar(filtro,
								RegistroAtendimentoSolicitante.class.getName());

				// Verifica se a pesquisa retornou algum objeto para a coleção
				if (colecaoRegistros == null || colecaoRegistros.isEmpty()) {
					throw new ControladorException(
							"atencao.registro_atendimento.associado.cliente");
				}
			}

			// Caso a situação do Registro de Atendimento não seja encerrada
			if (ra.getAtendimentoMotivoEncerramento() != null) {
				throw new ControladorException(
						"atencao.registro_atendimento.esta.encerrado");
			}

			// Caso o tipo de solicitação do registro atendimento
			// não permita a geração de débito a cobrar
			if (ra.getSolicitacaoTipoEspecificacao()
					.getIndicadorGeracaoDebito().intValue() == ConstantesSistema.NAO
					.intValue()) {
				throw new ControladorException(
						"atencao.registro_atendimento.nao.permite.guia.pagamento");
			}

			// [FS0007] Validar ordem de servico.
		} else if (ordemServico != null) {

			// Caso a Ordem de Serviço não esteja associada a um Registro de
			// Atendimento
			if (ordemServico.getRegistroAtendimento() == null
					|| ordemServico.getRegistroAtendimento().getId() == null) {
				throw new ControladorException(
						"atencao.ordem_servico.nao.esta.associado.registro_atendimento");
			}

			RegistroAtendimento registroAtendimento = ordemServico
					.getRegistroAtendimento();
			Imovel imovel = registroAtendimento.getImovel();

			// Caso a Ordem de Serviço esteja associada a um Registro
			// Atendimento,o imóvel tenha sido informado
			// e não existe um imóvel associado ao Registro Atendimento
			if (idImovel != null && imovel == null) {
				throw new ControladorException(
						"atencao.ordem_servico.imovel.registro_atendimento.nao.associado");
			}

			// Caso tenha informado o imóvel e o imóvel que esteja associado ao
			// Registro Atendimento
			// seja diferente do imóvel informado
			if (idImovel != null && imovel != null
					&& imovel.getId().intValue() != idImovel.intValue()) {
				throw new ControladorException(
						"atencao.os.registro_atendimento.associado.imovel",
						null, "" + imovel.getId());
			}

			// Caso tenha informado o cliente e o cliente informado não conste
			// na relação
			// de clientes do Registro Atendimento
			if (idCliente != null) {

				FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();

				filtro.adicionarParametro(new ParametroSimples(
						FiltroRegistroAtendimentoSolicitante.CLIENTE_ID,
						idCliente));

				filtro.adicionarParametro(new ParametroSimples(
						FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
						registroAtendimento.getId()));

				// Pesquisa de acordo com os parâmetros informados no filtro
				Collection colecaoRegistros = this.getControladorUtil()
						.pesquisar(filtro,
								RegistroAtendimentoSolicitante.class.getName());

				// Verifica se a pesquisa retornou algum objeto para a coleção
				if (colecaoRegistros == null || colecaoRegistros.isEmpty()) {
					throw new ControladorException(
							"atencao.os.registro_atendimento.associado.cliente");
				}
			}
		}
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * 
	 * [SB00010] Gerar Linhas da Descrição dos Serviços e Tarifas
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Collection gerarLinhasDescricaoServicoTarifasRelatorio(EmitirContaHelper emitirContaHelper, String consumoRateio, Object[] parmsMedicaoHistorico, 
			Integer tipoMedicao, boolean contaHistorico) throws ControladorException {

		Collection<ContaLinhasDescricaoServicosTarifasTotalHelper> colecaoLinhasDescricaoServicosTarifasTotal = new ArrayList<ContaLinhasDescricaoServicosTarifasTotalHelper>();

		if (emitirContaHelper.getValorAgua() != null
				&& (emitirContaHelper.getValorAgua().compareTo(new BigDecimal("0.00")) == 1 && (emitirContaHelper.getValorRateioAgua() == null || (emitirContaHelper
						.getValorAgua().compareTo(emitirContaHelper.getValorRateioAgua()) != 0)))) {

			if (!contaHistorico) {
				colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasTarifaAguaRelatorio(emitirContaHelper, consumoRateio, parmsMedicaoHistorico,
						tipoMedicao, colecaoLinhasDescricaoServicosTarifasTotal);
			} else {
				colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasTarifaAguaRelatorioContaHistorico(emitirContaHelper, consumoRateio,
						parmsMedicaoHistorico, tipoMedicao, colecaoLinhasDescricaoServicosTarifasTotal);
			}
		}

		if (emitirContaHelper.getValorEsgoto() != null && emitirContaHelper.getValorEsgoto().compareTo(new BigDecimal("0.00")) == 1) {
			colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasTarifaEsgotoRelatorio(emitirContaHelper, colecaoLinhasDescricaoServicosTarifasTotal);
		}

		if ((emitirContaHelper.getDebitos() != null && emitirContaHelper.getDebitos().compareTo(new BigDecimal("0.00")) == 1)
				|| (emitirContaHelper.getValorRateioAgua() != null || emitirContaHelper.getValorRateioEsgoto() != null)) {

			colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasDebitoCobradosRelatorio(emitirContaHelper, colecaoLinhasDescricaoServicosTarifasTotal,
					contaHistorico);
		}

		if (emitirContaHelper.getValorCreditos() != null && emitirContaHelper.getValorCreditos().compareTo(new BigDecimal("0.00")) == 1) {
			colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasCreditosRealizadosRelatorio(emitirContaHelper, colecaoLinhasDescricaoServicosTarifasTotal,
					contaHistorico);
		}

		if (emitirContaHelper.getValorImpostos() != null && emitirContaHelper.getValorImpostos().compareTo(new BigDecimal("0.00")) == 1) {
			colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasImpostosRetidosRelatorio(emitirContaHelper, colecaoLinhasDescricaoServicosTarifasTotal,
					contaHistorico);
		}

		return colecaoLinhasDescricaoServicosTarifasTotal;

	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * 
	 * [SB00011] Gerar Linhas da Tarifa de Água
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasTarifaAguaRelatorio(
			EmitirContaHelper emitirContaHelper, String consumoRateio,
			Object[] parmsMedicaoHistorico, Integer tipoMedicao,
			Collection colecaoLinhasDescricaoServicosTarifasTotal)
			throws ControladorException {

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;

		String descricaoServicosTarifas1 = "";

		// -- Linha 1 --//
		descricaoServicosTarifas1 = "AGUA";
		contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
		contaLinhasDescricaoServicosTarifasTotalHelper
				.setDescricaoServicosTarifas(descricaoServicosTarifas1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper
				.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		Collection colecaoContaCategoriaComFaixas = null;
		try {
			colecaoContaCategoriaComFaixas = repositorioFaturamento
					.pesquisarContaCategoria(emitirContaHelper.getIdConta());
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (colecaoContaCategoriaComFaixas != null
				&& !colecaoContaCategoriaComFaixas.isEmpty()) {
			Iterator iteratorContaCategoriaComFaixas = colecaoContaCategoriaComFaixas
					.iterator();
			while (iteratorContaCategoriaComFaixas.hasNext()) {
				ContaCategoria contaCategoria = (ContaCategoria) iteratorContaCategoriaComFaixas
						.next();

				String descricaoServicosTarifas2 = "";

				// -- Linha 2 --//
				descricaoServicosTarifas2 = " ";
				// descricao da categoria
				descricaoServicosTarifas2 = descricaoServicosTarifas2
						+ Util.completaString(contaCategoria.getComp_id()
								.getCategoria().getDescricao(), 13);
				// quantidade de economias
				descricaoServicosTarifas2 = descricaoServicosTarifas2
						+ Util.adicionarZerosEsquedaNumero(3, ""
								+ contaCategoria.getQuantidadeEconomia());

				if (contaCategoria.getQuantidadeEconomia() == 1) {
					descricaoServicosTarifas2 = descricaoServicosTarifas2
							+ "  UNIDADE ";
				} else {
					descricaoServicosTarifas2 = descricaoServicosTarifas2
							+ "  UNIDADES ";
				}

				contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
				contaLinhasDescricaoServicosTarifasTotalHelper
						.setDescricaoServicosTarifas(descricaoServicosTarifas2);
				contaLinhasDescricaoServicosTarifasTotalHelper
						.setConsumoFaixa("");
				contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
				colecaoContaLinhasDescricaoServicosTarifasTotalHelper
						.add(contaLinhasDescricaoServicosTarifasTotalHelper);

				// -- Linha 3 --//
				contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
				String descricaoServicosTarifas3 = "";
				String consumoFaixa3 = "";
				String valor3 = "";
				if (parmsMedicaoHistorico == null) {
					descricaoServicosTarifas3 = " TARIFA MÍNIMA";

					// Valor da tarifa mínima de água para a categoria por
					// economia
					BigDecimal qtdEconomia = null;

					if (contaCategoria.getComp_id().getCategoria()
							.getFatorEconomias() != null) {

						qtdEconomia = Util.formatarMoedaRealparaBigDecimal(""
								+ contaCategoria.getComp_id().getCategoria()
										.getFatorEconomias());
					} else {

						qtdEconomia = Util.formatarMoedaRealparaBigDecimal(""
								+ contaCategoria.getQuantidadeEconomia());
					}

					String valorTarifaMinima = "";
					if (contaCategoria.getValorTarifaMinimaAgua() != null
							&& qtdEconomia != null) {
						BigDecimal valorTarifaMinimaBigDecimal = contaCategoria
								.getValorTarifaMinimaAgua().divide(qtdEconomia,
										2, RoundingMode.UP);
						valorTarifaMinima = Util
								.formatarMoedaReal(valorTarifaMinimaBigDecimal);
					}

					descricaoServicosTarifas3 = descricaoServicosTarifas3
							+ Util.completaStringComEspacoAEsquerda(
									valorTarifaMinima, 6);
					descricaoServicosTarifas3 = descricaoServicosTarifas3
							+ " POR UNIDADE";

					consumoFaixa3 = "MINIMO";
					consumoFaixa3 = consumoFaixa3 + Util.completaString("", 11);

					// valor da água para categoria
					String valorAgua = Util.formatarMoedaReal(contaCategoria
							.getValorAgua());
					valor3 = valorAgua;

					contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
					contaLinhasDescricaoServicosTarifasTotalHelper
							.setDescricaoServicosTarifas(descricaoServicosTarifas3);
					contaLinhasDescricaoServicosTarifasTotalHelper
							.setConsumoFaixa(consumoFaixa3);
					contaLinhasDescricaoServicosTarifasTotalHelper
							.setValor(valor3);
					colecaoContaLinhasDescricaoServicosTarifasTotalHelper
							.add(contaLinhasDescricaoServicosTarifasTotalHelper);

				} else {

					// recupera a coleção de conta categoria consumo faixa
					Collection colecaoContaCategoriaConsumoFaixa = null;
					try {
						colecaoContaCategoriaConsumoFaixa = repositorioFaturamento
								.pesquisarContaCategoriaFaixas(
										emitirContaHelper.getIdConta(),
										contaCategoria.getComp_id()
												.getCategoria().getId());
					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}

					// 2.3.1 caso existam faixas de consumo para conta/categoria
					if (colecaoContaCategoriaConsumoFaixa != null
							&& !colecaoContaCategoriaConsumoFaixa.isEmpty()) {

						// Consumo mínimo de água para a categoria por economia
						BigDecimal qtdEconomia = null;

						if (contaCategoria.getComp_id().getCategoria()
								.getFatorEconomias() != null) {

							qtdEconomia = Util
									.formatarMoedaRealparaBigDecimal(""
											+ contaCategoria.getComp_id()
													.getCategoria()
													.getFatorEconomias());
						} else {

							qtdEconomia = Util
									.formatarMoedaRealparaBigDecimal(""
											+ contaCategoria
													.getQuantidadeEconomia());
						}

						Integer idTipoCalculo = null;
						try {
							idTipoCalculo = repositorioFaturamento
									.pesquisarTipoCalculoConta(emitirContaHelper
											.getIdConta());
						} catch (ErroRepositorioException e) {
							e.printStackTrace();
						}

						if (idTipoCalculo == null
								|| !idTipoCalculo
										.equals(TarifaTipoCalculo.CALCULO_DIRETO_NA_FAIXA)) {
							descricaoServicosTarifas3 = " ATE ";

							BigDecimal consumoMinimoAgua = null;
							if (contaCategoria.getConsumoMinimoAgua() != null) {
								consumoMinimoAgua = Util
										.formatarMoedaRealparaBigDecimal(""
												+ contaCategoria
														.getConsumoMinimoAgua());
							}
							BigDecimal consumoMinimaBigDecimal = new BigDecimal(
									"0.00");
							if (consumoMinimoAgua != null
									&& qtdEconomia != null) {
								consumoMinimaBigDecimal = consumoMinimoAgua
										.divide(qtdEconomia, 2, RoundingMode.UP);
							}
							String consumoMinima = ""
									+ consumoMinimaBigDecimal.intValue();

							descricaoServicosTarifas3 = descricaoServicosTarifas3
									+ Util.completaStringComEspacoAEsquerda(
											consumoMinima, 2);

							descricaoServicosTarifas3 = descricaoServicosTarifas3
									+ " M3" + Util.completaString("", 7);
							descricaoServicosTarifas3 = descricaoServicosTarifas3
									+ "- R$";

							// valor da tarifa minima de agua para a categoria
							// por
							// economia
							BigDecimal valorTarifaMinimaBigDecimal = null;
							if (contaCategoria.getValorTarifaMinimaAgua() != null
									&& qtdEconomia != null) {
								valorTarifaMinimaBigDecimal = contaCategoria
										.getValorTarifaMinimaAgua()
										.divide(qtdEconomia, 2, RoundingMode.UP);
							}

							String valorTarifaMinima = Util
									.completaStringComEspacoAEsquerda(
											""
													+ Util.formatarMoedaReal(valorTarifaMinimaBigDecimal),
											6);

							descricaoServicosTarifas3 = descricaoServicosTarifas3
									+ valorTarifaMinima + " (POR UNIDADE)";

							// Consumo mínimo de água para a categoria
							if (contaCategoria.getConsumoMinimoAgua() != null
									&& !contaCategoria.getConsumoMinimoAgua()
											.equals("")) {
								consumoFaixa3 = Util
										.completaStringComEspacoAEsquerda(
												""
														+ contaCategoria
																.getConsumoMinimoAgua(),
												4);
							} else {
								consumoFaixa3 = Util
										.completaStringComEspacoAEsquerda("", 4);
							}
							consumoFaixa3 = consumoFaixa3 + " M3";

							// valor da tarifa mínima de agua para categoria
							String valorAguaCategoria = "";
							if (contaCategoria.getValorTarifaMinimaAgua() != null) {
								valorAguaCategoria = Util
										.formatarMoedaReal(contaCategoria
												.getValorTarifaMinimaAgua());
							}

							valor3 = valorAguaCategoria;

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setDescricaoServicosTarifas(descricaoServicosTarifas3);
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setConsumoFaixa(consumoFaixa3.trim());
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setValor(valor3);
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper
									.add(contaLinhasDescricaoServicosTarifasTotalHelper);
						}

						Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa
								.iterator();
						while (iteratorContaCategoriaConsumoFaixa.hasNext()) {
							ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) iteratorContaCategoriaConsumoFaixa
									.next();

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							String descricaoServicosTarifas4 = "";
							String consumoFaixa4 = "";
							String valor4 = "";

							// -- Linha 4 --//
							descricaoServicosTarifas4 = " ";

							// caso a faixa seja a ultima da tarifa de consumo
							if (contaCategoriaConsumoFaixa.getConsumoFaixaFim()
									.equals(999999)) {
								// Consumo inicial da faixa menos 1 m3
								String consumoInicialFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaInicio() - 1);

								// valor da tarifa na faixa
								String valorTarifaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorTarifaFaixa());

								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ "ACIMA DE";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ Util.completaStringComEspacoAEsquerda(
												consumoInicialFaixa, 3);
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ " M3  - R$";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ Util.completaStringComEspacoAEsquerda(
												valorTarifaFaixa, 6);
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ " POR M3";

								// consumo da agua na faixa

								// consumoFaixa4 = Util
								// .completaStringComEspacoAEsquerda(""
								// + contaCategoriaConsumoFaixa
								// .getConsumoAgua(), 6)
								consumoFaixa4 = Util
										.completaStringComEspacoAEsquerda(
												""
														+ contaCategoriaConsumoFaixa
																.getConsumoAgua()
														* qtdEconomia
																.intValue(), 6)
										+ " M3";

								// valor da agua na faixa
								BigDecimal valorAguaFaixa = contaCategoriaConsumoFaixa
										.getValorAgua().multiply(qtdEconomia)
										.setScale(Parcelamento.CASAS_DECIMAIS);

								valor4 = ""
										+ Util.formatarMoedaReal(valorAguaFaixa);

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setDescricaoServicosTarifas(descricaoServicosTarifas4);
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setConsumoFaixa(consumoFaixa4.trim());
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setValor(valor4);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper
										.add(contaLinhasDescricaoServicosTarifasTotalHelper);

							} else {
								if (contaCategoriaConsumoFaixa.getConsumoAgua() != null
										&& contaCategoriaConsumoFaixa
												.getValorAgua() != null) {

									// Consumo inicial da faixa
									String consumoInicialFaixa = ""
											+ (contaCategoriaConsumoFaixa
													.getConsumoFaixaInicio());
									// consumo final da faixa
									String consumoFinalFaixa = ""
											+ (contaCategoriaConsumoFaixa
													.getConsumoFaixaFim());
									// valor da tarifa na faixa
									String valorTarifaFaixa = Util
											.formatarMoedaReal(contaCategoriaConsumoFaixa
													.getValorTarifaFaixa());

									descricaoServicosTarifas4 = descricaoServicosTarifas4
											+ Util.completaStringComEspacoAEsquerda(
													consumoInicialFaixa, 2)
											+ " M3 A";
									descricaoServicosTarifas4 = descricaoServicosTarifas4
											+ Util.completaStringComEspacoAEsquerda(
													consumoFinalFaixa, 3)
											+ " M3";
									descricaoServicosTarifas4 = descricaoServicosTarifas4
											+ "   - R$";
									descricaoServicosTarifas4 = descricaoServicosTarifas4
											+ Util.completaStringComEspacoAEsquerda(
													valorTarifaFaixa, 6)
											+ " POR M3";

									// consumo de Agua na faixa
									// consumoFaixa4 = Util
									// .completaStringComEspacoAEsquerda(""
									// + contaCategoriaConsumoFaixa
									// .getConsumoAgua(), 6)
									consumoFaixa4 = Util
											.completaStringComEspacoAEsquerda(
													""
															+ contaCategoriaConsumoFaixa
																	.getConsumoAgua()
															* qtdEconomia
																	.intValue(),
													6)
											+ " M3";

									// valor da agua na faixa

									BigDecimal valorAguaFaixa = contaCategoriaConsumoFaixa
											.getValorAgua()
											.multiply(qtdEconomia)
											.setScale(
													Parcelamento.CASAS_DECIMAIS);

									valor4 = ""
											+ Util.formatarMoedaReal(valorAguaFaixa);

									// String valorAguaFaixa = Util
									// .formatarMoedaReal(contaCategoriaConsumoFaixa
									// .getValorAgua());
									//
									// valor4 = valorAguaFaixa;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setDescricaoServicosTarifas(descricaoServicosTarifas4);
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setConsumoFaixa(consumoFaixa4
													.trim());
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setValor(valor4);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
											.add(contaLinhasDescricaoServicosTarifasTotalHelper);
								}
							}
						}

					} else {
						// 2.3.2.

						descricaoServicosTarifas3 = " CONSUMO DE ÁGUA";
						consumoFaixa3 = Util.completaStringComEspacoAEsquerda(
								"" + contaCategoria.getConsumoAgua(), 6)
								+ " M3";
						/**
						 * Segunda via de conta com
						 * rateio está somando o valor de água da categoria com
						 * o valor do rateio.
						 * 
						 * @author Wellington Rocha
						 * @date 21/12/2012
						 */
						if (emitirContaHelper.getValorRateioAgua() != null) {
							valor3 = Util.formatarMoedaReal(contaCategoria
									.getValorAgua().subtract(
											emitirContaHelper
													.getValorRateioAgua()));
						} else {
							valor3 = Util.formatarMoedaReal(contaCategoria
									.getValorAgua());
						}

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper
								.setDescricaoServicosTarifas(descricaoServicosTarifas3);
						contaLinhasDescricaoServicosTarifasTotalHelper
								.setConsumoFaixa(consumoFaixa3.trim());
						contaLinhasDescricaoServicosTarifasTotalHelper
								.setValor(valor3);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper
								.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}

				}
			}
		}

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * 
	 * [SB00012] Gerar Linhas da Tarifa de Esgoto
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasTarifaEsgotoRelatorio(
			EmitirContaHelper emitirContaHelper,
			Collection colecaoLinhasDescricaoServicosTarifasTotal)
			throws ControladorException {

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();

		String descricaoServicosTarifas1 = "";
		String consumoFaixa1 = "";
		String valor1 = "";

		// StringBuilder linhasTarifaEsgoto = new StringBuilder();
		// -- Linha 1 --//
		descricaoServicosTarifas1 = "ESGOTO ";

		// caso o consumo de agua seja igual ao volume coletado de esgoto e o
		// valor de agua seja diferente de 0
		if (emitirContaHelper.getConsumoAgua().equals(
				emitirContaHelper.getConsumoEsgoto())
				&& emitirContaHelper.getValorAgua() != null
				&& !emitirContaHelper.getValorAgua().equals("0.00")) {
			// Percentual esgoto
			String percentualEsgoto = Util.formatarMoedaReal(emitirContaHelper
					.getPercentualEsgotoConta());

			descricaoServicosTarifas1 = descricaoServicosTarifas1
					+ Util.completaStringComEspacoAEsquerda(percentualEsgoto, 6);
			descricaoServicosTarifas1 = descricaoServicosTarifas1
					+ " % DO VALOR DA ÁGUA";

		} else {
			// Volume coletado de esgoto
			consumoFaixa1 = Util.completaStringComEspacoAEsquerda(""
					+ emitirContaHelper.getConsumoEsgoto(), 6);
			consumoFaixa1 = consumoFaixa1 + " M3";

			// Percentual esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper
					.getValorEsgoto());
			valor1 = valorEsgoto;
		}

		/**
		 *  Pamela Gatinho - 02/08/2012
		 * 
		 * Alteração para exibir somente o valor do esgoto, sem o ralor do
		 * rateio, que será mostrado separadamente em outra linha do documento.
		 */
		BigDecimal valorEsgotoSemRateio = new BigDecimal("0.00");
		if (emitirContaHelper.getValorRateioEsgoto() != null) {
			valorEsgotoSemRateio = emitirContaHelper.getValorEsgoto().subtract(
					emitirContaHelper.getValorRateioEsgoto());
		} else {
			valorEsgotoSemRateio = emitirContaHelper.getValorEsgoto();
		}

		// Percentual esgoto
		String valorEsgotoFinal = Util.formatarMoedaReal(valorEsgotoSemRateio);
		valor1 = valorEsgotoFinal;

		contaLinhasDescricaoServicosTarifasTotalHelper
				.setDescricaoServicosTarifas(descricaoServicosTarifas1);
		contaLinhasDescricaoServicosTarifasTotalHelper
				.setConsumoFaixa(consumoFaixa1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor1);
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper
				.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * 
	 * [SB0015] Gerar Linhas de Impostos Retidos
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasImpostosRetidosRelatorio(
			EmitirContaHelper emitirContaHelper,
			Collection colecaoLinhasDescricaoServicosTarifasTotal,
			boolean contaHistorico) throws ControladorException {

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;

		String descricaoServicosTarifas1 = "";

		// -- Linha 1 --//
		// Constante
		descricaoServicosTarifas1 = "DEDUCAO IMPOSTOS LEI FEDERAL N.9430 DE 27/12/1996";
		contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
		contaLinhasDescricaoServicosTarifasTotalHelper
				.setDescricaoServicosTarifas(descricaoServicosTarifas1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper
				.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		// -- Linha 2 --//
		String descricaoServicosTarifas2 = "";
		String valor2 = "";
		// Completa com espaços em branco
		descricaoServicosTarifas2 = Util.completaString("", 2);
		Collection colecaoParmsImpostosDeduzidos = null;
		try {
			if (!contaHistorico) {
				colecaoParmsImpostosDeduzidos = repositorioFaturamento
						.pesquisarParmsContaImpostosDeduzidos(emitirContaHelper
								.getIdConta());
			} else {
				colecaoParmsImpostosDeduzidos = repositorioFaturamento
						.pesquisarParmsContaImpostosDeduzidosHistorico(emitirContaHelper
								.getIdConta());
			}
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		StringBuilder descricaoAbreviadaImposto = new StringBuilder();
		BigDecimal valorImpostosTotal = new BigDecimal("0.00");
		// verifica se a coleção é diferente de nulo
		if (colecaoParmsImpostosDeduzidos != null
				&& !colecaoParmsImpostosDeduzidos.isEmpty()) {
			Iterator iteratorParmsImpostosDeduzidos = colecaoParmsImpostosDeduzidos
					.iterator();
			while (iteratorParmsImpostosDeduzidos.hasNext()) {
				Object[] parmsImpostoDeduzido = (Object[]) iteratorParmsImpostosDeduzidos
						.next();
				String descricaoTipoImposto = "";
				if (parmsImpostoDeduzido[0] != null) {
					descricaoTipoImposto = (String) parmsImpostoDeduzido[0];
				}
				String percentualAliquota = "";
				if (parmsImpostoDeduzido[1] != null) {
					percentualAliquota = Util
							.formatarMoedaReal((BigDecimal) parmsImpostoDeduzido[1]);
				}
				BigDecimal valorImpostos = null;
				if (parmsImpostoDeduzido[2] != null) {
					valorImpostos = (BigDecimal) parmsImpostoDeduzido[2];
				}
				// concatena a descrição abreviada do tipo de imposto com o
				// precentual de aliquota
				descricaoAbreviadaImposto.append(descricaoTipoImposto + "-"
						+ percentualAliquota + "%");
				// Completa com espaços em branco
				descricaoAbreviadaImposto.append(" ");
				// adiciona o valor dos impostos
				valorImpostosTotal = valorImpostosTotal.add(valorImpostos);
			}
		}
		// recupera a descrição abreviada concatenada com a aliquota
		String descricaoAbreviadaConcatenada = "";
		if (descricaoAbreviadaImposto != null
				&& !descricaoAbreviadaImposto.equals("")) {
			descricaoAbreviadaConcatenada = descricaoAbreviadaImposto
					.toString();
		}
		descricaoServicosTarifas2 = descricaoServicosTarifas2
				+ descricaoAbreviadaConcatenada;
		String valorImpostosTotalString = Util
				.formatarMoedaReal(valorImpostosTotal);
		valor2 = valorImpostosTotalString;

		contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
		contaLinhasDescricaoServicosTarifasTotalHelper
				.setDescricaoServicosTarifas(descricaoServicosTarifas2);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper
				.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * 
	 * [SB00013] Gerar Linhas de Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */

	protected Collection gerarLinhasDebitoCobradosRelatorio(
			EmitirContaHelper emitirContaHelper,
			Collection colecaoLinhasDescricaoServicosTarifasTotal,
			boolean contaHistorico) throws ControladorException {

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;

		// CRC4428 - Vivianne Sousa - 14/06/2010
		Collection<Object[]> collectionParmsDebitoAutomatico = null;
		// try {

		if (!contaHistorico) {
			collectionParmsDebitoAutomatico = this.pesquisarParmsDebitoAutomatico(emitirContaHelper.getIdConta());
		} else {
			collectionParmsDebitoAutomatico = this.pesquisarParmsDebitoAutomaticoHistorico(emitirContaHelper.getIdConta());
		}

		// } catch (ErroRepositorioException e) {
		// sessionContext.setRollbackOnly();
		// throw new ControladorException("erro.sistema", e);
		// }

		if (collectionParmsDebitoAutomatico != null) {

			Iterator iter = collectionParmsDebitoAutomatico.iterator();

			while (iter.hasNext()) {
				Object[] parmsDebitoAutomatico = (Object[]) iter.next();

				// caso a consulta retorne algum resultado
				if (parmsDebitoAutomatico != null) {
					String valorDebitosCobrados = "";
					String numeroPrestacao = "";
					Short numeroTotalPrestacao = 0;
					Short numeroParcelaBonus = 0;
					String totalPrestacaoMenosBonus = "";
					// valor acumulado dos debitos cobrados
					if (parmsDebitoAutomatico[0] != null) {
						valorDebitosCobrados = Util.formatarMoedaReal((BigDecimal) parmsDebitoAutomatico[0]);
					}
					// numero de prestação do débito
					if (parmsDebitoAutomatico[1] != null) {
						numeroPrestacao = "" + ((Short) parmsDebitoAutomatico[1]);
					}
					// valor acumulado dos debitos cobrados
					if (parmsDebitoAutomatico[2] != null) {
						numeroTotalPrestacao = (Short) parmsDebitoAutomatico[2];
					}

					/*
					 * Alterado por Vivianne Sousa em 21/12/2007 - Analista:
					 * Adriano criação do bonus para parcelamento com RD
					 * especial
					 */
					// numero parcela bonus
					if (parmsDebitoAutomatico[3] != null) {
						numeroParcelaBonus = (Short) parmsDebitoAutomatico[3];
					}
					totalPrestacaoMenosBonus = "" + (numeroTotalPrestacao.intValue() - numeroParcelaBonus.intValue());

					if (!valorDebitosCobrados.equals("0,00")) {
						String descricaoServicosTarifas1 = "";
						String valor1 = "";
						// -- Linha 1 --//
						descricaoServicosTarifas1 = "PARCELAMENTO DE DÉBITOS" + Util.completaString("", 2) + "PARCELA ";
						// numero da prestação do débito
						descricaoServicosTarifas1 = descricaoServicosTarifas1 + Util.completaStringComEspacoAEsquerda(numeroPrestacao, 3) + "/";
						// numero total da prestação do débito
						descricaoServicosTarifas1 = descricaoServicosTarifas1 + Util.completaString(totalPrestacaoMenosBonus, 3);
						valor1 = valorDebitosCobrados;

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas1);
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor1);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}
				}

			}
		}

		// CRC4428 - Vivianne Sousa - 14/06/2010
		List colecaoDebitoCobradoPorTipo = null;
		if (!contaHistorico) {
			colecaoDebitoCobradoPorTipo = this.pesquisarParmsDebitoCobradoPorTipo(emitirContaHelper.getIdConta());
		} else {
			colecaoDebitoCobradoPorTipo = this.pesquisarParmsDebitoCobradoHistoricoPorTipo(emitirContaHelper.getIdConta());
		}
		if (colecaoDebitoCobradoPorTipo != null && !colecaoDebitoCobradoPorTipo.isEmpty()) {
			ListIterator iteratorDebitoCobradoPorTipo = (ListIterator) colecaoDebitoCobradoPorTipo.listIterator();
			// variável responsável para controle de mudança do tipo de débito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// débito,que entra para ser escrito no txt só uma vez a
			// descrição do tipo do debito
			boolean primeiraVez = true;
			Integer idDebitoTipoVerificador = null;
			BigDecimal valorTotalPrestacoes = new BigDecimal("0.00");
			// valor da pretação
			BigDecimal valorPrestacao = null;
			// numero da pretação atual
			Integer numeroPrestacaoDebito = null;
			// numero total de prestações
			Integer numeroPrestacaoTotal = null;
			String totalPrestacaoMenosBonus = "";
			// colecao para guardar os ano/mes referencia do débito cobrado
			Collection colecaoAnoMesReferenciaDebito = new ArrayList();
			// cria um int que vai ver o tamanho da string builder
			// dependendo da quantidade de mes/ano referencia calcula os
			// espaços em brancos para o valor ficar no lugar certo
			// int tamanhoAnoMesReferencia = 0;
			String descricaoServicosTarifas2 = "";
			// String consumoFaixa2 = "";
			String valor2 = "";

			while (iteratorDebitoCobradoPorTipo.hasNext()) {
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoCobradoPorTipo.next();

				// recupera os parametros da coleção valor da pretação
				if (parmsDebitoCobradoPorTipo[0] != null) {
					valorPrestacao = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if (parmsDebitoCobradoPorTipo[1] != null) {
					numeroPrestacaoDebito = new Integer("" + (Short) parmsDebitoCobradoPorTipo[1]);
				}
				// numero total de prestações
				if (parmsDebitoCobradoPorTipo[2] != null) {
					numeroPrestacaoTotal = new Integer("" + (Short) parmsDebitoCobradoPorTipo[2]);
				}
				// ano Mes Referência do débito
				Integer anoMesReferencia = null;
				if (parmsDebitoCobradoPorTipo[3] != null) {
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idDebitoTipo = null;
				if (parmsDebitoCobradoPorTipo[4] != null) {
					idDebitoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do débito
				String descricaoDebitoTipo = null;
				if (parmsDebitoCobradoPorTipo[5] != null) {
					descricaoDebitoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}

				/*
				 * Alterado por Vivianne Sousa em 21/12/2007 - Analista: Adriano
				 * criação do bonus para parcelamento com RD especial
				 */
				Short numeroParcelaBonus = 0;
				// numero parcela bonus
				if (parmsDebitoCobradoPorTipo[6] != null) {
					numeroParcelaBonus = (Short) parmsDebitoCobradoPorTipo[6];
				}
				totalPrestacaoMenosBonus = "" + (numeroPrestacaoTotal.intValue() - numeroParcelaBonus.intValue());

				// muda o estado do boolean e o valor do débito tipo
				// verificador na primeira vez ou quando mudar o tipo
				if (mudou) {
					idDebitoTipoVerificador = idDebitoTipo;
					mudou = false;
					// tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if (idDebitoTipo.equals(idDebitoTipoVerificador)) {
					if (primeiraVez) {
						// -- Linha 2 --//
						// descrição do tipo de débito
						descricaoServicosTarifas2 = Util.completaString(descricaoDebitoTipo, 30);
						primeiraVez = false;
					}
					// adiciona o valor da prestação ao total
					valorTotalPrestacoes = valorTotalPrestacoes.add(valorPrestacao);
					// adiciona o ano/mes referencia na coleção
					if (anoMesReferencia != null) {
						colecaoAnoMesReferenciaDebito.add(anoMesReferencia);
					} else {
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + "PARCELA ";
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + Util.completaStringComEspacoAEsquerda("" + numeroPrestacaoDebito, 3);
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + "/" + Util.completaString(totalPrestacaoMenosBonus, 3);

						// Valor da pretação
						String valorPrestacaoString = Util.formatarMoedaReal(valorTotalPrestacoes);
						valor2 = valorPrestacaoString;

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}

				} else {
					// 4.1.2. caso a coleção dos meses de referência do
					// grupo do tipo de débito esteja preenchida
					if (colecaoAnoMesReferenciaDebito != null && !colecaoAnoMesReferenciaDebito.isEmpty()) {
						Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito.iterator();
						int i = 1;
						while (iteratorAnoMesReferenciaDebito.hasNext()) {
							Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito.next();
							String anoMesReferenciaDebitoString = null;
							if (i == 1) {
								// mes/ano referencia do débito
								anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;
								// caso exita somente um mes/ano de
								// referencia na lista
								if (colecaoAnoMesReferenciaDebito.size() == 1) {
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									valor2 = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

								} 
							} else {
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if (i == 2) {
									// -- Linha 3 --//
									// completa espaços em brancos
									descricaoServicosTarifas2 = " ";
									// mes/ano referencia do debito
									anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;

									// caso exita somente um mes/ano de
									// referencia na lista
									if (colecaoAnoMesReferenciaDebito.size() == 2) {
										// valor acumulado do tipo do débito
										String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
										valor2 = valorAcumulado;

										contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
										contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
										contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
										contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
										colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

									} else {
										// completa espaços em brancos
										descricaoServicosTarifas2 = descricaoServicosTarifas2 + " ";
									}

								} else {
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o
									// ultimo anoMes
									if ((colecaoAnoMesReferenciaDebito.size() - 1) <= 2) {

										// mes/ano referencia do credito
										anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
										descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;
										// caso não tenha outro ano mes na
										// coleção então completa a linha
										// com o valor
										if (!iteratorAnoMesReferenciaDebito.hasNext()) {
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
											valor2 = valorAcumulado;

											contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
											contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
											contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
											contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
											colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
										}

									} else {
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if (i < 3) {
											// mes/ano referencia do débito
											anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
											descricaoServicosTarifas2 = descricaoServicosTarifas2 + anoMesReferenciaDebitoString + " ";
										} else {
											// completa espaços em brancos
											descricaoServicosTarifas2 = descricaoServicosTarifas2 + " E OUTRAS";
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
											valor2 = valorAcumulado;

											contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
											contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
											contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
											contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
											colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
											break;
										}
									}
								}
							}
							i = i + 1;
						}

					}// limpa os campos
					valorTotalPrestacoes = new BigDecimal("0.00");
					colecaoAnoMesReferenciaDebito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoCobradoPorTipo.previous();
				}
			}

			// no caso de ser o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de débito esteja preenchida
			if (colecaoAnoMesReferenciaDebito != null && !colecaoAnoMesReferenciaDebito.isEmpty()) {
				Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito.iterator();
				int i = 1;
				while (iteratorAnoMesReferenciaDebito.hasNext()) {
					Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito.next();
					String anoMesReferenciaDebitoString = null;
					if (i == 1) {
						// mes/ano referencia do débito
						anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;

						if (colecaoAnoMesReferenciaDebito.size() == 1) {
							// valor acumulado do tipo do débito
							String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
							valor2 = valorAcumulado;

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
							contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
							contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
						} 
					} else {
						if (i == 2) {
							// -- Linha 3 --//
							anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
							descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;

							// caso exita somente um mes/ano de referencia
							// na lista
							if (colecaoAnoMesReferenciaDebito.size() == 2) {

								// valor acumulado do tipo do débito
								String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
								valor2 = valorAcumulado;

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
								contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
								contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
							}
						} else {
							// caso exista até mais 6 ocorrências na lista
							// de meses
							// -1 pq já foi colocado na string o ultimo
							// anoMes
							if ((colecaoAnoMesReferenciaDebito.size() - 1) <= 2) {

								// mes/ano referencia do credito
								anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;

								// caso não tenha outro ano mes na
								// coleção então completa a linha com o
								// valor
								if (!iteratorAnoMesReferenciaDebito.hasNext()) {
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									valor2 = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
								}

							} else {
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if (i < 3) {
									// mes/ano referencia do débito
									anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									descricaoServicosTarifas2 = descricaoServicosTarifas2 + anoMesReferenciaDebitoString + " ";
								} else {
									descricaoServicosTarifas2 = descricaoServicosTarifas2 + " E OUTRAS";

									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									valor2 = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
									break;
								}
							}
						}
					}
					i = i + 1;
				}

			}

		}

		Imovel imovel = this.getControladorImovel().pesquisarImovel(emitirContaHelper.getIdImovel());

		if (imovel.isImovelCondominio()) {

//			try {

				FaturamentoGrupo faturamentoGrupo = getControladorImovel().pesquisarGrupoImovel(imovel.getId());

				faturamentoGrupo.setAnoMesReferencia(emitirContaHelper.getAmReferencia());
				//BigDecimal[] valoresRateioAguaEsgotoImovel = this.calcularValorRateioImovel(imovel, faturamentoGrupo);

				// RATEIO DE ÁGUA
				String descricaoServicosTarifas1 = "";

				if (emitirContaHelper.getValorRateioAgua() != null) {
					descricaoServicosTarifas1 = "RATEIO DE CONSUMO DE ÁGUA";

					contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
					contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas1);
					contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
					contaLinhasDescricaoServicosTarifasTotalHelper.setValor(Util.formatarMoedaReal(emitirContaHelper.getValorRateioAgua()));

					colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
				}

				// RATEIO DE ESGOTO
				String descricaoServicosTarifas2 = "";

				if (emitirContaHelper.getValorRateioEsgoto() != null) {
					descricaoServicosTarifas2 = "RATEIO DE CONSUMO DE ESGOTO";

					contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
					contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
					contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
					contaLinhasDescricaoServicosTarifasTotalHelper.setValor(Util.formatarMoedaReal(emitirContaHelper.getValorRateioEsgoto()));

					colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
				}
//			} catch (ErroRepositorioException e) {
//				e.printStackTrace();
//			}
		}

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * 
	 * [SB00013] Gerar Linhas de Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasCreditosRealizadosRelatorio(
			EmitirContaHelper emitirContaHelper,
			Collection colecaoLinhasDescricaoServicosTarifasTotal,
			boolean contaHistorico) throws ControladorException {

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();

		String descricaoServicosTarifas = "";
		String valor = "";

		List colecaoCreditoRealizadoPorTipo = null;
		try {
			if (!contaHistorico) {
				colecaoCreditoRealizadoPorTipo = repositorioFaturamento
						.pesquisarParmsCreditoRealizadoPorTipo(emitirContaHelper
								.getIdConta());
			} else {
				colecaoCreditoRealizadoPorTipo = repositorioFaturamento
						.pesquisarParmsCreditoRealizadoHistoricoPorTipo(emitirContaHelper
								.getIdConta());
			}
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		if (colecaoCreditoRealizadoPorTipo != null
				&& !colecaoCreditoRealizadoPorTipo.isEmpty()) {
			ListIterator iteratorDebitoRealizadoPorTipo = (ListIterator) colecaoCreditoRealizadoPorTipo
					.listIterator();
			// variável responsável para controle de mudança do tipo de
			// credito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// credito,que entra para ser escrito
			// no txt só uma vez a descrição do tipo do credito
			boolean primeiraVez = true;
			Integer idCreditoTipoVerificador = null;
			BigDecimal valorTotalCredito = new BigDecimal("0.00");
			BigDecimal valorCredito = null;
			Short numeroCredito = null;
			// numero total de créditos
			Short numeroCreditoTotal = null;
			String numeroCreditoTotalMenosBonus = "";
			// cria um int que vai ver o tamanho da string builder
			// dependendo da quantidade
			// de mes/ano referencia calcula os espaços em brancos
			// para o valor ficar no lugar certo
			// int tamanhoAnoMesReferencia = 0;
			// caso não seja a primeira vez que entre no boolean primeira
			// vez(que nesse caso é quando troca o tipo de credito)
			// boolean primeiraVezIndependenteTipo = false;
			// colecao para guardar os ano/mes referencia do credito realizado
			Collection colecaoAnoMesReferenciaCredito = new ArrayList();
			while (iteratorDebitoRealizadoPorTipo.hasNext()) {
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoRealizadoPorTipo
						.next();

				// recupera os parametros da coleção
				// valor do crédito
				if (parmsDebitoCobradoPorTipo[0] != null) {
					valorCredito = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if (parmsDebitoCobradoPorTipo[1] != null) {
					numeroCredito = (Short) parmsDebitoCobradoPorTipo[1];
				}

				if (parmsDebitoCobradoPorTipo[2] != null) {
					numeroCreditoTotal = (Short) parmsDebitoCobradoPorTipo[2];
				}
				// ano Mes Referência do crédito
				Integer anoMesReferencia = null;
				if (parmsDebitoCobradoPorTipo[3] != null) {
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idCreditoTipo = null;
				if (parmsDebitoCobradoPorTipo[4] != null) {
					idCreditoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do credito
				String descricaoCreditoTipo = null;
				if (parmsDebitoCobradoPorTipo[5] != null) {
					descricaoCreditoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}
				/*
				 * Alterado por Vivianne Sousa em 21/12/2007 - Analista: Adriano
				 * criação do bonus para parcelamento com RD especial
				 */
				Short numeroParcelaBonus = 0;
				// numero parcela bonus
				if (parmsDebitoCobradoPorTipo[6] != null) {
					numeroParcelaBonus = (Short) parmsDebitoCobradoPorTipo[6];
				}
				numeroCreditoTotalMenosBonus = ""
						+ (numeroCreditoTotal.intValue() - numeroParcelaBonus
								.intValue());
				// muda o estado do boolean e o valor do credito tipo
				// verificador
				// na primeira vez ou quando mudar o tipo
				if (mudou) {
					idCreditoTipoVerificador = idCreditoTipo;
					mudou = false;
					// tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if (idCreditoTipo.equals(idCreditoTipoVerificador)) {
					if (primeiraVez) {
						// proxima linha
						// if (primeiraVezIndependenteTipo) {
						// linhasCreditosRealizados.append(System
						// .getProperty("line.separator"));
						// }
						// -- Linha 1 --//

						// descrição do tipo de credito
						descricaoServicosTarifas = descricaoCreditoTipo;

						primeiraVez = false;
						// primeiraVezIndependenteTipo = true;
					}
					// adiciona o valor do credito ao total
					valorTotalCredito = valorTotalCredito.add(valorCredito);
					// adiciona o ano/mes referencia na coleção
					if (anoMesReferencia != null) {
						colecaoAnoMesReferenciaCredito.add(anoMesReferencia);
					} else {
						// -- Linha 1 (CONTINUAÇÂO)--//
						// Constante
						descricaoServicosTarifas = descricaoServicosTarifas
								+ "PARCELA ";
						descricaoServicosTarifas = descricaoServicosTarifas
								+ Util.completaStringComEspacoAEsquerda(""
										+ numeroCredito, 3) + "/";
						descricaoServicosTarifas = descricaoServicosTarifas
								+ Util.completaString(
										numeroCreditoTotalMenosBonus, 3);

						// Valor da pretação
						String valorCreditoString = Util
								.formatarMoedaReal(valorCredito);
						valor = valorCreditoString;

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper
								.setDescricaoServicosTarifas(descricaoServicosTarifas);
						contaLinhasDescricaoServicosTarifasTotalHelper
								.setConsumoFaixa("");
						contaLinhasDescricaoServicosTarifasTotalHelper
								.setValor(valor);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper
								.add(contaLinhasDescricaoServicosTarifasTotalHelper);

					}

				} else {
					// caso a coleção dos meses de referência do grupo do
					// tipo de credito esteja preenchida
					if (colecaoAnoMesReferenciaCredito != null
							&& !colecaoAnoMesReferenciaCredito.isEmpty()) {
						Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito
								.iterator();
						int i = 1;
						while (iteratorAnoMesReferenciaCredito.hasNext()) {
							Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito
									.next();
							String anoMesReferenciaCreditoString = null;
							if (i == 1) {
								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								descricaoServicosTarifas = descricaoServicosTarifas
										+ " " + anoMesReferenciaCreditoString;

								// caso exita somente um mes/ano de
								// referencia na lista
								if (colecaoAnoMesReferenciaCredito.size() == 1) {

									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									valor = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setDescricaoServicosTarifas(descricaoServicosTarifas);
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setValor(valor);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
											.add(contaLinhasDescricaoServicosTarifasTotalHelper);

								} else {
									// completa espaços em brancos
									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setDescricaoServicosTarifas(descricaoServicosTarifas);
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setValor("");
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
											.add(contaLinhasDescricaoServicosTarifasTotalHelper);
								}
							} else {
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if (i == 2) {
									// -- Linha 3 --//

									// mes/ano referencia do credito
									anoMesReferenciaCreditoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									descricaoServicosTarifas = descricaoServicosTarifas
											+ " "
											+ anoMesReferenciaCreditoString;

									// caso exita somente um mes/ano de
									// referencia na lista
									if (colecaoAnoMesReferenciaCredito.size() == 2) {

										// valor acumulado do tipo do débito
										String valorAcumulado = Util
												.formatarMoedaReal(valorTotalCredito);
										valor = valorAcumulado;

										contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
										contaLinhasDescricaoServicosTarifasTotalHelper
												.setDescricaoServicosTarifas(descricaoServicosTarifas);
										contaLinhasDescricaoServicosTarifasTotalHelper
												.setConsumoFaixa("");
										contaLinhasDescricaoServicosTarifasTotalHelper
												.setValor(valor);
										colecaoContaLinhasDescricaoServicosTarifasTotalHelper
												.add(contaLinhasDescricaoServicosTarifasTotalHelper);

									} else {
										// completa espaços em brancos
										descricaoServicosTarifas = descricaoServicosTarifas
												+ " ";
									}
								} else {
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o
									// ultimo anoMes
									if ((colecaoAnoMesReferenciaCredito.size() - 1) <= 6) {

										// mes/ano referencia do credito
										anoMesReferenciaCreditoString = Util
												.formatarAnoMesParaMesAno(anoMesReferenciaCredito);

										descricaoServicosTarifas = descricaoServicosTarifas
												+ anoMesReferenciaCreditoString
												+ " ";

										// caso não tenha outro ano mes na
										// coleção então
										// completa a linha com o valor
										if (!iteratorAnoMesReferenciaCredito
												.hasNext()) {

											// valor acumulado do tipo do débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalCredito);
											valor = valorAcumulado;

											contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
											contaLinhasDescricaoServicosTarifasTotalHelper
													.setDescricaoServicosTarifas(descricaoServicosTarifas);
											contaLinhasDescricaoServicosTarifasTotalHelper
													.setConsumoFaixa("");
											contaLinhasDescricaoServicosTarifasTotalHelper
													.setValor(valor);
											colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);

										}

									} else {
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if (i < 7) {
											// mes/ano referencia do débito
											anoMesReferenciaCreditoString = Util
													.formatarAnoMesParaMesAno(anoMesReferenciaCredito);

											descricaoServicosTarifas = descricaoServicosTarifas
													+ anoMesReferenciaCreditoString
													+ " ";

										} else {
											descricaoServicosTarifas = descricaoServicosTarifas
													+ " E OUTRAS";

											// valor acumulado do tipo do débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalCredito);
											valor = valorAcumulado;

											contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
											contaLinhasDescricaoServicosTarifasTotalHelper
													.setDescricaoServicosTarifas(descricaoServicosTarifas);
											contaLinhasDescricaoServicosTarifasTotalHelper
													.setConsumoFaixa("");
											contaLinhasDescricaoServicosTarifasTotalHelper
													.setValor(valor);
											colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);
											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					}
					// limpa os campos
					valorTotalCredito = new BigDecimal("0.00");
					colecaoAnoMesReferenciaCredito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoRealizadoPorTipo.previous();
				}
			}
			// No caso de ter o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de credito esteja preenchida
			if (colecaoAnoMesReferenciaCredito != null
					&& !colecaoAnoMesReferenciaCredito.isEmpty()) {
				Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito
						.iterator();
				int i = 1;
				while (iteratorAnoMesReferenciaCredito.hasNext()) {
					Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito
							.next();
					String anoMesReferenciaCreditoString = null;
					if (i == 1) {
						// mes/ano referencia do credito
						anoMesReferenciaCreditoString = Util
								.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
						descricaoServicosTarifas = descricaoServicosTarifas
								+ " " + anoMesReferenciaCreditoString;

						// caso exita somente um mes/ano de
						// referencia na lista
						if (colecaoAnoMesReferenciaCredito.size() == 1) {

							// valor acumulado do tipo do débito
							String valorAcumulado = Util
									.formatarMoedaReal(valorTotalCredito);
							valor = valorAcumulado;

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setDescricaoServicosTarifas(descricaoServicosTarifas);
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setConsumoFaixa("");
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setValor(valor);
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper
									.add(contaLinhasDescricaoServicosTarifasTotalHelper);

						} else {
							// completa espaços em brancos
							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setDescricaoServicosTarifas(descricaoServicosTarifas);
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setConsumoFaixa("");
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setValor("");
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper
									.add(contaLinhasDescricaoServicosTarifasTotalHelper);
						}
					} else {
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if (i == 2) {
							// -- Linha 3 --//

							// mes/ano referencia do credito
							anoMesReferenciaCreditoString = Util
									.formatarAnoMesParaMesAno(anoMesReferenciaCredito);

							descricaoServicosTarifas = descricaoServicosTarifas
									+ " " + anoMesReferenciaCreditoString;

							// caso exita somente um mes/ano de referencia na
							// lista
							if (colecaoAnoMesReferenciaCredito.size() == 2) {

								// valor acumulado do tipo do débito
								String valorAcumulado = Util
										.formatarMoedaReal(valorTotalCredito);
								valor = valorAcumulado;

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setDescricaoServicosTarifas(descricaoServicosTarifas);
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setConsumoFaixa("");
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setValor(valor);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper
										.add(contaLinhasDescricaoServicosTarifasTotalHelper);

							} else {
								// completa espaços em brancos
								descricaoServicosTarifas = descricaoServicosTarifas
										+ " ";
							}
						} else {
							// caso exista até mais 6 ocorrências na lista de
							// meses
							// -1 pq já foi colocado na string o ultimo anoMes
							if ((colecaoAnoMesReferenciaCredito.size() - 1) <= 6) {

								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								descricaoServicosTarifas = descricaoServicosTarifas
										+ anoMesReferenciaCreditoString + " ";

								// caso não tenha outro ano mes na
								// coleção então
								// completa a linha com o valor
								if (!iteratorAnoMesReferenciaCredito.hasNext()) {

									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									valor = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setDescricaoServicosTarifas(descricaoServicosTarifas);
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setValor(valor);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
											.add(contaLinhasDescricaoServicosTarifasTotalHelper);
								}

							} else {
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if (i < 7) {
									// mes/ano referencia do débito
									anoMesReferenciaCreditoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									descricaoServicosTarifas = descricaoServicosTarifas
											+ anoMesReferenciaCreditoString
											+ " ";
								} else {
									descricaoServicosTarifas = descricaoServicosTarifas
											+ " E OUTRAS";

									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									valor = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setDescricaoServicosTarifas(descricaoServicosTarifas);
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper
											.setValor(valor);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
											.add(contaLinhasDescricaoServicosTarifasTotalHelper);
									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}
		}

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * Seleciona as contas agrupando por imóvel
	 * 
	 * [UC0485] - Gerar Resumo dos Devedores Duvidosos
	 * 
	 * @author Rafael Pinto, Pedro Alexandre
	 * @date 22/11/2006, 08/06/2007
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * 
	 * @throws ErroRepositorioException
	 */

	public HashMap obterContaAgrupadasPorImovel(int anoMesReferenciaContabil,
			int idLocalidade, int idQuadra) throws ControladorException {

		HashMap mapContasPorImovel = new HashMap();

		Iterator itera = null;

		Collection<Conta> dadosContas = null;
		try {

			dadosContas = this.repositorioFaturamento
					.obterContaAgrupadasPorImovel(anoMesReferenciaContabil,
							idLocalidade, idQuadra);

			if (dadosContas != null && !dadosContas.isEmpty()) {

				itera = dadosContas.iterator();

				while (itera.hasNext()) {

					Conta conta = (Conta) itera.next();

					boolean indicadorClienteResponsavel = repositorioFaturamento
							.verificarExistenciaClienteResponsavelConta(conta
									.getId());

					if (!indicadorClienteResponsavel) {

						Integer chaveImovel = conta.getImovel().getId();
						if (!mapContasPorImovel.containsKey(chaveImovel)) {

							Collection colecao = new ArrayList();
							colecao.add(conta);

							mapContasPorImovel.put(chaveImovel, colecao);
						} else {

							Collection colecao = (ArrayList) mapContasPorImovel
									.get(chaveImovel);
							colecao.add(conta);

							mapContasPorImovel.put(chaveImovel, colecao);
						}

					}

					conta = null;
				}
			}

			// numeroIndice = numeroIndice + 10000;
			//
			// if (dadosContas == null || dadosContas.size() <
			// quantidadeRegistros) {
			// flagTerminou = true;
			// }

		} catch (Exception e) {

			// sessionContext.setRollbackOnly();

			throw new ControladorException("erro.sistema", e);
		}

		return mapContasPorImovel;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 23/11/2006
	 * 
	 * @param filtroImovel
	 * @param usuarioLogado
	 * @return
	 * @throws ControladorException
	 */
	public Imovel pesquisarImovelContaManter(FiltroImovel filtroImovel,
			Usuario usuarioLogado) throws ControladorException {

		Imovel imovel = null;

		imovel = (Imovel) Util.retonarObjetoDeColecao(this.getControladorUtil()
				.pesquisar(filtroImovel, Imovel.class.getName()));

		// ------------ CONTROLE DE ABRANGENCIA ----------------
		Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

		if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.acesso.negado.abrangencia");
		}

		// ------------ FIM CONTROLE DE ABRANGENCIA ------------

		return imovel;
	}

	/**
	 * 
	 * 
	 * Utilizado pelo [UC0] Manter Conta
	 * 
	 * @author Rafael Santos
	 * @date 23/11/2006
	 * 
	 * @param idConta
	 * @param dataUltimaAlteracao
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Object pesquisarDataUltimaAlteracaoConta(Integer idConta)
			throws ControladorException {
		try {

			return this.repositorioFaturamento
					.pesquisarDataUltimaAlteracaoConta(idConta);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	public void atualizarDataHoraRealizacaoAtividade(Integer idAtividade,
			Integer anoMesReferencia, Integer idFaturamentoGrupo)
			throws ControladorException {
		try {
			repositorioFaturamento.atualizarDataHoraRealizacaoAtividade(
					idAtividade, anoMesReferencia, idFaturamentoGrupo);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Recupera a data de realização passando o id do imovel e a quantidade de
	 * meses que quer subtrair,caso não queira subtrair colocar 0 [UC0488]
	 * Informar Retorno Ordem de Fiscalização
	 * 
	 * [SB0004] - Calcular Valor de Água e/ou Esgoto
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 04/12/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Date pesquisarDataRealizacaoFaturamentoAtividadeCronagrama(
			Integer idImovel, int quantidadeMeses) throws ControladorException {

		Date dataRealizacao = null;
		try {
			Object[] parmsFaturamentoGrupo = repositorioFaturamento
					.pesquisarParmsFaturamentoGrupo(idImovel);
			Integer idFaturamentoGrupo = null;
			Integer anoMesFaturamentoGrupo = null;
			if (parmsFaturamentoGrupo != null) {
				if (parmsFaturamentoGrupo[0] != null) {
					idFaturamentoGrupo = (Integer) parmsFaturamentoGrupo[0];
				}
				if (parmsFaturamentoGrupo[1] != null) {
					anoMesFaturamentoGrupo = (Integer) parmsFaturamentoGrupo[1];
				}
			}
			if (idFaturamentoGrupo != null && anoMesFaturamentoGrupo != null) {
				// caso a quantidades de meses que quer subitrair seja diferente
				// de 0
				if (quantidadeMeses > 0) {
					anoMesFaturamentoGrupo = Util.subtrairMesDoAnoMes(
							anoMesFaturamentoGrupo, quantidadeMeses);
				}
				Integer idFaturamentoAtividade = FaturamentoAtividade.EFETUAR_LEITURA;
				// pesquisa a data de realização
				dataRealizacao = repositorioFaturamento
						.pesquisarDataRealizacaoFaturamentoAtividadeCronograma(
								idFaturamentoGrupo, idFaturamentoAtividade,
								anoMesFaturamentoGrupo);
			}
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return dataRealizacao;

	}

	/**
	 * Resgata Colecao de contas a apartir do imovel e de um determinad periodo
	 * Tiago Moreno
	 */

	public Collection obterContasImovelIntervalo(Integer imovel,
			Integer situacaoNormal, Integer situacaoIncluida,
			Integer situacaoRetificada, Integer anoMesInicio,
			Integer anoMesFim, Integer idContaMotivoRevisao)
			throws ControladorException {

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoContasManutencaoArray = null;

		try {

			if (idContaMotivoRevisao != null
					&& !idContaMotivoRevisao.equals("")) {
				colecaoContasManutencaoArray = repositorioFaturamento
						.obterContasImovelIntervalo(imovel, situacaoNormal,
								situacaoIncluida, situacaoRetificada,
								anoMesInicio, anoMesFim, idContaMotivoRevisao);
			} else {
				colecaoContasManutencaoArray = repositorioFaturamento
						.obterContasImovelIntervalo(imovel, situacaoNormal,
								situacaoIncluida, situacaoRetificada,
								anoMesInicio, anoMesFim);
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoContasManutencaoArray != null
				&& !colecaoContasManutencaoArray.isEmpty()) {

			Iterator colecaoContasManutencaoArrayIterator = colecaoContasManutencaoArray
					.iterator();

			while (colecaoContasManutencaoArrayIterator.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] contaArray = (Object[]) colecaoContasManutencaoArrayIterator
						.next();

				Conta conta = new Conta();

				// ID da conta
				conta.setId((Integer) contaArray[0]);

				// Ano Mês referencia
				conta.setReferencia((Integer) contaArray[1]);

				// Data de vencimento
				String vencimento = String.valueOf(contaArray[2]);

				SimpleDateFormat formatoData = new SimpleDateFormat(
						"yyyy-MM-dd");

				Date dataVencimento;

				try {
					dataVencimento = formatoData.parse(vencimento);
				} catch (java.text.ParseException e) {
					dataVencimento = null;
				}

				conta.setDataVencimentoConta(dataVencimento);

				// Valor de água
				conta.setValorAgua((BigDecimal) contaArray[3]);

				// Valor de esgoto
				conta.setValorEsgoto((BigDecimal) contaArray[4]);

				// Valor dos débitos
				conta.setDebitos((BigDecimal) contaArray[5]);

				// Valor dos créditos
				conta.setValorCreditos((BigDecimal) contaArray[6]);

				// Consumo de água
				conta.setConsumoAgua((Integer) contaArray[7]);

				// Consumo de esgoto
				conta.setConsumoEsgoto((Integer) contaArray[8]);

				// Data de validade
				String validade = String.valueOf(contaArray[9]);

				Date dataValidade;

				try {
					dataValidade = formatoData.parse(validade);
				} catch (java.text.ParseException e) {
					dataValidade = null;
				}

				conta.setDataValidadeConta(dataValidade);

				// Data de revisao
				String revisao = String.valueOf(contaArray[10]);

				Date dataRevisao;

				try {
					dataRevisao = formatoData.parse(revisao);
				} catch (java.text.ParseException e) {
					dataRevisao = null;
				}

				conta.setDataRevisao(dataRevisao);

				// DebitoCreditoSituacaoAtual
				conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);

				// Ano Mês referencia contábil
				conta.setReferenciaContabil((Integer) contaArray[12]);

				// ultima Alteracao

				SimpleDateFormat formatoDataEspecifico = new SimpleDateFormat(
						"yyyy-MM-dd HH:mm:ss");

				String ultimaAlteracao = String.valueOf(contaArray[13]);

				Date dataUltimaAlteracao;

				try {
					dataUltimaAlteracao = formatoDataEspecifico
							.parse(ultimaAlteracao);
				} catch (java.text.ParseException e) {
					dataUltimaAlteracao = null;
				}

				conta.setUltimaAlteracao(dataUltimaAlteracao);

				Imovel objImovel = new Imovel();
				objImovel.setId(imovel);
				conta.setImovel(objImovel);

				retorno.add(conta);
			}
		}

		return retorno;
	}

	/**
	 * [UC113] Faturar Grupo Faturamento
	 * 
	 * Apaga todas as contas existentes para uma rota em um determinado anoMês
	 * de referência que estajam com a situação atual igual a situação recebida
	 * pelo método.
	 * 
	 * @author Rafael Santos, Raphael Rossiter
	 * @date 02/01/2007, 24/03/2008
	 * 
	 * @param ApagarDadosFaturamentoHelper
	 *            helper
	 * @param int atividade
	 */
	protected boolean apagarDadosGeradosFaturarGrupoFaturamento(
			ApagarDadosFaturamentoHelper helper, int atividade)
			throws ControladorException {

		boolean existeContasApagadas = false;
		if (atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()) {
			
			Integer quantidadeContas = null;
			try {

				quantidadeContas = repositorioFaturamento.quantidadeContasRota(
						helper.getAnoMesFaturamento(), helper.getRota(),
						helper.getIdDebitoCreditoSituacaoAtual(),
						helper.getIdImovel());

			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (quantidadeContas != null && quantidadeContas.intValue() > 0) {
				
				System.out.println("**============ 1 - apagarDadosGeradosFaturarGrupoFaturamento ===============**"
									+ "\n Imovel: " + helper.getIdImovel());

				try {
					repositorioFaturamento.apagarContaImpressao(helper);
					repositorioFaturamento.apagarContaCategoriaConsumoFaixa(helper);
					repositorioFaturamento.apagarContaCategoria(helper);
					repositorioFaturamento.apagarClienteConta(helper);
					repositorioFaturamento.apagarContaImpostosDeduzidos(helper);
					repositorioFaturamento.apagarDebitoAutomaticoMovimento(helper);
					
					repositorioFaturamento.apagarDebitoCobradoCategoria(helper);
					repositorioFaturamento.apagarDebitoCobrado(helper);
					repositorioFaturamento.apagarCreditoRealizadoCategoria(helper);
					repositorioFaturamento.apagarCreditoRealizado(helper);
					
					repositorioFaturamento.atualizarDebitoACobrar(helper);
					//repositorioFaturamento.atualizarCreditoARealizar(helper);
					repositorioFaturamento.atualizarContaGeral(helper);
					
					repositorioFaturamento.apagarDadosCobranca(helper);
					repositorioFaturamento.apagarConta(helper);
					
					existeContasApagadas = true;
				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}
			}
		}
		
		return existeContasApagadas;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Atualiza o ano/mês de referência do faturamento somando mais um mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 08/01/2007
	 * 
	 * @param anoMesFaturamentoSistemaParametro
	 * @throws ControladorException
	 */
	public void atualizarAnoMesFaturamento(
			Integer anoMesFaturamentoSistemaParametro)
			throws ControladorException {
		try {
			// item 12
			// responsável por atualizar o ano/mês de
			// faturamento da tabela de parâmetros do sistema
			repositorioFaturamento.atualizarAnoMesfaturamento(
					anoMesFaturamentoSistemaParametro,
					Util.somarData(anoMesFaturamentoSistemaParametro));
			// fim item 12
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * Pesquisar os ids das localidades para encerrar o faturamento do mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 08/01/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarIdsLocalidadeParaEncerrarFaturamento()
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarIdsLocalidadeParaEncerrarFaturamento();
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Pesquisar os ids das localidades para gerar o resumo das
	 * ligações/economias.
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/01/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarIdsLocalidadeParaGerarResumoLigacoesEconomias()
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarIdsLocalidadeParaEncerrarFaturamento();
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	public Collection<EmitirContaHelper> formatarEmitirContasHelper(
			Collection colecaoPamsContas, int tipoConta) throws ControladorException {
		Collection<EmitirContaHelper> colecaoContas = new ArrayList();

		if (colecaoPamsContas != null) {
			Iterator iteColecaoContas = colecaoPamsContas.iterator();

			while (iteColecaoContas.hasNext()) {
				Object[] parmsConta = (Object[]) iteColecaoContas.next();
				if (parmsConta != null) {
					EmitirContaHelper emitirContaHelper = new EmitirContaHelper();

					if (parmsConta[0] != null) {
						emitirContaHelper.setIdConta((Integer) parmsConta[0]);
					}

					if (tipoConta == 3 || tipoConta == 4 || tipoConta == 7 || tipoConta == 8) {
						if (parmsConta[1] != null) {
							String nomeCliente = this.obterNomeCliente(emitirContaHelper.getIdConta());
							emitirContaHelper.setNomeCliente(nomeCliente);
						}

						if (parmsConta[32] != null) {
							emitirContaHelper.setNomeImovel((String) parmsConta[32]);
						}
					} else {
						if (parmsConta[1] != null) {
							String nomeCliente = this.obterNomeCliente(emitirContaHelper.getIdConta());
							emitirContaHelper.setNomeCliente(nomeCliente);
						}
					}

					if (parmsConta[2] != null) {
						emitirContaHelper.setDataVencimentoConta((Date) parmsConta[2]);
					}
					if (parmsConta[3] != null) {
						emitirContaHelper.setAmReferencia((Integer) parmsConta[3]);
					}
					if (parmsConta[4] != null) {
						emitirContaHelper.setDigitoVerificadorConta((Short) parmsConta[4]);
					}
					if (parmsConta[5] != null) {
						emitirContaHelper.setCodigoSetorComercialConta((Integer) parmsConta[5]);
					}
					if (parmsConta[6] != null) {
						emitirContaHelper.setIdQuadraConta((Integer) parmsConta[6]);
					}
					if (parmsConta[7] != null) {
						emitirContaHelper.setLoteConta((Short) parmsConta[7]);
					}
					if (parmsConta[8] != null) {
						emitirContaHelper.setSubLoteConta((Short) parmsConta[8]);
					}
					if (parmsConta[9] != null) {
						emitirContaHelper.setConsumoAgua((Integer) parmsConta[9]);
					}
					if (parmsConta[10] != null) {
						emitirContaHelper.setConsumoEsgoto((Integer) parmsConta[10]);
					}

					int tam = parmsConta.length;

					if (parmsConta[11] != null) {
						BigDecimal valorAgua = (BigDecimal) parmsConta[11];
						if (tam > 42) {
							if (parmsConta[43] != null) {
								BigDecimal valorRateio = (BigDecimal) parmsConta[43];
								valorAgua = valorAgua.subtract(valorRateio);
								if (valorAgua.compareTo(BigDecimal.ZERO) == -1)
									valorAgua = valorAgua.negate();
							}
						}
						emitirContaHelper.setValorAgua(valorAgua);
					}
					if (parmsConta[12] != null) {
						BigDecimal valorEsgoto = (BigDecimal) parmsConta[12];
						if (tam > 42) {
							if (parmsConta[44] != null) {
								BigDecimal valorRateio = (BigDecimal) parmsConta[44];
								valorEsgoto = valorEsgoto.subtract(valorRateio);
								if (valorEsgoto.compareTo(BigDecimal.ZERO) == -1)
									valorEsgoto = valorEsgoto.negate();
							}
						}
						emitirContaHelper.setValorEsgoto(valorEsgoto);
					}
					if (parmsConta[13] != null) {
						emitirContaHelper.setDebitos((BigDecimal) parmsConta[13]);
					}
					if (parmsConta[14] != null) {
						emitirContaHelper.setValorCreditos((BigDecimal) parmsConta[14]);
					}
					if (parmsConta[15] != null) {
						emitirContaHelper.setValorImpostos((BigDecimal) parmsConta[15]);
					}
					if (parmsConta[16] != null) {
						emitirContaHelper.setDataValidadeConta((Date) parmsConta[16]);
					}
					if (parmsConta[17] != null) {
						emitirContaHelper.setIdImovel((Integer) parmsConta[17]);
					}
					if (parmsConta[18] != null) {
						emitirContaHelper.setIdLocalidade((Integer) parmsConta[18]);
					}
					if (parmsConta[19] != null) {
						emitirContaHelper.setIdGerenciaRegional((Integer) parmsConta[19]);
					}
					if (parmsConta[20] != null) {
						emitirContaHelper.setNomeGerenciaRegional((String) parmsConta[20]);
					}
					if (parmsConta[21] != null) {
						emitirContaHelper.setIdLigacaoAguaSituacao((Integer) parmsConta[21]);
					}
					if (parmsConta[22] != null) {
						emitirContaHelper.setIdLigacaoEsgotoSituacao((Integer) parmsConta[22]);
					}
					if (parmsConta[23] != null) {
						emitirContaHelper.setIdImovelPerfil((Integer) parmsConta[23]);
					}
					if (parmsConta[24] != null) {
						emitirContaHelper.setIdSetorComercial((Integer) parmsConta[24]);
					}
					if (parmsConta[25] != null) {
						emitirContaHelper.setIdFaturamentoGrupo((Integer) parmsConta[25]);
					}
					if (parmsConta[26] != null) {
						emitirContaHelper.setIdEmpresa((Integer) parmsConta[26]);
					}
					if (parmsConta[27] != null) {
						emitirContaHelper.setDescricaoLocalidade((String) parmsConta[27]);
					}
					if (parmsConta[28] != null) {
						emitirContaHelper.setDescricaoLigacaoAguaSituacao((String) parmsConta[28]);
					}
					if (parmsConta[29] != null) {
						emitirContaHelper.setDescricaoLigacaoEsgotoSituacao((String) parmsConta[29]);
					}
					if (parmsConta[30] != null) {
						emitirContaHelper.setPercentualEsgotoConta((BigDecimal) parmsConta[30]);
					}
					if (parmsConta[31] != null) {
						emitirContaHelper.setIdClienteResponsavel(""+ (Integer) parmsConta[31]);
					}
					if (parmsConta[32] != null) {
						emitirContaHelper.setNomeImovel((String) parmsConta[32]);
					}

					if (tam > 34) {
						if (parmsConta[33] != null) {
							emitirContaHelper.setCodigoRota((Short) parmsConta[33]);
						}
						if (parmsConta[34] != null) {
							emitirContaHelper.setNumeroSequencialRota((Integer) parmsConta[34]);
						}
						if (parmsConta[35] != null) {
							emitirContaHelper.setIdOrigem((Integer) parmsConta[35]);
						}
						if (parmsConta[36] != null) {
							emitirContaHelper.setDebitoCreditoSituacaoAtualConta((Integer) parmsConta[36]);
						}
						if (parmsConta[37] != null) {
							emitirContaHelper.setIdFuncionario((Integer) parmsConta[37]);
						}
						if (parmsConta[38] != null) {
							emitirContaHelper.setNomeFuncionario((String) parmsConta[38]);
						}
						if (parmsConta[39] != null) {
							emitirContaHelper.setContaTipo((Integer) parmsConta[39]);
						}
						if (parmsConta[40] != null) {
							emitirContaHelper.setIdRotaEntrega((Integer) parmsConta[40]);
						}
						if (parmsConta[41] != null) {
							emitirContaHelper.setNumeroSequencialRotaEntrega((Integer) parmsConta[41]);
						}

						if (tam > 42) {
							if (parmsConta[42] != null) {
								emitirContaHelper.setNumeroQuadraEntrega((Integer) parmsConta[42]);
							}
							if (parmsConta[43] != null) {
								emitirContaHelper.setValorRateioAgua((BigDecimal) parmsConta[43]);
							}
							if (parmsConta[44] != null) {
								emitirContaHelper.setValorRateioEsgoto((BigDecimal) parmsConta[44]);
							}
						}

					}

					this.preencherInformacoesMacro(emitirContaHelper);
					
					colecaoContas.add(emitirContaHelper);
					emitirContaHelper = null;
				}

			}
		}
		return colecaoContas;
	}
	
	private void preencherInformacoesMacro(EmitirContaHelper helper) throws ControladorException {
		Imovel imovel = getControladorImovel().pesquisarImovel(helper.getIdImovel());
		
		if (imovel.pertenceACondominio()) {
			
			logger.info("	macro: " + imovel.getImovelCondominio().getId());
			Imovel imovelMacro = getControladorImovel().pesquisarImovel(imovel.getImovelCondominio().getId());
			
			Collection<Imovel> imoveisVinculados = getControladorMicromedicao().obterImoveisVinculadosDoCondominio(imovelMacro.getId());
			
			FaturamentoGrupo grupo = new FaturamentoGrupo(helper.getIdFaturamentoGrupo());
			grupo.setAnoMesReferencia(helper.getAmReferencia());
			
			BigDecimal[] valoresASeremRateados = this.obterValorConsumoASerRateado(imovelMacro, grupo);
			
			ConsumoHistorico historico = this.getControladorMicromedicao().obterConsumoHistorico(
					imovelMacro, new LigacaoTipo(LigacaoTipo.LIGACAO_AGUA), grupo.getAnoMesReferencia());
			
			Integer somaConsumosImoveisMicro = getControladorMicromedicao().obterConsumoLigacaoImoveisVinculados(
					imovelMacro.getId(), grupo.getAnoMesReferencia(), LigacaoTipo.LIGACAO_AGUA);
			
			helper.setQuantidadeImoveisMicro(imoveisVinculados.size());
			helper.setSomaConsumosImoveisMicro(somaConsumosImoveisMicro);
			helper.setConsumoMacro(historico.getNumeroConsumoFaturadoMes());
			helper.setValorTotalASerrateado(valoresASeremRateados[0]);
		}
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição
	 * Individualizada
	 * 
	 * @author Rafael Corrêa
	 * @date 02/06/2008
	 * 
	 * @param colecaoLigacoesMedicao
	 * @throws ControladorException
	 */
	public Collection pesquisarFaturamentoLigacoesMedicaoIndividualizadaRelatorio(
			Collection<Imovel> colecaoImoveisGerarRelatorio,
			String anoMesfaturamentoGrupo) throws ControladorException {

		Collection colecaoRetorno = new ArrayList();

		int indicadorQuebraImovelCondominio = 0;

		for (Imovel imovel : colecaoImoveisGerarRelatorio) {
			// FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
			// faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper = null;
			Integer indicadorPoco = null;
			indicadorQuebraImovelCondominio++;

			// somatório da qtde de economias dos imóveis vinculados ao
			// imóvel condomínio
			int somaQtdeEconomias = 0;
			// somatório da qtde de imóveis vinculados ao imóvel condomínio
			// int somaQtdeImoveis = 0;

			if (imovel.getPocoTipo() != null) {
				indicadorPoco = imovel.getPocoTipo().getId();
			}

			Collection colecaoImovelLigacoesMedicaoIndividualizada = null;

			try {
				colecaoImovelLigacoesMedicaoIndividualizada = repositorioFaturamento
						.pesquisarLigacoesMedicaoIndividualizadaRelatorio(
								imovel.getId(), anoMesfaturamentoGrupo);
			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			if (colecaoImovelLigacoesMedicaoIndividualizada != null
					&& !colecaoImovelLigacoesMedicaoIndividualizada.isEmpty()) {
				criarColecaoImovelMedicaoIndividualizada(colecaoRetorno,
						indicadorQuebraImovelCondominio, imovel.getId(), imovel
								.getLocalidade().getId(), imovel
								.getLocalidade().getDescricao(), indicadorPoco,
						somaQtdeEconomias,
						colecaoImovelLigacoesMedicaoIndividualizada);
			}
		}

		return colecaoRetorno;
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição
	 * Individualizada
	 * 
	 * @author Vivianne Sousa
	 * @date 10/01/2007
	 * 
	 * @param colecaoLigacoesMedicao
	 * @throws ControladorException
	 */
	public Collection pesquisarFaturamentoLigacoesMedicaoIndividualizadaRelatorio(
			FiltroMedicaoHistoricoSql filtroMedicaoHistoricoSql,
			String anoMesfaturamentoGrupo) throws ControladorException {

		Collection colecaoIdImovelCondominioLigacoesMedicaoIndividualizada = null;
		Collection colecaoRetorno = new ArrayList();

		try {
			colecaoIdImovelCondominioLigacoesMedicaoIndividualizada = repositorioFaturamento
					.pesquisarIdImovelCondominioLigacoesMedicaoIndividualizada(
							filtroMedicaoHistoricoSql, anoMesfaturamentoGrupo);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (colecaoIdImovelCondominioLigacoesMedicaoIndividualizada != null
				&& !colecaoIdImovelCondominioLigacoesMedicaoIndividualizada
						.isEmpty()) {

			int indicadorQuebraImovelCondominio = 0;
			Iterator iterImovelCondominio = colecaoIdImovelCondominioLigacoesMedicaoIndividualizada
					.iterator();

			while (iterImovelCondominio.hasNext()) {
				Object[] objetoCondominio = (Object[]) iterImovelCondominio
						.next();
				// FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
				// faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper =
				// null;
				Integer idImovel = (Integer) objetoCondominio[0];
				Integer idLocalidade = (Integer) objetoCondominio[1];
				String nomeLocalidade = (String) objetoCondominio[2];
				Integer indicadorPoco = null;
				indicadorQuebraImovelCondominio++;

				// somatório da qtde de economias dos imóveis vinculados ao
				// imóvel condomínio
				int somaQtdeEconomias = 0;
				// somatório da qtde de imóveis vinculados ao imóvel condomínio
				// int somaQtdeImoveis = 0;

				if (objetoCondominio[3] != null) {
					indicadorPoco = (Integer) objetoCondominio[3];
				}

				Collection colecaoImovelLigacoesMedicaoIndividualizada = null;

				try {
					colecaoImovelLigacoesMedicaoIndividualizada = repositorioFaturamento
							.pesquisarLigacoesMedicaoIndividualizadaRelatorio(
									idImovel, anoMesfaturamentoGrupo);
				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				if (colecaoImovelLigacoesMedicaoIndividualizada != null
						&& !colecaoImovelLigacoesMedicaoIndividualizada
								.isEmpty()) {
					criarColecaoImovelMedicaoIndividualizada(colecaoRetorno,
							indicadorQuebraImovelCondominio, idImovel,
							idLocalidade, nomeLocalidade, indicadorPoco,
							somaQtdeEconomias,
							colecaoImovelLigacoesMedicaoIndividualizada);

				}

			}

		}

		return colecaoRetorno;
	}

	private void criarColecaoImovelMedicaoIndividualizada(
			Collection colecaoRetorno, int indicadorQuebraImovelCondominio,
			Integer idImovel, Integer idLocalidade, String nomeLocalidade,
			Integer indicadorPoco, int somaQtdeEconomias,
			Collection colecaoImovelLigacoesMedicaoIndividualizada) {
		FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper;
		int somaQtdeImoveis;
		int cont = 0;
		Iterator iterImovelLigacoesMedicaoIndividualizada = colecaoImovelLigacoesMedicaoIndividualizada
				.iterator();

		while (iterImovelLigacoesMedicaoIndividualizada.hasNext()) {
			Object[] imovelLigacoesMedicaoIndividualizada = (Object[]) iterImovelLigacoesMedicaoIndividualizada
					.next();

			faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper = new FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper();

			faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
					.setIdLocalidade("" + idLocalidade);
			faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
					.setNomeLocalidade(nomeLocalidade);

			if (idImovel.equals(imovelLigacoesMedicaoIndividualizada[0])) {
				// imóvel Condomínio

				if (indicadorPoco != null
						&& !indicadorPoco.equals(PocoTipo.SEM_POCO)) {
					faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
							.setIndicadorPoco("1");
				} else {
					faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
							.setIndicadorPoco("2");
				}

			}

			faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
					.setMatriculaImovel(""
							+ imovelLigacoesMedicaoIndividualizada[0]);

			if (imovelLigacoesMedicaoIndividualizada[1] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setQtdeEconomias(""
								+ imovelLigacoesMedicaoIndividualizada[1]);

				if (!idImovel.equals(imovelLigacoesMedicaoIndividualizada[0])) {
					somaQtdeEconomias = somaQtdeEconomias
							+ (Short) imovelLigacoesMedicaoIndividualizada[1];
				}
			}

			if (imovelLigacoesMedicaoIndividualizada[2] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setDataLeituraAnterior(Util
								.formatarData((Date) imovelLigacoesMedicaoIndividualizada[2]));
			}

			if (imovelLigacoesMedicaoIndividualizada[3] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setLeituraAnterior(Util.adicionarZerosEsquedaNumero(6,
								"" + imovelLigacoesMedicaoIndividualizada[3]));
			}

			if (imovelLigacoesMedicaoIndividualizada[4] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setDataLeituraAtual(Util
								.formatarData((Date) imovelLigacoesMedicaoIndividualizada[4]));
			}

			if (imovelLigacoesMedicaoIndividualizada[5] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setLeituraAtual(Util.adicionarZerosEsquedaNumero(6, ""
								+ imovelLigacoesMedicaoIndividualizada[5]));
			}

			if (imovelLigacoesMedicaoIndividualizada[6] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setConsumoImoveisVinculados(""
								+ imovelLigacoesMedicaoIndividualizada[6]);
			} else {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setConsumoImoveisVinculados("0");
			}

			if (imovelLigacoesMedicaoIndividualizada[7] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setAnormalidade(Util.adicionarZerosEsquedaNumero(2, ""
								+ imovelLigacoesMedicaoIndividualizada[7]));
			} else {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setAnormalidade("00");
			}

			if (imovelLigacoesMedicaoIndividualizada[8] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setMedia(Util.adicionarZerosEsquedaNumero(5, ""
								+ imovelLigacoesMedicaoIndividualizada[8]));
			} else {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setMedia("00000");
			}

			if (imovelLigacoesMedicaoIndividualizada[9] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setConsumoFaturado(""
								+ imovelLigacoesMedicaoIndividualizada[9]);
			} else {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setConsumoFaturado("0");
			}

			if (imovelLigacoesMedicaoIndividualizada[10] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setRateio(""
								+ imovelLigacoesMedicaoIndividualizada[10]);
			} else {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setRateio("");
			}

			if (imovelLigacoesMedicaoIndividualizada[11] != null) {
				String anormalidadeConsumo = (String) imovelLigacoesMedicaoIndividualizada[11];

				if (Util.validarValorNaoNumerico(anormalidadeConsumo)) {
					faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
							.setAnormalidadeConsumo(anormalidadeConsumo);
				} else {
					faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
							.setAnormalidadeConsumo(Util
									.adicionarZerosEsquedaNumero(2,
											anormalidadeConsumo));
				}

			} else {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setAnormalidadeConsumo("00");
			}

			if (imovelLigacoesMedicaoIndividualizada[12] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setTipoConsumo(""
								+ imovelLigacoesMedicaoIndividualizada[12]);
			}

			if (imovelLigacoesMedicaoIndividualizada[13] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setConsumoEsgoto(""
								+ imovelLigacoesMedicaoIndividualizada[13]);
			} else {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setConsumoEsgoto("0");
			}

			if (imovelLigacoesMedicaoIndividualizada[14] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setCodigoSetorComercial(""
								+ imovelLigacoesMedicaoIndividualizada[14]);
			}

			if (imovelLigacoesMedicaoIndividualizada[15] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setNumeroQuadra(""
								+ imovelLigacoesMedicaoIndividualizada[15]);
			}

			if (imovelLigacoesMedicaoIndividualizada[16] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setNumeroLote(""
								+ imovelLigacoesMedicaoIndividualizada[16]);
			}

			if (imovelLigacoesMedicaoIndividualizada[17] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setNumeroSubLote(""
								+ imovelLigacoesMedicaoIndividualizada[17]);
			}

			if (imovelLigacoesMedicaoIndividualizada[18] != null) {
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setNomeConsumidor(""
								+ imovelLigacoesMedicaoIndividualizada[18]);
			}

			faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
					.setIndicadorQuebraImovelCondominio(""
							+ indicadorQuebraImovelCondominio);

			cont++;

			if (cont == colecaoImovelLigacoesMedicaoIndividualizada.size()) {
				// qtde de imoveis menos o imovel condominio
				somaQtdeImoveis = colecaoImovelLigacoesMedicaoIndividualizada
						.size() - 1;
				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setTotalConsumidoresRateioMacromedidor(""
								+ somaQtdeImoveis);

				faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
						.setNumeroEconomiasRateio("" + somaQtdeEconomias);
			}

			colecaoRetorno
					.add(faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper);
		}
	}

	/**
	 * [UC0493] Emitir de Extrato de Consumo de Imóvel Condomínio
	 * 
	 * Flávio Cordeiro 08/01/2007
	 */
	public void emitirExtratoConsumoImovelCondominio(String anoMesFaturamento,
			String idFaturamento, int idFuncionalidadeIniciada)
			throws ControladorException {

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		int idUnidadeIniciada = 0;
		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, 0);

		try {
			Collection rotasFaturamento;

			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

			filtroFaturamentoAtividadeCronograma
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
							idFaturamento));

			filtroFaturamentoAtividadeCronograma
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
							anoMesFaturamento));

			filtroFaturamentoAtividadeCronograma
					.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID,
							FaturamentoAtividade.FATURAR_GRUPO));

			Collection colecaoFaturamentoAtividade = getControladorUtil()
					.pesquisar(filtroFaturamentoAtividadeCronograma,
							FaturamentoAtividadeCronograma.class.getName());

			rotasFaturamento = RepositorioBatchHBM
					.getInstancia()
					.pesquisarRotasProcessamentoBatchFaturamentoComandado(
							((FaturamentoAtividadeCronograma) colecaoFaturamentoAtividade
									.iterator().next()).getId());

			Collection idsRotas = new ArrayList();
			Iterator iteratorRotasFat = rotasFaturamento.iterator();
			while (iteratorRotasFat.hasNext()) {
				Object[] objeto = (Object[]) iteratorRotasFat.next();

				idsRotas.add(((Rota) objeto[1]).getId());

			}

			StringBuilder txt = new StringBuilder();

			boolean flagFimPesquisa = false;
			final int quantidadeEmitir = 1000;
			int quantidadeEmitirInicio = 0;

			int sequencialImpressao = 0;

			while (!flagFimPesquisa) {

				Collection colecaoEmitir = repositorioFaturamento
						.pesquisarEmitirExtratoConsumoImovelCondominio(
								idsRotas, anoMesFaturamento);

				if (!colecaoEmitir.isEmpty()) {

					EmitirConsumoImovelCondominimoHelper emitirConsumoImovelCondominimoHelper = null;
					Cliente cliente = null;
					String endereco = "";
					String mesAnoDigito = "";
					int count = 0;

					if (colecaoEmitir.size() < quantidadeEmitir) {
						flagFimPesquisa = true;
					} else {
						quantidadeEmitirInicio = quantidadeEmitirInicio + 1000;
					}

					int metadeColecao = 0;
					if (colecaoEmitir.size() % 2 == 0) {
						metadeColecao = colecaoEmitir.size() / 2;
					} else {
						metadeColecao = (colecaoEmitir.size() / 2) + 1;
					}

					Map<Integer, Map<Object, Object>> mapEmitirOrdenada = getControladorUtil()
							.dividirColecao(colecaoEmitir);

					if (mapEmitirOrdenada != null) {
						int countOrdem = 0;

						while (countOrdem < mapEmitirOrdenada.size()) {
							Map<Object, Object> mapEmitirDivididas = mapEmitirOrdenada
									.get(countOrdem);

							Iterator iteratorEmitir = mapEmitirDivididas
									.keySet().iterator();

							while (iteratorEmitir.hasNext()) {
								emitirConsumoImovelCondominimoHelper = new EmitirConsumoImovelCondominimoHelper();

								int situacao = 0;

								Object[] objetoEmitir = (Object[]) iteratorEmitir
										.next();

								sequencialImpressao++;

								while (situacao < 2) {
									if (situacao == 0) {
										situacao = 1;
										sequencialImpressao = atualizaSequencial(
												sequencialImpressao, situacao,
												metadeColecao);

									} else {
										objetoEmitir = (Object[]) mapEmitirDivididas
												.get(objetoEmitir);
										situacao = 2;
										sequencialImpressao = atualizaSequencial(
												sequencialImpressao, situacao,
												metadeColecao);
									}
									if (objetoEmitir == null) {
										break;
									}
									// idImovel
									if (objetoEmitir[0] != null) {

										if (((Integer) objetoEmitir[0])
												.equals(57847042)) {
											System.out.println("Achou Imovel");
										}

										emitirConsumoImovelCondominimoHelper
												.setIdImovel((Integer) objetoEmitir[0]);
									}
									// idLocalidade
									if (objetoEmitir[1] != null) {
										emitirConsumoImovelCondominimoHelper
												.setIdLocalidade((Integer) objetoEmitir[1]);
									}
									// nomeLocalidade
									if (objetoEmitir[2] != null) {
										emitirConsumoImovelCondominimoHelper
												.setNomeLocalidade((String) objetoEmitir[2]);
									}
									// dataLeituraAtualFat
									if (objetoEmitir[3] != null) {
										emitirConsumoImovelCondominimoHelper
												.setDataLeituraAtualFat((Date) objetoEmitir[3]);
									}
									// numero leitura atual fat
									if (objetoEmitir[4] != null) {
										emitirConsumoImovelCondominimoHelper
												.setNumeroLeituraAtualFat((Integer) objetoEmitir[4]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setNumeroLeituraAtualFat(new Integer(
														0));
									}
									// consumo fat mes
									if (objetoEmitir[5] != null) {
										emitirConsumoImovelCondominimoHelper
												.setConsumoFaturado((Integer) objetoEmitir[5]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setConsumoFaturado(new Integer(
														0));
									}
									// descricao da leitura atual
									if (objetoEmitir[6] != null) {
										emitirConsumoImovelCondominimoHelper
												.setDescricaoLeituraSituacao((String) objetoEmitir[6]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setDescricaoLeituraSituacao("");
									}
									// descricao tipo de sconsumo
									if (objetoEmitir[7] != null) {
										emitirConsumoImovelCondominimoHelper
												.setDescricaoConsumoTipo((String) objetoEmitir[7]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setDescricaoConsumoTipo("");
									}
									// descricao anormalidade de consumo
									if (objetoEmitir[8] != null) {
										emitirConsumoImovelCondominimoHelper
												.setDescricaoAnormalidadeConsumo((String) objetoEmitir[8]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setDescricaoAnormalidadeConsumo("");
									}
									// qtd economias
									if (objetoEmitir[9] != null) {
										emitirConsumoImovelCondominimoHelper
												.setQtdEconomias((Integer) objetoEmitir[9]);
									}
									// situacao ligacao agua
									if (objetoEmitir[10] != null) {
										emitirConsumoImovelCondominimoHelper
												.setSituacaoAgua((Integer) objetoEmitir[10]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setSituacaoAgua(new Integer(0));
									}
									// situacao Ligacao Esgoto
									if (objetoEmitir[11] != null) {
										emitirConsumoImovelCondominimoHelper
												.setSituacaoEsgoto((Integer) objetoEmitir[11]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setSituacaoEsgoto(new Integer(
														0));
									}
									// Abreviacao Consumo Tipo
									if (objetoEmitir[12] != null) {
										emitirConsumoImovelCondominimoHelper
												.setAbreviadaConsumoTipo((String) objetoEmitir[12]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setAbreviadaConsumoTipo("");
									}
									// anormalidade leitura faturada
									if (objetoEmitir[13] != null) {
										emitirConsumoImovelCondominimoHelper
												.setAnormalidadeLeituraFat((Integer) objetoEmitir[13]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setAnormalidadeLeituraFat(new Integer(
														0));
									}
									// Consumo anormalidade abreviada
									if (objetoEmitir[14] != null) {
										emitirConsumoImovelCondominimoHelper
												.setAbreviadaConsumoAnormalidade((String) objetoEmitir[14]);
									} else {
										emitirConsumoImovelCondominimoHelper
												.setAbreviadaConsumoAnormalidade("");
									}
									// Perfil tipo
									if (objetoEmitir[15] != null) {
										emitirConsumoImovelCondominimoHelper
												.setPerfilImovel((Integer) objetoEmitir[15]);
									}
									// Data leitura anterior Faturamento
									if (objetoEmitir[16] != null) {
										emitirConsumoImovelCondominimoHelper
												.setDataLeituraAnteriorFat((Date) objetoEmitir[16]);
									}
									// Consumo Medio
									if (objetoEmitir[17] != null) {
										emitirConsumoImovelCondominimoHelper
												.setConsumoMedio((Integer) objetoEmitir[17]);
									}
									// rateio
									if (objetoEmitir[18] != null) {
										emitirConsumoImovelCondominimoHelper
												.setRateio((Integer) objetoEmitir[18]);
									}
									// id Empresa
									if (objetoEmitir[19] != null) {
										emitirConsumoImovelCondominimoHelper
												.setIdEmpresa((Integer) objetoEmitir[19]);
									}
									// idLeituraSituacao
									if (objetoEmitir[20] != null) {
										emitirConsumoImovelCondominimoHelper
												.setIdLeituraSituacao((Integer) objetoEmitir[20]);
									}

									// consumorateio
									String consumoVinculados = "0";
									if (objetoEmitir[25] != null) {
										consumoVinculados = ""
												+ ((Integer) objetoEmitir[25]);
									}

									String codigoAuxiliar = emitirConsumoImovelCondominimoHelper
											.getIdLeituraSituacao()
											+ emitirConsumoImovelCondominimoHelper
													.getAbreviadaConsumoTipo()
											+ "0"
											+ emitirConsumoImovelCondominimoHelper
													.getAnormalidadeLeituraFat()
											+ emitirConsumoImovelCondominimoHelper
													.getAbreviadaConsumoAnormalidade()
											+ emitirConsumoImovelCondominimoHelper
													.getPerfilImovel()
											+ Util.obterQuantidadeDiasEntreDuasDatas(
													emitirConsumoImovelCondominimoHelper
															.getDataLeituraAtualFat(),
													emitirConsumoImovelCondominimoHelper
															.getDataLeituraAnteriorFat())
											+ emitirConsumoImovelCondominimoHelper
													.getConsumoMedio();

									cliente = repositorioClienteImovel
											.retornaClienteUsuario((Integer) objetoEmitir[0]);
									// idCliente
									// nomeCliente
									if (cliente != null) {
										emitirConsumoImovelCondominimoHelper
												.setIdCliente(cliente.getId());
										emitirConsumoImovelCondominimoHelper
												.setNomeCliente(cliente
														.getNome());
									}

									if (objetoEmitir[0] != null) {
										// inscricaoImovel
										emitirConsumoImovelCondominimoHelper
												.setInscricaoImovel(getControladorImovel()
														.pesquisarInscricaoImovel(
																(Integer) objetoEmitir[0]));

										// endereco - [UC0085] Obter
										// Endereço
										endereco = getControladorEndereco()
												.pesquisarEnderecoFormatado(
														(Integer) objetoEmitir[0]);
										emitirConsumoImovelCondominimoHelper
												.setEndereco(endereco);
									}

									// mesAnoDigito - [UC0260] Obter Digito
									// Verificador
									// Modulo 10
									mesAnoDigito = Util
											.formatarAnoMesParaMesAno(anoMesFaturamento)
											+ "-"
											+ Util.obterDigitoVerificadorModulo10(new Long(
													Util.formatarAnoMesParaMesAno(
															anoMesFaturamento)
															.replace("/", "")));

									count = count + 1;

									// --Linha 1-- //
									// Canal
									txt.append("1");
									// Fonte
									txt.append("1");
									// restante da linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 2-- //
									// Canal
									txt.append("1");
									// Fonte
									txt.append("1");
									txt.append(Util.completaString("", 19));
									// nome da localidade
									txt.append(Util.completaString(
											emitirConsumoImovelCondominimoHelper
													.getNomeLocalidade(), 110));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 3-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// Inscricao do imovel
									txt.append(Util
											.completaString(
													getControladorImovel()
															.pesquisarInscricaoImovel(
																	emitirConsumoImovelCondominimoHelper
																			.getIdImovel()),
													30));
									// nome do cliente usuario
									txt.append(Util.completaString(
											emitirConsumoImovelCondominimoHelper
													.getNomeCliente(), 99));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 4-- //
									// Canal
									txt.append("+");
									// Fonte
									txt.append("2");
									txt.append(Util.completaString("", 64));
									// matricula do imovel
									txt.append(Util
											.completaString(
													emitirConsumoImovelCondominimoHelper
															.getIdImovel()
															.toString()
															.substring(
																	0,
																	(emitirConsumoImovelCondominimoHelper
																			.getIdImovel()
																			.toString()
																			.length() - 1))
															+ "."
															+ emitirConsumoImovelCondominimoHelper
																	.getIdImovel()
																	.toString()
																	.substring(
																			(emitirConsumoImovelCondominimoHelper
																					.getIdImovel()
																					.toString()
																					.length() - 1),
																			emitirConsumoImovelCondominimoHelper
																					.getIdImovel()
																					.toString()
																					.length()),
													65));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 5-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// endereco
									txt.append(Util.completaString(
											emitirConsumoImovelCondominimoHelper
													.getEndereco(), 50));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 6-- //
									// Canal
									txt.append("+");
									// Fonte
									txt.append("2");
									txt.append(Util.completaString("", 64));
									// mes ano referencia faturamento e
									// digito
									txt.append(Util.completaString(
											mesAnoDigito, 65));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 6A-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									if (emitirConsumoImovelCondominimoHelper
											.getEndereco() != null
											&& emitirConsumoImovelCondominimoHelper
													.getEndereco().length() > 50) {
										int quantidadePosicoes = emitirConsumoImovelCondominimoHelper
												.getEndereco().length();
										// Recupera o fim do
										// endereço do
										// cliente
										// responsável
										txt.append(Util
												.completaString(
														emitirConsumoImovelCondominimoHelper
																.getEndereco()
																.substring(50,
																		quantidadePosicoes),
														50));
										// compleca com
										// espaços
										// em
										// brancos
										txt.append(Util.completaString("", 79));

									} else {
										// compleca com
										// espaços
										// em
										// brancos
										txt.append(Util.completaString("", 129));
									}

									// --Linha 7-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// restante a linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 8-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("2");
									// restante a linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 9-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append(" ");
									// restante a linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 10-- //
									// Canal
									txt.append("-");
									// Fonte
									txt.append("1");
									// Dados do consumo do mes anterior 1
									EmitirContaHelper emitirConta = new EmitirContaHelper(
											emitirConsumoImovelCondominimoHelper
													.getIdImovel(),
											new Integer(anoMesFaturamento));
									txt.append(this.obterDadosConsumoAnterior(
											emitirConta, 1,
											LigacaoTipo.LIGACAO_AGUA,
											MedicaoTipo.LIGACAO_AGUA)
											.toString());
									// Dados do consumo do mes anterior 4
									txt.append(this.obterDadosConsumoAnterior(
											emitirConta, 4,
											LigacaoTipo.LIGACAO_AGUA,
											MedicaoTipo.LIGACAO_AGUA)
											.toString());
									// Data de Leitura Atual
									txt.append("      "
											+ Util.formatarData(emitirConsumoImovelCondominimoHelper
													.getDataLeituraAtualFat()));
									txt.append("  ");
									// Leitura Atual
									txt.append(Util.completaString(
											emitirConsumoImovelCondominimoHelper
													.getNumeroLeituraAtualFat()
													.toString(), 20));
									// Consumo Faturado
									txt.append(" "
											+ emitirConsumoImovelCondominimoHelper
													.getConsumoFaturado());
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 11-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// Dados do consumo do mes anterior 2
									txt.append(this.obterDadosConsumoAnterior(
											emitirConta, 2,
											LigacaoTipo.LIGACAO_AGUA,
											MedicaoTipo.LIGACAO_AGUA)
											.toString());
									// Dados do consumo do mes anterior 5
									txt.append(this.obterDadosConsumoAnterior(
											emitirConta, 5,
											LigacaoTipo.LIGACAO_AGUA,
											MedicaoTipo.LIGACAO_AGUA)
											.toString());
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 12-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// Dados do consumo do mes anterior 3
									txt.append(this.obterDadosConsumoAnterior(
											emitirConta, 3,
											LigacaoTipo.LIGACAO_AGUA,
											MedicaoTipo.LIGACAO_AGUA)
											.toString());
									// Dados do consumo do mes anterior 6
									txt.append(this.obterDadosConsumoAnterior(
											emitirConta, 6,
											LigacaoTipo.LIGACAO_AGUA,
											MedicaoTipo.LIGACAO_AGUA)
											.toString());
									// situacao da leitura atual
									txt.append("     "
											+ emitirConsumoImovelCondominimoHelper
													.getDescricaoLeituraSituacao());
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 13-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									txt.append(Util.completaString("", 45));
									// tipo de consumo
									txt.append(emitirConsumoImovelCondominimoHelper
											.getDescricaoConsumoTipo());
									// anormalidade de consumo
									txt.append(" "
											+ emitirConsumoImovelCondominimoHelper
													.getDescricaoAnormalidadeConsumo());
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 14-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// Quantidade de economias do imovel
									// condominio
									txt.append(Util
											.completaStringComEspacoAEsquerda(
													emitirConsumoImovelCondominimoHelper
															.getQtdEconomias()
															.toString(), 6));
									// consumo por economia
									txt.append(Util
											.completaStringComEspacoAEsquerda(
													(emitirConsumoImovelCondominimoHelper
															.getConsumoFaturado() / emitirConsumoImovelCondominimoHelper
															.getQtdEconomias())
															+ "", 12));
									// codigo Auxiliar
									txt.append(Util
											.completaStringComEspacoAEsquerda(
													codigoAuxiliar, 16));
									// cod. situacao de agua
									txt.append(" "
											+ emitirConsumoImovelCondominimoHelper
													.getSituacaoAgua());
									// cod situacao de esgoto
									txt.append(emitirConsumoImovelCondominimoHelper
											.getSituacaoEsgoto());
									txt.append(Util
											.completaStringComEspacoAEsquerda(
													"", 8));
									// Constante
									txt.append("IMÓVEL CONDOMÍNIO ");
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 15-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// restante da linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 16-- //
									// Canal
									txt.append("-");
									// Fonte
									txt.append("1");
									// constante
									txt.append(Util.completaString(
											"  CONSUMO DO IMÓVEL CONDOMÍNIO ",
											51));
									// consumo faturado
									txt.append(Util
											.completaStringComEspacoAEsquerda(
													emitirConsumoImovelCondominimoHelper
															.getConsumoFaturado()
															.toString(), 6));
									txt.append(" M3");
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 17-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// constante
									txt.append(Util
											.completaString(
													"  SOMA DOS CONSUMOS DOS IMÓVEIS VINCULADOS ",
													51));
									// soma dos consumos dos imoveis
									// associados
									String soma = consumoVinculados;
									/*
									 * repositorioFaturamento
									 * .somaConsumosImoveisAssociados(
									 * emitirConsumoImovelCondominimoHelper
									 * .getIdImovel(), anoMesFaturamento) + "";
									 */
									if (soma.trim().equals("null")) {
										soma = "0";
									}
									txt.append(Util
											.completaStringComEspacoAEsquerda(
													soma, 6));
									txt.append(" M3");
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 18-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// constante
									txt.append(Util
											.completaString(
													"  QUANTIDADE DE IMÓVEIS VINCULADOS ",
													51));
									// Quantidade de imoveis associados
									txt.append(Util.completaStringComEspacoAEsquerda(
											repositorioFaturamento
													.quantidadeImoveisAssociados(
															emitirConsumoImovelCondominimoHelper
																	.getIdImovel(),
															anoMesFaturamento)
													+ "", 6));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 19-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// constante
									txt.append(Util.completaString(
											"  CONSUMO RATEADO ", 51));
									// rateio
									if (emitirConsumoImovelCondominimoHelper
											.getRateio() != null) {
										txt.append(Util
												.completaStringComEspacoAEsquerda(
														emitirConsumoImovelCondominimoHelper
																.getRateio()
																.toString(), 6));
									} else {
										txt.append(Util
												.completaStringComEspacoAEsquerda(
														"0", 6));
									}
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));

									// --Linha 20-- //
									// Canal
									txt.append("1");
									// Fonte
									txt.append("1");
									// Faturamento grupo id
									txt.append(Util
											.completaStringComEspacoAEsquerda(
													"", 9));
									txt.append(Util.completaString(
											idFaturamento, 29));
									// id empresa
									txt.append(Util
											.adicionarZerosEsquedaNumero(2,
													emitirConsumoImovelCondominimoHelper
															.getIdEmpresa()
															.toString()));
									// seq impresao extrato por empresa
									txt.append(Util.completaString(
											"-"
													+ Util.retornaSequencialFormatado(sequencialImpressao),
											27));

									// count
									txt.append(Util
											.retornaSequencialFormatado(sequencialImpressao));
									// pula para proxima linha
									txt.append(System
											.getProperty("line.separator"));
								}
							}
							countOrdem++;
						}
					}

					EnvioEmail envioEmial = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.EMITIR_EXTRATO_CONSUMO_IMOVEL_CONDOMINIO);

					String emailRemetente = envioEmial.getEmailRemetente();
					String tituloMensagem = envioEmial.getTituloMensagem();
					String corpoMensagem = envioEmial.getCorpoMensagem();
					String emailReceptor = envioEmial.getEmailReceptor();

					getControladorUtil().mandaArquivoLeituraEmail("GRUPO_" + idFaturamento+ "_extratoConsumoImovelCondominio", txt,
							emailReceptor, emailRemetente, tituloMensagem, corpoMensagem);

					// leitura.delete();
				}

				// --------------------------------------------------------
				//
				// Registrar o fim da execução da Unidade de Processamento
				//
				// --------------------------------------------------------
				getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
						idUnidadeIniciada, false);

			}

		} catch (Exception e) {
			// Este catch serve para interceptar qualquer exceção que o
			// processo
			// batch venha a lançar e garantir que a unidade de
			// processamento do
			// batch será atualizada com o erro ocorrido

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);
			throw new EJBException(e);

		}
	}

	/**
	 * [UC0173] Gerar Relatório de Resumo do Faturamento
	 * 
	 * @author Vivianne Sousa, Diogo Peixoto
	 * @created 24/01/2007, 25/04/2011
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Integer consultarQtdeRegistrosResumoFaturamentoRelatorio(
			int mesAnoReferencia, Integer localidade, Integer municipio,
			Integer gerenciaRegional, String opcaoTotalizacao)
			throws ControladorException {
		Integer retorno = 0;

		int anoMesReferencia = Util.formatarMesAnoParaAnoMes(mesAnoReferencia);

		try {

			retorno = repositorioFaturamento
					.consultarQtdeRegistrosResumoFaturamentoRelatorio(
							anoMesReferencia, localidade, municipio,
							gerenciaRegional, opcaoTotalizacao);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC0335] Gerar Resumo de Pendência
	 * 
	 * Pesquisar os ids das localidade
	 * 
	 * @author Ana Maria
	 * @date 29/01/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsLocalidade()
			throws ControladorException {
		try {
			return repositorioFaturamento.pesquisarIdsLocalidade();
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * @author Ana Maria
	 * @date 26/01/2007
	 * 
	 * @param idConta
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection obterConta(Integer idConta) throws ControladorException {
		try {
			return repositorioFaturamento.obterConta(idConta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Vivianne Sousa
	 * @created 30/01/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarContasEmitidasRelatorio(int anoMesReferencia,
			Integer grupoFaturamento, Collection esferaPoder,
			String tipoImpressao) throws ControladorException {

		Collection colecaoContasEmitidas = null;
		Collection colecaoRetorno = new ArrayList();

		try {

			// IMPRESSÃO SIMULTÂNEA
			if (tipoImpressao.equals("2")) {
				colecaoContasEmitidas = repositorioFaturamento
						.consultarContasEmitidasImpressaoSimultaneaRelatorio(
								anoMesReferencia, grupoFaturamento, esferaPoder);
				// NORMAL
			} else {
				colecaoContasEmitidas = repositorioFaturamento
						.consultarContasEmitidasRelatorio(anoMesReferencia,
								grupoFaturamento, esferaPoder);
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (colecaoContasEmitidas != null && !colecaoContasEmitidas.isEmpty()) {

			Iterator iterContasEmitidas = colecaoContasEmitidas.iterator();
			ContasEmitidasRelatorioHelper contasEmitidasRelatorioHelper = new ContasEmitidasRelatorioHelper();

			while (iterContasEmitidas.hasNext()) {
				Object[] objetoContasEmitidas = (Object[]) iterContasEmitidas
						.next();
				contasEmitidasRelatorioHelper = new ContasEmitidasRelatorioHelper();
				contasEmitidasRelatorioHelper.setIdGrupoFaturamento(""
						+ grupoFaturamento);
				contasEmitidasRelatorioHelper.setMesAnoReferencia(Util
						.formatarAnoMesParaMesAno(anoMesReferencia));

				// id da Conta
				if (objetoContasEmitidas[0] != null) {
					contasEmitidasRelatorioHelper.setIdContaImpressao(""
							+ objetoContasEmitidas[0]);
				}

				// id do cliente responsável
				if (objetoContasEmitidas[1] != null) {
					contasEmitidasRelatorioHelper.setIdClienteResponsavel(""
							+ objetoContasEmitidas[1]);

					String endereco = getControladorEndereco()
							.pesquisarEnderecoClienteAbreviado(
									(Integer) objetoContasEmitidas[1]);

					contasEmitidasRelatorioHelper.setEndereco(endereco);
				}

				// nome do cliente responsável
				if (objetoContasEmitidas[2] != null) {
					contasEmitidasRelatorioHelper.setNomeClienteResponsavel(""
							+ objetoContasEmitidas[2]);
				}

				// id da localidade
				if (objetoContasEmitidas[3] != null) {
					contasEmitidasRelatorioHelper.setIdLocalidade(""
							+ objetoContasEmitidas[3]);
				}

				// descrição da localidade
				if (objetoContasEmitidas[4] != null) {
					contasEmitidasRelatorioHelper.setDescLocalidade(""
							+ objetoContasEmitidas[4]);
				}

				// data do vencimento da conta
				if (objetoContasEmitidas[5] != null) {
					contasEmitidasRelatorioHelper.setDataVencimentoConta(Util
							.formatarData((Date) objetoContasEmitidas[5]));
				}

				// id do imóvel
				if (objetoContasEmitidas[6] != null) {
					contasEmitidasRelatorioHelper.setIdImovel(""
							+ objetoContasEmitidas[6]);
				}

				// codigo do setor comercial
				if (objetoContasEmitidas[7] != null) {
					contasEmitidasRelatorioHelper.setCodigoSetorComercial(""
							+ objetoContasEmitidas[7]);
				}

				// numero da quadra
				if (objetoContasEmitidas[8] != null) {
					contasEmitidasRelatorioHelper.setNumeroQuadra(""
							+ objetoContasEmitidas[8]);
				}

				// lote
				if (objetoContasEmitidas[9] != null) {
					contasEmitidasRelatorioHelper.setNumeroLote(""
							+ objetoContasEmitidas[9]);
				}

				// sublote
				if (objetoContasEmitidas[10] != null) {
					contasEmitidasRelatorioHelper.setNumeroSubLote(""
							+ objetoContasEmitidas[10]);
				}

				// nome do cliente usuario
				if (objetoContasEmitidas[11] != null) {
					contasEmitidasRelatorioHelper.setNomeUsuario(""
							+ objetoContasEmitidas[11]);
				}

				// valor agua
				if (objetoContasEmitidas[12] != null) {
					contasEmitidasRelatorioHelper
							.setValorAgua((BigDecimal) objetoContasEmitidas[12]);
				}

				// valor esgoto
				if (objetoContasEmitidas[13] != null) {
					contasEmitidasRelatorioHelper
							.setValorEsgoto((BigDecimal) objetoContasEmitidas[13]);
				}

				// valor debitos
				if (objetoContasEmitidas[14] != null) {
					contasEmitidasRelatorioHelper
							.setValorDebitos((BigDecimal) objetoContasEmitidas[14]);
				}

				// valor creditos
				if (objetoContasEmitidas[15] != null) {
					contasEmitidasRelatorioHelper
							.setValorCreditos((BigDecimal) objetoContasEmitidas[15]);
				}

				// id da Esfera Poder
				if (objetoContasEmitidas[16] != null) {

					contasEmitidasRelatorioHelper.setIdEsferaPoder(""
							+ objetoContasEmitidas[16]);
				}

				// descrição da Esfera Poder
				if (objetoContasEmitidas[17] != null) {
					contasEmitidasRelatorioHelper.setDescEsferaPoder(""
							+ objetoContasEmitidas[17]);
				}

				colecaoRetorno.add(contasEmitidasRelatorioHelper);

			}

		}

		return colecaoRetorno;
	}

	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Vivianne Sousa
	 * @created 02/02/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQtdeContasEmitidasRelatorio(int anoMesReferencia,
			Integer grupoFaturamento, Collection esferaPoder)
			throws ControladorException {
		try {
			return repositorioFaturamento.consultarQtdeContasEmitidasRelatorio(
					anoMesReferencia, grupoFaturamento, esferaPoder);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * retorna o anoMes do faturamento grupo do imóvel passado
	 */
	public Integer retornaAnoMesFaturamentoGrupo(Integer idImovel)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.retornaAnoMesFaturamentoGrupo(idImovel);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0001] Inserir Distrito Operacional
	 * 
	 * @author Eduardo Bianchi
	 * @date 26/01/2007
	 * 
	 * @param Distrito
	 *            Operaciona Descrição do parâmetro
	 */
	public Integer inserirContratoDemanda(ContratoDemanda contratoDemanda,
			Usuario usuarioLogado) throws ControladorException {

		FiltroContratoDemanda filtroContratoDemanda = new FiltroContratoDemanda();
		filtroContratoDemanda.adicionarParametro(new ParametroSimples(
				FiltroContratoDemanda.MUMEROCONTRATO, contratoDemanda
						.getNumeroContrato()));

		Collection colecaoContratoDemanda = getControladorUtil().pesquisar(
				filtroContratoDemanda, ContratoDemanda.class.getName());

		Integer idContratoDemanda = null;

		if (colecaoContratoDemanda.isEmpty()) {
			idContratoDemanda = (Integer) getControladorUtil().inserir(
					contratoDemanda);
		} else {
			throw new ControladorException("atencao.contrato_demanda_existente");
		}

		// // ------------ REGISTRAR TRANSAÇÃO----------------------------
		//
		// RegistradorOperacao registradorOperacao = new RegistradorOperacao(
		// Operacao.OPERACAO_DISTRITO_OPERACIONAL_INSERIR,
		// new UsuarioAcaoUsuarioHelper(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		//
		// Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_DISTRITO_OPERACIONAL_INSERIR);
		//
		// OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		// operacaoEfetuada.setOperacao(operacao);
		//
		// distritoOperacional.setOperacaoEfetuada(operacaoEfetuada);
		// distritoOperacional.adicionarUsuario(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		// registradorOperacao.registrarOperacao(distritoOperacional);
		//
		// // ------------ REGISTRAR TRANSAÇÃO----------------------------

		return idContratoDemanda;
	}

	/**
	 * 
	 * Permite atualizar os dados de um contrato de demanda
	 * 
	 * [UC0513] Manter Contrato de Demanda
	 * 
	 * [SB0001] Atualizar Contrato de Demanda
	 * 
	 * @author Rafael Corrêa
	 * @param usuarioLogado
	 * @date 28/06/2007
	 * 
	 */
	public void atualizarContratoDemanda(ContratoDemanda contratoDemanda,
			Usuario usuarioLogado) throws ControladorException {

		// [FS0003] - Atualização realizada por outro usuário
		FiltroContratoDemanda filtroContratoDemanda = new FiltroContratoDemanda();
		filtroContratoDemanda.adicionarParametro(new ParametroSimples(
				FiltroContratoDemanda.ID, contratoDemanda.getId()));

		Collection colecaoContratoDemandaBase = getControladorUtil().pesquisar(
				filtroContratoDemanda, ContratoDemanda.class.getName());

		if (colecaoContratoDemandaBase == null
				|| colecaoContratoDemandaBase.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		ContratoDemanda contratoDemandaBase = (ContratoDemanda) colecaoContratoDemandaBase
				.iterator().next();

		if (contratoDemandaBase.getUltimaAlteracao().after(
				contratoDemanda.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// [FS0007] - Verificar existência do contrato de demanda
		if (!contratoDemanda.getNumeroContrato().equals(
				contratoDemandaBase.getNumeroContrato())) {
			filtroContratoDemanda.limparListaParametros();
			filtroContratoDemanda.adicionarParametro(new ParametroSimples(
					FiltroContratoDemanda.MUMEROCONTRATO, contratoDemanda
							.getNumeroContrato()));

			Collection colecaoContratoDemanda = getControladorUtil().pesquisar(
					filtroContratoDemanda, ContratoDemanda.class.getName());

			if (colecaoContratoDemanda != null
					&& !colecaoContratoDemanda.isEmpty()) {
				throw new ControladorException(
						"atencao.contrato_demanda.ja_existente");
			}
		}

		contratoDemanda.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_CONTRATO_DEMANDA_ATUALIZAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CONTRATO_DEMANDA_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		contratoDemanda.setOperacaoEfetuada(operacaoEfetuada);
		contratoDemanda.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(contratoDemanda);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		getControladorUtil().atualizar(contratoDemanda);

	}

	/**
	 * Monta a colecao de resultdos apartir da tbela conta impressao para
	 * geracao do relatorio de MAPA DE CONTROLE DAS CONTAS EMITIDAS
	 * 
	 * @author Flávio Cordeiro
	 * @date 13/02/2007
	 * 
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarMapaControleContaRelatorio(
			Integer idGrupoFaturamento, String mesAno, Usuario usuarioLogado,
			String tipoRelatorio, String indicadorFichaCompensacao)
			throws ControladorException {

		Collection retorno = new ArrayList();
		try {
			Collection colecaoObjeto = repositorioFaturamento
					.filtrarMapaControleContaRelatorio(idGrupoFaturamento,
							Util.formatarMesAnoParaAnoMes(mesAno),
							indicadorFichaCompensacao);

			if (!colecaoObjeto.isEmpty()) {

				Iterator iterator = colecaoObjeto.iterator();

				while (iterator.hasNext()) {
					Object[] objeto = (Object[]) iterator.next();
					MapaControleContaRelatorioHelper mapaControleContaRelatorioHelper = new MapaControleContaRelatorioHelper();

					// idEmpresa
					// nomeEmpresa
					if (objeto[0] != null) {
						mapaControleContaRelatorioHelper
								.setIdEmpresa((Integer) objeto[0]);
						mapaControleContaRelatorioHelper
								.setNomeEmpresa((String) objeto[1]);
					}
					// idTipoConta
					// descricaoConta
					if (objeto[2] != null) {
						mapaControleContaRelatorioHelper
								.setIdTipoConta((Integer) objeto[2]);
						mapaControleContaRelatorioHelper
								.setDescricaoTipoConta((String) objeto[3]);
					}
					// idLocalidade
					if (objeto[4] != null) {
						mapaControleContaRelatorioHelper
								.setIdLocalidade((Integer) objeto[4]);
					}
					// codigoSetorComercial
					if (objeto[5] != null) {
						mapaControleContaRelatorioHelper
								.setCodigoSetor((Integer) objeto[5]);
					}
					// idFaturamentoGrupo
					if (objeto[6] != null) {
						mapaControleContaRelatorioHelper
								.setIdFaturamentoGrupo((Integer) objeto[6]);
					}
					// sequencialInicial
					if (objeto[7] != null) {
						mapaControleContaRelatorioHelper
								.setSequencialInicial((Integer) objeto[7]);
					}
					// sequencialFinal
					if (objeto[8] != null) {
						mapaControleContaRelatorioHelper
								.setSequencialFinal((Integer) objeto[8]);
					}
					// somaValorAgua
					if (objeto[9] != null) {
						mapaControleContaRelatorioHelper
								.setSomaValorAgua((BigDecimal) objeto[9]);
					}
					// somaValorEsgoto
					if (objeto[10] != null) {
						mapaControleContaRelatorioHelper
								.setSomaValorEsgoto((BigDecimal) objeto[10]);
					}
					// somaValordebito
					if (objeto[11] != null) {
						mapaControleContaRelatorioHelper
								.setSomaValordebito((BigDecimal) objeto[11]);
					}
					// somaValorCredito
					if (objeto[12] != null) {
						mapaControleContaRelatorioHelper
								.setSomaValorCredito((BigDecimal) objeto[12]);
					}

					retorno.add(mapaControleContaRelatorioHelper);
				}

				// parte nova para o relatório ter o processamento em batch
				// cria uma instância da classe do relatório
				RelatorioMapaControleConta relatorioMapaControleConta = new RelatorioMapaControleConta(
						usuarioLogado);

				relatorioMapaControleConta.addParametro(
						"colecaoMapaControleConta", retorno);

				relatorioMapaControleConta.addParametro("mesAno", mesAno);
				relatorioMapaControleConta.addParametro("idGrupoFaturamento",
						idGrupoFaturamento + "");

				if (indicadorFichaCompensacao.equals("1")) {
					relatorioMapaControleConta.addParametro(
							"tipoFichaCompensacao", "CONTA");
				} else if (indicadorFichaCompensacao.equals("2")) {
					relatorioMapaControleConta.addParametro(
							"tipoFichaCompensacao", "BOLETO BANCÁRIO");
				}

				// Parte do codigo q gera a data de vencimento
				// dia do vencimento do grupo/mes ano de referencia do grupo + 1
				FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
				filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupo.ID, idGrupoFaturamento));

				Collection colecaoFaturamento = Fachada.getInstancia()
						.pesquisar(filtroFaturamentoGrupo,
								FaturamentoGrupo.class.getName());
				FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) colecaoFaturamento
						.iterator().next();

				String vencimento = Util.adicionarZerosEsquedaNumero(2,
						faturamentoGrupo.getDiaVencimento() + "")
						+ "/"
						+ Util.somaMesMesAnoComBarra(
								Util.formatarMesAnoSemBarraParaMesAnoComBarra(mesAno),
								1);

				relatorioMapaControleConta.addParametro("vencimento",
						vencimento);

				if (tipoRelatorio == null) {
					tipoRelatorio = TarefaRelatorio.TIPO_PDF + "";
				}

				relatorioMapaControleConta.addParametro("tipoFormatoRelatorio",
						Integer.parseInt(tipoRelatorio));

				byte[] relatorioGerado = (byte[]) relatorioMapaControleConta
						.executar();

				EnvioEmail envioEmail = getControladorCadastro()
						.pesquisarEnvioEmail(
								EnvioEmail.GERAR_RELATORIO_MAPA_CONTROLE_CONTA);

				String emailRemetente = envioEmail.getEmailRemetente();

				String tituloMensagem = envioEmail.getTituloMensagem();

				String corpoMensagem = envioEmail.getCorpoMensagem();
				String emailReceptor = envioEmail.getEmailReceptor();

				ZipOutputStream zos = null;
				FileOutputStream out = null;
				try {

					String nomeZip = "";
					if (indicadorFichaCompensacao.equals("1")) {
						nomeZip = "relatorio_mapa_controle_conta_grupo_"
								+ faturamentoGrupo.getDescricao();
						File leitura = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".PDF");
						File compactado = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".zip"); // nomeZip
						zos = new ZipOutputStream(new FileOutputStream(compactado));
						out = new FileOutputStream(leitura.getAbsolutePath());
						out.write(relatorioGerado);
						out.flush();

						ZipUtil.adicionarArquivo(zos, leitura);

						ServicosEmail.enviarMensagemArquivoAnexado(
								emailRemetente, emailReceptor, tituloMensagem,
								corpoMensagem, leitura);

						leitura.delete();

					} else if (indicadorFichaCompensacao.equals("2")) {
						nomeZip = "relatorio_mapa_controle_conta_grupo_boleto_bancario_"
								+ faturamentoGrupo.getDescricao();
						File leitura = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".PDF");
						File compactado = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".zip"); // nomeZip
						
						zos = new ZipOutputStream(new FileOutputStream(compactado));
						out = new FileOutputStream(leitura.getAbsolutePath());
						out.write(relatorioGerado);
						out.flush();

						ZipUtil.adicionarArquivo(zos, leitura);

						ServicosEmail.enviarMensagemArquivoAnexado(
								emailRemetente, emailReceptor, tituloMensagem,
								corpoMensagem, leitura);

						leitura.delete();
					}
				} catch (IOException e) {
					throw new ControladorException("erro.sistema", e);
				} catch (Exception e) {
					throw new ControladorException("erro.sistema", e);
				} finally {
					IoUtil.fecharStream(out);
					IoUtil.fecharStream(zos);
				}

			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Monta a colecao de resultdos apartir da tabela conta impressao para
	 * geracao do relatorio de RESUMO CONTAS EMITIDAS POR LOCALIDADE NO GRUPO
	 * 
	 * @author Flávio Cordeiro
	 * @date 13/02/2007
	 * 
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarResumoContasLocalidade(Integer idGrupoFaturamento,
			String anoMes, Integer idFirma, String tipoImpressao)
			throws ControladorException {

		Collection retorno = new ArrayList();
		try {

			Collection colecaoObjeto = null;

			// Impressão Simultanea
			if (tipoImpressao.equals("2")) {

				colecaoObjeto = repositorioFaturamento
						.filtrarResumoContasLocalidadeImpressaoSimultanea(
								idGrupoFaturamento, anoMes, idFirma);
				// Normal
			} else {
				colecaoObjeto = repositorioFaturamento
						.filtrarResumoContasLocalidade(idGrupoFaturamento,
								anoMes, idFirma);
			}

			if (!colecaoObjeto.isEmpty()) {

				Iterator iterator = colecaoObjeto.iterator();

				while (iterator.hasNext()) {
					Object[] objeto = (Object[]) iterator.next();
					MapaControleContaRelatorioHelper mapaControleContaRelatorioHelper = new MapaControleContaRelatorioHelper();

					// idLocalidade
					if (objeto[0] != null) {
						mapaControleContaRelatorioHelper
								.setIdLocalidade((Integer) objeto[0]);
					}

					// idEmpresa
					if (objeto[1] != null) {
						mapaControleContaRelatorioHelper
								.setIdEmpresa((Integer) objeto[1]);
					}

					// esferaPoder
					if (objeto[2] != null) {
						mapaControleContaRelatorioHelper
								.setIdEsferaPoder((Integer) objeto[2]);
					}

					// sequencialInicial
					if (objeto[3] != null) {
						mapaControleContaRelatorioHelper
								.setSequencialInicial((Integer) objeto[3]);
					}
					// sequencialFinal
					if (objeto[4] != null) {
						mapaControleContaRelatorioHelper
								.setSequencialFinal((Integer) objeto[4]);
					}

					// Quantidade de Contas
					if (objeto[5] != null) {
						mapaControleContaRelatorioHelper
								.setQtdeContas((Integer) objeto[5]);
					}

					// Quantidade de Imovel
					if (objeto[6] != null) {
						mapaControleContaRelatorioHelper
								.setQtdTotalMacro((Integer) objeto[6]);
					}

					retorno.add(mapaControleContaRelatorioHelper);
				}
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0482] Emitir Segunda Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/02/2007
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public void gerarDebitoACobrarTaxaEmissaoConta(Integer idImovel,
			int anoMesReferencia) throws ControladorException {

		try {

			Imovel imovel = getControladorImovel().pesquisarImovel(idImovel);

			// Recupera os parametros do sistema
			SistemaParametro sistema = getControladorUtil()
					.pesquisarParametrosDoSistema();

			// Instância a forma de cobrança para cobrança em conta
			CobrancaForma cobrancaForma = new CobrancaForma();
			cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

			// Instância a situação do débito para normal
			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

			// Recupera o tipo de débito referente a despesa postal
			DebitoTipo debitoTipo = this
					.getDebitoTipoHql(DebitoTipo.TAXA_2_VIA_CONTA);

			// Recupera a data atual
			Date dataAtual = new Date(System.currentTimeMillis());

			// Verifica se já existe débito para este imóvel
			/*
			 * Object[] dadoDebitoACobrar = this.repositorioFaturamento
			 * .pesquisarDebitoACobrar(imovel.getId(), debitoTipo.getId(),
			 * sistema.getAnoMesFaturamento());
			 */

			// Cria a variável que vai armazenar o valor do débito
			BigDecimal valor = new BigDecimal("0");

			/*
			 * Caso o perfil do imóvel seja tarifa social o valor vai ser o
			 * valor da tarifa social Caso contrário o valor da tarifa vai ser o
			 * normal.
			 */
			if (!imovel.getImovelPerfil().getId()
					.equals(ImovelPerfil.TARIFA_SOCIAL)) {
				// caso o imóvel não seja enquadrado em tarifa social

				// Obtém o valor da Tarifa Normal
				BigDecimal valorMinimaTarifaNormal = this.repositorioFaturamento
						.obterValorTarifa(ConsumoTarifa.CONSUMO_NORMAL);

				// Caso o valor da tarifa normal esteja nulo seta o valor para
				// zero
				if (valorMinimaTarifaNormal == null) {
					valorMinimaTarifaNormal = new BigDecimal("0");
				}

				valor = valorMinimaTarifaNormal;

			} else if (imovel.getImovelPerfil().getId()
					.equals(ImovelPerfil.TARIFA_SOCIAL)) {
				// caso o imóvel seja enquadrado em tarifa social

				// Obtém o valor da Tarifa Social
				BigDecimal valorMinimaTarifaSocial = this.repositorioFaturamento
						.obterValorTarifa(ConsumoTarifa.CONSUMO_SOCIAL);

				// Caso o valor da tarifa social esteja nulo seta o valor para
				// zero
				if (valorMinimaTarifaSocial == null) {
					valorMinimaTarifaSocial = new BigDecimal("0");
				}

				valor = valorMinimaTarifaSocial;
			}

			// inclui Débito A Cobrar Geral
			DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
			debitoACobrarGeral
					.setIndicadorHistorico(DebitoACobrarGeral.INDICADOR_NAO_POSSUI_HISTORICO);
			debitoACobrarGeral.setUltimaAlteracao(new Date());
			Integer idDebitoACobrarGeral = (Integer) this.getControladorUtil()
					.inserir(debitoACobrarGeral);
			debitoACobrarGeral.setId(idDebitoACobrarGeral);

			// Cria uma instância de débito a cobrar
			DebitoACobrar debitoACobrar = new DebitoACobrar();
			debitoACobrar.setId(debitoACobrarGeral.getId());
			debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);

			// Seta o Imóvel
			debitoACobrar.setImovel(imovel);

			// Seta o Débito Tipo
			debitoACobrar.setDebitoTipo(debitoTipo);

			// Seta Data e Hora Atual
			debitoACobrar.setGeracaoDebito(dataAtual);

			// Seta ano/mês da conta emitida como 2 via
			debitoACobrar.setAnoMesReferenciaDebito(anoMesReferencia);

			// Seta Ano/Mês de Cobrança
			debitoACobrar.setAnoMesCobrancaDebito(sistema
					.getAnoMesArrecadacao());

			// Seta Ano/Mês Referência do Faturamento
			// Alteracao CRC1389 Data:09/03/2009
			// Author: Rômulo Aurélio
			// Analista: Rosana Carvalho

			int anoMesAtual = Util.getAnoMesComoInt(new Date());

			if (sistema.getAnoMesFaturamento().compareTo(anoMesAtual) < 0) {

				debitoACobrar.setAnoMesReferenciaContabil(anoMesAtual);

			} else {
				debitoACobrar.setAnoMesReferenciaContabil(sistema
						.getAnoMesFaturamento());
			}
			// Fim Alteracao CRC1389 Data:09/03/2009

			// Seta Valor do Débito
			BigDecimal valorMultiplicado = valor.multiply(new BigDecimal("10"));
			BigDecimal valorFinal = valorMultiplicado.divide(new BigDecimal(
					"100"), 2, BigDecimal.ROUND_HALF_UP);
			debitoACobrar.setValorDebito(valorFinal);

			// Seta Número de Prestações do Débito
			debitoACobrar.setNumeroPrestacaoDebito(new Short("1"));

			// Seta Número de Prestações Cobradas
			debitoACobrar.setNumeroPrestacaoCobradas(new Short("0"));

			// Seta Localidade
			debitoACobrar.setLocalidade(imovel.getLocalidade());

			// Seta Quadra
			debitoACobrar.setQuadra(imovel.getQuadra());

			// Seta Código do Setor Comercial
			debitoACobrar.setCodigoSetorComercial(imovel.getSetorComercial()
					.getCodigo());

			// Seta Número Quadra
			debitoACobrar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());

			// Seta Lote
			debitoACobrar.setNumeroLote(imovel.getLote());

			// Seta SubLote
			debitoACobrar.setNumeroSubLote(imovel.getSubLote());

			// Seta Taxa de Juros do Financiamento
			debitoACobrar.setPercentualTaxaJurosFinanciamento(new BigDecimal(
					"0"));

			// Seta Financiamento Tipo
			debitoACobrar.setFinanciamentoTipo(debitoTipo
					.getFinanciamentoTipo());

			// Seta Lançamento Item Contábil
			debitoACobrar.setLancamentoItemContabil(debitoTipo
					.getLancamentoItemContabil());

			// Seta Débito Crédito Situação
			debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

			// Seta Cobrança Forma
			debitoACobrar.setCobrancaForma(cobrancaForma);

			// Seta a data de ultima alteração
			debitoACobrar.setUltimaAlteracao(new Date());

			Integer idDebitoACobrar = (Integer) this.getControladorUtil()
					.inserir(debitoACobrar);

			debitoACobrar.setId(idDebitoACobrar);

			// Recupera Categorias por Imóvel
			Collection<Categoria> colecaoCategoria = this
					.getControladorImovel().obterQuantidadeEconomiasCategoria(
							imovel);
			// Recupera Valores por Categorias
			Collection<BigDecimal> colecaoValoresCategorias = this
					.getControladorImovel().obterValorPorCategoria(
							colecaoCategoria, valorFinal);
			// Insere débito a cobrar por categoria
			inserirDebitoACobrarCategoria(colecaoCategoria,
					colecaoValoresCategorias, debitoACobrar);

		} catch (Exception ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/*
	 * @author Vivianne Sousa @date 21/02/2007
	 * 
	 * @param colecaoCategoria @param colecaoValores @throws
	 * ControladorException
	 */
	protected void inserirDebitoACobrarCategoria(
			Collection<Categoria> colecaoCategoria,
			Collection<BigDecimal> colecaoValoresCategorias,
			DebitoACobrar debitoACobrar) throws ControladorException {

		DebitoACobrarCategoria debitoACobrarCategoria = null;
		BigDecimal valorCategoria = new BigDecimal(0);
		DebitoACobrarCategoriaPK debitoACobrarCategoriaPK = null;
		Iterator iColecaoValoresCategorias = colecaoValoresCategorias
				.iterator();

		for (Categoria categoria : colecaoCategoria) {

			debitoACobrarCategoriaPK = new DebitoACobrarCategoriaPK();
			debitoACobrarCategoriaPK.setCategoria(categoria);
			debitoACobrarCategoriaPK.setDebitoACobrar(debitoACobrar);

			debitoACobrarCategoria = new DebitoACobrarCategoria();

			debitoACobrarCategoria.setComp_id(debitoACobrarCategoriaPK);

			debitoACobrarCategoria.setQuantidadeEconomia(categoria
					.getQuantidadeEconomiasCategoria());

			// valorCategoria = colecaoValoresCategorias.iterator().next();
			valorCategoria = (BigDecimal) iColecaoValoresCategorias.next();

			debitoACobrarCategoria.setValorCategoria(valorCategoria);

			debitoACobrarCategoria.setUltimaAlteracao(new Date());

			this.getControladorUtil().inserir(debitoACobrarCategoria);
		}
	}

	/**
	 * atualiza a guia de pagamento na tabela GUIA_PAGAMENTO
	 * (DCST_IDANTERIOR=DCST_IDATUAL e DCST_IDATUAL=DCST_ID da tabela
	 * DEBITO_CREDITO_SITUACAO com o valor correspondente a Cancelada).
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * 
	 * @param guiaPagamentoManter
	 * @param operacaoEfetuada
	 * @param registradorOperacao
	 * @param usuarioLogado
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarGuiaPagamento(GuiaPagamento guiaPagamentoManter,
			OperacaoEfetuada operacaoEfetuada,
			RegistradorOperacao registradorOperacao, Usuario usuarioLogado)
			throws ControladorException {

		try {

			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			if (guiaPagamentoManter.getAnoMesReferenciaContabil().intValue() >= sistemaParametro
					.getAnoMesFaturamento().intValue()) {

				// SITUAÇÃO ANTERIOR
				guiaPagamentoManter
						.setDebitoCreditoSituacaoAnterior(guiaPagamentoManter
								.getDebitoCreditoSituacaoAtual());
			} else {

				// SITUAÇÃO ANTERIOR
				guiaPagamentoManter.setDebitoCreditoSituacaoAnterior(null);

				// REFERÊNCIA CONTÁBIL
				guiaPagamentoManter
						.setAnoMesReferenciaContabil(sistemaParametro
								.getAnoMesFaturamento());
			}

			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.CANCELADA);

			// SITUAÇÃO ATUAL
			guiaPagamentoManter
					.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

			// Seta os parametros do filtro

			FiltroGuiaPagamento filtroGuiaPagamentoBase = new FiltroGuiaPagamento();
			filtroGuiaPagamentoBase.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamento.ID, guiaPagamentoManter.getId()));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection guiasPagamentosBase = getControladorUtil().pesquisar(
					filtroGuiaPagamentoBase, GuiaPagamento.class.getName());

			GuiaPagamento guiaPagamentoBase = (GuiaPagamento) Util
					.retonarObjetoDeColecao(guiasPagamentosBase);

			if (guiasPagamentosBase != null && !guiasPagamentosBase.isEmpty()) {

				// Verifica se a data de alteração do objeto
				// gravado na base é
				// maior que a na instancia
				if ((guiaPagamentoBase.getUltimaAlteracao()
						.after(guiaPagamentoManter.getUltimaAlteracao()))) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.atualizacao.timestamp");

				}

			} else {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.removido");
			}

			guiaPagamentoManter.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			guiaPagamentoManter.setOperacaoEfetuada(operacaoEfetuada);
			guiaPagamentoManter.adicionarUsuario(usuarioLogado,
					UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(guiaPagamentoManter);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			guiaPagamentoManter.setUsuario(usuarioLogado);
			/**
			 * alterado por pedro alexandre dia 23/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA
			// ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado,
					guiaPagamentoManter.getImovel());

			if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.acesso.negado.abrangencia");
			} else {
				getControladorUtil().atualizar(guiaPagamentoManter);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA
			// ----------------

			// CRC2725 - alterado por Vivianne Sousa - 23/09/2009
			// analista:Fátima
			// 2.1.2.2.Verificar se há relação do cancelamento com itens de
			// negativação
			getControladorSpcSerasa()
					.verificarRelacaoDoCancelamentoComItensNegativacao(
							guiaPagamentoManter);

		} catch (ControladorException ex) {
			sessionContext.setRollbackOnly();
			throw ex;
		} catch (Exception ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * verifica se há restrições em remover Guia de Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * 
	 * @param idGuiaPagamento
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	private boolean verificarRestricoesRemoverGuiaPagamento(
			Integer idGuiaPagamento) throws ControladorException {

		try {
			boolean retorno = false;

			Collection colecaoGuiasPagamentoParcelamentoItem = repositorioFaturamento
					.obterGuiasPagamentoParcelamentoItem(idGuiaPagamento);

			if (colecaoGuiasPagamentoParcelamentoItem != null
					&& !colecaoGuiasPagamentoParcelamentoItem.isEmpty()) {

				retorno = true;

			} else {

				Collection colecaoGuiasPagamentoCobrancaDocumentoItem = repositorioFaturamento
						.obterGuiasPagamentoCobrancaDocumentoItem(idGuiaPagamento);

				if (colecaoGuiasPagamentoCobrancaDocumentoItem != null
						&& !colecaoGuiasPagamentoCobrancaDocumentoItem
								.isEmpty()) {

					retorno = true;

				} else {
					Collection colecaoGuiasPagamentoPagamento = repositorioFaturamento
							.obterGuiasPagamentoPagamento(idGuiaPagamento);

					if (colecaoGuiasPagamentoPagamento != null
							&& !colecaoGuiasPagamentoPagamento.isEmpty()) {

						retorno = true;

					} else {
						// adicionado por Vivianne Sousa - 23/09/2009 -
						// analista:Fatima
						Collection colecaoNmriAssociadosAGuiaPagamento = getControladorSpcSerasa()
								.pesquisarNegativadorMovimentoRegItemAssociadosAGuiaPagamento(
										idGuiaPagamento);

						if (colecaoNmriAssociadosAGuiaPagamento != null
								&& !colecaoNmriAssociadosAGuiaPagamento
										.isEmpty()) {

							retorno = true;

						}
					}
				}

			}

			return retorno;

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		} catch (ControladorException ex) {
			sessionContext.setRollbackOnly();
			throw ex;
		} catch (Exception ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Recupera as contas
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImoveis(Integer anoMes,
			Collection idsImovel, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim,
			String indicadorContaPaga) throws ControladorException {

		try {

			return repositorioFaturamento.pesquisarContasImoveis(anoMes,
					idsImovel, dataVencimentoContaInicio,
					dataVencimentoContaFim, anoMesFim, indicadorContaPaga);

		} catch (ErroRepositorioException ex2) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex2);
		}
	}

	/**
	 * Informar Tarifa de Consumo por Subcategoria
	 * 
	 * @autor Tiago Moreno
	 * @date 05/01/2006
	 * @param consumoTarifa
	 * @param consumoTarifaVigencia
	 * @param colecaoConsumoTarifaCategoria
	 * @param colecaoConsumoTarifaFaixa
	 * @throws ControladorException
	 */

	public void informarConsumoTarifaSubcategoria(ConsumoTarifa consumoTarifa,
			ConsumoTarifaVigencia consumoTarifaVigencia,
			Collection<ConsumoTarifaCategoria> colecaoConsumoTarifaCategoria)
			throws ControladorException {

		// Caso o objeto ConsumoTarifa já exista na base
		if (consumoTarifa.getId() != null) {

			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia
					.adicionarParametro(new ParametroSimples(
							FiltroConsumoTarifaVigencia.CONSUMO_TARIFA_ID,
							consumoTarifa.getId()));
			filtroConsumoTarifaVigencia
					.adicionarParametro(new ParametroSimples(
							FiltroConsumoTarifaVigencia.DATA_VIGENCIA,
							consumoTarifaVigencia.getDataVigencia()));
			Collection colecaoConsumoVigenciaExistente = getControladorUtil()
					.pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());

			consumoTarifaVigencia = (ConsumoTarifaVigencia) colecaoConsumoVigenciaExistente
					.iterator().next();
		} else {

			// Obtendo o ID gerado pelo BD
			Integer idConsumoTarifaGerado = (Integer) this.getControladorUtil()
					.inserir(consumoTarifa);

			// Carregando o novo objeto ConsumoTarifa
			consumoTarifa.setId(idConsumoTarifaGerado);
			consumoTarifaVigencia.setConsumoTarifa(consumoTarifa);

			// Inserindo o objeto ConsumoTarifaVigencia no BD
			Integer i = (Integer) this.getControladorUtil().inserir(
					consumoTarifaVigencia);
			consumoTarifaVigencia.setId(i);
		}

		// Para cada categoria: O sistema inserir um objeto do tipo
		// ConsumoTarifaCategoria

		Iterator colecaoConsumoTarifaCategoriaIt = colecaoConsumoTarifaCategoria
				.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoriaColecao = null;

		while (colecaoConsumoTarifaCategoriaIt.hasNext()) {
			consumoTarifaCategoriaColecao = (ConsumoTarifaCategoria) colecaoConsumoTarifaCategoriaIt
					.next();

			consumoTarifaCategoriaColecao
					.setConsumoTarifaVigencia(consumoTarifaVigencia);

			Subcategoria subcategoria = new Subcategoria();
			if (consumoTarifaCategoriaColecao.getSubCategoria().getId() == null) {
				consumoTarifaCategoriaColecao.getSubCategoria().setId(0);
			}
			subcategoria.setId(consumoTarifaCategoriaColecao.getSubCategoria()
					.getId());
			consumoTarifaCategoriaColecao.setSubCategoria(subcategoria);

			Integer codigoConsumoTarifaCategoriaColecao = (Integer) this
					.getControladorUtil()
					.inserir(consumoTarifaCategoriaColecao);
			consumoTarifaCategoriaColecao
					.setId(codigoConsumoTarifaCategoriaColecao);

			Collection consumoTarifaFaixa = new ArrayList(
					consumoTarifaCategoriaColecao.getConsumoTarifaFaixas());
			Collections.sort((List) consumoTarifaFaixa, new Comparator() {
				public int compare(Object a, Object b) {
					Integer numeroConsumoFaixaInicio1 = ((ConsumoTarifaFaixa) a)
							.getNumeroConsumoFaixaInicio();
					Integer numeroConsumoFaixaInicio2 = ((ConsumoTarifaFaixa) b)
							.getNumeroConsumoFaixaInicio();

					return numeroConsumoFaixaInicio1
							.compareTo(numeroConsumoFaixaInicio2);

				}
			});

			Iterator colecaoConsumoTarifaFaixaIt = consumoTarifaFaixa
					.iterator();

			while (colecaoConsumoTarifaFaixaIt.hasNext()) {
				ConsumoTarifaFaixa consumoTarifaFaixaColecao = (ConsumoTarifaFaixa) colecaoConsumoTarifaFaixaIt
						.next();

				consumoTarifaFaixaColecao
						.setConsumoTarifaCategoria(consumoTarifaCategoriaColecao);

				this.getControladorUtil().inserir(consumoTarifaFaixaColecao);
			}

		}

		// Para cada faixa informada para categori: O sistema inserir um objeto
		// do tipo ConsumoTarifaFaixa

	}

	/**
	 * [UC0147] - Cancelar Conjunto Conta
	 * 
	 * @author Ana Maria, Raphael Rossiter
	 * @date 10/12/2005, 27/02/2008
	 * 
	 * @param colecaoContas
	 * @param identificadores
	 * @param contaMotivoCancelamento
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void cancelarConjuntoConta(Collection colecaoImovel,
			ContaMotivoCancelamento contaMotivoCancelamento, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim, Usuario usuarioLogado, String indicadorContaPaga)
			throws ControladorException {

		Collection colecaoContasManutencao = new ArrayList();
		Collection colecaoConta = new ArrayList();
		List colecaoAuxiliar = new ArrayList();

		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		colecaoAuxiliar.addAll(colecaoImovel);

		int i = 0;
		int cont = 500;

		Collection colecao = new ArrayList();
		while (i <= colecaoImovel.size()) {

			colecao.clear();
			colecaoConta.clear();

			if (colecaoImovel.size() - i >= cont) {
				colecao.addAll(colecaoAuxiliar.subList(i, i + cont));
			} else {
				colecao.addAll(colecaoAuxiliar.subList(i, colecaoImovel.size()));
			}

			i = i + cont;
			try {
				colecaoContasManutencao = repositorioFaturamento
						.pesquisarContasImoveis(anoMes, colecao,
								dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFim,
								indicadorContaPaga);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}
			if (colecaoContasManutencao != null
					&& !colecaoContasManutencao.isEmpty()) {

				/**
				 * [UC0407] Filtrar Imóveis para Inserir ou Manter Conta 3. Caso
				 * o indicador de bloqueio de contas vinculadas a contrato de
				 * parcelamento no manter contas esteja ativo retirar da lista
				 * de contas selecionadas as contas vinculadas a algum contrato
				 * de parcelamento ativo
				 * 
				 * RM 1887 - Contrato Parcelamento por Cliente Adicionado por:
				 * Mariana Victor Data: 21/07/2011
				 * 
				 * */
				if (sistemaParametro
						.getIndicadorBloqueioContasContratoParcelManterConta() != null
						&& sistemaParametro
								.getIndicadorBloqueioContasContratoParcelManterConta()
								.equals(ConstantesSistema.SIM)) {
					colecaoContasManutencao = getControladorRetificarConta()
							.obterColecaoSemContasEmContratoParcelamentoRetificarConjuntoContasIds(colecaoContasManutencao);
				}
				/**
				 * FIM DA ALTERAÇÂO
				 * */

				Iterator colecaoContasManutencaoIterator = colecaoContasManutencao
						.iterator();

				while (colecaoContasManutencaoIterator.hasNext()) {

					// Obtém os dados do crédito realizado
					Object[] contaArray = (Object[]) colecaoContasManutencaoIterator
							.next();

					Conta conta = new Conta();
					// ID da conta
					conta.setId((Integer) contaArray[0]);
					// Ano Mês referencia
					conta.setReferencia((Integer) contaArray[1]);
					// DebitoCreditoSituacaoAtual
					conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);
					// Ano Mês referencia contábil
					conta.setReferenciaContabil((Integer) contaArray[12]);

					// imovel
					if (contaArray[14] != null) {
						conta.setImovel((Imovel) contaArray[14]);
					}

					// DebitoCreditoSituacaoAnterior
					if (contaArray[15] != null) {
						conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[15]);
					}

					colecaoConta.add(conta);
				}
			}

			Iterator colecaoContasIt = colecaoConta.iterator();
			Conta contaColecao = null;
			// Conta contaNaBase = null;
			FiltroConta filtroConta = new FiltroConta();

			while (colecaoContasIt.hasNext()) {
				contaColecao = (Conta) colecaoContasIt.next();

				// Usuário logado
				contaColecao.setUsuario(usuarioLogado);

				// Carregando a conta que está na base
				filtroConta.adicionarParametro(new ParametroSimples(
						FiltroConta.ID, contaColecao.getId()));

				filtroConta.limparListaParametros();
				/**
				 * Caso a situação atual da conta corresponda a normal
				 * (DCST_IDATUAL com o valor correspondente a normal da tabela
				 * DEBITO_CREDITO_SITUACAO) ou corresponda a retificada ou
				 * incluída (DCST_IDATUAL com o valor correspondente a
				 * retificada ou incluída, da tabela DEBITO_CREDITO_SITUACAO) e
				 * a retificação ou inclusão já tenha sido contabilizada
				 * (CNTA_AMREFERENCIACONTABIL menor que
				 * PARM_AMREFERENCIAFATURAMENTO da tabela SISTEMA_PARAMETROS),
				 * atualizar os seguintes atributos da conta.
				 */

				if (isContaNormalIncluidaOuRetificadaEReferenciaContabilMenor(contaColecao, sistemaParametro)) {

					// Data do cancelamento
					contaColecao.setDataCancelamento(new Date());

					// Motivo do Cancelamento
					contaColecao
							.setContaMotivoCancelamento(contaMotivoCancelamento);

					// Situação Anterior
					/*
					 * Caso a situação atual da conta corresponda a normal
					 * (DCST_IDATUAL com o valor correspondente a normal da
					 * tabela DEBITO_CREDITO_SITUACAO) e a conta tenha sido
					 * faturada no mês de faturamento corrente
					 * (CNTA_AMREFERENCIACONTA= PARM_AMREFERENCIAFATURAMENTO da
					 * tabela SISTEMA_PARAMETROS) DCST_IDANTERIOR=DCST_IDATUAL,
					 * caso contrário DCST_IDANTERIOR=nulo)
					 */
					if (contaColecao.getDebitoCreditoSituacaoAtual().getId()
							.equals(DebitoCreditoSituacao.NORMAL)
							&& Util.compararAnoMesReferencia(new Integer(
									contaColecao.getReferencia()), new Integer(
									sistemaParametro.getAnoMesFaturamento()),
									"=")) {

						contaColecao
								.setDebitoCreditoSituacaoAnterior(contaColecao
										.getDebitoCreditoSituacaoAtual());
					} else {
						contaColecao.setDebitoCreditoSituacaoAnterior(null);
					}

					// Situação Atual
					DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
					/**
					 * Caso motivo de retificação seja débito
					 * prescrito, alterar a situação da conta para 8.
					 * 
					 * @author Wellington Rocha
					 * @date 01/06/2012
					 * 
					 * */
					boolean contaPodeSerPrescrita = true;
					if (contaMotivoCancelamento.getId().equals(
							ContaMotivoCancelamento.DEBITO_PRESCRITO)
							|| contaMotivoCancelamento.getId().equals(
									ContaMotivoCancelamento.PRESCRICAO)) {

						contaPodeSerPrescrita = this
								.verificarPossibilidadePrescricaoConta(contaColecao
										.getId());
						if (contaPodeSerPrescrita) {
							debitoCreditoSituacao
									.setId(DebitoCreditoSituacao.DEBITO_PRESCRITO);
						}
					} else {
						debitoCreditoSituacao
								.setId(DebitoCreditoSituacao.CANCELADA);
					}

					if (!contaPodeSerPrescrita) {
						throw new ControladorException(
								"erro.conta_nao_satisfaz_criterios_para_prescricao",
								"exibirCancelarContaAction.do?contaID="
										+ contaColecao.getId() + "&idImovel="
										+ contaColecao.getImovel().getId(),
								null);
					} else {

						contaColecao
								.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

						// Colocado por Raphael Rossiter em 27/02/2008
						// Ano Mes Referencia Contabil
						if (contaColecao.getReferencia() <= sistemaParametro
								.getAnoMesFaturamento().intValue()) {

							contaColecao.setReferenciaContabil(Util
									.getAnoMesComoInteger(new Date()));
						}

						// Usuario
						contaColecao.setUsuario(usuarioLogado);

						// última alteração
						contaColecao.setUltimaAlteracao(new Date());

						/*
						 * Alterado por Raphael Rossiter em 30/07/2007
						 * (Analista: Rosana Carvalho)
						 * 
						 * OBJETIVO: Quando o mes/ano de faturamento for maior
						 * que o mes/ano de faturamento atual, não alterar o
						 * mes/ano contábil
						 */

						// Ano Mes Referencia Contabil
						if (contaColecao.getReferencia() <= sistemaParametro
								.getAnoMesFaturamento().intValue()) {

							contaColecao.setReferenciaContabil(Util
									.getAnoMesComoInteger(new Date()));
						}

						/*
						 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO:
						 * Gravar na tabela de conta o usuário que está logado
						 * no sistema
						 */

						// Usuario
						contaColecao.setUsuario(usuarioLogado);

						// ------------ <REGISTRAR
						// TRANSAÇÃO>----------------------------

						RegistradorOperacao registradorOperacao = new RegistradorOperacao(
								Operacao.OPERACAO_CANCELAR_CONTA,
								contaColecao.getImovel() != null ? contaColecao
										.getImovel().getId() : contaColecao
										.getId(),
								contaColecao.getId(),
								new UsuarioAcaoUsuarioHelper(
										usuarioLogado,
										UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						registradorOperacao.registrarOperacao(contaColecao);

						getControladorTransacao().registrarTransacao(
								contaColecao);

						// ------------ </REGISTRAR
						// TRANSAÇÃO>----------------------------

						// UPDATE
						try {

							if (contaColecao.getDebitoCreditoSituacaoAnterior() == null) {
								repositorioFaturamento
										.cancelarContaReferenciaContabilMenorSistemaParametro(
												contaColecao, null);

							} else {
								repositorioFaturamento
										.cancelarContaReferenciaContabilMenorSistemaParametro(
												contaColecao,
												contaColecao
														.getDebitoCreditoSituacaoAnterior()
														.getId());
							}

							// CRC2725 - alterado por Vivianne Sousa -
							// 30/03/2010
							// analista:Fátima
							// 1.1.2.Verificar se há relação do cancelamento com
							// itens de negativação
							getControladorSpcSerasa()
									.verificarRelacaoDoCancelamentoComItensNegativacao(
											contaColecao, null);

						} catch (ErroRepositorioException ex) {
							sessionContext.setRollbackOnly();
							new ControladorException("erro.sistema", ex);
						} catch (ControladorException ex) {
							sessionContext.setRollbackOnly();
							throw ex;
						} catch (Exception ex) {
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", ex);
						}

					}
				} else if (isContaIncluidaOuRetificadaEReferenciaContabilMaiorOuIgual(contaColecao, sistemaParametro)) {

					// Remoção da conta no BD
					contaColecao.setPercentualEsgoto(new BigDecimal("0.00"));

					// CRC2725 - alterado por Vivianne Sousa - 17/09/2009
					// analista:Fátima
					// [FS0003 - Verificar existência de itens de negativação
					// para a conta incluída]:
					getControladorSpcSerasa()
							.verificarExistenciaItensNegativacaoParaContaIncluida(
									contaColecao);
					// 1.2.4. Verificar se há relação do cancelamento com itens
					// de negativação:
					// [UC0937 - Obter Itens de Negativação Associados à Conta]
					// passando o identificador do imóvel (Imóvel da Conta
					// Retificada e Cancelada)
					// e a referência (Referência da Conta Retificada e
					// Cancelada).
					Collection colecaoNegativadorMovimentoRegItem = getControladorSpcSerasa()
							.obterItensNegativacaoAssociadosAConta(
									contaColecao.getImovel().getId(),
									contaColecao.getReferencia());

					this.getControladorUtil().remover(
							new String[] { "" + contaColecao.getId() },
							contaColecao.getClass().getName(), null, null);

					if (contaColecao.getDebitoCreditoSituacaoAtual().getId()
							.equals(DebitoCreditoSituacao.RETIFICADA)) {

						// [FS0002] - Verificar existência da conta
						// cancelada por retificação

						filtroConta.adicionarParametro(new ParametroSimples(
								FiltroConta.REFERENCIA, contaColecao
										.getReferencia()));

						filtroConta
								.adicionarParametro(new ParametroSimples(
										FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
										DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO));

						Collection colecaoContaCanceladaRetificacao = this
								.getControladorUtil().pesquisar(filtroConta,
										Conta.class.getName());

						filtroConta.limparListaParametros();

						if (colecaoContaCanceladaRetificacao == null
								|| colecaoContaCanceladaRetificacao.isEmpty()) {
							throw new ControladorException(
									"atencao.pesquisa.nenhuma.conta_cancelada_retificacao");
						}

						Conta contaCanceladaPorRetificacao = (Conta) Util
								.retonarObjetoDeColecao(colecaoContaCanceladaRetificacao);

						// Data do cancelamento
						contaCanceladaPorRetificacao
								.setDataCancelamento(new Date());

						// Motivo do cancelamento
						contaCanceladaPorRetificacao
								.setContaMotivoCancelamento(contaMotivoCancelamento);

						// Situação Atual
						DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
						debitoCreditoSituacao
								.setId(DebitoCreditoSituacao.CANCELADA);
						contaCanceladaPorRetificacao
								.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

						// Data da retificação = NULL
						contaCanceladaPorRetificacao.setDataRetificacao(null);

						// Motivo da retificação = NULL
						contaCanceladaPorRetificacao
								.setContaMotivoRetificacao(null);

						// Colocado por Raphael Rossiter em 27/02/2008
						// Ano Mês de referência contábil
						if (contaCanceladaPorRetificacao.getReferencia() <= sistemaParametro
								.getAnoMesFaturamento().intValue()) {

							contaCanceladaPorRetificacao
									.setReferenciaContabil(Util
											.getAnoMesComoInteger(new Date()));
						}

						/*
						 * Alterado por Raphael Rossiter em 30/07/2007
						 * (Analista: Rosana Carvalho)
						 * 
						 * OBJETIVO: Quando o mes/ano de faturamento for maior
						 * que o mes/ano de faturamento atual, não alterar o
						 * mes/ano contábil
						 */

						// Ano Mês de referência contábil do faturamento
						if (contaCanceladaPorRetificacao.getReferencia() <= sistemaParametro
								.getAnoMesFaturamento().intValue()) {

							contaCanceladaPorRetificacao
									.setReferenciaContabil(Util
											.getAnoMesComoInteger(new Date()));
						}

						// última alteração
						contaCanceladaPorRetificacao
								.setUltimaAlteracao(new Date());

						/*
						 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO:
						 * Gravar na tabela de conta o usuário que está logado
						 * no sistema
						 */

						// Usuario
						contaCanceladaPorRetificacao.setUsuario(usuarioLogado);

						// ------------ <REGISTRAR
						// TRANSAÇÃO>----------------------------

						RegistradorOperacao registradorOperacao = new RegistradorOperacao(
								Operacao.OPERACAO_CANCELAR_CONTA,
								contaCanceladaPorRetificacao.getImovel() != null ? contaCanceladaPorRetificacao
										.getImovel().getId() : contaColecao
										.getId(),
								contaColecao.getId(),
								new UsuarioAcaoUsuarioHelper(
										usuarioLogado,
										UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						registradorOperacao
								.registrarOperacao(contaCanceladaPorRetificacao);

						getControladorTransacao().registrarTransacao(
								contaCanceladaPorRetificacao);

						// ------------ </REGISTRAR
						// TRANSAÇÃO>----------------------------

						// UPDATE
						try {
							repositorioFaturamento
									.cancelarContaReferenciaContabilMaiorIgualSistemaParametro(contaCanceladaPorRetificacao);

							// CRC2725 - alterado por Vivianne Sousa -
							// 30/03/2010 analista:Fátima
							// 1.2.6.5. Caso existam itens de negativação
							// associados à conta (coleção de itens de
							// negativação não está vazia):
							if (colecaoNegativadorMovimentoRegItem != null
									&& !colecaoNegativadorMovimentoRegItem
											.isEmpty()) {
								// Caso existam itens de negativação associados
								// à conta:
								Iterator iterNmri = colecaoNegativadorMovimentoRegItem
										.iterator();
								while (iterNmri.hasNext()) {
									Integer idNmri = (Integer) iterNmri.next();
									// [SB0002 - Atualizar Item Negativação -
									// Conta Retificada].
									getControladorSpcSerasa()
											.atualizarNegativadorMovimentoRegItem(
													idNmri,
													new Date(),
													CobrancaDebitoSituacao.CANCELADO,
													contaCanceladaPorRetificacao
															.getId(),
													contaColecao.getId());
								}
							}

						} catch (ErroRepositorioException ex) {
							sessionContext.setRollbackOnly();
							new ControladorException("erro.sistema", ex);
						} catch (ControladorException ex) {
							sessionContext.setRollbackOnly();
							throw ex;
						} catch (Exception ex) {
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", ex);
						}

					}

				}

				// Alterado por Francisco - 26/05/08, por conta do Resumo de
				// Ações de cobrança
				// Analista: Ana Breda
				try {
					// Atualizar documento de cobranca da conta, se houver, para
					// cancelado
					repositorioCobranca.atualizarSituacaoCobrancaDocumentoItem(
							CobrancaDebitoSituacao.CANCELADO, new Date(),
							contaColecao.getId(), null, null);
				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					new ControladorException("erro.sistema", ex);
				}

			}

		}
	}
	
	public void alterarVencimentoConjuntoConta(Collection colecaoImovel,
			Date dataVencimentoInformada, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim, Usuario usuario, String indicadorContaPaga,
			String[] bancos) throws ControladorException {
		
		alterarVencimentoConjuntoConta(colecaoImovel, dataVencimentoInformada, anoMes, dataVencimentoContaInicio, dataVencimentoContaFim,
				anoMesFim, usuario, indicadorContaPaga, bancos, false);
		
	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Ana Maria
	 * @date 20/01/2007
	 * 
	 * @param colecaoContas
	 * @param dataVencimento
	 * @throws ControladorException
	 */
	public void alterarVencimentoConjuntoConta(Collection colecaoImovel,
			Date dataVencimentoInformada, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim, Usuario usuario, String indicadorContaPaga,
			String[] bancos, boolean isDebitoAutomatico) throws ControladorException {

		Collection colecaoContasManutencao = new ArrayList();
		Collection colecaoConta = new ArrayList();
		List colecaoAuxiliar = new ArrayList();

		// PARÂMETROS DO SISTEMA
		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		colecaoAuxiliar.addAll(colecaoImovel);

		int i = 0;
		int cont = 200;

		if (bancos != null) {
			this.alterarVencimentoConjuntoContaBanco(colecaoImovel,
					dataVencimentoInformada, anoMes, dataVencimentoContaInicio,
					dataVencimentoContaFim, anoMesFim, usuario,
					indicadorContaPaga, bancos);
		} else {

			Collection colecao = new ArrayList();
			while (i <= colecaoImovel.size()) {

				if (colecaoImovel.size() - i >= cont) {
					colecao = colecaoAuxiliar.subList(i, i + cont);
				} else {
					colecao = colecaoAuxiliar.subList(i, colecaoImovel.size());
				}

				if (colecao.size() == ConstantesSistema.ZERO.intValue()) {
					break;
				}

				i = i + cont;
				try {
					colecaoContasManutencao = repositorioFaturamento.pesquisarContasImoveis(colecao, anoMes, dataVencimentoContaInicio,
							dataVencimentoContaFim, anoMesFim, indicadorContaPaga, dataVencimentoInformada, isDebitoAutomatico);
					
					/**
					 * [UC0407] Filtrar Imóveis para Inserir ou Manter Conta 3.
					 * Caso o indicador de bloqueio de contas vinculadas a
					 * contrato de parcelamento no manter contas esteja ativo
					 * retirar da lista de contas selecionadas as contas
					 * vinculadas a algum contrato de parcelamento ativo
					 * 
					 * RM 1887 - Contrato Parcelamento por Cliente Adicionado
					 * por: Mariana Victor Data: 15/07/2011
					 * 
					 * */
					if (sistemaParametro.getIndicadorBloqueioContasContratoParcelManterConta() != null
							&& sistemaParametro.getIndicadorBloqueioContasContratoParcelManterConta().equals(ConstantesSistema.SIM)) {
						colecaoContasManutencao = getControladorRetificarConta().obterColecaoSemContasEmContratoParcelamentoRetificarConjuntoContasIds(colecaoContasManutencao);
					}
					/**
					 * FIM DA ALTERAÇÂO
					 * */

				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					new ControladorException("erro.sistema", ex);
				}

				if (colecaoContasManutencao != null
						&& !colecaoContasManutencao.isEmpty()) {

					Iterator colecaoContasManutencaoIterator = colecaoContasManutencao
							.iterator();
					while (colecaoContasManutencaoIterator.hasNext()) {

						// Obtém os dados do crédito realizado
						Object[] contaArray = (Object[]) colecaoContasManutencaoIterator
								.next();

						Conta conta = new Conta();
						// ID da conta
						conta.setId((Integer) contaArray[0]);

						// Data de vencimento
						String vencimento = String.valueOf(contaArray[2]);
						SimpleDateFormat formatoData = new SimpleDateFormat(
								"yyyy-MM-dd");
						Date dataVencimento;

						try {
							dataVencimento = formatoData.parse(vencimento);
						} catch (java.text.ParseException e) {
							dataVencimento = null;
						}

						conta.setDataVencimentoConta(dataVencimento);

						// Data de validade
						String validade = String.valueOf(contaArray[9]);
						Date dataValidade;

						try {

							dataValidade = formatoData.parse(validade);
						} catch (java.text.ParseException e) {
							dataValidade = null;
						}

						conta.setDataValidadeConta(dataValidade);

						conta.setUltimaAlteracao(new Date());

						/*
						 * Colocado por Raphael Rossiter em 27/12/2007 OBJ:
						 * Carregar o id do imóvel para registrar a transação
						 */
						Imovel imovel = (Imovel) contaArray[14];
						conta.setImovel(imovel);

						colecaoConta.add(conta);
					}
				}
				alterarVencimentoConta(colecaoConta, null,
						dataVencimentoInformada, usuario);
			}
		}
	}

	// flavio leonardo - alterar vencimento com banco como parametro 04/05/2009
	public void alterarVencimentoConjuntoContaBanco(Collection colecaoImovel,
			Date dataVencimentoInformada, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim, Usuario usuario, String indicadorContaPaga,
			String[] bancos) throws ControladorException {

		List colecaoAuxiliar = new ArrayList();

		colecaoAuxiliar.addAll(colecaoImovel);

		int i = 0;
		int cont = 200;
		Collection colecao = new ArrayList();
		while (i <= colecaoImovel.size()) {

			if (colecaoImovel.size() - i >= cont) {
				colecao = colecaoAuxiliar.subList(i, i + cont);
			} else {
				colecao = colecaoAuxiliar.subList(i, colecaoImovel.size());
			}

			if (colecao.size() == ConstantesSistema.ZERO.intValue()) {
				break;
			}

			i = i + cont;

			Collection colecaoContasManutencao = new ArrayList();
			Collection colecaoConta = new ArrayList();

			// PARÂMETROS DO SISTEMA
			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			try {
				colecaoContasManutencao = repositorioFaturamento
						.pesquisarContasImoveis(anoMes, colecao,
								dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFim,
								indicadorContaPaga);

				/**
				 * [UC0407] Filtrar Imóveis para Inserir ou Manter Conta 3. Caso
				 * o indicador de bloqueio de contas vinculadas a contrato de
				 * parcelamento no manter contas esteja ativo retirar da lista
				 * de contas selecionadas as contas vinculadas a algum contrato
				 * de parcelamento ativo
				 * 
				 * RM 1887 - Contrato Parcelamento por Cliente Adicionado por:
				 * Mariana Victor Data: 15/07/2011
				 * 
				 * */
				if (sistemaParametro
						.getIndicadorBloqueioContasContratoParcelManterConta() != null
						&& sistemaParametro
								.getIndicadorBloqueioContasContratoParcelManterConta()
								.equals(ConstantesSistema.SIM)) {
					colecaoContasManutencao = getControladorRetificarConta()
							.obterColecaoSemContasEmContratoParcelamentoRetificarConjuntoContasIds(colecaoContasManutencao);
				}
				/**
				 * FIM DA ALTERAÇÂO
				 * */

			} catch (ErroRepositorioException e1) {
				e1.printStackTrace();
			}

			if (colecaoContasManutencao != null
					&& !colecaoContasManutencao.isEmpty()) {

				Iterator colecaoContasManutencaoIterator = colecaoContasManutencao
						.iterator();
				while (colecaoContasManutencaoIterator.hasNext()) {

					// Obtém os dados do crédito realizado
					Object[] contaArray = (Object[]) colecaoContasManutencaoIterator
							.next();

					Conta conta = new Conta();
					// ID da conta
					conta.setId((Integer) contaArray[0]);

					// Data de vencimento
					String vencimento = String.valueOf(contaArray[2]);
					SimpleDateFormat formatoData = new SimpleDateFormat(
							"yyyy-MM-dd");
					Date dataVencimento;

					try {
						dataVencimento = formatoData.parse(vencimento);
					} catch (java.text.ParseException e) {
						dataVencimento = null;
					}

					conta.setDataVencimentoConta(dataVencimento);

					// Data de validade
					String validade = String.valueOf(contaArray[9]);
					Date dataValidade;

					try {

						dataValidade = formatoData.parse(validade);
					} catch (java.text.ParseException e) {
						dataValidade = null;
					}

					conta.setDataValidadeConta(dataValidade);

					conta.setUltimaAlteracao(new Date());

					/*
					 * Colocado por Raphael Rossiter em 27/12/2007 OBJ: Carregar
					 * o id do imóvel para registrar a transação
					 */
					Imovel imovel = (Imovel) contaArray[14];
					conta.setImovel(imovel);

					colecaoConta.add(conta);
				}
			}
			alterarVencimentoConta(colecaoConta, null, dataVencimentoInformada,
					usuario);
		}
	}

	
	/**
	 * 
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * 
	 * @param anoMes
	 * @param colecaoClientes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void chamarGerarArquivoTextoFaturamento(int anoMes,
			String idCliente, Collection colecaoClientesAptos) {

		Collection colecaoClientes = new ArrayList();

		if (idCliente.trim().equals("T")) {
			Iterator iterator = colecaoClientesAptos.iterator();
			while (iterator.hasNext()) {
				colecaoClientes.add(((Cliente) iterator.next()).getId());
			}
		} else {
			colecaoClientes.add(new Integer(idCliente));
		}

		Iterator iteratorCliente = colecaoClientes.iterator();
		while (iteratorCliente.hasNext()) {
			Integer idClienteGerar = (Integer) iteratorCliente.next();
			try {
				this.gerarArquivoTextoFaturamento(anoMes, idClienteGerar);
			} catch (ControladorException e) {
				e.printStackTrace();
			}
		}

	}

	/**
	 * 
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * 
	 * @param anoMes
	 * @param idCliente
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void gerarArquivoTextoFaturamento(int anoMes, Integer idCliente)
			throws ControladorException {
		Collection colecaoObjetos = null;

		try {

			colecaoObjetos = repositorioFaturamento
					.gerarArquivoTextoFaturamento(anoMes, idCliente);

			StringBuilder documentoTxt = new StringBuilder();
			int sequencialImpressao = 0;

			if (!colecaoObjetos.isEmpty()) {
				Iterator iteratorObjetos = colecaoObjetos.iterator();
				BigDecimal somaValorRegitros = new BigDecimal(0);
				// -- HEADER
				// ----------------------------------------------------
				documentoTxt.append("0");// Tipo Registro - Fixo 0 CHAR(1)
				documentoTxt.append(Util.completaString("CONTAS", 10));// Tipo
				// MOVIMENTO
				// -
				// Fixo
				// CONTAS
				// CHAR(10)
				documentoTxt.append("00000003");// CODIGO FORNECEDOR - Fixo
				// 00000008 CHAR(8)

				SistemaParametro sistemaParametro = this.getControladorUtil()
						.pesquisarParametrosDoSistema();

				documentoTxt.append(Util.completaString(
						sistemaParametro.getNomeAbreviadoEmpresa(), 30));// NOME
				// DO
				// FORNECEDOR
				// -
				// CHAR(30)
				documentoTxt.append(Util.recuperaDataInvertida(new Date()));// DATA
				// DO
				// MOVIMENTO
				// -
				// DATA
				// CORRENTE
				documentoTxt.append(Util.completaString("", 74));// CAMPO
				// LIVRE -
				// ESPAÇOS
				// CHAR(74)

				// Quebra de Linha
				documentoTxt.append(System.getProperty("line.separator"));
				// -- Fim ER
				// -------------------------------------------------
				while (iteratorObjetos.hasNext()) {
					sequencialImpressao++;
					Object[] objeto = (Object[]) iteratorObjetos.next();

					// -- CONTAS
					// -----------------------------------------------------
					documentoTxt.append("1");// Tipo Registro - Fixo 1
					// CHAR(1)
					// idImovel
					if (objeto[0] != null) {
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(8,
								((Integer) objeto[0]).toString()));// MATRICULA
						// - imov_id
						// CHAR(15)
						documentoTxt.append(Util.completaString("", 7));// MATRICULA
						// -
						// imov_id
						// CHAR(15)
					}
					// amReferencia
					if (objeto[1] != null) {
						String anoMesObjeto = ((Integer) objeto[1]).toString();
						String ano = anoMesObjeto.substring(0, 4);
						String mes = anoMesObjeto.substring(4, 6);
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(2,
								mes));// MES DO CONSUMO - mm CHAR(2)
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(4,
								ano));// ANO DO CONSUMO - aaaa CHAR(4)
					}
					// dtleitura
					if (objeto[6] != null) {
						documentoTxt.append(Util
								.recuperaDataInvertida((Date) objeto[6]));// DATA
						// DA
						// LEITURA
						// -
						// aaaammdd
					} else {
						documentoTxt.append(Util.recuperaDataInvertida(Util
								.gerarDataApartirAnoMesRefencia(new Integer(
										anoMes))));// DATA DA LEITURA -
						// aaaammdd
					}
					// vencimentoConta
					if (objeto[12] != null) {
						documentoTxt.append(Util
								.recuperaDataInvertida((Date) objeto[12]));// Vencimento
						// Conta
						// -
						// aaaammdd
					}
					// valorAgua
					BigDecimal valorAgua = new BigDecimal(0);
					if (objeto[2] != null) {
						valorAgua = (BigDecimal) objeto[2];
					}
					// valorEsgoto
					BigDecimal valorEsgoto = new BigDecimal(0);
					if (objeto[3] != null) {
						valorEsgoto = (BigDecimal) objeto[3];
					}
					// valorDebitos
					BigDecimal valorDebitos = new BigDecimal(0);
					if (objeto[4] != null) {
						valorDebitos = (BigDecimal) objeto[4];
					}
					// valorCreditos
					BigDecimal valorCreditos = new BigDecimal(0);
					if (objeto[5] != null) {
						valorCreditos = (BigDecimal) objeto[5];
					}
					// SOMATORIO
					// cnta_vlagua + cnta_vlesgoto + cnta_vldebitos -
					// cnta_vlcreditos da tabela conta
					BigDecimal valorTotal = new BigDecimal(0);

					valorTotal = valorTotal.add(valorAgua);
					valorTotal = valorTotal.add(valorEsgoto);
					valorTotal = valorTotal.add(valorDebitos);
					valorTotal = valorTotal.subtract(valorCreditos);

					documentoTxt.append(Util.adicionarZerosEsquedaNumero(10,
							valorTotal.toString().replace(".", "")));// VALOR
					// DA
					// FATURA
					// -
					// SOMATORIO
					// char(12)

					// Acumulador Geral
					somaValorRegitros = somaValorRegitros.add(valorTotal);

					documentoTxt
							.append(Util.adicionarZerosEsquedaNumero(5, ""));// numero
					// da
					// fatura
					// -
					// char(5)

					// leitura Atual
					if (objeto[7] != null) {
						// atualizado 29/10/2007 Flávio leonardo, solicitação de
						// Aryed
						String leituraAtual = Util.adicionarZerosEsquedaNumero(
								5, ((Integer) objeto[7]) + "");

						documentoTxt.append(leituraAtual.substring(0, 5));// Leitura
						// Atual
						// - char(5)
					} else {
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(5,
								""));// Leitura Atual - char(5)
					}
					// ************************Alteração feita no dia 9/4/2007 á
					// pedido de Aryed - Flávio Cordeiro
					// nome cliente
					if (objeto[8] != null) {
						String nomeCliente = repositorioFaturamento
								.pesquisarClienteUsuarioConta((Integer) objeto[8]);
						documentoTxt.append(Util
								.completaString(nomeCliente, 42));// Nome
						// Cliente -
						// clie_nmCliente
						// char(42)
					}

					documentoTxt.append("+");// Sinal Valor - FIXO + char(1)

					// nome cliente
					if (objeto[9] != null) {
						documentoTxt.append(Util.completaString(
								(String) objeto[9], 30));// Nome Municipio -
						// muni_nmmunicipio
						// char(30)
					}

					// Quebra de Linha
					documentoTxt.append(System.getProperty("line.separator"));

					// -- Consumo e Valor de Agua ----------------------
					// Gerar somente se valor de Agua MAIOR (>) que Zero
					if (valorAgua.intValue() > 0) {
						documentoTxt.append(Util.completaString("2", 1));// Tipo
						// Registro
						// -
						// fixo
						// 2
						// char(1)
						// idImovel
						if (objeto[0] != null) {
							documentoTxt.append(Util
									.adicionarZerosEsquedaNumero(8,
											((Integer) objeto[0]).toString()));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
							documentoTxt.append(Util.completaString("", 7));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
						}
						// amReferencia
						if (objeto[1] != null) {
							String anoMesObjeto = ((Integer) objeto[1])
									.toString();
							String ano = anoMesObjeto.substring(0, 4);
							String mes = anoMesObjeto.substring(4, 6);
							documentoTxt.append(Util
									.adicionarZerosEsquedaNumero(2, mes));// MES
							// DO
							// CONSUMO
							// - mm
							// CHAR(2)
							documentoTxt.append(Util
									.adicionarZerosEsquedaNumero(4, ano));// ANO
							// DO
							// CONSUMO
							// -
							// aaaa
							// CHAR(4)
						}
						// dtleitura
						if (objeto[6] != null) {
							documentoTxt.append(Util
									.recuperaDataInvertida((Date) objeto[6]));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						} else {
							documentoTxt
									.append(Util.recuperaDataInvertida(Util
											.gerarDataApartirAnoMesRefencia(new Integer(
													anoMes))));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(5,
								""));// Codigo - fixo Zeros char(5)
						// consumoAgua
						if (objeto[10] != null) {
							documentoTxt.append(Util
									.adicionarZerosEsquedaNumero(7,
											((Integer) objeto[10]).toString()));// Consumo
							// -
							// cnta_nnconsumoagua
							// char(7)
						}
						// valor agua
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(8,
								valorAgua.toString().replace(".", "")));// Valor
						// Agua
						// -
						// valorAgua
						// char(8)
						documentoTxt.append(Util.completaString("AGUA", 50));// historico
						// -
						// Fixo
						// AGUA
						// char(50)
						documentoTxt.append(Util.completaString("+", 1));// Sinal
						// do
						// Valro
						// -
						// Fixo
						// +
						// char(1)
						documentoTxt.append(Util.completaString("", 30));// Campo
						// livre
						// -
						// Espaços
						// char(1)

						// Quebra de Linha
						documentoTxt.append(System
								.getProperty("line.separator"));
					}

					// -- Consumo e Valor de Esgoto ------------------------
					// Gerar somente se valor do Esgoto MAIOR (>) que Zero
					if (valorEsgoto.intValue() > 0) {
						documentoTxt.append(Util.completaString("2", 1));// Tipo
						// Registro
						// -
						// fixo
						// 2
						// char(1)
						// idImovel
						if (objeto[0] != null) {
							documentoTxt.append(Util
									.adicionarZerosEsquedaNumero(8,
											((Integer) objeto[0]).toString()));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
							documentoTxt.append(Util.completaString("", 7));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
						}
						// amReferencia
						if (objeto[1] != null) {
							String anoMesObjeto = ((Integer) objeto[1])
									.toString();
							String ano = anoMesObjeto.substring(0, 4);
							String mes = anoMesObjeto.substring(4, 6);
							documentoTxt.append(Util
									.adicionarZerosEsquedaNumero(2, mes));// MES
							// DO
							// CONSUMO
							// - mm
							// CHAR(2)
							documentoTxt.append(Util
									.adicionarZerosEsquedaNumero(4, ano));// ANO
							// DO
							// CONSUMO
							// -
							// aaaa
							// CHAR(4)
						}
						// dtleitura
						if (objeto[6] != null) {
							documentoTxt.append(Util
									.recuperaDataInvertida((Date) objeto[6]));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						} else {
							documentoTxt
									.append(Util.recuperaDataInvertida(Util
											.gerarDataApartirAnoMesRefencia(new Integer(
													anoMes))));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(5,
								""));// Codigo - fixo Zeros char(5)
						// consumoEsgoto
						if (objeto[11] != null) {
							documentoTxt.append(Util
									.adicionarZerosEsquedaNumero(7,
											((Integer) objeto[11]).toString()));// Consumo
							// -
							// cnta_nnconsumoagua
							// char(7)
						}
						// valor agua
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(8,
								valorEsgoto.toString().replace(".", "")));// Valor
						// Agua
						// -
						// valorAgua
						// char(8)
						documentoTxt.append(Util.completaString("ESGOTO", 50));// historico
						// -
						// Fixo
						// ESGOTO
						// char(50)
						documentoTxt.append(Util.completaString("+", 1));// Sinal
						// do
						// Valro
						// -
						// Fixo
						// +
						// char(1)
						documentoTxt.append(Util.completaString("", 30));// Campo
						// livre
						// -
						// Espaços
						// char(1)

						// Quebra de Linha
						documentoTxt.append(System
								.getProperty("line.separator"));
					}

					// -- Codigo e valor de debito corbado
					// ------------------------------
					Collection colecaoServicos = repositorioFaturamento
							.gerarArquivoTextoFaturamentoServicos(anoMes,
									idCliente, (Integer) objeto[0]);
					if (!colecaoServicos.isEmpty()) {
						Iterator iteratorServicos = colecaoServicos.iterator();
						while (iteratorServicos.hasNext()) {
							Object[] servico = (Object[]) iteratorServicos
									.next();

							documentoTxt.append(Util.completaString("2", 1));// Tido
							// do
							// Registro
							// -
							// Fixo
							// 2
							// char(1)
							// idImovel
							if (servico[0] != null) {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(8,
												((Integer) servico[0])
														.toString()));// MATRICULA
								// -
								// imov_id
								// CHAR(15)
								documentoTxt.append(Util.completaString("", 7));// MATRICULA
								// -
								// imov_id
								// CHAR(15)
							}
							// amReferencia
							if (servico[1] != null) {
								String anoMesObjeto = ((Integer) servico[1])
										.toString();
								String ano = anoMesObjeto.substring(0, 4);
								String mes = anoMesObjeto.substring(4, 6);
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(2, mes));// MES
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(4, ano));// ANO
							}
							// dtleitura
							if (servico[3] != null) {
								documentoTxt
										.append(Util
												.recuperaDataInvertida((Date) servico[3]));// DATA
								// DA
								// LEITURA
								// -
								// aaaammdd
							} else {
								documentoTxt
										.append(Util.recuperaDataInvertida(Util
												.gerarDataApartirAnoMesRefencia(new Integer(
														anoMes))));// DATA
							}
							// idDebitoTipo
							if (servico[7] != null) {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(5,
												((Integer) servico[7])
														.toString()));// Codigo
							} else {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(5, ""));// Codigo
							}
							// Volume
							if (servico[6] != null) {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(7,
												((Integer) servico[6])
														.toString()));
							} else {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(7, ""));
							}
							// valor debito
							if (servico[8] != null) {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(
												8,
												((BigDecimal) servico[8])
														.toString().replace(
																".", "")));// Valor
							} else {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(8, ""));// Valor
							}
							documentoTxt.append(Util.completaString("SERVICO",
									50));// historico
							// -
							// Fixo
							// SERVICO
							// char(50)
							documentoTxt.append(Util.completaString("+", 1));// Sinal
							// do
							// Valro
							// -
							// Fixo
							// +
							// char(1)
							documentoTxt.append(Util.completaString("", 30));// Campo
							// livre
							// -
							// Espaços
							// char(1)

							// Quebra de Linha
							documentoTxt.append(System
									.getProperty("line.separator"));
						}
					}

					// -- Codigo e valor de credito realizado
					// ------------------------------
					Collection colecaoCreditos = repositorioFaturamento
							.gerarArquivoTextoFaturamentoCreditos(anoMes,
									idCliente, (Integer) objeto[0]);
					if (!colecaoCreditos.isEmpty()) {
						Iterator iteratorCreditos = colecaoCreditos.iterator();
						while (iteratorCreditos.hasNext()) {
							Object[] credito = (Object[]) iteratorCreditos
									.next();
							documentoTxt.append(Util.completaString("2", 1));// Tido
							// do
							// Registro
							// -
							// Fixo
							// 2
							// char(1)
							// idImovel
							if (credito[0] != null) {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(8,
												((Integer) credito[0])
														.toString()));// MATRICULA
								// -
								// imov_id
								// CHAR(15)
								documentoTxt.append(Util.completaString("", 7));// MATRICULA
								// -
								// imov_id
								// CHAR(15)
							}
							// amReferencia
							if (credito[1] != null) {
								String anoMesObjeto = ((Integer) credito[1])
										.toString();
								String ano = anoMesObjeto.substring(0, 4);
								String mes = anoMesObjeto.substring(4, 6);
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(2, mes));// MES
								// DO
								// CONSUMO
								// - mm
								// CHAR(2)
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(4, ano));// ANO
								// DO
								// CONSUMO
								// -
								// aaaa
								// CHAR(4)
							}
							// dtleitura
							if (credito[3] != null) {
								documentoTxt
										.append(Util
												.recuperaDataInvertida((Date) credito[3]));// DATA
								// DA
								// LEITURA
								// -
								// aaaammdd
							} else {
								documentoTxt
										.append(Util.recuperaDataInvertida(Util
												.gerarDataApartirAnoMesRefencia(new Integer(
														anoMes))));// DATA
								// DA
								// LEITURA
								// -
								// aaaammdd
							}
							// idCreditoTipo
							if (credito[7] != null) {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(4,
												((Integer) credito[7])
														.toString()));// Codigo
								// -
								// crti_id
								// CHAR(4)
							}
							if (credito[6] != null) {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(4,
												((Integer) credito[6])
														.toString()));// Volume
																		// -
																		// Zeros
																		// CHAR(9)
							} else {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(4, ""));// Volume
																				// -
																				// Zeros
																				// CHAR(9)
							}
							// valor credito
							if (credito[8] != null) {
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(
												10,
												((BigDecimal) credito[8])
														.toString().replace(
																".", "")));// Valor
								// Prestação
								// -
								// crrz_VLPRESTACAO
								// CHAR(10)
							}
							documentoTxt.append(Util.completaString("CREDITO",
									50));// historico
							// -
							// Fixo
							// SERVICO
							// char(50)
							documentoTxt.append(Util.completaString("-", 1));// Sinal
							// do
							// Valro
							// -
							// Fixo
							// -
							// char(1)
							documentoTxt.append(Util.completaString("", 30));// Campo
							// livre
							// -
							// Espaços
							// char(1)

							// Quebra de Linha
							documentoTxt.append(System
									.getProperty("line.separator"));
						}
					}

					// -- Valores dos Impostos Retidos
					// ------------------------------
					Collection colecaoImpostos = repositorioFaturamento
							.gerarArquivoTextoFaturamentoImpostos(anoMes,
									idCliente, (Integer) objeto[0]);
					if (!colecaoImpostos.isEmpty()) {
						Iterator iteratorImpostos = colecaoImpostos.iterator();
						while (iteratorImpostos.hasNext()) {
							Object[] imposto = (Object[]) iteratorImpostos
									.next();

							if (imposto[5] != null
									&& !((BigDecimal) imposto[5])
											.equals(BigDecimal.ZERO)) {
								documentoTxt
										.append(Util.completaString("2", 1));// Tido
								// do
								// Registro
								// -
								// Fixo
								// 2
								// char(1)
								// idImovel
								if (imposto[0] != null) {
									documentoTxt.append(Util
											.adicionarZerosEsquedaNumero(8,
													((Integer) imposto[0])
															.toString()));// MATRICULA
									// -
									// imov_id
									// CHAR(15)
									documentoTxt.append(Util.completaString("",
											7));// MATRICULA
									// -
									// imov_id
									// CHAR(15)
								}
								// amReferencia
								if (imposto[1] != null) {
									String anoMesObjeto = ((Integer) imposto[1])
											.toString();
									String ano = anoMesObjeto.substring(0, 4);
									String mes = anoMesObjeto.substring(4, 6);
									documentoTxt
											.append(Util
													.adicionarZerosEsquedaNumero(
															2, mes));// MES
									// DO
									// CONSUMO
									// - mm
									// CHAR(2)
									documentoTxt
											.append(Util
													.adicionarZerosEsquedaNumero(
															4, ano));// ANO
									// DO
									// CONSUMO
									// -
									// aaaa
									// CHAR(4)
								}
								// dtleitura
								if (imposto[2] != null) {
									documentoTxt
											.append(Util
													.recuperaDataInvertida((Date) imposto[2]));// DATA
									// DA
									// LEITURA
									// -
									// aaaammdd
								} else {
									documentoTxt
											.append(Util.recuperaDataInvertida(Util
													.gerarDataApartirAnoMesRefencia(new Integer(
															anoMes))));// DATA
									// DA
									// LEITURA
									// -
									// aaaammdd
								}
								// Codigo
								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(5, ""));// Codigo
																				// -
																				// Zeros
																				// CHAR(5)

								documentoTxt.append(Util
										.adicionarZerosEsquedaNumero(7, ""));// Volume
																				// -
																				// Zeros
																				// CHAR(9)
								// somaImpostos - soma dos cnid_vlimpostos
								if (imposto[5] != null) {
									documentoTxt.append(Util
											.adicionarZerosEsquedaNumero(8,
													((BigDecimal) imposto[5])
															.toString()
															.replace(".", "")));// Total
									// das
									// retenções
									// -
									// somaImpostos
									// CHAR(10)
								}
								documentoTxt
										.append(Util
												.completaString(
														"IR-4,8% CSLL-1.0% COFINS-3,0% PIS?PASEP-0,65%",
														50));// historico - Fixo
								// SERVICO char(50)
								documentoTxt
										.append(Util.completaString("-", 1));// Sinal
								// do
								// Valro
								// -
								// Fixo
								// -
								// char(1)
								documentoTxt
										.append(Util.completaString("", 30));// Campo
								// livre
								// -
								// Espaços
								// char(30)

								// Quebra de Linha
								documentoTxt.append(System
										.getProperty("line.separator"));
							}
						}

					}
				}

				// -- TRAILLER ---------------------------
				documentoTxt.append(Util.completaString("9", 1));// Fixo 9
				// char(1)
				documentoTxt.append(Util.adicionarZerosEsquedaNumero(6,
						sequencialImpressao + ""));// Sinal do Valro - Fixo -
				// char(1)
				documentoTxt.append(Util.adicionarZerosEsquedaNumero(
						12,
						((BigDecimal) somaValorRegitros).toString().replace(
								".", "")));// Soma dos valores Registrados
				// - soma char(1)
				documentoTxt.append(Util.completaString("", 110));// Campo
				// livre -
				// Espaços
				// char(112)
				// Quebra de Linha
				documentoTxt.append(System.getProperty("line.separator"));
				documentoTxt.append("\u0004");

				System.out.println("***************************************");
				System.out.println("INICO DA CRIACAO DO ARQUIVO");
				System.out.println("***************************************");

				if (documentoTxt != null && documentoTxt.length() != 0) {

					EnvioEmail envioEmail = getControladorCadastro()
							.pesquisarEnvioEmail(
									EnvioEmail.GERAR_ARQUIVO_TEXTO_FATURAMENTO);

					String corpoMensagem = envioEmail.getCorpoMensagem();
					String emailReceptor = envioEmail.getEmailReceptor();
					String tituloMensagem = envioEmail.getTituloMensagem();

					BufferedWriter out = null;
					ZipOutputStream zos = null;
					try {
						// criar o arquivo zip
						File compactado = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + "" + idCliente + "_"+ anoMes + ".zip"); // nomeZip

						zos = new ZipOutputStream(new FileOutputStream(compactado));

						File leitura;
						leitura = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + "" + idCliente + "_" + anoMes + ".txt");

						out = new BufferedWriter(
								new OutputStreamWriter(new FileOutputStream(
										leitura.getAbsolutePath())));
						out.write(documentoTxt.toString());
						out.flush();
						out.close();
						ZipUtil.adicionarArquivo(zos, leitura);
						zos.close();
						leitura.delete();

						ServicosEmail.enviarMensagemArquivoAnexado(
								emailReceptor, emailReceptor, tituloMensagem,
								corpoMensagem, compactado);

					} catch (IOException e) {
						throw new ControladorException("erro.sistema", e);
					} catch (Exception e) {
						throw new ControladorException("erro.sistema", e);
					} finally {
						IoUtil.fecharStream(out);
						IoUtil.fecharStream(zos);
					}

				}
				System.out.println("***************************************");
				System.out.println("FIM DA CRIACAO DO ARQUIVO");
				System.out.println("***************************************");
			}

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
	}

	/**
	 * [UC0157] - Simular Cálculo da Conta
	 * 
	 * [FS0003] - Verificar Consumo Mínimo
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2007
	 * 
	 * @param idLigacaoAguaSituacao
	 *            , consumoFaturado
	 * @return void
	 * @throws ControladorException
	 */
	public void verificarConsumoFaturadoAgua(Integer idLigacaoAguaSituacao,
			Integer consumoFaturado) throws ControladorException {

		FiltroLigacaoAguaSituacao filtroLigacaoAguaSituacao = new FiltroLigacaoAguaSituacao();

		filtroLigacaoAguaSituacao.adicionarParametro(new ParametroSimples(
				FiltroLigacaoAguaSituacao.ID, idLigacaoAguaSituacao));

		Collection colecaoLigacaoAguaSituacao = getControladorUtil().pesquisar(
				filtroLigacaoAguaSituacao, LigacaoAguaSituacao.class.getName());

		if (colecaoLigacaoAguaSituacao != null
				&& !colecaoLigacaoAguaSituacao.isEmpty()) {

			LigacaoAguaSituacao ligacaoAguaSituacao = (LigacaoAguaSituacao) Util
					.retonarObjetoDeColecao(colecaoLigacaoAguaSituacao);

			if (ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().equals(
					ConstantesSistema.INDICADOR_USO_ATIVO)
					&& consumoFaturado == null) {

				throw new ControladorException(
						"atencao.informe.consumoFaturadoAgua");
			}

			// [FS0003] - Verificar Consumo Mínimo
			else if (consumoFaturado != null
					&& consumoFaturado != 0
					&& consumoFaturado <= ligacaoAguaSituacao
							.getConsumoMinimoFaturamento()) {

				throw new ControladorException(
						"atencao.informe.consumo_faturado_agua_maior_consumo_minimo",
						null, ligacaoAguaSituacao.getConsumoMinimoFaturamento()
								.toString());

			}
		}
	}

	/**
	 * [UC0157] - Simular Cálculo da Conta
	 * 
	 * [FS0004] - Verificar Volume Mínimo
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2007
	 * 
	 * @param idLigacaoEsgotoSituacao
	 *            , consumoFaturado
	 * @return void
	 * @throws ControladorException
	 */
	public void verificarConsumoFaturadoEsgoto(Integer idLigacaoEsgotoSituacao,
			Integer consumoFaturado) throws ControladorException {

		FiltroLigacaoEsgotoSituacao filtroLigacaoEsgotoSituacao = new FiltroLigacaoEsgotoSituacao();

		filtroLigacaoEsgotoSituacao.adicionarParametro(new ParametroSimples(
				FiltroLigacaoEsgotoSituacao.ID, idLigacaoEsgotoSituacao));

		Collection colecaoLigacaoEsgotoSituacao = getControladorUtil()
				.pesquisar(filtroLigacaoEsgotoSituacao,
						LigacaoEsgotoSituacao.class.getName());

		if (colecaoLigacaoEsgotoSituacao != null
				&& !colecaoLigacaoEsgotoSituacao.isEmpty()) {

			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = (LigacaoEsgotoSituacao) Util
					.retonarObjetoDeColecao(colecaoLigacaoEsgotoSituacao);

			if (ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao().equals(
					ConstantesSistema.INDICADOR_USO_ATIVO)
					&& consumoFaturado == null) {

				throw new ControladorException(
						"atencao.informe.consumoFaturadoEsgoto");
			}

			// [FS0004] - Verificar Volume Mínimo
			else if (consumoFaturado != null
					&& consumoFaturado != 0
					&& consumoFaturado <= ligacaoEsgotoSituacao
							.getVolumeMinimoFaturamento()) {

				throw new ControladorException(
						"atencao.informe.volume_faturado_esgoto_maior_volume_minimo",
						null, ligacaoEsgotoSituacao
								.getVolumeMinimoFaturamento().toString());

			}
		}
	}

	/**
	 * Envia os cliente conta para o histórico.
	 * 
	 * [UC0000] Gerar Historico Encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 04/04/2007
	 * 
	 * @param contaHistoricoTemp
	 * @param idConta
	 * @throws ControladorException
	 */
	private void enviarClienteContaParaHistorico(
			ContaHistorico contaHistoricoTemp, Integer idConta)
			throws ControladorException {

		Collection colecaoClienteContaHistoricoInserir = new ArrayList();
		Collection colecaoClienteContaRemover = new ArrayList();

		try {
			Collection<IClienteConta> colecaoClienteConta = repositorioFaturamento
					.pesquisarClienteConta(idConta);

			ClienteContaHistorico clienteContaHistoricoTemp = null;

			if (colecaoClienteConta != null && !colecaoClienteConta.isEmpty()) {

				colecaoClienteContaRemover.addAll(colecaoClienteConta);

				for (IClienteConta clienteConta : colecaoClienteConta) {
					clienteContaHistoricoTemp = new ClienteContaHistorico();
					clienteContaHistoricoTemp.setId(clienteConta.getId());
					clienteContaHistoricoTemp.setCliente(clienteConta
							.getCliente());
					clienteContaHistoricoTemp
							.setClienteRelacaoTipo(clienteConta
									.getClienteRelacaoTipo());
					clienteContaHistoricoTemp
							.setContaHistorico(contaHistoricoTemp);
					clienteContaHistoricoTemp
							.setIndicadorNomeConta(clienteConta
									.getIndicadorNomeConta());
					clienteContaHistoricoTemp.setUltimaAlteracao(new Date());

					colecaoClienteContaHistoricoInserir
							.add(clienteContaHistoricoTemp);
				}

				// System.out.println("REMOVENDO CLIENTE CONTA");
				getControladorBatch().removerColecaoClienteContaParaBatch(
						colecaoClienteContaRemover);
				colecaoClienteContaRemover = null;

				// System.out.println("TRANSFERINDO CLIENTE CONTA PARA O
				// HISTORICO");
				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoClienteContaHistoricoInserir);
				colecaoClienteContaHistoricoInserir = null;
			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Envia as contas imppostos deduzidos para o histórico.
	 * 
	 * [UC0000] Gerar Historico Encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 04/04/2007
	 * 
	 * @param contaHistoricoTemp
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	private void enviarContaImpostosDeduzidosParaHistorico(
			ContaHistorico contaHistoricoTemp, Integer idConta)
			throws ControladorException {

		Collection colecaoContaImpostosDeduzidosHistoricoInserir = new ArrayList();
		Collection colecaoContaImpostosDeduzidosRemover = new ArrayList();

		try {

			Collection<IContaImpostosDeduzidos> colecaoContaImpostosDeduzidos = this.repositorioFaturamento
					.pesquisarContaImpostosDeduzidos(idConta);

			ContaImpostosDeduzidosHistorico contaImpostosDeduzidosHistoricoTemp = null;

			if (colecaoContaImpostosDeduzidos != null
					&& !colecaoContaImpostosDeduzidos.isEmpty()) {

				colecaoContaImpostosDeduzidosHistoricoInserir = new ArrayList();
				colecaoContaImpostosDeduzidosRemover = new ArrayList();
				colecaoContaImpostosDeduzidosRemover
						.addAll(colecaoContaImpostosDeduzidos);

				for (IContaImpostosDeduzidos contaImpostosDeduzidos : colecaoContaImpostosDeduzidos) {
					contaImpostosDeduzidosHistoricoTemp = new ContaImpostosDeduzidosHistorico();
					contaImpostosDeduzidosHistoricoTemp
							.setId(contaImpostosDeduzidos.getId());
					contaImpostosDeduzidosHistoricoTemp
							.setContaHistorico(contaHistoricoTemp);
					contaImpostosDeduzidosHistoricoTemp
							.setImpostoTipo(contaImpostosDeduzidos
									.getImpostoTipo());
					contaImpostosDeduzidosHistoricoTemp
							.setPercentualAliquota(contaImpostosDeduzidos
									.getPercentualAliquota());
					contaImpostosDeduzidosHistoricoTemp
							.setUltimaAlteracao(new Date());
					contaImpostosDeduzidosHistoricoTemp
							.setValorImposto(contaImpostosDeduzidos
									.getValorImposto());
					contaImpostosDeduzidosHistoricoTemp
							.setValorBaseCalculo(contaImpostosDeduzidos
									.getValorBaseCalculo());

					colecaoContaImpostosDeduzidosHistoricoInserir
							.add(contaImpostosDeduzidosHistoricoTemp);
				}

				// System.out.println("REMOVENDO CONTAS IMPOSTOS DEDUZIDOS");
				getControladorBatch()
						.removerColecaoContaImpostosDeduzidosParaBatch(
								colecaoContaImpostosDeduzidosRemover);
				colecaoContaImpostosDeduzidosRemover = null;

				// System.out.println("TRANSFERINDO CONTAS IMPOSTOS DEDUZIDOS
				// PARA O HISTORICO");
				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoContaImpostosDeduzidosHistoricoInserir);
				colecaoContaImpostosDeduzidosHistoricoInserir = null;
			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Envia os créditos realizados e créditos realizados categoria para o
	 * histórico.
	 * 
	 * [UC0000] Gerar Historico Encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 04/04/2007
	 * 
	 * @param anoMesFaturamentoSistemaParametro
	 * @param contaHistoricoTemp
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	private void enviarCreditoRealizadoParaHistorico(
			int anoMesFaturamentoSistemaParametro,
			ContaHistorico contaHistoricoTemp, Integer idConta)
			throws ControladorException {

		Collection colecaoCreditoRealizadoHistoricoInserir = new ArrayList();
		Collection colecaoCreditoRealizadoCategoriaHistoricoInserir = new ArrayList();
		Collection colecaoCreditoRealizadoRemover = new ArrayList();
		Collection colecaoCreditoRealizadoCategoriaRemover = new ArrayList();

		Conta conta = (Conta) this.obterConta(idConta).iterator().next();
		try {
			Collection<ICreditoRealizado> creditosRealizados = repositorioFaturamento.pesquisarCreditosRealizados(idConta);

			CreditoRealizadoHistorico creditoRealizadoHistoricoTemp = null;

			if (creditosRealizados != null && !creditosRealizados.isEmpty()) {

				colecaoCreditoRealizadoRemover.addAll(creditosRealizados);
				
				for (ICreditoRealizado creditoRealizado : creditosRealizados) {
					creditoRealizadoHistoricoTemp = new CreditoRealizadoHistorico();
					creditoRealizadoHistoricoTemp.setId(creditoRealizado.getId());
					creditoRealizadoHistoricoTemp.setCreditoRealizado(creditoRealizado.getCreditoRealizado());
					creditoRealizadoHistoricoTemp.setCodigoSetorComercial(creditoRealizado.getCodigoSetorComercial());
					creditoRealizadoHistoricoTemp.setNumeroQuadra(creditoRealizado.getNumeroQuadra());
					creditoRealizadoHistoricoTemp.setNumeroLote(creditoRealizado.getNumeroLote());
					creditoRealizadoHistoricoTemp.setNumeroSubLote(creditoRealizado.getNumeroSubLote());
					creditoRealizadoHistoricoTemp.setAnoMesReferenciaCredito(creditoRealizado.getAnoMesReferenciaCredito());
					creditoRealizadoHistoricoTemp.setAnoMesCobrancaCredito(creditoRealizado.getAnoMesCobrancaCredito());
					creditoRealizadoHistoricoTemp.setValorCredito(creditoRealizado.getValorCredito());
					creditoRealizadoHistoricoTemp.setNumeroPrestacao(creditoRealizado.getNumeroPrestacao());
					creditoRealizadoHistoricoTemp.setNumeroPrestacaoCredito(creditoRealizado.getNumeroPrestacaoCredito());
					creditoRealizadoHistoricoTemp.setNumeroParcelaBonus(creditoRealizado.getNumeroParcelaBonus());
					creditoRealizadoHistoricoTemp.setUltimaAlteracao(new Date());
					creditoRealizadoHistoricoTemp.setQuadra(creditoRealizado.getQuadra());
					creditoRealizadoHistoricoTemp.setLocalidade(creditoRealizado.getLocalidade());
					creditoRealizadoHistoricoTemp.setCreditoTipo(creditoRealizado.getCreditoTipo());
					creditoRealizadoHistoricoTemp.setContaHistorico(contaHistoricoTemp);
					creditoRealizadoHistoricoTemp.setLancamentoItemContabil(creditoRealizado.getLancamentoItemContabil());
					creditoRealizadoHistoricoTemp.setCreditoOrigem(creditoRealizado.getCreditoOrigem());
					creditoRealizadoHistoricoTemp.setCreditoARealizarGeral(creditoRealizado.getCreditoARealizarGeral());

					colecaoCreditoRealizadoHistoricoInserir.add(creditoRealizadoHistoricoTemp);

					Collection<CreditoRealizadoCategoria> colecaoCreditoRealizadoCategoria = this.repositorioFaturamento
							.pesquisarCreditoRealizadoCategoria(creditoRealizado.getId());

					if (colecaoCreditoRealizadoCategoria != null && !colecaoCreditoRealizadoCategoria.isEmpty()) {

						colecaoCreditoRealizadoCategoriaRemover = new ArrayList();
						colecaoCreditoRealizadoCategoriaRemover.addAll(colecaoCreditoRealizadoCategoria);

						for (CreditoRealizadoCategoria creditoRelizadoCategoria : colecaoCreditoRealizadoCategoria) {
							CreditoRealizadoCategoriaHistorico creditoRealizadoCategoriaHistorico = new CreditoRealizadoCategoriaHistorico(
									creditoRealizadoHistoricoTemp.getId(),creditoRelizadoCategoria.getCategoria().getId());
							creditoRealizadoCategoriaHistorico.setCategoria(creditoRelizadoCategoria.getCategoria());
							creditoRealizadoCategoriaHistorico.setCreditoRealizadoHistorico(creditoRealizadoHistoricoTemp);
							creditoRealizadoCategoriaHistorico.setQuantidadeEconomia(creditoRelizadoCategoria.getQuantidadeEconomia());
							creditoRealizadoCategoriaHistorico.setUltimaAlteracao(new Date());
							creditoRealizadoCategoriaHistorico.setValorCategoria(creditoRelizadoCategoria.getValorCategoria());

							colecaoCreditoRealizadoCategoriaHistoricoInserir.add(creditoRealizadoCategoriaHistorico);
						}
						getControladorBatch().removerColecaoCreditoRealizadoCategoriaParaBatch(colecaoCreditoRealizadoCategoriaRemover);

						colecaoCreditoRealizadoCategoriaRemover = null;
					}
				}
			}

			getControladorBatch().removerColecaoCreditoRealizadoParaBatch(colecaoCreditoRealizadoRemover);
			colecaoCreditoRealizadoRemover = null;

			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoRealizadoHistoricoInserir);
			colecaoCreditoRealizadoHistoricoInserir = null;

			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoRealizadoCategoriaHistoricoInserir);
			colecaoCreditoRealizadoCategoriaHistoricoInserir = null;

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Envia os débitos cobrados e debitos cobrados categoria para o histórico.
	 * 
	 * [UC0000] Gerar Historico Encerrar Faturamento
	 * 
	 * @author Pedro Alexandre, Raphael Rossiter
	 * @date 04/04/2007, 17/10/2008
	 * 
	 * @param anoMesFaturamentoSistemaParametro
	 * @param contaHistoricoTemp
	 * @param idConta
	 * @throws ControladorException
	 */
	private void enviarDebitoCobradoParaHistorico(
			int anoMesFaturamentoSistemaParametro,
			ContaHistorico contaHistoricoTemp, Integer idConta)
			throws ControladorException {

		Collection colecaoDebitoCobradoHistoricoInserir = new ArrayList();
		Collection colecaoDebitoCobradoCategoriaHistoricoInserir = new ArrayList();
		Collection colecaoDebitoCobradoRemover = new ArrayList();
		Collection colecaoDebitoCobradoCategoriaRemover = new ArrayList();

		try {
			Collection<IDebitoCobrado> debitosCobrados = repositorioFaturamento
					.pesquisarDebitosCobrados(idConta);

			// cria o objeto débito cobrado histórico
			DebitoCobradoHistorico debitoCobradoHistoricoTemp = null;

			if (debitosCobrados != null && !debitosCobrados.isEmpty()) {

				colecaoDebitoCobradoRemover.addAll(debitosCobrados);

				// laço para criar o histórico dos débitos cobrados da
				// conta
				for (IDebitoCobrado debitoCobrado : debitosCobrados) {
					// seta os dados do débito cobrado histórico
					debitoCobradoHistoricoTemp = new DebitoCobradoHistorico();
					debitoCobradoHistoricoTemp.setId(debitoCobrado.getId());
					debitoCobradoHistoricoTemp.setDebitoCobrado(debitoCobrado
							.getDebitoCobrado());
					debitoCobradoHistoricoTemp
							.setCodigoSetorComercial(debitoCobrado
									.getCodigoSetorComercial());
					debitoCobradoHistoricoTemp.setNumeroQuadra(debitoCobrado
							.getNumeroQuadra());
					debitoCobradoHistoricoTemp.setNumeroLote(debitoCobrado
							.getNumeroLote());
					debitoCobradoHistoricoTemp.setNumeroSubLote(debitoCobrado
							.getNumeroSubLote());
					debitoCobradoHistoricoTemp
							.setAnoMesReferenciaDebito(debitoCobrado
									.getAnoMesReferenciaDebito());
					debitoCobradoHistoricoTemp
							.setAnoMesCobrancaDebito(debitoCobrado
									.getAnoMesCobrancaDebito());
					debitoCobradoHistoricoTemp.setValorPrestacao(debitoCobrado
							.getValorPrestacao());
					debitoCobradoHistoricoTemp.setNumeroPrestacao(debitoCobrado
							.getNumeroPrestacao());
					debitoCobradoHistoricoTemp
							.setNumeroParcelaBonus(debitoCobrado
									.getNumeroParcelaBonus());
					debitoCobradoHistoricoTemp
							.setNumeroPrestacaoDebito(debitoCobrado
									.getNumeroPrestacaoDebito());
					debitoCobradoHistoricoTemp.setUltimaAlteracao(new Date());
					debitoCobradoHistoricoTemp
							.setFinanciamentoTipo(debitoCobrado
									.getFinanciamentoTipo());
					debitoCobradoHistoricoTemp.setQuadra(debitoCobrado
							.getQuadra());
					debitoCobradoHistoricoTemp.setLocalidade(debitoCobrado
							.getLocalidade());
					debitoCobradoHistoricoTemp
							.setContaHistorico(contaHistoricoTemp);
					debitoCobradoHistoricoTemp.setDebitoTipo(debitoCobrado
							.getDebitoTipo());
					debitoCobradoHistoricoTemp
							.setLancamentoItemContabil(debitoCobrado
									.getLancamentoItemContabil());
					debitoCobradoHistoricoTemp
							.setParcelamentoGrupo(debitoCobrado
									.getParcelamentoGrupo());

					// Colocado por Raphael Rossiter em 17/10/2008 - Analista:
					// Rosana Carvalho
					debitoCobradoHistoricoTemp
							.setDebitoACobrarGeral(debitoCobrado
									.getDebitoACobrarGeral());

					colecaoDebitoCobradoHistoricoInserir
							.add(debitoCobradoHistoricoTemp);

					Collection<DebitoCobradoCategoria> colecaoDebitoCobradoCategoria = this.repositorioFaturamento
							.pesquisarDebitoCobradoCategoria(debitoCobrado
									.getId());

					if (colecaoDebitoCobradoCategoria != null
							&& !colecaoDebitoCobradoCategoria.isEmpty()) {

						colecaoDebitoCobradoCategoriaRemover = new ArrayList();
						colecaoDebitoCobradoCategoriaRemover
								.addAll(colecaoDebitoCobradoCategoria);

						for (DebitoCobradoCategoria debitoCobradoCategoria : colecaoDebitoCobradoCategoria) {
							DebitoCobradoCategoriaHistorico debitoCobradoCategoriaHistorico = new DebitoCobradoCategoriaHistorico();
							debitoCobradoCategoriaHistorico
									.setComp_id(new DebitoCobradoCategoriaHistoricoPK(
											debitoCobradoHistoricoTemp.getId(),
											debitoCobradoCategoria
													.getCategoria().getId()));
							debitoCobradoCategoriaHistorico
									.setCategoria(debitoCobradoCategoria
											.getCategoria());
							debitoCobradoCategoriaHistorico
									.setDebitoCobradoHistorico(debitoCobradoHistoricoTemp);
							debitoCobradoCategoriaHistorico
									.setQuantidadeEconomia(debitoCobradoCategoria
											.getQuantidadeEconomia());
							debitoCobradoCategoriaHistorico
									.setUltimaAlteracao(new Date());
							debitoCobradoCategoriaHistorico
									.setValorCategoria(debitoCobradoCategoria
											.getValorCategoria());

							colecaoDebitoCobradoCategoriaHistoricoInserir
									.add(debitoCobradoCategoriaHistorico);
						}

						// System.out.println("REMOVENDO DEBITO COBRADO
						// CATEGORIA");
						getControladorBatch()
								.removerColecaoDebitoCobradoCategoriaParaBatch(
										colecaoDebitoCobradoCategoriaRemover);
						colecaoDebitoCobradoCategoriaRemover = null;

					}
				}

				// System.out.println("REMOVENDO DEBITO COBRADO");
				getControladorBatch().removerColecaoDebitoCobradoParaBatch(
						colecaoDebitoCobradoRemover);
				colecaoDebitoCobradoRemover = null;

				// System.out.println("TRANSFERINDO DEBITO COBRADO PARA O
				// HISTORICO");
				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoDebitoCobradoHistoricoInserir);
				colecaoDebitoCobradoHistoricoInserir = null;

				// System.out.println("TRANSFERINDO DEBITO COBRADO CATEGORIA
				// PARA O HISTORICO");
				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoDebitoCobradoCategoriaHistoricoInserir);
				colecaoDebitoCobradoCategoriaHistoricoInserir = null;
			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Envia as conta categoria e conta categoria consumo de faixa para o
	 * histórico
	 * 
	 * [UC0000] Gerar Historico Encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 04/04/2007
	 * 
	 * @param contaHistoricoTemp
	 * @param idConta
	 * @throws ControladorException
	 */
	private void enviarContaCategoriaParaHistorico(
			ContaHistorico contaHistoricoTemp, Integer idConta)
			throws ControladorException {

		Collection colecaoContaCategoriaHistoricoInserir = new ArrayList();
		Collection colecaoContaCategoriaRemover = new ArrayList();
		Collection colecaoContaCategoriaConsumoFaixaHistoricoInserir = new ArrayList();
		Collection colecaoContaCategoriaConsumoFaixaRemover = new ArrayList();
		ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistoricoTemp = null;
		ContaCategoriaHistorico contaCategoriaHistoricoTemp = null;

		try {

			// Conta Categoria
			Collection<IContaCategoria> colecaoContaCategoria = repositorioFaturamento
					.pesquisarContaCategoria(idConta);
			if (colecaoContaCategoria != null
					&& !colecaoContaCategoria.isEmpty()) {

				colecaoContaCategoriaRemover.addAll(colecaoContaCategoria);

				for (IContaCategoria contaContaCategoria : colecaoContaCategoria) {
					contaCategoriaHistoricoTemp = new ContaCategoriaHistorico();
					ContaCategoriaHistoricoPK contaCategoriaHistoricoPK = new ContaCategoriaHistoricoPK(
							contaHistoricoTemp,
							contaContaCategoria.getCategoria());
					contaCategoriaHistoricoPK
							.setSubcategoria(contaContaCategoria
									.getSubcategoria());
					contaCategoriaHistoricoTemp
							.setComp_id(contaCategoriaHistoricoPK);
					contaCategoriaHistoricoTemp
							.setConsumoAgua(contaContaCategoria
									.getConsumoAgua());
					contaCategoriaHistoricoTemp
							.setConsumoEsgoto(contaContaCategoria
									.getConsumoEsgoto());
					contaCategoriaHistoricoTemp
							.setConsumoMinimoAgua(contaContaCategoria
									.getConsumoMinimoAgua());
					contaCategoriaHistoricoTemp
							.setConsumoMinimoEsgoto(contaContaCategoria
									.getConsumoMinimoEsgoto());
					contaCategoriaHistoricoTemp
							.setQuantidadeEconomia(contaContaCategoria
									.getQuantidadeEconomia());
					contaCategoriaHistoricoTemp.setUltimaAlteracao(new Date());
					contaCategoriaHistoricoTemp
							.setValorAgua(contaContaCategoria.getValorAgua());
					contaCategoriaHistoricoTemp
							.setValorEsgoto(contaContaCategoria
									.getValorEsgoto());
					contaCategoriaHistoricoTemp
							.setValorTarifaMinimaAgua(contaContaCategoria
									.getValorTarifaMinimaAgua());
					contaCategoriaHistoricoTemp
							.setValorTarifaMinimaEsgoto(contaContaCategoria
									.getValorTarifaMinimaEsgoto());
					contaCategoriaHistoricoTemp
							.setContaCategoriaConsumoFaixasHistorico(contaContaCategoria
									.getContaCategoriaConsumoFaixas());

					colecaoContaCategoriaHistoricoInserir
							.add(contaCategoriaHistoricoTemp);
				}

				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoContaCategoriaHistoricoInserir);
				colecaoContaCategoriaHistoricoInserir = null;
			}

			// CONTA CATEGORIA CONSUMO FAIXA HISTORICO
			Collection<ContaCategoriaConsumoFaixa> colecaoContaCategoriaConsumoFaixa = this.repositorioFaturamento
					.pesquisarContaCategoriaConsumoFaixa(idConta);

			if (colecaoContaCategoriaConsumoFaixa != null
					&& !colecaoContaCategoriaConsumoFaixa.isEmpty()) {

				colecaoContaCategoriaConsumoFaixaRemover
						.addAll(colecaoContaCategoriaConsumoFaixa);

				for (ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa : colecaoContaCategoriaConsumoFaixa) {
					contaCategoriaHistoricoTemp = new ContaCategoriaHistorico();

					ContaCategoriaHistoricoPK contaCategoriaHistoricoPK = new ContaCategoriaHistoricoPK(
							contaHistoricoTemp,
							contaCategoriaConsumoFaixa.getCategoria());
					contaCategoriaHistoricoPK
							.setSubcategoria(contaCategoriaConsumoFaixa
									.getSubcategoria());
					contaCategoriaHistoricoTemp
							.setComp_id(contaCategoriaHistoricoPK);

					contaCategoriaConsumoFaixaHistoricoTemp = new ContaCategoriaConsumoFaixaHistorico();
					contaCategoriaConsumoFaixaHistoricoTemp
							.setId(contaCategoriaConsumoFaixa.getId());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setConsumoAgua(contaCategoriaConsumoFaixa
									.getConsumoAgua());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setConsumoEsgoto(contaCategoriaConsumoFaixa
									.getConsumoEsgoto());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setConsumoFaixaFim(contaCategoriaConsumoFaixa
									.getConsumoFaixaFim());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setConsumoFaixaInicio(contaCategoriaConsumoFaixa
									.getConsumoFaixaInicio());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setContaCategoriaHistorico(contaCategoriaHistoricoTemp);
					contaCategoriaConsumoFaixaHistoricoTemp
							.setUltimaAlteracao(new Date());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setValorAgua(contaCategoriaConsumoFaixa
									.getValorAgua());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setValorEsgoto(contaCategoriaConsumoFaixa
									.getValorEsgoto());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setValorTarifaFaixa(contaCategoriaConsumoFaixa
									.getValorTarifaFaixa());
					contaCategoriaConsumoFaixaHistoricoTemp
							.setSubcategoria(contaCategoriaConsumoFaixa
									.getSubcategoria());

					colecaoContaCategoriaConsumoFaixaHistoricoInserir
							.add(contaCategoriaConsumoFaixaHistoricoTemp);
				}

				getControladorBatch()
						.removerColecaoContaCategoriaConsumoFaixaParaBatch(
								colecaoContaCategoriaConsumoFaixaRemover);
				colecaoContaCategoriaConsumoFaixaRemover = null;
				colecaoContaCategoriaConsumoFaixaRemover = new ArrayList();

				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoContaCategoriaConsumoFaixaHistoricoInserir);
				colecaoContaCategoriaConsumoFaixaHistoricoInserir = null;
			}

			// Remove a coleção de ContaCategoria
			if (colecaoContaCategoriaRemover != null
					&& !colecaoContaCategoriaRemover.isEmpty()) {
				getControladorBatch().removerColecaoContaCategoriaParaBatch(
						colecaoContaCategoriaRemover);
				colecaoContaCategoriaRemover = null;
			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0XXX] Emitir Aviso de Cobrança
	 * 
	 * 
	 * @author Sávio LuizO
	 * @date 09/04/2007
	 * 
	 */
	public Object[] pesquisarAnoMesEDiaVencimentoFaturamentoGrupo(
			Integer idImovel) throws ControladorException {

		try {
			return repositorioFaturamento
					.pesquisarAnoMesEDiaVencimentoFaturamentoGrupo(idImovel);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorMultasCobradasPorFinanciamnetoTipo(
			int idConta) throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarValorMultasCobradasPorFinanciamnetoTipo(idConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorCreditoPorOrigem(int idConta)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarValorCreditoPorOrigem(idConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso calcula a tarifa miníma de água para um imóvel
	 * (SUBCATEGORIA)
	 * 
	 * [UC0451] Obter Tarifa Miníma de Água para um Imóvel
	 * 
	 * @author Raphael Rossiter
	 * @date 13/04/2006
	 * 
	 * @param imovel
	 * @param colecaoSubcategorias
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	public BigDecimal obterTarifaMinimaAguaImovelPorSubcategoria(Imovel imovel)
			throws ControladorException {

		// Declaração de variáveis
		BigDecimal tarifaMinimaAguaImovel = new BigDecimal("0.00");
		BigDecimal resultadoTarifaMinimaAguaImovel = new BigDecimal("0.00");

		// Declaração de objetos
		Collection colecaoDataVigencia = null;

		// Obtém o id da tarifa vigência da maior data de vigência da tarifa do
		// imóvel
		try {
			colecaoDataVigencia = repositorioMicromedicao
					.pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(),
							imovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		// Obtém o id do array e atribui na variável
		Object[] consumoTarifaVigenciaIdArray = (Object[]) Util
				.retonarObjetoDeColecaoArray(colecaoDataVigencia);
		Integer consumoTarifaVigenciaId = null;

		if (consumoTarifaVigenciaIdArray == null) {
			throw new ControladorException(
					"erro.nao_cadastrada_consumo_tarifa_vigencia", null,
					String.valueOf(imovel.getId()));
		}

		if (consumoTarifaVigenciaIdArray[0] != null) {
			consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0];
		}

		// Cria o objeto consumo tarifa vigência e seta o id
		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		consumoTarifaVigencia.setId(consumoTarifaVigenciaId);

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoSubcategorias = getControladorImovel()
				.obterQuantidadeEconomiasSubCategoria(imovel.getId());

		Iterator colecaoSubcategoriasIterator = colecaoSubcategorias.iterator();

		while (colecaoSubcategoriasIterator.hasNext()) {

			Subcategoria subcategoria = (Subcategoria) colecaoSubcategoriasIterator
					.next();

			try {
				// Obtém a tarifa mínima da subcategoria do imóvel
				tarifaMinimaAguaImovel = (BigDecimal) repositorioFaturamento
						.pesquisarTarifaMinimaCategoriaVigenciaPorSubcategoria(
								consumoTarifaVigencia, subcategoria);

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}

			/*
			 * Caso não exista tarifa cadastrada para a subcategoria em questao,
			 * utilizar a tarifa da categoria
			 */
			if (tarifaMinimaAguaImovel == null) {

				Categoria categoria = subcategoria.getCategoria();
				categoria.setQuantidadeEconomiasCategoria(subcategoria
						.getQuantidadeEconomias());

				Collection colecaoCategoria = new ArrayList();
				colecaoCategoria.add(categoria);

				tarifaMinimaAguaImovel = this
						.obterTarifaMinimaAguaImovel(imovel);

			}

			// Multiplica a quantidade de economias da categoria pelo consumo
			// mínimo e acumula
			resultadoTarifaMinimaAguaImovel = resultadoTarifaMinimaAguaImovel
					.add(tarifaMinimaAguaImovel.multiply(new BigDecimal(
							subcategoria.getQuantidadeEconomias())));

		}

		// Retorna o consumo mínimo da ligação
		return resultadoTarifaMinimaAguaImovel;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0004] Verificar Critério
	 * de Cobrança para Imóvel Pesquisa a soma dos imoveis com parcelamento.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarQuantidadeDebitosCobradosComParcelamento(
			Collection<ContaValoresHelper> colecaoContasValores)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarQuantidadeDebitosCobradosComParcelamento(colecaoContasValores);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisar conjunto de contas p/ emissão da 2°Via
	 * 
	 * @author Ana Maria
	 * @date 19/04/2007
	 * 
	 * @param colecaoImovel
	 * @param anoMes
	 * @throws ControladorException
	 */
	public Collection pesquisarConjuntoContaEmitir2Via(
			Collection colecaoImovel, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim, String indicadorContaPaga)
			throws ControladorException {

		Collection colecaoContasEmissao = new ArrayList();
		Collection colecaoContasManutencao = new ArrayList();
		List colecaoAuxiliar = new ArrayList();

		colecaoAuxiliar.addAll(colecaoImovel);

		int i = 0;
		int cont = 500;

		Collection colecao = new ArrayList();
		while (i <= colecaoImovel.size()) {

			if (colecaoImovel.size() - i >= cont) {
				colecao = colecaoAuxiliar.subList(i, i + cont);
			} else {
				colecao = colecaoAuxiliar.subList(i, colecaoImovel.size());
			}

			if (colecao.size() == ConstantesSistema.ZERO.intValue()) {
				break;
			}

			i = i + cont;
			try {
				colecaoContasManutencao = repositorioFaturamento
						.pesquisarIdContasImoveis(anoMes, colecao,
								dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFim,
								indicadorContaPaga);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}
			if (colecaoContasManutencao != null
					&& !colecaoContasManutencao.isEmpty()) {
				colecaoContasEmissao.addAll(colecaoContasManutencao);
			}
		}

		return colecaoContasEmissao;
	}

	/**
	 * Gera credito a realizar para os imóveis de determinados grupos
	 * 
	 * BATCH PARA CORREÇÃO DA BASE
	 * 
	 * @author Sávio Luiz
	 * @date 02/05/2007
	 * 
	 */
	public void gerarCreditoARealizarPorImoveisDoGrupo(Collection idsGrupos,
			Integer anoMesReferenciaConta, Integer anoMesReferenciaDebito)
			throws ControladorException {
		Collection colecaoDadosImovelCreditoARealizar = null;
		try {
			colecaoDadosImovelCreditoARealizar = repositorioFaturamento
					.pesquisarDadosImoveisParaGerarCreditoARealizar(idsGrupos,
							anoMesReferenciaConta, anoMesReferenciaDebito);
		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (colecaoDadosImovelCreditoARealizar != null
				&& !colecaoDadosImovelCreditoARealizar.equals("")) {
			Iterator iteDados = colecaoDadosImovelCreditoARealizar.iterator();
			while (iteDados.hasNext()) {
				Object[] dadosImovelCreditoARealizar = (Object[]) iteDados
						.next();
				if (dadosImovelCreditoARealizar != null) {
					Integer idImovel = null;
					Integer idLocalidade = null;
					Integer idQuadra = null;
					Integer numeroQuadra = null;
					Integer codigoSetor = null;
					Short lote = null;
					Short subLote = null;
					BigDecimal valorPretacao = null;
					Integer amreferenciaDebito = null;
					if (dadosImovelCreditoARealizar[0] != null) {
						idImovel = (Integer) dadosImovelCreditoARealizar[0];
					}
					if (dadosImovelCreditoARealizar[1] != null) {
						idLocalidade = (Integer) dadosImovelCreditoARealizar[1];
					}
					if (dadosImovelCreditoARealizar[2] != null) {
						idQuadra = (Integer) dadosImovelCreditoARealizar[2];
					}
					if (dadosImovelCreditoARealizar[3] != null) {
						numeroQuadra = (Integer) dadosImovelCreditoARealizar[3];
					}
					if (dadosImovelCreditoARealizar[4] != null) {
						codigoSetor = (Integer) dadosImovelCreditoARealizar[4];
					}
					if (dadosImovelCreditoARealizar[5] != null) {
						lote = (Short) dadosImovelCreditoARealizar[5];
					}
					if (dadosImovelCreditoARealizar[6] != null) {
						subLote = (Short) dadosImovelCreditoARealizar[6];
					}
					if (dadosImovelCreditoARealizar[7] != null) {
						valorPretacao = (BigDecimal) dadosImovelCreditoARealizar[7];
					}
					if (dadosImovelCreditoARealizar[8] != null) {
						amreferenciaDebito = (Integer) dadosImovelCreditoARealizar[8];
					}

					// cria o objeto de credito a realizar Geral
					CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
					creditoARealizarGeral.setIndicadorHistorico(new Short("2"));
					creditoARealizarGeral.setUltimaAlteracao(new Date());
					Integer idCreditoARealizarGeral = (Integer) getControladorUtil()
							.inserir(creditoARealizarGeral);
					creditoARealizarGeral.setId(idCreditoARealizarGeral);

					// cria o objeto de credito a realizar
					CreditoARealizar creditoARealizar = new CreditoARealizar();
					creditoARealizar.setId(idCreditoARealizarGeral);
					creditoARealizar
							.setCreditoARealizarGeral(creditoARealizarGeral);
					if (idImovel != null) {
						Imovel imovel = new Imovel(idImovel);
						creditoARealizar.setImovel(imovel);
					}
					creditoARealizar.setCreditoTipo(new CreditoTipo(
							CreditoTipo.DEVOLUCAO_ACRESCIMOS_IMPONTUALIDADE));
					creditoARealizar.setGeracaoCredito(new Date());
					creditoARealizar
							.setAnoMesReferenciaCredito(amreferenciaDebito);
					creditoARealizar.setAnoMesCobrancaCredito(sistemaParametro
							.getAnoMesArrecadacao());
					creditoARealizar
							.setAnoMesReferenciaContabil(sistemaParametro
									.getAnoMesFaturamento());
					creditoARealizar.setValorCredito(valorPretacao);
					creditoARealizar
							.setValorResidualMesAnterior(new BigDecimal("0.00"));
					creditoARealizar.setNumeroPrestacaoCredito(new Short("1"));
					creditoARealizar
							.setNumeroPrestacaoRealizada(new Short("0"));
					if (idLocalidade != null) {
						Localidade localidade = new Localidade(idLocalidade);
						creditoARealizar.setLocalidade(localidade);
					}
					if (idQuadra != null) {
						Quadra quadra = new Quadra(idQuadra);
						creditoARealizar.setQuadra(quadra);
					}
					creditoARealizar.setCodigoSetorComercial(codigoSetor);
					creditoARealizar.setNumeroQuadra(numeroQuadra);
					creditoARealizar.setNumeroLote(lote);
					creditoARealizar.setNumeroSubLote(subLote);
					creditoARealizar
							.setLancamentoItemContabil(new LancamentoItemContabil(
									LancamentoItemContabil.ACRESCIMOS_POR_IMPONTUALIDADE));
					creditoARealizar
							.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(
									DebitoCreditoSituacao.NORMAL));
					creditoARealizar
							.setCreditoOrigem(new CreditoOrigem(
									CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE));
					creditoARealizar.setUltimaAlteracao(new Date());
					getControladorUtil().inserir(creditoARealizar);

					if (idImovel != null) {
						Map<Categoria, BigDecimal> mapValorIRPagamentosClassificadosConta = new HashMap();
						// [UC0108 - Obter Quantidade de Economias por
						// Categoria]
						Collection colecaoCategoriasImovel = getControladorImovel()
								.obterQuantidadeEconomiasCategoria(
										new Imovel(idImovel));
						Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel
								.iterator();

						// [UC0185 - Obter Valor por Categoria]
						Iterator iteratorColecaoValorIRPorCategoria = (getControladorImovel()
								.obterValorPorCategoria(
										colecaoCategoriasImovel, valorPretacao))
								.iterator();

						while (iteratorColecaoCategoriasImovel.hasNext()
								&& iteratorColecaoValorIRPorCategoria.hasNext()) {
							Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel
									.next();

							BigDecimal valorIR = (BigDecimal) iteratorColecaoValorIRPorCategoria
									.next();

							if (!mapValorIRPagamentosClassificadosConta
									.containsKey(categoria)) {
								mapValorIRPagamentosClassificadosConta.put(
										categoria, BigDecimal.ZERO);
							}

							mapValorIRPagamentosClassificadosConta.put(
									categoria,
									mapValorIRPagamentosClassificadosConta.get(
											categoria).add(valorIR));
						}
						Iterator mapIterator = mapValorIRPagamentosClassificadosConta
								.keySet().iterator();
						while (mapIterator.hasNext()) {
							Categoria categoria = (Categoria) mapIterator
									.next();
							CreditoARealizarCategoria creditoARealizarCategoria = new CreditoARealizarCategoria();
							creditoARealizarCategoria
									.setComp_id(new CreditoARealizarCategoriaPK(
											creditoARealizar.getId(), categoria
													.getId()));
							creditoARealizarCategoria.setCategoria(categoria);
							creditoARealizarCategoria
									.setCreditoARealizar(creditoARealizar);
							BigDecimal valorCategoria = mapValorIRPagamentosClassificadosConta
									.get(categoria);
							creditoARealizarCategoria
									.setValorCategoria(valorCategoria);
							creditoARealizarCategoria
									.setQuantidadeEconomia(categoria
											.getQuantidadeEconomiasCategoria());
							creditoARealizarCategoria
									.setUltimaAlteracao(new Date());
							getControladorUtil().inserir(
									creditoARealizarCategoria);
						}
					}
				}

			}
		}

	}

	/**
	 * [UC0144] Inserir Comando Atividade Faturamento
	 * 
	 * A data de vencimento do grupo será formatada com o mês seguinte ao de
	 * referência do grupo
	 * 
	 * @author Raphael Rossiter
	 * @date 05/05/2007
	 * 
	 * @param diaVencimento
	 *            , mesVencimento, anoVencimento
	 * @throws ControladorException
	 */
	public Date obterDataVencimentoFaturamentoGrupo(int diaVencimento,
			int mesVencimento, int anoVencimento) throws ControladorException {

		Calendar dataVencimento = new GregorianCalendar(new Integer(
				anoVencimento).intValue(),
				new Integer(mesVencimento).intValue(), diaVencimento);

		return dataVencimento.getTime();
	}

	/**
	 * [UC0XXX] - Gerar Relatório Tarifa de Consumo
	 * 
	 * Pesquisas as tarifas de consumo para o relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 11/05/2007
	 * 
	 * @param descricao
	 *            , dataVigenciaInicial, dataVigenciaFinal
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConsumoTarifaRelatorio(String descricao,
			Date dataVigenciaInicial, Date dataVigenciaFinal)
			throws ControladorException {

		Collection colecaoDadosConsumoTarifa = null;
		Collection colecaoConsumoTarifaRelatorioHelper = new ArrayList();

		try {
			colecaoDadosConsumoTarifa = repositorioFaturamento
					.pesquisarConsumoTarifaRelatorio(descricao,
							dataVigenciaInicial, dataVigenciaFinal);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDadosConsumoTarifa != null
				&& !colecaoDadosConsumoTarifa.isEmpty()) {

			Iterator colecaoDadosConsumoTarifaIterator = colecaoDadosConsumoTarifa
					.iterator();

			ConsumoTarifaRelatorioHelper consumoTarifaRelatorioHelper = null;

			while (colecaoDadosConsumoTarifaIterator.hasNext()) {

				Object[] dadosConsumoTarifa = (Object[]) colecaoDadosConsumoTarifaIterator
						.next();

				consumoTarifaRelatorioHelper = new ConsumoTarifaRelatorioHelper();

				// Id da Tarifa de Consumo
				if (dadosConsumoTarifa[0] != null) {
					consumoTarifaRelatorioHelper
							.setIdConsumoTarifa((Integer) dadosConsumoTarifa[0]);
				}

				// Descrição da Tarifa de Consumo
				if (dadosConsumoTarifa[1] != null) {
					consumoTarifaRelatorioHelper
							.setDescricaoConsumoTarifa((String) dadosConsumoTarifa[1]);
				}

				// Categoria
				if (dadosConsumoTarifa[2] != null) {
					consumoTarifaRelatorioHelper
							.setCategoria((String) dadosConsumoTarifa[2]);
				}

				// Faixa Inicial
				if (dadosConsumoTarifa[3] != null) {
					consumoTarifaRelatorioHelper
							.setFaixaInicial((Integer) dadosConsumoTarifa[3]);
				}

				// Faixa Final
				if (dadosConsumoTarifa[4] != null) {
					consumoTarifaRelatorioHelper
							.setFaixaFinal((Integer) dadosConsumoTarifa[4]);
				}

				// Custo
				if (dadosConsumoTarifa[5] != null) {
					consumoTarifaRelatorioHelper
							.setCusto((BigDecimal) dadosConsumoTarifa[5]);
				}

				// Tarifa Mínima
				if (dadosConsumoTarifa[6] != null) {
					consumoTarifaRelatorioHelper
							.setTarifaMinima((BigDecimal) dadosConsumoTarifa[6]);
				}

				// Data Validade Inicial
				if (dadosConsumoTarifa[7] != null) {
					consumoTarifaRelatorioHelper
							.setDataValidadeInicial((Date) dadosConsumoTarifa[7]);
				}

				// Consumo Mínimo
				if (dadosConsumoTarifa[8] != null) {
					consumoTarifaRelatorioHelper
							.setConsumoMinimo((Integer) dadosConsumoTarifa[8]);
				}

				colecaoConsumoTarifaRelatorioHelper
						.add(consumoTarifaRelatorioHelper);

			}

		}

		return colecaoConsumoTarifaRelatorioHelper;

	}

	/**
	 * [UC0XXX] - Gerar Relatório de Tarifa de Consumo
	 * 
	 * Pesquisas a data final de validade de uma tarifa de consumo
	 * 
	 * @author Rafael Corrêa
	 * @date 11/05/2007
	 * 
	 * @param Integer
	 *            idConsumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarDataFinalValidadeConsumoTarifa(
			Integer idConsumoTarifa, Date dataInicioVigencia)
			throws ControladorException {

		Date dataFimVigencia = null;
		Date dataQuery = null;

		try {
			dataQuery = repositorioFaturamento
					.pesquisarDataFinalValidadeConsumoTarifa(idConsumoTarifa,
							dataInicioVigencia);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (dataQuery != null) {
			dataFimVigencia = Util.subtrairNumeroDiasDeUmaData(dataQuery, 1);
		}

		return dataFimVigencia;

	}

	/**
	 * Recupera o id da Conta Retificada
	 * 
	 * @author Vivianne Sousa
	 * @date 08/05/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarAnoMesReferenciaFaturamentoGrupo(Integer idImovel)
			throws ControladorException {

		Integer retorno = null;
		try {
			retorno = repositorioFaturamento
					.pesquisarAnoMesReferenciaFaturamentoGrupo(idImovel);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Recupera as contas do Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer obterContasConjuntoImoveis(Integer anoMes,
			Collection idsImovel, Integer codigoCliente, Short relacaoTipo,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer idGrupoFaturamento, Integer anoMesFinal,
			String indicadorContaPaga, Integer somenteDebitoAutomatico)
			throws ControladorException {

		Integer quantidadeConta = 0;
		try {
			if (idGrupoFaturamento != null) {
				quantidadeConta = repositorioFaturamento
						.pesquisarQuantidadeContasGrupoFaturamento(anoMes,
								idGrupoFaturamento, dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFinal,
								somenteDebitoAutomatico);
			} else {
				quantidadeConta = repositorioFaturamento
						.pesquisarQuantidadeContasImoveis(anoMes, idsImovel,
								dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFinal,
								indicadorContaPaga, somenteDebitoAutomatico);
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}
		return quantidadeConta;
	}

	/**
	 * Recupera quantidade contas sem está em revisão dos Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer obterContasRevisaoConjuntoImoveis(Integer anoMes,
			Collection idsImovel, Integer codigoCliente, Short relacaoTipo,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer idGrupoFaturamento, Integer anoMesFinal,
			String indicadorContaPaga) throws ControladorException {

		Integer quantidadeConta = 0;
		try {
			if (idGrupoFaturamento != null) {
				quantidadeConta = repositorioFaturamento
						.pesquisarQuantidadeContasRevisaoGrupoFaturamento(
								anoMes, idGrupoFaturamento,
								dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFinal);
			} else {
				quantidadeConta = repositorioFaturamento
						.pesquisarQuantidadeContasRevisaoImoveis(anoMes,
								idsImovel, dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFinal,
								indicadorContaPaga);
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}
		return quantidadeConta;
	}

	/**
	 * [UC0147] - Cancelar Conjunto Conta Cliente
	 * 
	 * @author Ana Maria, Raphael Rossiter
	 * @date 10/12/2005, 27/02/2008
	 * 
	 * @param colecaoContas
	 * @param identificadores
	 * @param contaMotivoCancelamento
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void cancelarConjuntoContaCliente(Integer codigoCliente,
			Short relacaoTipo, ContaMotivoCancelamento contaMotivoCancelamento,
			Integer anoMes, Date dataVencimentoContaInicio,
			Date dataVencimentoContaFim, Integer anoMesFim,
			Usuario usuarioLogado) throws ControladorException {

		Collection colecaoConta = new ArrayList();
		Collection colecaoContasManutencao = new ArrayList();
		// Collection colecao = new ArrayList();

		try {
			colecaoContasManutencao = repositorioFaturamento
					.pesquisarContasCliente(codigoCliente, relacaoTipo, anoMes,
							dataVencimentoContaInicio, dataVencimentoContaFim,
							anoMesFim, null);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}
		if (colecaoContasManutencao != null
				&& !colecaoContasManutencao.isEmpty()) {

			Iterator colecaoContasManutencaoIterator = colecaoContasManutencao
					.iterator();

			while (colecaoContasManutencaoIterator.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] contaArray = (Object[]) colecaoContasManutencaoIterator
						.next();

				Conta conta = new Conta();
				// ID da conta
				conta.setId((Integer) contaArray[0]);
				// Ano Mês referencia
				conta.setReferencia((Integer) contaArray[1]);
				// DebitoCreditoSituacaoAtual
				conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);
				// Ano Mês referencia contábil
				conta.setReferenciaContabil((Integer) contaArray[12]);

				// imovel
				if (contaArray[14] != null) {
					conta.setImovel((Imovel) contaArray[14]);
				}

				// DebitoCreditoSituacaoAnterior
				if (contaArray[15] != null) {
					conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[15]);
				}

				colecaoConta.add(conta);
			}
		}

		Iterator colecaoContasIt = colecaoConta.iterator();
		Conta contaColecao = null;
		// Conta contaNaBase = null;
		FiltroConta filtroConta = new FiltroConta();

		while (colecaoContasIt.hasNext()) {
			contaColecao = (Conta) colecaoContasIt.next();

			// Usuário logado
			contaColecao.setUsuario(usuarioLogado);

			// Carregando a conta que está na base
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID,
					contaColecao.getId()));

			filtroConta.limparListaParametros();
			/**
			 * Caso a situação atual da conta corresponda a normal (DCST_IDATUAL
			 * com o valor correspondente a normal da tabela
			 * DEBITO_CREDITO_SITUACAO) ou corresponda a retificada ou incluída
			 * (DCST_IDATUAL com o valor correspondente a retificada ou
			 * incluída, da tabela DEBITO_CREDITO_SITUACAO) e a retificação ou
			 * inclusão já tenha sido contabilizada (CNTA_AMREFERENCIACONTABIL
			 * menor que PARM_AMREFERENCIAFATURAMENTO da tabela
			 * SISTEMA_PARAMETROS), atualizar os seguintes atributos da conta.
			 */

			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			if (isContaNormalIncluidaOuRetificadaEReferenciaContabilMenor(contaColecao, sistemaParametro)) {

				// Data do cancelamento
				contaColecao.setDataCancelamento(new Date());

				// Motivo do Cancelamento
				contaColecao
						.setContaMotivoCancelamento(contaMotivoCancelamento);

				// Situação Anterior
				/*
				 * Caso a situação atual da conta corresponda a normal
				 * (DCST_IDATUAL com o valor correspondente a normal da tabela
				 * DEBITO_CREDITO_SITUACAO) e a conta tenha sido faturada no mês
				 * de faturamento corrente (CNTA_AMREFERENCIACONTA=
				 * PARM_AMREFERENCIAFATURAMENTO da tabela SISTEMA_PARAMETROS)
				 * DCST_IDANTERIOR=DCST_IDATUAL, caso contrário
				 * DCST_IDANTERIOR=nulo)
				 */
				if (contaColecao.getDebitoCreditoSituacaoAtual().getId()
						.equals(DebitoCreditoSituacao.NORMAL)
						&& Util.compararAnoMesReferencia(new Integer(
								contaColecao.getReferencia()), new Integer(
								sistemaParametro.getAnoMesFaturamento()), "=")) {

					contaColecao.setDebitoCreditoSituacaoAnterior(contaColecao
							.getDebitoCreditoSituacaoAtual());
				} else {
					contaColecao.setDebitoCreditoSituacaoAnterior(null);
				}

				// Situação Atual
				DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();

				/**
				 * Caso motivo de retificação seja débito
				 * prescrito, alterar a situação da conta para 8.
				 * 
				 * @author Wellington Rocha
				 * @date 01/06/2012
				 * 
				 * */
				boolean contaPodeSerPrescrita = true;
				if (contaMotivoCancelamento.getId().equals(
						ContaMotivoCancelamento.DEBITO_PRESCRITO)
						|| contaMotivoCancelamento.getId().equals(
								ContaMotivoCancelamento.PRESCRICAO)) {

					contaPodeSerPrescrita = this
							.verificarPossibilidadePrescricaoConta(contaColecao
									.getId());
					if (contaPodeSerPrescrita) {
						debitoCreditoSituacao
								.setId(DebitoCreditoSituacao.DEBITO_PRESCRITO);
					}
				} else {
					debitoCreditoSituacao
							.setId(DebitoCreditoSituacao.CANCELADA);
				}

				if (!contaPodeSerPrescrita) {
					throw new ControladorException(
							"erro.conta_nao_satisfaz_criterios_para_prescricao",
							"exibirCancelarContaAction.do?contaID="
									+ contaColecao.getId() + "&idImovel="
									+ contaColecao.getImovel().getId(), null);
				} else {

					debitoCreditoSituacao
							.setId(DebitoCreditoSituacao.CANCELADA);
					contaColecao
							.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

					// Colocado por Raphael Rossiter em 27/02/2008
					// Ano Mes Referencia Contabil
					if (contaColecao.getReferencia() <= sistemaParametro
							.getAnoMesFaturamento().intValue()) {

						contaColecao.setReferenciaContabil(Util
								.getAnoMesComoInteger(new Date()));
					}

					// Usuario
					contaColecao.setUsuario(usuarioLogado);

					// última alteração
					contaColecao.setUltimaAlteracao(new Date());

					// ------------ <REGISTRAR
					// TRANSAÇÃO>----------------------------

					RegistradorOperacao registradorOperacao = new RegistradorOperacao(
							Operacao.OPERACAO_CANCELAR_CONTA,
							contaColecao.getImovel() != null ? contaColecao
									.getImovel().getId() : contaColecao.getId(),
							contaColecao.getId(), new UsuarioAcaoUsuarioHelper(
									usuarioLogado,
									UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacao.registrarOperacao(contaColecao);

					getControladorTransacao().registrarTransacao(contaColecao);

					// ------------ </REGISTRAR
					// TRANSAÇÃO>----------------------------

					// UPDATE
					try {

						if (contaColecao.getDebitoCreditoSituacaoAnterior() == null) {
							repositorioFaturamento
									.cancelarContaReferenciaContabilMenorSistemaParametro(
											contaColecao, null);

						} else {
							repositorioFaturamento
									.cancelarContaReferenciaContabilMenorSistemaParametro(
											contaColecao,
											contaColecao
													.getDebitoCreditoSituacaoAnterior()
													.getId());
						}

						// CRC2725 - alterado por Vivianne Sousa - 30/03/2010
						// analista:Fátima
						// 1.1.2.Verificar se há relação do cancelamento com
						// itens
						// de negativação
						getControladorSpcSerasa()
								.verificarRelacaoDoCancelamentoComItensNegativacao(
										contaColecao, null);

					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						new ControladorException("erro.sistema", ex);
					} catch (ControladorException ex) {
						sessionContext.setRollbackOnly();
						throw ex;
					} catch (Exception ex) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
				}

			} else if (isContaIncluidaOuRetificadaEReferenciaContabilMaiorOuIgual(contaColecao, sistemaParametro)) {

				// Remoção da conta no BD
				contaColecao.setPercentualEsgoto(new BigDecimal("0.00"));

				// CRC2725 - alterado por Vivianne Sousa - 17/09/2009
				// analista:Fátima
				// [FS0003 - Verificar existência de itens de negativação para a
				// conta incluída]:
				getControladorSpcSerasa()
						.verificarExistenciaItensNegativacaoParaContaIncluida(
								contaColecao);
				// 1.2.4. Verificar se há relação do cancelamento com itens de
				// negativação:
				// [UC0937 - Obter Itens de Negativação Associados à Conta]
				// passando o identificador do imóvel (Imóvel da Conta
				// Retificada e Cancelada)
				// e a referência (Referência da Conta Retificada e Cancelada).
				Collection colecaoNegativadorMovimentoRegItem = getControladorSpcSerasa()
						.obterItensNegativacaoAssociadosAConta(
								contaColecao.getImovel().getId(),
								contaColecao.getReferencia());

				this.getControladorUtil().remover(
						new String[] { "" + contaColecao.getId() },
						contaColecao.getClass().getName(), null, null);

				if (contaColecao.getDebitoCreditoSituacaoAtual().getId()
						.equals(DebitoCreditoSituacao.RETIFICADA)) {

					// [FS0002] - Verificar existência da conta
					// cancelada por retificação

					filtroConta.adicionarParametro(new ParametroSimples(
							FiltroConta.REFERENCIA, contaColecao
									.getReferencia()));

					filtroConta.adicionarParametro(new ParametroSimples(
							FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
							DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO));

					Collection colecaoContaCanceladaRetificacao = this
							.getControladorUtil().pesquisar(filtroConta,
									Conta.class.getName());

					filtroConta.limparListaParametros();

					if (colecaoContaCanceladaRetificacao == null
							|| colecaoContaCanceladaRetificacao.isEmpty()) {
						throw new ControladorException(
								"atencao.pesquisa.nenhuma.conta_cancelada_retificacao");
					}

					Conta contaCanceladaPorRetificacao = (Conta) Util
							.retonarObjetoDeColecao(colecaoContaCanceladaRetificacao);

					// Data do cancelamento
					contaCanceladaPorRetificacao
							.setDataCancelamento(new Date());

					// Motivo do cancelamento
					contaCanceladaPorRetificacao
							.setContaMotivoCancelamento(contaMotivoCancelamento);

					// Situação Atual
					DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
					debitoCreditoSituacao
							.setId(DebitoCreditoSituacao.CANCELADA);
					contaCanceladaPorRetificacao
							.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

					// Data da retificação = NULL
					contaCanceladaPorRetificacao.setDataRetificacao(null);

					// Motivo da retificação = NULL
					contaCanceladaPorRetificacao
							.setContaMotivoRetificacao(null);

					// Colocado por Raphael Rossiter em 27/02/2008
					// Ano Mês de referência contábil
					if (contaCanceladaPorRetificacao.getReferencia() <= sistemaParametro
							.getAnoMesFaturamento().intValue()) {

						contaCanceladaPorRetificacao.setReferenciaContabil(Util
								.getAnoMesComoInteger(new Date()));
					}

					// última alteração
					contaCanceladaPorRetificacao.setUltimaAlteracao(new Date());

					// Usuário logado
					contaCanceladaPorRetificacao.setUsuario(usuarioLogado);

					// ------------ <REGISTRAR
					// TRANSAÇÃO>----------------------------

					RegistradorOperacao registradorOperacao = new RegistradorOperacao(
							Operacao.OPERACAO_CANCELAR_CONTA,
							contaCanceladaPorRetificacao.getImovel() != null ? contaCanceladaPorRetificacao
									.getImovel().getId() : contaColecao.getId(),
							contaColecao.getId(), new UsuarioAcaoUsuarioHelper(
									usuarioLogado,
									UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacao
							.registrarOperacao(contaCanceladaPorRetificacao);

					getControladorTransacao().registrarTransacao(
							contaCanceladaPorRetificacao);

					// ------------ </REGISTRAR
					// TRANSAÇÃO>----------------------------
					// UPDATE
					try {
						repositorioFaturamento
								.cancelarContaReferenciaContabilMaiorIgualSistemaParametro(contaCanceladaPorRetificacao);

						// CRC2725 - alterado por Vivianne Sousa - 17/09/2009
						// analista:Fátima
						// 1.2.6.5. Caso existam itens de negativação associados
						// à conta (coleção de itens de negativação não está
						// vazia):
						if (colecaoNegativadorMovimentoRegItem != null
								&& !colecaoNegativadorMovimentoRegItem
										.isEmpty()) {
							// Caso existam itens de negativação associados à
							// conta:
							Iterator iterNmri = colecaoNegativadorMovimentoRegItem
									.iterator();
							while (iterNmri.hasNext()) {
								Integer idNmri = (Integer) iterNmri.next();
								// [SB0002 - Atualizar Item Negativação - Conta
								// Retificada].
								getControladorSpcSerasa()
										.atualizarNegativadorMovimentoRegItem(
												idNmri,
												new Date(),
												CobrancaDebitoSituacao.CANCELADO,
												contaCanceladaPorRetificacao
														.getId(),
												contaColecao.getId());
							}
						}

					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						new ControladorException("erro.sistema", ex);
					} catch (ControladorException ex) {
						sessionContext.setRollbackOnly();
						throw ex;
					} catch (Exception ex) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
				}
			}

			// Alterado por Francisco - 26/05/08, por conta do Resumo de Ações
			// de cobrança
			// Analista: Ana Breda
			try {
				// Atualizar documento de cobranca da conta, se houver, para
				// cancelado
				repositorioCobranca.atualizarSituacaoCobrancaDocumentoItem(
						CobrancaDebitoSituacao.CANCELADO, new Date(),
						contaColecao.getId(), null, null);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}

		}
	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Ana Maria
	 * @date 20/01/2007
	 * 
	 * @param colecaoContas
	 * @param dataVencimento
	 * @throws ControladorException
	 */
	public void alterarVencimentoConjuntoContaCliente(Integer codigoCliente, Short relacaoTipo, Date dataVencimentoInformada,
			Integer anoMes, Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Integer anoMesFim, Usuario usuario,
			Integer codigoClienteSuperior, boolean isDebitoAutomatico) throws ControladorException {

		Collection colecaoConta = new ArrayList();
		Collection colecaoContasManutencao = new ArrayList();

		// PARÂMETROS DO SISTEMA
		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

		try {
			colecaoContasManutencao = repositorioFaturamento.pesquisarContasCliente(codigoCliente, relacaoTipo, anoMes,
					dataVencimentoContaInicio, dataVencimentoContaFim, anoMesFim, codigoClienteSuperior, dataVencimentoInformada,
					isDebitoAutomatico);
			
			/**
			 * [UC0407] Filtrar Imóveis para Inserir ou Manter Conta 3. Caso o
			 * indicador de bloqueio de contas vinculadas a contrato de
			 * parcelamento no manter contas esteja ativo retirar da lista de
			 * contas selecionadas as contas vinculadas a algum contrato de
			 * parcelamento ativo
			 * 
			 * RM 1887 - Contrato Parcelamento por Cliente Adicionado por:
			 * Mariana Victor Data: 15/07/2011
			 * 
			 * */
			if (sistemaParametro
					.getIndicadorBloqueioContasContratoParcelManterConta() != null
					&& sistemaParametro
							.getIndicadorBloqueioContasContratoParcelManterConta()
							.equals(ConstantesSistema.SIM)) {
				colecaoContasManutencao = getControladorRetificarConta()
						.obterColecaoSemContasEmContratoParcelamentoRetificarConjuntoContasIds(colecaoContasManutencao);
			}
			/**
			 * FIM DA ALTERAÇÂO
			 * */

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		//

		if (colecaoContasManutencao != null
				&& !colecaoContasManutencao.isEmpty()) {

			Iterator colecaoContasManutencaoIterator = colecaoContasManutencao
					.iterator();

			while (colecaoContasManutencaoIterator.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] contaArray = (Object[]) colecaoContasManutencaoIterator
						.next();

				Conta conta = new Conta();
				// ID da conta
				conta.setId((Integer) contaArray[0]);

				// Data de vencimento
				String vencimento = String.valueOf(contaArray[2]);
				SimpleDateFormat formatoData = new SimpleDateFormat(
						"yyyy-MM-dd");
				Date dataVencimento;

				try {
					dataVencimento = formatoData.parse(vencimento);
				} catch (java.text.ParseException e) {
					dataVencimento = null;
				}

				conta.setDataVencimentoConta(dataVencimento);

				// Data de validade
				String validade = String.valueOf(contaArray[9]);
				Date dataValidade;

				try {

					dataValidade = formatoData.parse(validade);
				} catch (java.text.ParseException e) {
					dataValidade = null;
				}

				conta.setDataValidadeConta(dataValidade);

				conta.setUltimaAlteracao(new Date());

				/*
				 * Colocado por Raphael Rossiter em 27/12/2007 OBJ: Carregar o
				 * id do imóvel para registrar a transação
				 */
				Imovel imovel = (Imovel) contaArray[14];
				conta.setImovel(imovel);

				colecaoConta.add(conta);
			}
		}

		alterarVencimentoConta(colecaoConta, null, dataVencimentoInformada,
				usuario);

		// ALTERANDO O VENVCIMENTO DAS FATURAS
		this.alterarVencimentoConjuntoFaturaCliente(codigoCliente,
				dataVencimentoInformada, anoMes, dataVencimentoContaInicio,
				dataVencimentoContaFim, anoMesFim, codigoClienteSuperior);
	}

	
	/**
	 * Pesquisar conjunto de contas p/ emissão da 2°Via
	 * 
	 * @author Ana Maria
	 * @date 19/04/2007
	 * 
	 * @param colecaoImovel
	 * @param anoMes
	 * @throws ControladorException
	 */
	public Collection pesquisarConjuntoContaClienteEmitir2Via(
			Integer codigoCliente, Short relacaoTipo, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim) throws ControladorException {

		Collection colecaoContasEmissao = new ArrayList();
		Collection colecaoContasManutencao = new ArrayList();

		try {
			colecaoContasManutencao = repositorioFaturamento
					.pesquisarIdContasCliente(codigoCliente, relacaoTipo,
							anoMes, dataVencimentoContaInicio,
							dataVencimentoContaFim, anoMesFim);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}
		if (colecaoContasManutencao != null
				&& !colecaoContasManutencao.isEmpty()) {
			colecaoContasEmissao.addAll(colecaoContasManutencao);
		}

		return colecaoContasEmissao;
	}

	/**
	 * Recupera id de conta(s) sem revisão ou em revisão por ação do usuário
	 * 
	 * @author Vivianne Sousa
	 * @date 14/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasNaoEmRevisaoOuEmRevisaoPorAcaoUsuario(
			Collection idsConta) throws ControladorException {

		Collection retorno = null;
		try {
			retorno = repositorioFaturamento
					.obterContasNaoEmRevisaoOuEmRevisaoPorAcaoUsuario(idsConta);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Recupera id de contas que estão em revisão por acão do usuario
	 * 
	 * @author Vivianne Sousa
	 * @date 14/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasEmRevisaoPorAcaoUsuario(Collection idsConta)
			throws ControladorException {

		Collection retorno = null;
		try {
			retorno = repositorioFaturamento
					.obterContasEmRevisaoPorAcaoUsuario(idsConta);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Permite inserir um Tipo de Credito
	 * 
	 * [UC0217] Inserir Tipo Credito
	 * 
	 * @author Thiago Tenório
	 * @date 30/03/2006
	 * 
	 */
	public Integer inserirTipoCredito(CreditoTipo creditoTipo,
			Usuario usuarioLogado) throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_TIPO_CREDITO_INSERIR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_TIPO_CREDITO_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		creditoTipo.setOperacaoEfetuada(operacaoEfetuada);
		creditoTipo.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(creditoTipo);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Integer id = (Integer) getControladorUtil().inserir(creditoTipo);

		return id;

	}

	/**
	 * [UC0513] Manter Tipo de Crédito
	 * 
	 * Remover Tipo de Crédito
	 * 
	 * @author Thiago Tenório
	 * @date 19/03/2007
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public void removerTipoCredito(String[] ids, Usuario usuarioLogado)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_TIPO_CREDITO_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(
				usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		this.getControladorUtil().remover(ids, CreditoTipo.class.getName(),
				null, null);
	}

	/**
	 * [UC0298] Manter Tipo de Credito[] Atualizar Tipo de Credito Metodo que
	 * atualiza a Situação Usuario
	 * 
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * 
	 * @param Tipo
	 *            de Credito
	 * @throws ControladorException
	 */

	public void atualizarTipoCredito(CreditoTipo creditoTipo,
			Usuario usuarioLogado) throws ControladorException {

		// Verifica se todos os campos obrigatorios foram preenchidos

		if ((creditoTipo.getDescricao() == null || creditoTipo.getDescricao()
				.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (creditoTipo.getDescricaoAbreviada() == null || creditoTipo
						.getDescricaoAbreviada().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (creditoTipo.getIndicadorGeracaoAutomatica() == 0)
				&& (creditoTipo.getIndicadorUso() == null || creditoTipo
						.getIndicadorUso().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (creditoTipo.getValorLimite() == null || creditoTipo
						.getValorLimite().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (creditoTipo.getLancamentoItemContabil() == null || creditoTipo
						.getLancamentoItemContabil().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Descrição foi preenchido

		if (creditoTipo.getDescricao() == null
				|| creditoTipo.getDescricao().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Descrição do Tipo de Crédito");
		}

		// Verifica se o campo Descrição foi preenchido

		if (creditoTipo.getDescricaoAbreviada() == null
				|| creditoTipo.getDescricaoAbreviada().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Descrição do Tipo de Crédito Abreviada");
		}

		// Verifica se o campo Tipo do Lançamento do Item Contábil foi
		// preenchido

		if (creditoTipo.getLancamentoItemContabil() == null
				|| creditoTipo.getLancamentoItemContabil().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Tipo do Lançamento do Item Contábil");
		}

		// Verifica se o campo Referência do Tipo de Serviço foi preenchido
		if (creditoTipo.getValorLimite() == null
				|| creditoTipo.getValorLimite().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Valor Limite do Crédito");
		}

		// Verifica se o campo ndicador de Geração Automática do Crédito foi
		// preenchido
		if (creditoTipo.getIndicadorGeracaoAutomatica() == null
				|| creditoTipo.getIndicadorGeracaoAutomatica().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Indicador de Geração Automática do Crédito");
		}

		// Verifica se o campo Indicador de Uso foi preenchido
		if (creditoTipo.getIndicadorUso() == null
				|| creditoTipo.getIndicadorUso().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Indicador de Uso");
		}

		FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
		filtroCreditoTipo.adicionarParametro(new ParametroSimples(
				FiltroCreditoTipo.ID, creditoTipo.getId()));

		Collection colecaoCreditoTipoBase = getControladorUtil().pesquisar(
				filtroCreditoTipo, CreditoTipo.class.getName());

		if (colecaoCreditoTipoBase == null || colecaoCreditoTipoBase.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		CreditoTipo creditoTipoBase = (CreditoTipo) colecaoCreditoTipoBase
				.iterator().next();

		if (creditoTipo.getUltimaAlteracao().after(
				creditoTipoBase.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_TIPO_CREDITO_ATUALIZAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_TIPO_CREDITO_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		creditoTipo.setOperacaoEfetuada(operacaoEfetuada);
		creditoTipo.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(creditoTipo);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		creditoTipo.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(creditoTipo);

	}

	/**
	 * Permite informar uma nao entrega de documentos
	 * 
	 * [UC0217] Informar Nao Entrega de Documentos
	 * 
	 * @author Thiago Tenório
	 * @date 04/04/2007
	 * 
	 */
	public Integer informarNaoEntregaDocumentos(
			Collection colecaoDocumentosNaoEntregues, Usuario usuarioLogado)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_NAO_ENTREGA_DOCUMENTOS_INFORMAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_NAO_ENTREGA_DOCUMENTOS_INFORMAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		DocumentoNaoEntregue documentoNaoEntregue = new DocumentoNaoEntregue();

		documentoNaoEntregue.setOperacaoEfetuada(operacaoEfetuada);
		documentoNaoEntregue.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(documentoNaoEntregue);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Iterator iterator = colecaoDocumentosNaoEntregues.iterator();
		Integer id = null;
		while (iterator.hasNext()) {
			id = (Integer) getControladorUtil().inserir(
					(DocumentoNaoEntregue) iterator.next());

		}

		return id;

	}

	/**
	 * 
	 * Este caso de uso permite gerar um ralatorio analitico do faturamento
	 * 
	 * [UC0xxx]Gerar Relatório Analítico do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 18/05/2007
	 * 
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @param indicadorLocalidadeInformatizada
	 * @param idLocalidades
	 * @param idSetores
	 * @param idQuadras
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosRelatorioAnaliticoFaturamento(
			int anoMesFaturamento, Integer idFaturamentoGrupo,
			int indicadorLocalidadeInformatizada, Collection idLocalidades,
			Collection idSetores, Collection idQuadras, String tipoRelatorio,
			Usuario usuarioLogado) throws ControladorException {

		Collection retorno = new ArrayList();
		try {
			Collection colecaoObjeto = repositorioFaturamento
					.pesquisarDadosRelatorioAnaliticoFaturamento(
							anoMesFaturamento, idFaturamentoGrupo,
							indicadorLocalidadeInformatizada, idLocalidades,
							idSetores, idQuadras);
			if (colecaoObjeto != null && !colecaoObjeto.isEmpty()) {
				Iterator iterator = colecaoObjeto.iterator();

				while (iterator.hasNext()) {
					RelatorioAnaliticoFaturamentoHelper relatorioAnaliticoFaturamentoHelper = new RelatorioAnaliticoFaturamentoHelper();
					Object[] objeto = (Object[]) iterator.next();
					// idImovel
					if (objeto[0] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setIdImovel((Integer) objeto[0]);
						relatorioAnaliticoFaturamentoHelper
								.setInscricao(getControladorImovel()
										.pesquisarInscricaoImovel(
												relatorioAnaliticoFaturamentoHelper
														.getIdImovel()));
					}
					// consumoAgua
					if (objeto[1] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setConsumoAgua((Integer) objeto[1]);
					}
					// consumoRateioAgua
					if (objeto[2] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setConsumoRateioAgua((Integer) objeto[2]);
					}
					// valorAgua
					if (objeto[3] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setValorAgua((BigDecimal) objeto[3]);
					}
					// consumoEsgoto
					if (objeto[4] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setConsumoEsgoto((Integer) objeto[4]);
					}
					// consumoRateioEsgoto
					if (objeto[5] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setConsumoRateioAgua((Integer) objeto[5]);
					}
					// valorEsgoto
					if (objeto[6] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setValorEsgoto((BigDecimal) objeto[6]);
					}
					// debitos
					if (objeto[7] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setDebitos((BigDecimal) objeto[7]);
					}
					// creditos
					if (objeto[8] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setValorCreditos((BigDecimal) objeto[8]);
					}
					// codigoSetor
					if (objeto[9] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setCodigoSetorComercial((Integer) objeto[9]);
					}
					// idLocalidade
					if (objeto[10] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setIdLocalidade((Integer) objeto[10]);

						relatorioAnaliticoFaturamentoHelper
								.setIdDescricaoLocalidade(Util
										.adicionarZerosEsquedaNumero(3,
												(Integer) objeto[10] + "")
										+ " - " + (String) objeto[13]);
					}
					// DigitoVerificador
					if (objeto[11] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setDigitoVerificador((Short) objeto[11]);
					}

					// creditos
					if (objeto[12] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setValorImposto((BigDecimal) objeto[12]);
					}

					// UNIDADE_NEGOCIO
					if (objeto[14] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setIdDescricaoUnidadeNegocio((Integer) objeto[14]
										+ " - " + (String) objeto[15]);
					}

					// NOME CLIENTE
					if (objeto[16] != null) {
						relatorioAnaliticoFaturamentoHelper
								.setNomeCliente((String) objeto[16]);
					} else {
						relatorioAnaliticoFaturamentoHelper.setNomeCliente("");
					}

					relatorioAnaliticoFaturamentoHelper
							.setMesAnoFaturamento(Util
									.formatarAnoMesParaMesAnoSemBarra(anoMesFaturamento));

					retorno.add(relatorioAnaliticoFaturamentoHelper);

				}

				// parte nova para o relatório ter o processamento em batch
				// cria uma instância da classe do relatório

			}
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 18/05/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Collection<EmitirContaHelper> emitir2ViaContasHistorico(
			Collection idsContaEP, boolean cobrarTaxaEmissaoConta,
			Short contaSemCodigoBarras) throws ControladorException {

		Collection<EmitirContaHelper> colecaoEmitirContaHelper = new ArrayList();

		Iterator iter = idsContaEP.iterator();

		while (iter.hasNext()) {
			Integer idContaEP = (Integer) iter.next();

			Collection colectionConta;
			try {
				colectionConta = this.repositorioFaturamento
						.pesquisarContaHistorico(idContaEP);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) colectionConta
					.iterator().next();

			SistemaParametro sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			// Linha 5
			// --------------------------------------------------------------
			// recupera endereco do imóvel
			String enderecoImovel = "";
			try {
				enderecoImovel = getControladorEndereco()
						.pesquisarEnderecoFormatado(
								emitirContaHelper.getIdImovel());
			} catch (ControladorException e1) {
				e1.printStackTrace();
			}
			emitirContaHelper.setEnderecoImovel(enderecoImovel);

			// Linha 6
			// --------------------------------------------------------------
			// instância um imovel com os dados da conta para recuperar a
			// inscrição que está no objeto imovel
			Imovel imovel = new Imovel();
			Localidade localidade = new Localidade();
			localidade.setId(emitirContaHelper.getIdLocalidade());
			imovel.setLocalidade(localidade);
			SetorComercial setorComercial = new SetorComercial();
			setorComercial.setCodigo(emitirContaHelper
					.getCodigoSetorComercialConta());
			imovel.setSetorComercial(setorComercial);
			Quadra quadra = new Quadra();
			quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
			imovel.setQuadra(quadra);
			imovel.setLote(emitirContaHelper.getLoteConta());
			imovel.setSubLote(emitirContaHelper.getSubLoteConta());
			// Inscrição do imóvel
			emitirContaHelper
					.setInscricaoImovel(imovel.getInscricaoFormatada());

			// Linha 7
			// --------------------------------------------------------------
			String idClienteResponsavel = "";
			String enderecoClienteResponsavel = "";
			Integer idImovelContaEnvio = emitirContaHelper
					.getIdImovelContaEnvio();
			// caso a coleção de contas seja de entrega para o cliente
			// responsável
			if (idImovelContaEnvio != null
					&& (idImovelContaEnvio
							.equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL) || idImovelContaEnvio
							.equals(ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL))) {

				Integer idClienteResponsavelInteger = null;
				idClienteResponsavelInteger = pesquisarIdClienteResponsavelConta(
						emitirContaHelper.getIdConta(), true);

				if (idClienteResponsavelInteger != null
						&& !idClienteResponsavelInteger.equals("")) {
					idClienteResponsavel = idClienteResponsavelInteger
							.toString();
					// [UC0085]Obter Endereco
					enderecoClienteResponsavel = getControladorEndereco()
							.pesquisarEnderecoClienteAbreviado(
									idClienteResponsavelInteger);
				}

			}

			/**
			 * Emitir faturas agrupadas sem código de barras
			 * 
			 * @author Wellington Rocha
			 * @date 25/01/2012
			 */
			if (idImovelContaEnvio != null
					&& idImovelContaEnvio
							.equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL_FINAL_GRUPO)) {
				emitirContaHelper.setClienteComFaturaAgrupada(new Short("1"));
			} else {
				emitirContaHelper.setClienteComFaturaAgrupada(new Short("2"));
			}
			emitirContaHelper.setIdClienteResponsavel(idClienteResponsavel);
			emitirContaHelper
					.setEnderecoClienteResponsavel(enderecoClienteResponsavel);

			// Linha 8
			// --------------------------------------------------------------

			// [SB0002] - Determinar tipo de ligação e tipo de Medição
			Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
			Integer tipoLigacao = parmSituacao[0];
			Integer tipoMedicao = parmSituacao[1];

			// Linha 9
			// --------------------------------------------------------------
			// cria uma stringBuilder para recuperar o resultado do [SB0003]
			// o tamanho da string que vem como resultado é de 20 posições
			StringBuilder obterDadosConsumoMedicaoAnterior = null;

			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 1
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 1, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes1(obterDadosConsumoMedicaoAnterior
							.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 4
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 4, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes4(obterDadosConsumoMedicaoAnterior
							.toString());

			// Linha 10
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 2
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 2, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes2(obterDadosConsumoMedicaoAnterior
							.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 5
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 5, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes5(obterDadosConsumoMedicaoAnterior
							.toString());
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros da medição historico do
			// [SB0004] - Obter Dados da Medição da Conta
			Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(
					emitirContaHelper, tipoMedicao);
			// Leitura Anterior
			String leituraAnterior = "";
			// Leitura Atual
			String leituraAtual = "";
			// Data Leitura Anterior
			String dataLeituraAnterior = "";
			// Leitura Anterior
			String dataLeituraAtual = "";
			// Leitura Situação Atual
			// String leituraSituacaoAtual = "";
			// Leitura Anormalidade Faturamento
			String leituraAnormalidadeFaturamento = "";
			if (parmsMedicaoHistorico != null) {

				if (parmsMedicaoHistorico[0] != null) {
					leituraAnterior = "" + (Integer) parmsMedicaoHistorico[0];
				}

				if (parmsMedicaoHistorico[1] != null) {
					leituraAtual = "" + (Integer) parmsMedicaoHistorico[1];
				}

				if (parmsMedicaoHistorico[3] != null) {
					dataLeituraAnterior = Util
							.formatarData((Date) parmsMedicaoHistorico[3]);
				}

				if (parmsMedicaoHistorico[2] != null) {
					dataLeituraAtual = Util
							.formatarData((Date) parmsMedicaoHistorico[2]);
				}

				if (parmsMedicaoHistorico[4] != null) {
					// leituraSituacaoAtual = ""
					// + (Integer) parmsMedicaoHistorico[4];
				}

				if (parmsMedicaoHistorico[5] != null) {
					leituraAnormalidadeFaturamento = ""
							+ (Integer) parmsMedicaoHistorico[5];
				}
			}
			emitirContaHelper.setDataLeituraAnterior(dataLeituraAnterior);
			emitirContaHelper.setDataLeituraAtual(dataLeituraAtual);
			String diasConsumo = "";
			if (!dataLeituraAnterior.equals("") && !dataLeituraAtual.equals("")) {
				// calcula a quantidade de dias de consumo que é a
				// quantidade de dias
				// entre a data de leitura
				// anterior(parmsMedicaoHistorico[2]) e a data de leitura
				// atual(parmsMedicaoHistorico[3])
				diasConsumo = ""
						+ Util.obterQuantidadeDiasEntreDuasDatas(
								(Date) parmsMedicaoHistorico[3],
								(Date) parmsMedicaoHistorico[2]);
			}
			// recupera os parametros de consumo faturamento e consumo médio
			// diário
			// [SB0005] - Obter Consumo Faturado e Consumo Médio Diário
			String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(
					emitirContaHelper, tipoMedicao, diasConsumo);
			String consumoFaturamento = parmsConsumo[0];
			emitirContaHelper.setConsumoFaturamento(consumoFaturamento);

			String consumoMedioDiario = parmsConsumo[1];
			emitirContaHelper.setConsumoMedioDiario(consumoMedioDiario);
			// Fim Chamar Sub-Fluxo
			// Leitura Anterior
			leituraAnterior = Util.completaString(leituraAnterior, 7);
			emitirContaHelper.setLeituraAnterior(leituraAnterior);
			// Leitura Atual
			leituraAtual = Util.completaString(leituraAtual, 7);
			emitirContaHelper.setLeituraAtual(leituraAtual);
			// Dias de consumo
			diasConsumo = Util.completaString(diasConsumo, 2);
			emitirContaHelper.setDiasConsumo(diasConsumo);

			// Linha 11
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 3
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 3, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes3(obterDadosConsumoMedicaoAnterior
							.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 6
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
					emitirContaHelper, 6, tipoLigacao, tipoMedicao);
			emitirContaHelper
					.setDadosConsumoMes6(obterDadosConsumoMedicaoAnterior
							.toString());

			// Linha 12
			// --------------------------------------------------------------
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros do consumo historico da conta
			// [SB0006] - Obter Dados de Consumo da Conta
			Object[] parmsConsumoHistorico = null;
			String descricaoAbreviadaTipoConsumo = "";
			String descricaoTipoConsumo = "";
			String consumoMedio = "";
			String descricaoAbreviadaAnormalidadeConsumo = "";
			String descricaoAnormalidadeConsumo = "";
			String consumoRateio = "";
			// caso o tipo de ligacao for diferente de nulo
			if (tipoLigacao != null) {
				try {
					parmsConsumoHistorico = getControladorMicromedicao()
							.obterDadosConsumoConta(
									emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia(),
									tipoLigacao);
				} catch (ControladorException e) {
					e.printStackTrace();
				}

				if (parmsConsumoHistorico != null) {
					// descrição abreviada tipo de consumo
					if (parmsConsumoHistorico[0] != null) {
						descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
					}
					// descrição tipo de consumo
					if (parmsConsumoHistorico[1] != null) {
						descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
					}
					// Consumo médio
					if (parmsConsumoHistorico[2] != null) {
						consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
					}
					// descrição abreviada anormalidade de consumo
					if (parmsConsumoHistorico[3] != null) {
						descricaoAbreviadaAnormalidadeConsumo = (String) parmsConsumoHistorico[3];
					}
					// descrição anormalidade de consumo
					if (parmsConsumoHistorico[4] != null) {
						descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
					}
					// Consumo médio
					if (parmsConsumoHistorico[5] != null) {
						consumoRateio = "" + (Integer) parmsConsumoHistorico[5];
					}
				}
			}

			// Consumo de rateio
			// transforma o consumoRateio para um bigDecimal
			BigDecimal consumoRateioBigDecimal = null;
			if (consumoRateio != null && !consumoRateio.equals("")) {
				consumoRateioBigDecimal = Util
						.formatarMoedaRealparaBigDecimal(consumoRateio);
			}

			emitirContaHelper.setDescricaoTipoConsumo(descricaoTipoConsumo);
			emitirContaHelper
					.setDescricaoAnormalidadeConsumo(descricaoAnormalidadeConsumo);

			// Fim Chamar Sub-Fluxo

			// Linha 13
			// --------------------------------------------------------------

			// Inicio Chamar Sub-Fluxo
			// soma a quantidades de economias da tabela contaCategoria
			// [SB0007] - Obter Dados da Medição da Conta
			Short quantidadeEconomiaConta = 0;
			quantidadeEconomiaConta = obterQuantidadeEconomiasConta(
					emitirContaHelper.getIdConta(), true);
			emitirContaHelper.setQuantidadeEconomiaConta(""
					+ quantidadeEconomiaConta);
			// Fim Chamar Sub-Fluxo

			// Consumo por Economia
			// transforma o consumoFaturamento para um bigDecimal
			BigDecimal consumoFaturadoBigDecimal = null;
			if (consumoFaturamento != null && !consumoFaturamento.equals("")) {
				consumoFaturadoBigDecimal = Util
						.formatarMoedaRealparaBigDecimal(consumoFaturamento);

			}
			// transforma a quantidade de economias da conta para um
			// bigDecimal
			BigDecimal qtdEconomiasBigDecimal = null;
			if (quantidadeEconomiaConta != null
					&& !quantidadeEconomiaConta.equals("")) {
				qtdEconomiasBigDecimal = Util
						.formatarMoedaRealparaBigDecimal(""
								+ quantidadeEconomiaConta);
			}

			String consumoEconomia = "";
			if (consumoFaturadoBigDecimal != null
					&& qtdEconomiasBigDecimal != null) {
				if (consumoRateioBigDecimal == null) {
					BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal
							.divide(qtdEconomiasBigDecimal, 2, RoundingMode.UP);
					consumoEconomia = Util
							.formatarMoedaReal(consumoEconomiaBigDecimal);
					emitirContaHelper.setConsumoEconomia(consumoEconomia
							.substring(0, (consumoEconomia.length() - 3)));
				} else {
					BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal
							.subtract(consumoRateioBigDecimal);
					consumoEconomiaBigDecimal = consumoEconomiaBigDecimal
							.divide(qtdEconomiasBigDecimal, 2, RoundingMode.UP);
					consumoEconomia = Util
							.formatarMoedaReal(consumoEconomiaBigDecimal);
					emitirContaHelper.setConsumoEconomia(consumoEconomia
							.substring(0, (consumoEconomia.length() - 3)));
				}
			}

			// Inicio Chamar Sub-Fluxo
			// concatena os campos dos sub-fluxos anteriores
			// [SB0008] - Obter Dados da Medição da Conta
			StringBuilder codigoAuxiliar = new StringBuilder();
			// leitura situação atual
			// tipo de consumo
			codigoAuxiliar.append(Util.completaString(
					descricaoAbreviadaTipoConsumo, 1));
			// tipo de contrato
			codigoAuxiliar.append(Util.completaString("", 1));
			// anormalidade de leitura
			codigoAuxiliar.append(Util.completaString(
					leituraAnormalidadeFaturamento, 2));
			// anormalidade de consumo
			codigoAuxiliar.append(Util.completaString(
					descricaoAbreviadaAnormalidadeConsumo, 2));

			// perfil do imóvel
			if (emitirContaHelper.getIdImovelPerfil() != null) {
				codigoAuxiliar.append(Util.completaString(""
						+ emitirContaHelper.getIdImovelPerfil(), 1));
			} else {
				codigoAuxiliar.append(Util.completaString("", 1));
			}
			// dias do consumo
			codigoAuxiliar.append(Util.completaString(diasConsumo, 2));
			// Consumo medio do imóvel
			codigoAuxiliar.append(Util.completaString(consumoMedio, 6));
			// Fim Chamar Sub-Fluxo
			emitirContaHelper
					.setCodigoAuxiliarString(codigoAuxiliar.toString());

			// chama o [SB0009] - Obter Mensagem de Rateio de Consumo Fixo de
			// Esgoto
			StringBuilder mesagemConsumo = obterMensagemRateioConsumo(
					emitirContaHelper, consumoRateio, parmsMedicaoHistorico,
					tipoMedicao);
			// mensagem de rateio de consumo ou consumo fixo de esgoto
			emitirContaHelper.setMensagemConsumoString(mesagemConsumo
					.toString());

			// Linha 16
			// --------------------------------------------------------------
			// chama o [SB0010] - Gerar Linhas da Descrição dos Serviços e
			// Tarifas

			Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = gerarLinhasDescricaoServicoTarifasRelatorio(
					emitirContaHelper, consumoRateio, parmsMedicaoHistorico,
					tipoMedicao, true);
			emitirContaHelper
					.setColecaoContaLinhasDescricaoServicosTarifasTotalHelper(colecaoContaLinhasDescricaoServicosTarifasTotalHelper);

			// Linha 17
			// --------------------------------------------------------------
			// cria um objeto conta para calcular o valor da conta
			Conta conta = new Conta();
			conta.setValorAgua(emitirContaHelper.getValorAgua());
			conta.setValorEsgoto(emitirContaHelper.getValorEsgoto());
			conta.setValorCreditos(emitirContaHelper.getValorCreditos());
			conta.setDebitos(emitirContaHelper.getDebitos());
			conta.setValorImposto(emitirContaHelper.getValorImpostos());
			BigDecimal valorConta = conta.getValorTotalContaBigDecimal();

			emitirContaHelper.setValorContaString(Util
					.formatarMoedaReal(valorConta));
			emitirContaHelper.setValorConta(valorConta);

			PagamentoHistorico pagamento = getControladorArrecadacao()
					.pesquisarPagamentoDeContaEmHistorico(idContaEP);
			if (pagamento != null
					&& pagamento.getValorPagamento().compareTo(valorConta) >= 0) {
				emitirContaHelper.setContaPaga("1");
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
				emitirContaHelper.setDataPagamentoConta(sdf.format(pagamento
						.getDataPagamento()));
			} else {
				emitirContaHelper.setContaPaga("2");
				emitirContaHelper.setDataPagamentoConta("");
			}

			if (emitirContaHelper.getContaPaga().equals("1")
					|| valorConta.compareTo(new BigDecimal("0.00")) == 0
					|| emitirContaHelper.getClienteComFaturaAgrupada().equals(
							new Short("1"))) {
				emitirContaHelper.setContaSemCodigoBarras("1");
			} else {
				emitirContaHelper.setContaSemCodigoBarras("2");
			}

			// chama o [SB0016] - Obter Mensagem da Conta em 3 Partes
			String[] parmsPartesConta = obterMensagemConta3Partes(
					emitirContaHelper, sistemaParametro);

			// Linha 18
			// --------------------------------------------------------------
			emitirContaHelper.setPrimeiraParte(parmsPartesConta[0]);

			// Linha 19
			// --------------------------------------------------------------
			emitirContaHelper.setSegundaParte(parmsPartesConta[1]);

			// Linha 20
			// --------------------------------------------------------------
			emitirContaHelper.setTerceiraParte(parmsPartesConta[2]);

			// Linha 21
			// --------------------------------------------------------------
			int anoMesReferenciaSubtraido = Util.subtrairMesDoAnoMes(
					emitirContaHelper.getAmReferencia(), 1);
			emitirContaHelper.setMesAnoFormatado(Util
					.formatarAnoMesParaMesAno(anoMesReferenciaSubtraido));

			// Linha 22
			// --------------------------------------------------------------
			Object[] parmsQualidadeAgua = null;
			parmsQualidadeAgua = pesquisarParmsQualidadeAgua(emitirContaHelper);

			// numero indice turbidez da qualidade agua
			String numeroIndiceTurbidez = "";
			// numero cloro residual da qualidade agua
			String numeroCloroResidual = "";
			if (parmsQualidadeAgua != null) {
				if (parmsQualidadeAgua[0] != null) {
					numeroIndiceTurbidez = Util
							.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]);
				}

				if (parmsQualidadeAgua[1] != null) {
					numeroCloroResidual = Util
							.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]);
				}
			}
			emitirContaHelper.setNumeroIndiceTurbidez(numeroIndiceTurbidez);
			emitirContaHelper.setNumeroCloroResidual(numeroCloroResidual);

			// Linha28
			Date dataValidade = obterDataValidade2ViaConta(emitirContaHelper);
			emitirContaHelper.setDataValidade(Util.formatarData(dataValidade));

			// Se valor da conta maior que o valor limite
			// emite uma Ficha de Compensação(Boleto bancario)
			// if (valorConta
			// .compareTo(EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO) ==
			// 1) {
			// StringBuilder nossoNumero = obterNossoNumeroFichaCompensacao(
			// "1", emitirContaHelper.getIdConta().toString());
			// emitirContaHelper.setNossoNumero(nossoNumero.toString());
			//
			// }

			Integer digitoVerificadorConta = new Integer(""
					+ emitirContaHelper.getDigitoVerificadorConta());
			// formata ano mes para mes ano
			String anoMes = "" + emitirContaHelper.getAmReferencia();
			String mesAno = anoMes.substring(4, 6) + anoMes.substring(0, 4);

			String representacaoNumericaCodBarra = "";

			if (emitirContaHelper.getContaSemCodigoBarras().equals("2")) {

				representacaoNumericaCodBarra = this
						.getControladorArrecadacao()
						.obterRepresentacaoNumericaCodigoBarra(3, valorConta,
								emitirContaHelper.getIdLocalidade(),
								emitirContaHelper.getIdImovel(), mesAno,
								digitoVerificadorConta, null, null, null, null,
								null, null, null);

				// Linha 24
				// Formata a representação númerica do código de barras
				String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra
						.substring(0, 11)
						+ "-"
						+ representacaoNumericaCodBarra.substring(11, 12)
						+ " "
						+ representacaoNumericaCodBarra.substring(12, 23)
						+ "-"
						+ representacaoNumericaCodBarra.substring(23, 24)
						+ " "
						+ representacaoNumericaCodBarra.substring(24, 35)
						+ "-"
						+ representacaoNumericaCodBarra.substring(35, 36)
						+ " "
						+ representacaoNumericaCodBarra.substring(36, 47)
						+ "-"
						+ representacaoNumericaCodBarra.substring(47, 48);
				emitirContaHelper
						.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

				// Linha 25
				String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra
						.substring(0, 11)
						+ representacaoNumericaCodBarra.substring(12, 23)
						+ representacaoNumericaCodBarra.substring(24, 35)
						+ representacaoNumericaCodBarra.substring(36, 47);
				emitirContaHelper
						.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);

			}

			/** Alterações para atendender mudanças na segunda via da conta */
			String leituraAnteriorInformada = "";
			String leituraAtualInformada = "";
			String dataLeituraAnteriorInformada = "";
			String dataLeituraAtualInformada = "";

			MedicaoHistorico medicaoHistoricoAgua = getControladorMicromedicao()
					.pesquisarMedicaoHistoricoTipoAguaLeituraAnormalidade(
							emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia());
			MedicaoHistorico medicaoHistoricoAguaMesAnterior = getControladorMicromedicao()
					.pesquisarMedicaoHistoricoTipoAguaLeituraAnormalidade(
							emitirContaHelper.getIdImovel(),
							Util.subtrairMesDoAnoMes(
									emitirContaHelper.getAmReferencia(), 1));
			MedicaoHistorico medicaoHistoricoPocoMesAnterior = getControladorMicromedicao()
					.pesquisarMedicaoHistoricoTipoPocoLeituraAnormalidade(
							emitirContaHelper.getIdImovel(),
							Util.subtrairMesDoAnoMes(
									emitirContaHelper.getAmReferencia(), 1));
			MedicaoHistorico medicaoHistoricoPoco = getControladorMicromedicao()
					.pesquisarMedicaoHistoricoTipoPocoLeituraAnormalidade(
							emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia());

			if (medicaoHistoricoAgua != null) {

				if (medicaoHistoricoAgua.getLeituraAnteriorInformada() != null) {
					leituraAnteriorInformada = medicaoHistoricoAgua
							.getLeituraAnteriorInformada() + "";
				}
				if (medicaoHistoricoAgua.getLeituraAtualInformada() != null) {
					leituraAtualInformada = medicaoHistoricoAgua
							.getLeituraAtualInformada() + "";
				}
				if (medicaoHistoricoAgua.getDataLeituraAtualInformada() != null) {
					dataLeituraAtualInformada = Util
							.formatarData(medicaoHistoricoAgua
									.getDataLeituraAtualInformada());
				}
				if (medicaoHistoricoAguaMesAnterior != null) {
					if (medicaoHistoricoAguaMesAnterior
							.getDataLeituraAtualInformada() != null) {
						dataLeituraAnteriorInformada = Util
								.formatarData(medicaoHistoricoAguaMesAnterior
										.getDataLeituraAtualInformada());
					}
				}
			} else if (medicaoHistoricoPoco != null) {

				if (medicaoHistoricoPoco.getLeituraAnteriorInformada() != null) {
					leituraAnteriorInformada = medicaoHistoricoPoco
							.getLeituraAnteriorInformada() + "";
				}
				if (medicaoHistoricoPoco.getLeituraAtualInformada() != null) {
					leituraAtualInformada = medicaoHistoricoPoco
							.getLeituraAtualInformada() + "";
				}
				if (medicaoHistoricoPoco.getDataLeituraAtualInformada() != null) {
					dataLeituraAtualInformada = Util
							.formatarData(medicaoHistoricoPoco
									.getDataLeituraAtualInformada());
				}
				if (medicaoHistoricoPocoMesAnterior
						.getDataLeituraAtualInformada() != null) {
					dataLeituraAnteriorInformada = Util
							.formatarData(medicaoHistoricoPocoMesAnterior
									.getDataLeituraAtualInformada());
				}
			}
			emitirContaHelper
					.setLeituraAnteriorInformada(leituraAnteriorInformada);
			emitirContaHelper.setLeituraAtualInformada(leituraAtualInformada);
			emitirContaHelper
					.setDataLeituraAnteriorInformada(dataLeituraAnteriorInformada);
			emitirContaHelper
					.setDataLeituraAtualInformada(dataLeituraAtualInformada);

			if (cobrarTaxaEmissaoConta) {
				this.gerarDebitoACobrarTaxaEmissaoConta(
						emitirContaHelper.getIdImovel(),
						emitirContaHelper.getAmReferencia());
			}

			Imovel imovelQuadraFace = getControladorImovel().pesquisarImovel(
					emitirContaHelper.getIdImovel());
			String[] qualidadeAgua = this
					.obterDadosQualidadeAguaCosanpa(emitirContaHelper,
							imovelQuadraFace.getQuadraFace().getId());

			// Padrão
			emitirContaHelper.setPadraoCor(qualidadeAgua[0]);
			emitirContaHelper.setPadraoTurbidez(qualidadeAgua[1]);
			emitirContaHelper.setPadraoCloro(qualidadeAgua[3]);
			emitirContaHelper.setPadraoFluor(qualidadeAgua[2]);
			emitirContaHelper.setPadraoColiformesTotais(qualidadeAgua[4]);
			emitirContaHelper.setPadraoColiformesfecais(qualidadeAgua[5]);

			// Exigido
			emitirContaHelper.setValorExigidoCor(qualidadeAgua[6]);
			emitirContaHelper.setValorExigidoTurbidez(qualidadeAgua[7]);
			emitirContaHelper.setValorExigidoCloro(qualidadeAgua[9]);
			emitirContaHelper.setValorExigidoFluor(qualidadeAgua[8]);
			emitirContaHelper
					.setValorExigidoColiformesTotais(qualidadeAgua[10]);
			emitirContaHelper
					.setValorExigidoColiformesTermotolerantes(qualidadeAgua[11]);

			// Analisado
			emitirContaHelper.setValorMedioCor(qualidadeAgua[12]);
			emitirContaHelper.setValorMedioTurbidez(qualidadeAgua[13]);
			emitirContaHelper.setValorMedioCloro(qualidadeAgua[15]);
			emitirContaHelper.setValorMedioFluor(qualidadeAgua[14]);
			emitirContaHelper.setValorMedioColiformesTotais(qualidadeAgua[16]);
			emitirContaHelper.setValorMedioColiformesfecais(qualidadeAgua[17]);

			// Conforme
			emitirContaHelper.setValorConformeCor(qualidadeAgua[18]);
			emitirContaHelper.setValorConformeTurbidez(qualidadeAgua[19]);
			emitirContaHelper.setValorConformeCloro(qualidadeAgua[21]);
			emitirContaHelper.setValorConformeFluor(qualidadeAgua[20]);
			emitirContaHelper
					.setValorConformeColiformesTotais(qualidadeAgua[22]);
			emitirContaHelper
					.setValorConformeColiformesTermotolerantes(qualidadeAgua[23]);

			colecaoEmitirContaHelper.add(emitirContaHelper);

		}

		return colecaoEmitirContaHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * 
	 * [SB00011] Gerar Linhas da Tarifa de Água
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasTarifaAguaRelatorioContaHistorico(
			EmitirContaHelper emitirContaHelper, String consumoRateio,
			Object[] parmsMedicaoHistorico, Integer tipoMedicao,
			Collection colecaoLinhasDescricaoServicosTarifasTotal)
			throws ControladorException {

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;

		String descricaoServicosTarifas1 = "";

		// -- Linha 1 --//
		descricaoServicosTarifas1 = "AGUA";
		contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
		contaLinhasDescricaoServicosTarifasTotalHelper
				.setDescricaoServicosTarifas(descricaoServicosTarifas1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper
				.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		Collection colecaoContaCategoriaComFaixas = null;
		try {
			colecaoContaCategoriaComFaixas = repositorioFaturamento
					.pesquisarContaCategoriaHistorico(emitirContaHelper
							.getIdConta());
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (colecaoContaCategoriaComFaixas != null
				&& !colecaoContaCategoriaComFaixas.isEmpty()) {
			Iterator iteratorContaCategoriaComFaixas = colecaoContaCategoriaComFaixas
					.iterator();
			while (iteratorContaCategoriaComFaixas.hasNext()) {
				ContaCategoriaHistorico contaCategoria = (ContaCategoriaHistorico) iteratorContaCategoriaComFaixas
						.next();

				String descricaoServicosTarifas2 = "";

				// -- Linha 2 --//
				descricaoServicosTarifas2 = " ";
				// descricao da categoria
				descricaoServicosTarifas2 = descricaoServicosTarifas2
						+ Util.completaString(contaCategoria.getComp_id()
								.getCategoria().getDescricao(), 13);
				// quantidade de economias
				descricaoServicosTarifas2 = descricaoServicosTarifas2
						+ Util.adicionarZerosEsquedaNumero(3, ""
								+ contaCategoria.getQuantidadeEconomia());

				if (contaCategoria.getQuantidadeEconomia() == 1) {
					descricaoServicosTarifas2 = descricaoServicosTarifas2
							+ "  UNIDADE ";
				} else {
					descricaoServicosTarifas2 = descricaoServicosTarifas2
							+ "  UNIDADES ";
				}

				contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
				contaLinhasDescricaoServicosTarifasTotalHelper
						.setDescricaoServicosTarifas(descricaoServicosTarifas2);
				contaLinhasDescricaoServicosTarifasTotalHelper
						.setConsumoFaixa("");
				contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
				colecaoContaLinhasDescricaoServicosTarifasTotalHelper
						.add(contaLinhasDescricaoServicosTarifasTotalHelper);

				// -- Linha 3 --//
				contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
				String descricaoServicosTarifas3 = "";
				String consumoFaixa3 = "";
				String valor3 = "";
				if (parmsMedicaoHistorico == null) {
					descricaoServicosTarifas3 = " TARIFA MÍNIMA";

					// Valor da tarifa mínima de água para a categoria por
					// economia
					BigDecimal qtdEconomia = Util
							.formatarMoedaRealparaBigDecimal(""
									+ contaCategoria.getQuantidadeEconomia());
					String valorTarifaMinima = "";
					if (contaCategoria.getValorTarifaMinimaAgua() != null
							&& qtdEconomia != null) {
						BigDecimal valorTarifaMinimaBigDecimal = contaCategoria
								.getValorTarifaMinimaAgua().divide(qtdEconomia,
										2, RoundingMode.UP);
						valorTarifaMinima = Util
								.formatarMoedaReal(valorTarifaMinimaBigDecimal);
					}

					descricaoServicosTarifas3 = descricaoServicosTarifas3
							+ Util.completaStringComEspacoAEsquerda(
									valorTarifaMinima, 6);
					descricaoServicosTarifas3 = descricaoServicosTarifas3
							+ " POR UNIDADE";

					consumoFaixa3 = "MINIMO";
					consumoFaixa3 = consumoFaixa3 + Util.completaString("", 11);

					// valor da água para categoria
					String valorAgua = Util.formatarMoedaReal(contaCategoria
							.getValorAgua());
					valor3 = valorAgua;

					contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
					contaLinhasDescricaoServicosTarifasTotalHelper
							.setDescricaoServicosTarifas(descricaoServicosTarifas3);
					contaLinhasDescricaoServicosTarifasTotalHelper
							.setConsumoFaixa(consumoFaixa3);
					contaLinhasDescricaoServicosTarifasTotalHelper
							.setValor(valor3);
					colecaoContaLinhasDescricaoServicosTarifasTotalHelper
							.add(contaLinhasDescricaoServicosTarifasTotalHelper);

				} else {

					// recupera a coleção de conta categoria consumo faixa
					Collection colecaoContaCategoriaConsumoFaixa = null;
					try {
						colecaoContaCategoriaConsumoFaixa = repositorioFaturamento
								.pesquisarContaCategoriaHistoricoFaixas(
										emitirContaHelper.getIdConta(),
										contaCategoria.getComp_id()
												.getCategoria().getId());
					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}

					// 2.3.1 caso existam faixas de consumo para conta/categoria
					if (colecaoContaCategoriaConsumoFaixa != null
							&& !colecaoContaCategoriaConsumoFaixa.isEmpty()) {

						// Consumo mínimo de água para a categoria por economia
						BigDecimal qtdEconomia = Util
								.formatarMoedaRealparaBigDecimal(""
										+ contaCategoria
												.getQuantidadeEconomia());

						Integer idTipoCalculo = null;
						try {
							idTipoCalculo = repositorioFaturamento
									.pesquisarTipoCalculoContaHistorico(emitirContaHelper
											.getIdConta());
						} catch (ErroRepositorioException e) {
							e.printStackTrace();
						}

						if (idTipoCalculo == null
								|| !idTipoCalculo
										.equals(TarifaTipoCalculo.CALCULO_DIRETO_NA_FAIXA)) {

							descricaoServicosTarifas3 = " ATE ";

							BigDecimal consumoMinimoAgua = null;
							if (contaCategoria.getConsumoMinimoAgua() != null) {
								consumoMinimoAgua = Util
										.formatarMoedaRealparaBigDecimal(""
												+ contaCategoria
														.getConsumoMinimoAgua());
							}
							BigDecimal consumoMinimaBigDecimal = new BigDecimal(
									"0.00");
							if (consumoMinimoAgua != null
									&& qtdEconomia != null) {
								consumoMinimaBigDecimal = consumoMinimoAgua
										.divide(qtdEconomia, 2, RoundingMode.UP);
							}
							String consumoMinima = ""
									+ consumoMinimaBigDecimal.intValue();

							descricaoServicosTarifas3 = descricaoServicosTarifas3
									+ Util.completaStringComEspacoAEsquerda(
											consumoMinima, 2);

							descricaoServicosTarifas3 = descricaoServicosTarifas3
									+ " M3" + Util.completaString("", 7);
							descricaoServicosTarifas3 = descricaoServicosTarifas3
									+ "- R$";

							// valor da tarifa minima de agua para a categoria
							// por
							// economia
							BigDecimal valorTarifaMinimaBigDecimal = null;
							if (contaCategoria.getValorTarifaMinimaAgua() != null
									&& qtdEconomia != null) {
								valorTarifaMinimaBigDecimal = contaCategoria
										.getValorTarifaMinimaAgua()
										.divide(qtdEconomia, 2, RoundingMode.UP);
							}

							String valorTarifaMinima = Util
									.completaStringComEspacoAEsquerda(
											""
													+ Util.formatarMoedaReal(valorTarifaMinimaBigDecimal),
											6);

							descricaoServicosTarifas3 = descricaoServicosTarifas3
									+ valorTarifaMinima + " (POR UNIDADE)";

							// Consumo mínimo de água para a categoria
							if (contaCategoria.getConsumoMinimoAgua() != null
									&& !contaCategoria.getConsumoMinimoAgua()
											.equals("")) {
								consumoFaixa3 = Util
										.completaStringComEspacoAEsquerda(
												""
														+ contaCategoria
																.getConsumoMinimoAgua(),
												4);
							} else {
								consumoFaixa3 = Util
										.completaStringComEspacoAEsquerda("", 4);
							}
							consumoFaixa3 = consumoFaixa3 + " M3";

							// valor da tarifa mínima de agua para categoria
							String valorAguaCategoria = "";
							if (contaCategoria.getValorTarifaMinimaAgua() != null) {
								valorAguaCategoria = Util
										.formatarMoedaReal(contaCategoria
												.getValorTarifaMinimaAgua());
							}

							valor3 = valorAguaCategoria;

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setDescricaoServicosTarifas(descricaoServicosTarifas3);
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setConsumoFaixa(consumoFaixa3.trim());
							contaLinhasDescricaoServicosTarifasTotalHelper
									.setValor(valor3);
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper
									.add(contaLinhasDescricaoServicosTarifasTotalHelper);
						}

						Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa
								.iterator();
						while (iteratorContaCategoriaConsumoFaixa.hasNext()) {
							ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixaHistorico) iteratorContaCategoriaConsumoFaixa
									.next();

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							String descricaoServicosTarifas4 = "";
							String consumoFaixa4 = "";
							String valor4 = "";

							// -- Linha 4 --//
							descricaoServicosTarifas4 = " ";

							// caso a faixa seja a ultima da tarifa de consumo
							if (contaCategoriaConsumoFaixa.getConsumoFaixaFim()
									.equals(999999)) {
								// Consumo inicial da faixa menos 1 m3
								String consumoInicialFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaInicio() - 1);

								// valor da tarifa na faixa
								String valorTarifaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorTarifaFaixa());

								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ "ACIMA DE";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ Util.completaStringComEspacoAEsquerda(
												consumoInicialFaixa, 3);
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ " M3  - R$";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ Util.completaStringComEspacoAEsquerda(
												valorTarifaFaixa, 6);
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ " POR M3";

								// consumo da agua na faixa

								// consumoFaixa4 = Util
								// .completaStringComEspacoAEsquerda(""
								// + contaCategoriaConsumoFaixa
								// .getConsumoAgua(), 6)
								consumoFaixa4 = Util
										.completaStringComEspacoAEsquerda(
												""
														+ contaCategoriaConsumoFaixa
																.getConsumoAgua()
														* qtdEconomia
																.intValue(), 6)
										+ " M3";

								// valor da agua na faixa
								BigDecimal valorAguaFaixa = contaCategoriaConsumoFaixa
										.getValorAgua().multiply(qtdEconomia)
										.setScale(Parcelamento.CASAS_DECIMAIS);

								valor4 = ""
										+ Util.formatarMoedaReal(valorAguaFaixa);

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setDescricaoServicosTarifas(descricaoServicosTarifas4);
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setConsumoFaixa(consumoFaixa4.trim());
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setValor(valor4);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper
										.add(contaLinhasDescricaoServicosTarifasTotalHelper);

							} else {
								// Consumo inicial da faixa
								String consumoInicialFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaInicio());
								// consumo final da faixa
								String consumoFinalFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaFim());
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorTarifaFaixa());

								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ Util.completaStringComEspacoAEsquerda(
												consumoInicialFaixa, 2)
										+ " M3 A";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ Util.completaStringComEspacoAEsquerda(
												consumoFinalFaixa, 3) + " M3";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ "   - R$";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
										+ Util.completaStringComEspacoAEsquerda(
												valorTarifaFaixa, 6)
										+ " POR M3";

								// consumo de Agua na faixa
								// consumoFaixa4 = Util
								// .completaStringComEspacoAEsquerda(""
								// + contaCategoriaConsumoFaixa
								// .getConsumoAgua(), 6)
								consumoFaixa4 = Util
										.completaStringComEspacoAEsquerda(
												""
														+ contaCategoriaConsumoFaixa
																.getConsumoAgua()
														* qtdEconomia
																.intValue(), 6)
										+ " M3";

								// valor da agua na faixa

								BigDecimal valorAguaFaixa = contaCategoriaConsumoFaixa
										.getValorAgua().multiply(qtdEconomia)
										.setScale(Parcelamento.CASAS_DECIMAIS);

								valor4 = ""
										+ Util.formatarMoedaReal(valorAguaFaixa);

								// String valorAguaFaixa = Util
								// .formatarMoedaReal(contaCategoriaConsumoFaixa
								// .getValorAgua());
								//
								// valor4 = valorAguaFaixa;

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setDescricaoServicosTarifas(descricaoServicosTarifas4);
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setConsumoFaixa(consumoFaixa4.trim());
								contaLinhasDescricaoServicosTarifasTotalHelper
										.setValor(valor4);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper
										.add(contaLinhasDescricaoServicosTarifasTotalHelper);
							}
						}

					} else {
						// 2.3.2.

						descricaoServicosTarifas3 = " CONSUMO DE ÁGUA";
						consumoFaixa3 = Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoAgua(), 6) + " M3";
						BigDecimal valorRateioAgua = emitirContaHelper.getValorRateioAgua();
						valor3 = Util.formatarMoedaReal(contaCategoria.getValorAgua().subtract(valorRateioAgua));

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas3);
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa3.trim());
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor3);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}

				}
			}
		}

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Collection<EmitirHistogramaAguaHelper> pesquisarEmitirHistogramaAgua(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		int opcaoTotalizacao = filtro.getOpcaoTotalizacao();

		FiltrarEmitirHistogramaAguaHelper filtroClone = new FiltrarEmitirHistogramaAguaHelper(
				filtro);

		switch (opcaoTotalizacao) {

		// Estado
		case 1:

			colecaoEmitirHistogramaAgua = this
					.pesquisarEmitirHistogramaAguaEstado(filtro);
			break;

		// Estado por Gerencia Regional
		case 2:

			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaGerenciaRegional(filtro);
			colecaoEmitirHistogramaAgua.addAll(this
					.pesquisarEmitirHistogramaAguaEstado(filtroClone));
			break;

		// Estado por Unidade Negocio
		case 3:

			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaUnidadeNegocioGerenciaRegional(filtro);
			colecaoEmitirHistogramaAgua.addAll(this
					.pesquisarEmitirHistogramaAguaEstado(filtroClone));
			break;

		// Estado por Elo Polo
		case 4:

			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaEloUnidadeNegocioGerenciaRegional(filtro);
			colecaoEmitirHistogramaAgua.addAll(this
					.pesquisarEmitirHistogramaAguaEstado(filtroClone));
			break;

		// Estado por Localidade
		case 5:

			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaLocalidadeEloUnidadeNegocioGerenciaRegional(filtro);
			colecaoEmitirHistogramaAgua.addAll(this
					.pesquisarEmitirHistogramaAguaEstado(filtroClone));
			break;

		// Gerência Regional
		case 6:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaGerenciaRegional(filtro);
			break;

		// Gerência Regional por Unidade Negocio
		case 7:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaUnidadeNegocioGerenciaRegional(filtro);
			break;

		// Gerência Regional por Elo
		case 8:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaEloUnidadeNegocioGerenciaRegional(filtro);
			break;

		// Gerência Regional por Localidade
		case 9:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaLocalidadeEloUnidadeNegocioGerenciaRegional(filtro);
			break;

		// Unidade de Negocio
		case 10:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaUnidadeNegocio(filtro);
			break;

		// Unidade de Negocio por Elo
		case 11:

			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaEloUnidadeNegocio(filtro);
			break;

		// Unidade de Negocio por Localidade
		case 12:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaLocalidadeEloUnidadeNegocio(filtro);
			break;

		// Elo Polo
		case 13:
			colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaElo(filtro);
			break;

		// Elo Polo Por Localidade
		case 14:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaLocalidadeElo(filtro);
			break;

		// Elo Polo Por Setor Comercial
		case 15:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaSetorComercialLocalidadeElo(filtro);
			break;

		// Localidade
		case 16:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaLocalidade(filtro);
			break;

		// Localidade Por Setor Comercial
		case 17:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaSetorComercialLocalidade(filtro);
			break;

		// Localidade Por Quadra
		case 18:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaQuadraLocalidade(filtro);
			break;

		// Setor Comercial
		case 19:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaSetorComercial(filtro);
			break;

		// Setor Comercial Por Quadra
		case 20:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaQuadraSetorComercial(filtro);
			break;

		// Quadra
		case 21:
			colecaoEmitirHistogramaAgua = this
					.emitirHistogramaAguaQuadra(filtro);
			break;

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * @author Rafael Pinto
	 * @date 06/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> pesquisarEmitirHistogramaAguaEstado(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setOpcaoTotalizacao(1);

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {
			String descricaoOpcaoTotalizacao = this.getControladorUtil()
					.pesquisarParametrosDoSistema().getNomeEstado();

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while (iter.hasNext()) {

				String estado = (String) iter.next();

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(estado);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

			}
		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água - Gerencia Regional
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaGerenciaRegional(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.gerenciaRegional.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setEloPolo(null);
		filtro.setUnidadeNegocio(null);
		filtro.setLocalidade(null);
		filtro.setConsumoFaixaLigacao(null);

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			FiltroGerenciaRegional filtroGerencia = null;
			Collection colecaoGerencia = null;
			GerenciaRegional gerenciaRegional = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while (iter.hasNext()) {

				String gerencia = (String) iter.next();

				gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setId(new Integer(gerencia));

				filtro.setGerenciaRegional(gerenciaRegional);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(gerencia);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroGerencia = new FiltroGerenciaRegional();
				filtroGerencia.adicionarParametro(new ParametroSimples(
						FiltroGerenciaRegional.ID, gerencia));

				// Recupera Gerencia Regional
				colecaoGerencia = this.getControladorUtil().pesquisar(
						filtroGerencia, GerenciaRegional.class.getName());

				gerenciaRegional = (GerenciaRegional) Util
						.retonarObjetoDeColecao(colecaoGerencia);

				String descricaoOpcaoTotalizacao = gerenciaRegional.getId()
						+ " - " + gerenciaRegional.getNome();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Unidade Negocio e Gerencia Regional
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaUnidadeNegocioGerenciaRegional(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.unidadeNegocio.id,histograma.gerenciaRegional.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int gerenciaAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			FiltroUnidadeNegocio filtroUnidade = null;
			Collection colecaoUnidade = null;
			UnidadeNegocio unidade = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(new Integer(arrayNumeracao[0]));

				GerenciaRegional gerencia = new GerenciaRegional();
				gerencia.setId(new Integer(arrayNumeracao[1]));

				filtro.setUnidadeNegocio(unidadeNegocio);

				if (gerenciaAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					gerenciaAnterior = gerencia.getId();
				}

				// Mudou de Gerencia
				if (gerenciaAnterior != gerencia.getId().intValue()) {

					filtro.setOpcaoTotalizacao(2);

					GerenciaRegional gereAnterior = new GerenciaRegional();
					gereAnterior.setId(gerenciaAnterior);
					filtro.setGerenciaRegional(gereAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaGerenciaRegional(filtro));
				}

				filtro.setOpcaoTotalizacao(3);
				filtro.setGerenciaRegional(gerencia);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroUnidade = new FiltroUnidadeNegocio();
				filtroUnidade.adicionarParametro(new ParametroSimples(
						FiltroUnidadeNegocio.ID, unidadeNegocio.getId()));

				filtroUnidade
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");

				// Recupera Unidade Negocio
				colecaoUnidade = this.getControladorUtil().pesquisar(
						filtroUnidade, UnidadeNegocio.class.getName());

				unidade = (UnidadeNegocio) Util
						.retonarObjetoDeColecao(colecaoUnidade);

				String descricaoOpcaoTotalizacao = unidade
						.getGerenciaRegional().getId()
						+ "-"
						+ unidade.getGerenciaRegional().getNomeAbreviado()
						+ " / " + unidade.getId() + " - " + unidade.getNome();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				filtro.setMedicao(indicadorMedicao);

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				gerenciaAnterior = gerencia.getId();

			}

			filtro.setOpcaoTotalizacao(2);

			GerenciaRegional gereAnterior = new GerenciaRegional();
			gereAnterior.setId(gerenciaAnterior);
			filtro.setGerenciaRegional(gereAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaGerenciaRegional(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * 
	 * Elo e Unidade Negocio e Gerencia Regional
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaEloUnidadeNegocioGerenciaRegional(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidadeEelo.id,"
				+ "histograma.unidadeNegocio.id,histograma.gerenciaRegional.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int gerenciaAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int unidadeNegocioAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade eloPolo = null;
			UnidadeNegocio unidadeNegocio = null;
			GerenciaRegional gerencia = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				eloPolo = new Localidade();
				eloPolo.setId(new Integer(arrayNumeracao[0]));

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(new Integer(arrayNumeracao[1]));

				gerencia = new GerenciaRegional();
				gerencia.setId(new Integer(arrayNumeracao[2]));

				if (unidadeNegocioAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					unidadeNegocioAnterior = unidadeNegocio.getId();
				}

				if (gerenciaAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					gerenciaAnterior = gerencia.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setGerenciaRegional(gerencia);

				// Mudou de Unidade
				if (unidadeNegocioAnterior != unidadeNegocio.getId().intValue()) {

					filtro.setOpcaoTotalizacao(10);

					UnidadeNegocio uniAnterior = new UnidadeNegocio();
					uniAnterior.setId(unidadeNegocioAnterior);
					filtro.setUnidadeNegocio(uniAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaUnidadeNegocio(filtro));
				}

				filtro.setMedicao(indicadorMedicao);

				// Mudou de Gerencia
				if (gerenciaAnterior != gerencia.getId().intValue()) {

					GerenciaRegional gereAnterior = new GerenciaRegional();
					gereAnterior.setId(gerenciaAnterior);
					filtro.setGerenciaRegional(gereAnterior);

					filtro.setOpcaoTotalizacao(2);
					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaGerenciaRegional(filtro));
				}

				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setGerenciaRegional(gerencia);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(
						FiltroLocalidade.ID, eloPolo.getId()));

				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(
						filtroLocalidade, Localidade.class.getName());

				eloPolo = (Localidade) Util
						.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = eloPolo
						.getGerenciaRegional().getId()
						+ "-"
						+ eloPolo.getGerenciaRegional().getNomeAbreviado()
						+ " / "
						+ eloPolo.getUnidadeNegocio().getId()
						+ "-"
						+ eloPolo.getUnidadeNegocio().getNomeAbreviado()
						+ " / "
						+ eloPolo.getId()
						+ "-"
						+ eloPolo.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				filtro.setMedicao(indicadorMedicao);

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				gerenciaAnterior = gerencia.getId();
				unidadeNegocioAnterior = unidadeNegocio.getId();

			}

			filtro.setMedicao(indicadorMedicao);

			filtro.setOpcaoTotalizacao(10);
			UnidadeNegocio uniAnterior = new UnidadeNegocio();
			uniAnterior.setId(unidadeNegocioAnterior);
			filtro.setUnidadeNegocio(uniAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaUnidadeNegocio(filtro));

			filtro.setMedicao(indicadorMedicao);

			filtro.setOpcaoTotalizacao(2);
			GerenciaRegional gereAnterior = new GerenciaRegional();
			gereAnterior.setId(gerenciaAnterior);
			filtro.setGerenciaRegional(gereAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaGerenciaRegional(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Elo e Unidade Negocio
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaEloUnidadeNegocio(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidadeEelo.id,histograma.unidadeNegocio.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int unidadeNegocioAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade eloPolo = null;
			UnidadeNegocio unidadeNegocio = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				eloPolo = new Localidade();
				eloPolo.setId(new Integer(arrayNumeracao[0]));

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(new Integer(arrayNumeracao[1]));

				if (unidadeNegocioAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					unidadeNegocioAnterior = unidadeNegocio.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);

				// Mudou de Unidade
				if (unidadeNegocioAnterior != unidadeNegocio.getId().intValue()) {

					filtro.setOpcaoTotalizacao(10);

					UnidadeNegocio uniAnterior = new UnidadeNegocio();
					uniAnterior.setId(unidadeNegocioAnterior);
					filtro.setUnidadeNegocio(uniAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaUnidadeNegocio(filtro));
				}

				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(
						FiltroLocalidade.ID, eloPolo.getId()));

				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(
						filtroLocalidade, Localidade.class.getName());

				eloPolo = (Localidade) Util
						.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = eloPolo
						.getGerenciaRegional().getId()
						+ "-"
						+ eloPolo.getGerenciaRegional().getNomeAbreviado()
						+ " / "
						+ eloPolo.getUnidadeNegocio().getId()
						+ "-"
						+ eloPolo.getUnidadeNegocio().getNomeAbreviado()
						+ " / "
						+ eloPolo.getId()
						+ "-"
						+ eloPolo.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				filtro.setMedicao(indicadorMedicao);

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				unidadeNegocioAnterior = unidadeNegocio.getId();

			}

			filtro.setMedicao(indicadorMedicao);

			filtro.setOpcaoTotalizacao(10);
			UnidadeNegocio uniAnterior = new UnidadeNegocio();
			uniAnterior.setId(unidadeNegocioAnterior);
			filtro.setUnidadeNegocio(uniAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaUnidadeNegocio(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Localidade Elo e Unidade Negocio
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaLocalidadeEloUnidadeNegocio(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidade.id,histograma.localidadeEelo.id,"
				+ "histograma.unidadeNegocio.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int unidadeNegocioAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int eloPoloAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade localidade = null;
			Localidade eloPolo = null;
			UnidadeNegocio unidadeNegocio = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				localidade = new Localidade();
				localidade.setId(new Integer(arrayNumeracao[0]));

				eloPolo = new Localidade();
				eloPolo.setId(new Integer(arrayNumeracao[1]));

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(new Integer(arrayNumeracao[2]));

				if (eloPoloAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					eloPoloAnterior = eloPolo.getId();
				}

				if (unidadeNegocioAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					unidadeNegocioAnterior = unidadeNegocio.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);

				// Mudou de Elo Polo
				if (eloPoloAnterior != eloPolo.getId().intValue()) {

					filtro.setOpcaoTotalizacao(13);
					Localidade eloAnterior = new Localidade();
					eloAnterior.setId(eloPoloAnterior);
					filtro.setEloPolo(eloAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaElo(filtro));
				}

				filtro.setMedicao(indicadorMedicao);

				// Mudou de Unidade
				if (unidadeNegocioAnterior != unidadeNegocio.getId().intValue()) {

					filtro.setOpcaoTotalizacao(10);
					UnidadeNegocio uniAnterior = new UnidadeNegocio();
					uniAnterior.setId(unidadeNegocioAnterior);
					filtro.setUnidadeNegocio(uniAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaUnidadeNegocio(filtro));
				}

				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(
						FiltroLocalidade.ID, localidade.getId()));

				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(
						filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util
						.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade
						.getGerenciaRegional().getId()
						+ "-"
						+ localidade.getGerenciaRegional().getNomeAbreviado()
						+ " / "
						+ localidade.getUnidadeNegocio().getId()
						+ "-"
						+ localidade.getUnidadeNegocio().getNomeAbreviado()
						+ " / "
						+ localidade.getLocalidade().getId()
						+ "-"
						+ localidade.getLocalidade().getDescricao()
						+ " / "
						+ localidade.getId() + "-" + localidade.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				unidadeNegocioAnterior = unidadeNegocio.getId();
				eloPoloAnterior = eloPolo.getId();

			}

			filtro.setOpcaoTotalizacao(13);
			filtro.setMedicao(indicadorMedicao);

			Localidade eloAnterior = new Localidade();
			eloAnterior.setId(eloPoloAnterior);
			filtro.setEloPolo(eloAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaElo(filtro));

			filtro.setOpcaoTotalizacao(10);
			filtro.setMedicao(indicadorMedicao);

			UnidadeNegocio uniAnterior = new UnidadeNegocio();
			uniAnterior.setId(unidadeNegocioAnterior);
			filtro.setUnidadeNegocio(uniAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaUnidadeNegocio(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Localidade Elo e Unidade Negocio e Gerencia Regional
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaLocalidadeEloUnidadeNegocioGerenciaRegional(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidade.id,histograma.localidadeEelo.id,"
				+ "histograma.unidadeNegocio.id,histograma.gerenciaRegional.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int gerenciaAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int unidadeNegocioAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int eloPoloAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade localidade = null;
			Localidade eloPolo = null;
			UnidadeNegocio unidadeNegocio = null;
			GerenciaRegional gerencia = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				localidade = new Localidade();
				localidade.setId(new Integer(arrayNumeracao[0]));

				eloPolo = new Localidade();
				eloPolo.setId(new Integer(arrayNumeracao[1]));

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(new Integer(arrayNumeracao[2]));

				gerencia = new GerenciaRegional();
				gerencia.setId(new Integer(arrayNumeracao[3]));

				if (eloPoloAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					eloPoloAnterior = eloPolo.getId();
				}

				if (unidadeNegocioAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					unidadeNegocioAnterior = unidadeNegocio.getId();
				}

				if (gerenciaAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					gerenciaAnterior = gerencia.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setGerenciaRegional(gerencia);

				// Mudou de Elo Polo
				if (eloPoloAnterior != eloPolo.getId().intValue()) {

					filtro.setOpcaoTotalizacao(13);
					Localidade eloAnterior = new Localidade();
					eloAnterior.setId(eloPoloAnterior);
					filtro.setEloPolo(eloAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaElo(filtro));
				}

				filtro.setMedicao(indicadorMedicao);

				// Mudou de Unidade
				if (unidadeNegocioAnterior != unidadeNegocio.getId().intValue()) {

					filtro.setOpcaoTotalizacao(10);
					UnidadeNegocio uniAnterior = new UnidadeNegocio();
					uniAnterior.setId(unidadeNegocioAnterior);
					filtro.setUnidadeNegocio(uniAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaUnidadeNegocio(filtro));
				}
				filtro.setMedicao(indicadorMedicao);

				// Mudou de Gerencia
				if (gerenciaAnterior != gerencia.getId().intValue()) {

					GerenciaRegional gereAnterior = new GerenciaRegional();
					gereAnterior.setId(gerenciaAnterior);
					filtro.setGerenciaRegional(gereAnterior);

					filtro.setOpcaoTotalizacao(2);
					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaGerenciaRegional(filtro));
				}

				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setGerenciaRegional(gerencia);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(
						FiltroLocalidade.ID, localidade.getId()));

				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(
						filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util
						.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade
						.getGerenciaRegional().getId()
						+ "-"
						+ localidade.getGerenciaRegional().getNomeAbreviado()
						+ " / "
						+ localidade.getUnidadeNegocio().getId()
						+ "-"
						+ localidade.getUnidadeNegocio().getNomeAbreviado()
						+ " / "
						+ localidade.getLocalidade().getId()
						+ "-"
						+ localidade.getLocalidade().getDescricao()
						+ " / "
						+ localidade.getId() + "-" + localidade.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				gerenciaAnterior = gerencia.getId();
				unidadeNegocioAnterior = unidadeNegocio.getId();
				eloPoloAnterior = eloPolo.getId();

			}

			filtro.setOpcaoTotalizacao(13);
			filtro.setMedicao(indicadorMedicao);

			Localidade eloAnterior = new Localidade();
			eloAnterior.setId(eloPoloAnterior);
			filtro.setEloPolo(eloAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaElo(filtro));

			filtro.setOpcaoTotalizacao(10);
			filtro.setMedicao(indicadorMedicao);

			UnidadeNegocio uniAnterior = new UnidadeNegocio();
			uniAnterior.setId(unidadeNegocioAnterior);
			filtro.setUnidadeNegocio(uniAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaUnidadeNegocio(filtro));

			filtro.setOpcaoTotalizacao(2);
			filtro.setMedicao(indicadorMedicao);

			GerenciaRegional gereAnterior = new GerenciaRegional();
			gereAnterior.setId(gerenciaAnterior);
			filtro.setGerenciaRegional(gereAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaGerenciaRegional(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * 
	 * Unidade Negocio
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaUnidadeNegocio(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.unidadeNegocio.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setEloPolo(null);
		filtro.setGerenciaRegional(null);
		filtro.setLocalidade(null);
		filtro.setConsumoFaixaLigacao(null);

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			FiltroUnidadeNegocio filtroUnidade = null;
			Collection colecaoUnidade = null;
			UnidadeNegocio unidadeNegocio = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(new Integer(chave));

				filtro.setUnidadeNegocio(unidadeNegocio);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroUnidade = new FiltroUnidadeNegocio();
				filtroUnidade.adicionarParametro(new ParametroSimples(
						FiltroUnidadeNegocio.ID, chave));

				filtroUnidade
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");

				// Recupera Unidade Negocio
				colecaoUnidade = this.getControladorUtil().pesquisar(
						filtroUnidade, UnidadeNegocio.class.getName());

				unidadeNegocio = (UnidadeNegocio) Util
						.retonarObjetoDeColecao(colecaoUnidade);

				String descricaoOpcaoTotalizacao = unidadeNegocio
						.getGerenciaRegional().getId()
						+ "-"
						+ unidadeNegocio.getGerenciaRegional()
								.getNomeAbreviado()
						+ " / "
						+ unidadeNegocio.getId()
						+ "-"
						+ unidadeNegocio.getNome();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}
				filtro.setMedicao(indicadorMedicao);

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * 
	 * Elo Polo
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaElo(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidadeEelo.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setLocalidade(null);
		filtro.setUnidadeNegocio(null);
		filtro.setGerenciaRegional(null);
		filtro.setCodigoSetorComercial(null);
		filtro.setConsumoFaixaLigacao(null);

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;
			Localidade localidade = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				localidade = new Localidade();
				localidade.setId(new Integer(chave));

				filtro.setEloPolo(localidade);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(
						FiltroLocalidade.ID, chave));

				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Unidade Negocio
				colecaoLocalidade = this.getControladorUtil().pesquisar(
						filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util
						.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade
						.getGerenciaRegional().getId()
						+ "-"
						+ localidade.getGerenciaRegional().getNomeAbreviado()
						+ " / "
						+ localidade.getUnidadeNegocio().getId()
						+ "-"
						+ localidade.getUnidadeNegocio().getNomeAbreviado()
						+ " / "
						+ localidade.getId()
						+ "-"
						+ localidade.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Localidade, Elo e Unidade Negocio
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaLocalidadeElo(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidade.id,histograma.localidadeEelo.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int eloPoloAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade localidade = null;
			Localidade eloPolo = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				localidade = new Localidade();
				localidade.setId(new Integer(arrayNumeracao[0]));

				eloPolo = new Localidade();
				eloPolo.setId(new Integer(arrayNumeracao[1]));

				if (eloPoloAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					eloPoloAnterior = eloPolo.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);

				// Mudou de Elo Polo
				if (eloPoloAnterior != eloPolo.getId().intValue()) {

					filtro.setOpcaoTotalizacao(13);
					Localidade eloAnterior = new Localidade();
					eloAnterior.setId(eloPoloAnterior);
					filtro.setEloPolo(eloAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaElo(filtro));
				}

				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(
						FiltroLocalidade.ID, localidade.getId()));

				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade
						.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(
						filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util
						.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade
						.getGerenciaRegional().getId()
						+ "-"
						+ localidade.getGerenciaRegional().getNomeAbreviado()
						+ " / "
						+ localidade.getUnidadeNegocio().getId()
						+ "-"
						+ localidade.getUnidadeNegocio().getNomeAbreviado()
						+ " / "
						+ localidade.getLocalidade().getId()
						+ "-"
						+ localidade.getLocalidade().getDescricao()
						+ " / "
						+ localidade.getId() + "-" + localidade.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				eloPoloAnterior = eloPolo.getId();

			}

			filtro.setOpcaoTotalizacao(13);
			filtro.setMedicao(indicadorMedicao);

			Localidade eloAnterior = new Localidade();
			eloAnterior.setId(eloPoloAnterior);
			filtro.setEloPolo(eloAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaElo(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Setor Comercial ,Localidade e Elo
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaSetorComercialLocalidadeElo(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.codigoSetorComercial,histograma.localidade.id,"
				+ "histograma.localidadeEelo.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int localidadeAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int eloPoloAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroSetorComercial filtroSetorComercial = null;
			Collection colecaoSetorComercial = null;

			Integer codigoSetorComercial = null;
			SetorComercial setorComercial = null;
			Localidade localidade = null;
			Localidade eloPolo = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				codigoSetorComercial = new Integer(arrayNumeracao[0]);

				localidade = new Localidade();
				localidade.setId(new Integer(arrayNumeracao[1]));

				eloPolo = new Localidade();
				eloPolo.setId(new Integer(arrayNumeracao[2]));

				if (eloPoloAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					eloPoloAnterior = eloPolo.getId();
				}

				if (localidadeAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					localidadeAnterior = localidade.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setCodigoSetorComercial(codigoSetorComercial);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);

				// Mudou de Localidade
				if (localidadeAnterior != localidade.getId().intValue()) {

					filtro.setOpcaoTotalizacao(16);

					Localidade localAnterior = new Localidade();
					localAnterior.setId(localidadeAnterior);

					filtro.setLocalidade(localAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaLocalidade(filtro));
				}

				filtro.setCodigoSetorComercial(codigoSetorComercial);
				filtro.setLocalidade(localidade);
				filtro.setMedicao(indicadorMedicao);

				// Mudou de Elo Polo
				if (eloPoloAnterior != eloPolo.getId().intValue()) {

					filtro.setOpcaoTotalizacao(13);
					Localidade eloAnterior = new Localidade();
					eloAnterior.setId(eloPoloAnterior);
					filtro.setEloPolo(eloAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaElo(filtro));
				}

				filtro.setCodigoSetorComercial(codigoSetorComercial);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);

				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroSetorComercial = new FiltroSetorComercial();
				filtroSetorComercial.adicionarParametro(new ParametroSimples(
						FiltroSetorComercial.CODIGO_SETOR_COMERCIAL,
						codigoSetorComercial));

				filtroSetorComercial
						.adicionarParametro(new ParametroSimples(
								FiltroSetorComercial.ID_LOCALIDADE, localidade
										.getId()));

				filtroSetorComercial
						.adicionarCaminhoParaCarregamentoEntidade("localidade");

				// Recupera Setor Comercial
				colecaoSetorComercial = this.getControladorUtil().pesquisar(
						filtroSetorComercial, SetorComercial.class.getName());

				setorComercial = (SetorComercial) Util
						.retonarObjetoDeColecao(colecaoSetorComercial);

				String descricaoOpcaoTotalizacao = setorComercial
						.getLocalidade().getId()
						+ "-"
						+ setorComercial.getLocalidade().getDescricao()
						+ " / "
						+ setorComercial.getCodigo()
						+ "-"
						+ setorComercial.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				localidadeAnterior = localidade.getId();
				eloPoloAnterior = eloPolo.getId();

			}

			filtro.setOpcaoTotalizacao(16);
			filtro.setMedicao(indicadorMedicao);

			Localidade localAnterior = new Localidade();
			localAnterior.setId(localidadeAnterior);

			filtro.setLocalidade(localAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaLocalidade(filtro));

			filtro.setOpcaoTotalizacao(13);
			filtro.setMedicao(indicadorMedicao);

			Localidade eloAnterior = new Localidade();
			eloAnterior.setId(eloPoloAnterior);
			filtro.setEloPolo(eloAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaElo(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Setor Comercial ,Localidade e Elo
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaSetorComercialLocalidade(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.codigoSetorComercial,histograma.localidade.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int localidadeAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroSetorComercial filtroSetorComercial = null;
			Collection colecaoSetorComercial = null;

			Integer codigoSetorComercial = null;
			SetorComercial setorComercial = null;
			Localidade localidade = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				codigoSetorComercial = new Integer(arrayNumeracao[0]);

				localidade = new Localidade();
				localidade.setId(new Integer(arrayNumeracao[1]));

				if (localidadeAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					localidadeAnterior = localidade.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setCodigoSetorComercial(codigoSetorComercial);
				filtro.setLocalidade(localidade);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroSetorComercial = new FiltroSetorComercial();
				filtroSetorComercial.adicionarParametro(new ParametroSimples(
						FiltroSetorComercial.CODIGO_SETOR_COMERCIAL,
						codigoSetorComercial));

				filtroSetorComercial
						.adicionarParametro(new ParametroSimples(
								FiltroSetorComercial.ID_LOCALIDADE, localidade
										.getId()));

				filtroSetorComercial
						.adicionarCaminhoParaCarregamentoEntidade("localidade");

				// Recupera Setor Comercial
				colecaoSetorComercial = this.getControladorUtil().pesquisar(
						filtroSetorComercial, SetorComercial.class.getName());

				setorComercial = (SetorComercial) Util
						.retonarObjetoDeColecao(colecaoSetorComercial);

				String descricaoOpcaoTotalizacao = setorComercial
						.getLocalidade().getId()
						+ "-"
						+ setorComercial.getLocalidade().getDescricao()
						+ " / "
						+ setorComercial.getCodigo()
						+ "-"
						+ setorComercial.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				localidadeAnterior = localidade.getId();

			}

			filtro.setOpcaoTotalizacao(16);
			filtro.setMedicao(indicadorMedicao);

			Localidade localAnterior = new Localidade();
			localAnterior.setId(localidadeAnterior);

			filtro.setLocalidade(localAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaLocalidade(filtro));
		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Setor Comercial e Quadra
	 * 
	 * @author Rafael Pinto
	 * @date 13/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaQuadraSetorComercial(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.numeroQuadra,histograma.setorComercial.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int setorComercialAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroQuadra filtroQuadra = null;
			Collection colecaoQuadra = null;

			Integer numeroQuadra = null;
			SetorComercial setorComercial = null;
			Quadra quadra = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				numeroQuadra = new Integer(arrayNumeracao[0]);

				setorComercial = new SetorComercial();
				setorComercial.setId(new Integer(arrayNumeracao[1]));

				if (setorComercialAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					setorComercialAnterior = setorComercial.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setNumeroQuadra(numeroQuadra);
				filtro.setSetorComercial(setorComercial);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroQuadra = new FiltroQuadra();
				filtroQuadra.adicionarParametro(new ParametroSimples(
						FiltroQuadra.NUMERO_QUADRA, numeroQuadra));

				filtroQuadra
						.adicionarParametro(new ParametroSimples(
								FiltroQuadra.ID_SETORCOMERCIAL, setorComercial
										.getId()));

				filtroQuadra
						.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
				filtroQuadra
						.adicionarCaminhoParaCarregamentoEntidade("setorComercial.localidade");

				// Recupera Quadra
				colecaoQuadra = this.getControladorUtil().pesquisar(
						filtroQuadra, Quadra.class.getName());

				quadra = (Quadra) Util.retonarObjetoDeColecao(colecaoQuadra);

				String descricaoOpcaoTotalizacao = quadra.getSetorComercial()
						.getLocalidade().getId()
						+ "-"
						+ quadra.getSetorComercial().getLocalidade()
								.getDescricao()
						+ " / "
						+ quadra.getSetorComercial().getCodigo()
						+ "-"
						+ quadra.getSetorComercial().getDescricao()
						+ " / "
						+ quadra.getNumeroQuadra();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				setorComercialAnterior = setorComercial.getId();

			}

			SetorComercial setorAnterior = new SetorComercial();
			setorAnterior.setId(setorComercialAnterior);

			filtro.setOpcaoTotalizacao(19);
			filtro.setMedicao(indicadorMedicao);
			filtro.setSetorComercial(setorAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaSetorComercial(filtro));
		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Setor Comercial ,Localidade e Elo
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaQuadraLocalidade(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.numeroQuadra,histograma.setorComercial.id,"
				+ "histograma.localidade.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int localidadeAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int setorComercialAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroQuadra filtroQuadra = null;
			Collection colecaoQuadra = null;

			Integer numeroQuadra = null;

			Quadra quadra = null;
			SetorComercial setorComercial = null;
			Localidade localidade = null;

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				numeroQuadra = new Integer(arrayNumeracao[0]);

				setorComercial = new SetorComercial();
				setorComercial.setId(new Integer(arrayNumeracao[1]));

				localidade = new Localidade();
				localidade.setId(new Integer(arrayNumeracao[2]));

				if (setorComercialAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					setorComercialAnterior = setorComercial.getId();
				}

				if (localidadeAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO) {
					localidadeAnterior = localidade.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setSetorComercial(setorComercial);
				filtro.setLocalidade(localidade);

				// Mudou de Setor Comercial
				if (setorComercialAnterior != setorComercial.getId().intValue()) {

					filtro.setOpcaoTotalizacao(19);

					SetorComercial setorAnterior = new SetorComercial();
					setorAnterior.setId(setorComercialAnterior);
					filtro.setSetorComercial(setorAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaSetorComercial(filtro));
				}

				filtro.setMedicao(indicadorMedicao);

				// Mudou de Localidade
				if (localidadeAnterior != localidade.getId().intValue()) {

					filtro.setOpcaoTotalizacao(16);

					Localidade localAnterior = new Localidade();
					localAnterior.setId(localidadeAnterior);

					filtro.setLocalidade(localAnterior);

					colecaoEmitirHistogramaAgua.addAll(this
							.emitirHistogramaAguaLocalidade(filtro));
				}

				filtro.setNumeroQuadra(numeroQuadra);
				filtro.setSetorComercial(setorComercial);
				filtro.setLocalidade(localidade);
				filtro.setMedicao(indicadorMedicao);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroQuadra = new FiltroQuadra();
				filtroQuadra.adicionarParametro(new ParametroSimples(
						FiltroQuadra.NUMERO_QUADRA, numeroQuadra));

				filtroQuadra
						.adicionarParametro(new ParametroSimples(
								FiltroQuadra.ID_SETORCOMERCIAL, setorComercial
										.getId()));

				filtroQuadra
						.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
				filtroQuadra
						.adicionarCaminhoParaCarregamentoEntidade("setorComercial.localidade");

				// Recupera Quadra
				colecaoQuadra = this.getControladorUtil().pesquisar(
						filtroQuadra, Quadra.class.getName());

				quadra = (Quadra) Util.retonarObjetoDeColecao(colecaoQuadra);

				String descricaoOpcaoTotalizacao = quadra.getSetorComercial()
						.getLocalidade().getId()
						+ "-"
						+ quadra.getSetorComercial().getLocalidade()
								.getDescricao()
						+ " / "
						+ quadra.getSetorComercial().getCodigo()
						+ "-"
						+ quadra.getSetorComercial().getDescricao()
						+ " / "
						+ quadra.getNumeroQuadra();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

				localidadeAnterior = localidade.getId();
				setorComercialAnterior = setorComercial.getId();

			}

			SetorComercial setorAnterior = new SetorComercial();
			setorAnterior.setId(setorComercialAnterior);

			filtro.setOpcaoTotalizacao(19);
			filtro.setMedicao(indicadorMedicao);
			filtro.setSetorComercial(setorAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaSetorComercial(filtro));

			Localidade localAnterior = new Localidade();
			localAnterior.setId(localidadeAnterior);

			filtro.setOpcaoTotalizacao(16);
			filtro.setMedicao(indicadorMedicao);
			filtro.setLocalidade(localAnterior);

			colecaoEmitirHistogramaAgua.addAll(this
					.emitirHistogramaAguaLocalidade(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * 
	 * Localidade
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaLocalidade(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidade.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setCodigoSetorComercial(null);
		filtro.setSetorComercial(null);
		filtro.setEloPolo(null);
		filtro.setConsumoFaixaLigacao(null);

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;
			Localidade localidade = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				localidade = new Localidade();
				localidade.setId(new Integer(chave));

				filtro.setLocalidade(localidade);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(
						FiltroLocalidade.ID, chave));

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(
						filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util
						.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade.getId() + "-"
						+ localidade.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * 
	 * Setor Comercial
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaSetorComercial(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.setorComercial.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setConsumoFaixaLigacao(null);

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			FiltroSetorComercial filtroSetorComercial = null;
			Collection colecaoSetorComercial = null;
			SetorComercial setorComercial = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				setorComercial = new SetorComercial();
				setorComercial.setId(new Integer(chave));

				filtro.setSetorComercial(setorComercial);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroSetorComercial = new FiltroSetorComercial();
				filtroSetorComercial.adicionarParametro(new ParametroSimples(
						FiltroSetorComercial.ID, chave));

				filtroSetorComercial
						.adicionarCaminhoParaCarregamentoEntidade("localidade");

				// Recupera Setor Comercial
				colecaoSetorComercial = this.getControladorUtil().pesquisar(
						filtroSetorComercial, SetorComercial.class.getName());

				setorComercial = (SetorComercial) Util
						.retonarObjetoDeColecao(colecaoSetorComercial);

				String descricaoOpcaoTotalizacao = setorComercial
						.getLocalidade().getId()
						+ "-"
						+ setorComercial.getLocalidade().getDescricao()
						+ " / "
						+ setorComercial.getCodigo()
						+ "-"
						+ setorComercial.getDescricao();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * 
	 * Quadra
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * 
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * 
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaQuadra(
			FiltrarEmitirHistogramaAguaHelper filtro)
			throws ControladorException {

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro
				.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.quadra.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		try {

			if (filtro.getMedicao() != null) {
				if (filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO) {
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				} else {
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
							.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento
					.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(
					filtro, colecaoTotalGeral);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()) {

			FiltroQuadra filtroQuadra = null;
			Collection colecaoQuadra = null;
			Quadra quadra = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while (iter.hasNext()) {

				String chave = (String) iter.next();

				quadra = new Quadra();
				quadra.setId(new Integer(chave));

				filtro.setQuadra(quadra);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
						.get(chave);

				HashMap mapTotalizacaoCategoria = this
						.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroQuadra = new FiltroQuadra();
				filtroQuadra.adicionarParametro(new ParametroSimples(
						FiltroQuadra.ID, chave));

				filtroQuadra
						.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
				filtroQuadra
						.adicionarCaminhoParaCarregamentoEntidade("setorComercial.localidade");

				// Recupera Setor Comercial
				colecaoQuadra = this.getControladorUtil().pesquisar(
						filtroQuadra, Quadra.class.getName());

				quadra = (Quadra) Util.retonarObjetoDeColecao(colecaoQuadra);

				String descricaoOpcaoTotalizacao = quadra.getSetorComercial()
						.getLocalidade().getId()
						+ "-"
						+ quadra.getSetorComercial().getLocalidade()
								.getDescricao()
						+ " / "
						+ quadra.getSetorComercial().getCodigo()
						+ "-"
						+ quadra.getSetorComercial().getDescricao()
						+ " / "
						+ quadra.getNumeroQuadra();

				// Vai gerar Faixa para medido
				if (colecaoConsumoFaixaLigacaoMedido != null
						&& !colecaoConsumoFaixaLigacaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_ATIVO,
							mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if (colecaoConsumoFaixaLigacaoNaoMedido != null
						&& !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()) {

					this.montarEmitirHistogramaAguaFaixaConsumo(
							colecaoConsumoFaixaLigacaoNaoMedido, filtro,
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeLigacoes(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalValorFaturado(),
							emitirHistogramaAguaHelperTotalGeral
									.getTotalQuantidadeVolumeTotal(),
							colecaoEmitirHistogramaAgua,
							descricaoOpcaoTotalizacao,
							ConstantesSistema.INDICADOR_USO_DESATIVO,
							mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral
						.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral
						.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua
						.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Total Geral
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param Collection
	 *            <Object[]>
	 * 
	 * @return HashMap
	 * @throws ControladorException
	 */
	private LinkedHashMap montarEmitirHistogramaAguaTotalGeral(
			FiltrarEmitirHistogramaAguaHelper filtro,
			Collection<Object[]> colecao) throws ControladorException {

		LinkedHashMap hashMapTotalizacao = new LinkedHashMap();

		if (colecao != null && !colecao.isEmpty()) {

			Iterator iterator = colecao.iterator();

			Collection<EmitirHistogramaAguaDetalheHelper> colecaoEmitirHistogramaAguaDetalhe = null;

			while (iterator.hasNext()) {
				Object[] objeto = (Object[]) iterator.next();

				EmitirHistogramaAguaDetalheHelper detalhe = new EmitirHistogramaAguaDetalheHelper();

				detalhe.setDescricaoCategoria((String) objeto[1]);
				detalhe.setQuantidadeLigacoes((Integer) objeto[2]);
				detalhe.setQuantidadeEconomias((Integer) objeto[3]);
				detalhe.setValorFaturado((BigDecimal) objeto[4]);

				/*
				 * if ( filtro.getIndicadorTarifaCategoria() == 2 ){
				 * Subcategoria subcategoria = new Subcategoria();
				 * subcategoria.setId( ( Integer ) objeto[5] );
				 * filtro.setSubcategoria( subcategoria ); }
				 */

				String tipoTotalizacao = "0";

				GerenciaRegional gerencia = null;
				UnidadeNegocio unidadeNegocio = null;
				Localidade eloPolo = null;
				Localidade localidade = null;
				SetorComercial setorComercial = null;
				Quadra quadra = null;

				int chaveQuadra = 0;
				int chaveSetorComercial = 0;
				int chaveLocalidade = 0;
				int chaveElo = 0;
				int chaveUnidade = 0;
				int chaveGerencia = 0;

				if (filtro.getOpcaoTotalizacao() == 2
						|| filtro.getOpcaoTotalizacao() == 6) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						tipoTotalizacao = ((Integer) objeto[7]).toString();
					} else {
						tipoTotalizacao = ((Integer) objeto[5]).toString();
					}

					gerencia = new GerenciaRegional();
					gerencia.setId(new Integer(tipoTotalizacao));

					filtro.setGerenciaRegional(gerencia);

				} else if (filtro.getOpcaoTotalizacao() == 3
						|| filtro.getOpcaoTotalizacao() == 7) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveUnidade = (Integer) objeto[7];
						chaveGerencia = (Integer) objeto[8];
					} else {
						chaveUnidade = (Integer) objeto[5];
						chaveGerencia = (Integer) objeto[6];
					}

					tipoTotalizacao = chaveUnidade + ";" + chaveGerencia;

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

					gerencia = new GerenciaRegional();
					gerencia.setId(chaveGerencia);
					filtro.setGerenciaRegional(gerencia);

				} else if (filtro.getOpcaoTotalizacao() == 4
						|| filtro.getOpcaoTotalizacao() == 8) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveElo = (Integer) objeto[7];
						chaveUnidade = (Integer) objeto[8];
						chaveGerencia = (Integer) objeto[9];
					} else {
						chaveElo = (Integer) objeto[5];
						chaveUnidade = (Integer) objeto[6];
						chaveGerencia = (Integer) objeto[7];
					}

					tipoTotalizacao = chaveElo + ";" + chaveUnidade + ";"
							+ chaveGerencia;

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

					gerencia = new GerenciaRegional();
					gerencia.setId(chaveGerencia);
					filtro.setGerenciaRegional(gerencia);

				} else if (filtro.getOpcaoTotalizacao() == 5
						|| filtro.getOpcaoTotalizacao() == 9) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveLocalidade = (Integer) objeto[7];
						chaveElo = (Integer) objeto[8];
						chaveUnidade = (Integer) objeto[9];
						chaveGerencia = (Integer) objeto[10];
					} else {
						chaveLocalidade = (Integer) objeto[5];
						chaveElo = (Integer) objeto[6];
						chaveUnidade = (Integer) objeto[7];
						chaveGerencia = (Integer) objeto[8];
					}

					tipoTotalizacao = chaveLocalidade + ";" + chaveElo + ";"
							+ chaveUnidade + ";" + chaveGerencia;

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

					gerencia = new GerenciaRegional();
					gerencia.setId(chaveGerencia);
					filtro.setGerenciaRegional(gerencia);

				} else if (filtro.getOpcaoTotalizacao() == 10) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveUnidade = (Integer) objeto[7];
					} else {
						chaveUnidade = (Integer) objeto[5];
					}
					tipoTotalizacao = "" + chaveUnidade;

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

				} else if (filtro.getOpcaoTotalizacao() == 11) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveElo = (Integer) objeto[7];
						chaveUnidade = (Integer) objeto[8];
					} else {
						chaveElo = (Integer) objeto[5];
						chaveUnidade = (Integer) objeto[6];
					}

					tipoTotalizacao = chaveElo + ";" + chaveUnidade;

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

				} else if (filtro.getOpcaoTotalizacao() == 12) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveLocalidade = (Integer) objeto[7];
						chaveElo = (Integer) objeto[8];
						chaveUnidade = (Integer) objeto[9];
					} else {
						chaveLocalidade = (Integer) objeto[5];
						chaveElo = (Integer) objeto[6];
						chaveUnidade = (Integer) objeto[7];
					}

					tipoTotalizacao = chaveLocalidade + ";" + chaveElo + ";"
							+ chaveUnidade;

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

				} else if (filtro.getOpcaoTotalizacao() == 13) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveElo = (Integer) objeto[7];
					} else {
						chaveElo = (Integer) objeto[5];
					}
					tipoTotalizacao = "" + chaveElo;

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

				} else if (filtro.getOpcaoTotalizacao() == 14) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveLocalidade = (Integer) objeto[7];
						chaveElo = (Integer) objeto[8];
					} else {
						chaveLocalidade = (Integer) objeto[5];
						chaveElo = (Integer) objeto[6];
					}

					tipoTotalizacao = chaveLocalidade + ";" + chaveElo;

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

				} else if (filtro.getOpcaoTotalizacao() == 15) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveSetorComercial = (Integer) objeto[7];
						chaveLocalidade = (Integer) objeto[8];
						chaveElo = (Integer) objeto[9];
					} else {
						chaveSetorComercial = (Integer) objeto[5];
						chaveLocalidade = (Integer) objeto[6];
						chaveElo = (Integer) objeto[7];
					}

					tipoTotalizacao = chaveSetorComercial + ";"
							+ chaveLocalidade + ";" + chaveElo;

					filtro.setCodigoSetorComercial(chaveSetorComercial);

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

				} else if (filtro.getOpcaoTotalizacao() == 16) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveLocalidade = (Integer) objeto[7];
					} else {
						chaveLocalidade = (Integer) objeto[5];
					}
					tipoTotalizacao = "" + chaveLocalidade;

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

				} else if (filtro.getOpcaoTotalizacao() == 17) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveSetorComercial = (Integer) objeto[7];
						chaveLocalidade = (Integer) objeto[8];
					} else {
						chaveSetorComercial = (Integer) objeto[5];
						chaveLocalidade = (Integer) objeto[6];
					}

					tipoTotalizacao = chaveSetorComercial + ";"
							+ chaveLocalidade;

					filtro.setCodigoSetorComercial(chaveSetorComercial);

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

				} else if (filtro.getOpcaoTotalizacao() == 18) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveQuadra = (Integer) objeto[7];
						chaveSetorComercial = (Integer) objeto[8];
						chaveLocalidade = (Integer) objeto[9];
					} else {
						chaveQuadra = (Integer) objeto[5];
						chaveSetorComercial = (Integer) objeto[6];
						chaveLocalidade = (Integer) objeto[7];
					}

					tipoTotalizacao = chaveQuadra + ";" + chaveSetorComercial
							+ ";" + chaveLocalidade;

					filtro.setNumeroQuadra(chaveQuadra);

					setorComercial = new SetorComercial();
					setorComercial.setId(chaveSetorComercial);
					filtro.setSetorComercial(setorComercial);

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

				} else if (filtro.getOpcaoTotalizacao() == 19) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveSetorComercial = (Integer) objeto[7];
					} else {
						chaveSetorComercial = (Integer) objeto[5];
					}
					tipoTotalizacao = "" + chaveSetorComercial;

					setorComercial = new SetorComercial();
					setorComercial.setId(chaveSetorComercial);

					filtro.setSetorComercial(setorComercial);

				} else if (filtro.getOpcaoTotalizacao() == 20) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveQuadra = (Integer) objeto[7];
						chaveSetorComercial = (Integer) objeto[8];
					} else {
						chaveQuadra = (Integer) objeto[5];
						chaveSetorComercial = (Integer) objeto[6];
					}

					tipoTotalizacao = chaveQuadra + ";" + chaveSetorComercial;

					filtro.setNumeroQuadra(chaveQuadra);

					setorComercial = new SetorComercial();
					setorComercial.setId(chaveSetorComercial);
					filtro.setSetorComercial(setorComercial);

				} else if (filtro.getOpcaoTotalizacao() == 21) {

					if (filtro.getIndicadorTarifaCategoria() == 2) {
						chaveQuadra = (Integer) objeto[7];
					} else {
						chaveQuadra = (Integer) objeto[5];
					}
					tipoTotalizacao = "" + chaveQuadra;

					quadra = new Quadra();
					quadra.setId(chaveQuadra);

					filtro.setQuadra(quadra);

				}

				try {
					Object[] somatorio = this.repositorioFaturamento
							.pesquisarEmitirHistogramaAguaTotalGeral(filtro,
									null);

					Integer quantidadeVolumeMedido;
					Integer quantidadeVolumeEstimado;

					if (filtro.getIndicadorTarifaCategoria().intValue() == ConstantesSistema.SIM) {

						Categoria categ = new Categoria();
						categ.setId((Integer) objeto[0]);

						quantidadeVolumeMedido = this.repositorioFaturamento
								.pesquisarEmitirHistogramaAguaVolumeConsumo(
										filtro,
										ConstantesSistema.INDICADOR_USO_ATIVO,
										categ, null);

						quantidadeVolumeEstimado = this.repositorioFaturamento
								.pesquisarEmitirHistogramaAguaVolumeConsumo(
										filtro,
										ConstantesSistema.INDICADOR_USO_DESATIVO,
										categ, null);
					} else {

						Subcategoria subcateg = new Subcategoria();
						subcateg.setId((Integer) objeto[5]);
						Categoria categoria = new Categoria();
						categoria.setId((Integer) objeto[0]);

						subcateg.setCategoria(categoria);

						quantidadeVolumeMedido = this.repositorioFaturamento
								.pesquisarEmitirHistogramaAguaVolumeConsumo(
										filtro,
										ConstantesSistema.INDICADOR_USO_ATIVO,
										subcateg, null);

						quantidadeVolumeEstimado = this.repositorioFaturamento
								.pesquisarEmitirHistogramaAguaVolumeConsumo(
										filtro,
										ConstantesSistema.INDICADOR_USO_DESATIVO,
										subcateg, null);
					}

					if (quantidadeVolumeMedido != null) {
						detalhe.setQuantidadeVolumeMedido(quantidadeVolumeMedido);
					}

					if (quantidadeVolumeEstimado != null) {
						detalhe.setQuantidadeVolumeEstimado(quantidadeVolumeEstimado);
					}

					BigDecimal percentualParcialLigacao = new BigDecimal(0.0);
					BigDecimal percentualParcialFaturamento = new BigDecimal(
							0.0);
					BigDecimal percentualParcialConsumo = new BigDecimal(0.0);

					if (((Integer) somatorio[0]).intValue() != 0) {

						percentualParcialLigacao = Util
								.calcularPercentualBigDecimal(
										"" + detalhe.getQuantidadeLigacoes(),
										"" + somatorio[0]);

					}

					if (((Integer) somatorio[1]).intValue() != 0) {

						percentualParcialConsumo = Util
								.calcularPercentualBigDecimal(
										"" + detalhe.getQuantidadeVolumeTotal(),
										"" + somatorio[1]);

					}

					if (((BigDecimal) somatorio[2]).compareTo(new BigDecimal(
							0.0)) > 0) {

						percentualParcialFaturamento = Util
								.calcularPercentualBigDecimal(
										detalhe.getValorFaturado(),
										new BigDecimal("" + somatorio[2]));
					}

					detalhe.setPercentualParcialLigacao(percentualParcialLigacao
							.doubleValue());
					detalhe.setPercentualParcialConsumo(percentualParcialConsumo
							.doubleValue());
					detalhe.setPercentualParcialFaturamento(percentualParcialFaturamento
							.doubleValue());

				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				if (hashMapTotalizacao.get(tipoTotalizacao) != null) {

					EmitirHistogramaAguaHelper emitirHistogramaAguaHelper = (EmitirHistogramaAguaHelper) hashMapTotalizacao
							.get(tipoTotalizacao);

					int totalLigacoes = emitirHistogramaAguaHelper
							.getTotalQuantidadeLigacoes();
					int totalEconomias = emitirHistogramaAguaHelper
							.getTotalQuantidadeEconomias();
					int volumeEstimado = emitirHistogramaAguaHelper
							.getTotalQuantidadeVolumeEstimado();
					int volumeMedido = emitirHistogramaAguaHelper
							.getTotalQuantidadeVolumeMedido();

					BigDecimal totalValorFaturado = emitirHistogramaAguaHelper
							.getTotalValorFaturado();

					emitirHistogramaAguaHelper
							.setTotalQuantidadeLigacoes(totalLigacoes
									+ detalhe.getQuantidadeLigacoes());
					emitirHistogramaAguaHelper
							.setTotalQuantidadeEconomias(totalEconomias
									+ detalhe.getQuantidadeEconomias());
					emitirHistogramaAguaHelper
							.setTotalValorFaturado(totalValorFaturado
									.add(detalhe.getValorFaturado()));

					emitirHistogramaAguaHelper
							.setTotalQuantidadeVolumeMedido(volumeMedido
									+ detalhe.getQuantidadeVolumeMedido());
					emitirHistogramaAguaHelper
							.setTotalQuantidadeVolumeEstimado(volumeEstimado
									+ detalhe.getQuantidadeVolumeEstimado());

					colecaoEmitirHistogramaAguaDetalhe = emitirHistogramaAguaHelper
							.getColecaoEmitirHistogramaAguaDetalhe();

					colecaoEmitirHistogramaAguaDetalhe.add(detalhe);
					emitirHistogramaAguaHelper
							.setColecaoEmitirHistogramaAguaDetalhe(colecaoEmitirHistogramaAguaDetalhe);

					hashMapTotalizacao.put(tipoTotalizacao,
							emitirHistogramaAguaHelper);

				} else {
					EmitirHistogramaAguaHelper emitirHistogramaAguaHelper = new EmitirHistogramaAguaHelper();
					emitirHistogramaAguaHelper
							.setDescricaoTitulo("TOTAL GERAL");

					emitirHistogramaAguaHelper
							.setTotalQuantidadeLigacoes(detalhe
									.getQuantidadeLigacoes());
					emitirHistogramaAguaHelper
							.setTotalQuantidadeEconomias(detalhe
									.getQuantidadeEconomias());
					emitirHistogramaAguaHelper
							.setTotalQuantidadeVolumeMedido(detalhe
									.getQuantidadeVolumeMedido());
					emitirHistogramaAguaHelper
							.setTotalQuantidadeVolumeEstimado(detalhe
									.getQuantidadeVolumeEstimado());

					emitirHistogramaAguaHelper.setTotalValorFaturado(detalhe
							.getValorFaturado());

					colecaoEmitirHistogramaAguaDetalhe = new ArrayList();
					colecaoEmitirHistogramaAguaDetalhe.add(detalhe);

					emitirHistogramaAguaHelper
							.setColecaoEmitirHistogramaAguaDetalhe(colecaoEmitirHistogramaAguaDetalhe);

					hashMapTotalizacao.put(tipoTotalizacao,
							emitirHistogramaAguaHelper);
				}

			}
		}
		return hashMapTotalizacao;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Total Geral Por Categoria
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param Collection
	 *            <Object[]>
	 * 
	 * @return HashMap
	 * @throws ControladorException
	 */
	private LinkedHashMap montarEmitirHistogramaAguaTotalGeralCategoria(
			Collection<EmitirHistogramaAguaDetalheHelper> colecao)
			throws ControladorException {

		LinkedHashMap hashMapTotalizacao = new LinkedHashMap();

		if (colecao != null && !colecao.isEmpty()) {

			Iterator iterator = colecao.iterator();

			while (iterator.hasNext()) {
				EmitirHistogramaAguaDetalheHelper detalhe = (EmitirHistogramaAguaDetalheHelper) iterator
						.next();

				Object[] objeto = new Object[3];

				objeto[0] = detalhe.getQuantidadeLigacoes();
				objeto[1] = detalhe.getQuantidadeVolumeTotal();
				objeto[2] = detalhe.getValorFaturado();

				hashMapTotalizacao.put(detalhe.getDescricaoCategoria(), objeto);
			}
		}

		return hashMapTotalizacao;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Gera as linhas Por Faixa de Consumo
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param Collection
	 *            <Object[]>
	 * 
	 * @return HashMap
	 * @throws ControladorException
	 */
	private void montarEmitirHistogramaAguaFaixaConsumo(
			Collection<ConsumoFaixaLigacao> colecao,
			FiltrarEmitirHistogramaAguaHelper filtro,
			int totalQuantidadeLigacoesTotalGeral,
			BigDecimal totalValorFaturado, int totalQuantidadeVolumeTotal,
			Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua,
			String descricaoOpcaoTotalizacao, short indicadorMedicao,
			HashMap mapTotalizacaoGategoria) throws ControladorException {

		// Gera os a linhas com a Faixa (PAI)
		// depois os totalizadores por categoria(FILHO)
		if (colecao != null && !colecao.isEmpty()) {

			Collection<Object[]> colecaoRetorno = null;
			EmitirHistogramaAguaHelper emitirTotalizadorIndicador = null;

			String descricaoTitulo = "TOTAL C/HID.";
			if (indicadorMedicao != ConstantesSistema.INDICADOR_USO_ATIVO
					.shortValue()) {
				descricaoTitulo = "TOTAL S/HID.";
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
						.retornaOLimiteConsultaTotal(indicadorMedicao));
				filtro.setConsumoFaixaLigacaoIntervaloMedido(null);
			} else {
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(null);
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro
						.retornaOLimiteConsultaTotal(indicadorMedicao));
			}

			try {

				filtro.setConsumoFaixaLigacao(null);

				filtro.setMedicao(indicadorMedicao);

				colecaoRetorno = this.repositorioFaturamento
						.pesquisarEmitirHistogramaAgua(filtro);

				filtro.setMedicao(null);

				emitirTotalizadorIndicador = this
						.montarEmitirHistogramaAguaDetalhe(colecaoRetorno,
								descricaoTitulo, filtro,
								descricaoOpcaoTotalizacao,
								totalQuantidadeLigacoesTotalGeral,
								totalValorFaturado, totalQuantidadeVolumeTotal,
								indicadorMedicao, mapTotalizacaoGategoria,
								null, null);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			if (emitirTotalizadorIndicador != null) {

				// chave(Id categoria),valores(BigDecimal[3] percentuais)
				LinkedHashMap mapPercentualParcialPorCategoriaAnterior = new LinkedHashMap();
				LinkedHashMap mapPercentualParcialPorTotalAnterior = new LinkedHashMap();

				filtro.setMedicao(indicadorMedicao);

				Iterator itera = colecao.iterator();
				while (itera.hasNext()) {
					ConsumoFaixaLigacao consumo = (ConsumoFaixaLigacao) itera
							.next();

					filtro.setConsumoFaixaLigacao(consumo);

					try {
						descricaoTitulo = consumo.getNumeroFaixaInicio()
								+ " a " + consumo.getNumeroFaixaFim();

						colecaoRetorno = this.repositorioFaturamento
								.pesquisarEmitirHistogramaAgua(filtro);

						EmitirHistogramaAguaHelper emitirFaixa = this
								.montarEmitirHistogramaAguaDetalhe(
										colecaoRetorno,
										descricaoTitulo,
										filtro,
										descricaoOpcaoTotalizacao,
										emitirTotalizadorIndicador
												.getTotalQuantidadeLigacoes(),
										emitirTotalizadorIndicador
												.getTotalValorFaturado(),
										emitirTotalizadorIndicador
												.getTotalQuantidadeVolumeTotal(),
										indicadorMedicao,
										null,
										mapPercentualParcialPorCategoriaAnterior,
										mapPercentualParcialPorTotalAnterior);

						if (emitirFaixa != null) {
							colecaoEmitirHistogramaAgua.add(emitirFaixa);
						}

					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				}
				if (emitirTotalizadorIndicador != null) {
					colecaoEmitirHistogramaAgua.add(emitirTotalizadorIndicador);
				}

			}// fim do emitir totalizador
		}
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * Linha Faixa
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * 
	 * @param Collection
	 *            <Object[]>
	 * 
	 * @return EmitirHistogramaAguaHelper
	 * @throws ControladorException
	 */
	private EmitirHistogramaAguaHelper montarEmitirHistogramaAguaDetalhe(
			Collection<Object[]> colecao, String descricaoTitulo,
			FiltrarEmitirHistogramaAguaHelper filtro,
			String descricaoOpcaoTotalizacao, int quantidadeLigacaoIndicador,
			BigDecimal valorFaturado, int totalQuantidadeVolumeTotal,
			short indicadorHidrometro, HashMap mapTotalizacaoGategoria,
			LinkedHashMap mapPercentualParcialPorCategoriaAnterior,
			LinkedHashMap mapPercentualParcialPorTotalAnterior)
			throws ControladorException {

		EmitirHistogramaAguaHelper emitirHistogramaAguaHelper = null;
		if (colecao != null && !colecao.isEmpty()) {

			Iterator iterator = colecao.iterator();

			Collection<EmitirHistogramaAguaDetalheHelper> colecaoEmitirHistogramaAguaDetalhe = new ArrayList();

			EmitirHistogramaAguaDetalheHelper detalhe = null;

			int totalLigacoes = 0;
			int totalEconomias = 0;
			int volumeMedido = 0;
			int volumeEstimado = 0;

			BigDecimal totalValorFaturado = new BigDecimal("0.0");

			while (iterator.hasNext()) {
				Object[] objeto = (Object[]) iterator.next();

				detalhe = new EmitirHistogramaAguaDetalheHelper();

				detalhe.setDescricaoCategoria((String) objeto[1]);
				detalhe.setQuantidadeLigacoes((Integer) objeto[2]);

				detalhe.setQuantidadeEconomias((Integer) objeto[3]);
				detalhe.setValorFaturado((BigDecimal) objeto[4]);

				if (filtro.getIndicadorTarifaCategoria().intValue() == ConstantesSistema.NAO) {
					detalhe.setDescricaoSubcategoria((String) objeto[6]);
				}

				try {

					Categoria categ = new Categoria();
					categ.setId((Integer) objeto[0]);
					Object[] somatorio = null;

					if (mapTotalizacaoGategoria != null) {
						somatorio = (Object[]) mapTotalizacaoGategoria
								.get(detalhe.getDescricaoCategoria());
					} else {
						somatorio = this.repositorioFaturamento
								.pesquisarEmitirHistogramaAguaTotalGeral(
										filtro, categ);
					}

					if (somatorio == null) {
						somatorio = new Object[3];
						somatorio[0] = 0;
						somatorio[1] = 0;
						somatorio[2] = new BigDecimal(0.0);
					}

					BigDecimal percentualParcialLigacao = new BigDecimal(0.0);
					BigDecimal percentualParcialFaturamento = new BigDecimal(
							0.0);
					BigDecimal percentualParcialConsumo = new BigDecimal(0.0);

					if (((Integer) somatorio[0]).intValue() != 0) {

						percentualParcialLigacao = Util
								.calcularPercentualBigDecimal(
										"" + detalhe.getQuantidadeLigacoes(),
										"" + somatorio[0]);

					}

					detalhe.setPercentualParcialLigacao(percentualParcialLigacao
							.doubleValue());

					if (((BigDecimal) somatorio[2]).compareTo(new BigDecimal(
							0.0)) > 0) {

						percentualParcialFaturamento = Util
								.calcularPercentualBigDecimal(
										detalhe.getValorFaturado(),
										new BigDecimal("" + somatorio[2]));
					}

					detalhe.setPercentualParcialFaturamento(percentualParcialFaturamento
							.doubleValue());

					if (indicadorHidrometro == ConstantesSistema.INDICADOR_USO_ATIVO
							.shortValue()) {

						Integer quantidadeVolumeMedido;
						Integer quantidadeVolumeEstimado;

						if (filtro.getIndicadorTarifaCategoria().intValue() == ConstantesSistema.SIM) {
							quantidadeVolumeMedido = this.repositorioFaturamento
									.pesquisarEmitirHistogramaAguaVolumeConsumo(
											filtro,
											ConstantesSistema.INDICADOR_USO_ATIVO,
											categ, indicadorHidrometro);

							quantidadeVolumeEstimado = this.repositorioFaturamento
									.pesquisarEmitirHistogramaAguaVolumeConsumo(
											filtro,
											ConstantesSistema.INDICADOR_USO_DESATIVO,
											categ, indicadorHidrometro);
						} else {

							Subcategoria subcateg = new Subcategoria();
							subcateg.setId((Integer) objeto[5]);

							Categoria categoria = new Categoria();
							categoria.setId((Integer) objeto[0]);

							subcateg.setCategoria(categoria);

							quantidadeVolumeMedido = this.repositorioFaturamento
									.pesquisarEmitirHistogramaAguaVolumeConsumo(
											filtro,
											ConstantesSistema.INDICADOR_USO_ATIVO,
											subcateg, indicadorHidrometro);

							quantidadeVolumeEstimado = this.repositorioFaturamento
									.pesquisarEmitirHistogramaAguaVolumeConsumo(
											filtro,
											ConstantesSistema.INDICADOR_USO_DESATIVO,
											subcateg, indicadorHidrometro);
						}

						if (quantidadeVolumeMedido != null) {
							detalhe.setQuantidadeVolumeMedido(quantidadeVolumeMedido);
						}
						if (quantidadeVolumeEstimado != null) {
							detalhe.setQuantidadeVolumeEstimado(quantidadeVolumeEstimado);
						}

					} else {
						Integer quantidadeVolumeEstimado;

						if (filtro.getIndicadorTarifaCategoria().intValue() == ConstantesSistema.SIM) {
							quantidadeVolumeEstimado = this.repositorioFaturamento
									.pesquisarEmitirHistogramaAguaVolumeConsumo(
											filtro,
											ConstantesSistema.INDICADOR_USO_DESATIVO,
											categ, indicadorHidrometro);
						} else {
							Subcategoria subcateg = new Subcategoria();
							subcateg.setId((Integer) objeto[5]);

							Categoria categoria = new Categoria();
							categoria.setId((Integer) objeto[0]);

							subcateg.setCategoria(categoria);

							quantidadeVolumeEstimado = this.repositorioFaturamento
									.pesquisarEmitirHistogramaAguaVolumeConsumo(
											filtro,
											ConstantesSistema.INDICADOR_USO_DESATIVO,
											subcateg, indicadorHidrometro);
						}

						if (quantidadeVolumeEstimado != null) {
							detalhe.setQuantidadeVolumeEstimado(quantidadeVolumeEstimado);
						}
					}

					if (((Integer) somatorio[1]).intValue() != 0) {

						percentualParcialConsumo = Util
								.calcularPercentualBigDecimal(
										"" + detalhe.getQuantidadeVolumeTotal(),
										"" + somatorio[1]);
					}

					detalhe.setPercentualParcialConsumo(percentualParcialConsumo
							.doubleValue());

					if (mapPercentualParcialPorCategoriaAnterior != null) {

						BigDecimal[] valoresPercentual = (BigDecimal[]) mapPercentualParcialPorCategoriaAnterior
								.get(categ.getId());

						BigDecimal percentualAcumuladoLigacao = new BigDecimal(
								0.0);
						BigDecimal percentualAcumuladoConsumo = new BigDecimal(
								0.0);
						BigDecimal percentualAcumuladoFaturamento = new BigDecimal(
								0.0);

						if (valoresPercentual != null) {

							percentualAcumuladoLigacao = percentualParcialLigacao
									.add(valoresPercentual[0]);
							percentualAcumuladoConsumo = percentualParcialConsumo
									.add(valoresPercentual[1]);
							percentualAcumuladoFaturamento = percentualParcialFaturamento
									.add(valoresPercentual[2]);

						} else {

							percentualAcumuladoLigacao = percentualParcialLigacao;
							percentualAcumuladoConsumo = percentualParcialConsumo;
							percentualAcumuladoFaturamento = percentualParcialFaturamento;

						}

						detalhe.setPercentualAcumuladoLigacao(percentualAcumuladoLigacao
								.doubleValue());
						detalhe.setPercentualAcumuladoConsumo(percentualAcumuladoConsumo
								.doubleValue());
						detalhe.setPercentualAcumuladoFaturamento(percentualAcumuladoFaturamento
								.doubleValue());

						valoresPercentual = new BigDecimal[3];

						valoresPercentual[0] = percentualAcumuladoLigacao;
						valoresPercentual[1] = percentualAcumuladoConsumo;
						valoresPercentual[2] = percentualAcumuladoFaturamento;

						mapPercentualParcialPorCategoriaAnterior.put(
								categ.getId(), valoresPercentual);

					}

				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				totalLigacoes += detalhe.getQuantidadeLigacoes();
				totalEconomias += detalhe.getQuantidadeEconomias();
				volumeMedido += detalhe.getQuantidadeVolumeMedido();
				volumeEstimado += detalhe.getQuantidadeVolumeEstimado();
				totalValorFaturado = totalValorFaturado.add(detalhe
						.getValorFaturado());

				colecaoEmitirHistogramaAguaDetalhe.add(detalhe);

			}

			emitirHistogramaAguaHelper = new EmitirHistogramaAguaHelper();
			emitirHistogramaAguaHelper
					.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
			emitirHistogramaAguaHelper.setDescricaoTitulo(descricaoTitulo);
			emitirHistogramaAguaHelper
					.setColecaoEmitirHistogramaAguaDetalhe(colecaoEmitirHistogramaAguaDetalhe);
			emitirHistogramaAguaHelper
					.setTotalQuantidadeLigacoes(totalLigacoes);
			emitirHistogramaAguaHelper
					.setTotalQuantidadeEconomias(totalEconomias);
			emitirHistogramaAguaHelper
					.setTotalQuantidadeVolumeMedido(volumeMedido);
			emitirHistogramaAguaHelper
					.setTotalQuantidadeVolumeEstimado(volumeEstimado);
			emitirHistogramaAguaHelper
					.setTotalValorFaturado(totalValorFaturado);

			BigDecimal percentualParcialLigacao = new BigDecimal(0.0);
			BigDecimal percentualParcialFaturamento = new BigDecimal(0.0);
			BigDecimal percentualParcialConsumo = new BigDecimal(0.0);

			if (quantidadeLigacaoIndicador != 0) {

				percentualParcialLigacao = Util.calcularPercentualBigDecimal(
						""
								+ emitirHistogramaAguaHelper
										.getTotalQuantidadeLigacoes(), ""
								+ quantidadeLigacaoIndicador);
			}

			if (totalQuantidadeVolumeTotal != 0) {

				percentualParcialConsumo = Util.calcularPercentualBigDecimal(
						""
								+ emitirHistogramaAguaHelper
										.getTotalQuantidadeVolumeTotal(), ""
								+ totalQuantidadeVolumeTotal);

			}

			if (valorFaturado.compareTo(new BigDecimal(0.0)) > 0) {

				percentualParcialFaturamento = Util
						.calcularPercentualBigDecimal(
								emitirHistogramaAguaHelper
										.getTotalValorFaturado(), valorFaturado);
			}

			emitirHistogramaAguaHelper
					.setTotalPercentualParcialLigacao(percentualParcialLigacao
							.doubleValue());
			emitirHistogramaAguaHelper
					.setTotalPercentualParcialConsumo(percentualParcialConsumo
							.doubleValue());
			emitirHistogramaAguaHelper
					.setTotalPercentualParcialFaturamento(percentualParcialFaturamento
							.doubleValue());

			if (mapPercentualParcialPorTotalAnterior != null) {

				BigDecimal[] valoresPercentual = (BigDecimal[]) mapPercentualParcialPorTotalAnterior
						.get("TOTAL");

				BigDecimal percentualAcumuladoLigacao = new BigDecimal(0.0);
				BigDecimal percentualAcumuladoConsumo = new BigDecimal(0.0);
				BigDecimal percentualAcumuladoFaturamento = new BigDecimal(0.0);

				if (valoresPercentual != null) {

					percentualAcumuladoLigacao = percentualParcialLigacao
							.add(valoresPercentual[0]);
					percentualAcumuladoConsumo = percentualParcialConsumo
							.add(valoresPercentual[1]);
					percentualAcumuladoFaturamento = percentualParcialFaturamento
							.add(valoresPercentual[2]);

				} else {

					percentualAcumuladoLigacao = percentualParcialLigacao;
					percentualAcumuladoConsumo = percentualParcialConsumo;
					percentualAcumuladoFaturamento = percentualParcialFaturamento;

				}

				emitirHistogramaAguaHelper
						.setTotalPercentualAcumuladoLigacao(percentualAcumuladoLigacao
								.doubleValue());
				emitirHistogramaAguaHelper
						.setTotalPercentualAcumuladoConsumo(percentualAcumuladoConsumo
								.doubleValue());
				emitirHistogramaAguaHelper
						.setTotalPercentualAcumuladoFaturamento(percentualAcumuladoFaturamento
								.doubleValue());

				valoresPercentual = new BigDecimal[3];

				valoresPercentual[0] = percentualAcumuladoLigacao;
				valoresPercentual[1] = percentualAcumuladoConsumo;
				valoresPercentual[2] = percentualAcumuladoFaturamento;

				mapPercentualParcialPorTotalAnterior.put("TOTAL",
						valoresPercentual);

			}

		}

		return emitirHistogramaAguaHelper;
	}

	/**
	 * Inseri o tipo de debito na base
	 * 
	 * [UC0529] Inserir Tipo de Débito
	 * 
	 * 
	 * @author Rômulo Aurélio
	 * @date 09/03/2007
	 * 
	 * @param descricao
	 * @param descricaoAbreviada
	 * @param idTipoFinanciamento
	 * @param indicadorGeracaoDebitoAutomatica
	 * @param indicadorGeracaoDebitoConta
	 * @param idLancamentoItemContabil
	 * @param valorLimeteDebito
	 * @param usuarioLogado
	 * @param indicadorDebitoCartaoCredito
	 * @return
	 */

	public Integer inserirDebitoTipo(String descricao,
			String descricaoAbreviada, String idTipoFinanciamento,
			String indicadorGeracaoDebitoAutomatica,
			String indicadorGeracaoDebitoConta,
			String idLancamentoItemContabil, String valorLimiteDebito,
			Usuario usuarioLogado, String valorSugerido,
			String indicadorDebitoCartaoCredito, String indicadorJurosParCliente)
			throws ControladorException {

		Integer retorno = null;

		if (descricao == null || descricao.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Descrição do Tipo de Débito");
		}

		if (idTipoFinanciamento == null
				|| idTipoFinanciamento.trim().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Tipo de Financiamento");
		}

		if (indicadorGeracaoDebitoAutomatica == null
				|| indicadorGeracaoDebitoAutomatica.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Indicador de Geração do Débito Automática");
		}

		if (indicadorGeracaoDebitoConta == null
				|| indicadorGeracaoDebitoConta.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Indicador de Geração do Débito em Conta");
		}

		if (idLancamentoItemContabil == null
				|| idLancamentoItemContabil.trim().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Tipo do Lançamento do Item Contábil");
		}

		if (valorLimiteDebito == null || valorLimiteDebito.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Valor Limite do Débito");
		}

		if (indicadorDebitoCartaoCredito == null
				|| indicadorDebitoCartaoCredito.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Indicador de Cartão de Crédito");
		}

		if (indicadorJurosParCliente == null
				|| indicadorJurosParCliente.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Juros de Contrato de Parcelamento por Cliente:");
		}

		DebitoTipo debitoTipo = new DebitoTipo();

		debitoTipo.setDescricao(descricao);

		if (descricaoAbreviada != null
				&& !descricaoAbreviada.equalsIgnoreCase("")) {
			debitoTipo.setDescricaoAbreviada(descricaoAbreviada);
		}
		debitoTipo.setIndicadorGeracaoAutomatica(new Short(
				indicadorGeracaoDebitoAutomatica));

		debitoTipo.setIndicadorGeracaoConta(new Short(
				indicadorGeracaoDebitoConta));

		if (idTipoFinanciamento != null
				&& !idTipoFinanciamento.trim().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {

			FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();

			financiamentoTipo.setId(new Integer(idTipoFinanciamento));

			debitoTipo.setFinanciamentoTipo(financiamentoTipo);

		}

		if (idLancamentoItemContabil != null
				&& !idLancamentoItemContabil.trim().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {

			LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();

			lancamentoItemContabil.setId(new Integer(idLancamentoItemContabil));

			debitoTipo.setLancamentoItemContabil(lancamentoItemContabil);

		}

		// valor Limite Debito
		BigDecimal valor;

		String valorDebito = valorLimiteDebito.toString().replace(".", "");

		valorDebito = valorDebito.replace(",", ".");

		valor = new BigDecimal(valorDebito);

		debitoTipo.setValorLimite(valor);

		// valor Sugerido
		if (valorSugerido != null && !valorSugerido.equals("")) {
			BigDecimal valorSug;

			String valorDebitoSug = valorSugerido.toString().replace(".", "");

			valorDebitoSug = valorDebitoSug.replace(",", ".");

			valorSug = new BigDecimal(valorDebitoSug);

			debitoTipo.setValorSugerido(valorSug);
		}

		debitoTipo.setIndicadorDebitoCartaoCredito(new Short(
				indicadorDebitoCartaoCredito));

		debitoTipo.setIndicadorJurosParCliente(new Short(
				indicadorJurosParCliente));

		debitoTipo.setIndicadorUso(ConstantesSistema.INDICADOR_USO_ATIVO);

		debitoTipo.setUltimaAlteracao(new Date());

		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();

		// verifica se ja existe a descricao informada na base e exibe uma
		// critica.

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.DESCRICAO, debitoTipo.getDescricao()));

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.INDICADOR_USO,
				ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection colecaoDebitoTipoDescricao = getControladorUtil().pesquisar(
				filtroDebitoTipo, DebitoTipo.class.getName());

		if (colecaoDebitoTipoDescricao != null
				&& !colecaoDebitoTipoDescricao.isEmpty()) {
			throw new ControladorException(
					"atencao.descricao_tipo_debito_ja_existente", null, ""
							+ debitoTipo.getDescricao() + "");
		}

		// verifica se ja existe a descricaoAbreviada informada na base e exibe
		// uma
		// critica.
		if (debitoTipo.getDescricaoAbreviada() != null) {

			if (!debitoTipo.getDescricaoAbreviada().equalsIgnoreCase("")) {

				filtroDebitoTipo.adicionarParametro(new ParametroSimples(
						FiltroDebitoTipo.DESCRICAO_ABREVIADA, debitoTipo
								.getDescricaoAbreviada()));

				filtroDebitoTipo.adicionarParametro(new ParametroSimples(
						FiltroDebitoTipo.INDICADOR_USO,
						ConstantesSistema.INDICADOR_USO_ATIVO));

				Collection colecaoDebitoTipoDescricaoAbreviada = getControladorUtil()
						.pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if (colecaoDebitoTipoDescricaoAbreviada != null
						&& !colecaoDebitoTipoDescricaoAbreviada.isEmpty()) {
					throw new ControladorException(
							"atencao.descricao_abreviada_tipo_debito_ja_existente",
							null, "" + debitoTipo.getDescricaoAbreviada() + "");
				}
			}
		}
		retorno = (Integer) getControladorUtil().inserir(debitoTipo);

		return retorno;

	}

	/**
	 * Atualizar o tipo de debito na base
	 * 
	 * [UC0530] Atualizar Tipo de Débito
	 * 
	 * 
	 * @author Rômulo Aurélio
	 * @date 15/03/2007
	 * 
	 * @param id
	 * @param descricao
	 * @param descricaoAbreviada
	 * @param idTipoFinanciamento
	 * @param indicadorGeracaoDebitoAutomatica
	 * @param indicadorGeracaoDebitoConta
	 * @param idLancamentoItemContabil
	 * @param valorLimeteDebito
	 * @param usuarioLogado
	 * @return
	 */

	public void atualizarDebitoTipo(DebitoTipo debitoTipo, String id,
			String descricao, String descricaoAbreviada,
			String idTipoFinanciamento,
			String indicadorGeracaoDebitoAutomatica,
			String indicadorGeracaoDebitoConta,
			String idLancamentoItemContabil, String valorLimiteDebito,
			String indicadorUso, Usuario usuarioLogado, String valorSugerido,
			String indicadorDebitoCartaoCredito, String indicadorJurosParCliente)
			throws ControladorException {

		if (descricao == null || descricao.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Descrição do Tipo de Débito");
		}

		if (idTipoFinanciamento == null
				|| idTipoFinanciamento.trim().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Tipo de Financiamento");
		}

		if (indicadorGeracaoDebitoAutomatica == null
				|| indicadorGeracaoDebitoAutomatica.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Indicador de Geração do Débito Automática");
		}

		if (indicadorGeracaoDebitoConta == null
				|| indicadorGeracaoDebitoConta.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Indicador de Geração do Débito em Conta");
		}

		if (idLancamentoItemContabil == null
				|| idLancamentoItemContabil.trim().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Tipo do Lançamento do Item Contábil");
		}

		if (valorLimiteDebito == null || valorLimiteDebito.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Valor Limite do Débito");
		}

		if (indicadorDebitoCartaoCredito == null
				|| indicadorDebitoCartaoCredito.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Indicador de Cartão de Crédito");
		}

		if (indicadorJurosParCliente == null
				|| indicadorJurosParCliente.equalsIgnoreCase("")) {
			throw new ControladorException(
					"atencao.campo_selecionado.obrigatorio", null,
					"Juros de Contrato de Parcelamento por Cliente");
		}

		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();

		// verifica se ja existe a descricao informada na base e exibe uma
		// critica.

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.DESCRICAO, descricao));

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.INDICADOR_USO,
				ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection colecaoDebitoTipoDescricao = getControladorUtil().pesquisar(
				filtroDebitoTipo, DebitoTipo.class.getName());

		if (colecaoDebitoTipoDescricao != null
				&& !colecaoDebitoTipoDescricao.isEmpty()) {
			DebitoTipo debitoTipoDescricao = (DebitoTipo) colecaoDebitoTipoDescricao
					.iterator().next();

			if (debitoTipoDescricao.getId().intValue() != debitoTipo.getId()
					.intValue()) {

				throw new ControladorException(
						"atencao.descricao_tipo_debito_ja_existente", null, ""
								+ descricao + "");
			}
		}

		// verifica se ja existe a descricaoAbreviada informada na base e exibe
		// uma
		// critica.
		if (descricaoAbreviada != null) {

			if (!descricaoAbreviada.equalsIgnoreCase("")) {

				filtroDebitoTipo.adicionarParametro(new ParametroSimples(
						FiltroDebitoTipo.DESCRICAO_ABREVIADA,
						descricaoAbreviada));

				filtroDebitoTipo.adicionarParametro(new ParametroSimples(
						FiltroDebitoTipo.INDICADOR_USO,
						ConstantesSistema.INDICADOR_USO_ATIVO));

				Collection colecaoDebitoTipoDescricaoAbreviada = getControladorUtil()
						.pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if (colecaoDebitoTipoDescricaoAbreviada != null
						&& !colecaoDebitoTipoDescricaoAbreviada.isEmpty()) {
					DebitoTipo debitoTipoDescricaoAbreviada = (DebitoTipo) colecaoDebitoTipoDescricaoAbreviada
							.iterator().next();

					if (debitoTipoDescricaoAbreviada.getId().intValue() != debitoTipo
							.getId().intValue()) {

						throw new ControladorException(
								"atencao.descricao_abreviada_tipo_debito_ja_existente",
								null, "" + descricaoAbreviada + "");
					}
				}
			}
		}

		debitoTipo.setDescricao(descricao);

		if (descricaoAbreviada != null
				&& !descricaoAbreviada.equalsIgnoreCase("")) {
			debitoTipo.setDescricaoAbreviada(descricaoAbreviada);
		}
		debitoTipo.setIndicadorGeracaoAutomatica(new Short(
				indicadorGeracaoDebitoAutomatica));

		debitoTipo.setIndicadorGeracaoConta(new Short(
				indicadorGeracaoDebitoConta));

		if (idTipoFinanciamento != null
				&& !idTipoFinanciamento.trim().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {

			FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();

			financiamentoTipo.setId(new Integer(idTipoFinanciamento));

			debitoTipo.setFinanciamentoTipo(financiamentoTipo);

		}

		if (idLancamentoItemContabil != null
				&& !idLancamentoItemContabil.trim().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {

			LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();

			lancamentoItemContabil.setId(new Integer(idLancamentoItemContabil));

			debitoTipo.setLancamentoItemContabil(lancamentoItemContabil);

		}

		// valor Limite Debito
		BigDecimal valor;

		String valorDebito = valorLimiteDebito.toString().replace(".", "");

		valorDebito = valorDebito.replace(",", ".");

		valor = new BigDecimal(valorDebito);

		debitoTipo.setValorLimite(valor);

		// valor sugerido
		BigDecimal valorDebSug;

		if (valorSugerido != null && !valorSugerido.equals("")) {
			String valorSug = valorSugerido.toString().replace(".", "");

			valorSug = valorSug.replace(",", ".");

			valorDebSug = new BigDecimal(valorSug);

			debitoTipo.setValorSugerido(valorDebSug);
		}

		debitoTipo.setIndicadorDebitoCartaoCredito(new Short(
				indicadorDebitoCartaoCredito));

		debitoTipo.setIndicadorJurosParCliente(new Short(
				indicadorJurosParCliente));

		debitoTipo.setIndicadorUso(new Short(indicadorUso));

		debitoTipo.setUltimaAlteracao(new Date());

		// Verifica Atualização realizada por outro usuário

		filtroDebitoTipo.limparListaParametros();

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(
				FiltroDebitoTipo.ID, debitoTipo.getId()));

		Collection colecaoDebitoTipoBase = getControladorUtil().pesquisar(
				filtroDebitoTipo, DebitoTipo.class.getName());

		if (colecaoDebitoTipoBase == null || colecaoDebitoTipoBase.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		DebitoTipo debitoTipoBase = (DebitoTipo) colecaoDebitoTipoBase
				.iterator().next();

		if (debitoTipoBase.getUltimaAlteracao().after(
				debitoTipo.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		debitoTipo.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSação----------------------------

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_TIPO_DEBITO_ATUALIZAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_TIPO_DEBITO_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		debitoTipo.setOperacaoEfetuada(operacaoEfetuada);
		debitoTipo.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(debitoTipo);

		// --------FIM---- REGISTRAR TRANSação----------------------------
		getControladorUtil().atualizar(debitoTipo);

	}

	/**
	 * Determina qual a menor data de vencimento para uma coleção de contas
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 19/06/2007
	 * 
	 * @param colecaoContas
	 * @return
	 * @throws ControladorException
	 */
	public Date determinarMenorDataVencimentoConta(Collection colecaoContas)
			throws ControladorException {

		Date dataVencimentoConta = null;
		if (colecaoContas != null && !colecaoContas.isEmpty()) {
			Iterator<Conta> iteratorContas = colecaoContas.iterator();

			while (iteratorContas.hasNext()) {
				Conta conta = iteratorContas.next();

				if (dataVencimentoConta == null) {
					dataVencimentoConta = conta.getDataVencimentoConta();
				} else {
					if (dataVencimentoConta.compareTo(conta
							.getDataVencimentoConta()) > 0) {
						dataVencimentoConta = conta.getDataVencimentoConta();
					}
				}
			}
		}
		return dataVencimentoConta;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 18/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioEstadoPorUnidadeNegocio(
			int anoMesReferencia, String opcaoRelatorio)
			throws ControladorException {

		Collection colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio = new ArrayList();
		Collection retorno = new ArrayList();

		try {
			colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio = repositorioFaturamento
					.consultarResumoFaturamentoRelatorioEstadoPorUnidadeNegocio(
							anoMesReferencia, opcaoRelatorio);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio
				.iterator();

		// Prepara cada linha do relatório
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String descMunicipioAnterior = null;
		String codigoCentroCusto = null;
		String idLocalidadeAnterior = null;
		String idMunicipioAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while (iterator.hasNext()) {
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if (tipoLancamento == null) {
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					// se for agrupado por gerencia
					// compara se o registro atual eh da
					// mesma gerencia regional do registro anterior

					switch (((Integer) element[8]).intValue()) {
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
					}

				} else {

					condicaoIgual = false;
				}

			} else {

				condicaoIgual = false;

			}

			if (!condicaoIgual) {

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
						(BigDecimal[]) arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(Short) elementAnterior[4], (Short) elementAnterior[5],
						(Integer) elementAnterior[6],
						(Integer) elementAnterior[7], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, descMunicipioAnterior,
						idMunicipioAnterior, descLancamentoTipoSuperior,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
						codigoCentroCusto);

				retorno.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[8]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}

			}

			if (idGerenciaRegionalAnterior != null
					&& !idGerenciaRegionalAnterior.equals("" + element[14])) {
				// quebra por gerencia
				retorno = consultarResumoFaturamentoRelatorioPorGerenciaRegional(
						anoMesReferencia, new Integer(
								idGerenciaRegionalAnterior), retorno,
						opcaoRelatorio);
			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if (((String) element[1]).equalsIgnoreCase((String) element[2])) {
				elementAnterior[2] = null; // descricaoItemLancamento
			} else {
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			descUnidadeNegocioAnterior = "" + element[9];
			idUnidadeNegocioAnterior = "" + element[10];

			descGerenciaRegionalAnterior = "" + element[13];
			idGerenciaRegionalAnterior = "" + element[14];

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio != null
				&& !colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio
						.isEmpty()) {
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
					(BigDecimal[]) arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(Short) elementAnterior[4], (Short) elementAnterior[5],
					(Integer) elementAnterior[6], (Integer) elementAnterior[7],
					false, descGerenciaRegionalAnterior,
					idGerenciaRegionalAnterior, descLocalidadeAnterior,
					idLocalidadeAnterior, descMunicipioAnterior,
					idMunicipioAnterior, descLancamentoTipoSuperior,
					descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
					codigoCentroCusto);

			retorno.add(resumoFaturamentoRelatorioHelper);

			retorno = consultarResumoFaturamentoRelatorioPorGerenciaRegional(
					anoMesReferencia, new Integer(idGerenciaRegionalAnterior),
					retorno, opcaoRelatorio);

		}

		return retorno;

	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 18/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorGerenciaRegional(
			int anoMesReferencia, Integer idGerenciaRegional,
			Collection colecaoResumoFaturamentoRelatorio, String opcaoRelatorio)
			throws ControladorException {

		Collection colecaoResumoFaturamentoRelatorioPorGerenciaRegional = new ArrayList();

		try {
			colecaoResumoFaturamentoRelatorioPorGerenciaRegional = repositorioFaturamento
					.consultarResumoFaturamentoRelatorioPorGerenciaRegional(
							anoMesReferencia, idGerenciaRegional,
							opcaoRelatorio);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iteratorResumoFaturamentoRelatorioPorGerenciaRegional = colecaoResumoFaturamentoRelatorioPorGerenciaRegional
				.iterator();

		// Prepara cada linha do relatório
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String descMunicipioAnterior = null;
		String codigoCentroCusto = null;
		String idLocalidadeAnterior = null;
		String idMunicipioAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		Boolean agrupaPorGerencia = true;

		while (iteratorResumoFaturamentoRelatorioPorGerenciaRegional.hasNext()) {
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iteratorResumoFaturamentoRelatorioPorGerenciaRegional
					.next();

			if (tipoLancamento == null) {
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					// se for agrupado por gerencia
					// compara se o registro atual eh da
					// mesma gerencia regional do registro anterior
					if (!agrupaPorGerencia
							|| descGerenciaRegionalAnterior == null
							|| (agrupaPorGerencia && descGerenciaRegionalAnterior
									.equalsIgnoreCase((String) element[9]))) {

						switch (((Integer) element[8]).intValue()) {
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
						}
					} else {
						condicaoIgual = false;
					}

				} else {

					condicaoIgual = false;
				}

			} else {

				condicaoIgual = false;

			}

			if (!condicaoIgual) {

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
						(BigDecimal[]) arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(Short) elementAnterior[4], (Short) elementAnterior[5],
						(Integer) elementAnterior[6],
						(Integer) elementAnterior[7], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, descMunicipioAnterior,
						idMunicipioAnterior, descLancamentoTipoSuperior,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
						codigoCentroCusto);

				colecaoResumoFaturamentoRelatorio
						.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[8]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if (((String) element[1]).equalsIgnoreCase((String) element[2])) {
				elementAnterior[2] = null; // descricaoItemLancamento
			} else {
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			descGerenciaRegionalAnterior = "" + element[9];
			idGerenciaRegionalAnterior = "" + element[10];

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoFaturamentoRelatorioPorGerenciaRegional != null
				&& !colecaoResumoFaturamentoRelatorioPorGerenciaRegional
						.isEmpty()) {
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
					(BigDecimal[]) arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(Short) elementAnterior[4], (Short) elementAnterior[5],
					(Integer) elementAnterior[6], (Integer) elementAnterior[7],
					false, descGerenciaRegionalAnterior,
					idGerenciaRegionalAnterior, descLocalidadeAnterior,
					idLocalidadeAnterior, descMunicipioAnterior,
					idMunicipioAnterior, descLancamentoTipoSuperior,
					descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
					codigoCentroCusto);

			colecaoResumoFaturamentoRelatorio
					.add(resumoFaturamentoRelatorioHelper);
		}

		return colecaoResumoFaturamentoRelatorio;

	}

	/**
	 * Remove os contratos de demanda selecionados pelo usuário
	 * 
	 * [UC0513] - Manter Contrato de Demanda
	 * 
	 * @author Rafael Corrêa
	 * @date 27/06/2007
	 * 
	 * @param idsContratosDemanda
	 * @throws ControladorException
	 */
	public void removerContratosDemanda(String[] idsContratosDemanda,
			Usuario usuarioLogado) throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_CONTRATO_DEMANDA_REMOVER,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CONTRATO_DEMANDA_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		if (idsContratosDemanda != null && idsContratosDemanda.length > 0) {
			for (int i = 0; i < idsContratosDemanda.length; i++) {
				String idContratoDemanda = idsContratosDemanda[i];

				// Cria o filtro de equipe para verificar se a equipe ja foi
				// removida
				FiltroContratoDemanda filtroContratoDemanda = new FiltroContratoDemanda();

				filtroContratoDemanda.adicionarParametro(new ParametroSimples(
						FiltroContratoDemanda.ID, idContratoDemanda));

				Collection colecaoContratoDemanda = getControladorUtil()
						.pesquisar(filtroContratoDemanda,
								ContratoDemanda.class.getSimpleName());

				if (colecaoContratoDemanda != null
						&& !colecaoContratoDemanda.isEmpty()) {

					ContratoDemanda contratoDemanda = (ContratoDemanda) Util
							.retonarObjetoDeColecao(colecaoContratoDemanda);

					// ------------ REGISTRAR TRANSAÇÃO ----------------
					contratoDemanda.setOperacaoEfetuada(operacaoEfetuada);
					contratoDemanda.adicionarUsuario(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					registradorOperacao.registrarOperacao(contratoDemanda);
					// ------------ REGISTRAR TRANSAÇÃO ----------------

					getControladorUtil().remover(contratoDemanda);

				} else {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.registro_remocao_nao_existente");
				}

			}
		}
	}

	/**
	 * Obter a data de vencimento de um grupo de faturamento, no mês de
	 * faturamento corrente.
	 * 
	 * [UC0618] Obter data de vencimento do grupo
	 * 
	 * @author Pedro Alexandre
	 * @date 26/06/2007
	 * 
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ControladorException
	 */
	public Date obterDataVencimentoGrupo(Integer idFaturamentoGrupo,
			Integer anoMesInformado) throws ControladorException {
		SimpleDateFormat formatoData = new SimpleDateFormat("dd/MM/yyyy");
		Date retorno = null;

		// Recupera o grupo de faturamento informado
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
				FiltroFaturamentoGrupo.ID, idFaturamentoGrupo));
		Collection colecaoFaturamentoGrupo = getControladorUtil().pesquisar(
				filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());
		FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) Util
				.retonarObjetoDeColecao(colecaoFaturamentoGrupo);

		Integer anoMesReferencia = null;

		// Caso tenha sido chamado o este método na funcionalidade de
		// Inserir Cronograma do faturamento
		if (anoMesInformado != null) {
			anoMesReferencia = anoMesInformado;
		}

		/**
		 * Caso o indicador de que o vencimento do grupo é igual ao ano/mês do
		 * faturamento corresponda a SIM, formatar a data de vencimento a partir
		 * do ano/mês de referência do faturamento e do dia de vencimento do
		 * grupo. Caso contrário , formatar a apartir do mês seguinte ao mês de
		 * referência do faturamento e do dia de vencimento do grupo.
		 */
		if (faturamentoGrupo.getIndicadorVencimentoMesFatura().equals(
				ConstantesSistema.SIM)) {
			if (anoMesReferencia == null) {
				anoMesReferencia = faturamentoGrupo.getAnoMesReferencia();
			}
		} else {
			anoMesReferencia = Util.somaMesAnoMesReferencia(
					faturamentoGrupo.getAnoMesReferencia(), 1);
		}

		try {
			// Recupera o dia de vencimento do grupo
			int diaVencimento = faturamentoGrupo.getDiaVencimento().intValue();
			String mesVencimento = String.valueOf(anoMesReferencia).substring(
					4, 6);
			String anoVencimento = String.valueOf(anoMesReferencia).substring(
					0, 4);

			retorno = formatoData.parse(diaVencimento + "/" + mesVencimento
					+ "/" + anoVencimento);
		} catch (ParseException ex) {
			throw new ActionServletException("errors.date", null,
					"Data vencimento");
		}

		return retorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * @author Raphael Rossiter
	 * @date 29/06/2007
	 * 
	 * @param consumoTarifa
	 * @param dataFaturamento
	 * @throws ErroRepositorioException
	 */
	public ConsumoTarifaVigencia pesquisarConsumoTarifaVigenciaMenorOUIgualDataFaturamento(
			Integer idConsumoTarifa, Date dataFaturamento)
			throws ControladorException {

		ConsumoTarifaVigencia consumoTarifaVigencia = null;

		try {

			consumoTarifaVigencia = repositorioFaturamento
					.pesquisarConsumoTarifaVigenciaMenorOUIgualDataFaturamento(
							idConsumoTarifa, dataFaturamento);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return consumoTarifaVigencia;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstadoPorLocalidade(
			int anoMesReferencia, String opcaoRelatorio)
			throws ControladorException {

		Collection colecaoResumoFaturamentoRelatorioEstadoPorLocalidade = new ArrayList();
		Collection retorno = new ArrayList();

		try {
			colecaoResumoFaturamentoRelatorioEstadoPorLocalidade = repositorioFaturamento
					.consultarResumoFaturamentoRelatorioPorEstadoPorLocalidade(
							anoMesReferencia, opcaoRelatorio);

			if (colecaoResumoFaturamentoRelatorioEstadoPorLocalidade != null
					&& !colecaoResumoFaturamentoRelatorioEstadoPorLocalidade
							.isEmpty()) {

				Iterator iterator = colecaoResumoFaturamentoRelatorioEstadoPorLocalidade
						.iterator();

				// Prepara cada linha do relatório

				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String descMunicipioAnterior = null;
				String idLocalidadeAnterior = null;
				String idMunicipioAnterior = null;
				String descLancamentoTipoSuperior = "";
				String codigoCentroCustoAnterior = null;
				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				while (iterator.hasNext()) {
					Object[] element = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;
					String codigoCentroCusto = null;

					element = (Object[]) iterator.next();

					if (tipoLancamento == null) {
						tipoLancamento = (String) element[1];
						itemLancamento = (String) element[2];
						itemContabel = (String) element[3];
					}

					tempTipoLancamento = (String) element[1];
					tempItemLancamento = (String) element[2];
					tempItemContabel = (String) element[3];

					codigoCentroCusto = (String) element[17];

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if (tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)) {

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if (itemContabel == null
								&& tempItemContabel == null
								|| (itemContabel != null
										&& tempItemContabel != null && itemContabel
											.equals(tempItemContabel))) {

							switch (((Integer) element[8]).intValue()) {
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
							}

						} else {

							condicaoIgual = false;
						}

					} else {

						condicaoIgual = false;

					}

					if (!condicaoIgual) {

						ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
								(BigDecimal[]) arrayValores,
								(String) elementAnterior[1],
								(String) elementAnterior[2],
								(String) elementAnterior[3],
								(Short) elementAnterior[4],
								(Short) elementAnterior[5],
								(Integer) elementAnterior[6],
								(Integer) elementAnterior[7], false,
								descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior,
								descLocalidadeAnterior, idLocalidadeAnterior,
								descMunicipioAnterior, idMunicipioAnterior,
								descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior,
								idUnidadeNegocioAnterior,
								codigoCentroCustoAnterior);

						retorno.add(resumoFaturamentoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch (((Integer) element[8]).intValue()) {
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
						}

					}

					if (idUnidadeNegocioAnterior != null
							&& !idUnidadeNegocioAnterior.equals(""
									+ element[16])) {
						// quebra por Unidade Negocio
						retorno = consultarResumoFaturamentoRelatorioPorUnidadeNegocio(
								anoMesReferencia, new Integer(
										idUnidadeNegocioAnterior), retorno,
								opcaoRelatorio);

					}

					if (idGerenciaRegionalAnterior != null
							&& !idGerenciaRegionalAnterior.equals(""
									+ element[10])) {
						// quebra por gerencia
						retorno = consultarResumoFaturamentoRelatorioPorGerenciaRegional(
								anoMesReferencia, new Integer(
										idGerenciaRegionalAnterior), retorno,
								opcaoRelatorio);

					}

					elementAnterior[1] = element[1]; // descricaoTipoLancamento
					if (((String) element[1])
							.equalsIgnoreCase((String) element[2])) {
						elementAnterior[2] = null; // descricaoItemLancamento
					} else {
						elementAnterior[2] = element[2]; // descricaoItemLancamento
					}

					elementAnterior[3] = element[3]; // descricaoItemContabil
					elementAnterior[4] = element[4]; // indicadorImpressao
					elementAnterior[5] = element[5]; // indicadorTotal
					elementAnterior[6] = element[6]; // lancamentoTipo
					elementAnterior[7] = element[7]; // lancamentoTipoSuperior
					codigoCentroCustoAnterior = codigoCentroCusto;
					descGerenciaRegionalAnterior = "" + element[9];
					idGerenciaRegionalAnterior = "" + element[10];
					descLocalidadeAnterior = "" + element[11];
					idLocalidadeAnterior = "" + element[12];
					descUnidadeNegocioAnterior = "" + element[15];
					idUnidadeNegocioAnterior = "" + element[16];

					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;

				}

				if (colecaoResumoFaturamentoRelatorioEstadoPorLocalidade != null
						&& !colecaoResumoFaturamentoRelatorioEstadoPorLocalidade
								.isEmpty()) {
					// adiciona a ultima linha

					ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
							(BigDecimal[]) arrayValores,
							(String) elementAnterior[1],
							(String) elementAnterior[2],
							(String) elementAnterior[3],
							(Short) elementAnterior[4],
							(Short) elementAnterior[5],
							(Integer) elementAnterior[6],
							(Integer) elementAnterior[7], false,
							descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior,
							idLocalidadeAnterior, descMunicipioAnterior,
							idMunicipioAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior,
							idUnidadeNegocioAnterior, codigoCentroCustoAnterior);

					retorno.add(resumoFaturamentoRelatorioHelper);

					retorno = consultarResumoFaturamentoRelatorioPorUnidadeNegocio(
							anoMesReferencia, new Integer(
									idUnidadeNegocioAnterior), retorno,
							opcaoRelatorio);

					retorno = consultarResumoFaturamentoRelatorioPorGerenciaRegional(
							anoMesReferencia, new Integer(
									idGerenciaRegionalAnterior), retorno,
							opcaoRelatorio);

					retorno = consultarResumoFaturamentoRelatorioPorEstado(
							anoMesReferencia, retorno, opcaoRelatorio, false);
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Diogo Peixoto
	 * @date 25/04/2011
	 * 
	 * @param anoMesReferencia
	 * @param opcaoRelatorio
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstadoPorMunicipio(
			int anoMesReferencia, String opcaoRelatorio)
			throws ControladorException {

		Collection colecaoResFatuRelatEstadoPorMunicipio = new ArrayList();
		Collection retorno = new ArrayList();

		try {
			colecaoResFatuRelatEstadoPorMunicipio = this.repositorioFaturamento
					.consultarResumoFaturamentoRelatorioPorEstadoPorMunicipio(
							anoMesReferencia, opcaoRelatorio);

			if (colecaoResFatuRelatEstadoPorMunicipio != null
					&& !colecaoResFatuRelatEstadoPorMunicipio.isEmpty()) {

				Iterator iterator = colecaoResFatuRelatEstadoPorMunicipio
						.iterator();

				// Prepara cada linha do relatório

				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String descMunicipioAnterior = null;
				String idLocalidadeAnterior = null;
				String idMunicipioAnterior = null;
				String descLancamentoTipoSuperior = "";
				String codigoCentroCustoAnterior = null;
				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				while (iterator.hasNext()) {
					Object[] element = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;

					element = (Object[]) iterator.next();

					if (tipoLancamento == null) {
						tipoLancamento = (String) element[1];
						itemLancamento = (String) element[2];
						itemContabel = (String) element[3];
					}

					tempTipoLancamento = (String) element[1];
					tempItemLancamento = (String) element[2];
					tempItemContabel = (String) element[3];

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if (tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)) {

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if (itemContabel == null
								&& tempItemContabel == null
								|| (itemContabel != null
										&& tempItemContabel != null && itemContabel
											.equals(tempItemContabel))) {

							switch (((Integer) element[8]).intValue()) {
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
							}

						} else {
							condicaoIgual = false;
						}

					} else {
						condicaoIgual = false;
					}

					if (!condicaoIgual) {

						ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
								(BigDecimal[]) arrayValores,
								(String) elementAnterior[1],
								(String) elementAnterior[2],
								(String) elementAnterior[3],
								(Short) elementAnterior[4],
								(Short) elementAnterior[5],
								(Integer) elementAnterior[6],
								(Integer) elementAnterior[7], false,
								descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior,
								descLocalidadeAnterior, idLocalidadeAnterior,
								descMunicipioAnterior, idMunicipioAnterior,
								descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior,
								idUnidadeNegocioAnterior,
								codigoCentroCustoAnterior);

						retorno.add(resumoFaturamentoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch (((Integer) element[8]).intValue()) {
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
						}

					}

					if (idMunicipioAnterior != null
							&& !idMunicipioAnterior.equals(String
									.valueOf((Integer) element[12]))) {
						// quebra por Unidade Negocio
						retorno = consultarResumoFaturamentoRelatorioPorMunicipio(
								anoMesReferencia, new Integer(
										idMunicipioAnterior), retorno,
								opcaoRelatorio);
					}

					elementAnterior[1] = element[1]; // descricaoTipoLancamento
					if (((String) element[1])
							.equalsIgnoreCase((String) element[2])) {
						elementAnterior[2] = null; // descricaoItemLancamento
					} else {
						elementAnterior[2] = element[2]; // descricaoItemLancamento
					}

					elementAnterior[3] = element[3]; // descricaoItemContabil
					elementAnterior[4] = element[4]; // indicadorImpressao
					elementAnterior[5] = element[5]; // indicadorTotal
					elementAnterior[6] = element[6]; // lancamentoTipo
					elementAnterior[7] = element[7]; // lancamentoTipoSuperior
					descLocalidadeAnterior = (String) element[9];
					idLocalidadeAnterior = String
							.valueOf((Integer) element[10]);
					descMunicipioAnterior = (String) element[11];
					idMunicipioAnterior = String.valueOf((Integer) element[12]);

					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;

				}

				if (colecaoResFatuRelatEstadoPorMunicipio != null
						&& !colecaoResFatuRelatEstadoPorMunicipio.isEmpty()) {
					// adiciona a ultima linha

					ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
							(BigDecimal[]) arrayValores,
							(String) elementAnterior[1],
							(String) elementAnterior[2],
							(String) elementAnterior[3],
							(Short) elementAnterior[4],
							(Short) elementAnterior[5],
							(Integer) elementAnterior[6],
							(Integer) elementAnterior[7], false,
							descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior,
							idLocalidadeAnterior, descMunicipioAnterior,
							idMunicipioAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior,
							idUnidadeNegocioAnterior, codigoCentroCustoAnterior);

					retorno.add(resumoFaturamentoRelatorioHelper);

					retorno = consultarResumoFaturamentoRelatorioPorMunicipio(
							anoMesReferencia, new Integer(idMunicipioAnterior),
							retorno, opcaoRelatorio);

					retorno = consultarResumoFaturamentoRelatorioPorEstado(
							anoMesReferencia, retorno, opcaoRelatorio, true);
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorUnidadeNegocio(
			int anoMesReferencia, Integer idUnidadeNegocio,
			Collection colecaoResumoFaturamentoRelatorio, String opcaoRelatorio)
			throws ControladorException {

		Collection colecaoResumoFaturamentoRelatorioPorUnidadeNegocio = new ArrayList();

		try {
			colecaoResumoFaturamentoRelatorioPorUnidadeNegocio = repositorioFaturamento
					.consultarResumoFaturamentoRelatorioPorUnidadeNegocio(
							anoMesReferencia, idUnidadeNegocio, opcaoRelatorio);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoFaturamentoRelatorioPorUnidadeNegocio
				.iterator();

		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String descMunicipioAnterior = null;
		String codigoCentroCusto = null;
		String idLocalidadeAnterior = null;
		String idMunicipioAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while (iterator.hasNext()) {
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if (tipoLancamento == null) {
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					switch (((Integer) element[8]).intValue()) {
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
					}

				} else {

					condicaoIgual = false;
				}

			} else {

				condicaoIgual = false;

			}

			if (!condicaoIgual) {

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
						(BigDecimal[]) arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(Short) elementAnterior[4], (Short) elementAnterior[5],
						(Integer) elementAnterior[6],
						(Integer) elementAnterior[7], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, descMunicipioAnterior,
						idMunicipioAnterior, descLancamentoTipoSuperior,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
						codigoCentroCusto);

				colecaoResumoFaturamentoRelatorio
						.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[8]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if (((String) element[1]).equalsIgnoreCase((String) element[2])) {
				elementAnterior[2] = null; // descricaoItemLancamento
			} else {
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			descGerenciaRegionalAnterior = "" + element[13];
			idGerenciaRegionalAnterior = "" + element[14];
			descUnidadeNegocioAnterior = "" + element[9];
			idUnidadeNegocioAnterior = "" + element[10];

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoFaturamentoRelatorio != null
				&& !colecaoResumoFaturamentoRelatorio.isEmpty()) {
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
					(BigDecimal[]) arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(Short) elementAnterior[4], (Short) elementAnterior[5],
					(Integer) elementAnterior[6], (Integer) elementAnterior[7],
					false, descGerenciaRegionalAnterior,
					idGerenciaRegionalAnterior, descLocalidadeAnterior,
					idLocalidadeAnterior, descMunicipioAnterior,
					idMunicipioAnterior, descLancamentoTipoSuperior,
					descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
					codigoCentroCusto);

			colecaoResumoFaturamentoRelatorio
					.add(resumoFaturamentoRelatorioHelper);
		}

		return colecaoResumoFaturamentoRelatorio;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Diogo Peixoto
	 * @date 25/04/2011
	 * 
	 * @param anoMesReferencia
	 * @param idMunicipio
	 * @param colecaoResumoFaturamentoRelatorio
	 * @param opcaoRelatorio
	 * 
	 * @return consultarResumoFaturamentoRelatorioPorMunicipio
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorMunicipio(
			int anoMesReferencia, Integer idMunicipio,
			Collection colecaoResumoFaturamentoRelatorio, String opcaoRelatorio)
			throws ControladorException {

		Collection colecaoResuFatuRelatPorMunicipio = new ArrayList();

		try {
			colecaoResuFatuRelatPorMunicipio = repositorioFaturamento
					.consultarResumoFaturamentoRelatorioPorMunicipio(
							anoMesReferencia, idMunicipio, opcaoRelatorio);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResuFatuRelatPorMunicipio.iterator();

		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String descMunicipioAnterior = null;
		String codigoCentroCusto = null;
		String idLocalidadeAnterior = null;
		String idMunicipioAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while (iterator.hasNext()) {
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if (tipoLancamento == null) {
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					switch (((Integer) element[8]).intValue()) {
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
					}

				} else {
					condicaoIgual = false;
				}

			} else {
				condicaoIgual = false;
			}

			if (!condicaoIgual) {

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
						(BigDecimal[]) arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(Short) elementAnterior[4], (Short) elementAnterior[5],
						(Integer) elementAnterior[6],
						(Integer) elementAnterior[7], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, descMunicipioAnterior,
						idMunicipioAnterior, descLancamentoTipoSuperior,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
						codigoCentroCusto);

				colecaoResumoFaturamentoRelatorio
						.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[8]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}
			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if (((String) element[1]).equalsIgnoreCase((String) element[2])) {
				elementAnterior[2] = null; // descricaoItemLancamento
			} else {
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			descMunicipioAnterior = (String) element[9];
			idMunicipioAnterior = String.valueOf((Integer) element[10]);

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoFaturamentoRelatorio != null
				&& !colecaoResumoFaturamentoRelatorio.isEmpty()) {
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
					(BigDecimal[]) arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(Short) elementAnterior[4], (Short) elementAnterior[5],
					(Integer) elementAnterior[6], (Integer) elementAnterior[7],
					false, descGerenciaRegionalAnterior,
					idGerenciaRegionalAnterior, descLocalidadeAnterior,
					idLocalidadeAnterior, descMunicipioAnterior,
					idMunicipioAnterior, descLancamentoTipoSuperior,
					descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
					codigoCentroCusto);

			colecaoResumoFaturamentoRelatorio
					.add(resumoFaturamentoRelatorioHelper);
		}
		return colecaoResumoFaturamentoRelatorio;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 27/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstado(
			int anoMesReferencia, Collection colecaoResumoFaturamentoRelatorio,
			String opcaoRelatorio, boolean estadoMunicipio)
			throws ControladorException {

		Collection colecaoResumoFaturamentoRelatorioPorEstado = new ArrayList();

		try {
			colecaoResumoFaturamentoRelatorioPorEstado = repositorioFaturamento
					.consultarResumoFaturamentoRelatorioPorEstado(
							anoMesReferencia, opcaoRelatorio, estadoMunicipio);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoFaturamentoRelatorioPorEstado
				.iterator();

		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String descMunicipioAnterior = null;
		String codigoCentroCusto = null;
		String idLocalidadeAnterior = null;
		String idMunicipioAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while (iterator.hasNext()) {
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if (tipoLancamento == null) {
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					switch (((Integer) element[8]).intValue()) {
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
					}

				} else {

					condicaoIgual = false;
				}

			} else {

				condicaoIgual = false;

			}

			if (!condicaoIgual) {

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
						(BigDecimal[]) arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(Short) elementAnterior[4], (Short) elementAnterior[5],
						(Integer) elementAnterior[6],
						(Integer) elementAnterior[7], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, descMunicipioAnterior,
						idMunicipioAnterior, descLancamentoTipoSuperior,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
						codigoCentroCusto);

				colecaoResumoFaturamentoRelatorio
						.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[8]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if (((String) element[1]).equalsIgnoreCase((String) element[2])) {
				elementAnterior[2] = null; // descricaoItemLancamento
			} else {
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoFaturamentoRelatorioPorEstado != null
				&& !colecaoResumoFaturamentoRelatorioPorEstado.isEmpty()) {
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
					(BigDecimal[]) arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(Short) elementAnterior[4], (Short) elementAnterior[5],
					(Integer) elementAnterior[6], (Integer) elementAnterior[7],
					false, descGerenciaRegionalAnterior,
					idGerenciaRegionalAnterior, descLocalidadeAnterior,
					idLocalidadeAnterior, descMunicipioAnterior,
					idMunicipioAnterior, descLancamentoTipoSuperior,
					descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
					codigoCentroCusto);

			colecaoResumoFaturamentoRelatorio
					.add(resumoFaturamentoRelatorioHelper);
		}

		return colecaoResumoFaturamentoRelatorio;
	}

	/**
	 * 
	 * Metodo que retorna a data de revisão da conta
	 * 
	 * @author Vivianne Sousa
	 * @date 06/07/2007
	 * 
	 * @param idsConta
	 * @return
	 */
	public Collection pesquisarDataRevisaoConta(Collection idsConta)
			throws ControladorException {

		Collection colecaoContas = null;
		Collection colecaoRetorno = new ArrayList();
		try {
			colecaoContas = repositorioFaturamento
					.pesquisarDataRevisaoConta(idsConta);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		if (colecaoContas != null && !colecaoContas.isEmpty()) {

			Iterator contaIterator = colecaoContas.iterator();

			while (contaIterator.hasNext()) {

				Object[] parmsConta = (Object[]) contaIterator.next();

				if (parmsConta != null) {
					Conta conta = new Conta();
					if (parmsConta[0] != null) {
						conta.setId((Integer) parmsConta[0]);
					}
					if (parmsConta[1] != null) {
						conta.setDataRevisao((Date) parmsConta[1]);
					}
					if (parmsConta[2] != null) {
						Parcelamento parcelamento = new Parcelamento();
						parcelamento.setId((Integer) parmsConta[2]);
						conta.setParcelamento(parcelamento);
					}

					if (parmsConta[3] != null) {
						ContaMotivoRevisao contaMotivoRevisao = new ContaMotivoRevisao();
						contaMotivoRevisao.setId((Integer) parmsConta[3]);
						conta.setContaMotivoRevisao(contaMotivoRevisao);
					}

					colecaoRetorno.add(conta);
				}

			}
		}
		return colecaoRetorno;

	}

	/**
	 * [UC0146] - Manter Conta Author: Raphael Rossiter Data: 21/01/2006
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean verificarImoveisComDebito(Integer idImovel)
			throws ControladorException {

		boolean temDebito = false;
		try {
			Collection colecaoContas = repositorioFaturamento
					.obterIdsContasImovel(idImovel);

			if (colecaoContas != null && colecaoContas.size() > 3) {
				int qtdPagamentos = repositorioFaturamento
						.obterPagamentosContas(colecaoContas);

				if (colecaoContas.size() - qtdPagamentos > 3) {
					temDebito = true;
				}
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return temDebito;

	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoMetas(Integer anoMesReferencia)
			throws ControladorException {

		try {
			return repositorioFaturamento
					.pesquisarResumoMetas(anoMesReferencia);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * 
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoMetasAcumulado(Integer anoMesReferencia)
			throws ControladorException {

		try {
			return repositorioFaturamento
					.pesquisarResumoMetasAcumulado(anoMesReferencia);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0485] Gerar Resumo dos Devedores Duvidosos
	 * 
	 * @author Pedro Alexandre
	 * @date 27/07/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Short recuperarValorMaximoSequencialImpressaoMais10()
			throws ControladorException {

		try {
			return repositorioFaturamento
					.recuperarValorMaximoSequencialImpressaoMais10();

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	public void emitirContasOrgaoPublico(Integer anoMesReferenciaFaturamento,
			FaturamentoGrupo faturamentoGrupo, int idFuncionalidadeIniciada,
			int tipoConta, Integer idEmpresa,
			Short indicadorEmissaoExtratoFaturamento)
			throws ControladorException {

	}

	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 10/08/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualConta(Integer idImovel,
			Integer anoMesReferencia) throws ControladorException {

		try {

			return repositorioFaturamento
					.pesquisarDebitoCreditoSituacaoAtualConta(idImovel,
							anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Metodo temporario para correção da base de dados
	 * 
	 * Gerar Crédito a Realizar para os imóveis com contas com vencimento em
	 * 14/08/2007 com multa da conta 06/2007 cobrada na conta 07/2007 e que
	 * pagaram em 17/07/2007
	 * 
	 * @author Pedro Alexandre
	 * @date 20/08/2007
	 * 
	 * @throws ControladorException
	 */
	public void gerarCreditoARealizarPorImoveisComContasComVencimento14_08_2007()
			throws ControladorException {

		Collection colecaoDadosImovelCreditoARealizar = null;
		try {
			colecaoDadosImovelCreditoARealizar = repositorioFaturamento
					.pesquisarDadosImoveisParaGerarCreditoARealizarPorImoveisComContasComVencimento14_08_2007();
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (colecaoDadosImovelCreditoARealizar != null
				&& !colecaoDadosImovelCreditoARealizar.equals("")) {

			Iterator iteDados = colecaoDadosImovelCreditoARealizar.iterator();
			while (iteDados.hasNext()) {
				/*
				 * 0 - id do imóvel 1 - valor da prestação 2 - id da localidade
				 * 3 - id da quadra 4 - código do setor comercial 5 - nº da
				 * quadra 6 - nº do lote 7 - nº do sublote
				 */
				Object[] dadosImovelCreditoARealizar = (Object[]) iteDados
						.next();

				if (dadosImovelCreditoARealizar != null) {
					Integer idImovel = null;
					Integer idLocalidade = null;
					Integer idQuadra = null;
					Integer numeroQuadra = null;
					Integer codigoSetor = null;
					Short lote = null;
					Short subLote = null;
					BigDecimal valorPretacao = null;
					Integer anoMesReferenciaDebito = null;

					if (dadosImovelCreditoARealizar[0] != null) {
						idImovel = (Integer) dadosImovelCreditoARealizar[0];
					}

					if (dadosImovelCreditoARealizar[1] != null) {
						valorPretacao = (BigDecimal) dadosImovelCreditoARealizar[1];
					}

					if (dadosImovelCreditoARealizar[2] != null) {
						idLocalidade = (Integer) dadosImovelCreditoARealizar[2];
					}

					if (dadosImovelCreditoARealizar[3] != null) {
						idQuadra = (Integer) dadosImovelCreditoARealizar[3];
					}

					if (dadosImovelCreditoARealizar[4] != null) {
						codigoSetor = (Integer) dadosImovelCreditoARealizar[4];
					}

					if (dadosImovelCreditoARealizar[5] != null) {
						numeroQuadra = (Integer) dadosImovelCreditoARealizar[5];
					}

					if (dadosImovelCreditoARealizar[6] != null) {
						lote = ((Integer) dadosImovelCreditoARealizar[6])
								.shortValue();
					}

					if (dadosImovelCreditoARealizar[7] != null) {
						subLote = ((Integer) dadosImovelCreditoARealizar[7])
								.shortValue();
					}

					if (dadosImovelCreditoARealizar[8] != null) {
						anoMesReferenciaDebito = ((Integer) dadosImovelCreditoARealizar[8]);
					}

					// cria o objeto de credito a realizar Geral
					CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
					creditoARealizarGeral.setIndicadorHistorico(new Short("2"));
					creditoARealizarGeral.setUltimaAlteracao(new Date());
					Integer idCreditoARealizarGeral = (Integer) getControladorUtil()
							.inserir(creditoARealizarGeral);
					creditoARealizarGeral.setId(idCreditoARealizarGeral);

					// cria o objeto de credito a realizar
					CreditoARealizar creditoARealizar = new CreditoARealizar();
					creditoARealizar.setId(idCreditoARealizarGeral);
					creditoARealizar
							.setCreditoARealizarGeral(creditoARealizarGeral);

					if (idImovel != null) {
						Imovel imovel = new Imovel(idImovel);
						creditoARealizar.setImovel(imovel);
					}

					creditoARealizar.setCreditoTipo(new CreditoTipo(
							CreditoTipo.DEVOLUCAO_ACRESCIMOS_IMPONTUALIDADE));
					creditoARealizar.setGeracaoCredito(new Date());

					// ------Alterado Rodrigo 31/08/2007
					creditoARealizar
							.setAnoMesReferenciaCredito(anoMesReferenciaDebito);
					// ------
					creditoARealizar.setAnoMesCobrancaCredito(sistemaParametro
							.getAnoMesArrecadacao());
					creditoARealizar
							.setAnoMesReferenciaContabil(sistemaParametro
									.getAnoMesFaturamento());
					creditoARealizar.setValorCredito(valorPretacao);
					creditoARealizar
							.setValorResidualMesAnterior(new BigDecimal("0.00"));
					creditoARealizar.setNumeroPrestacaoCredito(new Short("1"));
					creditoARealizar
							.setNumeroPrestacaoRealizada(new Short("0"));

					if (idLocalidade != null) {
						Localidade localidade = new Localidade(idLocalidade);
						creditoARealizar.setLocalidade(localidade);
					}

					if (idQuadra != null) {
						Quadra quadra = new Quadra(idQuadra);
						creditoARealizar.setQuadra(quadra);
					}

					creditoARealizar.setCodigoSetorComercial(codigoSetor);
					creditoARealizar.setNumeroQuadra(numeroQuadra);
					creditoARealizar.setNumeroLote(lote);
					creditoARealizar.setNumeroSubLote(subLote);
					creditoARealizar.setRegistroAtendimento(null);
					creditoARealizar.setOrdemServico(null);
					creditoARealizar
							.setLancamentoItemContabil(new LancamentoItemContabil(
									LancamentoItemContabil.ACRESCIMOS_POR_IMPONTUALIDADE));
					creditoARealizar
							.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(
									DebitoCreditoSituacao.NORMAL));
					creditoARealizar.setDebitoCreditoSituacaoAnterior(null);
					creditoARealizar
							.setCreditoOrigem(new CreditoOrigem(
									CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE));
					creditoARealizar.setUltimaAlteracao(new Date());
					getControladorUtil().inserir(creditoARealizar);

					if (idImovel != null) {
						Map<Categoria, BigDecimal> mapValorPorCategoria = new HashMap();
						// [UC0108 - Obter Quantidade de Economias por
						// Categoria]
						Collection colecaoCategoriasImovel = getControladorImovel()
								.obterQuantidadeEconomiasCategoria(
										new Imovel(idImovel));
						Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel
								.iterator();

						// [UC0185 - Obter Valor por Categoria]
						Iterator iteratorColecaoValorIRPorCategoria = (getControladorImovel()
								.obterValorPorCategoria(
										colecaoCategoriasImovel, valorPretacao))
								.iterator();

						while (iteratorColecaoCategoriasImovel.hasNext()
								&& iteratorColecaoValorIRPorCategoria.hasNext()) {
							Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel
									.next();

							BigDecimal valorIR = (BigDecimal) iteratorColecaoValorIRPorCategoria
									.next();

							if (!mapValorPorCategoria.containsKey(categoria)) {
								mapValorPorCategoria.put(categoria,
										BigDecimal.ZERO);
							}

							mapValorPorCategoria.put(
									categoria,
									mapValorPorCategoria.get(categoria).add(
											valorIR));
						}

						Iterator mapIterator = mapValorPorCategoria.keySet()
								.iterator();

						while (mapIterator.hasNext()) {
							Categoria categoria = (Categoria) mapIterator
									.next();
							CreditoARealizarCategoria creditoARealizarCategoria = new CreditoARealizarCategoria();
							creditoARealizarCategoria
									.setComp_id(new CreditoARealizarCategoriaPK(
											creditoARealizar.getId(), categoria
													.getId()));
							creditoARealizarCategoria.setCategoria(categoria);
							creditoARealizarCategoria
									.setCreditoARealizar(creditoARealizar);
							BigDecimal valorCategoria = mapValorPorCategoria
									.get(categoria);
							creditoARealizarCategoria
									.setValorCategoria(valorCategoria);
							creditoARealizarCategoria
									.setQuantidadeEconomia(categoria
											.getQuantidadeEconomiasCategoria());
							creditoARealizarCategoria
									.setUltimaAlteracao(new Date());
							getControladorUtil().inserir(
									creditoARealizarCategoria);
						}
					}
				}
			}
		}
	}

	public ControladorTransacaoLocal getControladorTransacao() {
		ControladorTransacaoLocalHome localHome = null;
		ControladorTransacaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorTransacaoLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_TRANSACAO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}

	}

	/**
	 * [UC0099] Emitir Relação Analítica de Faturas
	 * 
	 * @author Rafael Pinto
	 * @date 28/08/2007
	 * 
	 * @param colecaoFatura
	 * @throws ControladorException
	 */
	public void emitirRelacaoAnaliticaFaturas(Collection<Fatura> colecaoFatura,
			Integer anoMesFaturamento) throws ControladorException {

		Collection<FaturaClienteResponsavelHelper> colecaoFaturaHelper = new ArrayList();

		if (colecaoFatura != null) {

			int quantidadeFaturas = 0;

			for (Fatura fatura : colecaoFatura) {

				quantidadeFaturas++;

				try {

					FaturaClienteResponsavelHelper faturaHelper = new FaturaClienteResponsavelHelper();

					Cliente cliente = this.getControladorCliente()
							.pesquisarCliente(fatura.getCliente().getId());

					int anoMes = fatura.getAnoMesReferencia();

					faturaHelper.setCodigoCliente(cliente.getId().toString());
					faturaHelper.setNomeCliente(cliente.getNome());
					faturaHelper.setMesAno(Util
							.formatarAnoMesParaMesAno(anoMes));

					// Obtém a coleção dos itens da fatura atual
					List<FaturaItem> colecaoFaturaItem = (ArrayList) repositorioFaturamento
							.pesquisarItemsFatura(fatura.getId());

					Collection<FaturaItemClienteResponsavelHelper> colecaoFaturaItemHelper = new ArrayList();

					// Caso a coleção de itens da fatura estejam preenchidos
					if (colecaoFaturaItem != null
							&& colecaoFaturaItem.size() > 0) {

						for (FaturaItem faturaItem : colecaoFaturaItem) {

							FaturaItemClienteResponsavelHelper faturaItemHelper = new FaturaItemClienteResponsavelHelper();

							Integer idImovel = faturaItem.getImovel().getId();
							Integer idConta = faturaItem.getContaGeral()
									.getId();
							BigDecimal impostos = faturaItem.getValorImposto();

							// Valor Impostos
							faturaItemHelper.setValorImpostos(impostos + "");

							String endereco = this.getControladorEndereco()
									.obterEnderecoAbreviadoImovel(idImovel);

							Conta conta = (Conta) Util
									.retonarObjetoDeColecao(this
											.obterConta(idConta));

							// Matricula
							faturaItemHelper
									.setMatricula(Util
											.adicionarZerosEsquedaNumero(
													8,
													Util.retornaMatriculaImovelFormatada(idImovel)));

							// Inscricao
							String inscricao = this.getControladorImovel()
									.pesquisarInscricaoImovel(idImovel);
							faturaItemHelper.setInscricao(inscricao);

							// Categoria
							Categoria categoria = this.getControladorImovel()
									.obterPrincipalCategoriaImovel(idImovel);
							faturaItemHelper.setCategoria(categoria
									.getDescricaoAbreviada());

							// Quantidade de Economias
							Short quantidadeEconomiaConta = repositorioFaturamento
									.obterQuantidadeEconomiasConta(idConta);

							faturaItemHelper
									.setQtdEconomias(quantidadeEconomiaConta
											+ "");

							// Endereço
							faturaItemHelper.setEndereco(endereco);

							EmitirContaHelper emitirContaHelper = new EmitirContaHelper();

							emitirContaHelper.setAmReferencia(anoMes);
							emitirContaHelper.setIdImovel(idImovel);

							if (conta.getLigacaoAguaSituacao() != null
									&& conta.getLigacaoAguaSituacao().getId() != null) {

								emitirContaHelper
										.setIdLigacaoAguaSituacao(conta
												.getLigacaoAguaSituacao()
												.getId());
							}

							if (conta.getLigacaoEsgotoSituacao() != null
									&& conta.getLigacaoEsgotoSituacao().getId() != null) {

								emitirContaHelper
										.setIdLigacaoEsgotoSituacao(conta
												.getLigacaoEsgotoSituacao()
												.getId());
							}

							Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);

							Integer tipoLigacao = parmSituacao[0];
							Integer tipoMedicao = parmSituacao[1];

							Object[] parmsConsumoHistorico = null;

							String consumoMedio = "";

							if (tipoLigacao != null) {

								try {
									parmsConsumoHistorico = repositorioMicromedicao
											.obterDadosConsumoConta(
													emitirContaHelper
															.getIdImovel(),
													emitirContaHelper
															.getAmReferencia(),
													tipoLigacao);

								} catch (ErroRepositorioException e) {
									throw new ControladorException(
											"erro.sistema", e);
								}

								if (parmsConsumoHistorico != null) {

									// Consumo médio
									if (parmsConsumoHistorico[2] != null) {
										consumoMedio = ""
												+ (Integer) parmsConsumoHistorico[2];
									}

								}
							}

							Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(
									emitirContaHelper, tipoMedicao);

							// Leitura Anterior
							String leituraAnterior = "";

							// Leitura Atual
							String leituraAtual = "";

							// Data Leitura Anterior
							String dataLeituraAnterior = "";

							// Data Leitura Atual
							String dataLeituraAtual = "";

							if (parmsMedicaoHistorico != null) {

								if (parmsMedicaoHistorico[0] != null) {
									leituraAnterior = ""
											+ (Integer) parmsMedicaoHistorico[0];
								}

								if (parmsMedicaoHistorico[1] != null) {
									leituraAtual = ""
											+ (Integer) parmsMedicaoHistorico[1];
								}

								if (parmsMedicaoHistorico[3] != null) {
									dataLeituraAnterior = Util
											.formatarData((Date) parmsMedicaoHistorico[3]);
								}

								if (parmsMedicaoHistorico[2] != null) {
									dataLeituraAtual = Util
											.formatarData((Date) parmsMedicaoHistorico[2]);
								}

							}

							// Leitura Anterior
							faturaItemHelper
									.setLeituraAnterior(leituraAnterior);

							// Leitura Atual
							faturaItemHelper.setLeituraAtual(leituraAtual);

							// Média
							faturaItemHelper.setMedia(consumoMedio);

							// Consumo Faturado
							String diasConsumo = "";
							if (!dataLeituraAnterior.equals("")
									&& !dataLeituraAtual.equals("")) {

								diasConsumo = ""
										+ Util.obterQuantidadeDiasEntreDuasDatas(
												(Date) parmsMedicaoHistorico[3],
												(Date) parmsMedicaoHistorico[2]);
							}
							emitirContaHelper.setConsumoAgua(conta
									.getConsumoAgua());
							emitirContaHelper.setConsumoEsgoto(conta
									.getConsumoEsgoto());

							String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(
									emitirContaHelper, tipoMedicao, diasConsumo);

							String consumoFaturamento = parmsConsumo[0];

							faturaItemHelper
									.setConsumoFaturado(consumoFaturamento);

							// Data da leitura
							faturaItemHelper.setDataLeitura(dataLeituraAtual);

							// Data Vencimento
							faturaItemHelper.setDataVencimento(Util
									.formatarData(conta
											.getDataVencimentoConta()));

							// Consumo Agua
							String consumoAgua = "";
							if (conta.getConsumoAgua() != null) {
								consumoAgua = conta.getConsumoAgua().toString();
							}
							faturaItemHelper.setConsumoAgua(consumoAgua);

							// Rateio Agua
							String rateioAgua = "";
							if (conta.getConsumoRateioAgua() != null) {
								rateioAgua = conta.getConsumoRateioAgua()
										.toString();
							}
							faturaItemHelper.setRateioAgua(rateioAgua);

							// Valor Agua
							String valorAgua = "";
							if (conta.getValorAgua() != null) {
								valorAgua = Util.formatarMoedaReal(conta
										.getValorAgua());
							}
							faturaItemHelper.setValorAgua(valorAgua);

							// Consumo Esgoto
							String consumoEsgoto = "";
							if (conta.getConsumoEsgoto() != null) {
								consumoEsgoto = conta.getConsumoEsgoto()
										.toString();
							}
							faturaItemHelper.setConsumoEsgoto(consumoEsgoto);

							// Rateio Esgoto
							String rateioEsgoto = "";
							if (conta.getConsumoRateioEsgoto() != null) {
								rateioEsgoto = conta.getConsumoRateioEsgoto()
										.toString();
							}
							faturaItemHelper.setRateioEsgoto(rateioEsgoto);

							// Valor Esgoto
							String valorEsgoto = "";
							if (conta.getValorEsgoto() != null) {
								valorEsgoto = Util.formatarMoedaReal(conta
										.getValorEsgoto());
							}
							faturaItemHelper.setValorEsgoto(valorEsgoto);

							// Debito Cobrado
							String debitoCobrado = "";
							if (conta.getDebitos() != null) {
								debitoCobrado = Util.formatarMoedaReal(conta
										.getDebitos());
							}
							faturaItemHelper.setDebitoCobrado(debitoCobrado);

							// Credito Realizado
							String creditoRealizado = "";
							if (conta.getValorCreditos() != null) {
								creditoRealizado = Util.formatarMoedaReal(conta
										.getValorCreditos());
							}
							faturaItemHelper
									.setCreditoRealizado(creditoRealizado);

							// Valor Total da Conta
							faturaItemHelper.setValor(Util
									.formatarMoedaReal(faturaItem
											.getValorConta()));

							colecaoFaturaItemHelper.add(faturaItemHelper);
						}// fim do for faturaItem

					}// fim do if fatura

					faturaHelper.setValorTotalAPagar(Util
							.formatarMoedaReal(fatura.getDebito()));
					faturaHelper
							.setColecaoFaturaItemClienteResponsavelHelper(colecaoFaturaItemHelper);

					colecaoFaturaHelper.add(faturaHelper);

					// Erro no repositório
				} catch (ErroRepositorioException ex) {
					throw new ControladorException("erro.sistema", ex);
				}
			}

			RelatorioRelacaoAnaliticaFaturas relatorio = new RelatorioRelacaoAnaliticaFaturas(
					Usuario.USUARIO_BATCH);

			relatorio.addParametro("colecaoFaturas", colecaoFaturaHelper);
			relatorio.addParametro("tipoFormatoRelatorio",
					TarefaRelatorio.TIPO_PDF);

			byte[] relatorioGerado = (byte[]) relatorio.executar();
			FileOutputStream out = null;

			try {

				String mesReferencia = anoMesFaturamento.toString().substring(4, 6);
				String anoReferencia = anoMesFaturamento.toString().substring(0, 4);

				String nomeRelatorio = "RELATORIO_RELACAO_ANALITICA_FATURA_" + mesReferencia + "_" + anoReferencia + ".PDF";

				File leitura = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeRelatorio);
				out = new FileOutputStream(leitura.getAbsolutePath());
				out.write(relatorioGerado);
				out.flush();

			} catch (IOException e) {
				throw new ControladorException("erro.sistema", e);
			} finally {
				IoUtil.fecharStream(out);
			}

		}

	}

	/**
	 * Recupera o data prevista do faturamento atividade cronograma
	 * 
	 * @author Sávio Luiz
	 * @date 28/08/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarFaturamentoAtividadeCronogramaDataPrevista(
			Integer faturamentoGrupoId, Integer faturamentoAtividadeId,
			Integer anoMesReferencia) throws ControladorException {

		try {

			return repositorioFaturamento
					.pesquisarFaturamentoAtividadeCronogramaDataPrevista(
							faturamentoGrupoId, faturamentoAtividadeId,
							anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0596] Inserir Qualidade de Agua
	 * 
	 * @author Kássia Albuquerque
	 * @date 06/08/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */

	public void inserirQualidadeAgua(QualidadeAgua qualidadeAgua,
			Collection colecaoQualidadeAgua, Usuario usuarioLogado,
			QualidadeAguaPadrao qualidadeAguaPadrao)
			throws ControladorException {

		if (colecaoQualidadeAgua != null && !colecaoQualidadeAgua.isEmpty()) {

			Iterator IteratorColecaoQualidadeAgua = colecaoQualidadeAgua
					.iterator();

			while (IteratorColecaoQualidadeAgua.hasNext()) {

				QualidadeAgua qualidadeAguaColecao = (QualidadeAgua) IteratorColecaoQualidadeAgua
						.next();

				// -------- REGISTRAR TRANSAÇÃO------------------

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_QUALIDADE_AGUA_INSERIR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				Operacao operacao = new Operacao();
				operacao.setId(Operacao.OPERACAO_QUALIDADE_AGUA_INSERIR);

				OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
				operacaoEfetuada.setOperacao(operacao);

				qualidadeAguaColecao.setOperacaoEfetuada(operacaoEfetuada);
				qualidadeAguaColecao.adicionarUsuario(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(qualidadeAguaColecao);
				// ------------ REGISTRAR TRANSAÇÃO----------------------------

				getControladorUtil().inserir(qualidadeAguaColecao);

			}

		} else {

			// [FS0005 - VERIFICAR EXISTÊNCIA DA QUALIDADE DE ÁGUA PARA
			// LOCALIDADE]
			if ((qualidadeAgua.getSetorComercial() == null || qualidadeAgua
					.getSetorComercial().equals(""))
					&& (qualidadeAgua.getLocalidade() != null && !qualidadeAgua
							.getLocalidade().equals(""))) {

				FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();

				filtroQualidadeAgua
						.adicionarCaminhoParaCarregamentoEntidade("localidade");

				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
						FiltroQualidadeAgua.ANO_MES_REFERENCIA, qualidadeAgua
								.getAnoMesReferencia().toString()));
				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
						FiltroQualidadeAgua.LOCALIDADE_ID, qualidadeAgua
								.getLocalidade().getId().toString()));
				filtroQualidadeAgua.adicionarParametro(new ParametroNulo(
						FiltroQualidadeAgua.SETOR_COMERCIAL_ID));

				Collection colecaoExistenciaQualidadeAgua = getControladorUtil()
						.pesquisar(filtroQualidadeAgua,
								QualidadeAgua.class.getName());

				if (colecaoExistenciaQualidadeAgua != null
						&& !colecaoExistenciaQualidadeAgua.isEmpty()) {

					throw new ControladorException(
							"atencao.faturamento.qualidade_agua_existente",
							null, qualidadeAgua.getLocalidade().getId()
									.toString());
				}

			} else if ((qualidadeAgua.getSetorComercial() != null && !qualidadeAgua
					.getSetorComercial().equals(""))
					&& (qualidadeAgua.getLocalidade() != null && !qualidadeAgua
							.getLocalidade().equals(""))) {

				// [FS0006 - VERIFICAR EXISTÊNCIA DA QUALIDADE DE ÁGUA PARA
				// SETOR COMERCIAL]

				FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();

				filtroQualidadeAgua
						.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroQualidadeAgua
						.adicionarCaminhoParaCarregamentoEntidade("setorComercial");

				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
						FiltroQualidadeAgua.ANO_MES_REFERENCIA, qualidadeAgua
								.getAnoMesReferencia().toString()));
				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
						FiltroQualidadeAgua.LOCALIDADE_ID, qualidadeAgua
								.getLocalidade().getId().toString()));
				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
						FiltroQualidadeAgua.SETOR_COMERCIAL_ID, qualidadeAgua
								.getSetorComercial().getId().toString()));

				Collection colecaoExistenciaQualidadeAgua = getControladorUtil()
						.pesquisar(filtroQualidadeAgua,
								QualidadeAgua.class.getName());

				if (colecaoExistenciaQualidadeAgua != null
						&& !colecaoExistenciaQualidadeAgua.isEmpty()) {

					QualidadeAgua qualidadeAguaExistente = (QualidadeAgua) colecaoExistenciaQualidadeAgua
							.iterator().next();
					throw new ControladorException(
							"atencao.faturamento.qualidade_agua_existente_setor_comercial",
							null, ""
									+ qualidadeAguaExistente.getLocalidade()
											.getId()
									+ "/"
									+ qualidadeAguaExistente
											.getSetorComercial().getCodigo());
				}

			}

			qualidadeAgua.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO------------------

			RegistradorOperacao registradorOperacao = new RegistradorOperacao(
					Operacao.OPERACAO_QUALIDADE_AGUA_INSERIR,
					new UsuarioAcaoUsuarioHelper(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_QUALIDADE_AGUA_INSERIR);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			qualidadeAgua.setOperacaoEfetuada(operacaoEfetuada);
			qualidadeAgua.adicionarUsuario(usuarioLogado,
					UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(qualidadeAgua);
			// ------------ REGISTRAR TRANSAÇÃO----------------------------

			getControladorUtil().inserir(qualidadeAgua);

			// ----------- INSERINDO QUALIDADE DE AGUA PADRAO -----------------

			qualidadeAguaPadrao.setUltimaAlteracao(new Date());

			getControladorUtil().atualizar(qualidadeAguaPadrao);
		}
	}

	/**
	 * [UC0147] - Cancelar Conjunto Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * 
	 * @throws ControladorException
	 */
	public void cancelarConjuntoConta(Integer idGrupoFaturamento,
			ContaMotivoCancelamento contaMotivoCancelamento, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim, Usuario usuarioLogado)
			throws ControladorException {

		Collection colecaoContasManutencao = new ArrayList();
		Collection colecaoConta = new ArrayList();

		// PARÂMETROS DO SISTEMA
		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		try {

			colecaoContasManutencao = repositorioFaturamento
					.pesquisarContasGrupoFaturamento(anoMes,
							idGrupoFaturamento, dataVencimentoContaInicio,
							dataVencimentoContaFim, anoMesFim);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoContasManutencao != null
				&& !colecaoContasManutencao.isEmpty()) {

			/**
			 * [UC0407] Filtrar Imóveis para Inserir ou Manter Conta 3. Caso o
			 * indicador de bloqueio de contas vinculadas a contrato de
			 * parcelamento no manter contas esteja ativo retirar da lista de
			 * contas selecionadas as contas vinculadas a algum contrato de
			 * parcelamento ativo
			 * 
			 * RM 1887 - Contrato Parcelamento por Cliente Adicionado por:
			 * Mariana Victor Data: 21/07/2011
			 * 
			 * */
			if (sistemaParametro
					.getIndicadorBloqueioContasContratoParcelManterConta() != null
					&& sistemaParametro
							.getIndicadorBloqueioContasContratoParcelManterConta()
							.equals(ConstantesSistema.SIM)) {
				colecaoContasManutencao = getControladorRetificarConta()
						.obterColecaoSemContasEmContratoParcelamentoRetificarConjuntoContasIds(colecaoContasManutencao);
			}
			/**
			 * FIM DA ALTERAÇÂO
			 * */

			Iterator colecaoContasManutencaoIterator = colecaoContasManutencao
					.iterator();

			while (colecaoContasManutencaoIterator.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] contaArray = (Object[]) colecaoContasManutencaoIterator
						.next();

				Conta conta = new Conta();
				// ID da conta
				conta.setId((Integer) contaArray[0]);
				// Ano Mês referencia
				conta.setReferencia((Integer) contaArray[1]);
				// DebitoCreditoSituacaoAtual
				conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);
				// Ano Mês referencia contábil
				conta.setReferenciaContabil((Integer) contaArray[12]);

				// imovel
				if (contaArray[14] != null) {
					conta.setImovel((Imovel) contaArray[14]);
				}

				// DebitoCreditoSituacaoAnterior
				if (contaArray[15] != null) {
					conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[15]);
				}

				colecaoConta.add(conta);
			}
		}

		Iterator colecaoContasIt = colecaoConta.iterator();
		Conta contaColecao = null;
		// Conta contaNaBase = null;
		FiltroConta filtroConta = new FiltroConta();

		while (colecaoContasIt.hasNext()) {
			contaColecao = (Conta) colecaoContasIt.next();

			// Usuário Logado
			contaColecao.setUsuario(usuarioLogado);

			// Carregando a conta que está na base
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID,
					contaColecao.getId()));

			filtroConta.limparListaParametros();
			/**
			 * Caso a situação atual da conta corresponda a normal (DCST_IDATUAL
			 * com o valor correspondente a normal da tabela
			 * DEBITO_CREDITO_SITUACAO) ou corresponda a retificada ou incluída
			 * (DCST_IDATUAL com o valor correspondente a retificada ou
			 * incluída, da tabela DEBITO_CREDITO_SITUACAO) e a retificação ou
			 * inclusão já tenha sido contabilizada (CNTA_AMREFERENCIACONTABIL
			 * menor que PARM_AMREFERENCIAFATURAMENTO da tabela
			 * SISTEMA_PARAMETROS), atualizar os seguintes atributos da conta.
			 */

			if (isContaNormalIncluidaOuRetificadaEReferenciaContabilMenor(contaColecao, sistemaParametro)) {

				// Data do cancelamento
				contaColecao.setDataCancelamento(new Date());

				// Motivo do Cancelamento
				contaColecao
						.setContaMotivoCancelamento(contaMotivoCancelamento);

				// Situação Anterior
				/*
				 * Caso a situação atual da conta corresponda a normal
				 * (DCST_IDATUAL com o valor correspondente a normal da tabela
				 * DEBITO_CREDITO_SITUACAO) e a conta tenha sido faturada no mês
				 * de faturamento corrente (CNTA_AMREFERENCIACONTA=
				 * PARM_AMREFERENCIAFATURAMENTO da tabela SISTEMA_PARAMETROS)
				 * DCST_IDANTERIOR=DCST_IDATUAL, caso contrário
				 * DCST_IDANTERIOR=nulo)
				 */
				if (contaColecao.getDebitoCreditoSituacaoAtual().getId()
						.equals(DebitoCreditoSituacao.NORMAL)
						&& Util.compararAnoMesReferencia(new Integer(
								contaColecao.getReferencia()), new Integer(
								sistemaParametro.getAnoMesFaturamento()), "=")) {

					contaColecao.setDebitoCreditoSituacaoAnterior(contaColecao
							.getDebitoCreditoSituacaoAtual());
				} else {
					contaColecao.setDebitoCreditoSituacaoAnterior(null);
				}

				// Situação Atual
				DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
				/**
				 * Caso motivo de retificação seja débito
				 * prescrito, alterar a situação da conta para 8.
				 * 
				 * @author Wellington Rocha
				 * @date 01/06/2012
				 * 
				 * */
				boolean contaPodeSerPrescrita = true;
				if (contaMotivoCancelamento.getId().equals(
						ContaMotivoCancelamento.DEBITO_PRESCRITO)
						|| contaMotivoCancelamento.getId().equals(
								ContaMotivoCancelamento.PRESCRICAO)) {

					contaPodeSerPrescrita = this
							.verificarPossibilidadePrescricaoConta(contaColecao
									.getId());
					if (contaPodeSerPrescrita) {
						debitoCreditoSituacao
								.setId(DebitoCreditoSituacao.DEBITO_PRESCRITO);
					}
				} else {
					debitoCreditoSituacao
							.setId(DebitoCreditoSituacao.CANCELADA);
				}

				if (!contaPodeSerPrescrita) {
					throw new ControladorException(
							"erro.conta_nao_satisfaz_criterios_para_prescricao",
							"exibirCancelarContaAction.do?contaID="
									+ contaColecao.getId() + "&idImovel="
									+ contaColecao.getImovel().getId(), null);
				} else {
					contaColecao
							.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

					// Colocado por Raphael Rossiter em 27/02/2008
					// Ano Mes Referencia Contabil
					if (contaColecao.getReferencia() <= sistemaParametro
							.getAnoMesFaturamento().intValue()) {

						contaColecao.setReferenciaContabil(Util
								.getAnoMesComoInteger(new Date()));
					}

					// Usuario
					contaColecao.setUsuario(usuarioLogado);

					// última alteração
					contaColecao.setUltimaAlteracao(new Date());

					/*
					 * Alterado por Raphael Rossiter em 30/07/2007 (Analista:
					 * Rosana Carvalho)
					 * 
					 * OBJETIVO: Quando o mes/ano de faturamento for maior que o
					 * mes/ano de faturamento atual, não alterar o mes/ano
					 * contábil
					 */

					// Ano Mes Referencia Contabil
					if (contaColecao.getReferencia() <= sistemaParametro
							.getAnoMesFaturamento().intValue()) {

						contaColecao.setReferenciaContabil(Util
								.getAnoMesComoInteger(new Date()));
					}

					/*
					 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO:
					 * Gravar na tabela de conta o usuário que está logado no
					 * sistema
					 */

					// Usuario
					contaColecao.setUsuario(usuarioLogado);

					// ------------ <REGISTRAR
					// TRANSAÇÃO>----------------------------

					RegistradorOperacao registradorOperacao = new RegistradorOperacao(
							Operacao.OPERACAO_CANCELAR_CONTA,
							contaColecao.getImovel() != null ? contaColecao
									.getImovel().getId() : contaColecao.getId(),
							contaColecao.getId(), new UsuarioAcaoUsuarioHelper(
									usuarioLogado,
									UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacao.registrarOperacao(contaColecao);

					getControladorTransacao().registrarTransacao(contaColecao);

					// ------------ </REGISTRAR
					// TRANSAÇÃO>----------------------------

					// UPDATE
					try {

						if (contaColecao.getDebitoCreditoSituacaoAnterior() == null) {
							repositorioFaturamento
									.cancelarContaReferenciaContabilMenorSistemaParametro(
											contaColecao, null);

						} else {
							repositorioFaturamento
									.cancelarContaReferenciaContabilMenorSistemaParametro(
											contaColecao,
											contaColecao
													.getDebitoCreditoSituacaoAnterior()
													.getId());
						}

						// CRC2725 - alterado por Vivianne Sousa - 30/03/2010
						// analista:Fátima
						// 1.1.2.Verificar se há relação do cancelamento com
						// itens
						// de negativação
						getControladorSpcSerasa()
								.verificarRelacaoDoCancelamentoComItensNegativacao(
										contaColecao, null);

					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						new ControladorException("erro.sistema", ex);
					} catch (ControladorException ex) {
						sessionContext.setRollbackOnly();
						throw ex;
					} catch (Exception ex) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
				}

			} else if (isContaIncluidaOuRetificadaEReferenciaContabilMaiorOuIgual(contaColecao, sistemaParametro)) {

				// Remoção da conta no BD
				contaColecao.setPercentualEsgoto(new BigDecimal("0.00"));

				// CRC2725 - alterado por Vivianne Sousa - 17/09/2009
				// analista:Fátima
				// [FS0003 - Verificar existência de itens de negativação para a
				// conta incluída]:
				getControladorSpcSerasa()
						.verificarExistenciaItensNegativacaoParaContaIncluida(
								contaColecao);
				// 1.2.4. Verificar se há relação do cancelamento com itens de
				// negativação:
				// [UC0937 - Obter Itens de Negativação Associados à Conta]
				// passando o identificador do imóvel (Imóvel da Conta
				// Retificada e Cancelada)
				// e a referência (Referência da Conta Retificada e Cancelada).
				Collection colecaoNegativadorMovimentoRegItem = getControladorSpcSerasa()
						.obterItensNegativacaoAssociadosAConta(
								contaColecao.getImovel().getId(),
								contaColecao.getReferencia());

				this.getControladorUtil().remover(
						new String[] { "" + contaColecao.getId() },
						contaColecao.getClass().getName(), null, null);

				if (contaColecao.getDebitoCreditoSituacaoAtual().getId()
						.equals(DebitoCreditoSituacao.RETIFICADA)) {

					// [FS0002] - Verificar existência da conta
					// cancelada por retificação

					filtroConta.adicionarParametro(new ParametroSimples(
							FiltroConta.REFERENCIA, contaColecao
									.getReferencia()));

					filtroConta.adicionarParametro(new ParametroSimples(
							FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
							DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO));

					Collection colecaoContaCanceladaRetificacao = this
							.getControladorUtil().pesquisar(filtroConta,
									Conta.class.getName());

					filtroConta.limparListaParametros();

					if (colecaoContaCanceladaRetificacao == null
							|| colecaoContaCanceladaRetificacao.isEmpty()) {
						throw new ControladorException(
								"atencao.pesquisa.nenhuma.conta_cancelada_retificacao");
					}

					Conta contaCanceladaPorRetificacao = (Conta) Util
							.retonarObjetoDeColecao(colecaoContaCanceladaRetificacao);

					// Data do cancelamento
					contaCanceladaPorRetificacao
							.setDataCancelamento(new Date());

					// Motivo do cancelamento
					contaCanceladaPorRetificacao
							.setContaMotivoCancelamento(contaMotivoCancelamento);

					// Situação Atual
					DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
					debitoCreditoSituacao
							.setId(DebitoCreditoSituacao.CANCELADA);
					contaCanceladaPorRetificacao
							.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

					// Data da retificação = NULL
					contaCanceladaPorRetificacao.setDataRetificacao(null);

					// Motivo da retificação = NULL
					contaCanceladaPorRetificacao
							.setContaMotivoRetificacao(null);

					// Colocado por Raphael Rossiter em 27/02/2008
					// Ano Mês de referência contábil
					if (contaCanceladaPorRetificacao.getReferencia() <= sistemaParametro
							.getAnoMesFaturamento().intValue()) {

						contaCanceladaPorRetificacao.setReferenciaContabil(Util
								.getAnoMesComoInteger(new Date()));
					}

					/*
					 * Alterado por Raphael Rossiter em 30/07/2007 (Analista:
					 * Rosana Carvalho)
					 * 
					 * OBJETIVO: Quando o mes/ano de faturamento for maior que o
					 * mes/ano de faturamento atual, não alterar o mes/ano
					 * contábil
					 */

					// Ano Mês de referência contábil do faturamento
					if (contaCanceladaPorRetificacao.getReferencia() <= sistemaParametro
							.getAnoMesFaturamento().intValue()) {

						contaCanceladaPorRetificacao.setReferenciaContabil(Util
								.getAnoMesComoInteger(new Date()));
					}

					// última alteração
					contaCanceladaPorRetificacao.setUltimaAlteracao(new Date());

					/*
					 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO:
					 * Gravar na tabela de conta o usuário que está logado no
					 * sistema
					 */
					// Usuario
					contaCanceladaPorRetificacao.setUsuario(usuarioLogado);

					// ------------ <REGISTRAR
					// TRANSAÇÃO>----------------------------

					RegistradorOperacao registradorOperacao = new RegistradorOperacao(
							Operacao.OPERACAO_CANCELAR_CONTA,
							contaCanceladaPorRetificacao.getImovel() != null ? contaCanceladaPorRetificacao
									.getImovel().getId() : contaColecao.getId(),
							contaColecao.getId(), new UsuarioAcaoUsuarioHelper(
									usuarioLogado,
									UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacao
							.registrarOperacao(contaCanceladaPorRetificacao);

					getControladorTransacao().registrarTransacao(
							contaCanceladaPorRetificacao);

					// ------------ </REGISTRAR
					// TRANSAÇÃO>----------------------------

					// UPDATE
					try {
						repositorioFaturamento
								.cancelarContaReferenciaContabilMaiorIgualSistemaParametro(contaCanceladaPorRetificacao);

						// CRC2725 - alterado por Vivianne Sousa - 17/09/2009
						// analista:Fátima
						// 1.2.6.5. Caso existam itens de negativação associados
						// à conta (coleção de itens de negativação não está
						// vazia):
						if (colecaoNegativadorMovimentoRegItem != null
								&& !colecaoNegativadorMovimentoRegItem
										.isEmpty()) {
							// Caso existam itens de negativação associados à
							// conta:
							Iterator iterNmri = colecaoNegativadorMovimentoRegItem
									.iterator();
							while (iterNmri.hasNext()) {
								Integer idNmri = (Integer) iterNmri.next();
								// [SB0002 - Atualizar Item Negativação - Conta
								// Retificada].
								getControladorSpcSerasa()
										.atualizarNegativadorMovimentoRegItem(
												idNmri,
												new Date(),
												CobrancaDebitoSituacao.CANCELADO,
												contaCanceladaPorRetificacao
														.getId(),
												contaColecao.getId());
							}
						}

					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						new ControladorException("erro.sistema", ex);
					} catch (ControladorException ex) {
						sessionContext.setRollbackOnly();
						throw ex;
					} catch (Exception ex) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
				}
			}

			// Alterado por Francisco - 26/05/08, por conta do Resumo de Ações
			// de cobrança
			// Analista: Ana Breda
			try {
				// Atualizar documento de cobranca da conta, se houver, para
				// cancelado
				repositorioCobranca.atualizarSituacaoCobrancaDocumentoItem(
						CobrancaDebitoSituacao.CANCELADO, new Date(),
						contaColecao.getId(), null, null);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}

		}
	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * @throws ControladorException
	 */
	public void alterarVencimentoConjuntoConta(Integer idGrupoFaturamento,
			Date dataVencimentoInformada, Integer anoMes, Integer anoMesFim,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Usuario usuarioLogado, boolean somenteDebitoAutomatico) throws ControladorException {

		try {

			Date dataValidade = this.retornaDataValidadeConta(dataVencimentoInformada);
			
			repositorioFaturamento.alterarVencimentoContaGrupoFaturamento(
					dataVencimentoInformada, dataValidade,
					Conta.INDICADOR_ALTERACAO_VENCIMENTO_ATIVO,
					idGrupoFaturamento, anoMes, anoMesFim,
					dataVencimentoContaInicio, dataVencimentoContaFim,
					somenteDebitoAutomatico);

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.GERAR_MOVIMENTO_AUTOMATICO_BANCO);
			String mensagem = "VENCIMENTO DE CONJUTO DE CONTAS ALTERADO COM SUCESSO.";

			try {
				ServicosEmail.enviarMensagem(envioEmail.getEmailRemetente(), usuarioLogado.getDescricaoEmail(),
						"CONTAS_ALTERADAS", mensagem);
			} catch (ErroEmailException e) {
				throw new ControladorException("erro.envio.mensagem");
			}

		} catch (ErroRepositorioException ex) {
			String mensagem = "VENCIMENTO DE CONJUTO DE CONTAS NÃO FOI ALTERADO DEVIDO A UM ERRO DE SISTEMA.";
			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.GERAR_MOVIMENTO_AUTOMATICO_BANCO);

			try {
				ServicosEmail.enviarMensagem(envioEmail.getEmailRemetente(), usuarioLogado.getDescricaoEmail(), 
						"CONTAS_NÃO_ALTERADAS", mensagem);
			} catch (ErroEmailException e) {
				throw new ControladorException("erro.envio.mensagem");
			}
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}
	}

	
	/**
	 * Pesquisar conjunto de contas p/ emissão da 2°Via
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * 
	 * @throws ControladorException
	 */
	public Collection pesquisarConjuntoContaEmitir2Via(
			Integer idGrupoFaturamento, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim) throws ControladorException {

		Collection colecaoContasEmissao = new ArrayList();
		Collection colecaoContasManutencao = new ArrayList();

		try {
			colecaoContasManutencao = repositorioFaturamento
					.pesquisarIdContasGrupoFaturamento(anoMes,
							idGrupoFaturamento, dataVencimentoContaInicio,
							dataVencimentoContaFim, anoMesFim);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoContasManutencao != null
				&& !colecaoContasManutencao.isEmpty()) {
			colecaoContasEmissao.addAll(colecaoContasManutencao);
		}

		return colecaoContasEmissao;
	}

	/**
	 * [UC0216] Calcular Acrescimo por Impontualidade
	 * 
	 * @author Raphael Rossiter
	 * @date 28/08/2007
	 * 
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarContaAtualizacaoTarifaria(Integer idConta)
			throws ControladorException {

		Conta retorno = null;
		Object[] arrayConta = null;

		try {

			arrayConta = repositorioFaturamento
					.pesquisarContaAtualizacaoTarifaria(idConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (arrayConta != null) {

			retorno = new Conta();

			retorno.setId((Integer) arrayConta[0]);

			if (arrayConta[1] != null) {
				retorno.setConsumoAgua((Integer) arrayConta[1]);
			}

			if (arrayConta[2] != null) {
				retorno.setConsumoEsgoto((Integer) arrayConta[2]);
			}

			LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
			ligacaoAguaSituacao.setId((Integer) arrayConta[3]);

			retorno.setLigacaoAguaSituacao(ligacaoAguaSituacao);

			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
			ligacaoEsgotoSituacao.setId((Integer) arrayConta[4]);

			retorno.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

			ConsumoTarifa consumoTarifa = new ConsumoTarifa();
			consumoTarifa.setId((Integer) arrayConta[5]);

			retorno.setConsumoTarifa(consumoTarifa);

			if (arrayConta[6] != null) {
				retorno.setPercentualEsgoto((BigDecimal) arrayConta[6]);
			}

			FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
			faturamentoGrupo.setId((Integer) arrayConta[10]);

			Rota rota = new Rota();
			rota.setId((Integer) arrayConta[9]);
			rota.setFaturamentoGrupo(faturamentoGrupo);

			Quadra quadra = new Quadra();
			quadra.setId((Integer) arrayConta[8]);
			quadra.setRota(rota);

			Imovel imovel = new Imovel();
			imovel.setId((Integer) arrayConta[7]);

			imovel.setQuadra(quadra);

			retorno.setImovel(imovel);

			if (arrayConta[11] != null) {
				retorno.setValorAgua((BigDecimal) arrayConta[11]);
			}

			if (arrayConta[12] != null) {
				retorno.setValorEsgoto((BigDecimal) arrayConta[12]);
			}

			retorno.setReferencia((Integer) arrayConta[13]);

		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/09/2007
	 * 
	 * @return Fatura
	 * @throws ErroRepositorioException
	 */
	public Fatura pesquisarFaturaPorQualificador(Short codigoQualificador,
			Integer anoMesReferencia, BigDecimal valorDebito)
			throws ControladorException {

		Fatura retorno = null;
		Object[] arrayFatura = null;

		try {

			arrayFatura = repositorioFaturamento
					.pesquisarFaturaPorQualificador(codigoQualificador,
							anoMesReferencia, valorDebito);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (arrayFatura != null) {

			retorno = new Fatura();

			retorno.setId((Integer) arrayFatura[0]);

			Cliente cliente = new Cliente();
			cliente.setId((Integer) arrayFatura[1]);

			retorno.setCliente(cliente);
		}

		return retorno;
	}

	/**
	 * obtem o consumo médio faturado nos ultimos 6 meses [UC0214] Efetuar
	 * Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 05/09/2007
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public Integer obterValorConsumoMedio6meses(Integer idImovel)
			throws ControladorException {

		Integer obterValorConsumoMedio6meses = 0;

		int anoMes = Util.getAnoMesComoInt(new Date());

		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses
				+ obterConsumoFaturadoAnterior(idImovel, anoMes, 1, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses
				+ obterConsumoFaturadoAnterior(idImovel, anoMes, 2, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses
				+ obterConsumoFaturadoAnterior(idImovel, anoMes, 3, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses
				+ obterConsumoFaturadoAnterior(idImovel, anoMes, 4, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses
				+ obterConsumoFaturadoAnterior(idImovel, anoMes, 5, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses
				+ obterConsumoFaturadoAnterior(idImovel, anoMes, 6, 1);

		if (obterValorConsumoMedio6meses != 0) {
			obterValorConsumoMedio6meses = Util.dividirArredondarResultado(
					obterValorConsumoMedio6meses, 6);
		}

		return obterValorConsumoMedio6meses;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 05/09/2007
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public Integer obterConsumoFaturadoAnterior(Integer idImovel, int anoMes,
			int qtdMeses, Integer tipoLigacao) throws ControladorException {

		int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
		Integer numeroConsumoFaturadoMes = 0;

		// caso o tipo de ligação e medição seja diferente de nulo
		if (tipoLigacao != null) {
			Object[] parmsConsumoHistorico = null;
			parmsConsumoHistorico = getControladorMicromedicao()
					.obterConsumoAnteriorAnormalidadeDoImovel(idImovel,
							anoMesSubtraido, tipoLigacao);

			if (parmsConsumoHistorico != null) {
				if (parmsConsumoHistorico[0] != null) {
					numeroConsumoFaturadoMes = (Integer) parmsConsumoHistorico[0];
				}
			}
		}

		return numeroConsumoFaturadoMes;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * 
	 * [UC0637] - Gerar Relatórios Volumes Faturados
	 * 
	 * @author Rafael Corrêa
	 * @created 11/09/2007
	 * 
	 * @throws ControladorException
	 */
	public Collection<VolumesFaturadosRelatorioHelper> pesquisarDadosRelatorioVolumesFaturados(
			Integer idLocalidade, Integer anoMes, Integer anoMes1,
			Integer anoMes2, Integer anoMes3, Integer anoMes4, Integer anoMes5,
			Integer anoMes6) throws ControladorException {
		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosVolumesFaturados = null;

		try {
			colecaoDadosVolumesFaturados = repositorioFaturamento
					.pesquisarDadosRelatorioVolumesFaturados(idLocalidade,
							anoMes, anoMes1, anoMes2, anoMes3, anoMes4,
							anoMes5, anoMes6);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDadosVolumesFaturados != null
				&& !colecaoDadosVolumesFaturados.isEmpty()) {

			Iterator colecaoDadosVolumesFaturadosIterator = colecaoDadosVolumesFaturados
					.iterator();

			while (colecaoDadosVolumesFaturadosIterator.hasNext()) {

				// Obtém os dados do débito cobrado
				Object[] dadosVolumesFaturados = (Object[]) colecaoDadosVolumesFaturadosIterator
						.next();

				VolumesFaturadosRelatorioHelper volumesFaturadosRelatorioHelper = new VolumesFaturadosRelatorioHelper();

				// Id do Imóvel
				if (dadosVolumesFaturados[0] != null) {
					volumesFaturadosRelatorioHelper
							.setIdImovel((Integer) dadosVolumesFaturados[0]);
				}

				// Id da Localidade
				if (dadosVolumesFaturados[1] != null) {
					volumesFaturadosRelatorioHelper
							.setIdLocalidade((Integer) dadosVolumesFaturados[1]);
				}

				// Nome da Localidade
				if (dadosVolumesFaturados[2] != null) {
					volumesFaturadosRelatorioHelper
							.setNomeLocalidade((String) dadosVolumesFaturados[2]);
				}

				// Id do Setor Comercial
				if (dadosVolumesFaturados[3] != null) {
					volumesFaturadosRelatorioHelper
							.setIdSetorComercial((Integer) dadosVolumesFaturados[3]);
				}

				// Código do Setor Comercial
				if (dadosVolumesFaturados[4] != null) {
					volumesFaturadosRelatorioHelper
							.setCodigoSetorComercial((Integer) dadosVolumesFaturados[4]);
				}

				// Nome do Setor Comercial
				if (dadosVolumesFaturados[5] != null) {
					volumesFaturadosRelatorioHelper
							.setNomeSetorComercial((String) dadosVolumesFaturados[5]);
				}

				// Id da Quadra
				if (dadosVolumesFaturados[6] != null) {
					volumesFaturadosRelatorioHelper
							.setIdQuadra((Integer) dadosVolumesFaturados[6]);
				}

				// Número da Quadra
				if (dadosVolumesFaturados[7] != null) {
					volumesFaturadosRelatorioHelper
							.setNumeroQuadra((Integer) dadosVolumesFaturados[7]);
				}

				// Nome do Usuário
				if (dadosVolumesFaturados[8] != null) {
					volumesFaturadosRelatorioHelper
							.setNomeUsuario((String) dadosVolumesFaturados[8]);
				}

				// Id da Situação de Água
				if (dadosVolumesFaturados[9] != null) {
					volumesFaturadosRelatorioHelper
							.setIdSituacaoAgua((Integer) dadosVolumesFaturados[9]);
				}

				// Id da Situação de Esgoto
				if (dadosVolumesFaturados[10] != null) {
					volumesFaturadosRelatorioHelper
							.setIdSituacaoEsgoto((Integer) dadosVolumesFaturados[10]);
				}

				// Consumo Médio
				if (dadosVolumesFaturados[11] != null) {
					volumesFaturadosRelatorioHelper
							.setMediaConsumo((Integer) dadosVolumesFaturados[11]);
				}

				// Consumo Mês/Ano 1
				if (dadosVolumesFaturados[12] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno1((Integer) dadosVolumesFaturados[12]);
				}

				// Consumo Mês/Ano 2
				if (dadosVolumesFaturados[13] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno2((Integer) dadosVolumesFaturados[13]);
				}

				// Consumo Mês/Ano 3
				if (dadosVolumesFaturados[14] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno3((Integer) dadosVolumesFaturados[14]);
				}

				// Consumo Mês/Ano 4
				if (dadosVolumesFaturados[15] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno4((Integer) dadosVolumesFaturados[15]);
				}

				// Consumo Mês/Ano 5
				if (dadosVolumesFaturados[16] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno5((Integer) dadosVolumesFaturados[16]);
				}

				// Consumo Mês/Ano 6
				if (dadosVolumesFaturados[17] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno6((Integer) dadosVolumesFaturados[17]);
				}

				retorno.add(volumesFaturadosRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório resumido
	 * 
	 * [UC0637] - Gerar Relatórios Volumes Faturados
	 * 
	 * @author Rafael Corrêa
	 * @created 13/09/2007
	 * 
	 * @throws ControladorException
	 */
	public Collection<VolumesFaturadosRelatorioHelper> pesquisarDadosRelatorioVolumesFaturadosResumido(
			Integer idLocalidade, Integer anoMes, Integer anoMes1,
			Integer anoMes2, Integer anoMes3, Integer anoMes4, Integer anoMes5,
			Integer anoMes6) throws ControladorException {
		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosVolumesFaturados = null;

		try {
			colecaoDadosVolumesFaturados = repositorioFaturamento
					.pesquisarDadosRelatorioVolumesFaturadosResumido(
							idLocalidade, anoMes, anoMes1, anoMes2, anoMes3,
							anoMes4, anoMes5, anoMes6);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDadosVolumesFaturados != null
				&& !colecaoDadosVolumesFaturados.isEmpty()) {

			Iterator colecaoDadosVolumesFaturadosIterator = colecaoDadosVolumesFaturados
					.iterator();

			while (colecaoDadosVolumesFaturadosIterator.hasNext()) {

				// Obtém os dados do débito cobrado
				Object[] dadosVolumesFaturados = (Object[]) colecaoDadosVolumesFaturadosIterator
						.next();

				VolumesFaturadosRelatorioHelper volumesFaturadosRelatorioHelper = new VolumesFaturadosRelatorioHelper();

				// Id da Localidade
				if (dadosVolumesFaturados[0] != null) {
					volumesFaturadosRelatorioHelper
							.setIdLocalidade((Integer) dadosVolumesFaturados[0]);
				}

				// Nome da Localidade
				if (dadosVolumesFaturados[1] != null) {
					volumesFaturadosRelatorioHelper
							.setNomeLocalidade((String) dadosVolumesFaturados[1]);
				}

				// Id do Setor Comercial
				if (dadosVolumesFaturados[2] != null) {
					volumesFaturadosRelatorioHelper
							.setIdSetorComercial((Integer) dadosVolumesFaturados[2]);
				}

				// Código do Setor Comercial
				if (dadosVolumesFaturados[3] != null) {
					volumesFaturadosRelatorioHelper
							.setCodigoSetorComercial((Integer) dadosVolumesFaturados[3]);
				}

				// Nome do Setor Comercial
				if (dadosVolumesFaturados[4] != null) {
					volumesFaturadosRelatorioHelper
							.setNomeSetorComercial((String) dadosVolumesFaturados[4]);
				}

				// Número da Quadra
				if (dadosVolumesFaturados[5] != null) {
					volumesFaturadosRelatorioHelper
							.setNumeroQuadra((Integer) dadosVolumesFaturados[5]);
				}

				// Consumo Médio
				if (dadosVolumesFaturados[6] != null) {
					volumesFaturadosRelatorioHelper
							.setMediaConsumo((Integer) dadosVolumesFaturados[6]);
				}

				// Consumo Mês/Ano 1
				if (dadosVolumesFaturados[7] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno1((Integer) dadosVolumesFaturados[7]);
				}

				// Consumo Mês/Ano 2
				if (dadosVolumesFaturados[8] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno2((Integer) dadosVolumesFaturados[8]);
				}

				// Consumo Mês/Ano 3
				if (dadosVolumesFaturados[9] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno3((Integer) dadosVolumesFaturados[9]);
				}

				// Consumo Mês/Ano 4
				if (dadosVolumesFaturados[10] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno4((Integer) dadosVolumesFaturados[10]);
				}

				// Consumo Mês/Ano 5
				if (dadosVolumesFaturados[11] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno5((Integer) dadosVolumesFaturados[11]);
				}

				// Consumo Mês/Ano 6
				if (dadosVolumesFaturados[12] != null) {
					volumesFaturadosRelatorioHelper
							.setConsumoMesAno6((Integer) dadosVolumesFaturados[12]);
				}

				retorno.add(volumesFaturadosRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * 
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * 
	 * @throws ControladorException
	 */
	public Collection<ContasEmRevisaoRelatorioHelper> pesquisarDadosRelatorioContasRevisao(
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer codigoSetorComercialInicial,
			Integer codigoSetorComercialFinal,
			Collection colecaoIdsMotivoRevisao, Integer idImovelPerfil,
			Integer referenciaInicial, Integer referenciaFinal,
			Integer idCategoria, Integer idEsferaPoder)
			throws ControladorException {
		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosContasEmRevisao = null;

		try {
			colecaoDadosContasEmRevisao = repositorioFaturamento
					.pesquisarDadosRelatorioContasRevisao(idGerenciaRegional,
							idUnidadeNegocio, idLocalidadeInicial,
							idLocalidadeFinal, codigoSetorComercialInicial,
							codigoSetorComercialFinal, colecaoIdsMotivoRevisao,
							idImovelPerfil, referenciaInicial, referenciaFinal,
							idCategoria, idEsferaPoder);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDadosContasEmRevisao != null
				&& !colecaoDadosContasEmRevisao.isEmpty()) {

			Iterator colecaoDadosContasEmRevisaoIterator = colecaoDadosContasEmRevisao
					.iterator();

			while (colecaoDadosContasEmRevisaoIterator.hasNext()) {

				// Obtém os dados do débito cobrado
				Object[] dadosContasEmRevisao = (Object[]) colecaoDadosContasEmRevisaoIterator
						.next();

				ContasEmRevisaoRelatorioHelper contasEmRevisaoRelatorioHelper = new ContasEmRevisaoRelatorioHelper();

				// Id do Imóvel
				if (dadosContasEmRevisao[0] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdImovel((Integer) dadosContasEmRevisao[0]);
				}

				// Id da Gerência Regional
				if (dadosContasEmRevisao[1] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdGerenciaRegional((Integer) dadosContasEmRevisao[1]);
				}

				// Nome da Gerência Regional
				if (dadosContasEmRevisao[2] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeGerenciaRegional((String) dadosContasEmRevisao[2]);
				}

				// Id do Elo
				if (dadosContasEmRevisao[3] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdElo((Integer) dadosContasEmRevisao[3]);
				}

				// Nome do Elo
				if (dadosContasEmRevisao[4] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeElo((String) dadosContasEmRevisao[4]);
				}

				// Id da Unidade Negocio
				if (dadosContasEmRevisao[5] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdUnidadeNegocio((Integer) dadosContasEmRevisao[5]);
				}

				// Nome da Unidade Negocio
				if (dadosContasEmRevisao[6] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeUnidadeNegocio((String) dadosContasEmRevisao[6]);
				}

				// Id da Localidade
				if (dadosContasEmRevisao[7] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdLocalidade((Integer) dadosContasEmRevisao[7]);
				}

				// Nome da Localidade
				if (dadosContasEmRevisao[8] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeLocalidade((String) dadosContasEmRevisao[8]);
				}

				// Código do Setor Comercial
				if (dadosContasEmRevisao[9] != null) {
					contasEmRevisaoRelatorioHelper
							.setCodigoSetorComercial((Integer) dadosContasEmRevisao[9]);
				}

				// Nome do Setor Comercial
				if (dadosContasEmRevisao[10] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeSetorComercial((String) dadosContasEmRevisao[10]);
				}

				// Número da Quadra
				if (dadosContasEmRevisao[11] != null) {
					contasEmRevisaoRelatorioHelper
							.setNumeroQuadra((Integer) dadosContasEmRevisao[11]);
				}

				// Lote
				if (dadosContasEmRevisao[12] != null) {
					contasEmRevisaoRelatorioHelper
							.setLote((Short) dadosContasEmRevisao[12]);
				}

				// Sublote
				if (dadosContasEmRevisao[13] != null) {
					contasEmRevisaoRelatorioHelper
							.setSublote((Short) dadosContasEmRevisao[13]);
				}

				// Nome do Usuário
				if (dadosContasEmRevisao[14] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeUsuario((String) dadosContasEmRevisao[14]);
				}

				// DDD
				if (dadosContasEmRevisao[15] != null) {
					contasEmRevisaoRelatorioHelper
							.setDdd((String) dadosContasEmRevisao[15]);
				}

				// Número do Telefone
				if (dadosContasEmRevisao[16] != null) {
					contasEmRevisaoRelatorioHelper
							.setTelefone((String) dadosContasEmRevisao[16]);
				}

				// Ramal
				if (dadosContasEmRevisao[17] != null) {
					contasEmRevisaoRelatorioHelper
							.setRamal((String) dadosContasEmRevisao[17]);
				}

				// Mês/Ano de Referência da Conta
				if (dadosContasEmRevisao[18] != null) {
					contasEmRevisaoRelatorioHelper
							.setAnoMesReferenciaConta((Integer) dadosContasEmRevisao[18]);
				}

				// Valor da Conta
				if (dadosContasEmRevisao[19] != null) {
					contasEmRevisaoRelatorioHelper
							.setValorConta((BigDecimal) dadosContasEmRevisao[19]);
				}

				// Data de Revisão
				if (dadosContasEmRevisao[20] != null) {
					contasEmRevisaoRelatorioHelper
							.setDataRevisao((Date) dadosContasEmRevisao[20]);
				}

				// Id do Motivo de Revisão
				if (dadosContasEmRevisao[21] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdMotivoRevisao((Integer) dadosContasEmRevisao[21]);
				}

				// Descrição do Motivo de Revisão
				if (dadosContasEmRevisao[22] != null) {
					contasEmRevisaoRelatorioHelper
							.setDescricaoMotivoRevisao((String) dadosContasEmRevisao[22]);
				}

				retorno.add(contasEmRevisaoRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório resumido
	 * 
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * 
	 * @throws ControladorException
	 */
	public Collection<ContasEmRevisaoRelatorioHelper> pesquisarDadosRelatorioContasRevisaoResumido(
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer codigoSetorComercialInicial,
			Integer codigoSetorComercialFinal,
			Collection colecaoIdsMotivoRevisao, Integer idImovelPerfil,
			Integer referenciaInicial, Integer referenciaFinal,
			Integer idCategoria, Integer idEsferaPoder)
			throws ControladorException {
		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosContasEmRevisao = null;

		try {
			colecaoDadosContasEmRevisao = repositorioFaturamento
					.pesquisarDadosRelatorioContasRevisaoResumido(
							idGerenciaRegional, idUnidadeNegocio,
							idLocalidadeInicial, idLocalidadeFinal,
							codigoSetorComercialInicial,
							codigoSetorComercialFinal, colecaoIdsMotivoRevisao,
							idImovelPerfil, referenciaInicial, referenciaFinal,
							idCategoria, idEsferaPoder);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDadosContasEmRevisao != null
				&& !colecaoDadosContasEmRevisao.isEmpty()) {

			Iterator colecaoDadosContasEmRevisaoIterator = colecaoDadosContasEmRevisao
					.iterator();

			while (colecaoDadosContasEmRevisaoIterator.hasNext()) {

				// Obtém os dados do débito cobrado
				Object[] dadosContasEmRevisao = (Object[]) colecaoDadosContasEmRevisaoIterator
						.next();

				ContasEmRevisaoRelatorioHelper contasEmRevisaoRelatorioHelper = new ContasEmRevisaoRelatorioHelper();

				// Id da Gerência Regional
				if (dadosContasEmRevisao[0] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdGerenciaRegional((Integer) dadosContasEmRevisao[0]);
				}

				// Nome da Gerência Regional
				if (dadosContasEmRevisao[1] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeGerenciaRegional((String) dadosContasEmRevisao[1]);
				}

				// Id do Elo
				if (dadosContasEmRevisao[2] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdElo((Integer) dadosContasEmRevisao[2]);
				}

				// Nome do Elo
				if (dadosContasEmRevisao[3] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeElo((String) dadosContasEmRevisao[3]);
				}

				// Id da Localidade
				if (dadosContasEmRevisao[4] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdLocalidade((Integer) dadosContasEmRevisao[4]);
				}

				// Nome da Localidade
				if (dadosContasEmRevisao[5] != null) {
					contasEmRevisaoRelatorioHelper
							.setNomeLocalidade((String) dadosContasEmRevisao[5]);
				}

				// Mês/Ano de Referência da Conta
				if (dadosContasEmRevisao[6] != null) {
					contasEmRevisaoRelatorioHelper
							.setAnoMesReferenciaConta((Integer) dadosContasEmRevisao[6]);
				}

				// Id do Motivo de Revisão
				if (dadosContasEmRevisao[7] != null) {
					contasEmRevisaoRelatorioHelper
							.setIdMotivoRevisao((Integer) dadosContasEmRevisao[7]);
				}

				// Descrição do Motivo de Revisão
				if (dadosContasEmRevisao[8] != null) {
					contasEmRevisaoRelatorioHelper
							.setDescricaoMotivoRevisao((String) dadosContasEmRevisao[8]);
				}

				// Quantidade de Contas
				if (dadosContasEmRevisao[9] != null) {
					contasEmRevisaoRelatorioHelper
							.setQtdeContas((Integer) dadosContasEmRevisao[9]);
				}

				// Valor da Conta
				if (dadosContasEmRevisao[10] != null) {
					contasEmRevisaoRelatorioHelper
							.setValorConta((BigDecimal) dadosContasEmRevisao[10]);
				}

				retorno.add(contasEmRevisaoRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * 
	 * [UC0638] - Gerar Relatórios Anormalidade Consumo
	 * 
	 * @author Rafael Corrêa
	 * @created 15/10/2007
	 * 
	 * @throws ControladorException
	 */
	public Collection<GerarRelatorioAnormalidadeConsumoHelper> pesquisarDadosRelatorioAnormalidadeConsumo(
			Integer idGrupoFaturamento, Short codigoRota,
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorComercialInicial, Integer idSetorComercialFinal,
			Integer referencia, Integer idImovelPerfil,
			Integer numOcorConsecutivas, String indicadorOcorrenciasIguais,
			Integer mediaConsumoInicial, Integer mediaConsumoFinal,
			Collection<Integer> colecaoIdsAnormalidadeConsumo,
			Collection<Integer> colecaoIdsAnormalidadeLeitura,
			Collection<Integer> colecaoIdsAnormalidadeLeituraInformada,
			Integer tipoMedicao, Collection<Integer> colecaoIdsEmpresa,
			Integer numeroQuadraInicial, Integer numeroQuadraFinal,
			Integer idCategoria) throws ControladorException {

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosAnormalidadesConsumo = null;

		try {
			colecaoDadosAnormalidadesConsumo = repositorioFaturamento
					.pesquisarDadosRelatorioAnormalidadeConsumo(
							idGrupoFaturamento, codigoRota, idGerenciaRegional,
							idUnidadeNegocio, idLocalidadeInicial,
							idLocalidadeFinal, idSetorComercialInicial,
							idSetorComercialFinal, referencia, idImovelPerfil,
							numOcorConsecutivas, indicadorOcorrenciasIguais,
							mediaConsumoInicial, mediaConsumoFinal,
							colecaoIdsAnormalidadeConsumo,
							colecaoIdsAnormalidadeLeitura,
							colecaoIdsAnormalidadeLeituraInformada,
							tipoMedicao, colecaoIdsEmpresa,
							numeroQuadraInicial, numeroQuadraFinal, idCategoria);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDadosAnormalidadesConsumo != null
				&& !colecaoDadosAnormalidadesConsumo.isEmpty()) {

			Iterator colecaoDadosAnormalidadesConsumoIterator = colecaoDadosAnormalidadesConsumo
					.iterator();

			while (colecaoDadosAnormalidadesConsumoIterator.hasNext()) {

				// Obtém os dados do débito cobrado
				Object[] dadosAnormalidadesConsumo = (Object[]) colecaoDadosAnormalidadesConsumoIterator
						.next();

				GerarRelatorioAnormalidadeConsumoHelper gerarRelatorioAnormalidadeConsumoHelper = new GerarRelatorioAnormalidadeConsumoHelper();

				// Id do Grupo de Faturamento
				if (dadosAnormalidadesConsumo[0] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdGrupo((Integer) dadosAnormalidadesConsumo[0]);
				}

				// Nome do Grupo de Faturamento
				if (dadosAnormalidadesConsumo[1] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setNomeGrupo((String) dadosAnormalidadesConsumo[1]);
				}

				// Id da Gerência Regional
				if (dadosAnormalidadesConsumo[2] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdGerenciaRegional((Integer) dadosAnormalidadesConsumo[2]);
				}

				// Nome da Gerência Regional
				if (dadosAnormalidadesConsumo[3] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setNomeGerenciaRegional((String) dadosAnormalidadesConsumo[3]);
				}

				// Id da Unidade de Negócio
				if (dadosAnormalidadesConsumo[4] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdUnidadeNegocio((Integer) dadosAnormalidadesConsumo[4]);
				}

				// Nome da Unidade de Negócio
				if (dadosAnormalidadesConsumo[5] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setNomeUnidadeNegocio((String) dadosAnormalidadesConsumo[5]);
				}

				// Id do Elo
				if (dadosAnormalidadesConsumo[6] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdElo((Integer) dadosAnormalidadesConsumo[6]);
				}

				// Nome do Elo
				if (dadosAnormalidadesConsumo[7] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setNomeElo((String) dadosAnormalidadesConsumo[7]);
				}

				// Id da Localidade
				if (dadosAnormalidadesConsumo[8] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdLocalidade((Integer) dadosAnormalidadesConsumo[8]);
				}

				// Nome da Localidade
				if (dadosAnormalidadesConsumo[9] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setNomeLocalidade((String) dadosAnormalidadesConsumo[9]);
				}

				// Id do Imóvel
				if (dadosAnormalidadesConsumo[10] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdImovel((Integer) dadosAnormalidadesConsumo[10]);
				}

				// Nome do Usuário
				if (dadosAnormalidadesConsumo[11] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setNomeUsuario((String) dadosAnormalidadesConsumo[11]);
				}

				// Id da Situação de Água
				if (dadosAnormalidadesConsumo[12] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setSituacaoLigacaoAgua((Integer) dadosAnormalidadesConsumo[12]);
				}

				// Id da Situação de Esgoto
				if (dadosAnormalidadesConsumo[13] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setSituacaoLigacaoEsgoto((Integer) dadosAnormalidadesConsumo[13]);
				}

				// Indicador de Débito Automático
				if (dadosAnormalidadesConsumo[14] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIndicadorDebito((Short) dadosAnormalidadesConsumo[14]);
				}

				// Consumo Médio
				if (dadosAnormalidadesConsumo[15] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setConsumoMedio((Integer) dadosAnormalidadesConsumo[15]);
				}

				// Consumo do Mês
				if (dadosAnormalidadesConsumo[16] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setConsumoMes((Integer) dadosAnormalidadesConsumo[16]);
				}

				// Descrição Abreviada da Anormalidade de Consumo
				if (dadosAnormalidadesConsumo[17] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setDescricaoAbrevConsumoAnormalidade((String) dadosAnormalidadesConsumo[17]);
				}

				// Id da Anormalidade de Leitura
				if (dadosAnormalidadesConsumo[18] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdLeituraAnormalidade((Integer) dadosAnormalidadesConsumo[18]);
				}

				// Quantidade de Economias
				if (dadosAnormalidadesConsumo[19] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setQuantidadeEconomias((Short) dadosAnormalidadesConsumo[19]);
				}

				// Tipo de Medição
				if (dadosAnormalidadesConsumo[20] != null) {

					if (dadosAnormalidadesConsumo[20].equals(MedicaoTipo.POCO)) {
						gerarRelatorioAnormalidadeConsumoHelper
								.setTipoMedicao("PC");
					} else {
						gerarRelatorioAnormalidadeConsumoHelper
								.setTipoMedicao("LA");
					}

				} else {
					gerarRelatorioAnormalidadeConsumoHelper.setTipoMedicao("");
				}

				// Descrição Abreviada da Capacidade do Hidrômetro da
				// Ligação de Água
				if (dadosAnormalidadesConsumo[21] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setCapacidadeHidrometro((String) dadosAnormalidadesConsumo[21]);
				}

				// Descrição Abreviada do Local de Instalação do Hidrômetro
				// da Ligação de Água
				if (dadosAnormalidadesConsumo[22] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setLocalInstalacaoHidrometro((String) dadosAnormalidadesConsumo[22]);
				}

				// Id do Setor Comercial
				if (dadosAnormalidadesConsumo[23] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdSetorComercial((Integer) dadosAnormalidadesConsumo[23]);
				}

				// Código do Setor Comercial
				if (dadosAnormalidadesConsumo[24] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setCodigoSetorComercial((Integer) dadosAnormalidadesConsumo[24]);
				}

				// Número leitura atual informada
				if (dadosAnormalidadesConsumo[25] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setNnLeituraAtualInformada((Integer) dadosAnormalidadesConsumo[25]);
				}

				// Id Empresa
				if (dadosAnormalidadesConsumo[26] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setIdEmpresa((Integer) dadosAnormalidadesConsumo[26]);
				}

				// Nome Empresa
				if (dadosAnormalidadesConsumo[27] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setNomeEmpresa((String) dadosAnormalidadesConsumo[27]);
				}

				// inscrição do Imóvel
				if (dadosAnormalidadesConsumo[28] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setInscricaoImovel((String) dadosAnormalidadesConsumo[28]);
				}
				if (dadosAnormalidadesConsumo[29] != null) {
					gerarRelatorioAnormalidadeConsumoHelper
							.setEnderecoImovel((String) dadosAnormalidadesConsumo[29]);
				}

				retorno.add(gerarRelatorioAnormalidadeConsumoHelper);
			}
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * Gerar um perído de leitura para faturamento
	 * 
	 * @author Raphael Rossiter
	 * @data 18/09/2007
	 */
	public Date[] gerarPeriodoLeituraFaturamento(
			Date dataLeituraAtualFaturamento,
			Date dataLeituraAnteriorFaturamento,
			FaturamentoGrupo faturamentoGrupo, Integer anoMesFaturamento,
			Integer anoMesFaturamentoAnterior) throws ControladorException {

		Date[] periodoFaturamento = new Date[2];

		if (dataLeituraAtualFaturamento != null) {

			periodoFaturamento[1] = dataLeituraAtualFaturamento;

			// Obter data Prevista do cronograma do mês anterior
			try {

				dataLeituraAnteriorFaturamento = (Date) repositorioFaturamento
						.pesquisarFaturamentoAtividadeCronogramaDataPrevista(
								faturamentoGrupo.getId(),
								FaturamentoAtividade.EFETUAR_LEITURA,
								anoMesFaturamentoAnterior);

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			/*
			 * Caso a data prevista do cronograma anterior esteja nula, a data
			 * de leitura anterior do faturamento será: a data de leitura atual
			 * menos 30 dias
			 */
			if (dataLeituraAnteriorFaturamento == null) {
				dataLeituraAnteriorFaturamento = Util
						.subtrairNumeroDiasDeUmaData(
								dataLeituraAtualFaturamento, 30);

			}

			periodoFaturamento[0] = dataLeituraAnteriorFaturamento;

		} else if (dataLeituraAnteriorFaturamento != null) {

			periodoFaturamento[0] = dataLeituraAnteriorFaturamento;

			/*
			 * Caso a data de leitura anterior NÃO esteja nula: a data de
			 * leitura atual será a data de leitura anterior acrescida de mais
			 * 30 dias.
			 */
			dataLeituraAtualFaturamento = Util.adicionarNumeroDiasDeUmaData(
					dataLeituraAnteriorFaturamento, 30);

			periodoFaturamento[1] = dataLeituraAtualFaturamento;
		} else {

			/*
			 * Caso as datas de letira anterior e atual estejam nulas, o periodo
			 * será gerado a partir do anoMes de referencia da conta.
			 */
			int mesConta = Util.obterMes(anoMesFaturamento);
			int anoConta = Util.obterAno(anoMesFaturamento);

			int ultimoDiaMes = new Integer(Util.obterUltimoDiaMes(mesConta,
					anoConta));

			dataLeituraAtualFaturamento = Util.criarData(ultimoDiaMes,
					mesConta, anoConta);

			dataLeituraAnteriorFaturamento = Util.criarData(1, mesConta,
					anoConta);

			periodoFaturamento[0] = dataLeituraAnteriorFaturamento;
			periodoFaturamento[1] = dataLeituraAtualFaturamento;
		}

		return periodoFaturamento;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 18/09/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasAtualizacaoTarifaria(Integer idImovel,
			Integer inicialReferencia, Integer finalReferencia,
			Date inicialVencimento, Date finalVencimento,
			Integer indicadorContasRevisao) throws ControladorException {

		Collection retorno = null;
		Collection colecaoContasAtualizacaoTarifaria = null;
		Conta conta = null;

		try {

			colecaoContasAtualizacaoTarifaria = repositorioFaturamento
					.pesquisarContasAtualizacaoTarifaria(idImovel,
							inicialReferencia, finalReferencia,
							inicialVencimento, finalVencimento,
							indicadorContasRevisao);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoContasAtualizacaoTarifaria != null
				&& !colecaoContasAtualizacaoTarifaria.isEmpty()) {

			Iterator colecaoContasAtualizacaoTarifariaIterator = colecaoContasAtualizacaoTarifaria
					.iterator();
			retorno = new ArrayList();

			while (colecaoContasAtualizacaoTarifariaIterator.hasNext()) {

				Object[] arrayConta = (Object[]) colecaoContasAtualizacaoTarifariaIterator
						.next();
				conta = new Conta();
				boolean contaPaga = false;

				conta.setId((Integer) arrayConta[0]);

				if (arrayConta[1] != null) {
					conta.setConsumoAgua((Integer) arrayConta[1]);
				}

				if (arrayConta[2] != null) {
					conta.setConsumoEsgoto((Integer) arrayConta[2]);
				}

				LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
				ligacaoAguaSituacao.setId((Integer) arrayConta[3]);

				conta.setLigacaoAguaSituacao(ligacaoAguaSituacao);

				LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
				ligacaoEsgotoSituacao.setId((Integer) arrayConta[4]);

				conta.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

				ConsumoTarifa consumoTarifa = new ConsumoTarifa();
				consumoTarifa.setId((Integer) arrayConta[5]);

				conta.setConsumoTarifa(consumoTarifa);

				if (arrayConta[6] != null) {
					conta.setPercentualEsgoto((BigDecimal) arrayConta[6]);
				}

				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				faturamentoGrupo.setId((Integer) arrayConta[10]);

				Rota rota = new Rota();
				rota.setId((Integer) arrayConta[9]);
				rota.setFaturamentoGrupo(faturamentoGrupo);

				Quadra quadra = new Quadra();
				quadra.setId((Integer) arrayConta[8]);
				quadra.setRota(rota);

				Imovel imovel = new Imovel();
				imovel.setId((Integer) arrayConta[7]);

				imovel.setQuadra(quadra);

				conta.setImovel(imovel);

				if (arrayConta[11] != null) {
					conta.setValorAgua((BigDecimal) arrayConta[11]);
				}

				if (arrayConta[12] != null) {
					conta.setValorEsgoto((BigDecimal) arrayConta[12]);
				}

				conta.setReferencia((Integer) arrayConta[13]);

				// adicionado por Vivianne Sousa 17/03/2009 - analista:Adriano
				// Britto
				Collection dadosPagamento = null;
				try {

					dadosPagamento = repositorioCobranca
							.pesquisarValorTotalPagamentoMenorDataPagamento(conta
									.getId().toString());

				} catch (ErroRepositorioException ex) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				// verifica o valor de pagamento da conta
				if (dadosPagamento != null && !dadosPagamento.isEmpty()) {

					Object[] dadosPagamentoArray = (Object[]) dadosPagamento
							.iterator().next();

					if (dadosPagamentoArray[0] != null) {
						contaPaga = true;
					}

				}

				if (!contaPaga) {
					retorno.add(conta);
				}
			}

		}
		return retorno;

	}

	/**
	 * Pesquisa os Valores das Faixas de Débitos
	 * 
	 * @author Ivan Sérgio
	 * @created 14/09/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDebitoFaixaValores(Integer idFaixaValor,
			Double valorFaixa) throws ControladorException {

		Collection colecaoDebitoFaixaValores = null;

		try {
			colecaoDebitoFaixaValores = repositorioFaturamento
					.pesquisarDebitoFaixaValores(idFaixaValor, valorFaixa);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		return colecaoDebitoFaixaValores;
	}

	public void removerQualidadeAgua(String[] ids, Usuario usuarioLogado)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_ARRECADADOR_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(
				usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// [SB0002]
		this.getControladorUtil().remover(ids, QualidadeAgua.class.getName(),
				null, null);
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0003] - Obter Diferenças de
	 * Valores de Créditos Realizados de Conta Retificada Author: Pedro
	 * Alexandre Data: 27/10/2007
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsOrigemCredito
	 * 
	 * @throws ControladorException
	 */
	private BigDecimal[] obterDiferencaValoresCreditosRealizadosContaRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsOrigemCredito) throws ControladorException {

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal[] retorno = new BigDecimal[2];

		BigDecimal valorCreditoRealizadoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorCreditoRealizadoSituacaoRetificada = null;

		try {
			// obtém o valor dos creditos realizados cancelados do retificação
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = repositorioFaturamento
					.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoCanceladoPorRetificacao(
							anoMesReferencia, idLocalidade, idCategoria,
							idsOrigemCredito);

			// obtém o valor dos creditos realizados retificados
			valorCreditoRealizadoSituacaoRetificada = repositorioFaturamento
					.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoRetificada(
							anoMesReferencia, idLocalidade, idCategoria,
							idsOrigemCredito);

			// erro no hibernate
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		if (valorCreditoRealizadoSituacaoCanceladoPorRetificacao == null) {
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
		}

		if (valorCreditoRealizadoSituacaoRetificada == null) {
			valorCreditoRealizadoSituacaoRetificada = BigDecimal.ZERO;
		}

		// Valores cancelados acumulados
		retorno[0] = valorCreditoRealizadoSituacaoCanceladoPorRetificacao;

		// Valores incluidos acumulados
		retorno[1] = valorCreditoRealizadoSituacaoRetificada;

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * [SB0003] - Obter Diferenças de Valores de Créditos Realizados de Conta
	 * Retificada
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 27/10/2007, 06/03/2008
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsOrigemCredito
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ControladorException
	 */
	private BigDecimal[] obterDiferencaValoresCreditosRealizadosContaRetificada(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsOrigemCredito, Integer idLancamentoItemContabil)
			throws ControladorException {

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado (cancelados e incluido por
		// refaturamento)
		BigDecimal[] retorno = new BigDecimal[2];

		BigDecimal valorCreditoRealizadoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorCreditoRealizadoSituacaoRetificada = null;

		try {
			// obtém o valor dos creditos realizados cancelados do retificação
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = repositorioFaturamento
					.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabilCanceladoPorRetificacao(
							anoMesReferencia, idLocalidade, idCategoria,
							idsOrigemCredito, idLancamentoItemContabil);

			// obtém o valor dos creditos realizados retificados
			valorCreditoRealizadoSituacaoRetificada = repositorioFaturamento
					.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabilRetificada(
							anoMesReferencia, idLocalidade, idCategoria,
							idsOrigemCredito, idLancamentoItemContabil);

			// erro no hibernate
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		if (valorCreditoRealizadoSituacaoCanceladoPorRetificacao == null) {
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
		}

		if (valorCreditoRealizadoSituacaoRetificada == null) {
			valorCreditoRealizadoSituacaoRetificada = BigDecimal.ZERO;
		}

		// Valores cancelados acumulados
		retorno[0] = valorCreditoRealizadoSituacaoCanceladoPorRetificacao;

		// Valores incluidos acumulados
		retorno[1] = valorCreditoRealizadoSituacaoRetificada;

		return retorno;
	}

	/**
	 * [UC0626] Gerar Resumo de Metas Acumulado no Mês (CAERN)
	 * 
	 * @author Sávio Luiz
	 * @data 28/11/2007
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public boolean verificarDebitoMais3MesesFaturaEmAberto(
			Integer anoMesReferencia, Integer idImovel)
			throws ControladorException {
		boolean verificarDebito = false;

		Collection idsContas = null;
		try {
			idsContas = repositorioFaturamento
					.pesquisarIdsContasDoImovelPorMesAnoReferencia(
							anoMesReferencia, idImovel);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		if (idsContas != null && idsContas.size() > 3) {
			Collection colecaoPagamento = getControladorArrecadacao()
					.pesquisarPagamentoDeContas(idsContas);

			if (colecaoPagamento == null || colecaoPagamento.isEmpty()) {
				verificarDebito = true;
			}
		}

		return verificarDebito;
	}

	public Boolean pesquisarExisteciaParcelamentoConta(Integer idConta)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarExisteciaParcelamentoConta(idConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	// /////////////////////////////////////////////////////////////////////////

	/**
	 * [UC0348] Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa, Mariana Victor
	 * @date 08/01/2007,29/11/2007, 11/03/2011
	 * 
	 * @return
	 * @throws ControladorException
	 * @throws ControladorException
	 */
	protected Collection<EmitirContaHelper> formatarEmitirContasHelperOuFichaCompensacao(
			Collection colecaoPamsContas, int i) throws ControladorException {
		Collection<EmitirContaHelper> colecaoContas = new ArrayList();
		if (colecaoPamsContas != null) {
			Iterator iteColecaoContas = colecaoPamsContas.iterator();
			while (iteColecaoContas.hasNext()) {
				Object[] parmsConta = (Object[]) iteColecaoContas.next();
				if (parmsConta != null) {
					EmitirContaHelper emitirContaHelper = new EmitirContaHelper();
					// id da conta
					if (parmsConta[0] != null) {
						emitirContaHelper.setIdConta((Integer) parmsConta[0]);
					}
					if (i == 3 || i == 4 || i == 7 || i == 8) {
						// nome cliente
						if (parmsConta[1] != null) {
							/*
							 * Alterado por: Mariana Victor Data: 11/03/2011
							 */
							String nomeCliente = this
									.obterNomeCliente(emitirContaHelper
											.getIdConta());
							emitirContaHelper.setNomeCliente(nomeCliente);
						}
						// nome cliente
						if (parmsConta[32] != null) {
							emitirContaHelper
									.setNomeImovel((String) parmsConta[32]);
						}
					} else {
						if (parmsConta[32] != null) {
							emitirContaHelper
									.setNomeCliente((String) parmsConta[32]);
						} else {
							// nome cliente
							if (parmsConta[1] != null) {
								/*
								 * Alterado por: Mariana Victor Data: 11/03/2011
								 */
								String nomeCliente = this
										.obterNomeCliente(emitirContaHelper
												.getIdConta());
								emitirContaHelper.setNomeCliente(nomeCliente);
							}
						}
					}
					// data vencimento da conta
					if (parmsConta[2] != null) {
						emitirContaHelper
								.setDataVencimentoConta((Date) parmsConta[2]);
					}
					// ano mes referencia da conta
					if (parmsConta[3] != null) {
						emitirContaHelper
								.setAmReferencia((Integer) parmsConta[3]);
					}
					// digito verificador da conta
					if (parmsConta[4] != null) {
						emitirContaHelper
								.setDigitoVerificadorConta((Short) parmsConta[4]);
					}
					// codigo setor comercial da conta
					if (parmsConta[5] != null) {
						emitirContaHelper
								.setCodigoSetorComercialConta((Integer) parmsConta[5]);
					}
					// id da quadra da conta
					if (parmsConta[6] != null) {
						emitirContaHelper
								.setIdQuadraConta((Integer) parmsConta[6]);
					}
					// lote da conta
					if (parmsConta[7] != null) {
						emitirContaHelper.setLoteConta((Short) parmsConta[7]);
					}
					// sublote da conta
					if (parmsConta[8] != null) {
						emitirContaHelper
								.setSubLoteConta((Short) parmsConta[8]);
					}
					// consumo agua
					if (parmsConta[9] != null) {
						emitirContaHelper
								.setConsumoAgua((Integer) parmsConta[9]);
					}
					// consumo esgoto
					if (parmsConta[10] != null) {
						emitirContaHelper
								.setConsumoEsgoto((Integer) parmsConta[10]);
					}
					// valor agua
					if (parmsConta[11] != null) {
						emitirContaHelper
								.setValorAgua((BigDecimal) parmsConta[11]);
					}
					// valor esgoto
					if (parmsConta[12] != null) {
						emitirContaHelper
								.setValorEsgoto((BigDecimal) parmsConta[12]);
					}
					// id da conta
					if (parmsConta[13] != null) {
						emitirContaHelper
								.setDebitos((BigDecimal) parmsConta[13]);
					}
					// id da conta
					if (parmsConta[14] != null) {
						emitirContaHelper
								.setValorCreditos((BigDecimal) parmsConta[14]);
					}
					// id da conta
					if (parmsConta[15] != null) {
						emitirContaHelper
								.setValorImpostos((BigDecimal) parmsConta[15]);
					}
					// id da conta
					if (parmsConta[16] != null) {
						emitirContaHelper
								.setDataValidadeConta((Date) parmsConta[16]);
					}
					// id da conta
					if (parmsConta[17] != null) {
						emitirContaHelper.setIdImovel((Integer) parmsConta[17]);
					}
					// id da conta
					if (parmsConta[18] != null) {
						emitirContaHelper
								.setIdLocalidade((Integer) parmsConta[18]);
					}
					// id da conta
					if (parmsConta[19] != null) {
						emitirContaHelper
								.setIdGerenciaRegional((Integer) parmsConta[19]);
					}
					// id da conta
					if (parmsConta[20] != null) {
						emitirContaHelper
								.setNomeGerenciaRegional((String) parmsConta[20]);
					}
					// id da conta
					if (parmsConta[21] != null) {
						emitirContaHelper
								.setIdLigacaoAguaSituacao((Integer) parmsConta[21]);
					}
					// id da conta
					if (parmsConta[22] != null) {
						emitirContaHelper
								.setIdLigacaoEsgotoSituacao((Integer) parmsConta[22]);
					}
					// id da conta
					if (parmsConta[23] != null) {
						emitirContaHelper
								.setIdImovelPerfil((Integer) parmsConta[23]);
					}
					// id da conta
					if (parmsConta[24] != null) {
						emitirContaHelper
								.setIdSetorComercial((Integer) parmsConta[24]);
					}
					// id da conta
					if (parmsConta[25] != null) {
						emitirContaHelper
								.setIdFaturamentoGrupo((Integer) parmsConta[25]);
					}
					// id da conta
					if (parmsConta[26] != null) {
						emitirContaHelper
								.setIdEmpresa((Integer) parmsConta[26]);
					}
					// id da conta
					if (parmsConta[27] != null) {
						emitirContaHelper
								.setDescricaoLocalidade((String) parmsConta[27]);
					}
					// id da conta
					if (parmsConta[28] != null) {
						emitirContaHelper
								.setDescricaoLigacaoAguaSituacao((String) parmsConta[28]);
					}
					// id da conta
					if (parmsConta[29] != null) {
						emitirContaHelper
								.setDescricaoLigacaoEsgotoSituacao((String) parmsConta[29]);
					}
					// id da conta
					if (parmsConta[30] != null) {
						emitirContaHelper
								.setPercentualEsgotoConta((BigDecimal) parmsConta[30]);
					}
					// nome cliente
					if (parmsConta[31] != null) {
						emitirContaHelper.setIdClienteResponsavel(""
								+ (Integer) parmsConta[31]);
					}

					if (parmsConta[31] != null) {
						emitirContaHelper.setIdClienteResponsavel(""
								+ (Integer) parmsConta[31]);
					}

					int tam = parmsConta.length;
					if (tam > 34) {
						// id da rota
						if (parmsConta[33] != null) {
							emitirContaHelper
									.setCodigoRota((Short) parmsConta[33]);
						}

						// numero sequencial rota
						if (parmsConta[34] != null) {
							emitirContaHelper
									.setNumeroSequencialRota((Integer) parmsConta[34]);
						}

						// origem
						if (parmsConta[35] != null) {
							emitirContaHelper
									.setIdOrigem((Integer) parmsConta[35]);
						}

						// debitoCreditoSituacaoAtual
						if (parmsConta[36] != null) {
							emitirContaHelper
									.setDebitoCreditoSituacaoAtualConta((Integer) parmsConta[36]);
						}

						// id do funcionario
						if (parmsConta[37] != null) {
							emitirContaHelper
									.setIdFuncionario((Integer) parmsConta[37]);
						}

						// nome do funcionario
						if (parmsConta[38] != null) {
							emitirContaHelper
									.setNomeFuncionario((String) parmsConta[38]);
						}

						// valor Conta
						if (tam > 39 && parmsConta[39] != null) {
							emitirContaHelper
									.setValorConta((BigDecimal) parmsConta[39]);
						}

						// cpf
						if (tam > 40 && parmsConta[40] != null) {
							emitirContaHelper.setCpf((String) parmsConta[40]);
						}

					}

					colecaoContas.add(emitirContaHelper);
					emitirContaHelper = null;
				}

			}
		}
		return colecaoContas;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0009] Obter Mensagem de Rateio de Consumo ou Consumo fixo de Esgoto
	 * 
	 * @author Vivianne Sousa
	 * @date 13/11/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder obterMensagemRateioConsumoFichaCompensacao(
			EmitirContaHelper emitirContaHelper, String consumoRateio,
			Object[] parmsMedicaoHistorico, Integer tipoMedicao)
			throws ControladorException {
		StringBuilder mensagemConsumo = new StringBuilder();
		// caso o consumo de rateio seja diferente de vazio
		if (!consumoRateio.equals("") && !consumoRateio.equals("0")) {
			mensagemConsumo.append("CONSUMO DO RATEIO - ");
			mensagemConsumo.append(Util.completaStringComEspacoAEsquerda(
					consumoRateio, 6));
			mensagemConsumo.append("M3");
			// senão completa com espaços em branco
			mensagemConsumo.append(Util.completaString("", 3));
		} else {
			// senão caso o tipo de medição seja diferente de nulo e seja poço e
			// não existam dados para a medição
			if (tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO)
					&& parmsMedicaoHistorico == null) {
				mensagemConsumo.append("VOLUME FIXO DE ESGOTO - ");
				mensagemConsumo.append(Util.completaStringComEspacoAEsquerda(""
						+ emitirContaHelper.getConsumoEsgoto(), 5));
				mensagemConsumo.append("M3");

			} else {
				// caso o tipo de medição seja diferente de nulo e seja ligação
				// de agua e
				// o consumo de esgoto seja diferente de nulo d maior que o
				// consumo de agua
				if (tipoMedicao != null
						&& tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)
						&& emitirContaHelper.getConsumoEsgoto() != null
						&& emitirContaHelper.getConsumoEsgoto() > emitirContaHelper
								.getConsumoAgua()) {

					mensagemConsumo.append("VOLUME FIXO DE ESGOTO - ");
					mensagemConsumo.append(Util
							.completaStringComEspacoAEsquerda(""
									+ emitirContaHelper.getConsumoEsgoto(), 5));
					mensagemConsumo.append("M3");

				} else {
					// senão completa com espaços em branco
					mensagemConsumo.append(Util.completaString("", 31));
				}
			}
		}

		return mensagemConsumo;
	}

	/**
	 * [UC0352] Emitir Contas e Cartas
	 * 
	 * [SB0031] Obter Representação numérica do Nosso Número da Ficha de
	 * Compensação
	 * 
	 * @author Vivianne Sousa
	 * @date 13/11/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder obterNossoNumeroFichaCompensacao(
			String idDocumentoTipo, String idDocumentoEmitido)
			throws ControladorException {
		StringBuilder nossoNumero = new StringBuilder();

		// é o numero do convênio fornecido pelo Banco
		// número fixo e não pode ser alterado
		nossoNumero.append("2502792");

		// id do documento tipo de acordo com o tipo de documento q esta sendo
		// emitido
		nossoNumero
				.append(Util.adicionarZerosEsquedaNumero(2, idDocumentoTipo));

		// id do documento q esta sendo emitido
		Integer numeroBoletoDocumentoConta = null;

		if (idDocumentoTipo.trim().equals(DocumentoTipo.CONTA)) {

			numeroBoletoDocumentoConta = this
					.pesquisarSequencialContaBoleto(Integer
							.valueOf(idDocumentoEmitido));
		}

		if (numeroBoletoDocumentoConta != null) {

			nossoNumero.append(Util.adicionarZerosEsquedaNumero(8,
					numeroBoletoDocumentoConta.toString()));
		} else {

			nossoNumero.append(Util.adicionarZerosEsquedaNumero(8,
					idDocumentoEmitido));
		}

		/*
		 * Integer digito = Util.obterDigitoVerificadorModulo11(nossoNumero
		 * .toString());
		 * 
		 * nossoNumero.append("-");
		 * 
		 * nossoNumero.append(digito);
		 */

		return nossoNumero;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00010] Gerar Linhas da Descrição dos Serviços e Tarifas
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasDescricaoServicoTarifasFichaCompensacao(
			EmitirContaHelper emitirContaHelper, String consumoRateio,
			Object[] parmsMedicaoHistorico, Integer tipoMedicao)
			throws ControladorException {

		StringBuilder linhasDescricaoServicosTarifasTotal = new StringBuilder();
		// caso o valor da agua da conta seja maior que zero
		if (emitirContaHelper.getValorAgua() != null
				&& emitirContaHelper.getValorAgua().compareTo(
						new BigDecimal("0.00")) == 1) {

			// [SB0011] - Gerar Linhas da Tarifa de Água
			StringBuilder linhasTarifaAgua = gerarLinhasTarifaAguaFichaCompensacao(
					emitirContaHelper, consumoRateio, parmsMedicaoHistorico,
					tipoMedicao);
			linhasDescricaoServicosTarifasTotal.append(linhasTarifaAgua);
		}
		// caso o valor de água de esgoto seja maior que zero
		if (emitirContaHelper.getValorEsgoto() != null
				&& emitirContaHelper.getValorEsgoto().compareTo(
						new BigDecimal("0.00")) == 1) {

			// [SB0012] - Gerar Linhas da tarifa de Esgoto
			StringBuilder linhasTarifaEsgoto = gerarLinhasTarifaEsgotoFichaCompensacao(emitirContaHelper);
			linhasDescricaoServicosTarifasTotal.append(linhasTarifaEsgoto);

		}
		// caso o valor de debitos cobrados da conta seja maior que zero
		if (emitirContaHelper.getDebitos() != null
				&& emitirContaHelper.getDebitos().compareTo(
						new BigDecimal("0.00")) == 1) {

			// [SB0013] - Gerar Linhas de Débitos Cobrados
			StringBuilder linhasDebitoCobrados = gerarLinhasDebitoCobradosFichaCompensacao(emitirContaHelper);
			linhasDescricaoServicosTarifasTotal.append(linhasDebitoCobrados);

		}
		// caso o valor de créditos realizados seja maior que zero
		if (emitirContaHelper.getValorCreditos() != null
				&& emitirContaHelper.getValorCreditos().compareTo(
						new BigDecimal("0.00")) == 1) {

			// [SB0014] - Gerar Linhas de Crédito Realizado
			StringBuilder linhasCreditoRealizados = gerarLinhasCreditosRealizadosFichaCompensacao(emitirContaHelper);
			linhasDescricaoServicosTarifasTotal.append(linhasCreditoRealizados);

		}
		// caso o valor dos impostos retidos seja maior que zero
		if (emitirContaHelper.getValorImpostos() != null
				&& emitirContaHelper.getValorImpostos().compareTo(
						new BigDecimal("0.00")) == 1) {

			// [SB0015] - Gerar Linhas dos Impostos Retidos
			StringBuilder linhasImpostosRetidos = gerarLinhasImpostosRetidosFichaCompensacao(emitirContaHelper);
			linhasDescricaoServicosTarifasTotal.append(linhasImpostosRetidos);

		}

		return linhasDescricaoServicosTarifasTotal;

	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00011] Gerar Linhas da Tarifa de Água
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasTarifaAguaFichaCompensacao(
			EmitirContaHelper emitirContaHelper, String consumoRateio,
			Object[] parmsMedicaoHistorico, Integer tipoMedicao)
			throws ControladorException {

		StringBuilder linhasTarifaAgua = new StringBuilder();
		// descricao dos serviçoes e tarifas (tam 50)
		linhasTarifaAgua.append(Util.completaString("AGUA", 50));

		// consumo por faixa (tam 15) + valor (tam 14)
		linhasTarifaAgua.append(Util.completaString("", 29));

		Collection colecaoContaCategoriaComFaixas = null;
		try {
			colecaoContaCategoriaComFaixas = repositorioFaturamento
					.pesquisarContaCategoria(emitirContaHelper.getIdConta());
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (colecaoContaCategoriaComFaixas != null
				&& !colecaoContaCategoriaComFaixas.isEmpty()) {
			Iterator iteratorContaCategoriaComFaixas = colecaoContaCategoriaComFaixas
					.iterator();
			while (iteratorContaCategoriaComFaixas.hasNext()) {
				ContaCategoria contaCategoria = (ContaCategoria) iteratorContaCategoriaComFaixas
						.next();

				// descricao dos serviçoes e tarifas (tam 50)
				// descricao da categoria
				linhasTarifaAgua.append(Util.completaString(contaCategoria
						.getComp_id().getCategoria().getDescricao(), 13));
				// quantidade de economias
				linhasTarifaAgua.append(Util.adicionarZerosEsquedaNumero(3, ""
						+ contaCategoria.getQuantidadeEconomia()));
				// completa com espaços em branco
				linhasTarifaAgua.append(Util.completaString("", 2));
				if (contaCategoria.getQuantidadeEconomia() == 1) {
					linhasTarifaAgua
							.append(Util.completaString("UNIDADE ", 32));
				} else {
					linhasTarifaAgua
							.append(Util.completaString("UNIDADES", 32));
				}

				// consumo por faixa (tam 15) + valor (tam 14)
				linhasTarifaAgua.append(Util.completaString("", 29));

				// caso não existam dados de medição
				if (parmsMedicaoHistorico == null) {

					// descricao dos serviçoes e tarifas (tam 50)
					// Constante
					linhasTarifaAgua.append("TARIFA MÍNIMA");

					// Valor da tarifa mínima de água para a categoria por
					// economia
					BigDecimal qtdEconomia = Util
							.formatarMoedaRealparaBigDecimal(""
									+ contaCategoria.getQuantidadeEconomia());
					String valorTarifaMinima = "";
					if (contaCategoria.getValorTarifaMinimaAgua() != null
							&& qtdEconomia != null) {
						BigDecimal valorTarifaMinimaBigDecimal = contaCategoria
								.getValorTarifaMinimaAgua().divide(qtdEconomia,
										2, RoundingMode.UP);
						valorTarifaMinima = Util
								.formatarMoedaReal(valorTarifaMinimaBigDecimal);
					}

					linhasTarifaAgua.append(Util
							.completaStringComEspacoAEsquerda(
									valorTarifaMinima, 6));
					// completa com espaços em branco
					linhasTarifaAgua.append(" ");
					// Constante
					linhasTarifaAgua.append("POR UNIDADE");
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 19));

					// consumo por faixa (tam 15)
					// Constante
					linhasTarifaAgua.append("MINIMO");
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 9));

					// valor (tam 14)
					// valor da água para categoria
					String valorAgua = Util.formatarMoedaReal(contaCategoria
							.getValorAgua());
					linhasTarifaAgua.append(Util
							.completaStringComEspacoAEsquerda(valorAgua, 14));

				} else {
					// recupera a coleção de conta categoria consumo faixa
					Collection colecaoContaCategoriaConsumoFaixa = null;
					try {
						colecaoContaCategoriaConsumoFaixa = repositorioFaturamento
								.pesquisarContaCategoriaFaixas(
										emitirContaHelper.getIdConta(),
										contaCategoria.getComp_id()
												.getCategoria().getId());
					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}

					if (colecaoContaCategoriaConsumoFaixa != null
							&& !colecaoContaCategoriaConsumoFaixa.isEmpty()) {

						// descricao dos serviçoes e tarifas (tam 50)
						// Constante
						linhasTarifaAgua.append(" ATE");
						// Constante
						linhasTarifaAgua.append(" ");
						// Consumo mínimo de água para a categoria por economia

						BigDecimal qtdEconomia = Util
								.formatarMoedaRealparaBigDecimal(""
										+ contaCategoria
												.getQuantidadeEconomia());

						BigDecimal consumoMinimoAgua = null;
						if (contaCategoria.getConsumoMinimoAgua() != null) {
							consumoMinimoAgua = Util
									.formatarMoedaRealparaBigDecimal(""
											+ contaCategoria
													.getConsumoMinimoAgua());
						}

						BigDecimal consumoMinimaBigDecimal = new BigDecimal(
								"0.00");
						if (consumoMinimoAgua != null && qtdEconomia != null) {
							consumoMinimaBigDecimal = consumoMinimoAgua.divide(
									qtdEconomia, 2, RoundingMode.UP);
						}

						String consumoMinima = ""
								+ consumoMinimaBigDecimal.intValue();

						// CRC3001 - Por Ivan Sergio
						// linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoMinima,
						// 2));
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(
										consumoMinima, 6));
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append("M3");
						// completa com espaços em branco
						// CRC3001 - Por Ivan Sergio
						// linhasTarifaAgua.append(Util.completaString("", 7));
						linhasTarifaAgua.append(Util.completaString("", 3));
						// Constante
						linhasTarifaAgua.append("- R$");
						// valor da tarifa minima de agua para a categoria por
						// economia
						BigDecimal valorTarifaMinimaBigDecimal = null;
						if (contaCategoria.getValorTarifaMinimaAgua() != null
								&& qtdEconomia != null) {
							valorTarifaMinimaBigDecimal = contaCategoria
									.getValorTarifaMinimaAgua().divide(
											qtdEconomia, 2, RoundingMode.UP);
						}
						String valorTarifaMinima = Util
								.formatarMoedaReal(valorTarifaMinimaBigDecimal);
						// CRC3001 - Por Ivan Sergio
						// linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaMinima,
						// 6));
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(
										valorTarifaMinima, 11));
						// completa com espaços em branco
						// CRC3001 - Por Ivan Sergio
						// linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append(" (POR UNIDADE)");
						// completa com espaços em branco
						// CRC3001 - Por Ivan Sergio
						// linhasTarifaAgua.append(Util.completaString("", 8));
						linhasTarifaAgua.append(Util.completaString("", 4));

						// consumo por faixa (tam 15)
						// Consumo mínimo de água
						if (contaCategoria.getConsumoMinimoAgua() != null
								&& !contaCategoria.getConsumoMinimoAgua()
										.equals("")) {
							linhasTarifaAgua
									.append(Util.completaStringComEspacoAEsquerda(
											""
													+ contaCategoria
															.getConsumoMinimoAgua(),
											6));
						} else {
							linhasTarifaAgua.append(Util
									.completaStringComEspacoAEsquerda("", 6));
						}
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append("M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 6));

						// valor (tam 14)
						// valor agua para categoria
						String valorAguaCategoria = "";
						if (contaCategoria.getValorTarifaMinimaAgua() != null) {
							valorAguaCategoria = Util
									.formatarMoedaReal(contaCategoria
											.getValorTarifaMinimaAgua());
						}
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(
										valorAguaCategoria, 14));

						Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa
								.iterator();
						while (iteratorContaCategoriaConsumoFaixa.hasNext()) {
							ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) iteratorContaCategoriaConsumoFaixa
									.next();

							// descricao dos serviçoes e tarifas (tam 50)
							// completa com espaços em branco
							linhasTarifaAgua.append(" ");
							// caso a faixa seja a ultima ta tarifa de consumo
							if (contaCategoriaConsumoFaixa.getConsumoFaixaFim()
									.equals(999999)) {
								// Constante
								linhasTarifaAgua.append("ACIMA DE");
								// Consumo inicial da faixa menos 1 m3
								String consumoInicialFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaInicio() - 1);
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												consumoInicialFaixa, 5));
								// Constante
								linhasTarifaAgua.append(" M3 - R$");
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorTarifaFaixa());
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												valorTarifaFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" POR M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										15));

								// consumo por faixa (tam 15)
								// consumo da agua
								linhasTarifaAgua
										.append(Util
												.completaStringComEspacoAEsquerda(
														""
																+ contaCategoriaConsumoFaixa
																		.getConsumoAgua()
																* qtdEconomia
																		.intValue(),
														6));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										6));

								// valor (tam 14)
								// valor da agua na faixa
								String valorAguaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorAgua().multiply(
														qtdEconomia));
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												valorAguaFaixa, 14));

							} else {
								// Consumo inicial da faixa
								String consumoInicialFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaInicio());
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												consumoInicialFaixa, 2));
								// Constante
								linhasTarifaAgua.append(" M3 A");
								// consumo final da faixa
								String consumoFinalFaixa = ""
										+ (contaCategoriaConsumoFaixa
												.getConsumoFaixaFim());
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												consumoFinalFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										3));
								// Constante
								linhasTarifaAgua.append("- R$");
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorTarifaFaixa());
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												valorTarifaFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" POR M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										16));

								// consumo por faixa (tam 15)
								// consumo de Agua na faixa
								linhasTarifaAgua
										.append(Util
												.completaStringComEspacoAEsquerda(
														""
																+ contaCategoriaConsumoFaixa
																		.getConsumoAgua()
																* qtdEconomia
																		.intValue(),
														6));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("",
										3));

								// valor (tam 14)
								// valor da agua na faixa
								String valorAguaFaixa = Util
										.formatarMoedaReal(contaCategoriaConsumoFaixa
												.getValorAgua().multiply(
														qtdEconomia));
								linhasTarifaAgua.append(Util
										.completaStringComEspacoAEsquerda(
												valorAguaFaixa, 14));

							}
						}
					} else {
						// descricao dos serviçoes e tarifas (tam 50)
						linhasTarifaAgua.append("CONSUMO DE ÁGUA");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 35));

						// consumo por faixa (tam 15)
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(""
										+ contaCategoria.getConsumoAgua(), 6)
								+ " M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 6));

						// valor (tam 14)
						linhasTarifaAgua.append(Util
								.completaStringComEspacoAEsquerda(Util
										.formatarMoedaReal(contaCategoria
												.getValorAgua()), 14));

					}

				}
			}
		}

		return linhasTarifaAgua;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00012] Gerar Linhas da Tarifa de Esgoto
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasTarifaEsgotoFichaCompensacao(
			EmitirContaHelper emitirContaHelper) throws ControladorException {
		StringBuilder linhasTarifaEsgoto = new StringBuilder();

		// descricao dos serviçoes e tarifas (tam 50)
		// Constante
		linhasTarifaEsgoto.append("ESGOTO ");

		// caso o consumo de agua seja igual ao volume coletado de esgoto e o
		// valor de agua seja diferente de 0
		if (emitirContaHelper.getConsumoAgua().equals(
				emitirContaHelper.getConsumoEsgoto())
				&& emitirContaHelper.getValorAgua() != null
				&& !emitirContaHelper.getValorAgua().equals("0.00")) {

			// Percentual esgoto
			String percentualEsgoto = Util.formatarMoedaReal(emitirContaHelper
					.getPercentualEsgotoConta());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(
					percentualEsgoto, 6));
			// Constante
			linhasTarifaEsgoto.append(" % DO VALOR DA ÁGUA");
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 18));

			// consumo por faixa (tam 15)
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 15));

			// valor (tam 14)
			// valor esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper
					.getValorEsgoto());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(
					valorEsgoto, 14));

		} else {
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 43));
			// consumo por faixa (tam 15)
			// Volume coletado de esgoto
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(""
					+ emitirContaHelper.getConsumoEsgoto(), 6));
			// Constante
			linhasTarifaEsgoto.append(" M3");
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 6));

			// valor (tam 14)
			// valor esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper
					.getValorEsgoto());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(
					valorEsgoto, 14));
		}

		return linhasTarifaEsgoto;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00013] Gerar Linhas de Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasDebitoCobradosFichaCompensacao(
			EmitirContaHelper emitirContaHelper) throws ControladorException {
		StringBuilder linhasDebitosCobrados = new StringBuilder();

		// CRC4428 - Vivianne Sousa - 14/06/2010
		// Collection<Object[]> collectionParmsDebitoAutomatico = null;
		// try {
		Collection<Object[]> collectionParmsDebitoAutomatico = this
				.pesquisarParmsDebitoAutomatico(emitirContaHelper.getIdConta());
		// } catch (ErroRepositorioException e) {
		// sessionContext.setRollbackOnly();
		// throw new ControladorException("erro.sistema", e);
		// }

		if (collectionParmsDebitoAutomatico != null) {

			Iterator iter = collectionParmsDebitoAutomatico.iterator();

			while (iter.hasNext()) {
				Object[] parmsDebitoAutomatico = (Object[]) iter.next();

				// caso a consulta retorne algum resultado
				if (parmsDebitoAutomatico != null) {
					String valorDebitosCobrados = "";
					String numeroPrestacao = "";
					Short numeroTotalPrestacao = 0;
					Short numeroParcelaBonus = 0;
					String totalPrestacaoMenosBonus = "";
					// valor acumulado dos debitos cobrados
					if (parmsDebitoAutomatico[0] != null) {
						valorDebitosCobrados = Util
								.formatarMoedaReal((BigDecimal) parmsDebitoAutomatico[0]);
					}
					// numero de prestação do débito
					if (parmsDebitoAutomatico[1] != null) {
						numeroPrestacao = ""
								+ ((Short) parmsDebitoAutomatico[1]);
					}
					// valor acumulado dos debitos cobrados
					if (parmsDebitoAutomatico[2] != null) {
						numeroTotalPrestacao = (Short) parmsDebitoAutomatico[2];
					}
					/*
					 * Alterado por Vivianne Sousa em 21/12/2007 - Analista:
					 * Adriano criação do bonus para parcelamento com RD
					 * especial
					 */
					// numero parcela bonus
					if (parmsDebitoAutomatico[3] != null) {
						numeroParcelaBonus = (Short) parmsDebitoAutomatico[3];
					}
					totalPrestacaoMenosBonus = ""
							+ (numeroTotalPrestacao.intValue() - numeroParcelaBonus
									.intValue());
					if (!valorDebitosCobrados.equals("0,00")) {

						// descricao dos serviçoes e tarifas (tam 50)
						// Constante
						linhasDebitosCobrados.append("PARCELAMENTO DE DÉBITOS");
						// Completa com espaços em branco
						linhasDebitosCobrados
								.append(Util.completaString("", 2));
						// Constante
						linhasDebitosCobrados.append("PARCELA ");
						// numero da prestação do débito
						linhasDebitosCobrados.append(Util
								.completaStringComEspacoAEsquerda(
										numeroPrestacao, 3));
						// Constante
						linhasDebitosCobrados.append("/");
						// numero total da prestação do débito
						linhasDebitosCobrados.append(Util.completaString(
								totalPrestacaoMenosBonus, 3));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util
								.completaString("", 10));

						// consumo por faixa (tam 15)
						linhasDebitosCobrados.append(Util
								.completaString("", 15));

						// valor (tam 14)
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util
								.completaStringComEspacoAEsquerda(
										valorDebitosCobrados, 14));
					}
				}

			}

		}
		// CRC4428 - Vivianne Sousa - 14/06/2010
		// List colecaoDebitoCobradoPorTipo = null;
		// try {
		List colecaoDebitoCobradoPorTipo = this
				.pesquisarParmsDebitoCobradoPorTipo(emitirContaHelper
						.getIdConta());
		// } catch (ErroRepositorioException e) {
		// sessionContext.setRollbackOnly();
		// throw new ControladorException("erro.sistema", e);
		// }
		if (colecaoDebitoCobradoPorTipo != null
				&& !colecaoDebitoCobradoPorTipo.isEmpty()) {
			ListIterator iteratorDebitoCobradoPorTipo = (ListIterator) colecaoDebitoCobradoPorTipo
					.listIterator();
			// variável responsável para controle de mudança do tipo de débito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// débito,que entra para ser escrito no txt só uma vez a descrição
			// do tipo do debito
			boolean primeiraVez = true;
			boolean entrouPrimeiraVez = false;
			Integer idDebitoTipoVerificador = null;
			BigDecimal valorTotalPrestacoes = new BigDecimal("0.00");
			// valor da pretação
			BigDecimal valorPrestacao = null;
			// numero da pretação atual
			Integer numeroPrestacaoDebito = null;
			// numero total de prestações
			Integer numeroPrestacaoTotal = null;
			String totalPrestacaoMenosBonus = "";
			// colecao para guardar os ano/mes referencia do débito cobrado
			Collection colecaoAnoMesReferenciaDebito = new ArrayList();
			// cria um int que vai ver o tamanho da string builder dependendo da
			// quantidade
			// de mes/ano referencia calcula os espaços em brancos para o valor
			// ficar no lugar certo
			int tamanhoAnoMesReferencia = 0;
			while (iteratorDebitoCobradoPorTipo.hasNext()) {
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoCobradoPorTipo
						.next();

				// recupera os parametros da coleção valor da pretação
				if (parmsDebitoCobradoPorTipo[0] != null) {
					valorPrestacao = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if (parmsDebitoCobradoPorTipo[1] != null) {
					numeroPrestacaoDebito = new Integer(""
							+ (Short) parmsDebitoCobradoPorTipo[1]);
				}
				// numero total de prestações
				if (parmsDebitoCobradoPorTipo[2] != null) {
					numeroPrestacaoTotal = new Integer(""
							+ (Short) parmsDebitoCobradoPorTipo[2]);
				}
				// ano Mes Referência do débito
				Integer anoMesReferencia = null;
				if (parmsDebitoCobradoPorTipo[3] != null) {
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idDebitoTipo = null;
				if (parmsDebitoCobradoPorTipo[4] != null) {
					idDebitoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do débito
				String descricaoDebitoTipo = null;
				if (parmsDebitoCobradoPorTipo[5] != null) {
					descricaoDebitoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}
				/*
				 * Alterado por Vivianne Sousa em 21/12/2007 - Analista: Adriano
				 * criação do bonus para parcelamento com RD especial
				 */
				Short numeroParcelaBonus = 0;
				// numero parcela bonus
				if (parmsDebitoCobradoPorTipo[6] != null) {
					numeroParcelaBonus = (Short) parmsDebitoCobradoPorTipo[6];
				}
				totalPrestacaoMenosBonus = ""
						+ (numeroPrestacaoTotal.intValue() - numeroParcelaBonus
								.intValue());

				// muda o estado do boolean e o valor do débito tipo
				// verificador na primeira vez ou quando mudar o tipo
				if (mudou) {
					idDebitoTipoVerificador = idDebitoTipo;
					mudou = false;
					tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if (idDebitoTipo.equals(idDebitoTipoVerificador)) {
					if (primeiraVez) {
						linhasDebitosCobrados.append(Util.completaString(
								descricaoDebitoTipo, 30));
						primeiraVez = false;
						entrouPrimeiraVez = true;
					} else {
						entrouPrimeiraVez = false;
					}
					// adiciona o valor da prestação ao total
					valorTotalPrestacoes = valorTotalPrestacoes
							.add(valorPrestacao);
					// adiciona o ano/mes referencia na coleção
					if (anoMesReferencia != null) {
						colecaoAnoMesReferenciaDebito.add(anoMesReferencia);
					} else {
						if (!entrouPrimeiraVez) {
							// descrição do tipo de débito
							linhasDebitosCobrados.append(Util.completaString(
									descricaoDebitoTipo, 30));
						}
						// Constante
						linhasDebitosCobrados.append("PARCELA ");
						// numero da prestação do débito
						linhasDebitosCobrados.append(Util
								.completaStringComEspacoAEsquerda(""
										+ numeroPrestacaoDebito, 3));
						// Constante
						linhasDebitosCobrados.append("/");
						// numero total da prestação do débito
						linhasDebitosCobrados.append(Util.completaString(
								totalPrestacaoMenosBonus, 3));
						// Completa com espaços em branco
						linhasDebitosCobrados
								.append(Util.completaString("", 5));

						// consumo por faixa (tam 15)
						linhasDebitosCobrados.append(Util
								.completaString("", 15));

						// valor (tam 14)
						// Valor da pretação
						String valorPrestacaoString = Util
								.formatarMoedaReal(valorPrestacao);
						linhasDebitosCobrados.append(Util
								.completaStringComEspacoAEsquerda(
										valorPrestacaoString, 14));

					}

				} else {
					// caso a coleção dos meses de referência do grupo do
					// tipo de débito esteja preenchida
					if (colecaoAnoMesReferenciaDebito != null
							&& !colecaoAnoMesReferenciaDebito.isEmpty()) {
						Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito
								.iterator();
						int i = 1;
						while (iteratorAnoMesReferenciaDebito.hasNext()) {
							Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito
									.next();
							String anoMesReferenciaDebitoString = null;

							if (i == 1) {
								// mes/ano referencia do débito
								anoMesReferenciaDebitoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								linhasDebitosCobrados
										.append(Util
												.completaString(
														anoMesReferenciaDebitoString,
														7));
								// caso exita somente um mes/ano de referencia
								// na lista
								if (colecaoAnoMesReferenciaDebito.size() == 1) {

									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("", 13));

									// consumo por faixa (tam 15)
									linhasDebitosCobrados.append(Util
											.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 14));

								} else {

									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("", 42));
								}
							} else {
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if (i == 2) {

									// mes/ano referencia do debito
									anoMesReferenciaDebitoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									linhasDebitosCobrados
											.append(Util
													.completaString(
															anoMesReferenciaDebitoString,
															7));
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
									// adiciona o tamanho do mes/ano
									// referencia
									tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
									// caso exita somente um mes/ano de
									// referencia na lista
									if (colecaoAnoMesReferenciaDebito.size() == 2) {
										// o tamanho de espaços em
										// branco vai ser o tamanho sem
										// os mes/ano - os meses/anos
										// colocados na
										// stringbuilder.ex.:76-15=61
										// espaços em brancos
										int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
										// completa espaços em brancos
										linhasDebitosCobrados.append(Util
												.completaString("",
														tamanhoEspacosBrancos));

										// consumo por faixa (tam 15)
										linhasDebitosCobrados.append(Util
												.completaString("", 15));

										// valor (tam 14)
										// valor acumulado do tipo do débito
										String valorAcumulado = Util
												.formatarMoedaReal(valorTotalPrestacoes);
										linhasDebitosCobrados
												.append(Util
														.completaStringComEspacoAEsquerda(
																valorAcumulado,
																14));
									}

								} else {
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o ultimo
									// anoMes
									if ((colecaoAnoMesReferenciaDebito.size() - 1) <= 2) {

										// mes/ano referencia do debito
										anoMesReferenciaDebitoString = Util
												.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
										linhasDebitosCobrados
												.append(Util
														.completaString(
																anoMesReferenciaDebitoString,
																7));
										// completa espaços em brancos
										linhasDebitosCobrados.append(" ");
										// adiciona o tamanho do mes/ano
										// referencia + o espaço em branco
										tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

										// caso não tenha outro ano mes na
										// coleção então
										// completa a linha com o valor
										if (!iteratorAnoMesReferenciaDebito
												.hasNext()) {
											// o tamanho de espaços em branco
											// vai ser o tamanho sem
											// os mes/ano - os meses/anos
											// colocados na
											// stringbuilder.ex.:76-15=61
											// espaços em brancos
											int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
											// completa espaços em brancos
											linhasDebitosCobrados
													.append(Util
															.completaString("",
																	tamanhoEspacosBrancos));

											// consumo por faixa (tam 15)
											linhasDebitosCobrados.append(Util
													.completaString("", 15));

											// valor (tam 14)
											// valor acumulado do tipo do débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalPrestacoes);
											linhasDebitosCobrados
													.append(Util
															.completaStringComEspacoAEsquerda(
																	valorAcumulado,
																	14));

										}

									} else {
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if (i < 3) {
											// mes/ano referencia do débito
											anoMesReferenciaDebitoString = Util
													.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
											linhasDebitosCobrados
													.append(Util
															.completaString(
																	anoMesReferenciaDebitoString,
																	7));
											// completa espaços em brancos
											linhasDebitosCobrados.append(" ");
										} else {
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util
													.completaString("E OUTRAS",
															10));

											// consumo por faixa (tam 15)
											linhasDebitosCobrados.append(Util
													.completaString("", 15));

											// valor (tam 14)
											// valor acumulado do tipo do débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalPrestacoes);
											linhasDebitosCobrados
													.append(Util
															.completaStringComEspacoAEsquerda(
																	valorAcumulado,
																	14));

											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					} // limpa os campos
					valorTotalPrestacoes = new BigDecimal("0.00");
					colecaoAnoMesReferenciaDebito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoCobradoPorTipo.previous();
				}
			}

			// no caso de ser o ultimo tipo

			// caso a coleção dos meses de referência do grupo do tipo de débito
			// esteja preenchida
			if (colecaoAnoMesReferenciaDebito != null
					&& !colecaoAnoMesReferenciaDebito.isEmpty()) {
				Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito
						.iterator();
				int i = 1;
				while (iteratorAnoMesReferenciaDebito.hasNext()) {
					Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito
							.next();
					String anoMesReferenciaDebitoString = null;

					if (i == 1) {
						// mes/ano referencia do débito
						anoMesReferenciaDebitoString = Util
								.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
						linhasDebitosCobrados.append(Util.completaString(
								anoMesReferenciaDebitoString, 7));
						// caso exita somente um mes/ano de referencia na lista
						if (colecaoAnoMesReferenciaDebito.size() == 1) {

							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString(
									"", 13));

							// consumo por faixa (tam 15)
							linhasDebitosCobrados.append(Util.completaString(
									"", 15));

							// valor (tam 14)
							// valor acumulado do tipo do débito
							String valorAcumulado = Util
									.formatarMoedaReal(valorTotalPrestacoes);
							linhasDebitosCobrados.append(Util
									.completaStringComEspacoAEsquerda(
											valorAcumulado, 14));

						} else {
							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString(
									"", 42));
						}
					} else {
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if (i == 2) {

							// mes/ano referencia do debito
							anoMesReferenciaDebitoString = Util
									.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
							linhasDebitosCobrados.append(Util.completaString(
									anoMesReferenciaDebitoString, 7));
							// completa espaços em brancos
							linhasDebitosCobrados.append(" ");
							// adiciona o tamanho do mes/ano
							// referencia
							tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
							// caso exita somente um mes/ano de
							// referencia na lista
							if (colecaoAnoMesReferenciaDebito.size() == 2) {
								// o tamanho de espaços em
								// branco vai ser o tamanho sem
								// os mes/ano - os meses/anos
								// colocados na
								// stringbuilder.ex.:76-15=61
								// espaços em brancos
								int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
								// completa espaços em brancos
								linhasDebitosCobrados.append(Util
										.completaString("",
												tamanhoEspacosBrancos));

								// consumo por faixa (tam 15)
								linhasDebitosCobrados.append(Util
										.completaString("", 15));

								// valor (tam 14)
								// valor acumulado do tipo do débito
								String valorAcumulado = Util
										.formatarMoedaReal(valorTotalPrestacoes);
								linhasDebitosCobrados.append(Util
										.completaStringComEspacoAEsquerda(
												valorAcumulado, 14));
							}

						} else {
							// caso exista até mais 6 ocorrências na lista de
							// meses
							// -1 pq já foi colocado na string o ultimo anoMes
							if ((colecaoAnoMesReferenciaDebito.size() - 1) <= 2) {

								// mes/ano referencia do debito
								anoMesReferenciaDebitoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								linhasDebitosCobrados
										.append(Util
												.completaString(
														anoMesReferenciaDebitoString,
														7));
								// completa espaços em brancos
								linhasDebitosCobrados.append(" ");
								// adiciona o tamanho do mes/ano
								// referencia + o espaço em branco
								tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

								// caso não tenha outro ano mes na coleção então
								// completa a linha com o valor
								if (!iteratorAnoMesReferenciaDebito.hasNext()) {
									// o tamanho de espaços em branco vai ser o
									// tamanho sem
									// os mes/ano - os meses/anos
									// colocados na stringbuilder.ex.:76-15=61
									// espaços em brancos
									int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("",
													tamanhoEspacosBrancos));

									// consumo por faixa (tam 15)
									linhasDebitosCobrados.append(Util
											.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 14));

								}

							} else {
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if (i < 3) {
									// mes/ano referencia do débito
									anoMesReferenciaDebitoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									linhasDebitosCobrados
											.append(Util
													.completaString(
															anoMesReferenciaDebitoString,
															7));
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
								} else {
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util
											.completaString("E OUTRAS", 10));

									// consumo por faixa (tam 15)
									linhasDebitosCobrados.append(Util
											.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 14));

									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}

		}

		return linhasDebitosCobrados;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB00014] Gerar Linhas de Créditos Realizados
	 * 
	 * @author Vivianne Sousa
	 * @date 19/11/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasCreditosRealizadosFichaCompensacao(
			EmitirContaHelper emitirContaHelper) throws ControladorException {
		StringBuilder linhasCreditosRealizados = new StringBuilder();
		List colecaoCreditoRealizadoPorTipo = null;
		try {
			colecaoCreditoRealizadoPorTipo = repositorioFaturamento
					.pesquisarParmsCreditoRealizadoPorTipo(emitirContaHelper
							.getIdConta());
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		if (colecaoCreditoRealizadoPorTipo != null
				&& !colecaoCreditoRealizadoPorTipo.isEmpty()) {
			ListIterator iteratorDebitoRealizadoPorTipo = (ListIterator) colecaoCreditoRealizadoPorTipo
					.listIterator();
			// variável responsável para controle de mudança do tipo de credito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// credito,que entra para ser escrito no txt só uma vez a descrição
			// do tipo do credito
			boolean primeiraVez = true;
			boolean entrouPrimeiraVez = false;
			Integer idCreditoTipoVerificador = null;
			BigDecimal valorTotalCredito = new BigDecimal("0.00");
			BigDecimal valorCredito = null;
			Short numeroCredito = null;
			// numero total de créditos
			Short numeroCreditoTotal = null;
			String numeroCreditoTotalMenosBonus = "";
			// cria um int que vai ver o tamanho da string builder dependendo da
			// quantidade
			// de mes/ano referencia calcula os espaços em brancos para o valor
			// ficar no lugar certo
			int tamanhoAnoMesReferencia = 0;
			// caso não seja a primeira vez que entre no boolean primeira
			// vez(que nesse caso é quando troca o tipo de credito)
			// colecao para guardar os ano/mes referencia do credito realizado
			Collection colecaoAnoMesReferenciaCredito = new ArrayList();
			while (iteratorDebitoRealizadoPorTipo.hasNext()) {
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoRealizadoPorTipo
						.next();

				// recupera os parametros da coleção
				// valor do crédito
				if (parmsDebitoCobradoPorTipo[0] != null) {
					valorCredito = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if (parmsDebitoCobradoPorTipo[1] != null) {
					numeroCredito = (Short) parmsDebitoCobradoPorTipo[1];
				}

				if (parmsDebitoCobradoPorTipo[2] != null) {
					numeroCreditoTotal = (Short) parmsDebitoCobradoPorTipo[2];
				}
				// ano Mes Referência do crédito
				Integer anoMesReferencia = null;
				if (parmsDebitoCobradoPorTipo[3] != null) {
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idCreditoTipo = null;
				if (parmsDebitoCobradoPorTipo[4] != null) {
					idCreditoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do credito
				String descricaoCreditoTipo = null;
				if (parmsDebitoCobradoPorTipo[5] != null) {
					descricaoCreditoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}
				/*
				 * Alterado por Vivianne Sousa em 21/12/2007 - Analista: Adriano
				 * criação do bonus para parcelamento com RD especial
				 */
				Short numeroParcelaBonus = 0;
				// numero parcela bonus
				if (parmsDebitoCobradoPorTipo[6] != null) {
					numeroParcelaBonus = (Short) parmsDebitoCobradoPorTipo[6];
				}
				numeroCreditoTotalMenosBonus = ""
						+ (numeroCreditoTotal.intValue() - numeroParcelaBonus
								.intValue());

				// muda o estado do boolean e o valor do credito tipo
				// verificador na primeira vez ou quando mudar o tipo
				if (mudou) {
					idCreditoTipoVerificador = idCreditoTipo;
					mudou = false;
					tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if (idCreditoTipo.equals(idCreditoTipoVerificador)) {
					if (primeiraVez) {
						// descrição do tipo de credito
						linhasCreditosRealizados.append(Util.completaString(
								descricaoCreditoTipo, 30));
						primeiraVez = false;
						entrouPrimeiraVez = true;

					} else {
						entrouPrimeiraVez = false;
					}

					// adiciona o valor do credito ao total
					valorTotalCredito = valorTotalCredito.add(valorCredito);
					// adiciona o ano/mes referencia na coleção
					if (anoMesReferencia != null) {
						colecaoAnoMesReferenciaCredito.add(anoMesReferencia);
					} else {
						if (!entrouPrimeiraVez) {
							// descrição do tipo de credito
							linhasCreditosRealizados.append(Util
									.completaString(descricaoCreditoTipo, 30));
							primeiraVez = false;
						}
						// Constante
						linhasCreditosRealizados.append("PARCELA ");
						// numero da prestação do débito
						linhasCreditosRealizados.append(Util
								.completaStringComEspacoAEsquerda(""
										+ numeroCredito, 3));
						// Constante
						linhasCreditosRealizados.append("/");
						// numero total da prestação do débito
						linhasCreditosRealizados.append(Util.completaString(
								numeroCreditoTotalMenosBonus, 3));
						// Completa com espaços em branco
						linhasCreditosRealizados.append(Util.completaString("",
								5));

						// consumo por faixa (tam 15)
						linhasCreditosRealizados.append(Util.completaString("",
								15));

						// Valor da pretação
						String valorCreditoString = Util
								.formatarMoedaReal(valorCredito);
						linhasCreditosRealizados.append(Util
								.completaStringComEspacoAEsquerda(
										valorCreditoString, 14));

					}

				} else {
					// caso a coleção dos meses de referência do grupo do
					// tipo de credito esteja preenchida
					if (colecaoAnoMesReferenciaCredito != null
							&& !colecaoAnoMesReferenciaCredito.isEmpty()) {
						Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito
								.iterator();
						int i = 1;
						while (iteratorAnoMesReferenciaCredito.hasNext()) {
							Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito
									.next();
							String anoMesReferenciaCreditoString = null;
							if (i == 1) {
								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								linhasCreditosRealizados.append(Util
										.completaString(
												anoMesReferenciaCreditoString,
												7));
								// caso exita somente um mes/ano de referencia
								// na lista
								if (colecaoAnoMesReferenciaCredito.size() == 1) {

									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("", 13));

									// consumo por faixa (tam 15)
									linhasCreditosRealizados.append(Util
											.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 14));

								} else {
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("", 42));
								}
							} else {
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if (i == 2) {

									// mes/ano referencia do credito
									anoMesReferenciaCreditoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									linhasCreditosRealizados
											.append(Util
													.completaString(
															anoMesReferenciaCreditoString,
															7));
									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");
									// adiciona o tamanho do mes/ano referencia
									tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

									// caso exita somente um mes/ano de
									// referencia na lista
									if (colecaoAnoMesReferenciaCredito.size() == 2) {
										// o tamanho de espaços em
										// branco vai ser o tamanho sem
										// os mes/ano - os meses/anos
										// colocados na
										// stringbuilder.ex.:76-15=61
										// espaços em brancos
										int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
										// completa espaços em brancos
										linhasCreditosRealizados.append(Util
												.completaString("",
														tamanhoEspacosBrancos));

										// consumo por faixa (tam 15)
										linhasCreditosRealizados.append(Util
												.completaString("", 15));

										// valor (tam 14)
										// valor acumulado do tipo do débito
										String valorAcumulado = Util
												.formatarMoedaReal(valorTotalCredito);
										linhasCreditosRealizados
												.append(Util
														.completaStringComEspacoAEsquerda(
																valorAcumulado,
																14));

									}
								} else {
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o ultimo
									// anoMes
									if ((colecaoAnoMesReferenciaCredito.size() - 1) <= 6) {

										// mes/ano referencia do credito
										anoMesReferenciaCreditoString = Util
												.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
										linhasCreditosRealizados
												.append(Util
														.completaString(
																anoMesReferenciaCreditoString,
																7));
										// completa espaços em brancos
										linhasCreditosRealizados.append(" ");
										// adiciona o tamanho do mes/ano
										// referencia + o espaço em branco
										tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
										// caso não tenha outro ano mes na
										// coleção então completa a linha com o
										// valor
										if (!iteratorAnoMesReferenciaCredito
												.hasNext()) {
											// o tamanho de espaços em
											// branco vai ser o tamanho sem
											// os mes/ano - os meses/anos
											// colocados na
											// stringbuilder.ex.:76-15=61
											// espaços em brancos
											int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
											// completa espaços em brancos
											linhasCreditosRealizados
													.append(Util
															.completaString("",
																	tamanhoEspacosBrancos));

											// consumo por faixa (tam 15)
											linhasCreditosRealizados
													.append(Util
															.completaString("",
																	15));

											// valor (tam 14)
											// valor acumulado do tipo do débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalCredito);
											linhasCreditosRealizados
													.append(Util
															.completaStringComEspacoAEsquerda(
																	valorAcumulado,
																	14));

										}

									} else {
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if (i < 7) {
											// mes/ano referencia do débito
											anoMesReferenciaCreditoString = Util
													.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
											linhasCreditosRealizados
													.append(Util
															.completaString(
																	anoMesReferenciaCreditoString,
																	7));
											// completa espaços em brancos
											linhasCreditosRealizados
													.append(" ");
										} else {
											// completa espaços em brancos
											linhasCreditosRealizados
													.append(Util
															.completaString(
																	"E OUTRAS",
																	10));

											// consumo por faixa (tam 15)
											linhasCreditosRealizados
													.append(Util
															.completaString("",
																	15));

											// valor (tam 14)
											// valor acumulado do tipo do débito
											String valorAcumulado = Util
													.formatarMoedaReal(valorTotalCredito);
											linhasCreditosRealizados
													.append(Util
															.completaStringComEspacoAEsquerda(
																	valorAcumulado,
																	14));

											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					}
					// limpa os campos
					valorTotalCredito = new BigDecimal("0.00");
					colecaoAnoMesReferenciaCredito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoRealizadoPorTipo.previous();
				}
			}
			// No caso de ter o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de credito esteja preenchida
			if (colecaoAnoMesReferenciaCredito != null
					&& !colecaoAnoMesReferenciaCredito.isEmpty()) {
				Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito
						.iterator();
				int i = 1;
				while (iteratorAnoMesReferenciaCredito.hasNext()) {
					Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito
							.next();
					String anoMesReferenciaCreditoString = null;
					if (i == 1) {
						// mes/ano referencia do credito
						anoMesReferenciaCreditoString = Util
								.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
						linhasCreditosRealizados.append(Util.completaString(
								anoMesReferenciaCreditoString, 7));
						// caso exita somente um mes/ano de referencia na lista
						if (colecaoAnoMesReferenciaCredito.size() == 1) {

							// completa espaços em brancos
							linhasCreditosRealizados.append(Util
									.completaString("", 13));

							// consumo por faixa (tam 15)
							linhasCreditosRealizados.append(Util
									.completaString("", 15));

							// valor (tam 14)
							// valor acumulado do tipo do débito
							String valorAcumulado = Util
									.formatarMoedaReal(valorTotalCredito);
							linhasCreditosRealizados.append(Util
									.completaStringComEspacoAEsquerda(
											valorAcumulado, 14));

						} else {
							// completa espaços em brancos
							linhasCreditosRealizados.append(Util
									.completaString("", 42));
						}
					} else {
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if (i == 2) {
							anoMesReferenciaCreditoString = Util
									.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
							linhasCreditosRealizados.append(Util
									.completaString(
											anoMesReferenciaCreditoString, 7));
							// completa espaços em brancos
							linhasCreditosRealizados.append(" ");
							// adiciona o tamanho do mes/ano referencia
							tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

							// caso exita somente um mes/ano de referencia na
							// lista
							if (colecaoAnoMesReferenciaCredito.size() == 2) {
								// o tamanho de espaços em
								// branco vai ser o tamanho sem
								// os mes/ano - os meses/anos
								// colocados na
								// stringbuilder.ex.:76-15=61
								// espaços em brancos
								int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
								// completa espaços em brancos
								linhasCreditosRealizados.append(Util
										.completaString("",
												tamanhoEspacosBrancos));

								// consumo por faixa (tam 15)
								linhasCreditosRealizados.append(Util
										.completaString("", 15));

								// valor (tam 14)
								// valor acumulado do tipo do débito
								String valorAcumulado = Util
										.formatarMoedaReal(valorTotalCredito);
								linhasCreditosRealizados.append(Util
										.completaStringComEspacoAEsquerda(
												valorAcumulado, 14));

							}
						} else {
							// caso exista até mais 6 ocorrências na
							// lista de meses
							// -1 pq já foi colocado na string o
							// ultimo anoMes
							if ((colecaoAnoMesReferenciaCredito.size() - 1) <= 6) {

								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util
										.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								linhasCreditosRealizados.append(Util
										.completaString(
												anoMesReferenciaCreditoString,
												7));
								// completa espaços em brancos
								linhasCreditosRealizados.append(" ");
								// adiciona o tamanho do mes/ano
								// referencia + o espaço em branco
								tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
								// caso não tenha outro ano mes na
								// coleção então completa a linha com o valor
								if (!iteratorAnoMesReferenciaCredito.hasNext()) {
									// o tamanho de espaços em
									// branco vai ser o tamanho sem
									// os mes/ano - os meses/anos
									// colocados na
									// stringbuilder.ex.:76-15=61
									// espaços em brancos
									int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("",
													tamanhoEspacosBrancos));

									// consumo por faixa (tam 15)
									linhasCreditosRealizados.append(Util
											.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 14));

								}

							} else {
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if (i < 7) {
									// mes/ano referencia do débito
									anoMesReferenciaCreditoString = Util
											.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									linhasCreditosRealizados
											.append(Util
													.completaString(
															anoMesReferenciaCreditoString,
															7));
									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");
								} else {
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util
											.completaString("E OUTRAS", 10));

									// consumo por faixa (tam 15)
									linhasCreditosRealizados.append(Util
											.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util
											.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util
											.completaStringComEspacoAEsquerda(
													valorAcumulado, 14));

									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}

		}

		return linhasCreditosRealizados;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0015] Gerar Linhas de Impostos Retidos
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasImpostosRetidosFichaCompensacao(
			EmitirContaHelper emitirContaHelper) throws ControladorException {

		StringBuilder linhasImpostosRetidos = new StringBuilder();

		// descricao dos serviçoes e tarifas (tam 50)
		// Constante
		linhasImpostosRetidos.append(Util.completaString(
				"DEDUCAO IMPOSTOS LEI FEDERAL N.9430 DE 27/12/1996", 50));

		// consumo por faixa (tam 15)
		linhasImpostosRetidos.append(Util.completaString("", 15));

		// valor (tam 14)
		linhasImpostosRetidos.append(Util.completaString("", 14));

		// descricao dos serviçoes e tarifas (tam 50)
		linhasImpostosRetidos.append(Util.completaString("", 2));

		Collection colecaoParmsImpostosDeduzidos = null;
		try {
			colecaoParmsImpostosDeduzidos = repositorioFaturamento
					.pesquisarParmsContaImpostosDeduzidos(emitirContaHelper
							.getIdConta());
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		StringBuilder descricaoAbreviadaImposto = new StringBuilder();
		BigDecimal valorImpostosTotal = new BigDecimal("0.00");
		// verifica se a coleção é diferente de nulo
		if (colecaoParmsImpostosDeduzidos != null
				&& !colecaoParmsImpostosDeduzidos.isEmpty()) {
			Iterator iteratorParmsImpostosDeduzidos = colecaoParmsImpostosDeduzidos
					.iterator();
			while (iteratorParmsImpostosDeduzidos.hasNext()) {
				Object[] parmsImpostoDeduzido = (Object[]) iteratorParmsImpostosDeduzidos
						.next();
				String descricaoTipoImposto = "";
				if (parmsImpostoDeduzido[0] != null) {
					descricaoTipoImposto = (String) parmsImpostoDeduzido[0];
				}
				String percentualAliquota = "";
				if (parmsImpostoDeduzido[1] != null) {
					percentualAliquota = Util
							.formatarMoedaReal((BigDecimal) parmsImpostoDeduzido[1]);
				}
				BigDecimal valorImpostos = null;
				if (parmsImpostoDeduzido[2] != null) {
					valorImpostos = (BigDecimal) parmsImpostoDeduzido[2];
				}
				// concatena a descrição abreviada do tipo de imposto com o
				// precentual de aliquota
				descricaoAbreviadaImposto.append(descricaoTipoImposto + "-"
						+ percentualAliquota + "%");
				// Completa com espaços em branco
				descricaoAbreviadaImposto.append(" ");
				// adiciona o valor dos impostos
				valorImpostosTotal = valorImpostosTotal.add(valorImpostos);
			}
		}
		// recupera a descrição abreviada concatenada com a aliquota
		String descricaoAbreviadaConcatenada = "";
		if (descricaoAbreviadaImposto != null
				&& !descricaoAbreviadaImposto.equals("")) {
			descricaoAbreviadaConcatenada = descricaoAbreviadaImposto
					.toString();
		}
		linhasImpostosRetidos.append(Util.completaString(
				descricaoAbreviadaConcatenada, 48));

		// consumo por faixa (tam 15)
		linhasImpostosRetidos.append(Util.completaString("", 15));

		// valor (tam 14)
		String valorImpostosTotalString = Util
				.formatarMoedaReal(valorImpostosTotal);
		linhasImpostosRetidos.append(Util.completaStringComEspacoAEsquerda(
				valorImpostosTotalString, 14));

		return linhasImpostosRetidos;
	}

	/**
	 * [UC0352] Emitir Contas e Cartas
	 * 
	 * [SB0029] Gerar Arquivo TXT das fichas de Compensção
	 * 
	 * @author Vivianne Sousa, Mariana Victor
	 * @date 12/11/2007, 11/03/2011
	 * 
	 * @param emitirContaHelper
	 * @throws ControladorException
	 */
	public void emitirFichaCompensacao(Collection colecaoEmitirContaHelper,
			int tipoConta, FaturamentoGrupo faturamentoGrupo,
			Integer idEmpresa, Integer anoMesReferenciaFaturamento)
			throws ControladorException {

		SistemaParametro sistemaParametro = null;

		int quantidadeContas = 0;

		try {

			sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			// recebe todos as contas da lista
			StringBuilder contasTxtLista = null;
			StringBuilder cartasTxtListaConta = null;
			Map<Integer, Integer> mapAtualizaSequencial = null;

			try {

				Integer sequencialImpressao = 0;
				Integer sequencialCarta = 0;

				contasTxtLista = new StringBuilder();
				cartasTxtListaConta = new StringBuilder();

				mapAtualizaSequencial = new HashMap();

				if (colecaoEmitirContaHelper != null
						&& !colecaoEmitirContaHelper.isEmpty()) {

					EmitirContaHelper emitirContaHelper = null;
					int countOrdem = 0;
					Iterator iteratorConta = colecaoEmitirContaHelper
							.iterator();

					while (iteratorConta.hasNext()) {

						emitirContaHelper = null;
						int situacao = 0;

						emitirContaHelper = (EmitirContaHelper) iteratorConta
								.next();

						// [SB0020] - Gerar Arquivo TXT das Cartas
						if (tipoConta == 0 || tipoConta == 1) {
							sequencialCarta += 1;
						}
						sequencialImpressao += 1;
						quantidadeContas++;
						// Só para exibir no console a quantidade de contas

						if (emitirContaHelper != null) {

							// [SB0020] - Gerar Arquivo TXT das Cartas
							if (tipoConta == 0 || tipoConta == 1) {

								cartasTxtListaConta
										.append(gerarArquivoTxtCartas(
												emitirContaHelper,
												sequencialCarta, situacao));
								cartasTxtListaConta.append(System
										.getProperty("line.separator"));
							}

							StringBuilder contaTxt = new StringBuilder();
							// caso o [FS0006 - Verificar espaços para descrição
							// dos
							// serviços e tarifas totalmente preenchido]
							StringBuilder parteInicialcontaTxt = new StringBuilder();

							// item 1
							// determinar Mensagem
							String mensagemConta = determinarMensagem(tipoConta);
							contaTxt.append(Util.completaString(mensagemConta,
									50));

							// item 2
							// nome da localidade
							String descricaoLocalidade = emitirContaHelper
									.getDescricaoLocalidade();
							contaTxt.append(Util.completaString(
									descricaoLocalidade, 30));

							// item 3
							// matricula do imóvel
							// Recupera a matrícula do imóvel da coluna 1 e
							// formata a matrícula
							// (ex:500000001 em 5000000.1)
							String matriculaImovelFormatada = Util
									.retornaMatriculaImovelFormatada(emitirContaHelper
											.getIdImovel());
							contaTxt.append(Util.completaString(
									matriculaImovelFormatada, 9));

							// item 4
							// caso a coleção de contas seja de entrega para o
							// cliente responsável
							String nomeClienteUsuario = "";
							if (tipoConta == 3 || tipoConta == 4) {
								if (emitirContaHelper.getNomeImovel() != null
										&& !emitirContaHelper.getNomeImovel()
												.equals("")) {
									nomeClienteUsuario = emitirContaHelper
											.getNomeImovel();

								} else {
									/*
									 * Alterado por: Mariana Victor Data:
									 * 11/03/2011
									 */
									nomeClienteUsuario = this
											.obterNomeCliente(emitirContaHelper
													.getIdConta());
								}
								contaTxt.append(Util.completaString(
										nomeClienteUsuario, 30));
							} else {
								/*
								 * Alterado por: Mariana Victor Data: 11/03/2011
								 */
								nomeClienteUsuario = this
										.obterNomeCliente(emitirContaHelper
												.getIdConta());

								contaTxt.append(Util.completaString(
										nomeClienteUsuario, 30));
							}

							// item 5
							// data de vencimento da conta
							String dataVencimento = Util
									.formatarData(emitirContaHelper
											.getDataVencimentoConta());
							contaTxt.append(Util.completaString(dataVencimento,
									10));

							// item 6
							// instância um imovel com os dados da conta para
							// recuperar
							// a inscrição que está no objeto imovel
							Imovel imovel = new Imovel();
							Localidade localidade = new Localidade();
							localidade.setId(emitirContaHelper
									.getIdLocalidade());
							imovel.setLocalidade(localidade);
							SetorComercial setorComercial = new SetorComercial();
							setorComercial.setCodigo(emitirContaHelper
									.getCodigoSetorComercialConta());
							imovel.setSetorComercial(setorComercial);
							Quadra quadra = new Quadra();
							quadra.setNumeroQuadra(emitirContaHelper
									.getIdQuadraConta());
							imovel.setQuadra(quadra);
							imovel.setLote(emitirContaHelper.getLoteConta());
							imovel.setSubLote(emitirContaHelper
									.getSubLoteConta());
							// Inscrição do imóvel
							String inscricao = imovel.getInscricaoFormatada();

							imovel = null;
							localidade = null;
							setorComercial = null;
							quadra = null;

							contaTxt.append(Util.completaString(inscricao, 20));

							// item 7
							// recupera endereco do imóvel
							String enderecoImovel = getControladorEndereco()
									.pesquisarEnderecoFormatado(
											emitirContaHelper.getIdImovel());
							String enderecoImovelSegundaLinha = enderecoImovel;
							contaTxt.append(Util.completaString(
									enderecoImovel == null ? ""
											: enderecoImovel, 50));

							// item 8
							// Mês/Ano referência da conta
							String mesAnoReferencia = Util
									.formatarAnoMesParaMesAno(emitirContaHelper
											.getAmReferencia());
							// Dígito verificador da conta
							String digitoVerificador = ""
									+ emitirContaHelper
											.getDigitoVerificadorConta();
							contaTxt.append(Util.completaString(
									mesAnoReferencia + "-" + digitoVerificador,
									9));

							// item 9 e item 10
							// caso a coleção de contas seja de entrega para o
							// cliente responsável
							String enderecoClienteResponsavel = "";
							String enderecoClienteResponsavelSegundaLinha = "";

							// Comentado por Sávio Luiz em 08/01/2008 (Analista
							// Responsável: Aryed)
							// o tipo da conta(igual a 3 ou 4)

							if (emitirContaHelper.getIdClienteResponsavel() != null
									&& !emitirContaHelper
											.getIdClienteResponsavel().equals(
													"")) {

								// [UC0085]Obter Endereco
								enderecoClienteResponsavel = getControladorEndereco()
										.pesquisarEnderecoClienteAbreviado(
												new Integer(
														emitirContaHelper
																.getIdClienteResponsavel()));

								// id do cliente
								contaTxt.append(Util.completaString(
										""
												+ emitirContaHelper
														.getIdClienteResponsavel(),
										8));

								if (enderecoClienteResponsavel != null) {
									// endereco cliente responsável
									contaTxt.append(Util.completaString(
											enderecoClienteResponsavel, 50));
									enderecoClienteResponsavelSegundaLinha = enderecoClienteResponsavel;
								} else {
									// endereco cliente responsável
									contaTxt.append(Util.completaString("", 50));
								}
							} else {
								// endereco cliente responsável
								contaTxt.append(Util.completaString("", 58));
							}

							// item 11
							// descrição da situação da agua na conta
							String descricaoAguaSituacao = emitirContaHelper
									.getDescricaoLigacaoAguaSituacao();
							contaTxt.append(Util.completaString(
									descricaoAguaSituacao, 20));

							// item 12
							// descrição da situação de esgoto na conta
							String descricaoEsgotoSituacao = emitirContaHelper
									.getDescricaoLigacaoEsgotoSituacao();
							contaTxt.append(Util.completaString(
									descricaoEsgotoSituacao, 20));

							// [SB0002] - Determinar tipo de ligação e tipo de
							// Medição
							Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
							Integer tipoLigacao = parmSituacao[0];
							Integer tipoMedicao = parmSituacao[1];

							// cria uma stringBuilder para recuperar o resultado
							// do [SB0004]
							StringBuilder obterDadosConsumoMedicaoAnterior = null;

							// item 13
							// chama o [SB0004] - Obter Dados do Consumo e
							// Medição Anterior passando a quantidade de Meses
							// Igual a 1 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
									emitirContaHelper, 1, tipoLigacao,
									tipoMedicao);
							contaTxt.append(Util.completaString(
									obterDadosConsumoMedicaoAnterior.toString(),
									19));

							// item 14
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade
							// de Meses Igual a 4 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
									emitirContaHelper, 4, tipoLigacao,
									tipoMedicao);
							contaTxt.append(Util.completaString(
									obterDadosConsumoMedicaoAnterior.toString(),
									19));

							// item 15
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade
							// de Meses Igual a 2 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
									emitirContaHelper, 2, tipoLigacao,
									tipoMedicao);
							contaTxt.append(Util.completaString(
									obterDadosConsumoMedicaoAnterior.toString(),
									19));

							// item 16
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade
							// de Meses Igual a 5 e o tipode ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
									emitirContaHelper, 5, tipoLigacao,
									tipoMedicao);
							contaTxt.append(Util.completaString(
									obterDadosConsumoMedicaoAnterior.toString(),
									19));

							// item 17 e item 18
							// Inicio Chamar Sub-Fluxo recupera os parametros da
							// medição
							// historico do [SB0005] - Obter Dados da Medição da
							// Conta
							Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(
									emitirContaHelper, tipoMedicao);
							// Leitura Anterior
							String leituraAnterior = "";
							// Leitura Atual
							String leituraAtual = "";
							// Data Leitura Anterior
							String dataLeituraAnterior = "";
							// Leitura Anterior
							String dataLeituraAtual = "";
							// Leitura Situação Atual
							String leituraSituacaoAtual = "";
							// Leitura Anormalidade Faturamento
							String leituraAnormalidadeFaturamento = "";
							if (parmsMedicaoHistorico != null) {

								if (parmsMedicaoHistorico[0] != null) {
									leituraAnterior = ""
											+ (Integer) parmsMedicaoHistorico[0];
								}

								if (parmsMedicaoHistorico[1] != null) {
									leituraAtual = ""
											+ (Integer) parmsMedicaoHistorico[1];
								}

								if (parmsMedicaoHistorico[3] != null) {
									dataLeituraAnterior = Util
											.formatarData((Date) parmsMedicaoHistorico[3]);
								}

								if (parmsMedicaoHistorico[2] != null) {
									dataLeituraAtual = Util
											.formatarData((Date) parmsMedicaoHistorico[2]);
								}

								if (parmsMedicaoHistorico[4] != null) {
									leituraSituacaoAtual = ""
											+ (Integer) parmsMedicaoHistorico[4];
								}

								if (parmsMedicaoHistorico[5] != null) {
									leituraAnormalidadeFaturamento = ""
											+ (Integer) parmsMedicaoHistorico[5];
								}
							}
							String diasConsumo = "";
							if (!dataLeituraAnterior.equals("")
									&& !dataLeituraAtual.equals("")) {
								// calcula a quantidade de dias de consumo que é
								// a quantidade de
								// dias entre a data de leitura
								// anterior(parmsMedicaoHistorico[2])
								// e a data de leitura
								// atual(parmsMedicaoHistorico[3])
								diasConsumo = ""
										+ Util.obterQuantidadeDiasEntreDuasDatas(
												(Date) parmsMedicaoHistorico[3],
												(Date) parmsMedicaoHistorico[2]);
							}

							// recupera os parametros de consumo faturamento e
							// consumo médio diário
							// [SB0005] - Obter Consumo Faturado e Consumo Médio
							// Diário
							String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(
									emitirContaHelper, tipoMedicao, diasConsumo);
							String consumoFaturamento = parmsConsumo[0];
							String consumoMedioDiario = parmsConsumo[1];
							// Fim Chamar Sub-Fluxo

							// item 17
							// Leitura Anterior
							contaTxt.append(Util.completaString(
									leituraAnterior, 7));

							// item 18
							// Leitura Atual
							contaTxt.append(Util
									.completaString(leituraAtual, 7));

							// item 19
							// Consumo faturado
							contaTxt.append((Util
									.completaStringComEspacoAEsquerdaCondicaoTamanhoMaximo(
											consumoFaturamento.replace(".", ""),
											5).substring(0, 5)));

							// item 20
							// Dias de consumo
							contaTxt.append(Util.completaString(diasConsumo, 2));

							// item 21
							// Consumo médio diário
							contaTxt.append((Util
									.completaStringComEspacoAEsquerdaCondicaoTamanhoMaximo(
											consumoMedioDiario.replace(".", ""),
											6)).substring(0, 6));

							// item 22
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade de Meses
							// Igual a 3 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
									emitirContaHelper, 3, tipoLigacao,
									tipoMedicao);
							contaTxt.append(Util.completaString(
									obterDadosConsumoMedicaoAnterior.toString(),
									19));

							// item 23
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade
							// de Meses Igual a 6 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(
									emitirContaHelper, 6, tipoLigacao,
									tipoMedicao);
							contaTxt.append(Util.completaString(
									obterDadosConsumoMedicaoAnterior.toString(),
									19));

							// item 24
							// Data Leitura Anterior
							contaTxt.append(Util.completaString(
									dataLeituraAnterior, 10));

							// item 25
							// Data Leitura Atual
							contaTxt.append(Util.completaString(
									dataLeituraAtual, 10));

							// Inicio Chamar Sub-Fluxo recupera os parametros do
							// consumo historico
							// da conta [SB0007] - Obter Dados de Consumo da
							// Conta
							Object[] parmsConsumoHistorico = null;
							String descricaoAbreviadaTipoConsumo = "";
							String descricaoTipoConsumo = "";
							String consumoMedio = "";
							String descricaoAbreviadaAnormalidadeConsumo = "";
							String descricaoAnormalidadeConsumo = "";
							String consumoRateio = "";
							// caso o tipo de ligacao for diferente de nulo
							if (tipoLigacao != null) {
								try {
									parmsConsumoHistorico = repositorioMicromedicao
											.obterDadosConsumoConta(
													emitirContaHelper
															.getIdImovel(),
													emitirContaHelper
															.getAmReferencia(),
													tipoLigacao);

								} catch (ErroRepositorioException e) {
									sessionContext.setRollbackOnly();
									throw new ControladorException(
											"erro.sistema", e);
								}

								if (parmsConsumoHistorico != null) {
									// descrição abreviada tipo de consumo
									if (parmsConsumoHistorico[0] != null) {
										descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
									}
									// descrição tipo de consumo
									if (parmsConsumoHistorico[1] != null) {
										descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
									}
									// Consumo médio
									if (parmsConsumoHistorico[2] != null) {
										consumoMedio = ""
												+ (Integer) parmsConsumoHistorico[2];
									}
									// descrição abreviada anormalidade de
									// consumo
									if (parmsConsumoHistorico[3] != null) {
										descricaoAbreviadaAnormalidadeConsumo = (String) parmsConsumoHistorico[3];
									}
									// descrição anormalidade de consumo
									if (parmsConsumoHistorico[4] != null) {
										descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
									}
									// Consumo médio
									if (parmsConsumoHistorico[5] != null) {
										consumoRateio = ""
												+ (Integer) parmsConsumoHistorico[5];
									}
								}
							}
							// Fim Chamar Sub-Fluxo

							// item 26
							// constante
							contaTxt.append("CONSUMO ");

							// item 27
							// descrição tipo consumo
							contaTxt.append(Util.completaString(
									descricaoTipoConsumo, 20));

							// item 28
							// descrição da Anormalidade de consumo
							contaTxt.append(Util.completaString(
									descricaoAnormalidadeConsumo, 25));

							// Inicio Chamar Sub-Fluxo soma a quantidades de
							// economias da
							// tabela contaCategoria [SB0007] - Obter Dados da
							// Medição da Conta
							Short quantidadeEconomiaConta = 0;
							try {
								quantidadeEconomiaConta = repositorioFaturamento
										.obterQuantidadeEconomiasConta(emitirContaHelper
												.getIdConta());
							} catch (ErroRepositorioException e) {
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema",
										e);
							}
							// Fim Chamar Sub-Fluxo

							// item 29
							// Quantidade de economias da conta
							contaTxt.append(Util
									.completaStringComEspacoAEsquerda(""
											+ quantidadeEconomiaConta, 3));

							// Consumo por Economia transforma o
							// consumoFaturamento para um bigDecimal
							BigDecimal consumoFaturadoBigDecimal = null;
							if (consumoFaturamento != null
									&& !consumoFaturamento.equals("")) {
								consumoFaturadoBigDecimal = Util
										.formatarMoedaRealparaBigDecimal(consumoFaturamento);
							}
							// transforma a quantidade de economias da conta
							// para um bigDecimal
							BigDecimal qtdEconomiasBigDecimal = null;
							if (quantidadeEconomiaConta != null
									&& !quantidadeEconomiaConta.equals("")) {
								qtdEconomiasBigDecimal = Util
										.formatarMoedaRealparaBigDecimal(""
												+ quantidadeEconomiaConta);
							}

							String consumoEconomia = "";
							if (consumoFaturadoBigDecimal != null
									&& qtdEconomiasBigDecimal != null) {
								BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal
										.divide(qtdEconomiasBigDecimal, 2,
												RoundingMode.UP);
								consumoEconomia = Util
										.formatarMoedaReal(consumoEconomiaBigDecimal);
								if (consumoEconomia != null) {
									consumoEconomia = consumoEconomia
											.substring(
													0,
													consumoEconomia.length() - 3);
								}
							}

							// item 30
							// consumo por economia
							contaTxt.append((Util
									.completaStringComEspacoAEsquerdaCondicaoTamanhoMaximo(
											consumoEconomia.replace(".", ""), 5))
									.substring(0, 5));

							// Inicio Chamar Sub-Fluxo concatena os campos dos
							// sub-fluxos anteriores
							// [SB0009] - Obter Código auxiliar
							StringBuilder codigoAuxiliar = new StringBuilder();
							// leitura situação atual
							codigoAuxiliar.append(Util
									.adicionarZerosEsquedaNumero(1,
											leituraSituacaoAtual));
							// tipo de consumo
							codigoAuxiliar.append(Util
									.adicionarZerosEsquedaNumero(1,
											descricaoAbreviadaTipoConsumo));
							// tipo de contrato
							codigoAuxiliar.append(Util
									.adicionarZerosEsquedaNumero(1, ""));
							// anormalidade de leitura
							codigoAuxiliar.append(Util
									.adicionarZerosEsquedaNumero(2,
											leituraAnormalidadeFaturamento));
							// anormalidade de consumo
							codigoAuxiliar
									.append(Util
											.adicionarZerosEsquedaNumero(2,
													descricaoAbreviadaAnormalidadeConsumo));
							// perfil do imóvel
							if (emitirContaHelper.getIdImovelPerfil() != null) {
								codigoAuxiliar
										.append(Util
												.adicionarZerosEsquedaNumero(
														1,
														""
																+ emitirContaHelper
																		.getIdImovelPerfil()));
							} else {
								codigoAuxiliar.append(Util
										.adicionarZerosEsquedaNumero(1, ""));
							}
							// dias do consumo
							codigoAuxiliar
									.append(Util.adicionarZerosEsquedaNumero(2,
											diasConsumo));
							// Consumo medio do imóvel
							codigoAuxiliar.append(Util
									.adicionarZerosEsquedaNumero(6,
											consumoMedio));
							// Fim Chamar Sub-Fluxo

							// item 31
							// codigo auxiliar
							contaTxt.append(Util.completaString(
									codigoAuxiliar.toString(), 16));
							codigoAuxiliar = null;

							// item 32
							// chama o [SB0009] - Obter Mensagem de Rateio de
							// Consumo Fixo de Esgoto
							StringBuilder mesagemConsumo = obterMensagemRateioConsumoFichaCompensacao(
									emitirContaHelper, consumoRateio,
									parmsMedicaoHistorico, tipoMedicao);
							// mensagem de rateio de consumo ou consumo fixo de
							// esgoto
							contaTxt.append(mesagemConsumo);

							// [SB0010] - Gerar Linhas da Descrição dos Serviços
							// e Tarifas
							StringBuilder linhasDescricaoServicosTarifasTotal = gerarLinhasDescricaoServicoTarifasFichaCompensacao(
									emitirContaHelper, consumoRateio,
									parmsMedicaoHistorico, tipoMedicao);
							StringBuilder linhasDescricaoServicosTarifas = new StringBuilder();
							int posicaoAtual = 0;
							int tamanhoString = linhasDescricaoServicosTarifasTotal
									.length();
							// cada linha = 79 => 50 + 15 + 14
							// 79 * 15 = 1185
							int limite = 1185;

							// caso a quantidade de linhas seja menor ou igual a
							// zero,pois na conta
							// só cabe 15 linhas, passando isso é preciso gerar
							// outra folha para a conta
							if (tamanhoString <= limite) {
								// caso esteja vazio o array então completa com
								// espaços em branco
								if (tamanhoString == 0) {
									// completa com espaços em branco
									contaTxt.append(Util.completaString(
											consumoEconomia, limite));

								} else {
									posicaoAtual = 0;
									linhasDescricaoServicosTarifas = linhasDescricaoServicosTarifasTotal;
									linhasDescricaoServicosTarifasTotal = new StringBuilder();
								}
								// caso contrario [FS0006 - Verificar espaços
								// para descrição
								// dos serviços e tarifas totalmente preenchido]
							} else {
								// alterado por Vivianne Sousa - 01/12/2009
								linhasDescricaoServicosTarifas
										.append(linhasDescricaoServicosTarifasTotal
												.substring(0, limite));
								// linhasDescricaoServicosTarifas.append(linhasDescricaoServicosTarifasTotal.substring(0,limite-1));
								// posição atual recebe a posição inicial
								posicaoAtual = limite;

								parteInicialcontaTxt = new StringBuilder(
										contaTxt);

							}

							int espacosEmBranco = 0;

							// caso a posicao limite seja maior que o tamanho do
							// array,
							// significa que todas as strings já foram
							// atualizadas na conta.
							if (tamanhoString <= limite) {
								// Limpa os campos para mandar para o método que
								// o chamou
								posicaoAtual = 0;
								linhasDescricaoServicosTarifasTotal = null;
								espacosEmBranco = limite - tamanhoString;
							}

							if (linhasDescricaoServicosTarifas != null
									&& linhasDescricaoServicosTarifas.length() != 0) {
								contaTxt.append(linhasDescricaoServicosTarifas);
							}
							linhasDescricaoServicosTarifas = null;

							contaTxt.append(Util.completaString("",
									espacosEmBranco));

							if (tamanhoString <= limite) {
								contaTxt.append(Util.completaString("", 15));
							} else {
								contaTxt.append(Util.completaString(
										"         ", 15));
							}

							// item 79
							String valorContaString = Util
									.formatarMoedaReal(emitirContaHelper
											.getValorConta());
							// valor da conta
							contaTxt.append(Util
									.completaStringComEspacoAEsquerda(
											valorContaString, 14));

							if (faturamentoGrupo != null
									&& faturamentoGrupo.getAnoMesReferencia() != null) {
								emitirContaHelper
										.setAnoMesFaturamentoGrupo(faturamentoGrupo
												.getAnoMesReferencia());
							}

							// chama o [SB0016] - Obter Mensagem da Conta em 3
							// Partes
							String[] parmsPartesConta = obterMensagemConta3Partes(
									emitirContaHelper, sistemaParametro);
							String primeiraParte = parmsPartesConta[0];
							String segundaParte = parmsPartesConta[1];
							String terceiraParte = parmsPartesConta[2];

							// item 80
							// completa com a primeira parte do [SB0016]
							contaTxt.append(Util.completaString(primeiraParte,
									100));

							// item 81
							// completa com a segunda parte do [SB0016]
							contaTxt.append(Util.completaString(segundaParte,
									100));

							// item 82
							// completa com a terceira parte do [SB0016]
							contaTxt.append(Util.completaString(terceiraParte,
									100));

							// item 83
							// nome da gerencia regional
							contaTxt.append(Util.completaString(
									emitirContaHelper.getNomeGerenciaRegional(),
									25));

							// item 84
							int anoMesReferenciaSubtraido = Util
									.subtrairMesDoAnoMes(
											emitirContaHelper.getAmReferencia(),
											1);
							String mesAnoFormatado = Util
									.formatarAnoMesParaMesAno(anoMesReferenciaSubtraido);
							// mes/ano da referencia da conta
							contaTxt.append(Util.completaString(
									mesAnoFormatado, 7));

							Object[] parmsQualidadeAgua = null;
							try {
								parmsQualidadeAgua = repositorioFaturamento
										.pesquisarParmsQualidadeAgua(emitirContaHelper);
							} catch (ErroRepositorioException e) {
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema",
										e);
							}

							// numero indice turbidez da qualidade agua
							String numeroIndiceTurbidez = "";
							// numero cloro residual da qualidade agua
							String numeroCloroResidual = "";
							if (parmsQualidadeAgua != null) {
								if (parmsQualidadeAgua[0] != null) {
									numeroIndiceTurbidez = Util
											.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]);
								}

								if (parmsQualidadeAgua[1] != null) {
									numeroCloroResidual = Util
											.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]);
								}
							}

							// item 85
							// turbidez
							contaTxt.append(Util
									.completaStringComEspacoAEsquerda(
											numeroIndiceTurbidez, 9));

							// item 86
							// cloro residual
							contaTxt.append(Util
									.completaStringComEspacoAEsquerda(
											numeroCloroResidual, 9));

							// item 87
							// grupo de faturamento
							if (faturamentoGrupo != null) {
								contaTxt.append(Util.completaString(
										faturamentoGrupo.getId().toString(), 2));
							} else {
								contaTxt.append(Util.completaString("", 2));
							}

							// item 88
							// código da empresa
							if (emitirContaHelper.getIdEmpresa() != null) {
								contaTxt.append(Util.completaStringComEspacoAEsquerda(
										"" + emitirContaHelper.getIdEmpresa(),
										2));
							} else {
								contaTxt.append(Util.completaString("", 2));
							}

							// incrementa o sequencial de impressao
							// caso seja conta do cliente responsável então o
							// sequencial fica nulo

							// sequencial impressão
							String sequencialImpressaoFormatada = Util
									.adicionarZerosEsquedaNumero(6, ""
											+ sequencialImpressao);
							sequencialImpressaoFormatada = sequencialImpressaoFormatada
									.substring(0, 3)
									+ "."
									+ sequencialImpressaoFormatada.substring(3,
											6);

							// item 89
							// adiciona o sequencial ao txt
							contaTxt.append(Util.completaString(""
									+ sequencialImpressaoFormatada, 7));

							// item 90
							// código do banco
							contaTxt.append("001-9");

							// item 91
							// representação numérica do código de barras
							// [SB0030 - Obter representação numérica do código
							// de barras
							// da Ficha de Compensação]
							StringBuilder nossoNumero = obterNossoNumeroFichaCompensacao(
									"1", emitirContaHelper.getIdConta()
											.toString());
							String nossoNumeroSemDV = nossoNumero.toString()
									.substring(0, 17);

							Date dataVencimentoMais90 = Util
									.adicionarNumeroDiasDeUmaData(new Date(),
											90);
							String fatorVencimento = CodigoBarras.obterFatorVencimento(dataVencimentoMais90);

							String especificacaoCodigoBarra = CodigoBarras.obterEspecificacaoCodigoBarraFichaCompensacao(
											ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO,
											ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO,
											emitirContaHelper.getValorConta(),
											nossoNumeroSemDV.toString(),
											ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO,
											fatorVencimento);

							String representacaoNumericaCodigoBarraFichaCompensacao = CodigoBarras.obterRepresentacaoNumericaCodigoBarraFichaCompensacao(especificacaoCodigoBarra);

							contaTxt.append(representacaoNumericaCodigoBarraFichaCompensacao);

							// item 92
							// local de pagamento
							contaTxt.append(Util
									.completaString(
											"PAGÁVEL EM QUALQUER BANCO ATÉ O VENCIMENTO",
											45));

							// item 93
							// vencimento
							contaTxt.append(Util.completaString(
									"Contra-apresentação", 20));

							// item 94
							// cedente
							contaTxt.append(Util
									.completaString(
											"COMPESA-Companhia Pernambucana de Saneamento",
											50));

							// item 95
							// agência/código cedente
							contaTxt.append("3234-4/2868-1");

							// item 96
							// data do documento
							contaTxt.append(Util.formatarData(new Date()));

							// item 97
							// número do documento
							contaTxt.append(Util.completaString(
									matriculaImovelFormatada, 10));

							// item 98
							// espécie do documento
							contaTxt.append("FAT");

							// item 99
							// aceite
							contaTxt.append("N");

							// item 100
							// data do processamento
							contaTxt.append(Util.formatarData(new Date()));

							// item 101
							// nosso número com DV
							contaTxt.append(nossoNumero);

							// item 102
							// carteira
							contaTxt.append(ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO);

							// item 103
							// valor do documento
							contaTxt.append(Util
									.completaStringComEspacoAEsquerda(
											valorContaString, 14));

							// item 104
							// Sacado - linha 1.a
							if (nomeClienteUsuario != null
									&& !nomeClienteUsuario.equalsIgnoreCase("")) {
								contaTxt.append(Util.completaString(
										nomeClienteUsuario, 30));
							} else {
								contaTxt.append(Util.completaString(
										emitirContaHelper.getNomeCliente(), 30));
							}

							// item 105
							// Sacado - linha 1.b
							contaTxt.append(Util.completaString(
									"   Matrícula: ", 16));

							// item 106
							// Sacado - linha 1.c
							contaTxt.append(Util.completaString(
									matriculaImovelFormatada, 9));

							// item 107
							// Sacado - linha 1.d
							contaTxt.append(Util.completaString("   Fatura: ",
									14));

							// item 108
							// Sacado - linha 1.d
							contaTxt.append(Util.completaString(
									mesAnoReferencia + "-" + digitoVerificador,
									9));

							// item 109
							// Sacado - linha 2.a
							contaTxt.append(Util.completaString(enderecoImovel,
									50));

							// item 110
							// código de barras
							if (especificacaoCodigoBarra != null
									&& !especificacaoCodigoBarra.equals("")) {
								// Cria o objeto para gerar o códigode barras no
								// padrão intercalado 2 de 5
								Interleaved2of5 codigoBarraIntercalado2de5 = new Interleaved2of5();

								contaTxt.append(Util.completaString(
										codigoBarraIntercalado2de5
												.encodeValue(especificacaoCodigoBarra),
										112));

							}

							// ****************************************************************************************
							// Autor: Ivan Sergio
							// Data: 22/06/2009
							// Adicionado mais uma linha no Endereco do Imovel
							// e do Cliente Responsavel
							// ****************************************************************************************
							// 2º Linha do Endereco do Imovel
							if (enderecoImovelSegundaLinha != null) {
								if (enderecoImovelSegundaLinha.length() > 50) {
									enderecoImovelSegundaLinha = enderecoImovelSegundaLinha
											.substring(50);
								} else {
									enderecoImovelSegundaLinha = "";
								}
							}
							contaTxt.append(Util.completaString(
									enderecoImovelSegundaLinha == null ? ""
											: enderecoImovelSegundaLinha, 50));

							// 2º Linha do Endereco do Cliente Responsavel
							if (!enderecoClienteResponsavelSegundaLinha
									.equals("")) {
								if (enderecoClienteResponsavelSegundaLinha
										.length() > 50) {
									enderecoClienteResponsavelSegundaLinha = enderecoClienteResponsavelSegundaLinha
											.substring(50);
								} else {
									enderecoClienteResponsavelSegundaLinha = "";
								}
							}
							contaTxt.append(Util.completaString(
									enderecoClienteResponsavelSegundaLinha, 50));
							// ****************************************************************************************

							// recupera todas as linhas do while
							StringBuilder todasPaginasContaTxt = new StringBuilder();
							// se é a primeira vez que entra no while então
							// recupera o final da
							// linha colocando o continua para depois criar as
							// proximas paginas
							boolean primeiraVez = true;
							int posicaoLimite = 0;
							espacosEmBranco = 0;
							// responsável de criar outra pagina para a conta
							// caso a
							// descrição dos serviços e tarifas exceda as 15
							// linhas
							while (posicaoAtual != 0) {
								// é criado para criar a stringBuilder da ultima
								// linha no caso
								// da primeira vez,no caso da segunda vez em
								// diante é criado
								// para criar a proxima pagina da mesma conta
								StringBuilder paginaTxt = new StringBuilder();
								if (primeiraVez) {
									primeiraVez = false;
								} else {
									// caso a quantidade de linhas seja menor ou
									// igual a zero,
									// pois na conta só cabe 15 linhas, passando
									// isso é
									// preciso gerar outra folha para a conta

									// caso o tamanho do array seja maior que a
									// posição atual + 15
									if (tamanhoString <= posicaoAtual + limite) {
										posicaoLimite = tamanhoString;
									} else {
										posicaoLimite = posicaoAtual + limite;
									}

									linhasDescricaoServicosTarifas = new StringBuilder();
									linhasDescricaoServicosTarifas
											.append(linhasDescricaoServicosTarifasTotal
													.substring(posicaoAtual,
															posicaoLimite));

									// posição atual recebe a posição inicial
									posicaoAtual = posicaoLimite;

									// caso a posicao limite seja maior que o
									// tamanho do array,
									// significa que todas as strings já foram
									// atualizadas na conta.
									if (tamanhoString <= posicaoLimite) {
										// Limpa os campos para mandar para o
										// método que o chamou
										posicaoAtual = 0;
										linhasDescricaoServicosTarifasTotal = null;
										espacosEmBranco = posicaoLimite
												- tamanhoString;

									}
									paginaTxt.append(parteInicialcontaTxt);
									paginaTxt
											.append(linhasDescricaoServicosTarifas);

									// recupera a ultima linha
									// paginaTxt.append(ultimaLinhasConta);
									if (posicaoAtual != 0) {
										paginaTxt.append(Util.completaString(
												"", espacosEmBranco));

										if (tamanhoString <= limite) {
											paginaTxt.append(Util
													.completaString("", 15));
										} else {
											paginaTxt.append(Util
													.completaString(
															"         ", 15));
										}

									}

								}
								todasPaginasContaTxt.append(paginaTxt);
								paginaTxt = null;
								if (posicaoAtual != 0) {
									todasPaginasContaTxt.append(System
											.getProperty("line.separator"));
								}
							}

							// coloca a ultima linha ou a outra(s) parte(s) da
							// conta
							// (outra pagina caso a descrição de serviços e
							// tarifas exceda as 15 linhas) no txt da conta
							if (todasPaginasContaTxt != null
									&& todasPaginasContaTxt.length() != 0) {
								contaTxt.append(System
										.getProperty("line.separator"));
								contaTxt.append(todasPaginasContaTxt);
								todasPaginasContaTxt = null;
							}

							// txt recupera a string builder da conta da lista
							// de contas
							contasTxtLista.append(contaTxt.toString());

							StringBuilder teste = new StringBuilder();
							teste.append(contaTxt);

							contaTxt = null;

							contasTxtLista.append(System
									.getProperty("line.separator"));

							// adiciona o id da conta e o sequencial no para
							// serem atualizados
							mapAtualizaSequencial.put(
									emitirContaHelper.getIdConta(),
									sequencialImpressao);

						}// fim do laço que verifica se o
							// helper é diferente de nulo
					}// fim laço while do iterator do objeto helper
					countOrdem++;

					// fim do laço que verifica se a coleção é nula
				}

				repositorioFaturamento
						.atualizarSequencialContaImpressaoFichaCompensacao(mapAtualizaSequencial);
				mapAtualizaSequencial = null;

				String idGrupoFaturamento = null;

				if (faturamentoGrupo == null) {
					idGrupoFaturamento = "G";
				} else {
					idGrupoFaturamento = "G" + faturamentoGrupo.getId();
				}

				String mesReferencia = "_Fat"
						+ anoMesReferenciaFaturamento.toString()
								.substring(4, 6);
				String nomeZip = null;
				String nomeZipCartaConta = null;

				switch (tipoConta) {
				case 0:
					nomeZip = "BOLETO_E" + "_" + idGrupoFaturamento
							+ mesReferencia + "_Emp" + idEmpresa + "-";
					nomeZipCartaConta = "CARTA_BOLETO_CONTA_ESTOURO" + "_"
							+ idGrupoFaturamento + mesReferencia + "_Emp"
							+ idEmpresa + "-";
					break;
				case 1:
					nomeZip = "BOLETO_A" + "_" + idGrupoFaturamento
							+ mesReferencia + "_Emp" + idEmpresa + "-";
					nomeZipCartaConta = "CARTA_BOLETO_BAIXO_CONSUMO" + "_"
							+ idGrupoFaturamento + mesReferencia + "_Emp"
							+ idEmpresa + "-";
					break;
				case 2:
					nomeZip = "BOLETO_D" + "_" + idGrupoFaturamento
							+ mesReferencia + "_Emp" + idEmpresa + "-";
					break;
				case 3:
					nomeZip = "BOLETO_N_R" + "_" + idGrupoFaturamento
							+ mesReferencia + "-";
					break;
				case 4:
					nomeZip = "BOLETO_D_R" + "_" + idGrupoFaturamento
							+ mesReferencia + "-";
					break;
				case 5:
					nomeZip = "BOLETO_N" + "_" + idGrupoFaturamento
							+ mesReferencia + "_Emp" + idEmpresa + "-";
					break;

				case 6:
					nomeZip = "BOLETO_D_B" + "_" + mesReferencia + "-";
					break;

				case 7:
					nomeZip = "BOLETO_N_R_B" + "_" + mesReferencia + "-";
					break;

				case 8:
					nomeZip = "BOLETO_D_R_B" + "_" + mesReferencia + "-";
					break;

				case 9:
					nomeZip = "BOLETO_N_B" + "_" + mesReferencia + "-";
					break;
				}

				BufferedWriter out = null;
				ZipOutputStream zos = null;
				File compactadoTipoCarta = null;

				File compactadoTipo = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".zip");
				if (nomeZipCartaConta != null) {
					compactadoTipoCarta = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZipCartaConta + ".zip");
				}

				File leituraTipo = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZip + ".txt");
				File leituraTipoCarta = null;
				if (nomeZipCartaConta != null) {
					leituraTipoCarta = new File(getControladorUtil().getCaminhoDownloadArquivos("faturamento") + nomeZipCartaConta + ".txt");
				}

				if (contasTxtLista != null && contasTxtLista.length() != 0) {
					// fim de arquivo
					contasTxtLista.append("\u0004");
					// ************ TIPO E *************

					zos = new ZipOutputStream(new FileOutputStream(compactadoTipo));
					out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipo.getAbsolutePath())));
					
					out.write(contasTxtLista.toString());
					out.flush();
					ZipUtil.adicionarArquivo(zos, leituraTipo);
					zos.close();

					out.close();
					leituraTipo.delete();
				}

				if (cartasTxtListaConta != null
						&& cartasTxtListaConta.length() != 0) {
					// fim de arquivo
					contasTxtLista.append("\u0004");
					// ************ TIPO N *************

					zos = new ZipOutputStream(new FileOutputStream(compactadoTipoCarta));
					
					out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipoCarta.getAbsolutePath())));
					out.write(cartasTxtListaConta.toString());
					out.flush();
					ZipUtil.adicionarArquivo(zos, leituraTipoCarta);
					zos.close();
					out.close();
					leituraTipoCarta.delete();
				}

				// limpa todos os campos
				nomeZip = null;
				nomeZipCartaConta = null;
				out = null;
				zos = null;
				compactadoTipo = null;
				compactadoTipoCarta = null;
				leituraTipo = null;
				leituraTipoCarta = null;
				cartasTxtListaConta = null;
				contasTxtLista = null;

				tipoConta++;
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

		} catch (IOException e) {
			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");
			if (inicioMensagem != null
					&& (inicioMensagem[0].equals("erro") || inicioMensagem[0]
							.equals("atencao"))) {
				throw new ControladorException(mensagem);
			} else {
				throw new ControladorException("erro.sistema", e);
			}
		} catch (Exception e) {
			e.printStackTrace();
			String mensagem = e.getMessage();
			if (mensagem != null) {
				String[] inicioMensagem = mensagem.split("\\.");
				if (inicioMensagem != null
						&& (inicioMensagem[0].equals("erro") || inicioMensagem[0]
								.equals("atencao"))) {
					throw new ControladorException(mensagem);
				} else {
					throw new ControladorException("erro.sistema", e);
				}
			} else {
				throw new ControladorException("erro.sistema", e);
			}
		}
	}

	/**
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * Recupera o percentual alternativo e o numero de consumo do percentual
	 * alternativo para o imóvel informado.
	 * 
	 * @author Vivianne Sousa
	 * @date 24/01/2008
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	private Object[] obterPercentualAlternativoLigacaoEsgotoImovel(
			Integer idImovel) throws ControladorException {

		try {
			return repositorioFaturamento
					.obterPercentualAlternativoLigacaoEsgotoImovel(idImovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * 
	 * obtem imovel, localidade e conta atraves do id da conta
	 * 
	 * @author Vivianne Sousa
	 * @date 29/01/2008
	 * 
	 * @param idConta
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Conta obterImovelLocalidadeConta(Integer idConta)
			throws ControladorException {

		try {
			return repositorioFaturamento.obterImovelLocalidadeConta(idConta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * 
	 * obtem imovel, localidade e contaHistorico atraves do id da conta
	 * historico
	 * 
	 * @author Vivianne Sousa
	 * @date 29/01/2008
	 * 
	 * @param idConta
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public ContaHistorico obterImovelLocalidadeContaHistorico(Integer idConta)
			throws ControladorException {

		try {
			return repositorioFaturamento
					.obterImovelLocalidadeContaHistorico(idConta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela Bônus
	 * 
	 * Retorna dados dos parcelamentos com RD = 8 que estejam com situação
	 * normal e que não exista outro parcelamento com data posterior
	 * 
	 * @author Vivianne Sousa
	 * @date 27/12/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizaQtdeParcelaPagaConsecutivaEParcelaBonus(
			Integer idLocalidade, int idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.LOCALIDADE, idLocalidade);

		try {

			// 1. o sistema seleciona a lista de parcelamento da RD = 8 que
			// estejam com a situaçã normal
			Collection colecaoParcelamento = getControladorCobranca()
					.pesquisarParcelamentoRDEspecial(
							ParcelamentoSituacao.NORMAL, idLocalidade);

			if (colecaoParcelamento != null && !colecaoParcelamento.isEmpty()) {

				Iterator iteratorParcelamento = colecaoParcelamento.iterator();
				int anoMesArrecadacao = getControladorUtil()
						.pesquisarParametrosDoSistema().getAnoMesArrecadacao();

				while (iteratorParcelamento.hasNext()) {
					Parcelamento parcelamento = (Parcelamento) iteratorParcelamento
							.next();

					// 1.1 pega o ano/mês do parcelamento,
					// soma-se o numero de prestações ao número de meses deste
					// ano/mês
					// e adiciona mais 2 meses
					// o resultado, compara com o ano/mês da arrecadação

					int anoMesParcelamento = Util.getAnoMesComoInt(parcelamento
							.getParcelamento());
					Short numeroPrestacoes = parcelamento.getNumeroPrestacoes();
					int numeroPrestacoesMaisDois = numeroPrestacoes.intValue() + 2;

					anoMesParcelamento = Util.somaMesAnoMesReferencia(
							anoMesParcelamento, numeroPrestacoesMaisDois);

					if (anoMesParcelamento > anoMesArrecadacao) {

						// 2. verifica se existe conta com ano/mês de referencia
						// igual ao (ano/mês da arrecadação - 1 mês) e
						// que exista serviço de parcelamento cobrado na conta
						Object[] contaArray = null;

						contaArray = repositorioFaturamento
								.pesquisarContaImovel(parcelamento.getImovel()
										.getId(), Util.subtrairMesDoAnoMes(
										anoMesArrecadacao, 1));

						if (contaArray != null) {
							Integer idConta = null;
							Date dataVencimentoConta = null;

							if (contaArray[0] != null) {
								idConta = (Integer) contaArray[0];
							}

							if (contaArray[1] != null) {
								dataVencimentoConta = (Date) contaArray[1];
							}

							// verifica se conta esta paga
							Date dataPagamento = getControladorArrecadacao()
									.pesquisarDataPagamentoDeConta(idConta);

							if (dataPagamento == null) {
								// 2.1.1 caso não exista pagamento

								// zera o campo NNPARCELASPAGASCONSECUTIVAS da
								// tabela PARCELAMENTO
								getControladorCobranca()
										.atualizarNumeroParcelasPagasConsecutivasParcelamento(
												parcelamento.getId(),
												new Short("0"));

							} else {
								// 2.1.2
								dataVencimentoConta = Util
										.adicionarNumeroDiasDeUmaData(
												dataVencimentoConta, 2);

								// verifica se conta foi paga no vencimento
								if (dataPagamento
										.compareTo(dataVencimentoConta) == 1) {
									// conta não foi paga no vencimento

									// zera o campo NNPARCELASPAGASCONSECUTIVAS
									// da tabela PARCELAMENTO
									getControladorCobranca()
											.atualizarNumeroParcelasPagasConsecutivasParcelamento(
													parcelamento.getId(),
													new Short("0"));

								} else {
									// conta paga no vencimento
									// 2.1.2.1
									// verifica se o campo
									// NNPARCELASPAGASCONSECUTIVAS
									// é diferente de nulo e igual a 2
									if (parcelamento
											.getNumeroParcelasPagasConsecutivas() != null
											&& parcelamento
													.getNumeroParcelasPagasConsecutivas()
													.compareTo(new Short("2")) == 0) {

										// zera o campo
										// NNPARCELASPAGASCONSECUTIVAS da tabela
										// PARCELAMENTO
										getControladorCobranca()
												.atualizarNumeroParcelasPagasConsecutivasParcelamento(
														parcelamento.getId(),
														new Short("0"));

										// adiciona 1 ao campo
										// DBAC_NNPARCELABONUS da tabela
										// DEBITO_A_COBRAR
										adicionaUmNNParcelaBonusDebitoAcobrar(parcelamento
												.getId());

										// adiciona 1 ao campo
										// CRAR_NNPARCELABONUS da tabela
										// CREDITO_A_REALIZAR
										adicionaUmNNParcelaBonusCreditoARealizar(parcelamento
												.getId());

									} else {
										// adiciona 1 ao campo
										// NNPARCELASPAGASCONSECUTIVAS
										Short numeroParcelasPagasConsecutivas = 0;

										if (parcelamento
												.getNumeroParcelasPagasConsecutivas() != null) {
											numeroParcelasPagasConsecutivas = parcelamento
													.getNumeroParcelasPagasConsecutivas();
										}

										Short numeroParcelasPagasConsecutivasMaisUm = (short) (numeroParcelasPagasConsecutivas
												.intValue() + 1);

										getControladorCobranca()
												.atualizarNumeroParcelasPagasConsecutivasParcelamento(
														parcelamento.getId(),
														numeroParcelasPagasConsecutivasMaisUm);

									}

								}

							}

						}

					}

				}// while

			}

			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception ex) {
			getControladorBatch().encerrarUnidadeProcessamentoBatch(ex,
					idUnidadeIniciada, true);
			ex.printStackTrace();
			sessionContext.setRollbackOnly();

			throw new EJBException(ex);
		}

	}

	/**
	 * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela Bônus
	 * 
	 * @author Vivianne Sousa
	 * @date 07/02/2008
	 * 
	 * @param idParcelamento
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public void adicionaUmNNParcelaBonusDebitoAcobrar(Integer idParcelamento)
			throws ControladorException {

		try {
			repositorioFaturamento
					.adicionaUmNNParcelaBonusDebitoAcobrar(idParcelamento);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela Bônus
	 * 
	 * @author Vivianne Sousa
	 * @date 07/02/2008
	 * 
	 * @param idParcelamento
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public void adicionaUmNNParcelaBonusCreditoARealizar(Integer idParcelamento)
			throws ControladorException {

		try {
			repositorioFaturamento
					.adicionaUmNNParcelaBonusCreditoARealizar(idParcelamento);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public DebitoACobrar gerarDebitoACobrar(
			Integer anoMesReferenciaArrecadacao,
			Integer anoMesReferenciaFaturamento, Imovel imovel,
			Short numeroPrestacaoDebito, Short numeroPrestacaoCobradas,
			Integer anoMesReferenciaDebito, BigDecimal valorDebito,
			DebitoTipo debitoTipo, Usuario usuario) throws ControladorException {

		DebitoACobrar debitoACobrar;
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

		CobrancaForma cobrancaForma = new CobrancaForma();
		cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

		Object[] obterDebitoTipo;
		try {
			obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo
					.getId());

			FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
			if (obterDebitoTipo[0] != null) {
				financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
			}

			LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
			if (obterDebitoTipo[1] != null) {
				lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
			}

			debitoACobrar = new DebitoACobrar();
			debitoACobrar.setAnoMesCobrancaDebito(anoMesReferenciaArrecadacao);
			debitoACobrar
					.setAnoMesReferenciaContabil(getAnoMesReferenciaContabil());
			debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
			debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
			debitoACobrar.setImovel(imovel);
			debitoACobrar.setLocalidade(imovel.getLocalidade());
			debitoACobrar.setQuadra(imovel.getQuadra());
			if (imovel.getSetorComercial() != null) {
				debitoACobrar.setCodigoSetorComercial(imovel
						.getSetorComercial().getCodigo());
			}
			if (imovel.getQuadra() != null) {
				debitoACobrar.setNumeroQuadra(imovel.getQuadra()
						.getNumeroQuadra());
			}
			debitoACobrar.setNumeroLote(imovel.getLote());
			debitoACobrar.setNumeroSubLote(imovel.getSubLote());
			debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
			debitoACobrar.setRegistroAtendimento(null);
			debitoACobrar.setOrdemServico(null);
			debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
			debitoACobrar.setParcelamentoGrupo(null);
			debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
			debitoACobrar.setCobrancaForma(cobrancaForma);
			debitoACobrar.setDebitoTipo(debitoTipo);
			debitoACobrar.setUltimaAlteracao(new Date());
			debitoACobrar.setGeracaoDebito(new Date());
			debitoACobrar.setAnoMesReferenciaDebito(anoMesReferenciaDebito);
			debitoACobrar.setFinanciamentoTipo(financiamentoTipo);
			debitoACobrar.setLancamentoItemContabil(lancamentoItemContabil);
			debitoACobrar.setValorDebito(valorDebito);
			debitoACobrar.setUsuario(usuario);

			DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
			debitoACobrarGeral.setIndicadorHistorico(ConstantesSistema.NAO);
			debitoACobrarGeral.setUltimaAlteracao(new Date());

			Integer idDebitoACobrarGeral = (Integer) getControladorUtil()
					.inserir(debitoACobrarGeral);
			debitoACobrarGeral.setId(idDebitoACobrarGeral);

			debitoACobrar.setId(idDebitoACobrarGeral);
			debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);

			getControladorUtil().inserir(debitoACobrar);

			inserirDebitoACobrarCategoria(debitoACobrar, imovel);
		} catch (Exception e) {
			throw new EJBException(e);
		}

		return debitoACobrar;
	}

	/**
	 * [UC0302] - Gerar Débito a Cobrar de Acréscimos por Impontualidade
	 * 
	 * [SB0001] - Gerar Débito a Cobrar
	 * 
	 * Gera o débito a cobrar de acréscimos por impontualidade para a conta.
	 * 
	 * @author Pedro Alexandre
	 * @date 28/04/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param anoMesReferenciaFaturamento
	 * @param imovel
	 * @param localidade
	 * @param quadra
	 * @param setorComercial
	 * @param numeroPrestacaoDebito
	 * @param numeroPrestacaoCobradas
	 * @param conta
	 * @param calcularAcrescimoPorImpontualidade
	 * @param debitoTipo
	 * @return
	 * @throws ControladorException
	 */
	protected DebitoACobrar gerarDebitoACobrarParaConta(
			Integer anoMesReferenciaArrecadacao, Imovel imovel,
			Short numeroPrestacaoDebito, Short numeroPrestacaoCobradas,
			Conta conta, BigDecimal valorDebito, DebitoTipo debitoTipo,
			Usuario usuario) throws ControladorException {

		DebitoACobrar debitoACobrar;
		
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL);
		CobrancaForma cobrancaForma = new CobrancaForma(CobrancaForma.COBRANCA_EM_CONTA);
		
		Object[] obterDebitoTipo;

		try {
			obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo.getId());

			FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
			if (obterDebitoTipo[0] != null) {
				financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
			}

			LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
			if (obterDebitoTipo[1] != null) {
				lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
			}

			debitoACobrar = new DebitoACobrar();
			debitoACobrar.setImovel(imovel);
			debitoACobrar.setAnoMesCobrancaDebito(anoMesReferenciaArrecadacao);
			debitoACobrar.setAnoMesReferenciaContabil(getAnoMesReferenciaContabil());
			debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
			debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
			debitoACobrar.setLocalidade(imovel.getLocalidade());
			debitoACobrar.setQuadra(imovel.getQuadra());
			debitoACobrar.setCodigoSetorComercial(imovel.getSetorComercia().getCodigo());
			debitoACobrar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
			debitoACobrar.setNumeroLote(imovel.getLote());
			debitoACobrar.setNumeroSubLote(imovel.getSubLote());
			debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
			debitoACobrar.setRegistroAtendimento(null);
			debitoACobrar.setOrdemServico(null);
			debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
			debitoACobrar.setParcelamentoGrupo(null);
			debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
			debitoACobrar.setCobrancaForma(cobrancaForma);
			debitoACobrar.setDebitoTipo(debitoTipo);
			debitoACobrar.setUltimaAlteracao(new Date());
			debitoACobrar.setGeracaoDebito(new Date());
			debitoACobrar.setAnoMesReferenciaDebito(conta.getReferencia());
			debitoACobrar.setFinanciamentoTipo(financiamentoTipo);
			debitoACobrar.setLancamentoItemContabil(lancamentoItemContabil);
			debitoACobrar.setValorDebito(valorDebito);
			debitoACobrar.setUsuario(usuario);

			DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
			debitoACobrarGeral.setIndicadorHistorico(ConstantesSistema.NAO);
			debitoACobrarGeral.setUltimaAlteracao(new Date());

			Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
			debitoACobrarGeral.setId(idDebitoACobrarGeral);

			debitoACobrar.setId(idDebitoACobrarGeral);
			debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);
		} catch (Exception e) {
			throw new EJBException(e);
		}

		// retorna o débito a cobrar gerado
		return debitoACobrar;
	}

	private int getAnoMesReferenciaContabil() throws ControladorException {
		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();
		int anoMesReferenciaContabil = sistemaParametro.getAnoMesFaturamento();
		int anoMesCorrente = Util.getAnoMesComoInt(new Date());

		if (sistemaParametro.getAnoMesFaturamento() < anoMesCorrente) {
			anoMesReferenciaContabil = anoMesCorrente;
		}
		return anoMesReferenciaContabil;
	}

	/**
	 * retorna o maior valor entre o ano/mês da data corrente e o ano/mês de
	 * referencia do faturamento (PARM_AMREFERENCIAFATURAMENTO da tabela
	 * SISTEMA_PARAMETROS)
	 * 
	 * @author Vivianne Sousa
	 * @date 06/05/2008
	 */
	public Integer obterReferenciaContabilConta(
			SistemaParametro sistemaParametro) {

		Integer anoMesCorrente = Util.getAnoMesComoInteger(new Date());
		Integer anoMesFaturamento = sistemaParametro.getAnoMesFaturamento();
		Integer referenciaContabil = anoMesFaturamento;

		if (anoMesCorrente.compareTo(anoMesFaturamento) == 1) {
			referenciaContabil = anoMesCorrente;
		}
		return referenciaContabil;
	}

	public Collection gerarRelatorioContasCanceladas(
			RelatorioContasCanceladasRetificadasHelper helper)
			throws ControladorException {

		Collection retorno = new ArrayList();

		String tipoConta = helper.getTipoConta();
		try {
			SistemaParametro sistemaParametro;
			sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			int anoMes = Util.formatarMesAnoComBarraParaAnoMes(helper
					.getMesAno());

			Collection colecaoConta = null;

			// tipo conta = 1 - cancelada / 2 - retificada
			if (anoMes < sistemaParametro.getAnoMesFaturamento()) {
				// faturamento fechado( anoMes < anoMesParametroSistema)
				// pesquisar em conta historico
				colecaoConta = repositorioFaturamento
						.pesquisarContasCanceladasFaturamentoFechado(helper);

				if (colecaoConta != null && !colecaoConta.isEmpty()) {
					Iterator iterator = colecaoConta.iterator();
					RelatorioContasCanceladasRetificadasHelper contaHelper = new RelatorioContasCanceladasRetificadasHelper();

					BigDecimal valorTotal = BigDecimal.ZERO;
					BigDecimal valorAgua = BigDecimal.ZERO;
					BigDecimal valorEsgoto = BigDecimal.ZERO;
					BigDecimal valorCredito = BigDecimal.ZERO;
					BigDecimal valorDebito = BigDecimal.ZERO;
					BigDecimal valorImposto = BigDecimal.ZERO;

					while (iterator.hasNext()) {
						ContaHistorico contaHistorico = (ContaHistorico) iterator
								.next();

						valorTotal = BigDecimal.ZERO;
						valorAgua = BigDecimal.ZERO;
						valorEsgoto = BigDecimal.ZERO;
						valorCredito = BigDecimal.ZERO;
						valorDebito = BigDecimal.ZERO;
						valorImposto = BigDecimal.ZERO;

						valorAgua = contaHistorico.getValorAgua();
						valorEsgoto = contaHistorico.getValorEsgoto();
						valorDebito = contaHistorico.getValorDebitos();
						valorCredito = contaHistorico.getValorCreditos();
						valorImposto = contaHistorico.getValorImposto();

						if (valorAgua != null) {

							valorTotal = valorTotal.add(valorAgua);

						}

						if (valorEsgoto != null) {

							valorTotal = valorTotal.add(valorEsgoto);

						}

						if (valorDebito != null) {

							valorTotal = valorTotal.add(valorDebito);

						}

						if (valorCredito != null) {

							valorTotal = valorTotal.subtract(valorCredito);

						}

						if (valorImposto != null) {

							valorTotal = valorTotal.subtract(valorImposto);

						}

						contaHelper = new RelatorioContasCanceladasRetificadasHelper(
								contaHistorico.getDataCancelamento() != null ? Util
										.formatarData(contaHistorico
												.getDataCancelamento()) : null,
								contaHistorico.getUsuario() != null ? contaHistorico
										.getUsuario().getLogin() : null,
								getControladorImovel()
										.pesquisarInscricaoImovel(
												(contaHistorico.getImovel()
														.getId())),
								getControladorEndereco().pesquisarEndereco(
										contaHistorico.getImovel().getId()),
								Util.formatarAnoMesParaMesAno(contaHistorico
										.getAnoMesReferenciaConta()),
								contaHistorico.getContaMotivoCancelamento() != null ? contaHistorico
										.getContaMotivoCancelamento().getId()
										+ "-"
										+ contaHistorico
												.getContaMotivoCancelamento()
												.getDescricaoMotivoCancelamentoConta()
										+ ""
										: null,
								valorTotal + "",
								contaHistorico.getRegistroAtendimento() != null ? contaHistorico
										.getRegistroAtendimento().getId() + ""
										: null,
								contaHistorico.getLocalidade().getId() + "",
								Util.retornaMatriculaImovelFormatada(contaHistorico
										.getImovel().getId()));

						contaHelper.setCodigoSetorComercial(contaHistorico
								.getSetorComercial().toString());

						contaHelper.setIdUnidadeNegocio(contaHistorico
								.getLocalidade().getUnidadeNegocio().getId()
								+ "");
						contaHelper.setUnidadeNegocio(contaHistorico
								.getLocalidade().getUnidadeNegocio().getId()
								+ " - "
								+ contaHistorico.getLocalidade()
										.getUnidadeNegocio().getNome());

						contaHelper.setGerenciaRegional(contaHistorico
								.getLocalidade().getUnidadeNegocio()
								.getGerenciaRegional().getNome());
						contaHelper.setIdGerenciaRegional(contaHistorico
								.getLocalidade().getUnidadeNegocio()
								.getGerenciaRegional().getId().toString());

						contaHelper.setTipoConta(tipoConta);
						retorno.add(contaHelper);

					}
				}
			} else {
				// faturamento Aberto pesquisar em conta
				colecaoConta = repositorioFaturamento
						.pesquisarContasCanceladasFaturamentoAberto(helper);

				if (colecaoConta != null && !colecaoConta.isEmpty()) {
					Iterator iterator = colecaoConta.iterator();
					RelatorioContasCanceladasRetificadasHelper contaHelper = new RelatorioContasCanceladasRetificadasHelper();

					BigDecimal valorTotal = BigDecimal.ZERO;
					BigDecimal valorAgua = BigDecimal.ZERO;
					BigDecimal valorEsgoto = BigDecimal.ZERO;
					BigDecimal valorCredito = BigDecimal.ZERO;
					BigDecimal valorDebito = BigDecimal.ZERO;
					BigDecimal valorImposto = BigDecimal.ZERO;

					while (iterator.hasNext()) {
						Conta conta = (Conta) iterator.next();

						valorTotal = BigDecimal.ZERO;
						valorAgua = BigDecimal.ZERO;
						valorEsgoto = BigDecimal.ZERO;
						valorCredito = BigDecimal.ZERO;
						valorDebito = BigDecimal.ZERO;
						valorImposto = BigDecimal.ZERO;

						valorAgua = conta.getValorAgua();
						valorEsgoto = conta.getValorEsgoto();
						valorDebito = conta.getDebitos();
						valorCredito = conta.getValorCreditos();
						valorImposto = conta.getValorImposto();

						if (valorAgua != null) {

							valorTotal = valorTotal.add(valorAgua);

						}

						if (valorEsgoto != null) {

							valorTotal = valorTotal.add(valorEsgoto);

						}

						if (valorDebito != null) {

							valorTotal = valorTotal.add(valorDebito);

						}

						if (valorCredito != null) {

							valorTotal = valorTotal.subtract(valorCredito);

						}

						if (valorImposto != null) {

							valorTotal = valorTotal.subtract(valorImposto);

						}

						contaHelper = new RelatorioContasCanceladasRetificadasHelper(
								Util.formatarData(conta.getDataCancelamento()),
								conta.getUsuario().getLogin(),
								getControladorImovel()
										.pesquisarInscricaoImovel(
												(conta.getImovel().getId())),
								getControladorEndereco().pesquisarEndereco(
										conta.getImovel().getId()),
								Util.formatarAnoMesParaMesAno(conta
										.getReferencia()),
								conta.getContaMotivoCancelamento().getId()
										+ "-"
										+ conta.getContaMotivoCancelamento()
												.getDescricaoMotivoCancelamentoConta()
										+ "", valorTotal + "",
								conta.getRegistroAtendimento() != null ? conta
										.getRegistroAtendimento().getId() + ""
										: null, conta.getLocalidade().getId()
										+ "",
								Util.retornaMatriculaImovelFormatada(conta
										.getImovel().getId()));

						contaHelper.setCodigoSetorComercial(conta
								.getCodigoSetorComercial().toString());
						contaHelper.setIdUnidadeNegocio(conta.getLocalidade()
								.getUnidadeNegocio().getId()
								+ "");

						contaHelper.setUnidadeNegocio(conta.getLocalidade()
								.getUnidadeNegocio().getId()
								+ " - "
								+ conta.getLocalidade().getUnidadeNegocio()
										.getNome());

						contaHelper.setGerenciaRegional(conta.getLocalidade()
								.getUnidadeNegocio().getGerenciaRegional()
								.getNome());
						contaHelper.setIdGerenciaRegional(conta.getLocalidade()
								.getUnidadeNegocio().getGerenciaRegional()
								.getId().toString());

						contaHelper.setTipoConta(tipoConta);

						retorno.add(contaHelper);

					}
				}
			}

		} catch (ControladorException e) {
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * Cria a coleção de helper que irá preencher o relatorio das contas
	 * retificadas
	 * 
	 * @author Bruno Leonardo R. Barros,Vivianne Sousa
	 * @date 27/01/2009
	 * @param helper
	 * @return
	 * @throws ControladorException
	 */

	public Collection gerarRelatorioContasRetificadas(
			RelatorioContasCanceladasRetificadasHelper helper)
			throws ControladorException {

		Collection retorno = new ArrayList();

		try {
			SistemaParametro sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			int anoMes = Util.formatarMesAnoComBarraParaAnoMes(helper
					.getMesAno());

			Collection colContasOriginais = null;
			Collection colContasRetificadas = null;

			// Dados da conta Retificada, que pode vir de conta historico ou de
			// de conta
			Date contaRetificadaDataRetificacao = null;
			Usuario contaRetificadaUsuario = null;
			String contaRetificadaMotivoRetificacao = null;
			Localidade contaRetificadaLocalidade = null;
			BigDecimal contaRetificadaValor = BigDecimal.ZERO;

			// Dados que precisamos da conta original
			Integer contaOriginalImovelId = null;
			Integer contaOriginalAnoMesReferencia = null;
			BigDecimal contaOriginalValor = BigDecimal.ZERO;
			RegistroAtendimento contaOriginalRegistroAtendimento = null;

			// Verificamos se o faturamento ja foi fechado
			// se sim, pegamos as contas de conta histórico
			// se não, pegamos as contas de conta
			// [SB0002]  Pesquisar Contas Retificadas.
			if (anoMes < sistemaParametro.getAnoMesFaturamento()) {

				// 1. Caso o ano/mês referência informado esteja com o
				// faturamento fechado
				colContasOriginais = repositorioFaturamento
						.pesquisarContasRetificadasFaturamentoFechado(helper);

				if (colContasOriginais != null && !colContasOriginais.isEmpty()) {
					RelatorioContasCanceladasRetificadasHelper relatorioHelper;

					Iterator iteContasOriginais = colContasOriginais.iterator();

					while (iteContasOriginais.hasNext()) {

						// Selecionamos a conta atual que iremos trabalhar
						Object contaOriginal = iteContasOriginais.next();

						contaOriginalImovelId = ((ContaHistorico) contaOriginal)
								.getImovel().getId();
						contaOriginalAnoMesReferencia = ((ContaHistorico) contaOriginal)
								.getAnoMesReferenciaConta();
						contaOriginalValor = ((ContaHistorico) contaOriginal)
								.getValorTotal();
						contaOriginalRegistroAtendimento = ((ContaHistorico) contaOriginal)
								.getRegistroAtendimento();

						// 1.2. Pesquisa as contas na tabela CONTA_HISTORICO
						colContasRetificadas = repositorioFaturamento
								.pesquisarContasRetificadasValorNovoContaHistorico(
										helper, contaOriginalImovelId + "",
										contaOriginalAnoMesReferencia + "");

						// MIN(CNTA_ID da pesquisa atual) > CNTA_ID da pesquisa
						// anterior 1.1
						// (ou seja, recuperar a próxima conta do imóvel para a
						// mesma referência, com situação 1,4 ou 5).
						if (colContasRetificadas != null
								&& !colContasRetificadas.isEmpty()) {

							if (contaOriginal instanceof ContaHistorico) {
								boolean primeiraVez = true;
								ContaHistorico menorConta = null;

								Iterator colContasRetificadasIterator = colContasRetificadas
										.iterator();
								while (colContasRetificadasIterator.hasNext()) {

									ContaHistorico aux = (ContaHistorico) colContasRetificadasIterator
											.next();
									if (aux.getId().compareTo(
											((ContaHistorico) contaOriginal)
													.getId()) > 0) {

										if (primeiraVez) {
											menorConta = aux;
											primeiraVez = false;
										} else if (aux.getId().compareTo(
												menorConta.getId()) < 0) {
											menorConta = aux;
										}
									}
								}

								if (menorConta != null) {
									if (colContasRetificadas != null) {
										colContasRetificadas.clear();
									}
									colContasRetificadas.add(menorConta);
									menorConta = null;
								} else {
									if (colContasRetificadas != null) {
										colContasRetificadas.clear();
									}
								}
							}
						}

						// Caso a conta nao seja encontrada, significa que ainda
						// esta em conta
						if (colContasRetificadas != null
								&& !colContasRetificadas.isEmpty()) {

							ContaHistorico contaRetificada = (ContaHistorico) colContasRetificadas
									.iterator().next();
							contaRetificadaDataRetificacao = null;
							contaRetificadaDataRetificacao = contaRetificada
									.getDataRetificacao();
							contaRetificadaUsuario = contaRetificada
									.getUsuario();

							if (contaRetificada.getContaMotivoRetificacao() != null) {
								contaRetificadaMotivoRetificacao = contaRetificada
										.getContaMotivoRetificacao().getId()
										+ "-"
										+ contaRetificada
												.getContaMotivoRetificacao()
												.getDescricao() + "";
							}

							contaRetificadaLocalidade = contaRetificada
									.getLocalidade();
							contaRetificadaValor = contaRetificada
									.getValorTotal();

							// Montamos o Helper do relatorio com as informacoes
							// necessarias
							relatorioHelper = new RelatorioContasCanceladasRetificadasHelper(
									contaRetificadaDataRetificacao != null ? Util
											.formatarData(contaRetificadaDataRetificacao)
											: null,
									contaRetificadaUsuario != null ? contaRetificadaUsuario
											.getLogin() : null,
									getControladorImovel()
											.pesquisarInscricaoImovel(
													(contaOriginalImovelId)),
									getControladorEndereco().pesquisarEndereco(
											contaOriginalImovelId),
									Util.formatarAnoMesParaMesAno(contaOriginalAnoMesReferencia),
									contaRetificadaMotivoRetificacao,
									"",
									contaOriginalRegistroAtendimento != null ? contaOriginalRegistroAtendimento
											.getId() + ""
											: null,
									contaOriginalValor + "",
									contaRetificadaValor + "",
									Util.retornaMatriculaImovelFormatada(contaOriginalImovelId));

							relatorioHelper.setIdUnidadeNegocio(contaRetificada
									.getLocalidade().getUnidadeNegocio()
									.getId()
									+ "");
							relatorioHelper
									.setCodigoSetorComercial(contaRetificada
											.getSetorComercial().toString());
							relatorioHelper.setUnidadeNegocio(contaRetificada
									.getLocalidade().getUnidadeNegocio()
									.getId()
									+ " - "
									+ contaRetificada.getLocalidade()
											.getUnidadeNegocio().getNome());

							relatorioHelper
									.setIdLocalidade(contaRetificadaLocalidade
											.getId() + "");

							relatorioHelper
									.setIdGerenciaRegional(contaRetificada
											.getLocalidade()
											.getGerenciaRegional().getId()
											+ "");
							relatorioHelper.setGerenciaRegional(contaRetificada
									.getLocalidade().getGerenciaRegional()
									.getNome()
									+ "");

							retorno.add(relatorioHelper);
						}
						// 1.3. Caso a pesquisa 1.2 não tenha resultado.
						else {

							// Pesquisamos em conta
							colContasRetificadas = repositorioFaturamento
									.pesquisarContasRetificadasValorNovoConta(
											helper, contaOriginalImovelId + "",
											contaOriginalAnoMesReferencia + "");

							if (colContasRetificadas != null
									&& !colContasRetificadas.isEmpty()) {
								Conta contaRetificada = (Conta) colContasRetificadas
										.iterator().next();
								contaRetificadaDataRetificacao = null;
								contaRetificadaDataRetificacao = contaRetificada
										.getDataRetificacao();
								contaRetificadaUsuario = contaRetificada
										.getUsuario();
								if (contaRetificada.getContaMotivoRetificacao() != null
										&& !contaRetificada
												.getContaMotivoRetificacao()
												.equals("")) {
									contaRetificadaMotivoRetificacao = contaRetificada
											.getContaMotivoRetificacao()
											.getId()
											+ "-"
											+ ""
											+ contaRetificada
													.getContaMotivoRetificacao()
													.getDescricao() + "";
								}
								contaRetificadaLocalidade = contaRetificada
										.getLocalidade();

								contaRetificadaValor = contaRetificada
										.getValorTotal();

								// Montamos o Helper do relatorio com as
								// informacoes
								// necessarias
								relatorioHelper = new RelatorioContasCanceladasRetificadasHelper(
										contaRetificadaDataRetificacao != null ? Util
												.formatarData(contaRetificadaDataRetificacao)
												: null,
										contaRetificadaUsuario != null ? contaRetificadaUsuario
												.getLogin() : null,
										getControladorImovel()
												.pesquisarInscricaoImovel(
														(contaOriginalImovelId)),
										getControladorEndereco()
												.pesquisarEndereco(
														contaOriginalImovelId),
										Util.formatarAnoMesParaMesAno(contaOriginalAnoMesReferencia),
										contaRetificadaMotivoRetificacao,
										"",
										contaOriginalRegistroAtendimento != null ? contaOriginalRegistroAtendimento
												.getId() + ""
												: null,
										contaOriginalValor + "",
										contaRetificadaValor + "",
										Util.retornaMatriculaImovelFormatada(contaOriginalImovelId));

								relatorioHelper
										.setIdUnidadeNegocio(contaRetificada
												.getLocalidade()
												.getUnidadeNegocio().getId()
												+ "");
								relatorioHelper
										.setCodigoSetorComercial(contaRetificada
												.getCodigoSetorComercial()
												.toString());
								relatorioHelper
										.setUnidadeNegocio(contaRetificada
												.getLocalidade()
												.getUnidadeNegocio().getId()
												+ " - "
												+ contaRetificada
														.getLocalidade()
														.getUnidadeNegocio()
														.getNome());
								relatorioHelper
										.setIdLocalidade(contaRetificadaLocalidade
												.getId() + "");

								relatorioHelper
										.setIdGerenciaRegional(contaRetificada
												.getLocalidade()
												.getGerenciaRegional().getId()
												+ "");
								relatorioHelper
										.setGerenciaRegional(contaRetificada
												.getLocalidade()
												.getGerenciaRegional()
												.getNome()
												+ "");

								retorno.add(relatorioHelper);

							}
						}
					}
				}
			} else {

				colContasOriginais = repositorioFaturamento
						.pesquisarContasRetificadasFaturamentoAberto(helper);

				// Verificamos se algo foi encontrado
				if (colContasOriginais != null && !colContasOriginais.isEmpty()) {
					RelatorioContasCanceladasRetificadasHelper relatorioHelper;

					Iterator iteContasOriginais = colContasOriginais.iterator();

					while (iteContasOriginais.hasNext()) {

						// Selecionamos a conta atual que iremos trabalhar
						Object contaOriginal = iteContasOriginais.next();

						contaOriginalImovelId = ((Conta) contaOriginal)
								.getImovel().getId();
						contaOriginalAnoMesReferencia = ((Conta) contaOriginal)
								.getReferencia();
						contaOriginalValor = ((Conta) contaOriginal)
								.getValorTotal();
						contaOriginalRegistroAtendimento = ((Conta) contaOriginal)
								.getRegistroAtendimento();

						// Pesquisamos em conta
						colContasRetificadas = repositorioFaturamento
								.pesquisarContasRetificadasValorNovoContaAberta(
										helper, contaOriginalImovelId + "",
										contaOriginalAnoMesReferencia + "");

						if (colContasRetificadas != null
								&& !colContasRetificadas.isEmpty()) {
							Conta contaRetificada = (Conta) colContasRetificadas
									.iterator().next();
							contaRetificadaDataRetificacao = null;
							contaRetificadaDataRetificacao = contaRetificada
									.getDataRetificacao();
							contaRetificadaUsuario = contaRetificada
									.getUsuario();
							if (contaRetificada.getContaMotivoRetificacao() != null
									&& !contaRetificada
											.getContaMotivoRetificacao()
											.equals("")) {
								contaRetificadaMotivoRetificacao = contaRetificada
										.getContaMotivoRetificacao().getId()
										+ "-"
										+ ""
										+ contaRetificada
												.getContaMotivoRetificacao()
												.getDescricao() + "";
							}
							contaRetificadaLocalidade = contaRetificada
									.getLocalidade();

							contaRetificadaValor = contaRetificada
									.getValorTotal();

							// Montamos o Helper do relatorio com as informacoes
							// necessarias
							relatorioHelper = new RelatorioContasCanceladasRetificadasHelper(
									contaRetificadaDataRetificacao != null ? Util
											.formatarData(contaRetificadaDataRetificacao)
											: null,
									contaRetificadaUsuario != null ? contaRetificadaUsuario
											.getLogin() : null,
									getControladorImovel()
											.pesquisarInscricaoImovel(
													(contaOriginalImovelId)),
									getControladorEndereco().pesquisarEndereco(
											contaOriginalImovelId),
									Util.formatarAnoMesParaMesAno(contaOriginalAnoMesReferencia),
									contaRetificadaMotivoRetificacao,
									"",
									contaOriginalRegistroAtendimento != null ? contaOriginalRegistroAtendimento
											.getId() + ""
											: null,
									contaOriginalValor + "",
									contaRetificadaValor + "",
									Util.retornaMatriculaImovelFormatada(contaOriginalImovelId));

							relatorioHelper.setIdUnidadeNegocio(contaRetificada
									.getLocalidade().getUnidadeNegocio()
									.getId()
									+ "");
							relatorioHelper
									.setCodigoSetorComercial(contaRetificada
											.getCodigoSetorComercial()
											.toString());
							relatorioHelper.setUnidadeNegocio(contaRetificada
									.getLocalidade().getUnidadeNegocio()
									.getId()
									+ " - "
									+ contaRetificada.getLocalidade()
											.getUnidadeNegocio().getNome());
							relatorioHelper
									.setIdLocalidade(contaRetificadaLocalidade
											.getId() + "");

							relatorioHelper
									.setIdGerenciaRegional(contaRetificada
											.getLocalidade()
											.getGerenciaRegional().getId()
											+ "");
							relatorioHelper.setGerenciaRegional(contaRetificada
									.getLocalidade().getGerenciaRegional()
									.getNome()
									+ "");

							retorno.add(relatorioHelper);

						}

					}
				}

			}

		} catch (ControladorException e) {
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [UC0302] - Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * Gera o débito a cobrar por acréscimo de impontualidade para guia de
	 * pagamento.
	 * 
	 * [SB0001 - Gerar Débito a Cobrar]
	 * 
	 * @author Pedro Alexandre
	 * @date 29/04/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param anoMesReferenciaFaturamento
	 * @param imovel
	 * @param localidade
	 * @param quadra
	 * @param setorComercial
	 * @param numeroPrestacaoDebito
	 * @param numeroPrestacaoCobradas
	 * @param guiaPagamento
	 * @param calcularAcrescimoPorImpontualidade
	 * @param debitoTipo
	 * @return
	 * @throws ControladorException
	 */
	protected DebitoACobrar gerarDebitoACobrarParaGuiaPagamento(
			Integer anoMesReferenciaArrecadacao,
			Integer anoMesReferenciaFaturamento, Imovel imovel,
			Short numeroPrestacaoDebito, Short numeroPrestacaoCobradas,
			GuiaPagamento guiaPagamento, BigDecimal valorDebito,
			DebitoTipo debitoTipo, Usuario usuario) throws ControladorException {

		// declaração de variáveis
		DebitoACobrar debitoACobrar;
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
		CobrancaForma cobrancaForma = new CobrancaForma();
		cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);
		Object[] obterDebitoTipo;

		try {
			obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo
					.getId());

			FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
			if (obterDebitoTipo[0] != null) {
				financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
			}

			LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
			if (obterDebitoTipo[1] != null) {
				lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
			}

			debitoACobrar = new DebitoACobrar();
			debitoACobrar.setImovel(imovel);
			debitoACobrar.setAnoMesCobrancaDebito(anoMesReferenciaArrecadacao);
			debitoACobrar.setAnoMesReferenciaContabil(anoMesReferenciaFaturamento);
			debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
			debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
			debitoACobrar.setLocalidade(imovel.getLocalidade());
			debitoACobrar.setQuadra(imovel.getQuadra());
			debitoACobrar.setCodigoSetorComercial(imovel.getCodigoSetorComercial());
			debitoACobrar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
			debitoACobrar.setNumeroLote(imovel.getLote());
			debitoACobrar.setNumeroSubLote(imovel.getSubLote());
			debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
			debitoACobrar.setRegistroAtendimento(null);
			debitoACobrar.setOrdemServico(null);
			debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
			debitoACobrar.setParcelamentoGrupo(null);
			debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
			debitoACobrar.setCobrancaForma(cobrancaForma);
			debitoACobrar.setDebitoTipo(debitoTipo);
			debitoACobrar.setUltimaAlteracao(new Date());
			debitoACobrar.setGeracaoDebito(new Date());
			debitoACobrar.setAnoMesReferenciaDebito(guiaPagamento.getAnoMesReferenciaContabil());
			debitoACobrar.setFinanciamentoTipo(financiamentoTipo);
			debitoACobrar.setLancamentoItemContabil(lancamentoItemContabil);
			debitoACobrar.setValorDebito(valorDebito);
			debitoACobrar.setUsuario(usuario);

			// Inseri o débito a cobrar geral e recupera o id
			DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
			Integer idDebitoACobrarGeral = (Integer) getControladorUtil()
					.inserir(debitoACobrarGeral);
			debitoACobrarGeral.setId(idDebitoACobrarGeral);

			debitoACobrar.setId(idDebitoACobrarGeral);
			debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);

		} catch (Exception e) {
			throw new EJBException(e);
		}

		return debitoACobrar;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0302] - Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 05/05/2008
	 * 
	 * @param codigoEmpresaFebraban
	 * @param idRota
	 * @return
	 * @throws ControladorException
	 */
	protected Map<Integer, Categoria> pesquisarPrincipalCategoriaImovelPorRota(Short codigoEmpresaFebraban, Rota rota) throws ControladorException {

		Map<Integer, Categoria> retorno = new HashMap();

		try {
			Collection<Object[]> colecaoDadosImovelCategoria = null;

			if (!rota.getIndicadorRotaAlternativa().equals(ConstantesSistema.SIM)) {
				colecaoDadosImovelCategoria = repositorioFaturamento.pesquisarPrincipalCategoriaImovelPorRota(codigoEmpresaFebraban, rota.getId());
			} else {
				colecaoDadosImovelCategoria = repositorioFaturamento.pesquisarPrincipalCategoriaImovelPorRotaAlternativa(codigoEmpresaFebraban, rota.getId());
			}

			if (colecaoDadosImovelCategoria != null && !colecaoDadosImovelCategoria.isEmpty()) {
				
				for (Object[] dadosImovelCategoria : colecaoDadosImovelCategoria) {
					Integer idImovel = (Integer) dadosImovelCategoria[0];

					if (!retorno.containsKey(idImovel)) {
						Categoria categoria = new Categoria((Integer) dadosImovelCategoria[1]);
						categoria.setQuantidadeEconomiasCategoria((Integer) dadosImovelCategoria[2]);
						categoria.setIndicadorCobrancaAcrescimos((Short) dadosImovelCategoria[3]);

						retorno.put(idImovel, categoria);

					}
				}
			}
		} catch (Exception e) {
			throw new EJBException(e);
		}
		return retorno;
	}

	/**
	 * Retorna as contas com o indicador de pagamento para a conta.
	 * 
	 * [UC0302] - Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 08/05/2008
	 * 
	 * @param colecaoContas
	 * @param anoMesReferenciaAtual
	 * @return
	 * @throws ControladorException
	 */
	protected Map<Integer, Boolean> pesquisarIndicadorPagamentoConta(Collection<Object[]> colecaoContas, Integer anoMesReferenciaAtual){
		
		Map<Integer, Boolean> retorno = new HashMap();
		Collection<Integer> idsContas = new ArrayList();

		if (colecaoContas != null && !colecaoContas.isEmpty()) {
			for (Object[] dadosConta : colecaoContas) {
				Integer idConta = (Integer) dadosConta[0];
				idsContas.add(idConta);
			}

			try {
				Collection<Integer> colecaoRetorno = null;
				colecaoRetorno = this.repositorioFaturamento.obterIndicadorPagamentosClassificadosContaReferenciaMenorIgualAtual(idsContas, anoMesReferenciaAtual);
				if (colecaoRetorno != null && !colecaoRetorno.isEmpty()) {

					for (Integer idConta : colecaoRetorno) {
						if (!retorno.containsKey(idConta)) {
							retorno.put(idConta, true);
						}

					}
				}

			} catch (Exception e) {
				throw new EJBException(e);
			}

		}
		return retorno;
	}

	/**
	 * pesquisa o indicado de acréscimo para o cliente do imóvel.
	 * 
	 * [UC0302]-Gerar Débito a cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 09/05/2008
	 * 
	 * @param idRota
	 * @return
	 * @throws ControladorException
	 */
	protected Map<Integer, Short> obterIndicadorGeracaoAcrescimosClienteImovel(Rota rota) throws ControladorException {
		Map<Integer, Short> retorno = new HashMap();

		try {
			Collection<Object[]> colecaoRetorno = null;

			if (!rota.getIndicadorRotaAlternativa().equals(ConstantesSistema.SIM)) {
				colecaoRetorno = this.repositorioFaturamento.obterIndicadorGeracaoAcrescimosClienteImovel(rota.getId());
			} else {
				colecaoRetorno = this.repositorioFaturamento.obterIndicadorGeracaoAcrescimosClienteImovelPorRotaAlternativa(rota.getId());
			}

			if (colecaoRetorno != null && !colecaoRetorno.isEmpty()) {

				for (Object[] dadosRetorno : colecaoRetorno) {

					Integer idImovel = (Integer) dadosRetorno[0];
					Short indicadorAcrescimo = (Short) dadosRetorno[1];

					if (!retorno.containsKey(idImovel)) {
						retorno.put(idImovel, indicadorAcrescimo);
					}
				}
			}

		} catch (Exception e) {
			throw new EJBException(e);
		}

		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 15/05/2008
	 */
	public Integer pesquisarMaxIdConta() throws ControladorException {

		try {
			return repositorioFaturamento.pesquisarMaxIdConta();
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @author Vivianne Sousa
	 * @date 15/05/2008
	 */
	public Integer pesquisarMaxIdContaHistorico() throws ControladorException {

		try {
			return repositorioFaturamento.pesquisarMaxIdContaHistorico();
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso é responsável pelo pré-faturamento das contas que serão
	 * emitidas no cliente (Geração Simultânea)
	 * 
	 * [UC0000] - Pré-Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 09/04/2008
	 * 
	 * @param colecaoRota
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void preFaturarGrupoFaturamento(Rota rota, Integer anoMesFaturamento, Integer idFaturamentoGrupo, int idFuncionalidadeIniciada) throws ControladorException {

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,UnidadeProcessamento.ROTA, rota.getId());

		try {
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo(idFaturamentoGrupo);
			faturamentoGrupo.setAnoMesReferencia(anoMesFaturamento);

			rota.setFaturamentoGrupo(faturamentoGrupo);

			ApagarDadosFaturamentoHelper helper = new ApagarDadosFaturamentoHelper();

			helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.PRE_FATURADA);
			helper.setFaturamentoGrupo(faturamentoGrupo);
			helper.setRota(rota);
			helper.setAnoMesFaturamento(anoMesFaturamento);

			// Pesquisando o FaturamentoAtivCronRota para ser utilizando no momento de definição do vencimento da conta.
			FaturamentoAtivCronRota faturamentoAtivCronRota = this.pesquisarFaturamentoAtivCronRotaPara(rota.getId(), FaturamentoAtividade.GERAR_ARQUIVO_LEITURA, idFaturamentoGrupo, anoMesFaturamento);
			faturamentoAtivCronRota.setRota(rota);

			// APAGAR DADOS GERADOS PARA A ROTA NO ANO/MES DE REFERENCIA DO FATURAMENTO
			this.apagarDadosGeradosFaturarGrupoFaturamento(helper, FaturamentoAtividade.FATURAR_GRUPO);


			// Variáveis para a paginação da pesquisa de Imovel por Grupo Faturamento
			boolean flagTerminou = false;
			final int quantidadeRegistros = 3000;
			int numeroIndice = 0;

			while (!flagTerminou) {

				Collection colecaoImovel = this.pesquisarImovelGrupoFaturamento(rota, numeroIndice, quantidadeRegistros, true, false);

				Collection colecaoResumoFaturamento = new ArrayList();

				if (colecaoImovel != null && !colecaoImovel.isEmpty()) {
					Iterator iteratorColecaoImoveis = colecaoImovel.iterator();

					Imovel imovel = null;
					while (iteratorColecaoImoveis.hasNext()) {
						imovel = (Imovel) iteratorColecaoImoveis.next();
						this.preFaturarImovel(anoMesFaturamento, sistemaParametro, faturamentoAtivCronRota, colecaoResumoFaturamento, imovel, false, faturamentoGrupo);
					}
				}

				//Incrementa o nº do indice da páginação
				numeroIndice = numeroIndice + quantidadeRegistros;

				// Caso a coleção de imoveis retornados for menor que a quantidade de registros seta a flag indicando que a paginação terminou.
				if (colecaoImovel == null || colecaoImovel.size() < quantidadeRegistros) {
					flagTerminou = true;
				}

				if (colecaoImovel != null) {
					colecaoImovel.clear();
					colecaoImovel = null;
				}
			}
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);
		} catch (Exception e) {
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e, idUnidadeIniciada, true);
			throw new EJBException(e);
		}

	}

	/**
	 * [UC0000] - Pré-Faturar Grupo de Faturamento
	 * 
	 * Obter o registro da tabela FaturamentoAtivCronRota referente a rota que
	 * está sendo pré-faturada
	 * 
	 * @author Raphael Rossiter
	 * @date 09/04/2008
	 * 
	 * @param idRota
	 * @param idFaturamentoAtividade
	 * @param idFaturamentoGrupo
	 * @param anoMesReferencia
	 * @return FaturamentoAtivCronRota
	 * @throws ErroRepositorioException
	 */
	public FaturamentoAtivCronRota pesquisarFaturamentoAtivCronRotaPara(
			Integer idRota, Integer idFaturamentoAtividade,
			Integer idFaturamentoGrupo, Integer anoMesReferencia)
			throws ControladorException {

		FaturamentoAtivCronRota retorno = null;

		try {

			retorno = repositorioFaturamento.pesquisarFaturamentoAtivCronRota(
					idRota, idFaturamentoAtividade, idFaturamentoGrupo,
					anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Este caso de uso é responsável pelo pré-faturamento das contas que serão
	 * emitidas no cliente (Geração Simultânea)
	 * 
	 * [UC0113] - Pré-Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/03/2008
	 * 
	 * @param anoMesFaturamento
	 * @param atividade
	 * @param sistemaParametro
	 * @param faturamentoAtivCronRota
	 * @param colecaoResumoFaturamento
	 * @param imovel
	 * @throws ControladorException
	 */
	protected void preFaturarImovel(Integer anoMesFaturamento, SistemaParametro sistemaParametro, FaturamentoAtivCronRota faturamentoAtivCronRota,
			Collection colecaoResumoFaturamento, Imovel imovel, boolean faturamentoAntecipado, FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		// Verifica se existe conta para o imóvel para o ano/mês de faturamento.
		Integer existeImovelConta = (Integer) getControladorImovel().pesquisarImovelIdComConta(imovel.getId(), anoMesFaturamento);

		// CASO NÃO EXISTA CONTA PARA O IMOVEL NO ANO/MES DE REFERENCIA
		if (existeImovelConta == null) {
			boolean gerarAtividadeGrupoFaturamento = true;
			this.preDeterminarFaturamentoImovel(imovel, gerarAtividadeGrupoFaturamento, faturamentoAtivCronRota, colecaoResumoFaturamento, sistemaParametro,
					faturamentoAntecipado, anoMesFaturamento, faturamentoGrupo);
		}
	}

	/**
	 * Determina os dados do pré-faturamento do imóvel.
	 * 
	 * [UCXXXX] - Pré-Faturar Grupo de Faturamento
	 * 
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * 
	 * @author Raphael Rossiter
	 * @date 27/03/2008
	 * 
	 * @param imovel
	 * @param gerarAtividadeGrupoFaturamento
	 * @param faturamentoAtivCronRota
	 * @param colecaoResumoFaturamento
	 * @param sistemaParametro
	 * @param faturamentoAntecipado
	 * @param anoMesFaturamento
	 * @throws ControladorException
	 */
	protected void preDeterminarFaturamentoImovel(Imovel imovel, boolean gerarAtividadeGrupoFaturamento, FaturamentoAtivCronRota faturamentoAtivCronRota, 
			Collection colecaoResumoFaturamento, SistemaParametro sistemaParametro, boolean faturamentoAntecipado, Integer anoMesFaturamento, FaturamentoGrupo faturamentoGrupo)
			throws ControladorException {

		Collection colecaoCategorias = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
		Collection colecaoCategoriaOUSubcategoria = getControladorImovel().obterColecaoCategoriaOuSubcategoriaDoImovel(imovel);

		DeterminarValoresFaturamentoAguaEsgotoHelper helperValoresAguaEsgoto = new DeterminarValoresFaturamentoAguaEsgotoHelper();

		boolean temHidrometro = false;
		if ((imovel.getHidrometroInstalacaoHistorico() != null && imovel.getHidrometroInstalacaoHistorico().getId() != null)
			|| (imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null)) {
			temHidrometro = true;
		}

		//OBS: Selecionar os imóveis que farão parte do faturamento de acordo com o INDICADOR_FATURAMENTO_SITUACAO que se encontra na situação da ligação e água e esgoto do imóvel.
		if (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
				|| imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO) || temHidrometro) {

			// Verificar se é para faturar pela situação especial de faturamento
			FiltroFaturamentoSituacaoHistorico filtroFaturamentoSituacaoHistorico = new FiltroFaturamentoSituacaoHistorico();
			filtroFaturamentoSituacaoHistorico.adicionarParametro(new ParametroSimples(FiltroFaturamentoSituacaoHistorico.ID_IMOVEL, imovel.getId()));
			filtroFaturamentoSituacaoHistorico.adicionarParametro(new ParametroNulo(FiltroFaturamentoSituacaoHistorico.ANO_MES_FATURAMENTO_RETIRADA));
			Collection<FaturamentoSituacaoHistorico> colFiltroFaturamentoSituacaoHistorico = this.getControladorUtil().pesquisar(
					filtroFaturamentoSituacaoHistorico, FaturamentoSituacaoHistorico.class.getName());

			FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = (FaturamentoSituacaoHistorico) Util.retonarObjetoDeColecao(colFiltroFaturamentoSituacaoHistorico);

			boolean faturar = true;

			if (imovel.getFaturamentoSituacaoTipo() != null && !imovel.getFaturamentoSituacaoTipo().equals("")) {

				if ((faturamentoSituacaoHistorico != null && anoMesFaturamento >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio() && anoMesFaturamento <= faturamentoSituacaoHistorico
						.getAnoMesFaturamentoSituacaoFim())
						&& (imovel.getFaturamentoSituacaoTipo() != null
								&& imovel.getFaturamentoSituacaoTipo().getIndicadorParalisacaoFaturamento().intValue() == 1 && imovel
								.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue() == 1)) {
					faturar = false;
				}
			}

			// [SB0002] - Determinar Valores para Faturamento de Água e/ou
			// Esgoto
			if (faturar) {
				helperValoresAguaEsgoto.setValorTotalAgua(BigDecimal.ONE);
				helperValoresAguaEsgoto.setValorTotalEsgoto(BigDecimal.ONE);
			} else {
				helperValoresAguaEsgoto.setValorTotalAgua(BigDecimal.ZERO);
				helperValoresAguaEsgoto.setValorTotalEsgoto(BigDecimal.ZERO);
			}

			// PERCENTUAL DE ESGOTO
			helperValoresAguaEsgoto.setPercentualEsgoto(this.verificarPercentualEsgotoAlternativo(imovel, null));

			// PERCENTUAL COLETA DE ESGOTO
			BigDecimal percentualColetaEsgoto = this.obterPercentualColetaEsgotoImovel(imovel.getId());

			helperValoresAguaEsgoto.setPercentualColetaEsgoto(percentualColetaEsgoto);

		}

		// [SB0003] - Verificar Não Geração da Conta
		boolean gerarConta = this.verificarNaoGeracaoConta(imovel, helperValoresAguaEsgoto.getValorTotalAgua(), helperValoresAguaEsgoto.getValorTotalEsgoto(),
				anoMesFaturamento, true);

		if (gerarConta) {

			// RECOLOCAR OS VALORES ZERADOS PARA ÁGUA E ESGOTO
			helperValoresAguaEsgoto.setValorTotalAgua(BigDecimal.ZERO);
			helperValoresAguaEsgoto.setValorTotalEsgoto(BigDecimal.ZERO);

			boolean preFaturamento = true;

			// [SB0004] - Gerar os Débitos Cobrados
			GerarDebitoCobradoHelper gerarDebitoCobradoHelper = this.gerarDebitoCobrado(imovel, anoMesFaturamento, sistemaParametro,
					gerarAtividadeGrupoFaturamento);

			// [SB0005] - Gerar os Créditos Realizados
			GerarCreditoRealizadoHelper gerarCreditoRealizadoHelper = this.gerarCreditoRealizado(imovel, anoMesFaturamento, helperValoresAguaEsgoto,
					gerarDebitoCobradoHelper.getValorTotalDebito(), gerarAtividadeGrupoFaturamento, preFaturamento);

			// ATIVIDADE FATURAR GRUPO
			if (gerarAtividadeGrupoFaturamento) {

				// [UC0351] - Gerar Impostos Deduzidos da Conta
				GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper = this.gerarImpostosDeduzidosConta(imovel.getId(), anoMesFaturamento,
						helperValoresAguaEsgoto.getValorTotalAgua(), helperValoresAguaEsgoto.getValorTotalEsgoto(),
						gerarDebitoCobradoHelper.getValorTotalDebito(), gerarCreditoRealizadoHelper.getValorTotalCredito(), preFaturamento);

				// [SB0006] - Gerar Dados da Conta
				// -----------------------------------------------------------------------------------------------------
				Conta conta = this.gerarConta(imovel, anoMesFaturamento, sistemaParametro, faturamentoAtivCronRota, helperValoresAguaEsgoto,
						gerarDebitoCobradoHelper, gerarCreditoRealizadoHelper, gerarImpostosDeduzidosContaHelper, faturamentoGrupo, faturamentoAntecipado,
						preFaturamento);

				GerarContaCategoriaHelper gerarContaCategoriaHelper = this.gerarContaCategoriaValoresZerados(conta, colecaoCategoriaOUSubcategoria,
						sistemaParametro);

				// INSERINDO CONTA_CATEGORIA NA BASE
				if (gerarContaCategoriaHelper.getColecaoContaCategoria() != null && !gerarContaCategoriaHelper.getColecaoContaCategoria().isEmpty()) {

					this.getControladorBatch().inserirColecaoObjetoParaBatch(gerarContaCategoriaHelper.getColecaoContaCategoria());
				}

				// INSERINDO CONTA_CATEGORIA_CONSUMO_FAIXA
				if (gerarContaCategoriaHelper.getColecaoContaCategoriaConsumoFaixa() != null
						&& !gerarContaCategoriaHelper.getColecaoContaCategoriaConsumoFaixa().isEmpty()) {

					this.getControladorBatch().inserirColecaoObjetoParaBatch(gerarContaCategoriaHelper.getColecaoContaCategoriaConsumoFaixa());
				}

				// INSERINDO CLIENTE_CONTA
				this.inserirClienteConta(conta, imovel);

				// INSERINDO CONTA_IMPOSTOS_DEDUZIDOS
				this.inserirContaImpostosDeduzidos(conta, gerarImpostosDeduzidosContaHelper);

				// INSERINDO DEBITO_COBRADO E DEBITO_COBRADO_CATEGORIA
				this.inserirDebitoCobrado(gerarDebitoCobradoHelper.getMapDebitosCobrados(), conta);

				// ATUALIZANDO DEBITO_A_COBRAR
				this.atualizarDebitoACobrarFaturamento(gerarDebitoCobradoHelper.getColecaoDebitoACobrar());

				// INSERINDO CREDITO_REALIZADO E CREDITO_REALIZADO_CATEGORIA
				this.inserirCreditoRealizado(gerarCreditoRealizadoHelper.getMapCreditoRealizado(), conta);

				// ATUALIZANDO CREDITO_A_REALIZAR
				this.atualizarCreditoARealizar(gerarCreditoRealizadoHelper.getColecaoCreditoARealizar());

				// -----------------------------------------------------------------------------------------------------

				// [SF0008] - Gerar Movimento De Débito Automático
				if (imovel.getIndicadorDebitoConta().equals(ConstantesSistema.SIM) && conta.getContaMotivoRevisao() == null) {
					conta.setImovel(imovel);
					conta.setFaturamentoGrupo(faturamentoGrupo);
					
					this.gerarMovimentoDebitoAutomatico(conta);
				}
			}

			Integer anoMesReferenciaResumoFaturamento = null;
			if (faturamentoAntecipado) {
				anoMesReferenciaResumoFaturamento = anoMesFaturamento;
			}

			// [SB0009] - Gerar Resumo da Simulação do Faturamento
			this.gerarResumoFaturamentoSimulacao(colecaoCategorias, helperValoresAguaEsgoto.getColecaoCalcularValoresAguaEsgotoHelper(),
					gerarDebitoCobradoHelper, gerarCreditoRealizadoHelper, colecaoResumoFaturamento, imovel, gerarAtividadeGrupoFaturamento,
					faturamentoAtivCronRota, faturamentoGrupo, anoMesReferenciaResumoFaturamento, true);
		}
	}

	/**
	 * [UC113] Faturar Grupo Faturamento
	 * 
	 * Exclui os dados do resumo da simulação do faturamento para uma rota em um
	 * determinado anoMês de referência
	 * 
	 * @author Raphael Rossiter
	 * @date 25/03/2008
	 * 
	 * @param idFaturamentoGrupo
	 * @param helper
	 * @throws ControladorException
	 */
	protected void apagarDadosGeradosResumoFaturamentoSimulacao(
			Integer idFaturamentoGrupo, ApagarDadosFaturamentoHelper helper)
			throws ControladorException {

		try {

			repositorioFaturamento.deletarResumoFaturamentoSimulacao(
					idFaturamentoGrupo, helper.getAnoMesFaturamento(), helper
							.getRota().getId());

		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso permite faturar um imóvel de um grupo de faturamento de
	 * forma antecipada.
	 * 
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/03/2007
	 * 
	 * @param anoMesFaturamento
	 * @param atividade
	 * @param sistemaParametro
	 * @param faturamentoAtivCronRota
	 * @param colecaoResumoFaturamento
	 * @param imovel
	 * @throws ControladorException
	 */
	public void faturarImovelAntecipado(Integer anoMesFaturamento,
			int atividade, SistemaParametro sistemaParametro,
			FaturamentoAtivCronRota faturamentoAtivCronRota,
			Collection colecaoResumoFaturamento, Imovel imovel,
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		/*
		 * Caso o mês de faturamento corresponda ao mês de novembro, o sistema
		 * verifica se haverá faturamento antecipado
		 */
		if (Util.obterMes(anoMesFaturamento) == ConstantesSistema.NOVEMBRO
				&& sistemaParametro.getIndicadorFaturamentoAntecipado().equals(
						ConstantesSistema.SIM)) {

			Integer anoMesFaturamentoAntecipado = Util
					.somaUmMesAnoMesReferencia(anoMesFaturamento);

			Integer idConsumoHistorico = getControladorMicromedicao()
					.pesquisarConsumoHistoricoAntecipado(imovel.getId(),
							anoMesFaturamentoAntecipado);

			// Alterado por Rômulo Aurélio
			// CRC 5036
			// Data: 28/09/2010
			// Analista: Aryed Lins
			// Motivo: Antecipar também faturas onde o
			// valor faturado é constituído apenas de serviço (valor de água e
			// esgoto = 0)
			ClienteImovel clienteImovel = getControladorCadastro()
					.pesquisarClienteResponsavelComEsferaPoderPublico(
							imovel.getId());

			if (idConsumoHistorico != null
					|| (imovel.getIndicadorDebitoConta().equals(
							Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO) && clienteImovel != null)) {

				faturarImovel(anoMesFaturamentoAntecipado, atividade,
						sistemaParametro, faturamentoAtivCronRota,
						colecaoResumoFaturamento, imovel, true,
						faturamentoGrupo);
			}

		}
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0002] - Determinar Valores para Faturamento de Água e/ou Esgoto
	 * 
	 * @author Raphael Rossiter
	 * @date 28/03/2008
	 * 
	 * @param imovel
	 * @param faturamentoGrupo
	 * @param colecaoCategoriasOUSubCategorias
	 * @return DeterminarValoresFaturamentoAguaEsgotoHelper
	 * @throws ControladorException
	 */
	public DeterminarValoresFaturamentoAguaEsgotoHelper determinarValoresFaturamentoAguaEsgoto(
			Imovel imovel, Integer anoMesFaturamento,
			Collection colecaoCategoriasOUSubCategorias,
			FaturamentoGrupo faturamentoGrupo,
			ConsumoHistorico consumoHistoricoAgua,
			ConsumoHistorico consumoHistoricoEsgoto)
			throws ControladorException {

		DeterminarValoresFaturamentoAguaEsgotoHelper helper = new DeterminarValoresFaturamentoAguaEsgotoHelper();
		
		if (consumoHistoricoAgua != null) {
			helper.setConsumoHistoricoAgua(consumoHistoricoAgua);

			if (consumoHistoricoAgua.getIndicadorFaturamento() != null) {
				helper.setIndicadorFaturamentoAgua(consumoHistoricoAgua.getIndicadorFaturamento());
			}

			if (consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null) {
				helper.setConsumoFaturadoAgua(consumoHistoricoAgua.getNumeroConsumoFaturadoMes());
			}

			if (consumoHistoricoAgua.getConsumoRateio() != null) {
				helper.setConsumoRateioAgua(consumoHistoricoAgua.getConsumoRateio());
			}

			if (consumoHistoricoAgua.getConsumoTipo() != null) {
				helper.setConsumoTipoAgua(consumoHistoricoAgua.getConsumoTipo());
			}
		}

		if (consumoHistoricoEsgoto != null) {
			helper.setConsumoHistoricoEsgoto(consumoHistoricoEsgoto);

			if (consumoHistoricoEsgoto.getIndicadorFaturamento() != null) {
				helper.setIndicadorFaturamentoEsgoto(consumoHistoricoEsgoto.getIndicadorFaturamento());
			}

			if (consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null) {
				helper.setConsumoFaturadoEsgoto(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes());
			}

			if (consumoHistoricoEsgoto.getConsumoRateio() != null) {
				helper.setConsumoRateioEsgoto(consumoHistoricoEsgoto.getConsumoRateio());
			}

			if (consumoHistoricoEsgoto.getConsumoTipo() != null) {
				helper.setConsumoTipoEsgoto(consumoHistoricoEsgoto.getConsumoTipo());
			}
		}

		int consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, null);
		helper.setConsumoMinimoLigacao(consumoMinimoLigacao);

		Integer anoMesFaturamentoAnterior = Util.subtrairMesDoAnoMes(anoMesFaturamento, 1);

		Date dataLeituraAnteriorFaturamento = obterDataLeituraAnteriorFaturarImovel(imovel, anoMesFaturamentoAnterior, faturamentoGrupo);
		helper.setDataLeituraAnterior(dataLeituraAnteriorFaturamento);
		
		Date dataLeituraAtualFaturamento = obterDataLeituraAtualFaturarImovel(imovel, anoMesFaturamento, faturamentoGrupo);
		helper.setDataLeituraAtual(dataLeituraAtualFaturamento);
		
		// CASO O IMÓVEL SEJA PARA FATURAR ÁGUA
		if (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
				.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)) {

			// MEDICAO_HISTORICO_AGUA
			MedicaoHistorico medicaoHistoricoAgua = this
					.getControladorMicromedicao()
					.pesquisarMedicaoHistoricoTipoAgua(imovel.getId(),
							anoMesFaturamento);

			if (medicaoHistoricoAgua != null) {
				helper.setDataLeituraAnterior(medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento());
				helper.setDataLeituraAtual(medicaoHistoricoAgua.getDataLeituraAtualFaturamento());
			}
		}

		// CASO O IMÓVEL SEJA PARA FATURAR ESGOTO
		if (imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao()
				.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)) {

			// MEDICAO_HISTORICO_POCO
			MedicaoHistorico medicaoHistoricoPoco = this
					.getControladorMicromedicao()
					.pesquisarMedicaoHistoricoTipoPoco(imovel.getId(),
							anoMesFaturamento);

			if (medicaoHistoricoPoco != null) {

				// DATA_LEITURA_ANTERIOR
				if (medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento() != null) {

					helper.setDataLeituraAnterior(medicaoHistoricoPoco
							.getDataLeituraAnteriorFaturamento());
				}

				// DATA_LEITURA_ATUAL
				if (medicaoHistoricoPoco.getDataLeituraAtualFaturamento() != null) {

					helper.setDataLeituraAtual(medicaoHistoricoPoco
							.getDataLeituraAtualFaturamento());
				}
			}

			// PERCENTUAL DE ESGOTO
			BigDecimal percentualEsgoto = this
					.verificarPercentualEsgotoAlternativo(imovel,
							helper.getConsumoFaturadoEsgoto());

			helper.setPercentualEsgoto(percentualEsgoto);

			// PERCENTUAL COLETA DE ESGOTO
			BigDecimal percentualColetaEsgoto = this
					.obterPercentualColetaEsgotoImovel(imovel.getId());

			helper.setPercentualColetaEsgoto(percentualColetaEsgoto);
		}

		/*
		 * Caso NÃO existe cronograma para o anoMes informado ou seja a
		 * dataLeituraAnteriorFaturamento ou a dataLeituraAtualFaturamento
		 * estaja nula
		 */
		if (dataLeituraAnteriorFaturamento == null
				|| dataLeituraAtualFaturamento == null) {

			Date[] periodoLeitura = this.gerarPeriodoLeituraFaturamento(
					dataLeituraAtualFaturamento,
					dataLeituraAnteriorFaturamento, faturamentoGrupo,
					anoMesFaturamento, anoMesFaturamentoAnterior);

			// DATA_LEITURA_ANTERIOR
			helper.setDataLeituraAnterior(periodoLeitura[0]);

			// DATA_LEITURA_ATUAL
			helper.setDataLeituraAtual(periodoLeitura[1]);
		}

		// [UC0120] - Calcular Valores de Água e/ou Esgoto
		Collection colecaoCalcularValoresAguaEsgotoHelper = calcularValoresAguaEsgoto(
				anoMesFaturamento, imovel.getLigacaoAguaSituacao().getId(),
				imovel.getLigacaoEsgotoSituacao().getId(),
				helper.getIndicadorFaturamentoAgua(),
				helper.getIndicadorFaturamentoEsgoto(),
				colecaoCategoriasOUSubCategorias,
				helper.getConsumoFaturadoAgua(),
				helper.getConsumoFaturadoEsgoto(),
				helper.getConsumoMinimoLigacao(),
				helper.getDataLeituraAnterior(), helper.getDataLeituraAtual(),
				helper.getPercentualEsgoto(),
				imovel.getConsumoTarifa().getId(), helper.getConsumoTipoAgua(),
				helper.getConsumoTipoEsgoto());

		helper.setColecaoCalcularValoresAguaEsgotoHelper(colecaoCalcularValoresAguaEsgotoHelper);

		// TOTALIZANDO OS VALORES DE ÁGUA E ESGOTO
		BigDecimal valorTotalAgua = ConstantesSistema.VALOR_ZERO;
		BigDecimal valorTotalEsgoto = ConstantesSistema.VALOR_ZERO;

		if (colecaoCalcularValoresAguaEsgotoHelper != null
				&& !colecaoCalcularValoresAguaEsgotoHelper.isEmpty()) {

			Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper
					.iterator();

			while (iteratorColecaoCalcularValoresAguaEsgotoHelper.hasNext()) {

				CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
						.next();

				/*
				 * Caso tenha valor de água faturado para categoria adiciona o
				 * valor de água ao valor total de água. Caso contrário soma
				 * zero.
				 */
				if (calcularValoresAguaEsgotoHelper
						.getValorFaturadoAguaCategoria() != null) {

					// VALOR_TOTAL_AGUA
					valorTotalAgua = valorTotalAgua
							.add(calcularValoresAguaEsgotoHelper
									.getValorFaturadoAguaCategoria());
				} else {

					// VALOR_TOTAL_AGUA
					valorTotalAgua = valorTotalAgua
							.add(ConstantesSistema.VALOR_ZERO);
				}

				/*
				 * Caso tenha valor de esgoto faturado para categoria adiciona o
				 * valor de esgoto ao valor total de esgoto. Caso contrário soma
				 * zero.
				 */
				if (calcularValoresAguaEsgotoHelper
						.getValorFaturadoEsgotoCategoria() != null) {

					// VALOR_TOTAL_ESGOTO
					valorTotalEsgoto = valorTotalEsgoto
							.add(calcularValoresAguaEsgotoHelper
									.getValorFaturadoEsgotoCategoria());
				} else {

					// VALOR_TOTAL_ESGOTO
					valorTotalEsgoto = valorTotalEsgoto
							.add(ConstantesSistema.VALOR_ZERO);
				}
			}
		}

		helper.setValorTotalAgua(valorTotalAgua);
		helper.setValorTotalEsgoto(valorTotalEsgoto);

		return helper;
	}

	private Date obterDataLeituraAnteriorFaturarImovel(Imovel imovel, Integer anoMesFaturamentoAnterior, FaturamentoGrupo faturamentoGrupo) throws ControladorException {
		
		Date dataLeituraAnterior = null;
		try {
			dataLeituraAnterior = (Date) repositorioFaturamento
					.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
							faturamentoGrupo.getId(),
							FaturamentoAtividade.EFETUAR_LEITURA,
							anoMesFaturamentoAnterior);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return dataLeituraAnterior;
	}

	private Date obterDataLeituraAtualFaturarImovel(Imovel imovel, Integer anoMesFaturamento, FaturamentoGrupo faturamentoGrupo) throws ControladorException {
		
		Date dataLeituraAtualFaturamento = null;
		try {
			dataLeituraAtualFaturamento = repositorioFaturamento
					.pesquisarDataLeituraAtualMovimentoContaPreFaturada(
							anoMesFaturamento, imovel.getId());
			
			if (dataLeituraAtualFaturamento == null || dataLeituraAtualFaturamento.equals("")) {
				dataLeituraAtualFaturamento = (Date) repositorioFaturamento
						.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
								faturamentoGrupo.getId(),
								FaturamentoAtividade.EFETUAR_LEITURA,
								anoMesFaturamento);
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return dataLeituraAtualFaturamento;
	}


	/**
	 * Verifica se o imóvel tem um percentual de esgoto alternativo
	 * 
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Viviane Souza, Raphael Rossiter
	 * @date 27/03/2008
	 * 
	 * @param imovel
	 * @param consumoFaturadoEsgoto
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	public BigDecimal verificarPercentualEsgotoAlternativo(Imovel imovel,
			Integer consumoFaturadoEsgoto) throws ControladorException {

		BigDecimal percentualEsgoto = ConstantesSistema.VALOR_ZERO;

		/*
		 * CASO O IMÓVEL SEJA PARA FATURAR ESGOTO Essa verificação se faz
		 * necessária para o pré-faturamento.
		 */
		if (imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao()
				.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)) {

			// Recupera o percentual de esgoto do imóvel.
			percentualEsgoto = this.obterPercentualLigacaoEsgotoImovel(imovel
					.getId());

			// CASO O IMÓVEL SEJA PARA FATURAR ÁGUA
			if (imovel.getLigacaoAguaSituacao()
					.getIndicadorFaturamentoSituacao()
					.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
					&& consumoFaturadoEsgoto != null) {

				Object[] ligacaoEsgotoArray = null;
				BigDecimal percentualEsgotoAlternativo = null;
				Integer numeroConsumoPercentualAlternativo = 0;

				ligacaoEsgotoArray = this
						.obterPercentualAlternativoLigacaoEsgotoImovel(imovel
								.getId());

				if (ligacaoEsgotoArray != null) {
					if (ligacaoEsgotoArray[0] != null) {
						percentualEsgotoAlternativo = (BigDecimal) ligacaoEsgotoArray[0];
					}
					if (ligacaoEsgotoArray[1] != null) {
						numeroConsumoPercentualAlternativo = (Integer) ligacaoEsgotoArray[1];
					}
				}

				// Caso o percentual alternativo de esgoto seja diferente de
				// nulo
				if (percentualEsgotoAlternativo != null) {

					int qtdeEconomia = getControladorImovel()
							.obterQuantidadeEconomias(imovel);

					int consumoPorEconomia = Util.dividirArredondarResultado(
							consumoFaturadoEsgoto, qtdeEconomia);

					// verificar se o consumo por economia eh
					// menor ou igual ao consumo do percentual alternativo
					if (consumoPorEconomia <= numeroConsumoPercentualAlternativo
							.intValue()) {

						// enviar como percentual de esgoto o menor valor entre
						// percentual e percentualAlternativo
						if (percentualEsgotoAlternativo
								.compareTo(percentualEsgoto) == -1) {
							percentualEsgoto = percentualEsgotoAlternativo;
						}
					}

				}
			}
		}

		return percentualEsgoto;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0004] - Gerar os Débitos Cobrados
	 * 
	 * @author Raphael Rossiter
	 * @date 28/03/2008
	 * 
	 * @param imovel
	 * @param anoMesFaturamento
	 * @param gerarAtividadeGrupoFaturamento
	 * @return GerarDebitoCobradoHelper
	 * @throws ControladorException
	 */
	public GerarDebitoCobradoHelper gerarDebitoCobrado(Imovel imovel,
			Integer anoMesFaturamento, SistemaParametro sistemaParametro,
			boolean gerarAtividadeGrupoFaturamento) throws ControladorException {

		GerarDebitoCobradoHelper helper = new GerarDebitoCobradoHelper();

		// Pesquisa os débitos a cobrar do imóvel.
		Collection colecaoDebitosACobrar = this
				.obterDebitoACobrarImovel(imovel.getId(),
						DebitoCreditoSituacao.NORMAL, anoMesFaturamento);

		BigDecimal valorTotalDebitos = ConstantesSistema.VALOR_ZERO;
		List colecaoDebitosACobrarUpdate = new ArrayList();
		Collection colecaoDebitosCobradoCategoria = null;

		// Cria o map para armazenar os débitos cobrados junto com os débitos
		// cobrados por categoria.
		Map<DebitoCobrado, Collection<DebitoCobradoCategoria>> mapDebitosCobrados = null;
		// Cria o map para armazenar os débitos a cobradar junto com os valores
		// por tipo débito.
		Map<DebitoTipo, BigDecimal> mapValoresPorTipoDebito = null;

		/*
		 * Caso o imóvel tenha débitos a cobrar gera os débitos cobrados
		 */
		if (colecaoDebitosACobrar != null && !colecaoDebitosACobrar.isEmpty()) {

			Iterator iteratorColecaoDebitosACobrar = colecaoDebitosACobrar
					.iterator();

			mapDebitosCobrados = new HashMap();
			mapValoresPorTipoDebito = new HashMap<DebitoTipo, BigDecimal>();
			DebitoACobrar debitoACobrar = null;
			BigDecimal valorPrestacao = null;

			// LAÇO PARA GERAR OS DÉBITOS COBRADOS E OS DÉBITOS COBRADOS POR
			// CATEGORIA
			while (iteratorColecaoDebitosACobrar.hasNext()) {

				debitoACobrar = (DebitoACobrar) iteratorColecaoDebitosACobrar
						.next();

				// Calcula o valor da prestação
				valorPrestacao = debitoACobrar.getValorDebito()
						.divide(new BigDecimal(
								debitoACobrar.getNumeroPrestacaoDebito()), 2,
								BigDecimal.ROUND_DOWN);

				/*
				 * Alterado por Vivianne Sousa em 20/12/2007 - Analista: Adriano
				 * criação do bonus para parcelamento com RD especial
				 */
				Short numeroParcelaBonus = 0;
				if (debitoACobrar.getNumeroParcelaBonus() != null) {
					numeroParcelaBonus = debitoACobrar.getNumeroParcelaBonus();
				}

				// Caso seja a última prestação
				if (debitoACobrar.getNumeroPrestacaoCobradas() == ((debitoACobrar
						.getNumeroPrestacaoDebito() - numeroParcelaBonus) - 1)) {

					// Obtém o número de prestação débito
					BigDecimal numeroPrestacaoDebito = new BigDecimal(
							debitoACobrar.getNumeroPrestacaoDebito());

					// Mutiplica o (valor da prestação * número da prestação
					// debito) - numeroParcelaBonus

					BigDecimal multiplicacao = valorPrestacao.multiply(
							numeroPrestacaoDebito).setScale(2);

					// Subtrai o valor do débito pelo resultado da multiplicação
					BigDecimal parte1 = debitoACobrar.getValorDebito()
							.subtract(multiplicacao).setScale(2);

					// Calcula o valor da prestação
					valorPrestacao = valorPrestacao.add(parte1).setScale(2);
				}

				// Acumula o valor da prestação no valor total dos debitos
				valorTotalDebitos = valorTotalDebitos.add(valorPrestacao);

				// Se a atividade é faturar grupo de faturamento gera os débitos
				// cobrados
				if (gerarAtividadeGrupoFaturamento) {

					// GERANDO O DÉBITO COBRADO
					// -----------------------------------------------------------------------------------------
					DebitoCobrado debitoCobrado = new DebitoCobrado();

					DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
					debitoACobrarGeral.setId(debitoACobrar.getId());

					debitoCobrado.setDebitoACobrarGeral(debitoACobrarGeral);
					debitoCobrado.setDebitoTipo(debitoACobrar.getDebitoTipo());
					debitoCobrado.setUltimaAlteracao(new Date());
					debitoCobrado.setLancamentoItemContabil(debitoACobrar
							.getLancamentoItemContabil());
					debitoCobrado.setLocalidade(debitoACobrar.getLocalidade());
					debitoCobrado.setQuadra(debitoACobrar.getQuadra());
					debitoCobrado.setCodigoSetorComercial(debitoACobrar
							.getCodigoSetorComercial());
					debitoCobrado.setNumeroQuadra(debitoACobrar
							.getNumeroQuadra());
					debitoCobrado.setNumeroLote(debitoACobrar.getNumeroLote());
					debitoCobrado.setNumeroSubLote(debitoACobrar
							.getNumeroSubLote());
					debitoCobrado.setAnoMesReferenciaDebito(debitoACobrar
							.getAnoMesReferenciaDebito());
					debitoCobrado.setAnoMesCobrancaDebito(debitoACobrar
							.getAnoMesCobrancaDebito());
					debitoCobrado.setValorPrestacao(valorPrestacao);
					debitoCobrado.setNumeroPrestacao(debitoACobrar
							.getNumeroPrestacaoDebito());
					debitoCobrado.setFinanciamentoTipo(debitoACobrar
							.getFinanciamentoTipo());

					debitoCobrado.setNumeroParcelaBonus(numeroParcelaBonus);

					// Incrementa o nº de prestação cobradas
					int numeroPrestacaoCobradas = debitoACobrar
							.getNumeroPrestacaoCobradas() + 1;
					debitoCobrado
							.setNumeroPrestacaoDebito((short) numeroPrestacaoCobradas);
					// ----------------------------------------------------------------------------------------

					// Pesquisa os debitos a cobrar categoria do debito a cobrar
					Collection colecaoDebitoACobrarCategoria = this
							.obterDebitoACobrarCategoria(debitoACobrar.getId());

					// Carregando as categorias do debitoACobrarCategoria
					Iterator colecaoDebitoACobrarCategoriaIterator = colecaoDebitoACobrarCategoria
							.iterator();

					Collection colecaoCategoriasObterValor = new ArrayList();

					while (colecaoDebitoACobrarCategoriaIterator.hasNext()) {

						DebitoACobrarCategoria debitoACobrarCategoria = (DebitoACobrarCategoria) colecaoDebitoACobrarCategoriaIterator
								.next();

						Categoria categoria = new Categoria();
						categoria.setId(debitoACobrarCategoria.getCategoria()
								.getId());
						categoria
								.setQuantidadeEconomiasCategoria(debitoACobrarCategoria
										.getQuantidadeEconomia());

						colecaoCategoriasObterValor.add(categoria);
					}

					// [UC0185] Obter Valor por Categoria
					Collection colecaoCategoriasCalculadasValor = getControladorImovel()
							.obterValorPorCategoria(
									colecaoCategoriasObterValor, valorPrestacao);

					// GERANDO O DÉBITO COBRADO CATEGORIA
					// -------------------------------------------------------------------------------------------
					DebitoCobradoCategoria debitoCobradoCategoria = null;
					DebitoCobradoCategoriaPK debitoCobradoCategoriaPK = null;

					Iterator colecaoCategoriasCalculadasValorIterator = colecaoCategoriasCalculadasValor
							.iterator();
					Iterator colecaoCategoriasObterValorIterator = colecaoCategoriasObterValor
							.iterator();

					colecaoDebitosCobradoCategoria = new ArrayList();

					// LAÇO PARA GERAR OS DÉBITOS COBRADOS POR CATEGORIA
					while (colecaoCategoriasCalculadasValorIterator.hasNext()
							&& colecaoCategoriasObterValorIterator.hasNext()) {

						// Cria o débito a cobrar por categoria e adiciona a
						// coleção.
						debitoCobradoCategoria = new DebitoCobradoCategoria();

						// VALOR POR CATEGORIA
						BigDecimal valorPorCategoria = (BigDecimal) colecaoCategoriasCalculadasValorIterator
								.next();

						// CATEGORIA
						Categoria categoria = (Categoria) colecaoCategoriasObterValorIterator
								.next();

						debitoCobradoCategoria
								.setValorCategoria(valorPorCategoria);

						debitoCobradoCategoriaPK = new DebitoCobradoCategoriaPK();
						debitoCobradoCategoriaPK.setCategoriaId(categoria
								.getId());
						debitoCobradoCategoriaPK
								.setDebitoCobradoId(debitoCobrado.getId());

						debitoCobradoCategoria
								.setComp_id(debitoCobradoCategoriaPK);
						debitoCobradoCategoria.setDebitoCobrado(debitoCobrado);
						debitoCobradoCategoria.setCategoria(categoria);
						debitoCobradoCategoria.setQuantidadeEconomia(categoria
								.getQuantidadeEconomiasCategoria());

						// INSERINDO O debitoCobradoCategoria NA COLEÇÃO DE
						// RETORNO
						colecaoDebitosCobradoCategoria
								.add(debitoCobradoCategoria);
					}

					/*
					 * Adiciona no map o relacionamento entre o débito a cobrar
					 * e os débitos a cobrar por categoria.
					 */
					mapDebitosCobrados.put(debitoCobrado,
							colecaoDebitosCobradoCategoria);

					/*
					 * Adiciona no map o relacionamento entre o débito cobrado e
					 * o auto de infração
					 */

					/**
					 * Alteração feita por Bruno Barros dia 08 de Janeiro de
					 * 2009 Solicitante: Nelson Carvalho Descrição da
					 * solicitação: Não mais gerar o vinculo de debito cobrado a
					 * um auto de infração quando o débito a cobrar de origem
					 * estiver vinculado ao mesmo.
					 */

					/*
					 * Atualiza o nº de prestações cobradas do débito a cobrar e
					 * adicona o objeto a coleção de débitos a cobrar que vai
					 * ser atualizados.
					 */
					debitoACobrar.setNumeroPrestacaoCobradas(new Integer(
							debitoACobrar.getNumeroPrestacaoCobradas() + 1)
							.shortValue());

					// anoMes da prestação será o anaMes de referência da conta
					debitoACobrar
							.setAnoMesReferenciaPrestacao(anoMesFaturamento);

					// INSERINDO O debitoACobrar NA COLEÇÃO DE RETORNO
					colecaoDebitosACobrarUpdate.add(debitoACobrar);

				}// fim se atividade grupo faturamento

				/*
				 * Desenvolvedor: Hugo Amorim Analista:Jeferson Pedrosa Data:
				 * 29/07/2010
				 * 
				 * [CRC4457] Colecionar os valores que compõem os totais de
				 * débito e créditos nas tabelas
				 * resumo_faturamento_simulado_detalhe_debito e
				 * resumo_faturamento_simulado_detalhe_credito respectivamente.
				 */
				// Verifica se debito a cobrar já foi inserido, caso sim
				// acumala os valores.
				if (mapValoresPorTipoDebito.containsKey(debitoACobrar
						.getDebitoTipo())) {
					BigDecimal valor = mapValoresPorTipoDebito
							.get(debitoACobrar.getDebitoTipo());
					mapValoresPorTipoDebito.put(debitoACobrar.getDebitoTipo(),
							Util.somaBigDecimal(valor, valorPrestacao));
				}
				// Caso contrario inseri na coleção
				// primeiro registro do tipo.
				else {
					mapValoresPorTipoDebito.put(debitoACobrar.getDebitoTipo(),
							valorPrestacao);
				}
			}// fim do laço de debito a cobrar
		}// fim gerar debitos cobrados

		helper.setColecaoDebitoACobrar(colecaoDebitosACobrarUpdate);
		helper.setMapDebitosCobrados(mapDebitosCobrados);
		helper.setValorTotalDebito(valorTotalDebitos);
		helper.setMapValoresPorTipoDebito(mapValoresPorTipoDebito);

		return helper;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0005] - Gerar os Créditos Realizados
	 * 
	 * @author Raphael Rossiter
	 * @date 28/03/2008
	 * 
	 * @param imovel
	 * @param faturamentoGrupo
	 * @param helperValoresAguaEsgoto
	 * @param valorTotalDebitos
	 * @param gerarAtividadeGrupoFaturamento
	 * @return GerarCreditoRealizadoHelper
	 * @throws ControladorException
	 */
		
	public GerarCreditoRealizadoHelper gerarCreditoRealizado(Imovel imovel,
			Integer anoMesFaturamentoGrupo,
			DeterminarValoresFaturamentoAguaEsgotoHelper helperValoresAguaEsgoto,
			BigDecimal valorTotalDebitos,
			boolean gerarAtividadeGrupoFaturamento, boolean preFaturamento) throws ControladorException {

		GerarCreditoRealizadoHelper helper = new GerarCreditoRealizadoHelper();

		Collection colecaoCreditosARealizar = obterTodosCreditosARealizarImovel(imovel, anoMesFaturamentoGrupo, preFaturamento);

		Collection colecaoCreditosARealizarUpdate = new ArrayList();

		Map<CreditoRealizado, Collection<CreditoRealizadoCategoria>> mapCreditoRealizado = null;
		Map<CreditoTipo, BigDecimal> mapValoresPorTipoCredito = null;
		
		BigDecimal valorTotalCreditos = BigDecimal.ZERO;

		if (colecaoCreditosARealizar != null && !colecaoCreditosARealizar.isEmpty()) {

			mapCreditoRealizado = new HashMap();
			mapValoresPorTipoCredito = new HashMap<CreditoTipo, BigDecimal>();

			AtualizacaoCreditoARealizarHelper atualizacaoHelper = new FaturamentoUtil().atualizarCreditosARealizar(anoMesFaturamentoGrupo
			        , colecaoCreditosARealizar
			        , helperValoresAguaEsgoto.getValorTotalAgua()
			        , helperValoresAguaEsgoto.getValorTotalEsgoto()
			        , valorTotalDebitos, preFaturamento);

			for(ItemCreditoARealizar itemCredito : atualizacaoHelper.getCreditos()){
			    CreditoARealizar creditoARealizar = itemCredito.getCreditoARelizar();
			    
				if (gerarAtividadeGrupoFaturamento) {

					CreditoRealizado creditoRealizado = criarCreditoRealizado(itemCredito);
					Collection colecaoCreditosRealizadoCategoria = criarCreditoRealizadoCategoria(creditoRealizado, itemCredito);

					mapCreditoRealizado.put(creditoRealizado, colecaoCreditosRealizadoCategoria);

					colecaoCreditosARealizarUpdate.add(creditoARealizar);
				}

				if (mapValoresPorTipoCredito.containsKey(creditoARealizar.getCreditoTipo())) {
					BigDecimal valor = mapValoresPorTipoCredito.get(creditoARealizar.getCreditoTipo());
					mapValoresPorTipoCredito.put(creditoARealizar.getCreditoTipo(), Util.somaBigDecimal(valor, itemCredito.getCreditoCalculado()));
				} else {
					mapValoresPorTipoCredito.put(creditoARealizar.getCreditoTipo(), itemCredito.getCreditoCalculado());
				}
			}
			valorTotalCreditos = atualizacaoHelper.getValorTotalCreditos();
		}

		helper.setValorTotalCredito(valorTotalCreditos);
		helper.setColecaoCreditoARealizar(colecaoCreditosARealizarUpdate);
		helper.setMapCreditoRealizado(mapCreditoRealizado);
		helper.setMapValoresPorTipoCredito(mapValoresPorTipoCredito);

		return helper;
	}

	private Collection obterTodosCreditosARealizarImovel(Imovel imovel, Integer anoMesFaturamentoGrupo, boolean preFaturamento) throws ControladorException {
		Collection colecaoCreditosARealizar = this.obterCreditoARealizarImovelPorSituacao(imovel.getId(), DebitoCreditoSituacao.NORMAL, anoMesFaturamentoGrupo, preFaturamento);
		
		if (preFaturamento) {
			colecaoCreditosARealizar = obterCreditosARealizarPFdoImovel(imovel, anoMesFaturamentoGrupo, colecaoCreditosARealizar);
		}
		return colecaoCreditosARealizar;
	}

	private Collection obterCreditosARealizarPFdoImovel(Imovel imovel, Integer anoMesFaturamento, Collection colecaoCreditosARealizar)
			throws ControladorException {
		Collection colecaoCreditosARealizarPF = this.obterCreditoARealizarImovelPorSituacao(imovel.getId(), DebitoCreditoSituacao.PRE_FATURADA, anoMesFaturamento, true);
		
		if (colecaoCreditosARealizarPF != null && !colecaoCreditosARealizarPF.isEmpty()) {
			if (colecaoCreditosARealizar == null) {
				colecaoCreditosARealizar = new ArrayList();
			}
			colecaoCreditosARealizar.addAll(colecaoCreditosARealizarPF);
		}
		return colecaoCreditosARealizar;
	}

	private Collection criarCreditoRealizadoCategoria(CreditoRealizado creditoRealizado, ItemCreditoARealizar itemCredito) 
			throws ControladorException {
		CreditoRealizadoCategoria creditoRealizadoCategoria = null;
		
		Collection colecaoCategorias = obterCreditoARealizarCategoria(itemCredito.getCreditoARelizar());

		Collection colecaoCreditosRealizadoCategoria = new ArrayList();
		Collection colecaoCategoriasCalculadasValor = getControladorImovel().obterValorPorCategoria(colecaoCategorias, itemCredito.getCreditoCalculado());
		Iterator colecaoCategoriasCalculadasValorIterator = colecaoCategoriasCalculadasValor.iterator();
		
		
		Iterator colecaoCategoriasObterValorIterator = colecaoCategorias.iterator();
		
		while (colecaoCategoriasCalculadasValorIterator.hasNext() && colecaoCategoriasObterValorIterator.hasNext()) {
			BigDecimal valorPorCategoria = (BigDecimal) colecaoCategoriasCalculadasValorIterator.next();
			Categoria categoria = (Categoria) colecaoCategoriasObterValorIterator.next();

			// Cria o crédito a ralizar por categoria
			creditoRealizadoCategoria = new CreditoRealizadoCategoria();
			CreditoRealizadoCategoriaPK creditoRealizadoCategoriaPk = new CreditoRealizadoCategoriaPK();
			creditoRealizadoCategoriaPk.setCategoria(categoria);
			creditoRealizadoCategoriaPk.setCreditoRealizado(creditoRealizado);
			creditoRealizadoCategoria.setComp_id(creditoRealizadoCategoriaPk);
			creditoRealizadoCategoria.setValorCategoria(valorPorCategoria);
			creditoRealizadoCategoria.setCreditoRealizado(creditoRealizado);
			creditoRealizadoCategoria.setCategoria(categoria);
			creditoRealizadoCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
			colecaoCreditosRealizadoCategoria.add(creditoRealizadoCategoria);
		}
		
		if (colecaoCategoriasCalculadasValor != null) {
			colecaoCategoriasCalculadasValor.clear();
			colecaoCategoriasCalculadasValor = null;

		}
		
		return colecaoCreditosRealizadoCategoria;
	}

	private Collection obterCreditoARealizarCategoria(CreditoARealizar creditoARealizar) throws ControladorException {
		Collection colecaoCategorias = new ArrayList();
		
		CreditoARealizarCategoria creditoARealizarCategoria = null;
		
		Collection colecaoCreditoARealizarCategoria = this.obterCreditoRealizarCategoria(creditoARealizar.getId());
		Iterator colecaoCreditoARealizarCategoriaIterator = colecaoCreditoARealizarCategoria.iterator();

		while (colecaoCreditoARealizarCategoriaIterator.hasNext()) {
			creditoARealizarCategoria = (CreditoARealizarCategoria) colecaoCreditoARealizarCategoriaIterator.next();
			Categoria categoria = new Categoria();
			categoria.setId(creditoARealizarCategoria.getCategoria().getId());
			categoria.setQuantidadeEconomiasCategoria(creditoARealizarCategoria.getQuantidadeEconomia());
			colecaoCategorias.add(categoria);
		}
		return colecaoCategorias;
	}

	private CreditoRealizado criarCreditoRealizado(ItemCreditoARealizar itemCreditoARealizar) {
		
		CreditoARealizar creditoARealizar = itemCreditoARealizar.getCreditoARelizar();
		
		CreditoRealizado creditoRealizado = new CreditoRealizado();
		
		creditoRealizado.setCreditoTipo(creditoARealizar.getCreditoTipo());
		creditoRealizado.setCreditoRealizado(creditoARealizar.getGeracaoCredito());
		creditoRealizado.setLancamentoItemContabil(creditoARealizar.getLancamentoItemContabil());
		creditoRealizado.setLocalidade(creditoARealizar.getLocalidade());
		creditoRealizado.setQuadra(creditoARealizar.getQuadra());
		creditoRealizado.setCodigoSetorComercial(creditoARealizar.getCodigoSetorComercial());
		creditoRealizado.setNumeroQuadra(creditoARealizar.getNumeroQuadra());
		creditoRealizado.setNumeroLote(creditoARealizar.getNumeroLote());
		creditoRealizado.setNumeroSubLote(creditoARealizar.getNumeroSubLote());
		creditoRealizado.setAnoMesReferenciaCredito(creditoARealizar.getAnoMesReferenciaCredito());
		creditoRealizado.setAnoMesCobrancaCredito(creditoARealizar.getAnoMesCobrancaCredito());
		creditoRealizado.setValorCredito(itemCreditoARealizar.getCreditoCalculado());
		creditoRealizado.setCreditoOrigem(creditoARealizar.getCreditoOrigem());
		creditoRealizado.setNumeroPrestacao(creditoARealizar.getNumeroPrestacaoCredito());
		creditoRealizado.setNumeroParcelaBonus(creditoARealizar.numeroParcelaBonus());
		creditoRealizado.setNumeroPrestacaoCredito(creditoARealizar.getNumeroPrestacaoRealizada());
		creditoRealizado.setCreditoARealizarGeral(creditoARealizar.getCreditoARealizarGeral());
		
		return creditoRealizado;
	}

	public Conta gerarConta(
			Imovel imovel,
			Integer anoMesFaturamento,
			SistemaParametro sistemaParametro,
			FaturamentoAtivCronRota faturamentoAtivCronRota,
			DeterminarValoresFaturamentoAguaEsgotoHelper helperValoresAguaEsgoto,
			GerarDebitoCobradoHelper helperDebito,
			GerarCreditoRealizadoHelper helperCredito,
			GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper,
			FaturamentoGrupo faturamentoGrupo, boolean faturamentoAntecipado,
			boolean preFaturamento) throws ControladorException {

		// CONTA GERAL
		ContaGeral contaGeral = new ContaGeral();
		contaGeral.setIndicadorHistorico(ConstantesSistema.NAO);
		contaGeral.setUltimaAlteracao(new Date());

		// INSERINDO CONTA_GERAL NA BASE
		Integer idContaGeral = (Integer) getControladorUtil().inserir(contaGeral);
		contaGeral.setId(idContaGeral);

		// CONTA
		Conta conta = new Conta();
		conta.setImovel(imovel);
		conta.setReferencia(anoMesFaturamento);
		conta.setLigacaoAguaSituacao(imovel.getLigacaoAguaSituacao());
		conta.setLigacaoEsgotoSituacao(imovel.getLigacaoEsgotoSituacao());
		conta.setMotivoNaoEntregaDocumento(null);
		conta.setLocalidade(imovel.getLocalidade());
		conta.setQuadraConta(imovel.getQuadra());
		conta.setSubLote(imovel.getSubLote());
		conta.setLote(imovel.getLote());
		conta.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
		conta.setQuadra(imovel.getQuadra().getNumeroQuadra());
		conta.setDigitoVerificadorConta(new Short(String.valueOf(Util.calculoRepresentacaoNumericaCodigoBarrasModulo10(anoMesFaturamento))));
		conta.setIndicadorCobrancaMulta((short) 2);

		if (faturamentoAntecipado) {
			conta.setDataVencimentoConta(this.determinarVencimentoContaAntecipado(imovel, anoMesFaturamento));
		} else {
			conta.setDataVencimentoConta(this.determinarVencimentoConta(imovel, faturamentoAtivCronRota, sistemaParametro, anoMesFaturamento));
		}

		conta.setDataVencimentoOriginal(conta.getDataVencimentoConta());

		if (helperValoresAguaEsgoto.getIndicadorFaturamentoAgua() != null && helperValoresAguaEsgoto.getIndicadorFaturamentoAgua().equals(ConsumoHistorico.FATURAR_AGUA)) {
			conta.setConsumoAgua(helperValoresAguaEsgoto.getConsumoFaturadoAgua());
			conta.setConsumoRateioAgua(helperValoresAguaEsgoto.getConsumoRateioAgua());
		} else {
			conta.setConsumoAgua(0);
			conta.setConsumoRateioAgua(0);
		}

		if (helperValoresAguaEsgoto.getIndicadorFaturamentoEsgoto() != null && helperValoresAguaEsgoto.getIndicadorFaturamentoEsgoto().equals(ConsumoHistorico.FATURAR_ESGOTO)) {
			conta.setConsumoEsgoto(helperValoresAguaEsgoto.getConsumoFaturadoEsgoto());
			conta.setConsumoRateioEsgoto(helperValoresAguaEsgoto.getConsumoRateioEsgoto());
		} else {
			conta.setConsumoEsgoto(0);
			conta.setConsumoRateioEsgoto(0);
		}

		try {
			if (!preFaturamento && imovel.isImovelCondominio()) {
				BigDecimal[] valoresRateioAguaEsgotoImovel = this.calcularValorRateioImovel(imovel, faturamentoGrupo);
				
				BigDecimal valorRateioAgua = valoresRateioAguaEsgotoImovel[0];
				BigDecimal valorFinalAgua = helperValoresAguaEsgoto.getValorTotalAgua().add(valorRateioAgua);

				helperValoresAguaEsgoto.setValorTotalAgua(valorFinalAgua);
				conta.setValorRateioAgua(valorRateioAgua);

				if (imovel.getImovelCondominio().getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)) {
					BigDecimal valorRateioEsgoto = valoresRateioAguaEsgotoImovel[1];
					BigDecimal valorFinalEsgoto = helperValoresAguaEsgoto.getValorTotalEsgoto().add(valorRateioEsgoto);

					helperValoresAguaEsgoto.setValorTotalEsgoto(valorFinalEsgoto);
					conta.setValorRateioEsgoto(valorRateioEsgoto);
				}
			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		Date dataValidadeConta = Util.adcionarOuSubtrairMesesAData(conta.getDataVencimentoConta(), sistemaParametro.getNumeroMesesValidadeConta(), 0);

		int mesDataValidadeConta = Util.getMes(dataValidadeConta);
		int anoDataValidadeConta = Util.getAno(dataValidadeConta);

		dataValidadeConta = Util.criarData(Integer.parseInt(Util.obterUltimoDiaMes(mesDataValidadeConta, anoDataValidadeConta)), mesDataValidadeConta, anoDataValidadeConta);

		conta.setDataValidadeConta(dataValidadeConta);
		conta.setReferenciaContabil(anoMesFaturamento);
		conta.setIndicadorAlteracaoVencimento((short) 2);

		conta.setValorAgua(helperValoresAguaEsgoto.getValorTotalAgua());
		conta.setValorEsgoto(helperValoresAguaEsgoto.getValorTotalEsgoto());
		conta.setValorCreditos(helperCredito.getValorTotalCredito());
		conta.setDebitos(helperDebito.getValorTotalDebito());

		if (gerarImpostosDeduzidosContaHelper.getValorTotalImposto() != null) {
			conta.setValorImposto(gerarImpostosDeduzidosContaHelper.getValorTotalImposto());
		} else {
			conta.setValorImposto(ConstantesSistema.VALOR_ZERO);
		}

		conta.setPercentualEsgoto(helperValoresAguaEsgoto.getPercentualEsgoto());
		conta.setPercentualColeta(helperValoresAguaEsgoto.getPercentualColetaEsgoto());
		conta.setDataInclusao(null);

		conta.setContaMotivoCancelamento(null);
		conta.setContaMotivoRetificacao(null);
		conta.setContaMotivoInclusao(null);
		conta.setFuncionarioEntrega(null);

		conta.setDataRetificacao(null);
		conta.setDataCancelamento(null);
		conta.setDataEmissao(new Date());
		conta.setReferenciaBaixaContabil(null);

		conta.setFaturamentoTipo(imovel.getFaturamentoTipo());
		conta.setConsumoTarifa(imovel.getConsumoTarifa());
		conta.setRegistroAtendimento(null);
		conta.setImovelPerfil(imovel.getImovelPerfil());
		conta.setIndicadorDebitoConta(imovel.getIndicadorDebitoConta());

		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		ContaMotivoRevisao contaMotivoRevisao = null;

		if (preFaturamento) {
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.PRE_FATURADA);
		} else {
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
		}

		conta.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

		if (contaMotivoRevisao != null) {
			conta.setDataRevisao(new Date());
		}

		conta.setUltimaAlteracao(new Date());
		conta.setContaGeral(contaGeral);
		conta.setId(contaGeral.getId());
		conta.setFaturamentoGrupo(faturamentoGrupo);
		conta.setRota(faturamentoAtivCronRota.getRota());

		Object[] leiturasAnteriorEAtual = getControladorMicromedicao().obterLeituraAnteriorEAtualFaturamentoMedicaoHistorico(imovel.getId(), anoMesFaturamento);

		if (leiturasAnteriorEAtual != null) {
			Integer leituraAnteriorFaturamento = null;
			Integer leituraAtualFaturamento = null;

			if (leiturasAnteriorEAtual[0] != null) {
				leituraAnteriorFaturamento = (Integer) leiturasAnteriorEAtual[0];
			}
			if (leiturasAnteriorEAtual[1] != null) {
				leituraAtualFaturamento = (Integer) leiturasAnteriorEAtual[1];
			}

			conta.setNumeroLeituraAnterior(leituraAnteriorFaturamento);
			conta.setNumeroLeituraAtual(leituraAtualFaturamento);
		}

		conta.setNumeroBoleto(this.verificarGeracaoBoleto(sistemaParametro, conta));

		this.getControladorUtil().inserir(conta);

		return conta;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 31/03/2008
	 * 
	 * @param conta
	 * @param faturamentoGrupo
	 * @param imovel
	 * @param rota
	 * @return ContaImpressao
	 * @throws ControladorException
	 */
	public ContaImpressao gerarContaImpressao(Conta conta,
			FaturamentoGrupo faturamentoGrupo, Imovel imovel, Rota rota)
			throws ControladorException {

		ContaImpressao contaImpressao = new ContaImpressao();

		contaImpressao.setContaGeral(conta.getContaGeral());
		contaImpressao.setId(conta.getContaGeral().getId());
		contaImpressao.setReferenciaConta(conta.getReferencia());
		contaImpressao.setFaturamentoGrupo(faturamentoGrupo);
		contaImpressao.setIndicadorImpressao(ConstantesSistema.NAO);
		contaImpressao.setUltimaAlteracao(new Date());

		Object idClienteResponsavel = null;

		if (conta.getContaMotivoRevisao() == null
				&& imovel.getImovelContaEnvio().getId()
						.equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL)
				|| imovel
						.getImovelContaEnvio()
						.getId()
						.equals(ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL)) {

			try {

				idClienteResponsavel = repositorioFaturamento
						.pesquisarClienteResponsavel(imovel.getId());

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			if (idClienteResponsavel != null) {
				Cliente cliente = new Cliente();
				cliente.setId((Integer) idClienteResponsavel);

				contaImpressao.setClienteResponsavel(cliente);
			}

		}

		contaImpressao.setContaTipo(this.obterContaTipoParaContaImpressao(
				conta, (Integer) idClienteResponsavel, imovel));

		if (idClienteResponsavel == null) {

			Integer idEmpresaContaImpressao = null;

			try {

				idEmpresaContaImpressao = repositorioMicromedicao
						.obterIdEmpresaPorRota(rota);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			if (idEmpresaContaImpressao != null) {
				Empresa empresaContaImpressao = new Empresa();
				empresaContaImpressao.setId(idEmpresaContaImpressao);

				contaImpressao.setEmpresa(empresaContaImpressao);
			}
		}

		contaImpressao.setValorConta(conta.getValorTotalContaBigDecimal());

		// INSERINDO CONTA_IMPRESSAO NA BASE
		getControladorUtil().inserir(contaImpressao);

		return contaImpressao;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 31/03/2008
	 * 
	 * @param consumoHistoricoAgua
	 * @return ContaMotivoRevisao
	 * @throws ControladorException
	 */
	public ContaMotivoRevisao determinarContaMotivoRevisao(
			ConsumoHistorico consumoHistoricoAgua) throws ControladorException {

		return null;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2008
	 * 
	 * @param conta
	 * @param colecaoCategorias
	 * @param colecaoCalcularValoresAguaEsgotoHelper
	 * @return GerarContaCategoriaHelper
	 * @throws ControladorException
	 */
	public GerarContaCategoriaHelper gerarContaCategoria(Conta conta,
			Collection colecaoCategoriaOUSubcategoria,
			Collection colecaoCalcularValoresAguaEsgotoHelper,
			SistemaParametro sistemaParametro) throws ControladorException {

		GerarContaCategoriaHelper helper = new GerarContaCategoriaHelper();

		// Verificando se a empresa fatura por CATEGORIA ou SUBCATEGORIA
		if (sistemaParametro.getIndicadorTarifaCategoria().equals(
				SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {

			// GERANDO POR CATEGORIA
			helper = this.gerarContaCategoriaPorCategoria(conta,
					colecaoCategoriaOUSubcategoria,
					colecaoCalcularValoresAguaEsgotoHelper);
		} else {

			// GERANDO POR SUBCATEGORIA
			helper = this.gerarContaCategoriaPorSubcategoria(conta,
					colecaoCategoriaOUSubcategoria,
					colecaoCalcularValoresAguaEsgotoHelper);
		}

		return helper;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2008
	 * 
	 * @param conta
	 * @param colecaoCategorias
	 * @param colecaoCalcularValoresAguaEsgotoHelper
	 * @return GerarContaCategoriaHelper
	 * @throws ControladorException
	 */
	public GerarContaCategoriaHelper gerarContaCategoriaPorCategoria(
			Conta conta, Collection colecaoCategorias,
			Collection colecaoCalcularValoresAguaEsgotoHelper)
			throws ControladorException {

		GerarContaCategoriaHelper helper = new GerarContaCategoriaHelper();

		Collection colecaoContaCategoria = null;
		Collection colecaoContaCategoriaConsumoFaixa = null;

		BigDecimal[] valoresAguaEsgotoRateioPorEconomia = new BigDecimal[2];

		if (conta.getImovel().isImovelCondominio()) {
			valoresAguaEsgotoRateioPorEconomia = this
					.calcularValorRateioPorEconomia(conta.getImovel()
							.getImovelCondominio().getId(),
							conta.getFaturamentoGrupo());
		}

		if ((colecaoCategorias != null && !colecaoCategorias.isEmpty())
				&& (colecaoCalcularValoresAguaEsgotoHelper != null && !colecaoCalcularValoresAguaEsgotoHelper
						.isEmpty())) {

			ContaCategoria contaCategoria = null;
			ContaCategoriaPK contaCategoriaPK = null;
			Categoria categoria = null;
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = null;

			colecaoContaCategoria = new ArrayList();
			colecaoContaCategoriaConsumoFaixa = new ArrayList();

			Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();
			Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper
					.iterator();

			while (iteratorColecaoCategorias.hasNext()
					&& iteratorColecaoCalcularValoresAguaEsgotoHelper.hasNext()) {

				// CATEGORIA
				categoria = (Categoria) iteratorColecaoCategorias.next();

				// VALORES POR CATEGORIA
				calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
						.next();

				contaCategoria = new ContaCategoria();
				contaCategoriaPK = new ContaCategoriaPK();
				contaCategoriaPK.setConta(conta);
				contaCategoriaPK.setCategoria(categoria);
				contaCategoriaPK
						.setSubcategoria(Subcategoria.SUBCATEGORIA_ZERO);
				contaCategoria.setComp_id(contaCategoriaPK);
				contaCategoria.setQuantidadeEconomia(categoria
						.getQuantidadeEconomiasCategoria().shortValue());
				BigDecimal valorRateioAgua = new BigDecimal("0.00");
				BigDecimal valorRateioEsgoto = new BigDecimal("0.00");

				if (conta.getImovel().isImovelCondominio()) {
					valorRateioAgua = valoresAguaEsgotoRateioPorEconomia[0]
							.multiply(new BigDecimal(categoria
									.getQuantidadeEconomiasCategoria()));

					valorRateioEsgoto = valoresAguaEsgotoRateioPorEconomia[1]
							.multiply(new BigDecimal(categoria
									.getQuantidadeEconomiasCategoria()));

				}

				BigDecimal valorAgua = valorRateioAgua;
				if (calcularValoresAguaEsgotoHelper
						.getValorFaturadoAguaCategoria() != null)
					valorAgua = calcularValoresAguaEsgotoHelper
							.getValorFaturadoAguaCategoria().add(valorAgua);

				BigDecimal valorEsgoto = valorRateioEsgoto;
				if (calcularValoresAguaEsgotoHelper
						.getValorFaturadoEsgotoCategoria() != null)
					valorEsgoto = calcularValoresAguaEsgotoHelper
							.getValorFaturadoEsgotoCategoria().add(valorEsgoto);

				contaCategoria.setValorAgua(valorAgua);

				contaCategoria.setConsumoAgua(calcularValoresAguaEsgotoHelper
						.getConsumoFaturadoAguaCategoria());
				contaCategoria.setValorEsgoto(valorEsgoto);
				contaCategoria.setConsumoEsgoto(calcularValoresAguaEsgotoHelper
						.getConsumoFaturadoEsgotoCategoria());
				contaCategoria
						.setValorTarifaMinimaAgua(calcularValoresAguaEsgotoHelper
								.getValorTarifaMinimaAguaCategoria());
				contaCategoria
						.setConsumoMinimoAgua(calcularValoresAguaEsgotoHelper
								.getConsumoMinimoAguaCategoria());
				contaCategoria
						.setValorTarifaMinimaEsgoto(calcularValoresAguaEsgotoHelper
								.getValorTarifaMinimaEsgotoCategoria());
				contaCategoria
						.setConsumoMinimoEsgoto(calcularValoresAguaEsgotoHelper
								.getConsumoMinimoEsgotoCategoria());
				contaCategoria.setUltimaAlteracao(new Date());

				colecaoContaCategoria.add(contaCategoria);

				// CONTA_CATEGORIA_CONSUMO_FAIXA
				Collection colecaoFaixaTarifaConsumo = calcularValoresAguaEsgotoHelper
						.getFaixaTarifaConsumo();

				if (colecaoFaixaTarifaConsumo != null
						&& !colecaoFaixaTarifaConsumo.isEmpty()) {

					Iterator iteratorColecaoFaixaTarifaConsumo = colecaoFaixaTarifaConsumo
							.iterator();

					ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = null;
					CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = null;

					while (iteratorColecaoFaixaTarifaConsumo.hasNext()) {

						calcularValoresAguaEsgotoFaixaHelper = (CalcularValoresAguaEsgotoFaixaHelper) iteratorColecaoFaixaTarifaConsumo
								.next();

						contaCategoriaConsumoFaixa = new ContaCategoriaConsumoFaixa();
						contaCategoriaConsumoFaixa
								.setContaCategoria(contaCategoria);
						contaCategoriaConsumoFaixa
								.setValorAgua(calcularValoresAguaEsgotoFaixaHelper
										.getValorFaturadoAguaFaixa());
						contaCategoriaConsumoFaixa
								.setConsumoAgua(calcularValoresAguaEsgotoFaixaHelper
										.getConsumoFaturadoAguaFaixa());
						contaCategoriaConsumoFaixa
								.setValorEsgoto(calcularValoresAguaEsgotoFaixaHelper
										.getValorFaturadoEsgotoFaixa());
						contaCategoriaConsumoFaixa
								.setConsumoEsgoto(calcularValoresAguaEsgotoFaixaHelper
										.getConsumoFaturadoEsgotoFaixa());
						contaCategoriaConsumoFaixa
								.setConsumoFaixaInicio(calcularValoresAguaEsgotoFaixaHelper
										.getLimiteInicialConsumoFaixa());
						contaCategoriaConsumoFaixa
								.setConsumoFaixaFim(calcularValoresAguaEsgotoFaixaHelper
										.getLimiteFinalConsumoFaixa());
						contaCategoriaConsumoFaixa
								.setValorTarifaFaixa(calcularValoresAguaEsgotoFaixaHelper
										.getValorTarifaFaixa());
						contaCategoriaConsumoFaixa
								.setUltimaAlteracao(new Date());

						colecaoContaCategoriaConsumoFaixa
								.add(contaCategoriaConsumoFaixa);

					}
				}
			}

			helper.setColecaoContaCategoria(colecaoContaCategoria);
			helper.setColecaoContaCategoriaConsumoFaixa(colecaoContaCategoriaConsumoFaixa);

		} else if (colecaoCategorias != null && !colecaoCategorias.isEmpty()) {

			// GERAR CONTA CATEGORIA COM VALORES ZERADOS
			helper = this.gerarContaCategoriaValoresZeradosPorCategoria(conta,
					colecaoCategorias);
		}

		return helper;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2008
	 * 
	 * @param conta
	 * @param colecaoSubCategorias
	 * @param colecaoCalcularValoresAguaEsgotoHelper
	 * @return
	 * @throws ControladorException
	 */
	public GerarContaCategoriaHelper gerarContaCategoriaPorSubcategoria(
			Conta conta, Collection colecaoSubCategorias,
			Collection colecaoCalcularValoresAguaEsgotoHelper)
			throws ControladorException {

		GerarContaCategoriaHelper helper = new GerarContaCategoriaHelper();

		Collection colecaoContaCategoria = null;
		Collection colecaoContaCategoriaConsumoFaixa = null;

		BigDecimal[] valoresAguaEsgotoRateioPorEconomia = new BigDecimal[2];

		if (conta.getImovel().isImovelCondominio()) {

			valoresAguaEsgotoRateioPorEconomia = this
					.calcularValorRateioPorEconomia(conta.getImovel()
							.getImovelCondominio().getId(),
							conta.getFaturamentoGrupo());
		}

		if ((colecaoSubCategorias != null && !colecaoSubCategorias.isEmpty())
				&& (colecaoCalcularValoresAguaEsgotoHelper != null && !colecaoCalcularValoresAguaEsgotoHelper
						.isEmpty())) {

			ContaCategoria contaCategoria = null;
			ContaCategoriaPK contaCategoriaPK = null;
			Subcategoria subCategoria = null;
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = null;

			colecaoContaCategoria = new ArrayList();
			colecaoContaCategoriaConsumoFaixa = new ArrayList();

			Iterator iteratorColecaoSubCategorias = colecaoSubCategorias
					.iterator();

			Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper
					.iterator();

			while (iteratorColecaoSubCategorias.hasNext()
					&& iteratorColecaoCalcularValoresAguaEsgotoHelper.hasNext()) {

				// SUBCATEGORIA
				subCategoria = (Subcategoria) iteratorColecaoSubCategorias
						.next();

				// VALORES POR SUBCATEGORIA
				calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
						.next();

				contaCategoria = new ContaCategoria();
				contaCategoriaPK = new ContaCategoriaPK();
				contaCategoriaPK.setConta(conta);
				contaCategoriaPK.setCategoria(subCategoria.getCategoria());
				contaCategoriaPK.setSubcategoria(subCategoria);
				contaCategoria.setComp_id(contaCategoriaPK);
				contaCategoria.setQuantidadeEconomia(subCategoria
						.getQuantidadeEconomias().shortValue());

				BigDecimal valorRateioAgua = valoresAguaEsgotoRateioPorEconomia[0]
						.multiply(new BigDecimal(subCategoria
								.getQuantidadeEconomias()));

				BigDecimal valorAgua = calcularValoresAguaEsgotoHelper
						.getValorFaturadoAguaCategoria().add(valorRateioAgua);

				BigDecimal valorRateioEsgoto = valoresAguaEsgotoRateioPorEconomia[1]
						.multiply(new BigDecimal(subCategoria
								.getQuantidadeEconomias()));

				BigDecimal valorEsgoto = calcularValoresAguaEsgotoHelper
						.getValorFaturadoEsgotoCategoria().add(
								valorRateioEsgoto);

				contaCategoria.setValorAgua(valorAgua);

				contaCategoria.setConsumoAgua(calcularValoresAguaEsgotoHelper
						.getConsumoFaturadoAguaCategoria());
				contaCategoria.setValorEsgoto(valorEsgoto);
				contaCategoria.setConsumoEsgoto(calcularValoresAguaEsgotoHelper
						.getConsumoFaturadoEsgotoCategoria());
				contaCategoria
						.setValorTarifaMinimaAgua(calcularValoresAguaEsgotoHelper
								.getValorTarifaMinimaAguaCategoria());
				contaCategoria
						.setConsumoMinimoAgua(calcularValoresAguaEsgotoHelper
								.getConsumoMinimoAguaCategoria());
				contaCategoria
						.setValorTarifaMinimaEsgoto(calcularValoresAguaEsgotoHelper
								.getValorTarifaMinimaEsgotoCategoria());
				contaCategoria
						.setConsumoMinimoEsgoto(calcularValoresAguaEsgotoHelper
								.getConsumoMinimoEsgotoCategoria());
				contaCategoria.setUltimaAlteracao(new Date());

				colecaoContaCategoria.add(contaCategoria);

				// CONTA_CATEGORIA_CONSUMO_FAIXA
				Collection colecaoFaixaTarifaConsumo = calcularValoresAguaEsgotoHelper
						.getFaixaTarifaConsumo();

				if (colecaoFaixaTarifaConsumo != null
						&& !colecaoFaixaTarifaConsumo.isEmpty()) {

					Iterator iteratorColecaoFaixaTarifaConsumo = colecaoFaixaTarifaConsumo
							.iterator();

					ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = null;
					CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = null;

					while (iteratorColecaoFaixaTarifaConsumo.hasNext()) {

						calcularValoresAguaEsgotoFaixaHelper = (CalcularValoresAguaEsgotoFaixaHelper) iteratorColecaoFaixaTarifaConsumo
								.next();

						contaCategoriaConsumoFaixa = new ContaCategoriaConsumoFaixa();
						contaCategoriaConsumoFaixa
								.setContaCategoria(contaCategoria);
						contaCategoriaConsumoFaixa
								.setValorAgua(calcularValoresAguaEsgotoFaixaHelper
										.getValorFaturadoAguaFaixa());
						contaCategoriaConsumoFaixa
								.setConsumoAgua(calcularValoresAguaEsgotoFaixaHelper
										.getConsumoFaturadoAguaFaixa());
						contaCategoriaConsumoFaixa
								.setValorEsgoto(calcularValoresAguaEsgotoFaixaHelper
										.getValorFaturadoEsgotoFaixa());
						contaCategoriaConsumoFaixa
								.setConsumoEsgoto(calcularValoresAguaEsgotoFaixaHelper
										.getConsumoFaturadoEsgotoFaixa());
						contaCategoriaConsumoFaixa
								.setConsumoFaixaInicio(calcularValoresAguaEsgotoFaixaHelper
										.getLimiteInicialConsumoFaixa());
						contaCategoriaConsumoFaixa
								.setConsumoFaixaFim(calcularValoresAguaEsgotoFaixaHelper
										.getLimiteFinalConsumoFaixa());
						contaCategoriaConsumoFaixa
								.setValorTarifaFaixa(calcularValoresAguaEsgotoFaixaHelper
										.getValorTarifaFaixa());
						contaCategoriaConsumoFaixa
								.setUltimaAlteracao(new Date());

						colecaoContaCategoriaConsumoFaixa
								.add(contaCategoriaConsumoFaixa);

					}
				}
			}

			helper.setColecaoContaCategoria(colecaoContaCategoria);
			helper.setColecaoContaCategoriaConsumoFaixa(colecaoContaCategoriaConsumoFaixa);

		} else if (colecaoSubCategorias != null
				&& !colecaoSubCategorias.isEmpty()) {

			// GERAR CONTA CATEGORIA COM VALORES ZERADOS
			helper = this.gerarContaCategoriaValoresZeradosPorSubcategoria(
					conta, colecaoSubCategorias);
		}

		return helper;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2008
	 * 
	 * @param conta
	 * @param colecaoCategorias
	 * @return GerarContaCategoriaHelper
	 * @throws ControladorException
	 */
	public GerarContaCategoriaHelper gerarContaCategoriaValoresZerados(
			Conta conta, Collection colecaoCategorias,
			SistemaParametro sistemaParametro) throws ControladorException {

		GerarContaCategoriaHelper helper = new GerarContaCategoriaHelper();

		// Verificando se a empresa fatura por CATEGORIA ou SUBCATEGORIA
		if (sistemaParametro.getIndicadorTarifaCategoria().equals(
				SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {

			// GERANDO POR CATEGORIA
			helper = this.gerarContaCategoriaValoresZeradosPorCategoria(conta,
					colecaoCategorias);
		} else {

			// GERANDO POR SUBCATEGORIA
			helper = this.gerarContaCategoriaValoresZeradosPorSubcategoria(
					conta, colecaoCategorias);
		}

		return helper;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2008
	 * 
	 * @param conta
	 * @param colecaoCategorias
	 * @return GerarContaCategoriaHelper
	 * @throws ControladorException
	 */
	public GerarContaCategoriaHelper gerarContaCategoriaValoresZeradosPorCategoria(
			Conta conta, Collection colecaoCategorias)
			throws ControladorException {

		GerarContaCategoriaHelper helper = new GerarContaCategoriaHelper();

		Collection colecaoContaCategoria = new ArrayList();
		ContaCategoria contaCategoria = null;
		ContaCategoriaPK contaCategoriaPK = null;
		Categoria categoria = null;

		Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();

		while (iteratorColecaoCategorias.hasNext()) {

			categoria = (Categoria) iteratorColecaoCategorias.next();

			contaCategoria = new ContaCategoria();
			contaCategoriaPK = new ContaCategoriaPK();
			contaCategoriaPK.setConta(conta);
			contaCategoriaPK.setCategoria(categoria);
			contaCategoriaPK.setSubcategoria(Subcategoria.SUBCATEGORIA_ZERO);
			contaCategoria.setComp_id(contaCategoriaPK);
			contaCategoria.setQuantidadeEconomia(categoria
					.getQuantidadeEconomiasCategoria().shortValue());
			contaCategoria.setValorAgua(ConstantesSistema.VALOR_ZERO);
			contaCategoria.setConsumoAgua(0);
			contaCategoria.setValorEsgoto(ConstantesSistema.VALOR_ZERO);
			contaCategoria.setConsumoEsgoto(0);
			contaCategoria
					.setValorTarifaMinimaAgua(ConstantesSistema.VALOR_ZERO);
			contaCategoria.setConsumoMinimoAgua(0);
			contaCategoria
					.setValorTarifaMinimaEsgoto(ConstantesSistema.VALOR_ZERO);
			contaCategoria.setConsumoMinimoEsgoto(0);
			contaCategoria.setUltimaAlteracao(new Date());

			colecaoContaCategoria.add(contaCategoria);
		}

		helper.setColecaoContaCategoria(colecaoContaCategoria);

		return helper;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2008
	 * 
	 * @param conta
	 * @param colecaoSubCategorias
	 * @return
	 * @throws ControladorException
	 */
	public GerarContaCategoriaHelper gerarContaCategoriaValoresZeradosPorSubcategoria(
			Conta conta, Collection colecaoSubCategorias)
			throws ControladorException {

		GerarContaCategoriaHelper helper = new GerarContaCategoriaHelper();

		Collection colecaoContaCategoria = new ArrayList();
		ContaCategoria contaCategoria = null;
		ContaCategoriaPK contaCategoriaPK = null;
		Subcategoria subCategoria = null;

		Iterator iteratorColecaoSubCategorias = colecaoSubCategorias.iterator();

		while (iteratorColecaoSubCategorias.hasNext()) {

			subCategoria = (Subcategoria) iteratorColecaoSubCategorias.next();

			contaCategoria = new ContaCategoria();
			contaCategoriaPK = new ContaCategoriaPK();
			contaCategoriaPK.setConta(conta);
			contaCategoriaPK.setCategoria(subCategoria.getCategoria());
			contaCategoriaPK.setSubcategoria(subCategoria);
			contaCategoria.setComp_id(contaCategoriaPK);
			contaCategoria.setQuantidadeEconomia(subCategoria
					.getQuantidadeEconomias().shortValue());
			contaCategoria.setValorAgua(ConstantesSistema.VALOR_ZERO);
			contaCategoria.setConsumoAgua(0);
			contaCategoria.setValorEsgoto(ConstantesSistema.VALOR_ZERO);
			contaCategoria.setConsumoEsgoto(0);
			contaCategoria
					.setValorTarifaMinimaAgua(ConstantesSistema.VALOR_ZERO);
			contaCategoria.setConsumoMinimoAgua(0);
			contaCategoria
					.setValorTarifaMinimaEsgoto(ConstantesSistema.VALOR_ZERO);
			contaCategoria.setConsumoMinimoEsgoto(0);
			contaCategoria.setUltimaAlteracao(new Date());

			colecaoContaCategoria.add(contaCategoria);
		}

		helper.setColecaoContaCategoria(colecaoContaCategoria);

		return helper;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * [SB0009] - Gerar Resumo da Simulação do Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2008
	 * 
	 * @param colecaoCategorias
	 * @param colecaoCalcularValoresAguaEsgotoHelper
	 * @param helperDebito
	 * @param helperCredito
	 * @param colecaoResumoFaturamento
	 * @param imovel
	 * @param gerarAtividadeGrupoFaturamento
	 * @param faturamentoAtivCronRota
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	public void gerarResumoFaturamentoSimulacao(Collection colecaoCategorias,
			Collection colecaoCalcularValoresAguaEsgotoHelper,
			GerarDebitoCobradoHelper helperDebito,
			GerarCreditoRealizadoHelper helperCredito,
			Collection colecaoResumoFaturamento, Imovel imovel,
			boolean gerarAtividadeGrupoFaturamento,
			FaturamentoAtivCronRota faturamentoAtivCronRota,
			FaturamentoGrupo faturamentoGrupo,
			Integer anoMesReferenciaResumoFaturamento, boolean preFaturar)
			throws ControladorException {

		if (anoMesReferenciaResumoFaturamento == null) {
			anoMesReferenciaResumoFaturamento = faturamentoGrupo
					.getAnoMesReferencia();
		}

		if ((colecaoCategorias != null && !colecaoCategorias.isEmpty())
				&& (colecaoCalcularValoresAguaEsgotoHelper != null && !colecaoCalcularValoresAguaEsgotoHelper
						.isEmpty())) {

			/*
			 * Colocado por Raphael Rossiter em 26/03/2007
			 * 
			 * OBJ: Gerar o resumo da simulação do faturamento com os valores
			 * por categoria e não com o valor total.
			 */

			// Coleção com os valores por Categoria (DÉBITOS)
			Collection colecaoValoresDebitosCategorias = getControladorImovel()
					.obterValorPorCategoria(colecaoCategorias,
							helperDebito.getValorTotalDebito());

			Map<DebitoTipo, Collection<BigDecimal>> valoresDebitosCategoriasPorTipoDebito = new HashMap<DebitoTipo, Collection<BigDecimal>>();

			if (helperDebito.getMapValoresPorTipoDebito() != null) {
				for (Map.Entry debitos : helperDebito
						.getMapValoresPorTipoDebito().entrySet()) {
					Collection colecaoValoresDebitosCategoriasPorTipoDebito = getControladorImovel()
							.obterValorPorCategoria(colecaoCategorias,
									(BigDecimal) debitos.getValue());

					valoresDebitosCategoriasPorTipoDebito.put(
							(DebitoTipo) debitos.getKey(),
							colecaoValoresDebitosCategoriasPorTipoDebito);

				}
			}

			// Coleção com os valores por Categoria (CRÉDITOS)
			Collection colecaoValoresCreditosCategorias = getControladorImovel()
					.obterValorPorCategoria(colecaoCategorias,
							helperCredito.getValorTotalCredito());

			Map<CreditoTipo, Collection<BigDecimal>> valoresDebitosCategoriasPorTipoCredito = new HashMap<CreditoTipo, Collection<BigDecimal>>();

			if (helperCredito.getMapValoresPorTipoCredito() != null) {
				for (Map.Entry creditos : helperCredito
						.getMapValoresPorTipoCredito().entrySet()) {
					Collection colecaoValoresCreditosCategoriasPorTipoCredito = getControladorImovel()
							.obterValorPorCategoria(colecaoCategorias,
									(BigDecimal) creditos.getValue());

					valoresDebitosCategoriasPorTipoCredito.put(
							(CreditoTipo) creditos.getKey(),
							colecaoValoresCreditosCategoriasPorTipoCredito);

				}
			}

			// Coleção de categorias
			Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();

			// colecao com os valores para ser usados em conta categoria
			Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper
					.iterator();

			// Coleção com os valores por Categoria (DÉBITOS)
			Iterator iteratorColecaoValoresDebitosCategorias = colecaoValoresDebitosCategorias
					.iterator();

			// Coleção com os valores por Categoria (CRÉDITOS)
			Iterator iteratorColecaoValoresCreditosCategorias = colecaoValoresCreditosCategorias
					.iterator();

			Categoria categoria = null;
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = null;
			BigDecimal valorTotalDebitoCategoria = null;
			BigDecimal valorTotalCreditoCategoria = null;

			boolean primeiraCategoria = true;
			int contador = 0;
			while (iteratorColecaoCategorias.hasNext()
					&& iteratorColecaoCalcularValoresAguaEsgotoHelper.hasNext()
					&& iteratorColecaoValoresDebitosCategorias.hasNext()
					&& iteratorColecaoValoresCreditosCategorias.hasNext()) {

				categoria = (Categoria) iteratorColecaoCategorias.next();

				calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
						.next();

				valorTotalDebitoCategoria = (BigDecimal) iteratorColecaoValoresDebitosCategorias
						.next();

				valorTotalCreditoCategoria = (BigDecimal) iteratorColecaoValoresCreditosCategorias
						.next();

				Collection colecaoValoresPorTipoDebito = new ArrayList();
				for (Map.Entry debitos : valoresDebitosCategoriasPorTipoDebito
						.entrySet()) {
					ValorPorTipoRegistroHelper helper = new ValorPorTipoRegistroHelper();
					helper.setDebitoTipo((DebitoTipo) debitos.getKey());
					Collection colecaoValoresPorCategoria = (Collection) debitos
							.getValue();
					helper.setValor((BigDecimal) colecaoValoresPorCategoria
							.toArray()[contador]);

					colecaoValoresPorTipoDebito.add(helper);
				}

				Collection colecaoValoresPorTipoCredito = new ArrayList();
				for (Map.Entry creditos : valoresDebitosCategoriasPorTipoCredito
						.entrySet()) {
					ValorPorTipoRegistroHelper helper = new ValorPorTipoRegistroHelper();
					helper.setCreditoTipo((CreditoTipo) creditos.getKey());
					Collection colecaoValoresPorCategoria = (Collection) creditos
							.getValue();
					helper.setValor((BigDecimal) colecaoValoresPorCategoria
							.toArray()[contador]);

					colecaoValoresPorTipoCredito.add(helper);
				}

				BigDecimal valorImpostos = BigDecimal.ZERO;

				if (helperDebito.getGerarImpostosDeduzidosContaHelper() != null
						&& helperDebito.getGerarImpostosDeduzidosContaHelper()
								.getValorTotalImposto() != null) {
					valorImpostos = helperDebito
							.getGerarImpostosDeduzidosContaHelper()
							.getValorTotalImposto();
				}

				// [SB0009] - Gerar Resumo da Simulação do Faturamento
				this.adicionarColecaoResumoFaturamentoSimulacao(
						colecaoResumoFaturamento, categoria,
						Subcategoria.SUBCATEGORIA_ZERO,
						calcularValoresAguaEsgotoHelper, imovel,
						gerarAtividadeGrupoFaturamento,
						valorTotalDebitoCategoria, valorTotalCreditoCategoria,
						faturamentoAtivCronRota,
						anoMesReferenciaResumoFaturamento, primeiraCategoria,
						preFaturar, colecaoValoresPorTipoDebito,
						colecaoValoresPorTipoCredito, valorImpostos);

				contador++;
				primeiraCategoria = false;
			}
		} else if (colecaoCategorias != null && !colecaoCategorias.isEmpty()) {

			/*
			 * Colocado por Raphael Rossiter em 26/03/2007
			 * 
			 * OBJ: Gerar o resumo da simulação do faturamento com os valores
			 * por categoria e não com o valor total
			 */

			// Coleção com os valores por Categoria (DÉBITOS)
			Collection colecaoValoresDebitosCategorias = getControladorImovel()
					.obterValorPorCategoria(colecaoCategorias,
							helperDebito.getValorTotalDebito());

			// Coleção com os valores por Categoria (CRÉDITOS)
			Collection colecaoValoresCreditosCategorias = getControladorImovel()
					.obterValorPorCategoria(colecaoCategorias,
							helperCredito.getValorTotalCredito());

			// Coleção de categorias
			Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();

			// Coleção com os valores por Categoria (DÉBITOS)
			Iterator iteratorColecaoValoresDebitosCategorias = colecaoValoresDebitosCategorias
					.iterator();

			Map<DebitoTipo, Collection<BigDecimal>> valoresDebitosCategoriasPorTipoDebito = new HashMap<DebitoTipo, Collection<BigDecimal>>();

			if (helperDebito.getMapValoresPorTipoDebito() != null) {

				for (Map.Entry debitos : helperDebito
						.getMapValoresPorTipoDebito().entrySet()) {
					Collection colecaoValoresDebitosCategoriasPorTipoDebito = getControladorImovel()
							.obterValorPorCategoria(colecaoCategorias,
									(BigDecimal) debitos.getValue());

					valoresDebitosCategoriasPorTipoDebito.put(
							(DebitoTipo) debitos.getKey(),
							colecaoValoresDebitosCategoriasPorTipoDebito);

				}

			}

			// Coleção com os valores por Categoria (CRÉDITOS)
			Iterator iteratorColecaoValoresCreditosCategorias = colecaoValoresCreditosCategorias
					.iterator();

			Map<CreditoTipo, Collection<BigDecimal>> valoresDebitosCategoriasPorTipoCredito = new HashMap<CreditoTipo, Collection<BigDecimal>>();

			if (helperCredito.getMapValoresPorTipoCredito() != null) {

				for (Map.Entry creditos : helperCredito
						.getMapValoresPorTipoCredito().entrySet()) {
					Collection colecaoValoresCreditosCategoriasPorTipoCredito = getControladorImovel()
							.obterValorPorCategoria(colecaoCategorias,
									(BigDecimal) creditos.getValue());

					valoresDebitosCategoriasPorTipoCredito.put(
							(CreditoTipo) creditos.getKey(),
							colecaoValoresCreditosCategoriasPorTipoCredito);

				}

			}

			Categoria categoria = null;
			BigDecimal valorTotalDebitoCategoria = null;
			BigDecimal valorTotalCreditoCategoria = null;
			int contador = 0;
			boolean primeiraCategoria = true;
			while (iteratorColecaoCategorias.hasNext()
					&& iteratorColecaoValoresDebitosCategorias.hasNext()
					&& iteratorColecaoValoresCreditosCategorias.hasNext()) {

				categoria = (Categoria) iteratorColecaoCategorias.next();

				valorTotalDebitoCategoria = (BigDecimal) iteratorColecaoValoresDebitosCategorias
						.next();

				valorTotalCreditoCategoria = (BigDecimal) iteratorColecaoValoresCreditosCategorias
						.next();

				Collection colecaoValoresPorTipoDebito = new ArrayList();
				for (Map.Entry debitos : valoresDebitosCategoriasPorTipoDebito
						.entrySet()) {
					ValorPorTipoRegistroHelper helper = new ValorPorTipoRegistroHelper();
					helper.setDebitoTipo((DebitoTipo) debitos.getKey());
					Collection colecaoValoresPorCategoria = (Collection) debitos
							.getValue();
					helper.setValor((BigDecimal) colecaoValoresPorCategoria
							.toArray()[contador]);

					colecaoValoresPorTipoDebito.add(helper);
				}

				Collection colecaoValoresPorTipoCredito = new ArrayList();
				for (Map.Entry creditos : valoresDebitosCategoriasPorTipoCredito
						.entrySet()) {
					ValorPorTipoRegistroHelper helper = new ValorPorTipoRegistroHelper();
					helper.setCreditoTipo((CreditoTipo) creditos.getKey());
					Collection colecaoValoresPorCategoria = (Collection) creditos
							.getValue();
					helper.setValor((BigDecimal) colecaoValoresPorCategoria
							.toArray()[contador]);

					colecaoValoresPorTipoCredito.add(helper);
				}

				BigDecimal valorImpostos = BigDecimal.ZERO;

				if (helperDebito.getGerarImpostosDeduzidosContaHelper() != null
						&& helperDebito.getGerarImpostosDeduzidosContaHelper()
								.getValorTotalImposto() != null) {
					valorImpostos = helperDebito
							.getGerarImpostosDeduzidosContaHelper()
							.getValorTotalImposto();
				}

				// [SB0009] - Gerar Resumo da Simulação do Faturamento
				this.adicionarColecaoResumoFaturamentoSimulacao(
						colecaoResumoFaturamento, categoria,
						Subcategoria.SUBCATEGORIA_ZERO, null, imovel,
						gerarAtividadeGrupoFaturamento,
						valorTotalDebitoCategoria, valorTotalCreditoCategoria,
						faturamentoAtivCronRota,
						anoMesReferenciaResumoFaturamento, primeiraCategoria,
						preFaturar, colecaoValoresPorTipoDebito,
						colecaoValoresPorTipoCredito, valorImpostos);

				contador++;
				primeiraCategoria = false;
			}
		}
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * Caso seja faturamento antecipado, a Data de Vencimento da Conta será o
	 * último dia útil do ano e mês de referência
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2008
	 * 
	 * @param municipio
	 * @param anoMesFaturamento
	 * @return Date
	 * @throws ControladorException
	 */
	public Date determinarVencimentoContaAntecipado(Imovel imovel,
			Integer anoMesFaturamento) throws ControladorException {

		Date dataVencimentoContaAntecipado = null;

		// FERIADO NACIONAL
		Collection<NacionalFeriado> colecaoFeriadosNacionais = null;

		try {

			colecaoFeriadosNacionais = repositorioUtil
					.pesquisarFeriadosNacionais();

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		// ÚLTIMO DIA DO MÊS
		int mes = Util.obterMes(anoMesFaturamento);
		int ano = Util.obterAno(anoMesFaturamento);

		String ultimoDiaMes = Util.obterUltimoDiaMes(mes, ano);

		dataVencimentoContaAntecipado = Util.criarData(
				Integer.parseInt(ultimoDiaMes), mes, ano);

		while (!Util.ehDiaUtil(dataVencimentoContaAntecipado,
				colecaoFeriadosNacionais, null)) {

			dataVencimentoContaAntecipado = Util.subtrairNumeroDiasDeUmaData(
					dataVencimentoContaAntecipado, 1);
		}

		return dataVencimentoContaAntecipado;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter - Hugo Leonardo
	 * @date 03/07/2008 - 02/06/2010
	 * 
	 * @param rota
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void gerarArquivoTextoParaFaturamento(Rota rota,
			Integer anoMesFaturamento, FaturamentoGrupo faturamentoGrupo,
			Date dataComando, int idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		// PROCESSO BATCH
		// ------------------------------------------------------------------------------------
		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.ROTA, rota.getId());
		// ---------------------------------------------------------------------------------------------------

		try {

			gerarArquivoTextoParaFaturamento(rota, anoMesFaturamento,
					faturamentoGrupo, dataComando, Boolean.FALSE);

			/* fecha a unidade de processamento com sucesso */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception ex) {

			ex.printStackTrace();

			/* fecha a unidade de processamento com erro */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(ex,
					idUnidadeIniciada, true);

			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter - Hugo Leonardo - Bruno Barros
	 * @date 03/07/2008 - 02/06/2010 - 18/11/2010
	 * 
	 * @param rota
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @param dataComando
	 * @throws ControladorException
	 */
	public void gerarArquivoTextoParaFaturamento(Rota rota, Integer anoMesFaturamento, FaturamentoGrupo faturamentoGrupo,
			Date dataComando, Boolean regerar) throws ControladorException, ErroRepositorioException {

        boolean rotaSoComImoveisInformativos = true;

        UC0745GerarArquivoTextoFaturamento gerarArquivoTextoFaturamento = UC0745GerarArquivoTextoFaturamento.getInstancia(repositorioFaturamento,
                sessionContext, repositorioCobranca);

        SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

        // [FS0005] - Verificar existência do arquivo texto por rota
        boolean gerarArquivoTexto = gerarArquivoTextoFaturamento.verificarExistenciaArquivoTextoRota(rota.getId(), anoMesFaturamento);

        if (gerarArquivoTexto || regerar) {
            /*
             * Variáveis para a paginação da pesquisa de Imovel, acumulação da
             * quantidade de imóveis por rota e geração do arquivo txt.
             */
            // ========================================================================
            boolean flagTerminou = false;
            final int quantidadeRegistros = 3000;
            int numeroIndice = 0;
            Imovel imovel = null;
            int tamanhoArquivo = 0;

            int tamanhoArquivoDiv = 0;

            List<Integer> imoveisDivididos = new ArrayList<Integer>();

            StringBuilder arquivoTexto = null;
            StringBuilder arquivoTextoDiv = null;

            Collection<Imovel> colecaoImoveis = new ArrayList();

            // colecao de Arquivo Texto Roteiro Empresa Divisao
            Collection<ArquivoTextoRoteiroEmpresaDivisao> colecaoArquivoDivisao = new ArrayList();

            while (!flagTerminou) {

                Object[] dadosImoveis = gerarArquivoTextoFaturamento.pesquisarImovelGerarArquivoTextoFaturamento(rota, numeroIndice, quantidadeRegistros,
                        sistemaParametro, faturamentoGrupo, null);

                Collection colecaoImovel = (Collection) dadosImoveis[0];
                int quantidadeImoveis = (Integer) dadosImoveis[1];

                // PERFORMANCE
                dadosImoveis = null;

                /*
                 * Caso exista ids de imóveis para a rota atual determina a
                 * geração do arquivo texto para cada imóvel retornado.
                 */
                if (colecaoImovel != null && !colecaoImovel.isEmpty()) {

                    Iterator iteratorColecaoImoveis = colecaoImovel.iterator();

                    // LAÇO PARA DETERMINAR O ARQUIVO TEXTO DE TODOS OS IMOVEIS
                    // DA ROTA ATUAL
                    imovel = null;
                    while (iteratorColecaoImoveis.hasNext()) {

                        imovel = (Imovel) iteratorColecaoImoveis.next();
                        Conta conta = null;

                        if (arquivoTexto == null) {
                            arquivoTexto = new StringBuilder();
                        }

                        if (arquivoTextoDiv == null) {
                            arquivoTextoDiv = new StringBuilder();
                        }

                        if (imovel.getIndicadorImovelCondominio().equals(ConstantesSistema.INDICADOR_USO_DESATIVO)) {

                            Object[] retornoArquivo = carregarArquivoImpressaoSimultanea(gerarArquivoTextoFaturamento, imovel, anoMesFaturamento, rota,
                                    faturamentoGrupo, sistemaParametro, dataComando);
                            int tamanhoArquivoRetorno = 0;
                            if (retornoArquivo != null && !retornoArquivo.equals("")) {
                                if (arquivoTexto.length() != 0) {
                                    arquivoTexto.append(System.getProperty("line.separator"));
                                }
                                arquivoTexto.append(retornoArquivo[0]);
                                tamanhoArquivoRetorno = (Integer) retornoArquivo[1];
                                tamanhoArquivo = tamanhoArquivo + tamanhoArquivoRetorno;

                                // verifica se existe número limite de imoveis
                                // para a Rota.
                                // se existir, divide o arquivo em partes
                                // definidas pelo número limite de imoveis.
                                // Sempre observando os Critérios da UC0745 no
                                // Fluxo 3.2
                                if (rota.getNumeroLimiteImoveis() != null && !rota.getNumeroLimiteImoveis().equals("")) {

                                    if (arquivoTextoDiv.length() != 0) {
                                        arquivoTextoDiv.append(System.getProperty("line.separator"));
                                    }

                                    if (arquivoTextoDiv != null) {
                                        arquivoTextoDiv.append(retornoArquivo[0]);
                                        imoveisDivididos.add(imovel.getId());
                                        tamanhoArquivoDiv = tamanhoArquivoDiv + tamanhoArquivoRetorno;
                                    }
                                }
                            }

                            // inserir o id do imóvel na coleção
                            if (tamanhoArquivoRetorno != 0) {
                                colecaoImoveis.add(imovel);

                            }

                            // ----------------------------------------------------------------------------------
                        } else {

                            // ----------------------------------------------------------------------------------

                            // Caso o imóvel condomínio MACRO não seja não
                            // medido
                            if (imovel.getHidrometroInstalacaoHistorico() != null
                                    || (imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null)) {

                                // Recupera os imóveis micro dos imóveis Macro
                                Object[] dadosImoveisMicros = gerarArquivoTextoFaturamento.pesquisarImovelGerarArquivoTextoFaturamento(rota, numeroIndice,
                                        quantidadeRegistros, sistemaParametro, faturamentoGrupo, imovel.getId());

                                Collection colecaoImovelMicro = (Collection) dadosImoveisMicros[0];
                                // quantidadeImoveis = quantidadeImoveis +
                                // (Integer)dadosImoveisMicros[1];

                                // PERFORMANCE
                                dadosImoveisMicros = null;

                                /*
                                 * Caso exista ids de imóveis para a rota atual
                                 * determina a geração do arquivo texto para
                                 * cada imóvel retornado.
                                 */
                                if (colecaoImovelMicro != null && !colecaoImovelMicro.isEmpty()) {

                                    /*
                                     * Colocado por Raphael Rossiter e Sávio
                                     * Cavalcante em 30/08/2011 OBJ: Evitar que
                                     * o arquivo seja regerado com apenas uma
                                     * parte dos imóveis micros do condominio.
                                     */
                                    boolean imovelMicroNAOProcessado = true;

                                    if (regerar) {

                                        Integer qtdMovimentoContaPrefaturada = gerarArquivoTextoFaturamento
                                                .pesquisarMovimentoContaPrefaturadaArquivoTextoFaturamento(imovel.getId(), anoMesFaturamento);

                                        if (qtdMovimentoContaPrefaturada.intValue() > 0) {

                                            imovelMicroNAOProcessado = false;
                                        }
                                    }

                                    // Verifica se os imóveis micro tem conta,
                                    // caso não tenha então o imóvel macro não
                                    // vai
                                    // para o condomínio

                                    Iterator iteratorColecaoImoveisMicroConta = colecaoImovelMicro.iterator();

                                    boolean imovelMicroComConta = false;

                                    Imovel imovelMicroConta = null;
                                    Conta contaMicro = null;
                                    while (iteratorColecaoImoveisMicroConta.hasNext()) {

                                        imovelMicroConta = (Imovel) iteratorColecaoImoveisMicroConta.next();

                                        contaMicro = gerarArquivoTextoFaturamento.pesquisarContaGerarArquivoTextoFaturamento(imovelMicroConta,
                                                anoMesFaturamento, faturamentoGrupo.getId());

                                        if (contaMicro != null) {
                                            imovelMicroComConta = true;
                                            break;
                                        }
                                    }

                                    imovelMicroConta = null;
                                    contaMicro = null;

                                    if (imovelMicroComConta && imovelMicroNAOProcessado) {

                                        // inserir o id do imóvel na coleção
                                        // IMOVEIS MACROS dos condomínios
                                        colecaoImoveis.add(imovel);

                                        // GERAR ARQUIVO TEXTO
                                        // --------------------------------------------------------------
                                        if (arquivoTexto != null) {
                                            Object[] registroArquivoTexto = gerarArquivoTextoFaturamento.gerarArquivoTexto(imovel, conta, anoMesFaturamento,
                                                    rota, faturamentoGrupo, sistemaParametro, dataComando);
                                            if (arquivoTexto.length() != 0) {
                                                arquivoTexto.append(System.getProperty("line.separator"));
                                            }
                                            arquivoTexto = arquivoTexto.append(registroArquivoTexto[0]);
                                            int quantidadeRegistroArquivo = (Integer) registroArquivoTexto[1];
                                            tamanhoArquivo = tamanhoArquivo + quantidadeRegistroArquivo;

                                            // verifica se existe número limite
                                            // de imoveis para a Rota.
                                            // se existir, divide o arquivo em
                                            // partes definidas pelo número
                                            // limite de imoveis.
                                            // Sempre observando os Critérios da
                                            // UC0745 no Fluxo 3.2
                                            if (rota.getNumeroLimiteImoveis() != null && !rota.getNumeroLimiteImoveis().equals("")) {

                                                if (arquivoTextoDiv != null) {
                                                    if (arquivoTextoDiv.length() != 0) {
                                                        arquivoTextoDiv.append(System.getProperty("line.separator"));
                                                    }
                                                    arquivoTextoDiv = arquivoTextoDiv.append(registroArquivoTexto[0]);
                                                    int quantidadeRegistroArquivoDiv = (Integer) registroArquivoTexto[1];
                                                    imoveisDivididos.add(imovel.getId());
                                                    tamanhoArquivoDiv = tamanhoArquivoDiv + quantidadeRegistroArquivoDiv;
                                                }
                                            }

                                        }
                                        // ----------------------------------------------------------------------------------

                                        Iterator iteratorColecaoImoveisMicro = colecaoImovelMicro.iterator();

                                        Imovel imovelMicro = null;
                                        while (iteratorColecaoImoveisMicro.hasNext()) {

                                            imovelMicro = (Imovel) iteratorColecaoImoveisMicro.next();
                                            conta = null;

                                            Object[] retornoArquivo = carregarArquivoImpressaoSimultanea(gerarArquivoTextoFaturamento, imovelMicro,
                                                    anoMesFaturamento, rota, faturamentoGrupo, sistemaParametro, dataComando);
                                            int tamanhoArquivoRetorno = 0;
                                            if (retornoArquivo != null && !retornoArquivo.equals("")) {
                                                if (arquivoTexto.length() != 0) {
                                                    arquivoTexto.append(System.getProperty("line.separator"));
                                                }
                                                arquivoTexto.append(retornoArquivo[0]);
                                                tamanhoArquivoRetorno = (Integer) retornoArquivo[1];
                                                tamanhoArquivo = tamanhoArquivo + tamanhoArquivoRetorno;

                                                // verifica se existe número
                                                // limite de imoveis para a
                                                // Rota.
                                                // se existir, divide o arquivo
                                                // em partes definidas pelo
                                                // número limite de imoveis.
                                                // Sempre observando os
                                                // Critérios da UC0745 no Fluxo
                                                // 3.2
                                                if (rota.getNumeroLimiteImoveis() != null && !rota.getNumeroLimiteImoveis().equals("")) {

                                                    if (arquivoTextoDiv.length() != 0) {
                                                        arquivoTextoDiv.append(System.getProperty("line.separator"));
                                                    }
                                                    if (arquivoTextoDiv != null) {
                                                        arquivoTextoDiv.append(retornoArquivo[0]);
                                                        imoveisDivididos.add(imovel.getId());
                                                        tamanhoArquivoDiv = tamanhoArquivoDiv + tamanhoArquivoRetorno;
                                                    }
                                                }
                                            }

                                            // inserir o id do imóvel na coleção
                                            if (tamanhoArquivoRetorno != 0) {
                                                colecaoImoveis.add(imovelMicro);
                                            }
                                        }
                                        // FIM ColecaoImoveisMicro

                                    }// Fim imóvel micro com conta
                                }

                                // PERFORMANCE
                                colecaoImovelMicro = null;

                            }

                        }// FIM do else

                        // Caso exista número limite de imoveis para a Rota e
                        // se o contador numeroImoveisDiv for maior que o número
                        // definido
                        // pelo número limite de imoveis da Rota. Então,
                        // finaliza o arquivoDividido,
                        // gera o ArquivoTextoRoteiroEmpresaDivisao e adiciona
                        // na Coleção colecaoArquivoDivisao.
                        // Em seguida reinicia as variáveis Ultilizadas.
                        // Sempre observando os Critérios da UC0745 no Fluxo 3.2
                        if (rota.getNumeroLimiteImoveis() != null) {
                            /**
                             * Alteracao para corrigir a finalizacao de rotas
                             * divididas - Salvar a qtd de imoveis com conta PF
                             * nas rotas divididas, e não a quantidade de
                             * imóveis na rota - Finalizar a rota por parte do
                             * arquivo e não pelo IMEI do celular
                             */
                            if (imoveisDivididos.size() >= rota.getNumeroLimiteImoveis().intValue()) {

                                Integer qtdArquivosDividido = colecaoArquivoDivisao.size() + 1;
                                Object[] dadosRetorno = this.gerarPassosFinais(gerarArquivoTextoFaturamento, sistemaParametro, imovel, qtdArquivosDividido,
                                        anoMesFaturamento);

                                StringBuilder dadosFinais = new StringBuilder();
                                dadosFinais.append(dadosRetorno[0]);
                                int tamanhoArquivoFinal = (Integer) dadosRetorno[1];
                                tamanhoArquivoFinal = tamanhoArquivoFinal + tamanhoArquivoDiv;

                                StringBuilder arquivoDivCompleto = new StringBuilder();
                                arquivoDivCompleto.append(tamanhoArquivoFinal);
                                arquivoDivCompleto.append(System.getProperty("line.separator"));
                                arquivoDivCompleto.append(arquivoTextoDiv);
                                arquivoDivCompleto.append(dadosFinais);

                                Integer qtdImoveisDivididos = repositorioFaturamento.obterQtdImoveisRotaDivididaComContaPF(anoMesFaturamento, imoveisDivididos);

                                ArquivoTextoRoteiroEmpresaDivisao arquivoDividido = gerarArquivoTextoFaturamento.inserirArquivoTextoRoteiroEmpresaDivisao(
                                        anoMesFaturamento, faturamentoGrupo, rota, imovel, qtdImoveisDivididos, arquivoDivCompleto);

                                arquivoDividido.setNumeroSequenciaArquivo(qtdArquivosDividido);

                                colecaoArquivoDivisao.add(arquivoDividido);

                                qtdImoveisDivididos = 0;
                                imoveisDivididos.clear();

                                // numeroImoveisDiv = 0;
                                tamanhoArquivoDiv = 0;
                                arquivoTextoDiv = null;
                                dadosFinais = null;
                                tamanhoArquivoFinal = 0;
                                dadosRetorno = null;
                                arquivoDivCompleto = null;

                            }
                        }

                    }// FIM DO LOOP DE IMOVEIS

                }// FIM DO LOOP DE IMOVEIS

                /**
                 * Incrementa o nº do indice da páginação
                 */
                numeroIndice = numeroIndice + quantidadeRegistros;

                /**
                 * Caso a coleção de imoveis retornados for menor que a
                 * quantidade de registros seta a flag indicando que a paginação
                 * terminou.
                 */
                if (quantidadeImoveis == 0 || quantidadeImoveis < quantidadeRegistros) {

                    flagTerminou = true;
                }

                if (colecaoImovel != null) {
                    colecaoImovel.clear();
                    colecaoImovel = null;
                }

            }// FIM DO LOOP DA PAGINAÇÃO

            // Se chegar ao final da coleção de imoveis e o número definido
            // pelo número limite de imoveis da Rota ainda não tenha sido
            // alcançado, então:
            // finaliza o arquivoDividido, gera o
            // ArquivoTextoRoteiroEmpresaDivisao e adiciona
            // na Coleção colecaoArquivoDivisao. Em seguida reinicia as
            // variáveis Ultilizadas.
            // Sempre observando os Critérios da UC0745 no Fluxo 3.2
            if (arquivoTextoDiv != null && arquivoTextoDiv.length() > 0) {

                Integer qtdArquivosDividido = colecaoArquivoDivisao.size() + 1;

                Object[] dadosRetorno = this.gerarPassosFinais(gerarArquivoTextoFaturamento, sistemaParametro, imovel, qtdArquivosDividido, anoMesFaturamento);

                StringBuilder dadosFinais = new StringBuilder();
                dadosFinais.append(dadosRetorno[0]);
                int tamanhoArquivoFinal = (Integer) dadosRetorno[1];
                tamanhoArquivoFinal = tamanhoArquivoFinal + tamanhoArquivoDiv;

                StringBuilder arquivoDivCompleto = new StringBuilder();
                arquivoDivCompleto.append(tamanhoArquivoFinal);
                arquivoDivCompleto.append(System.getProperty("line.separator"));
                arquivoDivCompleto.append(arquivoTextoDiv);
                arquivoDivCompleto.append(dadosFinais);

                Integer qtdImoveisDivididos = repositorioFaturamento.obterQtdImoveisRotaDivididaComContaPF(anoMesFaturamento, imoveisDivididos);

                ArquivoTextoRoteiroEmpresaDivisao arquivoDividido = gerarArquivoTextoFaturamento.inserirArquivoTextoRoteiroEmpresaDivisao(anoMesFaturamento,
                        faturamentoGrupo, rota, imovel, qtdImoveisDivididos, arquivoDivCompleto);

                arquivoDividido.setNumeroSequenciaArquivo(qtdArquivosDividido);

                colecaoArquivoDivisao.add(arquivoDividido);

                qtdImoveisDivididos = 0;
                imoveisDivididos.clear();

                // numeroImoveisDiv = 0;
                tamanhoArquivoDiv = 0;
                arquivoTextoDiv = null;
                dadosFinais = null;
                tamanhoArquivoFinal = 0;
                dadosRetorno = null;
                arquivoDivCompleto = null;

            }

            if (arquivoTexto != null && arquivoTexto.length() > 0) {

                Integer qtdArquivosDividido = colecaoArquivoDivisao.size() + 1;

                Object[] dadosRetorno = this.gerarPassosFinais(gerarArquivoTextoFaturamento, sistemaParametro, imovel, qtdArquivosDividido, anoMesFaturamento);

                StringBuilder dadosFinais = new StringBuilder();
                dadosFinais.append(dadosRetorno[0]);
                int tamanhoArquivoFinal = (Integer) dadosRetorno[1];
                tamanhoArquivoFinal = tamanhoArquivoFinal + tamanhoArquivo;

                StringBuilder arquivoCompleto = new StringBuilder();
                arquivoCompleto.append(tamanhoArquivoFinal);
                arquivoCompleto.append(System.getProperty("line.separator"));
                arquivoCompleto.append(arquivoTexto);
                arquivoCompleto.append(dadosFinais);

                // QUEBRA POR ROTA
                if (colecaoImoveis != null && colecaoImoveis.size() > 0) {

                    /*
                     * Alteração feita para salvar no arquivo texto somente a
                     * quantidade de imóveis que possuem conta pré-faturada, e
                     * não a quantidade de imóveis total da rota.
                     */

                    Collection imoveisComContaPF = repositorioFaturamento.obterImoveisComContaPF(anoMesFaturamento, rota);

                    Integer qtdImoveiComContaPF = 0;

                    List<Imovel> imoveisConvertidosComContaPF = this.converterImoveis(imoveisComContaPF, sistemaParametro, faturamentoGrupo, rota);

                    if (imoveisComContaPF != null && !imoveisComContaPF.isEmpty()) {
                        qtdImoveiComContaPF = imoveisConvertidosComContaPF.size();
                    }

                    /*
                     * Verificar se todos os imóveis da rota são apenas
                     * informativos, se forem, gerar o arquivo já finalizado
                     */
                    if (qtdImoveiComContaPF > 0) {
                        rotaSoComImoveisInformativos = false;
                    }

                    Integer idArquivoTextoRoteiroEmpresa = gerarArquivoTextoFaturamento.inserirArquivoTextoRoteiroEmpresa(anoMesFaturamento, faturamentoGrupo,
                            rota, imovel, qtdImoveiComContaPF, arquivoCompleto, regerar, rotaSoComImoveisInformativos);

                    dadosFinais = null;
                    tamanhoArquivoFinal = 0;
                    dadosRetorno = null;

                    Iterator iteratorcolecaoArquivoDivisao = colecaoArquivoDivisao.iterator();

                    ArquivoTextoRoteiroEmpresaDivisao arquivoTextoRoteiroEmpresaDivisao = null;
                    ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = new ArquivoTextoRoteiroEmpresa();
                    arquivoTextoRoteiroEmpresa.setId(idArquivoTextoRoteiroEmpresa);

                    int sequencialArquivo = 0;
                    while (iteratorcolecaoArquivoDivisao.hasNext()) {

                        // adiciona o número sequencial ao objeto
                        // ArquivoTextoRoteiroEmpresaDivisao.
                        arquivoTextoRoteiroEmpresaDivisao = (ArquivoTextoRoteiroEmpresaDivisao) iteratorcolecaoArquivoDivisao.next();

                        arquivoTextoRoteiroEmpresaDivisao.setArquivoTextoRoteiroEmpresa(arquivoTextoRoteiroEmpresa);

                    }

                    // INSERINDO NA BASE OS OBJETOS
                    // ArquivoTextoRoteiroEmpresaDivisao.
                    this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoArquivoDivisao);

                    /**
                     * [SB0004]-Recuperar Dados para inclusao na Tabela
                     */
                    if (colecaoArquivoDivisao != null) {
                        colecaoArquivoDivisao.clear();
                        colecaoArquivoDivisao = null;
                    }

                    if (!regerar) {
                        getControladorMicromedicao().removerMovimentoRoteiroEmpresa(anoMesFaturamento, faturamentoGrupo.getId(), rota);

                        Integer idLeituraTipo = rota.getLeituraTipo().getId();

                        /**
                         * Alteração feita para corrigir o problema de incluir
                         * na tabela Movimento Roteiro Empresa os imóveis
                         * informativos, e não somente os imóveis que geraram
                         * conta PF
                         */
                        Collection<Imovel> colecaoImoveisAGerar = getControladorMicromedicao().verificarImoveisProcessadosEmMovimentoRoteiroEmpresa(
                                imoveisConvertidosComContaPF, faturamentoGrupo.getId(), anoMesFaturamento);

                        getControladorMicromedicao().inserirDadosImoveisMovimentoRoteiroEmpresa(colecaoImoveisAGerar, anoMesFaturamento, sistemaParametro,
                                idLeituraTipo);

                        if (colecaoImoveisAGerar != null) {
                            colecaoImoveisAGerar.clear();
                            colecaoImoveisAGerar = null;
                        }
                    }
                }

                // PERFORMANCE
                arquivoCompleto = null;
            }

            /*
             * Colocado por Raphael Rossiter e Sávio Cavalcante em 30/08/2011
             * OBJ: Evitar que o arquivo seja regerado com apenas uma parte dos
             * imóveis micros do condominio.
             */
            if (regerar && (colecaoImoveis == null || colecaoImoveis.size() == 0)) {

                throw new ControladorException("atencao.nenhum_imovel_selecionado_regeracao");
            }

            // PERFORMANCE
            if (colecaoImoveis != null) {
                colecaoImoveis.clear();
                colecaoImoveis = null;
            }

            // PERFORMANCE
            arquivoTexto = null;
        }

    }

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 03/07/2008
	 * 
	 * @param rota
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public Object[] carregarArquivoImpressaoSimultanea(
			UC0745GerarArquivoTextoFaturamento gerarArquivoTextoFaturamento,
			Imovel imovel, Integer anoMesFaturamento, Rota rota,
			FaturamentoGrupo faturamentoGrupo,
			SistemaParametro sistemaParametro, Date dataComando)
			throws ControladorException {

		StringBuilder arquivoRetorno = null;

		Object[] retorno = null;

		try {
			Conta conta = gerarArquivoTextoFaturamento
					.pesquisarContaGerarArquivoTextoFaturamento(imovel,
							anoMesFaturamento, faturamentoGrupo.getId());

			/*
			 *  Alteração feita para permitir que todos os imóveis sejam gerados na rota de leitura e impressão simultanea
			 */
			if (conta != null) {

				conta.setImovel(imovel);
			}

			retorno = new Object[2];
			arquivoRetorno = new StringBuilder();

			// GERAR ARQUIVO TEXTO
			// --------------------------------------------------------------

			Object[] registroArquivoTexto = gerarArquivoTextoFaturamento
					.gerarArquivoTexto(imovel, conta, anoMesFaturamento, rota,
							faturamentoGrupo, sistemaParametro, dataComando);
			arquivoRetorno.append(registroArquivoTexto[0]);
			int quantidadeRegistroArquivo = (Integer) registroArquivoTexto[1];

			retorno[0] = arquivoRetorno;
			retorno[1] = quantidadeRegistroArquivo;

		} catch (Exception ex) {

			ex.printStackTrace();

			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;

	}

	/**
	 * [UC0877] - EmitirGuiaPagamentoEmAtraso
	 * 
	 * @author Flávio Leonardo
	 * @date 27/01/2009
	 */
	public Collection pesquisarDadosRelatorioGuiaPagamentoEmAtraso(
			FiltroGuiaPagamento filtro) throws ControladorException {

		UC00877EmitirGuiaPagamentoEmAtraso emitirGuiaPagamentoEmAtraso = UC00877EmitirGuiaPagamentoEmAtraso
				.getInstancia(repositorioFaturamento, sessionContext);

		Collection retorno = emitirGuiaPagamentoEmAtraso
				.pesquisarDadosRelatorioGuiaPagamentoEmAtraso(filtro);

		if (retorno.isEmpty()) {
			throw new ControladorException("atencao.relatorio.vazio");
		}

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inclui, na tabela CONTA_CATEGORIA, a(s) categoria(s) e sua(s)
	 * respectiva(s) quantidade(s) de economia da lista do passo 5.8 do fluxo
	 * principal e os atributos retornados pelo [UC0120] para cada categoria,
	 * caso o [UC0120] não tenha sido chamado, os valores correspondentes devem
	 * ser nulos.
	 * 
	 * Caso o [UC0120] não tenha sido chamado não gravar a tabela
	 * CONTA_CATEGORIA_CONSUMO_FAIXA
	 * 
	 * @param calcularValoresConta
	 * @param colecaoCategoria
	 * @param conta
	 * @throws ControladorException
	 */
	public void inserirContaCategoria(
			Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta,
			Collection colecaoCategoriaOuSubcategoria, Conta conta)
			throws ControladorException {
		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (sistemaParametro.getIndicadorTarifaCategoria().equals(
				SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {
			inserirObjetoContaCategoria(calcularValoresConta,
					colecaoCategoriaOuSubcategoria, conta);
		} else {
			inserirObjetoContaSubcategoria(calcularValoresConta,
					colecaoCategoriaOuSubcategoria, conta);
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inclui a quantidade de economias por categoria do débito cobrado na
	 * tabela DEBITO_COBRADO_CATEGORIA
	 * 
	 * @param debitoCobrado
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirDebitoCobradoCategoria(DebitoCobrado debitoCobrado, Collection colecaoCategoriaOuSubcategoria) throws ControladorException {
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		if (sistemaParametro.getIndicadorTarifaCategoria().equals(SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {
			inserirObjetoDebitoCobradoCategoria(debitoCobrado, colecaoCategoriaOuSubcategoria);
		} else {
			inserirObjetoDebitoCobradoSubcategoria(debitoCobrado, colecaoCategoriaOuSubcategoria);
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inclui a quantidade de economias por categoria do crédito realizado na
	 * tabela CREDITO_REALIZADO_CATEGORIA
	 * 
	 * @param creditoRealizado
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirCreditoRealizadoCategoria(
			CreditoRealizado creditoRealizado,
			Collection colecaoCategoriaOuSubcategoria)
			throws ControladorException {
		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (sistemaParametro.getIndicadorTarifaCategoria().equals(
				SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {
			inserirObjetoCreditoRealizadoCategoria(creditoRealizado,
					colecaoCategoriaOuSubcategoria);
		} else {
			inserirObjetoCreditoRealizadoSubcategoria(creditoRealizado,
					colecaoCategoriaOuSubcategoria);
		}
	}

	/**
	 * Monta uma coleção de contas categoria a partir de uma coleção de
	 * categoria recebida
	 * 
	 * @param colecaoCategoria
	 * @param conta
	 * @return
	 */
	public Collection montarColecaoContaCategoria(Collection colecaoCategoriaOuSubcategoria, Conta conta) throws ControladorException {

		Collection retorno = null;

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		if (sistemaParametro.getIndicadorTarifaCategoria().equals(SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {
			retorno = montarColecaoObjetoContaCategoria(colecaoCategoriaOuSubcategoria, conta);
		} else {
			retorno = montarColecaoObjetoContaSubcategoria(colecaoCategoriaOuSubcategoria, conta);
		}

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * 
	 * Inclui, na tabela CONTA_CATEGORIA, a(s) categoria(s) e sua(s)
	 * respectiva(s) quantidade(s) de economia da lista do passo 5.8 do fluxo
	 * principal e os atributos retornados pelo [UC0120] para cada categoria,
	 * caso o [UC0120] não tenha sido chamado, os valores correspondentes devem
	 * ser nulos.
	 * 
	 * Caso o [UC0120] não tenha sido chamado não gravar a tabela
	 * CONTA_CATEGORIA_CONSUMO_FAIXA
	 * 
	 * @param calcularValoresConta
	 * @param colecaoCategoria
	 * @param conta
	 * @throws ControladorException
	 */
	public void inserirObjetoContaSubcategoria(
			Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta,
			Collection colecaoSubcategoria, Conta conta)
			throws ControladorException {

		Subcategoria subCategoria = new Subcategoria();

		ContaCategoriaPK contaCategoriaPK = new ContaCategoriaPK();
		contaCategoriaPK.setConta(conta);

		ContaCategoria contaCategoriaInsert = null;
		calcularValoresConta = calcularValoresAguaEsgotoTotalizando(calcularValoresConta);

		// O [UC0120] não foi invocado, inserir apenas o ID da conta, ID da
		// categoria e qtd de economias da categoria
		if (calcularValoresConta == null || calcularValoresConta.isEmpty()) {

			Iterator colecaoSubcategoriaIt = colecaoSubcategoria.iterator();

			while (colecaoSubcategoriaIt.hasNext()) {

				subCategoria = (Subcategoria) colecaoSubcategoriaIt.next();

				// Adicionando a categoria no objeto ContaCategoriaPK
				contaCategoriaPK.setCategoria(subCategoria.getCategoria());

				// Adicionando a subcategoria no objeto ContaCategoriaPK
				contaCategoriaPK.setSubcategoria(subCategoria);

				// Gerando o objeto ContaCategoria
				contaCategoriaInsert = new ContaCategoria();

				// Comp_id
				contaCategoriaInsert.setComp_id(contaCategoriaPK);

				// Qtd economias da subcategoria
				contaCategoriaInsert.setQuantidadeEconomia(new Short(String
						.valueOf(subCategoria.getQuantidadeEconomias()
								.intValue())).shortValue());

				// Ultima Alteração
				contaCategoriaInsert.setUltimaAlteracao(new Date());

				this.getControladorUtil().inserir(contaCategoriaInsert);
			}
		} else {

			Iterator calcularValoresContaIt = calcularValoresConta.iterator();
			CalcularValoresAguaEsgotoHelper calcularValoresContaObjeto = null;

			FiltroSubCategoria filtroSubCategoria = null;
			Collection colecaoSubcategoriaObterDados = null;

			// Integer idContaCategoriaGerado = null;

			while (calcularValoresContaIt.hasNext()) {

				calcularValoresContaObjeto = (CalcularValoresAguaEsgotoHelper) calcularValoresContaIt
						.next();

				// Esta situação irá retornar o id da subcategoria e não da
				// categoria
				subCategoria.setId(calcularValoresContaObjeto.getIdCategoria());

				/*
				 * Obtendo a categoria da subcategoria selecionada
				 */
				filtroSubCategoria = new FiltroSubCategoria();
				filtroSubCategoria
						.adicionarCaminhoParaCarregamentoEntidade("categoria");

				filtroSubCategoria.adicionarParametro(new ParametroSimples(
						FiltroSubCategoria.ID, subCategoria.getId()));

				colecaoSubcategoriaObterDados = this.getControladorUtil()
						.pesquisar(filtroSubCategoria,
								Subcategoria.class.getName());

				subCategoria = (Subcategoria) Util
						.retonarObjetoDeColecao(colecaoSubcategoriaObterDados);

				// Adicionando a subcategoria no objeto ContaCategoriaPK
				contaCategoriaPK.setSubcategoria(subCategoria);

				// Adicionando a categoria no objeto ContaCategoriaPK
				contaCategoriaPK.setCategoria(subCategoria.getCategoria());

				// Gerando o objeto ContaCategoria
				contaCategoriaInsert = new ContaCategoria();

				// Comp_id
				contaCategoriaInsert.setComp_id(contaCategoriaPK);

				// Qtd economias da categoria
				contaCategoriaInsert.setQuantidadeEconomia(new Short(String
						.valueOf(calcularValoresContaObjeto
								.getQuantidadeEconomiasCategoria().intValue()))
						.shortValue());

				// Valores relacionados aos cálculos de água

				contaCategoriaInsert.setValorAgua(calcularValoresContaObjeto
						.getValorFaturadoAguaCategoria());
				contaCategoriaInsert.setConsumoAgua(calcularValoresContaObjeto
						.getConsumoFaturadoAguaCategoria());
				contaCategoriaInsert
						.setValorTarifaMinimaAgua(calcularValoresContaObjeto
								.getValorTarifaMinimaAguaCategoria());
				contaCategoriaInsert
						.setConsumoMinimoAgua(calcularValoresContaObjeto
								.getConsumoMinimoAguaCategoria());

				// Valores relacionados aos cálculos de esgoto

				contaCategoriaInsert.setValorEsgoto(calcularValoresContaObjeto
						.getValorFaturadoEsgotoCategoria());
				contaCategoriaInsert
						.setConsumoEsgoto(calcularValoresContaObjeto
								.getConsumoFaturadoEsgotoCategoria());
				contaCategoriaInsert
						.setValorTarifaMinimaEsgoto(calcularValoresContaObjeto
								.getValorTarifaMinimaEsgotoCategoria());
				contaCategoriaInsert
						.setConsumoMinimoEsgoto(calcularValoresContaObjeto
								.getConsumoMinimoEsgotoCategoria());

				// Ultima Alteração
				contaCategoriaInsert.setUltimaAlteracao(new Date());

				this.getControladorUtil().inserir(contaCategoriaInsert);

				// Inserindo na tabela CONTA_CATEGORIA_CONSUMO_FAIXA
				this.inserirContaCategoriaConsumoFaixa(contaCategoriaInsert,
						calcularValoresContaObjeto.getFaixaTarifaConsumo());

			}
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 17/04/2007
	 * 
	 * Inclui a quantidade de economias por categoria do débito cobrado na
	 * tabela DEBITO_COBRADO_CATEGORIA
	 * 
	 * @param debitoCobrado
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirObjetoDebitoCobradoSubcategoria(
			DebitoCobrado debitoCobrado, Collection colecaoSubcategoria)
			throws ControladorException {

		// =============================================================================

		Collection colecaoCategoria = Util
				.montarColecaoCategoria(colecaoSubcategoria);

		// =============================================================================

		// [UC0185] - Obter Valor Por Categoria
		Collection valorPorCategoria = this.getControladorImovel()
				.obterValorPorCategoria(colecaoCategoria,
						debitoCobrado.getValorPrestacao());

		Iterator colecaoCategoriaIt = colecaoCategoria.iterator();
		Iterator colecaoValorPorCategoriaIt = valorPorCategoria.iterator();
		Categoria categoriaColecao;

		while (colecaoCategoriaIt.hasNext()) {
			categoriaColecao = (Categoria) colecaoCategoriaIt.next();

			// Gerando o objeto DebitoCobradoCategoriaPK
			DebitoCobradoCategoriaPK debitoCobradoCategoriaPKInserir = new DebitoCobradoCategoriaPK();
			// Categoria
			// debitoCobradoCategoriaPKInserir.setCategoria(categoriaColecao);
			debitoCobradoCategoriaPKInserir.setCategoriaId(categoriaColecao
					.getId());

			// Debito Cobrado
			// debitoCobradoCategoriaPKInserir.setDebitoCobrado(debitoCobrado);
			debitoCobradoCategoriaPKInserir.setDebitoCobradoId(debitoCobrado
					.getId());

			// Gerando o objeto que será inserido no BD
			DebitoCobradoCategoria debitoCobradoCategoriaInserir = new DebitoCobradoCategoria();

			// Comp_ID
			debitoCobradoCategoriaInserir
					.setComp_id(debitoCobradoCategoriaPKInserir);

			// Quantidade de economias da categoria
			debitoCobradoCategoriaInserir
					.setQuantidadeEconomia(categoriaColecao
							.getQuantidadeEconomiasCategoria());

			// Última alteração
			debitoCobradoCategoriaInserir.setUltimaAlteracao(new Date());

			// Valor categoria
			debitoCobradoCategoriaInserir
					.setValorCategoria((BigDecimal) colecaoValorPorCategoriaIt
							.next());

			// INSERINDO...
			this.getControladorUtil().inserir(debitoCobradoCategoriaInserir);
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 17/04/2007
	 * 
	 * Inclui a quantidade de economias por categoria do crédito realizado na
	 * tabela CREDITO_REALIZADO_CATEGORIA
	 * 
	 * @param creditoRealizado
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirObjetoCreditoRealizadoSubcategoria(
			CreditoRealizado creditoRealizado, Collection colecaoSubcategoria)
			throws ControladorException {

		// =============================================================================

		Collection colecaoCategoria = Util
				.montarColecaoCategoria(colecaoSubcategoria);

		// =============================================================================

		// [UC0185] - Obter Valor Por Categoria
		Collection valorPorCategoria = this.getControladorImovel()
				.obterValorPorCategoria(colecaoCategoria,
						creditoRealizado.getValorCredito());

		Iterator colecaoCategoriaIt = colecaoCategoria.iterator();
		Iterator colecaoValorPorCategoriaIt = valorPorCategoria.iterator();
		Categoria categoriaColecao;

		while (colecaoCategoriaIt.hasNext()) {
			categoriaColecao = (Categoria) colecaoCategoriaIt.next();

			// Gerando o objeto CreditoRealizadoCategoriaPK
			CreditoRealizadoCategoriaPK creditoRealizadoCategoriaPKInserir = new CreditoRealizadoCategoriaPK();
			// Categoria
			creditoRealizadoCategoriaPKInserir.setCategoria(categoriaColecao);
			// Crédito Realizado
			creditoRealizadoCategoriaPKInserir
					.setCreditoRealizado(creditoRealizado);

			// Gerando o objeto que será inserido no BD
			CreditoRealizadoCategoria creditoRealizadoCategoriaInserir = new CreditoRealizadoCategoria();

			// Comp_ID
			creditoRealizadoCategoriaInserir
					.setComp_id(creditoRealizadoCategoriaPKInserir);

			// Quantidade de economias da categoria
			creditoRealizadoCategoriaInserir
					.setQuantidadeEconomia(categoriaColecao
							.getQuantidadeEconomiasCategoria());

			// Última alteração
			creditoRealizadoCategoriaInserir.setUltimaAlteracao(new Date());

			// Valor categoria
			creditoRealizadoCategoriaInserir
					.setValorCategoria((BigDecimal) colecaoValorPorCategoriaIt
							.next());

			// INSERINDO...
			this.getControladorUtil().inserir(creditoRealizadoCategoriaInserir);
		}
	}

	/**
	 * [UC0641] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * @author Rafael Corrêa
	 * @date 10/07/2008
	 * 
	 * @throws ErroRepositorioException
	 */
	public TarefaRelatorio gerarRelatorioFaturas(List items,
			Usuario usuarioLogado, String tipoRelatorio) {

		Collection colecaoFaturaClienteResponsavel = this
				.gerarColecaoFaturaClienteResponsavel(items);

		RelatorioFaturaClienteResponsavel relatorio = new RelatorioFaturaClienteResponsavel(
				usuarioLogado);

		relatorio.addParametro("colecaoFaturaClienteResponsavelHelper",
				colecaoFaturaClienteResponsavel);

		if (tipoRelatorio == null) {
			tipoRelatorio = TarefaRelatorio.TIPO_PDF + "";
		}

		relatorio.addParametro("tipoFormatoRelatorio",
				Integer.parseInt(tipoRelatorio));

		return relatorio;

	}

	public Collection gerarColecaoFaturaClienteResponsavel(List items) {

		Collection retorno = new ArrayList();

		FileItem item = null;
		String nomeItem = null;

		// Parse the request
		InputStreamReader reader = null;
		BufferedReader buffer = null;
		try {

			Iterator iter = items.iterator();
			while (iter.hasNext()) {

				item = (FileItem) iter.next();

				// verifica se não é diretorio
				if (!item.isFormField()) {
					// coloca o nome do item para maiusculo
					nomeItem = item.getName().toUpperCase();
					// compara o final do nome do arquivo é .txt
					if (nomeItem.endsWith(".TXT")) {

						// abre o arquivo
						reader = new InputStreamReader(item.getInputStream());

						buffer = new BufferedReader(reader);

						// cria uma variavel do tipo boolean
						boolean eof = false;

						FaturaClienteResponsavelHelper faturaClienteResponsavelHelper = null;

						// enquanto a variavel for false
						while (!eof) {
							// pega a linha do arquivo
							String linhaLida = buffer.readLine();

							// se for a ultima linha do arquivo
							if (linhaLida == null
									|| linhaLida.trim().length() == 0) {
								// seta a variavel boolean para true
								eof = true;
							} else {

								faturaClienteResponsavelHelper = new FaturaClienteResponsavelHelper();

								// 1-Numero da Fatura (Campo 1 do TXT)
								faturaClienteResponsavelHelper
										.setNumeroFatura(linhaLida.substring(0,
												9).trim());

								// 2-Responsavel pelo Pagamento (Campo 2 do TXT)
								faturaClienteResponsavelHelper
										.setNomeCliente(linhaLida.substring(9,
												59).trim());

								// 3-Endereco de Correspondencia - Parte 1
								// (Campo 3.1 do TXT)
								faturaClienteResponsavelHelper
										.setEndereco(linhaLida.substring(59,
												159).trim());

								// 4-Bairro (Campo 3.2.1 do TXT)
								faturaClienteResponsavelHelper
										.setEnderecoLinha2(linhaLida.substring(
												159, 189).trim());

								// 5,6,7-Municipio,UF,CEP (Campo
								// 3.2.2,3.2.3,3.2.4 do TXT)
								String enderecoLinha3 = linhaLida.substring(
										189, 219).trim()
										+ " "
										+ linhaLida.substring(219, 221).trim()
										+ " "
										+ linhaLida.substring(221, 230).trim();

								faturaClienteResponsavelHelper
										.setEnderecoLinha3(enderecoLinha3);

								// 8-Tipo do Cliente (Campo 5 do TXT)
								faturaClienteResponsavelHelper
										.setTipoResponsavel(linhaLida
												.substring(237, 287).trim());

								// 9-Quantidade Itens da Fatura (Campo 6 do TXT)
								faturaClienteResponsavelHelper
										.setQtdeItens(linhaLida.substring(287,
												291).trim());

								// 10-Data de Emissao (Campo 7 do TXT)
								faturaClienteResponsavelHelper
										.setDataEmissao(linhaLida.substring(
												291, 301).trim());

								// 11-Mês/Ano (Campo 4 do TXT)
								faturaClienteResponsavelHelper
										.setMesAno(linhaLida
												.substring(230, 237).trim());

								// 12-Data de Vencimento (Campo 8 do TXT)
								// Nesse caso pega o primeiro vencimento da
								// fatura dos vencimento alternativos
								// Anterior - linhaLida.substring(301, 311)
								faturaClienteResponsavelHelper
										.setPrimeiroVencimento(linhaLida
												.substring(709, 719).trim());

								// 13-Turbidez Valor Medio (Campo 13 do TXT)
								faturaClienteResponsavelHelper
										.setValorMedioTurbidez(linhaLida
												.substring(499, 504).trim());

								// 14-Turbidez Valor Padrao (Campo 14 do TXT)
								faturaClienteResponsavelHelper
										.setPadraoTurbidez(linhaLida.substring(
												504, 524).trim());

								// 15-Ph Valor Medio (Campo 15 do TXT)
								faturaClienteResponsavelHelper
										.setValorMedioPh(linhaLida.substring(
												524, 529).trim());

								// 16-Ph Valor Padrao (Campo 16 do TXT)
								faturaClienteResponsavelHelper
										.setPadraoPh(linhaLida.substring(529,
												549).trim());

								// 17-Cor Valor Medio (Campo 17 do TXT)
								faturaClienteResponsavelHelper
										.setValorMedioCor(linhaLida.substring(
												549, 554).trim());

								// 18-Cor Valor Padrao (Campo 18 do TXT)
								faturaClienteResponsavelHelper
										.setPadraoCor(linhaLida.substring(554,
												574).trim());

								// 19-Cloro Valor Medio (Campo 19 do TXT)
								faturaClienteResponsavelHelper
										.setValorMedioCloro(linhaLida
												.substring(574, 579).trim());

								// 20-Cloro Valor Padrao (Campo 20 do TXT)
								faturaClienteResponsavelHelper
										.setPadraoCloro(linhaLida.substring(
												579, 599).trim());

								// 21-Fluor Valor Medio (Campo 21 do TXT)
								faturaClienteResponsavelHelper
										.setValorMedioFluor(linhaLida
												.substring(599, 604).trim());

								// 22-Fluor Valor Padrao (Campo 22 do TXT)
								faturaClienteResponsavelHelper
										.setPadraoFluor(linhaLida.substring(
												604, 624).trim());

								// 23-Ferro Valor Medio (Campo 23 do TXT)
								faturaClienteResponsavelHelper
										.setValorMedioFerro(linhaLida
												.substring(624, 629).trim());

								// 24-Ferro Valor Padrao(Campo 24 do TXT)
								faturaClienteResponsavelHelper
										.setPadraoFerro(linhaLida.substring(
												629, 649).trim());

								// 25-Coliformes Totais Valor Medio (Campo 25 do
								// TXT)
								faturaClienteResponsavelHelper
										.setValorMedioColiformesTotais(linhaLida
												.substring(649, 659));

								// 26-Coliformes Totais Valor Padrao (Campo 26
								// do TXT)
								faturaClienteResponsavelHelper
										.setPadraoColiformesTotais(linhaLida
												.substring(659, 679).trim());

								// 27-Coliformes Fecais Valor Medio (Campo 27 do
								// TXT)
								faturaClienteResponsavelHelper
										.setValorMedioColiformesfecais(linhaLida
												.substring(679, 689).trim());

								// 28-Coliformes Fecais Valor Padrao (Campo 28
								// do TXT)
								faturaClienteResponsavelHelper
										.setPadraoColiformesfecais(linhaLida
												.substring(689, 709).trim());

								// 29-Vencimento Alternativo 1
								// 30-Vencimento Alternativo 2
								// 31-Vencimento Alternativo 3
								// 32-Vencimento Alternativo 4
								// 33-Vencimento Alternativo 5
								// 34-Vencimento Alternativo 6

								// São as data de vencimento
								String datasVencimentos = linhaLida.substring(
										709, 719).trim()
										+ " "
										+ linhaLida.substring(719, 729).trim()
										+ " "
										+ linhaLida.substring(729, 739).trim()
										+ " "
										+ linhaLida.substring(739, 749).trim()
										+ " "
										+ linhaLida.substring(749, 759).trim()
										+ " "
										+ linhaLida.substring(759, 769).trim();

								faturaClienteResponsavelHelper
										.setDatasVencimentos(datasVencimentos);

								Collection<FaturaItemClienteResponsavelHelper> colecaoFaturaItem = new ArrayList();

								// 35-Nome do Usuario (Campo 13.1 do TXT)
								// 36-Matrícula do Imóvel (Campo 13.2 do TXT)
								// 37-Consumo (Campo 13.3 do TXT)
								// 38-Valor da Conta (Campo 13.4 do TXT)
								int quantidade = 0;
								int quantidadeItensPorFatura = FaturaItem.QTD_ITENS_RELATORIO_FATURA
										.intValue();

								for (int i = 0; i < quantidadeItensPorFatura; i++) {

									int index1 = 769 + quantidade;

									int index2 = index1 + 50;
									int index3 = index2 + 9;
									int index4 = index3 + 9;
									int index5 = index4 + 14;

									String nome = linhaLida.substring(index1,
											index2).trim();

									if (!nome.equals("")) {
										FaturaItemClienteResponsavelHelper faturaItemClienteResponsavelHelper = new FaturaItemClienteResponsavelHelper();

										faturaItemClienteResponsavelHelper
												.setNome(nome);
										faturaItemClienteResponsavelHelper
												.setMatricula(linhaLida
														.substring(index2,
																index3).trim());
										faturaItemClienteResponsavelHelper
												.setConsumo(linhaLida
														.substring(index3,
																index4).trim());
										faturaItemClienteResponsavelHelper
												.setValor(linhaLida.substring(
														index4, index5).trim());

										colecaoFaturaItem
												.add(faturaItemClienteResponsavelHelper);
									} else {
										break;
									}

									quantidade = quantidade + 82;
								}

								faturaClienteResponsavelHelper
										.setColecaoFaturaItemClienteResponsavelHelper(colecaoFaturaItem);

								// Só gera codigo de barras se existir valor
								// nesse campo

								// 17-Codigo de Barras Formatado (Campo 11 do
								// TXT)
								String codigoBarrasGerado = linhaLida
										.substring(387, 499).trim();
								boolean gerarCodigoBarras = false;
								if (!codigoBarrasGerado.equals("")) {
									gerarCodigoBarras = true;
								}

								if (gerarCodigoBarras) {

									// 16-Somatorio do Valor Total(Campo 9 do
									// TXT)
									faturaClienteResponsavelHelper
											.setValorTotalAPagar(linhaLida
													.substring(311, 325).trim());

									String codigoBarraFormatado = linhaLida
											.substring(332, 387).trim();
									faturaClienteResponsavelHelper
											.setRepresentacaoNumericaCodBarraFormatada(codigoBarraFormatado);

									// Representação numerica cod barra sem
									// digito
									String codigoBarra = codigoBarraFormatado
											.substring(0, 11)
											+ codigoBarraFormatado.substring(
													14, 25)
											+ codigoBarraFormatado.substring(
													28, 39)
											+ codigoBarraFormatado.substring(
													42, 53);

									faturaClienteResponsavelHelper
											.setRepresentacaoNumericaCodBarraSemDigito(codigoBarra);
									faturaClienteResponsavelHelper
											.setIndicadorCodigoBarras("S");

									// 17-Valor Bruto(Campo 36 do TXT)
									faturaClienteResponsavelHelper
											.setValorBruto(linhaLida.substring(
													2409, 2423).trim());

									// 18-Valor Impostos(Campo 37 do TXT)
									faturaClienteResponsavelHelper
											.setValorImposto(linhaLida
													.substring(2423, 2437)
													.trim());
								} else {
									// 16-Somatorio do Valor Total(Campo 9 do
									// TXT)
									faturaClienteResponsavelHelper
											.setValorTotalAPagar("CONTINUA...");
									faturaClienteResponsavelHelper
											.setIndicadorCodigoBarras(null);

								}

								retorno.add(faturaClienteResponsavelHelper);
							}
						}// fim do while eof
					} else {
						throw new ActionServletException(
								"atencao.tipo_importacao.nao_txt");
					}
				}
			}

		} catch (IOException ex) {
			throw new ActionServletException("erro.importacao.nao_concluida");
		} finally {
			IoUtil.fecharStream(buffer);
			IoUtil.fecharStream(reader);
		}

		return retorno;

	}

	/**
	 * [UC0641] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * @author Rafael Corrêa
	 * @date 10/07/2008
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection<RelatorioFaturasAgrupadasBean> pesquisarDadosRelatorioFaturasAgrupadas(
			Integer anoMesReferencia, Cliente cliente,
			Collection<Integer> idsClientes) throws ControladorException {

		Collection<RelatorioFaturasAgrupadasBean> retorno = new ArrayList<RelatorioFaturasAgrupadasBean>();

		Collection<Object[]> colecaoDadosRelatorio = new ArrayList<Object[]>();

		try {
			colecaoDadosRelatorio = repositorioFaturamento
					.pesquisarDadosRelatorioFaturasAgrupadas(anoMesReferencia,
							cliente, idsClientes);

			// Verifica se existe débitos a realizar
			if (colecaoDadosRelatorio != null
					&& !colecaoDadosRelatorio.isEmpty()) {

				Integer idResponsavelAnterior = null;
				BigDecimal valorTotal = new BigDecimal(0);
				Integer qtdFaturasResponsavel = null;

				BigDecimal percentualAliquota = this
						.pesquisarPercentualAliquota();

				for (Object[] dadosRelatorio : colecaoDadosRelatorio) {

					RelatorioFaturasAgrupadasBean relatorioFaturasAgrupadasBean = new RelatorioFaturasAgrupadasBean();

					Integer idFatura = 0;
					String referencia = "";
					Integer anoMes = null;
					Integer idResponsavel = null;
					// BigDecimal valorDebito = null;
					Integer sequencialFatura = null;

					// Id do Cliente Responsável
					if (dadosRelatorio[0] != null) {
						idResponsavel = (Integer) dadosRelatorio[0];
						relatorioFaturasAgrupadasBean
								.setIdResponsavel(idResponsavel);

						if (idResponsavelAnterior == null) {
							idResponsavelAnterior = idResponsavel;
							qtdFaturasResponsavel = repositorioFaturamento
									.pesquisarQuantidadeFaturasReponsavel(
											anoMesReferencia, idResponsavel);
						} else if (!idResponsavel.equals(idResponsavelAnterior)) {
							idResponsavelAnterior = idResponsavel;
							valorTotal = new BigDecimal(0);
							qtdFaturasResponsavel = repositorioFaturamento
									.pesquisarQuantidadeFaturasReponsavel(
											anoMesReferencia, idResponsavel);
						}

						// Endereço Responsável
						String enderecoResponsavel = getControladorEndereco()
								.pesquisarEnderecoClienteAbreviado(
										idResponsavel);

						if (enderecoResponsavel != null) {
							relatorioFaturasAgrupadasBean
									.setEnderecoResponsavel(enderecoResponsavel);
						} else {
							relatorioFaturasAgrupadasBean
									.setEnderecoResponsavel("");
						}
					}

					// Nome do Cliente Responsável
					if (dadosRelatorio[1] != null) {
						relatorioFaturasAgrupadasBean
								.setNomeResponsavel((String) dadosRelatorio[1]);
					}

					// Id da Fatura
					if (dadosRelatorio[2] != null) {
						idFatura = ((Integer) dadosRelatorio[2]);
					}

					// Ano/Mês de Referência
					if (dadosRelatorio[3] != null) {
						anoMes = (Integer) dadosRelatorio[3];
						referencia = Util.formatarAnoMesParaMesAno(anoMes);
						relatorioFaturasAgrupadasBean.setReferencia(referencia);
					}

					// Data de Emissão
					if (dadosRelatorio[4] != null) {
						relatorioFaturasAgrupadasBean.setEmissao(Util
								.formatarData((Date) dadosRelatorio[4]));

					}

					// Data de Vencimento
					if (dadosRelatorio[5] != null) {
						relatorioFaturasAgrupadasBean.setVencimento(Util
								.formatarData((Date) dadosRelatorio[5]));

					}

					// Valor Imposto
					if (dadosRelatorio[6] != null) {

						relatorioFaturasAgrupadasBean
								.setRetencao((BigDecimal) dadosRelatorio[6]);

						if (relatorioFaturasAgrupadasBean.getRetencao()
								.compareTo(new BigDecimal("0.00")) == 0) {

							relatorioFaturasAgrupadasBean
									.setPercentualAliquota(new BigDecimal(
											"0.00"));
						} else {

							relatorioFaturasAgrupadasBean
									.setPercentualAliquota(percentualAliquota);
						}

					} else {

						relatorioFaturasAgrupadasBean
								.setRetencao(new BigDecimal(0));

						relatorioFaturasAgrupadasBean
								.setPercentualAliquota(new BigDecimal("0.00"));
					}

					// Valor Débito
					/*
					 * if (dadosRelatorio[7] != null) { valorDebito =
					 * ((BigDecimal) dadosRelatorio[7]); }
					 */

					// Sequencial Fatura
					if (dadosRelatorio[8] != null) {
						sequencialFatura = ((Integer) dadosRelatorio[8]);
					}

					// Id do Imóvel
					if (dadosRelatorio[9] != null) {
						Integer idImovel = (Integer) dadosRelatorio[9];
						relatorioFaturasAgrupadasBean.setMatricula(idImovel
								.toString());

						// Endereço Imóvel
						String endereco = getControladorEndereco()
								.pesquisarEndereco(idImovel);
						relatorioFaturasAgrupadasBean
								.setEnderecoUsuario(endereco);
					}

					// Nome do Cliente Usuário

					/**
					 * Nome do imóvel no relatório de faturas agrupadas.
					 * 
					 * @author Wellington Rocha
					 * @date 26/11/2012
					 */
					if (dadosRelatorio[21] != null) {
						String nomeImovel = (String) dadosRelatorio[21];
						if (!nomeImovel.equals("")) {
							relatorioFaturasAgrupadasBean
									.setNomeUsuario(nomeImovel);
						} else if (dadosRelatorio[10] != null) {
							relatorioFaturasAgrupadasBean
									.setNomeUsuario((String) dadosRelatorio[10]);
						}

					} else if (dadosRelatorio[10] != null) {
						relatorioFaturasAgrupadasBean
								.setNomeUsuario((String) dadosRelatorio[10]);
					}

					// Id da Unidade de Negócio
					if (dadosRelatorio[11] != null) {
						relatorioFaturasAgrupadasBean
								.setUnidade(((Integer) dadosRelatorio[11])
										.toString());
					}

					// Localidade
					if (dadosRelatorio[12] != null) {
						Integer idLocalidade = (Integer) dadosRelatorio[12];
						String descricaoLocalidade = (String) dadosRelatorio[13];

						relatorioFaturasAgrupadasBean.setSistema(idLocalidade
								+ " - " + descricaoLocalidade);
					}

					// Hidrômetro
					if (dadosRelatorio[14] != null) {
						relatorioFaturasAgrupadasBean
								.setHidrometro((String) dadosRelatorio[14]);
					}

					// Tipo
					if (dadosRelatorio[15] != null) {
						relatorioFaturasAgrupadasBean
								.setTipo((String) dadosRelatorio[15]);
					}

					// Leitura
					if (dadosRelatorio[16] != null) {
						relatorioFaturasAgrupadasBean
								.setLeitura(((Integer) dadosRelatorio[16])
										.toString());
					} else {
						relatorioFaturasAgrupadasBean.setLeitura("");
					}

					// Consumo
					if (dadosRelatorio[17] != null) {
						relatorioFaturasAgrupadasBean
								.setConsumo(((Integer) dadosRelatorio[17])
										.toString());
					}

					// Valor
					if (dadosRelatorio[18] != null) {
						BigDecimal valor = (BigDecimal) dadosRelatorio[18];
						relatorioFaturasAgrupadasBean.setValor(valor);

						Integer indicadorContaHist = (Integer) dadosRelatorio[19];
						if (indicadorContaHist != null
								&& indicadorContaHist == 2) {

							valorTotal = valorTotal.add(valor);
						}

					}

					// Indicador Conta Historico
					if (dadosRelatorio[19] != null) {
						Integer indicadorContaHist = (Integer) dadosRelatorio[19];
						relatorioFaturasAgrupadasBean
								.setIndicadorContaHist(indicadorContaHist);

					}

					// Id da Fatura Item
					if (dadosRelatorio[20] != null) {

						relatorioFaturasAgrupadasBean
								.setIdFaturaItem((Integer) dadosRelatorio[20]);
					}

					// Número Fatura
					relatorioFaturasAgrupadasBean.setNumeroFatura(idResponsavel
							+ " - " + referencia);

					// Controle
					int ano = Util.obterAno(anoMes);
					relatorioFaturasAgrupadasBean.setControle(ano + " / "
							+ idFatura);

					// Total de Itens de Faturas do Responsável
					relatorioFaturasAgrupadasBean
							.setTotalFaturasResponsavel(qtdFaturasResponsavel);

					// Valor Total
					relatorioFaturasAgrupadasBean.setValorTotal(valorTotal);
					relatorioFaturasAgrupadasBean.setValorTotalExtenso(Util
							.valorExtenso(valorTotal));

					// Código de Barras
					Integer digitoVerificador = Util
							.obterDigitoVerificadorModulo10(referencia.replace(
									"/", ""));

					String codigoBarras = getControladorArrecadacao()
							.obterRepresentacaoNumericaCodigoBarra(
									// Tipo do Pagamento / Valor
									7, valorTotal,

									// Localidade / Imóvel
									null, null,

									// Referência / Dígito Verificador
									referencia.replace("/", ""),
									digitoVerificador,

									// Tipo do Débito / Ano Emissão Guia
									null, null,

									// Sequencial Documento de Cobrança /
									// Tipo
									// do Documento
									null, null,

									// Cliente / Sequencial Fatura Cliente
									// Responsável
									idResponsavel, sequencialFatura,

									// Id Guia
									null);

					relatorioFaturasAgrupadasBean.setCodigoBarras(codigoBarras);
					relatorioFaturasAgrupadasBean.setCodigoBarrasFormatado(Util
							.formatarCodigoBarra(codigoBarras));

					String representacaoNumericaCodBarraFormatada = codigoBarras
							.substring(0, 11)
							+ "-"
							+ codigoBarras.substring(11, 12)
							+ " "
							+ codigoBarras.substring(12, 23)
							+ "-"
							+ codigoBarras.substring(23, 24)
							+ " "
							+ codigoBarras.substring(24, 35)
							+ "-"
							+ codigoBarras.substring(35, 36)
							+ " "
							+ codigoBarras.substring(36, 47)
							+ "-"
							+ codigoBarras.substring(47, 48);

					String representacaoNumericaCodBarraSemDigito = codigoBarras
							.substring(0, 11)
							+ codigoBarras.substring(12, 23)
							+ codigoBarras.substring(24, 35)
							+ codigoBarras.substring(36, 47);

					relatorioFaturasAgrupadasBean
							.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);

					relatorioFaturasAgrupadasBean
							.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

					// ID DA FATURA
					relatorioFaturasAgrupadasBean.setIdFatura(idFatura
							.toString());

					retorno.add(relatorioFaturasAgrupadasBean);

				}

			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC0641] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * @author Rafael Corrêa
	 * @date 10/07/2008
	 * 
	 * @throws ControladorException
	 */
	public Integer pesquisarDadosRelatorioFaturasAgrupadasCount(
			Integer anoMesReferencia, Cliente cliente,
			Collection<Integer> idsClientes) throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarDadosRelatorioFaturasAgrupadasCount(
							anoMesReferencia, cliente, idsClientes);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0641] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * Pesquisa os clientes associados as faturas de uma determinada esfera de
	 * porder
	 * 
	 * @author Rafael Corrêa
	 * @date 21/01/2009
	 * 
	 * @throws ControladorException
	 */
	public Collection pesquisarClientesFaturas(Integer idEsferaPoder)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarClientesFaturas(idEsferaPoder);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0352] - Emitir TXT de Fatura de Cliente Responsável
	 * 
	 * Pesquisa o percentual de retenção
	 * 
	 * @author Rafael Corrêa
	 * @date 12/07/2008
	 * 
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarPercentualAliquota() throws ControladorException {

		BigDecimal retorno = null;

		try {
			retorno = this.repositorioFaturamento.pesquisarPercentualAliquota();

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * [UCXXXX] - Relatório de Protocolo de Entrega de Faturas
	 * 
	 * @author Rafael Corrêa
	 * @date 12/11/2008
	 * 
	 * @throws ControladorException
	 */
	public Collection<RelatorioProtocoloEntregaFaturaBean> pesquisarDadosRelatorioProtocoloEntregaFatura(
			Integer anoMesReferencia, Cliente cliente,
			Collection<Integer> idsClientes) throws ControladorException {

		Collection<RelatorioProtocoloEntregaFaturaBean> retorno = new ArrayList<RelatorioProtocoloEntregaFaturaBean>();

		Collection<Object[]> colecaoDadosRelatorio = new ArrayList<Object[]>();

		try {
			colecaoDadosRelatorio = repositorioFaturamento
					.pesquisarDadosRelatorioProtocoloEntregaFatura(
							anoMesReferencia, cliente, idsClientes);

			// Verifica se existe débitos a realizar
			if (colecaoDadosRelatorio != null
					&& !colecaoDadosRelatorio.isEmpty()) {

				for (Object[] dadosRelatorio : colecaoDadosRelatorio) {

					RelatorioProtocoloEntregaFaturaBean relatorioProtocoloEntregaFaturaBean = new RelatorioProtocoloEntregaFaturaBean();

					// Id do Cliente Responsável
					if (dadosRelatorio[0] != null) {
						Integer idResponsavel = (Integer) dadosRelatorio[0];

						relatorioProtocoloEntregaFaturaBean
								.setCodigo(idResponsavel.toString());

						// Endereço Responsável
						String enderecoResponsavel = getControladorEndereco()
								.pesquisarEnderecoClienteAbreviado(
										idResponsavel);
						if (enderecoResponsavel != null) {
							relatorioProtocoloEntregaFaturaBean
									.setEndereco(enderecoResponsavel);
						} else {
							relatorioProtocoloEntregaFaturaBean.setEndereco("");
						}
					}

					// Nome do Cliente Responsável
					if (dadosRelatorio[1] != null) {
						relatorioProtocoloEntregaFaturaBean
								.setNome((String) dadosRelatorio[1]);
					}

					// Referência
					if (dadosRelatorio[2] != null) {
						Integer referencia = (Integer) dadosRelatorio[2];
						relatorioProtocoloEntregaFaturaBean.setReferencia(Util
								.formatarAnoMesParaMesAno(referencia));
					}

					// Data de Vencimento
					if (dadosRelatorio[3] != null) {
						relatorioProtocoloEntregaFaturaBean.setVencimento(Util
								.formatarData((Date) dadosRelatorio[3]));

					}

					retorno.add(relatorioProtocoloEntregaFaturaBean);

				}

			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC0153] - Apresentar Dados Para Análise da Medição e Consumo
	 * 
	 * Pesquisa a situação especial de faturamento vigente do mês/ano informada
	 * 
	 * @author Rafael Corrêa
	 * @date 11/08/2008
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoSituacaoHistorico> pesquisarSituacaoEspecialFaturamentoVigente(
			Integer idImovel, Integer anoMesReferencia)
			throws ControladorException {

		Collection<FaturamentoSituacaoHistorico> retorno = new ArrayList<FaturamentoSituacaoHistorico>();

		Collection<Object[]> colecaoDados = null;

		try {

			colecaoDados = repositorioFaturamento
					.pesquisarSituacaoEspecialFaturamentoVigente(idImovel,
							anoMesReferencia);

			if (colecaoDados != null && !colecaoDados.isEmpty()) {

				for (Object[] dados : colecaoDados) {

					FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = new FaturamentoSituacaoHistorico();

					// Tipo da Situação Especial de Faturamento
					if (dados[0] != null) {
						FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
						faturamentoSituacaoTipo.setDescricao((String) dados[0]);

						faturamentoSituacaoHistorico
								.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
					}

					// Motivo da Situação Especial de Faturamento
					if (dados[1] != null) {
						FaturamentoSituacaoMotivo faturamentoSituacaoMotivo = new FaturamentoSituacaoMotivo();
						faturamentoSituacaoMotivo
								.setDescricao((String) dados[1]);

						faturamentoSituacaoHistorico
								.setFaturamentoSituacaoMotivo(faturamentoSituacaoMotivo);
					}

					// Mês/Ano Início
					if (dados[2] != null) {
						faturamentoSituacaoHistorico
								.setAnoMesFaturamentoSituacaoInicio((Integer) dados[2]);
					}

					// Mês/Ano Fim
					if (dados[3] != null) {
						faturamentoSituacaoHistorico
								.setAnoMesFaturamentoSituacaoFim((Integer) dados[3]);
					}

					// Usuário
					if (dados[4] != null) {
						Usuario usuario = new Usuario();
						usuario.setNomeUsuario((String) dados[4]);

						faturamentoSituacaoHistorico.setUsuario(usuario);
					}

					retorno.add(faturamentoSituacaoHistorico);

				}
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;

	}

	/**
	 * [UC0857] - Gerar Relatório de Arrecadação das Multas de Autos de Infração
	 * 
	 * Pesquisa os dados necessários para geração do relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 10/09/2008
	 * @param idUnidadeNegocio
	 *            , idFuncionario, dataPagamentoInicial, dataPagamentoFinal
	 * @throws ControladorException
	 */
	public Collection<RelatorioAutoInfracaoBean> pesquisarDadosRelatorioAutoInfracao(
			Integer idUnidadeNegocio, Integer idFuncionario,
			Integer dataPagamentoInicial, Integer dataPagamentoFinal)
			throws ControladorException {

		Collection<RelatorioAutoInfracaoBean> retorno = new ArrayList<RelatorioAutoInfracaoBean>();

		Collection<Object[]> colecaoDados = null;

		try {

			colecaoDados = repositorioFaturamento
					.pesquisarDadosRelatorioAutoInfracao(idUnidadeNegocio,
							idFuncionario, dataPagamentoInicial,
							dataPagamentoFinal);

			if (colecaoDados != null && !colecaoDados.isEmpty()) {

				for (Object[] dados : colecaoDados) {

					RelatorioAutoInfracaoBean relatorioAutoInfracaoBean = new RelatorioAutoInfracaoBean();

					// Unidade de Negócio
					if (dados[0] != null) {
						Integer idUnidadeNegocioRelatorio = (Integer) dados[0];
						String nomeUnidadeNegocio = (String) dados[1];

						String unidadeNegocio = idUnidadeNegocioRelatorio
								+ " - " + nomeUnidadeNegocio;

						relatorioAutoInfracaoBean
								.setUnidadeNegocio(unidadeNegocio);
					}

					// Funcionário
					if (dados[2] != null) {
						Integer idFuncionarioRelatorio = (Integer) dados[2];
						String nomeFuncionario = (String) dados[3];

						String funcionario = idFuncionarioRelatorio + " - "
								+ nomeFuncionario;

						relatorioAutoInfracaoBean.setFuncionario(funcionario);
					}

					// Data do Pagamento
					if (dados[4] != null) {
						Date dataPagamento = (Date) dados[4];

						relatorioAutoInfracaoBean.setDataPagamento(Util
								.formatarData(dataPagamento));
					}

					// Auto de Infração
					if (dados[5] != null) {
						Integer autoInfracao = (Integer) dados[5];

						relatorioAutoInfracaoBean.setAutoInfracao(autoInfracao
								.toString());
					}

					// Descrição do Serviço
					if (dados[6] != null) {
						String descricaoServico = (String) dados[6];

						relatorioAutoInfracaoBean
								.setDescricaoServico(descricaoServico);
					}
					// qtdParcelasPaga
					if (dados[8] != null) {
						Integer parcelaPaga = (Integer) dados[8];

						relatorioAutoInfracaoBean.setParcelaPaga(parcelaPaga
								+ "");
					}
					// qtdParcelas
					if (dados[9] != null) {
						Integer qtdParcelas = (Integer) dados[9];

						relatorioAutoInfracaoBean.setQtdParcelas(qtdParcelas
								+ "");
					}
					// valorParcelaPaga
					if (dados[10] != null) {
						BigDecimal valorPago = (BigDecimal) dados[10];

						relatorioAutoInfracaoBean
								.setValorParcelaPaga(valorPago);
					}

					// Valor do Serviço
					if (dados[7] != null) {
						BigDecimal valorServico = (BigDecimal) dados[7];

						relatorioAutoInfracaoBean.setValorServico(valorServico);
					}

					// Valor do Funcionário
					if (dados[11] != null) {
						BigDecimal valorFuncionario = (BigDecimal) dados[11];

						relatorioAutoInfracaoBean
								.setValorFuncionario(valorFuncionario);
					}

					// Matrícula do Imóvel
					if (dados[12] != null) {
						Integer idImovel = (Integer) dados[12];

						relatorioAutoInfracaoBean.setMatricula(idImovel
								.toString());
					}

					// Nome do Cliente Usuário
					if (dados[13] != null) {
						String nomeUsuario = (String) dados[13];

						relatorioAutoInfracaoBean.setNomeCliente(nomeUsuario);
					}

					retorno.add(relatorioAutoInfracaoBean);

				}
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * [UC0194] Inserir Credito a Realizar
	 * 
	 * Pesquisa a quantidade de contas e contas histórico para um imóvel em uma
	 * referência
	 * 
	 * @author Rafael Corrêa
	 * @date 14/08/2008
	 * 
	 * @param idImovel
	 * @param referenciaConta
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasEContasHistorico(Integer idImovel,
			Integer referenciaConta) throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarQuantidadeContasEContasHistorico(idImovel,
							referenciaConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Monta uma coleção de contas categoria a partir de uma coleção de
	 * categoria recebida
	 * 
	 * @param colecaoCategoria
	 * @param conta
	 * @return
	 */
	public Collection montarColecaoObjetoContaSubcategoria(
			Collection colecaoSubcategoria, Conta conta) {
		Iterator colecaoSubcategoriaIt = colecaoSubcategoria.iterator();
		Collection<ContaCategoria> colecaoContaCategoria = new ArrayList();

		while (colecaoSubcategoriaIt.hasNext()) {

			Subcategoria subcategoria = new Subcategoria();

			subcategoria = (Subcategoria) colecaoSubcategoriaIt.next();

			ContaCategoriaPK contaCategoriaPK = new ContaCategoriaPK();
			contaCategoriaPK.setConta(conta);
			contaCategoriaPK.setSubcategoria(subcategoria);

			// Adicionando a categoria no objeto ContaCategoriaPK
			contaCategoriaPK.setCategoria(subcategoria.getCategoria());

			// Gerando o objeto ContaCategoria
			ContaCategoria contaCategoriaInsert = new ContaCategoria();

			// Comp_id
			contaCategoriaInsert.setComp_id(contaCategoriaPK);

			// Qtd economias da categoria
			contaCategoriaInsert.setQuantidadeEconomia(new Short(String
					.valueOf(subcategoria.getQuantidadeEconomias().intValue()))
					.shortValue());

			// Ultima Alteração
			contaCategoriaInsert.setUltimaAlteracao(new Date());

			colecaoContaCategoria.add(contaCategoriaInsert);
		}
		return colecaoContaCategoria;
	}

	/**
	 * retorna o maior valor entre o ano/mês da data corrente e o ano/mês de
	 * referencia do faturamento (PARM_AMREFERENCIAFATURAMENTO da tabela
	 * SISTEMA_PARAMETROS) e o ano/mes de referencia da conta
	 * (CNTA_AMREFERENCIACONTA)
	 * 
	 * @author Vivianne Sousa
	 * @date 16/06/2008
	 */
	public Integer obterReferenciaContabilConta(SistemaParametro sistemaParametro, Integer anoMesReferenciaConta) throws ControladorException {

		Integer anoMesCorrente = Util.getAnoMesComoInteger(new Date());
		Integer anoMesFaturamento = sistemaParametro.getAnoMesFaturamento();
		Integer referenciaContabil = anoMesFaturamento;

		if (anoMesCorrente.compareTo(anoMesFaturamento) == 1) {
			referenciaContabil = anoMesCorrente;
		}

		if (anoMesReferenciaConta.compareTo(referenciaContabil) == 1) {
			referenciaContabil = anoMesReferenciaConta;
		}

		return referenciaContabil;
	}

	/**
	 * Verificar se esse grupo de Faturamento já está comandado
	 * 
	 * @author: Victor Cisneiros
	 * @date: 30/09/2008
	 */
	public Boolean verificarGrupoFaturamentoComandado(
			int anoMesReferenciaFaturamento, int idGrupoFaturamento)
			throws ControladorException {

		try {
			return repositorioFaturamento.verificarGrupoFaturamentoComandado(
					anoMesReferenciaFaturamento, idGrupoFaturamento);
		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 19/09/2008
	 */
	public Date obterDataValidade2ViaConta(EmitirContaHelper emitirContaHelper)
			throws ControladorException {

		Date dataValidade = null;

		try {

			if (emitirContaHelper.getDataValidadeConta().compareTo(new Date()) == 1) {
				dataValidade = emitirContaHelper.getDataValidadeConta();

			} else {
				// soma 60 dias a data atual
				Date dataValidadeConta = Util.adicionarNumeroDiasDeUmaData(
						new Date(), 60);

				int ano = Util.getAno(dataValidadeConta);
				int mes = Util.getMes(dataValidadeConta);
				Calendar calendar = new GregorianCalendar();
				calendar.set(Calendar.MONTH, mes - 1);
				calendar.set(Calendar.YEAR, ano);

				Collection colecaoNacionalFeriado = getControladorUtil()
						.pesquisarFeriadosNacionais();

				Collection colecaoDatasFeriados = new ArrayList();
				Iterator iterNacionalFeriado = colecaoNacionalFeriado
						.iterator();
				while (iterNacionalFeriado.hasNext()) {
					NacionalFeriado nacionalFeriado = (NacionalFeriado) iterNacionalFeriado
							.next();
					colecaoDatasFeriados.add(nacionalFeriado.getData());
				}

				calendar.set(Calendar.DAY_OF_MONTH, Util.obterUltimoDiaUtilMes(
						mes, ano, colecaoDatasFeriados));

				dataValidadeConta = calendar.getTime();

				dataValidade = dataValidadeConta;

			}

		} catch (ControladorException e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

		return dataValidade;

	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 */
	public Collection obterDebitoACobrarImovel(Integer imovelID)
			throws ControladorException {

		try {
			return repositorioFaturamento.obterDebitoACobrarImovel(imovelID);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 */
	public Collection obterDebitoACobrarHistoricoImovel(Integer imovelID)
			throws ControladorException {

		try {
			return repositorioFaturamento
					.obterDebitoACobrarHistoricoImovel(imovelID);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 11/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterCreditoARealizarImovel(Integer imovelID)
			throws ControladorException {

		try {
			return repositorioFaturamento.obterCreditoARealizarImovel(imovelID);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 11/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterCreditoARealizarHistoricoImovel(Integer imovelID)
			throws ControladorException {

		try {
			return repositorioFaturamento
					.obterCreditoARealizarHistoricoImovel(imovelID);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterGuiaPagamentoImovel(Integer imovelID)
			throws ControladorException {

		try {
			return repositorioFaturamento.obterGuiaPagamentoImovel(imovelID);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0193] - Consultar Histórico de Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2008
	 * 
	 * @param imovelID
	 */
	public Collection obterGuiaPagamentoHistoricoImovel(Integer imovelID)
			throws ControladorException {

		try {
			return repositorioFaturamento
					.obterGuiaPagamentoHistoricoImovel(imovelID);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * [UC0871] Manter Fatura de Cliente Responsável
	 * 
	 * Inserir Fatura Item e Fatura Item Historico Flávio Leonardo
	 * 
	 */
	public int inserirFaturaItemFaturaItemHistorico(
			Collection<FaturaItem> colecaoFaturaItem, Usuario usuarioLogado)
			throws ControladorException {
		int retorno = 0;
		try {
			if (colecaoFaturaItem != null) {
				Iterator iterator = colecaoFaturaItem.iterator();

				Integer sequencia = 0;

				while (iterator.hasNext()) {
					FaturaItem faturaItem = (FaturaItem) iterator.next();

					if (sequencia.intValue() == 0) {
						try {
							sequencia = repositorioFaturamento
									.maximoNumeroSequenciaFaturaItem(faturaItem
											.getFatura()) + 1;
						} catch (ErroRepositorioException e) {
							throw new ControladorException("erro.sistema", e);
						}
					} else {
						sequencia++;
					}

					if (faturaItem.getId() == null) {
						// inserir fatura Item
						faturaItem.setUltimaAlteracao(new Date());
						faturaItem.setItemSequencia(sequencia);
						getControladorUtil().inserir(faturaItem);

						// inserir fatura Item Historico
						FaturaItemHistorico faturaItemHistorico = new FaturaItemHistorico(
								faturaItem, usuarioLogado);
						faturaItemHistorico.setUltimaAlteracao(new Date());
						faturaItemHistorico.setItemSequencia(sequencia);
						BigDecimal valorImpostos = BigDecimal.ZERO;
						if (faturaItem.getContaGeral().getConta() != null
								&& faturaItem.getContaGeral().getConta()
										.getValorImposto() != null) {
							valorImpostos = faturaItem.getContaGeral()
									.getConta().getValorImposto();
						} else if (faturaItem.getContaGeral()
								.getContaHistorico() != null
								&& faturaItem.getContaGeral()
										.getContaHistorico().getValorImposto() != null) {
							valorImpostos = faturaItem.getContaGeral()
									.getContaHistorico().getValorImposto();
						}
						faturaItemHistorico.setValorImposto(valorImpostos);
						faturaItemHistorico.setIndicadorOperacao(new Integer(
								"1"));
						getControladorUtil().inserir(faturaItemHistorico);
						retorno++;
					}
				}
			}
		} catch (ControladorException e) {
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC0871] Manter Fatura de Cliente Responsável
	 * 
	 * Remover Fatura Item e Inserir Fatura Item Historico Flávio Leonardo
	 * 
	 */
	public void removerFaturaItemFaturaItemHistorico(
			Collection<FaturaItem> colecaoFaturaItemRemover,
			Usuario usuarioLogado) throws ControladorException {

		try {
			if (colecaoFaturaItemRemover != null) {
				Iterator iterator = colecaoFaturaItemRemover.iterator();

				Integer sequencia = 0;

				while (iterator.hasNext()) {
					FaturaItem faturaItem = (FaturaItem) iterator.next();

					if (sequencia.intValue() == 0) {
						try {
							sequencia = repositorioFaturamento
									.maximoNumeroSequencia(faturaItem
											.getFatura()) + 1;
						} catch (ErroRepositorioException e) {
							throw new ControladorException("erro.sistema", e);
						}
					} else {
						sequencia++;
					}

					// inserir fatura Item Historico
					FaturaItemHistorico faturaItemHistorico = new FaturaItemHistorico(
							faturaItem, usuarioLogado);
					faturaItemHistorico.setUltimaAlteracao(new Date());
					faturaItemHistorico.setItemSequencia(sequencia);
					BigDecimal valorImpostos = BigDecimal.ZERO;
					if (faturaItem.getContaGeral().getConta() != null
							&& faturaItem.getContaGeral().getConta()
									.getValorImposto() != null) {
						valorImpostos = faturaItem.getContaGeral().getConta()
								.getValorImposto();
					} else if (faturaItem.getContaGeral().getContaHistorico() != null
							&& faturaItem.getContaGeral().getContaHistorico()
									.getValorImposto() != null) {
						valorImpostos = faturaItem.getContaGeral()
								.getContaHistorico().getValorImposto();
					}
					faturaItemHistorico.setValorImposto(valorImpostos);
					faturaItemHistorico.setIndicadorOperacao(new Integer("2"));

					getControladorUtil().inserir(faturaItemHistorico);

					// remover faturaItem
					getControladorUtil().remover(faturaItem);
				}
			}
		} catch (ControladorException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0871] Manter Fatura de Cliente Responsável
	 */
	public BigDecimal somarValorFaturasItemFatura(Fatura fatura)
			throws ControladorException {
		try {
			return repositorioFaturamento.somarValorFaturasItemFatura(fatura);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0871] Manter Fatura de Cliente Responsável
	 */
	public Date vencimentoFaturasItemFatura(Fatura fatura)
			throws ControladorException {
		try {
			return repositorioFaturamento.vencimentoFaturasItemFatura(fatura);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0871] Manter Fatura de Cliente Responsável
	 * 
	 * @param fatura
	 * @throws ErroRepositorioException
	 */
	public void alterarVencimentoFaturaFaturaItem(Fatura fatura)
			throws ControladorException {
		try {
			repositorioFaturamento.alterarVencimentoFaturaFaturaItem(fatura);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 01/12/2008
	 * 
	 * @param codigoCliente
	 * @param dataVencimentoInformada
	 * @param anoMes
	 * @param dataVencimentoContaInicio
	 * @param dataVencimentoContaFim
	 * @param anoMesFim
	 * @throws ControladorException
	 */
	public void alterarVencimentoConjuntoFaturaCliente(Integer codigoCliente,
			Date dataVencimentoInformada, Integer anoMes,
			Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
			Integer anoMesFim, Integer codigoClienteSuperior)
			throws ControladorException {

		Collection colecaoFaturasManutencao = new ArrayList();

		try {

			colecaoFaturasManutencao = repositorioFaturamento
					.pesquisarFaturasCliente(codigoCliente, anoMes,
							dataVencimentoContaInicio, dataVencimentoContaFim,
							anoMesFim, codigoClienteSuperior);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoFaturasManutencao != null
				&& !colecaoFaturasManutencao.isEmpty()) {

			Iterator colecaoFaturasManutencaoIterator = colecaoFaturasManutencao
					.iterator();

			while (colecaoFaturasManutencaoIterator.hasNext()) {

				Fatura fatura = (Fatura) colecaoFaturasManutencaoIterator
						.next();

				this.alterarVencimentoFatura(fatura, dataVencimentoInformada);

			}
		}
	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 01/12/2008
	 * 
	 * @param fatura
	 * @param dataVencimentoInformada
	 * @throws ControladorException
	 */
	public void alterarVencimentoFatura(Fatura fatura,
			Date dataVencimentoInformada) throws ControladorException {

		// VENCIMENTO
		fatura.setVencimento(dataVencimentoInformada);

		// VALIDADE
		Date dataValidadeFatura = this
				.retornaDataValidadeConta(dataVencimentoInformada);
		fatura.setValidade(dataValidadeFatura);

		// ULTIMA ALTERACAO
		fatura.setUltimaAlteracao(new Date());

		try {

			repositorioFaturamento.alterarVencimentoFatura(fatura);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisar categoria por tarifa consumo
	 * 
	 * @author Rômulo Aurélio
	 * @date 19/12/2008
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCategoriaPorTarifaConsumo(Integer idConsumoTarifa)
			throws ControladorException {

		Collection retorno = null;

		try {

			retorno = repositorioFaturamento
					.pesquisarCategoriaPorTarifaConsumo(idConsumoTarifa);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * É necessário colocar a query abaixo no processo de faturar grupo como uma
	 * funcionalidade (Antes de rodar o faturar), para atender uma necessidade
	 * de uma localidade (Petrolina), onde existe uma cobrança diferenciada de
	 * esgoto. CRC771 - Socorro Oliveira
	 * 
	 * UPDATE atendimentopublico.ligacao_esgoto set lesg_pcalternativo = 50.00,
	 * lesg_nnconsumopcalternativo = 20 WHERE lesg_id in ( select im.imov_id
	 * from cadastro.imovel im INNER JOIN cadastro.quadra qdra on (qdra.qdra_id
	 * = im.qdra_id) INNER JOIN micromedicao.rota rota on (rota.rota_id =
	 * qdra.rota_id) INNER JOIN cadastro.imovel_subcategoria ims on (im.imov_id
	 * = ims.imov_id) WHERE rota.rota_id = ? AND im.loca_id = 111 AND im.last_id
	 * in (3,4,5) AND im.lest_id = 3 AND ims.scat_id < 20) AND
	 * lesg_nnconsumopcalternativo is null;
	 * 
	 * @author Raphael Rossiter
	 * @date 22/12/2008
	 * 
	 * @param rota
	 * @param atividade
	 * @throws ControladorException
	 */
	protected void atualizarLigacaoEsgotoPorRota(Rota rota, int atividade)
			throws ControladorException {

	}

	/**
	 * [UC0876] - Gerar Crédito Situação Especial Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 22/01/2009
	 * 
	 * @param colecaoFaturamentoAtividadeCronogramaRota
	 * @param faturamentoGrupo
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void gerarCreditoSituacaoEspecialFaturamento(
			Collection colecaoFaturamentoAtividadeCronogramaRota,
			FaturamentoGrupo faturamentoGrupo, int atividade,
			int idFuncionalidadeIniciada) throws ControladorException {

		int idUnidadeIniciada = 0;

		// PROCESSO BATCH
		// ------------------------------------------------------------------------------------
		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(
						idFuncionalidadeIniciada,
						UnidadeProcessamento.ROTA,
						((FaturamentoAtivCronRota) Util
								.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRota))
								.getRota().getId());
		// ---------------------------------------------------------------------------------------------------

		try {

			UC0876GerarCreditoSituacaoEspecialFaturamento gerarCreditoSituacaoEspecialFaturamento = UC0876GerarCreditoSituacaoEspecialFaturamento
					.getInstancia(repositorioFaturamento, sessionContext);

			SistemaParametro sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();

			/*
			 * Caso a coleção de atividade de faturamento de cronograma para
			 * rota não esteja nula para cada rota informada seleciona as
			 * quadras da rota e para cada quadra os imóveis
			 */
			if (colecaoFaturamentoAtividadeCronogramaRota != null
					&& !colecaoFaturamentoAtividadeCronogramaRota.isEmpty()) {

				// Objeto que armazenará as informações para deleção dos
				// créditos
				ApagarDadosFaturamentoHelper helper = new ApagarDadosFaturamentoHelper();

				// Caso a atividade seja de gerar dados para leitura, a situação
				// fica como pré-faturada
				if (atividade == FaturamentoAtividade.GERAR_ARQUIVO_LEITURA) {
					helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.PRE_FATURADA);
				} else {
					helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.NORMAL);
				}

				helper.setIdCreditoTipo(CreditoTipo.CREDITO_NITRATO);

				Iterator iteratorColecaoFaturamentoAtividadeCronogramaRota = colecaoFaturamentoAtividadeCronogramaRota
						.iterator();

				// LAÇO PARA GERAR CRÉDITO PARA TODAS AS ROTAS
				while (iteratorColecaoFaturamentoAtividadeCronogramaRota
						.hasNext()) {

					FaturamentoAtivCronRota faturamentoAtivCronRota = (FaturamentoAtivCronRota) iteratorColecaoFaturamentoAtividadeCronogramaRota
							.next();

					/*
					 * Processa só as rotas de impressão simultânea caso a
					 * atividade seja o de gerar dados para leitura.
					 * 
					 * Caso a atividade seja da faturar grupo, então processa
					 * normalmente
					 * 
					 * Analista: Sávio Luiz em 10/06/2010
					 */
					if (atividade == FaturamentoAtividade.GERAR_ARQUIVO_LEITURA
							.intValue()) {
						if (faturamentoAtivCronRota.getRota() != null
								&& !faturamentoAtivCronRota
										.getRota()
										.getLeituraTipo()
										.getId()
										.equals(LeituraTipo.LEITURA_E_ENTRADA_SIMULTANEA)) {
							break;
						}
					}

					helper.setRota(faturamentoAtivCronRota.getRota());
					helper.setAnoMesFaturamento(faturamentoGrupo
							.getAnoMesReferencia());

					// APAGAR DADOS GERADOS PARA A ROTA NO ANO/MES DE REFERENCIA
					// DA GERAÇÃO DOS CRÉDITOS
					// =================================================================================================

					// Caso a atividade não seja de gerar dados para leitura, a
					// situação fica como pré-faturada
					if (atividade != FaturamentoAtividade.GERAR_ARQUIVO_LEITURA) {

						helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.PRE_FATURADA);
						gerarCreditoSituacaoEspecialFaturamento
								.apagarDadosGeradosCreditoSituacaoEspecialFaturamento(helper);

						helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.NORMAL);
						gerarCreditoSituacaoEspecialFaturamento
								.apagarDadosGeradosCreditoSituacaoEspecialFaturamento(helper);

					} else {

						gerarCreditoSituacaoEspecialFaturamento
								.apagarDadosGeradosCreditoSituacaoEspecialFaturamento(helper);
						helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.PRE_FATURADA);

					}

					// =================================================================================================

					// Variáveis para a paginação da pesquisa de Imovel por
					// Grupo Faturamento
					// ========================================================================
					boolean flagTerminou = false;
					final int quantidadeRegistros = 500;
					int numeroIndice = 0;
					// ========================================================================

					while (!flagTerminou) {

						Collection colecaoImovel = this
								.pesquisarImovelGrupoFaturamento(
										faturamentoAtivCronRota.getRota(),
										numeroIndice, quantidadeRegistros,
										false, false);

						/*
						 * Caso exista ids de imóveis para a rota atual
						 * determina a geração do crédito para cada imóvel
						 * retornado.
						 */
						if (colecaoImovel != null && !colecaoImovel.isEmpty()) {

							Iterator iteratorColecaoImoveis = colecaoImovel
									.iterator();

							// LAÇO PARA GERAR O CRÉDITO DE TODOS OS IMOVEIS DA
							// ROTA ATUAL
							Imovel imovel = null;
							while (iteratorColecaoImoveis.hasNext()) {

								imovel = (Imovel) iteratorColecaoImoveis.next();

								// GERAÇÃO CRÉDITO
								// --------------------------------------------------------------------------------
								gerarCreditoSituacaoEspecialFaturamento
										.gerarCreditoSituacaoEspecialFaturamentoImovel(
												imovel, faturamentoGrupo,
												sistemaParametro, atividade);
								// --------------------------------------------------------------------------------

							}// FIM DO LOOP DE IMOVEIS

						}// FIM DO LOOP DE IMOVEIS

						/**
						 * Incrementa o nº do indice da páginação
						 */
						numeroIndice = numeroIndice + quantidadeRegistros;

						/**
						 * Caso a coleção de imoveis retornados for menor que a
						 * quantidade de registros seta a flag indicando que a
						 * paginação terminou.
						 */
						if (colecaoImovel == null
								|| colecaoImovel.size() < quantidadeRegistros) {

							flagTerminou = true;
						}

						if (colecaoImovel != null) {
							colecaoImovel.clear();
							colecaoImovel = null;
						}

					}// FIM DO LOOP DA PAGINAÇÃO
				}
			} else {
				// A LISTA COM AS ROTAS ESTÁ NULA OU VAZIA

				throw new ControladorException(
						"atencao.pesquisa.grupo_rota_vazio");
			}

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) {

			/*
			 * Este catch serve para interceptar qualquer exceção que o processo
			 * batch venha a lançar e garantir que a unidade de processamento do
			 * batch será atualizada com o erro ocorrido.
			 */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0157] - Simular Cálculo da Conta
	 * 
	 * [SB0001] - Determinar consumo mínimo por área
	 * 
	 * @author Rafael Corrêa, Mariana Victor
	 * @date 26/03/2009, 23/05/2011
	 * 
	 * @throws ControladorException
	 */
	public Integer calcularConsumoMinimo(BigDecimal areaTotal, Integer anoMes,
			Collection<Categoria> colecaoCategoria,
			Collection<Subcategoria> colecaoSubcategoria,
			BigDecimal pontosUtilizacao, BigDecimal numeroMoradores)
			throws ControladorException {

		Integer retorno = null;

		Integer qtdEconomias = this.calcularQuantidadeEconomias(
				colecaoCategoria, colecaoSubcategoria);

		if (qtdEconomias != null && qtdEconomias.intValue() != 0) {
			if (areaTotal != null) {
				// 1.2. Caso a área tenha sido informada

				BigDecimal area = areaTotal.divide(
						new BigDecimal(qtdEconomias), 2, RoundingMode.HALF_UP);

				if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
					retorno = new Integer(0);

					for (Categoria categoria : colecaoCategoria) {
						Integer consumoCategoria = getControladorMicromedicao()
								.pesquisarConsumoMinimoArea(area, anoMes, null,
										categoria);

						Integer qtdEconomiasCategoria = null;

						if (categoria.getFatorEconomias() != null) {
							qtdEconomiasCategoria = categoria
									.getFatorEconomias().intValue();
						} else {
							qtdEconomiasCategoria = categoria
									.getQuantidadeEconomiasCategoria();
						}

						retorno = retorno
								+ (consumoCategoria * qtdEconomiasCategoria);
					}
				}

				if (colecaoSubcategoria != null
						&& !colecaoSubcategoria.isEmpty()) {
					retorno = new Integer(0);

					for (Subcategoria subcategoria : colecaoSubcategoria) {
						Integer consumoSubcategoria = getControladorMicromedicao()
								.pesquisarConsumoMinimoArea(area, anoMes,
										subcategoria, null);

						Integer qtdEconomiasSubcategoria = null;

						if (subcategoria.getCategoria().getFatorEconomias() != null) {
							qtdEconomiasSubcategoria = subcategoria
									.getCategoria().getFatorEconomias()
									.intValue();
						} else {
							qtdEconomiasSubcategoria = subcategoria
									.getQuantidadeEconomias();
						}

						retorno = retorno
								+ (consumoSubcategoria * qtdEconomiasSubcategoria);
					}

				}
			} else if (pontosUtilizacao != null) {
				// 1.3. Caso os pontos de utilização do imóvel tenha sido
				// informado

				// 1.3.1. Caso as subcategorias tenham sido informadas
				if (colecaoSubcategoria != null
						&& !colecaoSubcategoria.isEmpty()) {
					retorno = new Integer(0);

					for (Subcategoria subcategoria : colecaoSubcategoria) {
						Integer consumoSubcategoria = getControladorMicromedicao()
								.pesquisarConsumoMinimoParametro(
										pontosUtilizacao, anoMes, subcategoria,
										null);

						Integer qtdEconomiasSubcategoria = null;

						if (subcategoria.getCategoria().getFatorEconomias() != null) {
							qtdEconomiasSubcategoria = subcategoria
									.getCategoria().getFatorEconomias()
									.intValue();
						} else {
							qtdEconomiasSubcategoria = subcategoria
									.getQuantidadeEconomias();
						}

						retorno = retorno
								+ (consumoSubcategoria * qtdEconomiasSubcategoria);
					}
				} else { // 1.3.2. Caso contrário; para cada categoria
							// informada:
					retorno = new Integer(0);

					for (Categoria categoria : colecaoCategoria) {
						Integer consumoCategoria = getControladorMicromedicao()
								.pesquisarConsumoMinimoParametro(
										pontosUtilizacao, anoMes, null,
										categoria);

						Integer qtdEconomiasCategoria = null;

						if (categoria.getFatorEconomias() != null) {
							qtdEconomiasCategoria = categoria
									.getFatorEconomias().intValue();
						} else {
							qtdEconomiasCategoria = categoria
									.getQuantidadeEconomiasCategoria();
						}

						retorno = retorno
								+ (consumoCategoria * qtdEconomiasCategoria);
					}
				}
			} else if (numeroMoradores != null) {
				// 1.4. Caso o número de moradores do imóvel tenha sido
				// informado
				// 1.4.1. Caso as subcategorias tenham sido informadas
				if (colecaoSubcategoria != null
						&& !colecaoSubcategoria.isEmpty()) {
					retorno = new Integer(0);

					for (Subcategoria subcategoria : colecaoSubcategoria) {
						Integer consumoSubcategoria = getControladorMicromedicao()
								.pesquisarConsumoMinimoParametro(
										numeroMoradores, anoMes, subcategoria,
										null);

						Integer qtdEconomiasSubcategoria = null;

						if (subcategoria.getCategoria().getFatorEconomias() != null) {
							qtdEconomiasSubcategoria = subcategoria
									.getCategoria().getFatorEconomias()
									.intValue();
						} else {
							qtdEconomiasSubcategoria = subcategoria
									.getQuantidadeEconomias();
						}

						retorno = retorno
								+ (consumoSubcategoria * qtdEconomiasSubcategoria);
					}
				} else { // 1.4.2. Caso contrário; para cada categoria informada
					retorno = new Integer(0);

					for (Categoria categoria : colecaoCategoria) {
						Integer consumoCategoria = getControladorMicromedicao()
								.pesquisarConsumoMinimoParametro(
										numeroMoradores, anoMes, null,
										categoria);

						Integer qtdEconomiasCategoria = null;

						if (categoria.getFatorEconomias() != null) {
							qtdEconomiasCategoria = categoria
									.getFatorEconomias().intValue();
						} else {
							qtdEconomiasCategoria = categoria
									.getQuantidadeEconomiasCategoria();
						}

						retorno = retorno
								+ (consumoCategoria * qtdEconomiasCategoria);
					}
				}

			}
		}
		return retorno;
	}

	/**
	 * [UC0157] - Simular Cálculo da Conta
	 * 
	 * @author Rafael Corrêa
	 * @date 26/03/2009
	 * 
	 */
	private Integer calcularQuantidadeEconomias(
			Collection<Categoria> colecaoCategoria,
			Collection<Subcategoria> colecaoSubcategoria) {
		Integer retorno = new Integer(0);

		if (colecaoCategoria != null && !colecaoCategoria.isEmpty()) {
			for (Categoria categoria : colecaoCategoria) {
				if (categoria.getFatorEconomias() != null) {
					retorno = retorno + categoria.getFatorEconomias();
				} else {
					retorno = retorno
							+ categoria.getQuantidadeEconomiasCategoria();
				}
			}
		}

		if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {
			for (Subcategoria subcategoria : colecaoSubcategoria) {
				if (subcategoria.getCategoria().getFatorEconomias() != null) {
					retorno = retorno
							+ subcategoria.getCategoria().getFatorEconomias();
				} else {
					retorno = retorno + subcategoria.getQuantidadeEconomias();
				}
			}
		}

		return retorno;
	}

	/**
	 * Consultar Leituras Não Registradas
	 * 
	 * @author Vinicius Medeiros
	 * @date 11/03/2009
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection retornarLeiturasNaoRegistradas(
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		Collection retorno = new ArrayList();

		try {

			Collection resultado = repositorioFaturamento
					.retornaLeiturasNaoRegistradas(faturamentoGrupo);

			if (resultado != null && !resultado.isEmpty()) {

				Iterator it = resultado.iterator();

				Object[] objeto = null;
				LeiturasNaoRegistradasHelper helper = null;

				while (it.hasNext()) {
					objeto = (Object[]) it.next();
					Localidade localidade = null;
					SetorComercial setorComercial = null;

					helper = new LeiturasNaoRegistradasHelper();

					if (objeto[0] != null) {
						localidade = new Localidade();
						localidade.setId((Integer) objeto[0]);
						localidade.setDescricao((String) objeto[1]);
						helper.setLocalidade(localidade);
					}

					if (objeto[2] != null) {
						setorComercial = new SetorComercial();
						setorComercial.setId((Integer) objeto[2]);
						setorComercial.setDescricao((String) objeto[3]);
						helper.setSetorComercial(setorComercial);
					}

					if (objeto[4] != null) {
						helper.setCodigoRota((Short) objeto[4]);
					}

					if (objeto[5] != null) {
						helper.setValorTotalImoveis((Integer) objeto[5]);
					}

					retorno.add(helper);
				}
			} else {
				throw new ControladorException(
						"atencao.nao_possui_leituras_nao_registradas");
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * [SB0005] - Obter Valor do Parcelamento Concedido como Bonus
	 * 
	 * @author Raphael Rossiter
	 * @date 24/03/2009
	 * 
	 * @param idLocalidade
	 * @param idCategoria
	 * @return
	 * @throws ControladorException
	 */
	private BigDecimal obterValorParcelamentoConcedidoBonus(int idLocalidade,
			int idCategoria) throws ControladorException {

		BigDecimal diferenca = BigDecimal.ZERO;
		BigDecimal valorDebitoACobrarParcelamentoConcedidoBonus = null;
		BigDecimal valorCreditoARealizarParcelamentoConcedidoBonus = null;

		try {

			// Acumulando debitos a cobrar
			valorDebitoACobrarParcelamentoConcedidoBonus = repositorioFaturamento
					.acumularValorDebitoACobrarParcelamentoConcedidoBonus(
							idLocalidade, idCategoria);

			// Acumulando creditos a realizar
			valorCreditoARealizarParcelamentoConcedidoBonus = repositorioFaturamento
					.acumularValorCreditoARealizarParcelamentoConcedidoBonus(
							idLocalidade, idCategoria);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		if (valorDebitoACobrarParcelamentoConcedidoBonus == null) {
			valorDebitoACobrarParcelamentoConcedidoBonus = BigDecimal.ZERO;
		}

		if (valorCreditoARealizarParcelamentoConcedidoBonus == null) {
			valorCreditoARealizarParcelamentoConcedidoBonus = BigDecimal.ZERO;
		}

		diferenca = valorDebitoACobrarParcelamentoConcedidoBonus
				.subtract(valorCreditoARealizarParcelamentoConcedidoBonus);

		return diferenca;
	}

	/**
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Rômulo Aurélio
	 * @created 18/01/2006
	 * 
	 */
	public Integer inserirFaturamentoSituacaoComando(
			SituacaoEspecialFaturamentoHelper situacaoEspecialFaturamentoHelper,
			boolean retirar) throws ControladorException {

		Integer id;

		FaturamentoSituacaoComando faturamentoSituacaoComando = new FaturamentoSituacaoComando();

		if (situacaoEspecialFaturamentoHelper.getIdImovel() != null
				&& !situacaoEspecialFaturamentoHelper.getIdImovel()
						.equalsIgnoreCase("")) {

			Imovel imovel = new Imovel();

			imovel.setId(new Integer(situacaoEspecialFaturamentoHelper
					.getIdImovel()));

			faturamentoSituacaoComando.setImovel(imovel);

		}

		if (situacaoEspecialFaturamentoHelper.getLocalidadeOrigemID() != null
				&& !situacaoEspecialFaturamentoHelper.getLocalidadeOrigemID()
						.equalsIgnoreCase("")) {

			Localidade localidadeInicial = new Localidade();

			localidadeInicial.setId(new Integer(
					situacaoEspecialFaturamentoHelper.getLocalidadeOrigemID()));

			faturamentoSituacaoComando.setLocalidadeInicial(localidadeInicial);

		}

		if (situacaoEspecialFaturamentoHelper.getLocalidadeDestinoID() != null
				&& !situacaoEspecialFaturamentoHelper.getLocalidadeDestinoID()
						.equalsIgnoreCase("")) {

			Localidade localidadeFinal = new Localidade();

			localidadeFinal.setId(new Integer(situacaoEspecialFaturamentoHelper
					.getLocalidadeDestinoID()));

			faturamentoSituacaoComando.setLocalidadeFinal(localidadeFinal);

		}

		if (situacaoEspecialFaturamentoHelper.getSetorComercialOrigemCD() != null
				&& !situacaoEspecialFaturamentoHelper
						.getSetorComercialOrigemCD().equalsIgnoreCase("")) {

			faturamentoSituacaoComando
					.setCodigoSetorComercialInicial(new Integer(
							situacaoEspecialFaturamentoHelper
									.getSetorComercialOrigemCD()));

		}

		if (situacaoEspecialFaturamentoHelper.getSetorComercialDestinoCD() != null
				&& !situacaoEspecialFaturamentoHelper
						.getSetorComercialDestinoCD().equalsIgnoreCase("")) {

			faturamentoSituacaoComando
					.setCodigoSetorComercialFinal(new Integer(
							situacaoEspecialFaturamentoHelper
									.getSetorComercialDestinoCD()));

		}

		if (situacaoEspecialFaturamentoHelper.getQuadraOrigemNM() != null
				&& !situacaoEspecialFaturamentoHelper.getQuadraOrigemNM()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setNumeroQuadraInicial(new Integer(
					situacaoEspecialFaturamentoHelper.getQuadraOrigemNM()));

		}

		if (situacaoEspecialFaturamentoHelper.getQuadraDestinoNM() != null
				&& !situacaoEspecialFaturamentoHelper.getQuadraDestinoNM()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setNumeroQuadraFinal(new Integer(
					situacaoEspecialFaturamentoHelper.getQuadraDestinoNM()));

		}

		if (situacaoEspecialFaturamentoHelper.getLoteOrigem() != null
				&& !situacaoEspecialFaturamentoHelper.getLoteOrigem()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setNumeroLoteInicial(new Integer(
					situacaoEspecialFaturamentoHelper.getLoteOrigem()));

		}

		if (situacaoEspecialFaturamentoHelper.getLoteDestino() != null
				&& !situacaoEspecialFaturamentoHelper.getLoteDestino()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setNumeroLoteFinal(new Integer(
					situacaoEspecialFaturamentoHelper.getLoteDestino()));

		}

		if (situacaoEspecialFaturamentoHelper.getSubloteOrigem() != null
				&& !situacaoEspecialFaturamentoHelper.getSubloteOrigem()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setNumeroSubLoteInicial(new Integer(
					situacaoEspecialFaturamentoHelper.getSubloteOrigem()));

		}

		if (situacaoEspecialFaturamentoHelper.getSubloteDestino() != null
				&& !situacaoEspecialFaturamentoHelper.getSubloteDestino()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setNumeroSubLoteFinal(new Integer(
					situacaoEspecialFaturamentoHelper.getSubloteDestino()));

		}

		if (situacaoEspecialFaturamentoHelper.getCodigoRotaInicial() != null
				&& !situacaoEspecialFaturamentoHelper.getCodigoRotaInicial()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setCodigoRotaInicial(new Integer(
					situacaoEspecialFaturamentoHelper.getCodigoRotaInicial()));

		}

		if (situacaoEspecialFaturamentoHelper.getCodigoRotaFinal() != null
				&& !situacaoEspecialFaturamentoHelper.getCodigoRotaFinal()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setCodigoRotaFinal(new Integer(
					situacaoEspecialFaturamentoHelper.getCodigoRotaFinal()));

		}

		if (situacaoEspecialFaturamentoHelper.getSequencialRotaInicial() != null
				&& !situacaoEspecialFaturamentoHelper
						.getSequencialRotaInicial().equalsIgnoreCase("")) {

			faturamentoSituacaoComando.setSequencialRotaInicial(new Integer(
					situacaoEspecialFaturamentoHelper
							.getSequencialRotaInicial()));

		}

		if (situacaoEspecialFaturamentoHelper.getSequencialRotaFinal() != null
				&& !situacaoEspecialFaturamentoHelper.getSequencialRotaFinal()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando
					.setSequencialRotaFinal(new Integer(
							situacaoEspecialFaturamentoHelper
									.getSequencialRotaFinal()));

		}

		if (situacaoEspecialFaturamentoHelper.getIdsCategoria() != null) {

			String[] idsCategoria = situacaoEspecialFaturamentoHelper
					.getIdsCategoria();

			for (int i = 0; i < idsCategoria.length; i++) {
				if (idsCategoria[i] != null && !idsCategoria[0].equals("-1")
						&& i == 0) {
					Categoria cat = new Categoria();
					cat.setId(new Integer(idsCategoria[i]));
					faturamentoSituacaoComando.setCategoria1(cat);
				} else if (idsCategoria[i] != null
						&& !idsCategoria[0].equals("-1") && i == 2) {
					Categoria cat = new Categoria();
					cat.setId(new Integer(idsCategoria[i]));
					faturamentoSituacaoComando.setCategoria2(cat);
				} else if (idsCategoria[i] != null
						&& !idsCategoria[0].equals("-1") && i == 3) {
					Categoria cat = new Categoria();
					cat.setId(new Integer(idsCategoria[i]));
					faturamentoSituacaoComando.setCategoria3(cat);
				} else if (idsCategoria[i] != null
						&& !idsCategoria[0].equals("-1") && i == 4) {
					Categoria cat = new Categoria();
					cat.setId(new Integer(idsCategoria[i]));
					faturamentoSituacaoComando.setCategoria4(cat);
				}
			}
		}

		if (situacaoEspecialFaturamentoHelper.getNumeroConsumoAguaMedido() != null
				&& !situacaoEspecialFaturamentoHelper
						.getNumeroConsumoAguaMedido().equals("")) {

			faturamentoSituacaoComando
					.setIndicadorConsumo(ConstantesSistema.SIM);

		} else if (situacaoEspecialFaturamentoHelper
				.getNumeroConsumoAguaNaoMedido() != null
				&& !situacaoEspecialFaturamentoHelper
						.getNumeroConsumoAguaNaoMedido().equals("")) {

			faturamentoSituacaoComando
					.setIndicadorConsumo(ConstantesSistema.NAO);

		} else {
			faturamentoSituacaoComando
					.setIndicadorConsumo(ConstantesSistema.TODOS);
		}

		if (situacaoEspecialFaturamentoHelper.getQuantidadeDeImoveis() != null
				&& !situacaoEspecialFaturamentoHelper.getQuantidadeDeImoveis()
						.equalsIgnoreCase("")) {

			faturamentoSituacaoComando
					.setQuantidadeImoveis(new Integer(
							situacaoEspecialFaturamentoHelper
									.getQuantidadeDeImoveis()));

		}

		if (situacaoEspecialFaturamentoHelper
				.getMesAnoReferenciaFaturamentoInicial() != null
				&& !situacaoEspecialFaturamentoHelper
						.getMesAnoReferenciaFaturamentoInicial().equals("")) {
			faturamentoSituacaoComando
					.setAnoMesInicialSituacaoFaturamento(Util
							.formatarMesAnoComBarraParaAnoMes(situacaoEspecialFaturamentoHelper
									.getMesAnoReferenciaFaturamentoInicial()));
		}

		if (situacaoEspecialFaturamentoHelper
				.getMesAnoReferenciaFaturamentoFinal() != null
				&& !situacaoEspecialFaturamentoHelper
						.getMesAnoReferenciaFaturamentoFinal().equals("")) {
			faturamentoSituacaoComando
					.setAnoMesFinalSituacaoFaturamento(Util
							.formatarMesAnoComBarraParaAnoMes(situacaoEspecialFaturamentoHelper
									.getMesAnoReferenciaFaturamentoFinal()));
		}

		if (situacaoEspecialFaturamentoHelper.getObservacao() != null
				&& !situacaoEspecialFaturamentoHelper.getObservacao()
						.equals("")) {
			faturamentoSituacaoComando
					.setObservacao(situacaoEspecialFaturamentoHelper
							.getObservacao());
		}

		faturamentoSituacaoComando.setUsuario(situacaoEspecialFaturamentoHelper
				.getUsuarioLogado());

		// Verifica se vem do retirar ou do Inserir

		if (!retirar) {
			if (situacaoEspecialFaturamentoHelper
					.getIdFaturamentoSituacaoTipo() != null
					&& !situacaoEspecialFaturamentoHelper
							.getIdFaturamentoSituacaoTipo().equals("-1")) {

				FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();

				faturamentoSituacaoTipo.setId(new Integer(
						situacaoEspecialFaturamentoHelper
								.getIdFaturamentoSituacaoTipo()));

				faturamentoSituacaoComando
						.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
			}

			if (situacaoEspecialFaturamentoHelper
					.getIdFaturamentoSituacaoMotivo() != null
					&& !situacaoEspecialFaturamentoHelper
							.getIdFaturamentoSituacaoMotivo().equals("-1")) {

				FaturamentoSituacaoMotivo faturamentoSituacaoMotivo = new FaturamentoSituacaoMotivo();

				faturamentoSituacaoMotivo.setId(new Integer(
						situacaoEspecialFaturamentoHelper
								.getIdFaturamentoSituacaoMotivo()));

				faturamentoSituacaoComando
						.setFaturamentoSituacaoMotivo(faturamentoSituacaoMotivo);
			}

			faturamentoSituacaoComando
					.setIndicadorComando(ConstantesSistema.SIM);
		} else {
			faturamentoSituacaoComando
					.setIndicadorComando(ConstantesSistema.NAO);
		}

		if (situacaoEspecialFaturamentoHelper.getIndicadorConsumoImovel() != null) {
			faturamentoSituacaoComando.setIndicadorConsumo(new Integer(
					situacaoEspecialFaturamentoHelper
							.getIndicadorConsumoImovel()).shortValue());
		}

		faturamentoSituacaoComando.setUltimaAlteracao(new Date());
		id = (Integer) getControladorUtil().inserir(faturamentoSituacaoComando);
		return id;
	}

	/**
	 * [UC0896] Manter Autos de Infração
	 * 
	 * @author Rômulo Aurélio
	 * @created 06/05/2009
	 * 
	 */
	public void atualizarAutoInfracao(AutosInfracao autosInfracao,
			Usuario usuarioLogado) throws ControladorException {

		SistemaParametro sistemaParametro = (SistemaParametro) getControladorUtil()
				.pesquisarParametrosDoSistema();

		this.validarQuantidadeParcelasAutoInfracao(autosInfracao
				.getNumeroParcelasDebito());
		this.validarDataEmissaoAutoInfracao(autosInfracao.getDataEmissao(),
				autosInfracao.getAutoInfracaoSituacao().getId(),
				sistemaParametro);

		this.validarDataInicioRecursoAutoInfracao(
				autosInfracao.getDataEmissao(),
				autosInfracao.getDataInicioRecurso(), sistemaParametro);

		this.validarDataTerminoRecursoAutoInfracao(
				autosInfracao.getDataInicioRecurso(),
				autosInfracao.getDataTerminoRecurso());
		// this.validarExistenciaDebitoAutoInfracao(autosInfracao.getId());

		autosInfracao.setUsuario(usuarioLogado);
		autosInfracao.setUltimaAlteracao(new Date());

		FiltroAutosInfracao filtroAutosInfracao = new FiltroAutosInfracao();

		filtroAutosInfracao.adicionarParametro(new ParametroSimples(
				FiltroAutosInfracao.ID, autosInfracao.getId()));

		Collection colecaoAutosInfracao = new ArrayList();
		colecaoAutosInfracao = getControladorUtil().pesquisar(
				filtroAutosInfracao, AutosInfracao.class.getName());

		if (colecaoAutosInfracao != null && !colecaoAutosInfracao.isEmpty()) {

			AutosInfracao autosInfracaoBase = (AutosInfracao) colecaoAutosInfracao
					.iterator().next();

			if (!autosInfracaoBase.getId().toString()
					.equalsIgnoreCase(autosInfracao.getId().toString())) {
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

		}

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ATUALIZAR_AUTO_INFRACAO,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ATUALIZAR_AUTO_INFRACAO);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		autosInfracao.setOperacaoEfetuada(operacaoEfetuada);
		autosInfracao.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(autosInfracao);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		getControladorUtil().atualizar(autosInfracao);

		// [SB0003]- Gerar Débito a Cobrar
		if (autosInfracao.getAutoInfracaoSituacao().getIndicadorGerarDebito()
				.toString().equals(ConstantesSistema.SIM.toString())) {
			getControladorAtendimentoPublico().gerarDebitoACobrarAutoInfracao(
					autosInfracao, sistemaParametro);
		}

	}

	public void validarDataEmissaoAutoInfracao(Date dataEmissao,
			Integer idAutoInfracaoSituacao, SistemaParametro sistemaParametro)
			throws ControladorException {

		if (dataEmissao.after(new Date())) {
			throw new ControladorException("atencao.data.invalida", null,
					"Data de Emissão");
		}

		if (idAutoInfracaoSituacao.toString().equals(
				AutoInfracaoSituacao.AUTO_EM_PRAZO_DE_RECURSO.toString())) {

			Integer diasPrazoRecurso = sistemaParametro
					.getNumeroDiasPrazoRecursoAutoInfracao();

			Date dataPrazoRecurso = Util.subtrairNumeroDiasDeUmaData(
					new Date(), diasPrazoRecurso);

			dataEmissao = Util.formatarDataFinal(dataEmissao);
			if (dataEmissao.before(dataPrazoRecurso)) {

				throw new ControladorException(
						"atencao.data_emissao_deve_ser_maior_data_recurso_infracao",
						null, Util.formatarData(dataPrazoRecurso));

			}

		} else if (idAutoInfracaoSituacao.toString().equals(
				AutoInfracaoSituacao.AUTO_COM_PRAZO_DE_RECURSO_VENCIDO
						.toString())) {

			Integer diasPrazoRecurso = sistemaParametro
					.getNumeroDiasPrazoRecursoAutoInfracao();

			Date dataPrazoRecurso = Util.subtrairNumeroDiasDeUmaData(
					new Date(), diasPrazoRecurso);

			if (dataEmissao.after(dataPrazoRecurso)) {

				throw new ControladorException(
						"atencao.data_emissao_deve_ser_menor_data_recurso_infracao",
						null, Util.formatarData(dataPrazoRecurso));

			}

		} else if (((idAutoInfracaoSituacao).toString()
				.equals(AutoInfracaoSituacao.AUTO_COM_RECURSO_EM_ANALISE_JULGAMENTO
						.toString()))
				|| (idAutoInfracaoSituacao.toString()
						.equals(AutoInfracaoSituacao.AUTO_COM_RECURSO_JULGADO_PROCEDENTE
								.toString()))
				|| (idAutoInfracaoSituacao.toString()
						.equals(AutoInfracaoSituacao.AUTO_COM_RECURSO_JULGADO_IMPROCEDENTE
								.toString()))
				|| (idAutoInfracaoSituacao.toString()
						.equals(AutoInfracaoSituacao.AUTO_CANCELADO.toString()))) {

			if (dataEmissao.after(new Date())) {
				throw new ControladorException(
						"atencao.data_emissao_deve_ser_maior_ou_igual_data_corrente",
						null, Util.formatarData(new Date()));
			}

		}

	}

	public void validarDataInicioRecursoAutoInfracao(Date dataEmissao,
			Date dataInicioRecurso, SistemaParametro sistemaParametro)
			throws ControladorException {

		Integer diasPrazoRecurso = sistemaParametro
				.getNumeroDiasPrazoRecursoAutoInfracao();

		Date dataPrazoRecurso = Util.adicionarNumeroDiasDeUmaData(dataEmissao,
				diasPrazoRecurso);

		if (dataInicioRecurso != null) {
			if (dataInicioRecurso.before(dataEmissao)
					|| dataInicioRecurso.after(dataPrazoRecurso)) {

				throw new ControladorException(
						"atencao.data_inicio_recurso_deve_ser_maior_ou_igual_data_emissao_menor_data_prazo",
						null, Util.formatarData(dataEmissao), Util
								.formatarData(dataPrazoRecurso));

			}
		}

	}

	public void validarDataTerminoRecursoAutoInfracao(Date dataInicioRecurso,
			Date dataTerminoRecurso) throws ControladorException {

		if (dataTerminoRecurso != null && dataInicioRecurso != null) {

			if (dataInicioRecurso.after(dataTerminoRecurso)) {

				throw new ControladorException(
						"atencao.data_inicio_recurso_superior_data_termino_recurso",
						null, Util.formatarData(dataInicioRecurso));

			}

		}

	}

	public void validarExistenciaDebitoAutoInfracao(Integer idAutosInfracao)
			throws ControladorException {
		FiltroAutosInfracaoDebitoACobrar filtroAutosInfracaoDebitoACobrar = new FiltroAutosInfracaoDebitoACobrar();
		filtroAutosInfracaoDebitoACobrar
				.adicionarParametro(new ParametroSimples(
						FiltroAutosInfracaoDebitoACobrar.AUTOS_INFRACAO_ID,
						idAutosInfracao));

		Collection colecaoAutosInfracaoDebitoACobrar = getControladorUtil()
				.pesquisar(filtroAutosInfracaoDebitoACobrar,
						AutosInfracaoDebitoACobrar.class.getName());

		if (colecaoAutosInfracaoDebitoACobrar != null
				&& !colecaoAutosInfracaoDebitoACobrar.isEmpty()) {
			throw new ControladorException(
					"atencao.auto_infracao_possui_debitos");
		}
	}

	public void validarQuantidadeParcelasAutoInfracao(Integer numeroParcelas)
			throws ControladorException {
		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (numeroParcelas == null
				|| numeroParcelas.intValue() < 1
				|| numeroParcelas.intValue() > sistemaParametro
						.getNumeroMaximoParcelasAutoInfracao().intValue()) {
			throw new ControladorException(
					"atencao.numero_parcelas_debito_auto_infracao_invalida",
					null, sistemaParametro
							.getNumeroMaximoParcelasAutoInfracao().toString());
		}
	}

	/**
	 * Pesquisa o valor da água da conta.
	 * 
	 * @author Sávio Luiz
	 * @date 11/05/2009
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorAguaConta(Integer idImovel,
			Integer referencia) throws ControladorException {
		try {

			return repositorioFaturamento.pesquisarValorAguaConta(idImovel,
					referencia);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Inserir Situacao Especial de Faturamento
	 * 
	 * @author Rômulo Aurélio
	 * @date 11/05/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirSituacaoEspecialFaturamento(
			SituacaoEspecialFaturamentoHelper situacaoEspecialFaturamentoHelper,
			boolean retirar, Collection colecaoDadosImoveisParaInserir,
			Integer idFaturamentoSituacaoTipo, Integer anoMesReferenciaInicial,
			Integer anoMesReferenciaFinal) throws ControladorException {

		try {
			Integer idFaturamentoSituacaoComando = this
					.inserirFaturamentoSituacaoComando(
							situacaoEspecialFaturamentoHelper, retirar);

			FaturamentoSituacaoComando faturamentoSituacaoComando = new FaturamentoSituacaoComando();

			faturamentoSituacaoComando.setId(idFaturamentoSituacaoComando);

			Collection colecaoImoveis = null;

			Iterator iterator = colecaoDadosImoveisParaInserir.iterator();
			Collection collectionFaturmentoSituaoHistorico = new ArrayList();
			colecaoImoveis = new ArrayList();
			while (iterator.hasNext()) {

				Object[] dadosImoveis = (Object[]) iterator.next();

				if (dadosImoveis != null) {

					Integer id = (Integer) dadosImoveis[0];

					Date ultimaAlteracao = (Date) dadosImoveis[1];

					Date ultimaAlteracaoImovel = getControladorImovel()
							.pesquisarUltimaAlteracaoImovel(id);

					if (ultimaAlteracaoImovel.after(ultimaAlteracao)) {
						logger.error("Data da ultima alteracao do imovel é maior que a ultima alteracao enviada.");
						throw new ControladorException(
								"atencao.atualizacao.timestamp");
					}

					colecaoImoveis.add(id);

					FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = new FaturamentoSituacaoHistorico();
					Imovel imovel = new Imovel();

					FiltroFaturamentoSituacaoTipo filtroFaturamentoSituacaoTipo = new FiltroFaturamentoSituacaoTipo();

					filtroFaturamentoSituacaoTipo
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoSituacaoTipo.ID,
									situacaoEspecialFaturamentoHelper
											.getIdFaturamentoSituacaoTipo()));

					Collection colecaoFaturementoTipo = this
							.getControladorUtil().pesquisar(
									filtroFaturamentoSituacaoTipo,
									FaturamentoSituacaoTipo.class.getName());

					FaturamentoSituacaoTipo faturamentoSituacaoTipo = (FaturamentoSituacaoTipo) colecaoFaturementoTipo
							.iterator().next();

					FiltroFaturamentoSituacaoMotivo filtroFaturamentoSituacaoMotivo = new FiltroFaturamentoSituacaoMotivo();

					filtroFaturamentoSituacaoMotivo
							.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoSituacaoMotivo.ID,
									situacaoEspecialFaturamentoHelper
											.getIdFaturamentoSituacaoMotivo()));

					Collection colecaoFaturementoMotivo = this
							.getControladorUtil().pesquisar(
									filtroFaturamentoSituacaoMotivo,
									FaturamentoSituacaoMotivo.class.getName());

					FaturamentoSituacaoMotivo faturamentoSituacaoMotivo = (FaturamentoSituacaoMotivo) colecaoFaturementoMotivo
							.iterator().next();

					imovel.setId(new Integer(id));
					faturamentoSituacaoHistorico.setImovel(imovel);
					faturamentoSituacaoHistorico.setFaturamentoSituacaoMotivo(faturamentoSituacaoMotivo);
					faturamentoSituacaoHistorico.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
					faturamentoSituacaoHistorico.setAnoMesFaturamentoSituacaoInicio(anoMesReferenciaInicial);
					faturamentoSituacaoHistorico.setAnoMesFaturamentoSituacaoFim(anoMesReferenciaFinal);
					faturamentoSituacaoHistorico.setAnoMesFaturamentoRetirada(null);
					faturamentoSituacaoHistorico.setFaturamentoSituacaoMotivo(faturamentoSituacaoMotivo);
					faturamentoSituacaoHistorico.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
					faturamentoSituacaoHistorico.setObservacaoInforma(situacaoEspecialFaturamentoHelper.getObservacaoInforma());
					faturamentoSituacaoHistorico.setUltimaAlteracao(Calendar.getInstance().getTime());
					faturamentoSituacaoHistorico.setNumeroConsumoAguaMedido(situacaoEspecialFaturamentoHelper.getNumeroConsumoAguaMedido());
					faturamentoSituacaoHistorico.setNumeroConsumoAguaNaoMedido(situacaoEspecialFaturamentoHelper.getNumeroConsumoAguaNaoMedido());
					faturamentoSituacaoHistorico.setNumeroVolumeEsgotoMedido(situacaoEspecialFaturamentoHelper.getNumeroVolumeEsgotoMedido());
					faturamentoSituacaoHistorico.setNumeroVolumeEsgotoNaoMedido(situacaoEspecialFaturamentoHelper.getNumeroVolumeEsgotoNaoMedido());
					faturamentoSituacaoHistorico.setFaturamentoSituacaoComandoInforma(faturamentoSituacaoComando);
					faturamentoSituacaoHistorico.setDataInclusao(new Date());

					collectionFaturmentoSituaoHistorico
							.add(faturamentoSituacaoHistorico);

				}
			}

			// ------------------------REGISTRAR
			// TRANSAÇÃO---------------------FATURAMENTO HISTORICO-----
			Iterator itera = collectionFaturmentoSituaoHistorico.iterator();
			while (itera.hasNext()) {
				FaturamentoSituacaoHistorico fsh = (FaturamentoSituacaoHistorico) itera
						.next();

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_INFORMAR_SITUACAO_ESPECIAL_FATURAMENTO,
						fsh.getImovel().getId(), fsh.getImovel().getId(),
						new UsuarioAcaoUsuarioHelper(
								situacaoEspecialFaturamentoHelper
										.getUsuarioLogado(),
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(fsh);
			}
			// ------------------------REGISTRAR
			// TRANSAÇÃO---------------------FATURAMENTO HISTORICO-----
			getControladorBatch().inserirColecaoObjetoParaBatch(
					collectionFaturmentoSituaoHistorico);

			getControladorImovel().atualizarFaturamentoSituacaoTipo(
					colecaoImoveis, idFaturamentoSituacaoTipo,
					situacaoEspecialFaturamentoHelper.getUsuarioLogado());

		} catch (ControladorException ex) {
			logger.error("Erro ao ao inserir situacao especial de faturamento.");
			sessionContext.setRollbackOnly();
			throw new ControladorException(ex.getMessage(), ex);
		}
	}

	/**
	 * [UC0857] - Conta quantidade de registros do relatorio
	 * 
	 * @author Hugo Amorim
	 * @date 10/07/2009
	 * 
	 * @param idUnidadeNegocio
	 *            , idFuncionario, dataPagamentoInicial, dataPagamentoFinal
	 * @throws ErroRepositorioException
	 */
	public int countRelatorioAutoInfracao(Integer idUnidadeNegocio,
			Integer idFuncionario, Integer dataPagamentoInicial,
			Integer dataPagamentoFinal) throws ControladorException {
		try {

			return repositorioFaturamento.countRelatorioAutoInfracao(
					idUnidadeNegocio, idFuncionario, dataPagamentoInicial,
					dataPagamentoFinal);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0928] - Manter Situação Especial de Faturamento [SB0001 e SB0002 ] -
	 * Retirar FSC e Inserir FSC FSC = Faturamento Situação Comando
	 * 
	 * Para que uma Situação Especial de Faturamento (SEF) seja atualizada na
	 * verdade é preciso retirar a SEF atual e inserir uma nova.
	 * 
	 * Além disso, é preciso atualzar o historico da SEF antiga e inserir um
	 * novo historico para a nova SEF.
	 * 
	 * @since 14/08/2009
	 * @author Marlon Patrick
	 */
	public void atualizarSituacaoEspecialFaturamento(
			FaturamentoSituacaoComando comandoOriginal,
			FaturamentoSituacaoComando comandoInserir,
			ArrayList<FaturamentoSituacaoHistorico> colecaoHistoricoInserir,
			FaturamentoSituacaoComando comandoRetirar,
			ArrayList<FaturamentoSituacaoHistorico> colecaoHistoricoRetirar)
			throws ControladorException {
		try {
			getControladorUtil().inserir(comandoRetirar);

			inserirNovoComandoRegistrarOperacaoAtualizacao(comandoOriginal,
					comandoInserir);

			for (int i = 0; i < colecaoHistoricoInserir.size(); i++) {
				getControladorUtil().atualizar(colecaoHistoricoRetirar.get(i));
				getControladorUtil().inserir(colecaoHistoricoInserir.get(i));
			}

			// repositorioFaturamento.atualizarSituacaoEspecialFaturamento(comandoInserir,
			// colecaoHistoricoInserir, comandoRetirar,
			// colecaoHistoricoRetirar);
		} catch (ControladorException ex) {
			ex.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0928] - Manter Situação Especial de Faturamento (SEF)
	 * 
	 * Para que a operação seja registrada como uma ATUALIZAÇÃO foi necessário
	 * inserir o novo Comando com os dados do antigo e em seguida atualizá-lo,
	 * dessa forma, na consulta de operações o usuário poderá ver o valor antigo
	 * e o novo.
	 * 
	 * @since 21/08/2009
	 * @author Marlon Patrick
	 */
	private void inserirNovoComandoRegistrarOperacaoAtualizacao(
			FaturamentoSituacaoComando comandoOriginal,
			FaturamentoSituacaoComando comandoInserir)
			throws ControladorException {

		Integer mesAno = comandoInserir.getAnoMesFinalSituacaoFaturamento();
		String observacao = comandoInserir.getObservacao();

		comandoInserir.setAnoMesFinalSituacaoFaturamento(comandoOriginal
				.getAnoMesFinalSituacaoFaturamento());
		comandoInserir.setObservacao(comandoOriginal.getObservacao());

		getControladorUtil().inserir(comandoInserir);

		comandoInserir.setAnoMesFinalSituacaoFaturamento(mesAno);
		comandoInserir.setObservacao(observacao);

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ATUALIZAR_SITUACAO_ESPECIAL_FATURAMENTO,
				comandoOriginal.getId(), comandoOriginal.getId(),
				new UsuarioAcaoUsuarioHelper(comandoInserir.getUsuario(),
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		registradorOperacao.registrarOperacao(comandoInserir);

		getControladorUtil().atualizar(comandoInserir);
	}

	public Integer pesquisarSituacaoEspecialFaturamentoCount(
			FaturamentoSituacaoComando comando) throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarSituacaoEspecialFaturamentoCount(comando);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	public Collection<FaturamentoSituacaoComando> pesquisarSituacaoEspecialFaturamento(
			FaturamentoSituacaoComando comando, Integer numeroPaginasPesquisa)
			throws ControladorException {
		try {
			return repositorioFaturamento.pesquisarSituacaoEspecialFaturamento(
					comando, numeroPaginasPesquisa);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0485] - Gerar Resumo dos Devedores Duvidosos
	 * 
	 * @author Vivianne Sousa
	 * @date 09/09/2009
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idQuadra
	 * 
	 * @throws ErroRepositorioException
	 */

	public Collection<Conta> obterContas(int anoMesReferenciaContabil,
			int idLocalidade, int idQuadra) throws ControladorException {

		try {

			return this.repositorioFaturamento.obterContaAgrupadasPorImovel(
					anoMesReferenciaContabil, idLocalidade, idQuadra);

		} catch (Exception e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0147] - Cancelar Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/09/2009
	 */
	public void atualizarIndicadorHistoricoContaGeral(Integer idContaGeral,
			Short indicadorHistorico) throws ControladorException {

		try {

			this.repositorioFaturamento.atualizarIndicadorHistoricoContaGeral(
					idContaGeral, indicadorHistorico);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0352] - Emitir Contas e Cartas
	 * 
	 * @author Sávio Luiz
	 * @date 29/12/2009
	 */
	public String[] obterMensagemAnormalidadeConsumo(
			EmitirContaHelper emitirContaHelper) throws ControladorException {

		String[] mensagemConta = null;

		LigacaoTipo ligacaoTipo = new LigacaoTipo();
		ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);
		Integer amReferencia = emitirContaHelper.getAmReferencia();
		Imovel imovel = new Imovel();
		imovel.setId(emitirContaHelper.getIdImovel());
		try {
			// Pesquisa o consumo histórico para a ligação de água
			Collection consumoHistoricoMesAnterior = repositorioMicromedicao
					.pesquisarConsumoHistoricoConsumoAnormalidade(imovel,
							ligacaoTipo, amReferencia);

			// caso não exista
			if (consumoHistoricoMesAnterior == null
					|| consumoHistoricoMesAnterior.isEmpty()) {
				ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
				// Pesquisa o consumo histórico para ligação de esgoto
				consumoHistoricoMesAnterior = repositorioMicromedicao
						.pesquisarConsumoHistoricoConsumoAnormalidade(imovel,
								ligacaoTipo, amReferencia);
			}
			// caso exista consumo historico e anormalidade de consumo
			if (consumoHistoricoMesAnterior != null
					&& !consumoHistoricoMesAnterior.isEmpty()) {
				Object[] dadosConsumo = (Object[]) Util
						.retonarObjetoDeColecao(consumoHistoricoMesAnterior);
				if (dadosConsumo != null) {
					Integer idAnormalidadeConsumo = null;
					if (dadosConsumo[1] != null) {
						idAnormalidadeConsumo = (Integer) dadosConsumo[1];
					}
					// verifica se a anormalidade de consumo é Baixo Consumo,
					// Alto Consumo ou Estou de Consumo
					if (idAnormalidadeConsumo != null
							&& (idAnormalidadeConsumo
									.equals(ConsumoAnormalidade.BAIXO_CONSUMO)
									|| idAnormalidadeConsumo
											.equals(ConsumoAnormalidade.ALTO_CONSUMO) || idAnormalidadeConsumo
										.equals(ConsumoAnormalidade.ESTOURO_CONSUMO))) {

						// Obtém a quantidade de economias por categoria
						Collection colecaoCategoria = getControladorImovel()
								.obterQuantidadeEconomiasCategoria(imovel);

						Integer idCategoriaComMaisEconomias = null;
						int maiorQuantidadeEconomia = 0;
						Iterator colecaoCategoriaIterator = colecaoCategoria
								.iterator();
						while (colecaoCategoriaIterator.hasNext()) {

							Categoria categoria = (Categoria) colecaoCategoriaIterator
									.next();

							int qtdEconomias = categoria
									.getQuantidadeEconomiasCategoria()
									.intValue();

							// Obtém a maior quantidade de economias e a vezes
							// média de estouro
							if (maiorQuantidadeEconomia < qtdEconomias) {

								idCategoriaComMaisEconomias = categoria.getId();

							}
						}

						Integer idImovelPerfil = emitirContaHelper
								.getIdImovelPerfil();
						// verifica se existe consumo anormalidade ação para a
						// anormalidade de consumo, a principal categoria e o
						// perfil
						ConsumoAnormalidadeAcao consumoAnormalidadeAcao = this
								.getControladorMicromedicao()
								.verificaAcaoASerTomada(idAnormalidadeConsumo,
										idCategoriaComMaisEconomias,
										idImovelPerfil);
						if (consumoAnormalidadeAcao != null) {
							String mensagemContaAnormalidade = "";

							// Obtém o ano e mês de referência de faturamento
							int anoMesReferenciaAnterior = Util
									.subtrairData(amReferencia);

							// Pesquisa o consumo histórico
							consumoHistoricoMesAnterior = repositorioMicromedicao
									.pesquisarConsumoHistoricoConsumoAnormalidade(
											imovel, ligacaoTipo,
											anoMesReferenciaAnterior,
											idAnormalidadeConsumo);

							// 3.1.1. Caso não tenha ocorrido estouro,auto ou
							// baixo consumo no mês anterior
							// (CSAN_ID da tabela CONSUMO_HISTORICO com o valor
							// diferente de estouro de consumo
							// com IMOV_ID=matrícula do imóvel, LGTI_ID com o
							// valor correspondente a ligação de água
							// ou com o valor correspondente a ligação de esgoto
							// e
							// CSHI_AMFATURAMENTO igual ao ano /mês de
							// faturamento menos um mês),
							// então verifica a ação a ser tomada no primeiro
							// mês (LACS_IDMES1):
							if (consumoHistoricoMesAnterior == null
									|| consumoHistoricoMesAnterior.isEmpty()) {

								mensagemContaAnormalidade = consumoAnormalidadeAcao
										.getDescricaoContaMensagemMes1();

							} else {

								// 3.1.2.Caso contrário, ou seja, tenha ocorrido
								// estouro,auto ou baixo de consumo no mês
								// anterior,
								// o sistema verifica se tenha ocorrido estouro
								// de consumo no segundo mês anterior
								// (CSAN_ID da tabela CONSUMO_HISTORICO com o
								// valor diferente de estouro de consumo
								// com IMOV_ID=matrícula do imóvel, LGTI_ID com
								// o valor correspondente a ligação de água
								// ou com o valor correspondente a ligação de
								// esgoto e
								// CSHI_AMFATURAMENTO igual ao ano /mês de
								// faturamento menos dois meses)

								Collection consumoHistoricoSegundoMesAnterior = repositorioMicromedicao
										.pesquisarConsumoHistoricoConsumoAnormalidade(
												imovel,
												ligacaoTipo,
												Util.subtrairData(anoMesReferenciaAnterior),
												idAnormalidadeConsumo);

								if (consumoHistoricoSegundoMesAnterior == null
										|| consumoHistoricoSegundoMesAnterior
												.isEmpty()) {
									mensagemContaAnormalidade = consumoAnormalidadeAcao
											.getDescricaoContaMensagemMes2();

								} else {
									mensagemContaAnormalidade = consumoAnormalidadeAcao
											.getDescricaoContaMensagemMes3();
								}

							}

							if (mensagemContaAnormalidade != null
									&& !mensagemContaAnormalidade.equals("")) {
								mensagemConta = new String[3];
								int tamanho = mensagemContaAnormalidade
										.length();
								if (tamanho < 60) {
									mensagemConta[0] = mensagemContaAnormalidade
											.substring(0, tamanho);
									mensagemConta[1] = "";
									mensagemConta[2] = "";
								} else {
									mensagemConta[0] = mensagemContaAnormalidade
											.substring(0, 60);
									mensagemConta[1] = mensagemContaAnormalidade
											.substring(60, tamanho);
									mensagemConta[2] = "";
								}

							}
						}

					}
				}
			}
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return mensagemConta;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * 
	 * Obter Dados da Medição da Conta
	 * 
	 * @author TiagoMoreno
	 * @date 25/02/2010
	 * 
	 * @param DataAnterior
	 *            e DataAtual
	 * @throws ControladorException
	 */
	public Object[] obterLeituraAnteriorEAtual(Integer idImovel,
			Integer amReferencia) throws ControladorException {
		Object[] parmsMedicao = null;
		try {

			parmsMedicao = repositorioMicromedicao.obterLeituraAnteriorEAtual(
					idImovel, amReferencia);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return parmsMedicao;
	}

	/**
	 * [UC0194] - Inserir Crédito a Realizar
	 * 
	 * @author Raphael Rossiter
	 * @date 14/04/2010
	 * 
	 * @param creditoARealizar
	 * @param imovel
	 * @param usuarioLogado
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer gerarCreditoARealizar(CreditoARealizar creditoARealizar,
			Imovel imovel, Usuario usuarioLogado) throws ControladorException {

		CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();

		creditoARealizarGeral.setIndicadorHistorico((short) 2);
		creditoARealizarGeral.setUltimaAlteracao(new Date());

		Integer idGerado = (Integer) this.getControladorUtil().inserir(
				creditoARealizarGeral);

		creditoARealizarGeral.setId(idGerado);

		creditoARealizar.setCreditoARealizarGeral(creditoARealizarGeral);
		creditoARealizar.setId(idGerado);

		if (usuarioLogado != null) {
			registrarTransacao(creditoARealizar,
					Operacao.OPERACAO_CREDITO_A_REALIZAR_INSERIR, imovel,
					usuarioLogado, idGerado);
		}

		getControladorUtil().inserir(creditoARealizar);

		inserirCreditoARealizarCategoria(creditoARealizar, imovel);

		return idGerado;
	}

	private void registrarTransacao(ObjetoTransacao objetoTransacao,
			Integer operacao, Imovel imovel, Usuario usuarioLogado,
			Integer idGerado) {

		UsuarioAcaoUsuarioHelper usuarioHelper = new UsuarioAcaoUsuarioHelper(
				usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				operacao, imovel.getId(), idGerado, usuarioHelper);

		registradorOperacao.registrarOperacao(objetoTransacao);
	}

	private void inserirCreditoARealizarCategoria(
			CreditoARealizar creditoARealizar, Imovel imovel)
			throws ControladorException {
		Collection colecaoCategoriasImovel = this.getControladorImovel()
				.obterQuantidadeEconomiasCategoria(imovel);

		Collection colecaoValoresPorCategoria = getControladorImovel()
				.obterValorPorCategoria(colecaoCategoriasImovel,
						creditoARealizar.getValorCredito());

		Iterator icolecaoCategorias = colecaoCategoriasImovel.iterator();
		Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria
				.iterator();

		while (icolecaoValoresPorCategoria.hasNext()
				&& icolecaoCategorias.hasNext()) {
			CreditoARealizarCategoria creditoARealizarCategoria = new CreditoARealizarCategoria();

			Categoria categoria = (Categoria) icolecaoCategorias.next();
			BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria.next();

			creditoARealizarCategoria
					.setComp_id(new CreditoARealizarCategoriaPK(
							creditoARealizar.getId(), categoria.getId()));
			creditoARealizarCategoria.setQuantidadeEconomia(categoria
					.getQuantidadeEconomiasCategoria());
			creditoARealizarCategoria.setValorCategoria(valor);
			creditoARealizarCategoria.setUltimaAlteracao(new Date());

			getControladorUtil().inserir(creditoARealizarCategoria);
		}
	}

	private Object[] gerarPassosFinais(
			UC0745GerarArquivoTextoFaturamento gerarArquivoTextoFaturamento,
			SistemaParametro sistemaParametro, Imovel imovel,
			Integer sequenciaRota, Integer anoMesFaturamento)
			throws ControladorException {

		StringBuilder arquivoFinal = new StringBuilder();
		Integer tamanhoArquivoFinal = 0;

		Object[] retorno = new Object[2];

		// registro tipo 11
		arquivoFinal.append(System.getProperty("line.separator"));
		arquivoFinal.append(gerarArquivoTextoFaturamento
				.gerarArquivoTextoRegistroTipo11(sistemaParametro, imovel,
						sequenciaRota, anoMesFaturamento));
		tamanhoArquivoFinal = tamanhoArquivoFinal + 1;
		// registro tipo 12
		Object[] reg12 = gerarArquivoTextoFaturamento
				.gerarArquivoTextoRegistroTipo12();
		StringBuilder arquivoTextoReg12 = (StringBuilder) reg12[0];
		if (arquivoTextoReg12 != null && arquivoTextoReg12.length() > 0) {
			arquivoFinal.append(System.getProperty("line.separator"));
			arquivoFinal.append(arquivoTextoReg12);
			int tamanhoArquivoReg12 = (Integer) reg12[1];
			tamanhoArquivoFinal = tamanhoArquivoFinal + tamanhoArquivoReg12;
		}

		// registro tipo 13
		Object[] reg13 = gerarArquivoTextoFaturamento
				.gerarArquivoTextoRegistroTipo13();
		StringBuilder arquivoTextoReg13 = (StringBuilder) reg13[0];
		if (arquivoTextoReg13 != null && arquivoTextoReg13.length() > 0) {
			arquivoFinal.append(System.getProperty("line.separator"));
			arquivoFinal.append(arquivoTextoReg13);
			int tamanhoArquivoReg13 = (Integer) reg13[1];
			tamanhoArquivoFinal = tamanhoArquivoFinal + tamanhoArquivoReg13;
		}

		// registro tipo 14
		Object[] reg14 = gerarArquivoTextoFaturamento
				.gerarArquivoTextoRegistroTipo14();
		StringBuilder arquivoTextoReg14 = (StringBuilder) reg14[0];
		if (arquivoTextoReg14 != null && arquivoTextoReg14.length() > 0) {
			arquivoFinal.append(System.getProperty("line.separator"));
			arquivoFinal.append(arquivoTextoReg14);
			int tamanhoArquivoReg14 = (Integer) reg14[1];
			tamanhoArquivoFinal = tamanhoArquivoFinal + tamanhoArquivoReg14;
		}

		retorno[0] = arquivoFinal;
		retorno[1] = tamanhoArquivoFinal;

		return retorno;

	}

	/**
	 * Método que retorna uma array de object com a soma do valor dos debitos
	 * cobrados de parcelamento,o numero da prestacao e o numero total de
	 * prestações
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParmsDebitoAutomatico(Integer idConta)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarParmsDebitoAutomatico(idConta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método que retorna uma array de object com a soma do valor dos debitos
	 * cobrados de parcelamento,o numero da prestacao e o numero total de
	 * prestações
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParmsDebitoAutomaticoHistorico(
			Integer idConta) throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarParmsDebitoAutomaticoHistorico(idConta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * 
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 19/05/2006, 16/01/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsDebitoCobradoPorTipo(Integer idConta)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarParmsDebitoCobradoPorTipo(idConta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * 
	 * 
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * 
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsDebitoCobradoHistoricoPorTipo(Integer idConta)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarParmsDebitoCobradoHistoricoPorTipo(idConta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0002] - Obter dados dos serviços de parcelamento
	 * 
	 * @author Raphael Rossiter
	 * @date 25/04/2008
	 * 
	 * @param conta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoCobradoDeParcelamento(Conta conta)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarDebitoCobradoDeParcelamento(conta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0002] - Obter dados dos serviços de parcelamento
	 * 
	 * @author Raphael Rossiter
	 * @date 25/04/2008
	 * 
	 * @param conta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoCobradoNaoParcelamento(Conta conta)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarDebitoCobradoNaoParcelamento(conta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * @Author Hugo Amorim
	 * @Date 29/07/2010
	 * 
	 * @param idFaturamentoGrupo
	 *            Id do Faturamento Grupo
	 * @param anoMesReferencia
	 *            Ano Mes Referencia
	 * @exception ErroRepositorioException
	 *                Erro de Hibernate
	 */
	protected void apagarDadosGeradosResumoFaturamentoSimulacaoDetalhe(
			Integer idFaturamentoGrupo, ApagarDadosFaturamentoHelper helper)
			throws ControladorException {

		try {

			repositorioFaturamento
					.deletarResumoFaturamentoSimulacaoDetalheDebito(
							idFaturamentoGrupo, helper.getAnoMesFaturamento(),
							helper.getRota().getId());

			repositorioFaturamento
					.deletarResumoFaturamentoSimulacaoDetalheCredito(
							idFaturamentoGrupo, helper.getAnoMesFaturamento(),
							helper.getRota().getId());

		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Verifica a Quantidade de Alteracoes no Vencimento da Conta
	 * 
	 * @author Hugo Leonardo
	 * @date 11/08/2010
	 * 
	 * @param idConta
	 * 
	 * @return void
	 * @throws ControladorException
	 */
	public void verificarQuantidadeAlteracoesVencimentoConta(Integer idConta)
			throws ControladorException {

		try {
			// PARÂMETROS DO SISTEMA
			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			if (sistemaParametro.getIndicadorLimiteAlteracaoVencimento()
					.equals(ConstantesSistema.SIM)) {

				Integer quantidadeMaximaRetificacoes = sistemaParametro
						.getNumeroLimiteAlteracaoVencimento();

				Integer quantidadeRetificacoes = this.repositorioFaturamento
						.obterQuantidadeAlteracoesVencimentoConta(idConta);

				if (quantidadeRetificacoes != null
						&& quantidadeMaximaRetificacoes != null
						&& quantidadeMaximaRetificacoes <= quantidadeRetificacoes) {
					throw new ControladorException(
							"atencao.retificacao_conta_nao_permitida", null,
							quantidadeMaximaRetificacoes.toString());
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Metodo que retornar o grupo de faturamento a partir do id do Imovel
	 * 
	 * @author Rômulo Aurélio
	 * @date 24/08/2010
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public FaturamentoGrupo recuperaGrupoFaturamentoDoImovel(Integer idImovel)
			throws ControladorException {

		FaturamentoGrupo faturamentoGrupo = null;
		try {

			faturamentoGrupo = repositorioFaturamento
					.recuperaGrupoFaturamentoDoImovel(idImovel);
		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}
		return faturamentoGrupo;
	}

	/**
	 * [UC0352] Emitir Contas e Cartas [SB0005] - Obter Dados da Medição da
	 * Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 20/09/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public Object[] obterLeituraAnteriorEAtualDaConta(Integer idConta)
			throws ControladorException {

		Object[] retorno = null;
		try {

			retorno = repositorioFaturamento
					.obterLeituraAnteriorEAtualConta(idConta);

			if (retorno == null) {
				retorno = repositorioFaturamento
						.obterLeituraAnteriorEAtualContaHistorico(idConta);
			}

		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC0629] Consultar Arquivo Texto para Leitura
	 * 
	 * [FS0015], [FS0016]
	 * 
	 * @autor Bruno Barros
	 * @date 18/11/2010
	 * @param idsArquivos
	 * @throws ErroRepositorioException
	 */
	public void gerarArquivoImoveisNaoEnviados(String[] idsArquivos)
			throws ControladorException, ErroRepositorioException {

		// Validamos todos os arquivos
		for (String id : idsArquivos) {
			FiltroArquivoTextoRoteiroEmpresa filArq = new FiltroArquivoTextoRoteiroEmpresa();
			filArq.adicionarParametro(new ParametroSimples(
					FiltroArquivoTextoRoteiroEmpresa.ID, id));

			filArq.adicionarCaminhoParaCarregamentoEntidade("rota.leiturista");
			filArq.adicionarCaminhoParaCarregamentoEntidade("rota.setorComercial");
			filArq.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupo");

			Collection<FiltroArquivoTextoRoteiroEmpresa> colArq = this
					.getControladorUtil().pesquisar(filArq,
							ArquivoTextoRoteiroEmpresa.class.getName());

			ArquivoTextoRoteiroEmpresa arq = (ArquivoTextoRoteiroEmpresa) Util
					.retonarObjetoDeColecao(colArq);

			String[] parametros = { arq.getLocalidade().getId().toString(),
					arq.getRota().getSetorComercial().getCodigo() + "",
					arq.getRota().getCodigo().toString() };

			if (arq.getSituacaoTransmissaoLeitura().getId().intValue() != SituacaoTransmissaoLeitura.EM_CAMPO) {

				ControladorException exception = new ControladorException(
						"atencao.arquivo_texto_nao_esta_em_campo");
				exception.setParametroMensagem(parametros);

				throw exception;
			}

			FiltroArquivoTextoRoteiroEmpresaDivisao filArqDiv = new FiltroArquivoTextoRoteiroEmpresaDivisao();
			filArqDiv
					.adicionarParametro(new ParametroSimples(
							FiltroArquivoTextoRoteiroEmpresaDivisao.ARQUIVO_TEXTO_ROTEIRO_EMPRESA_ID,
							id));
			Collection<FiltroArquivoTextoRoteiroEmpresaDivisao> colArqDiv = this
					.getControladorUtil().pesquisar(filArqDiv,
							ArquivoTextoRoteiroEmpresaDivisao.class.getName());

			if (colArqDiv != null && !colArqDiv.isEmpty()) {

				ControladorException exception = new ControladorException(
						"atencao.arquivo_texto_possue_arquivos_divididos");
				exception.setParametroMensagem(parametros);

				throw exception;
			}

			int quantidade = -1;

			try {
				quantidade = this.repositorioFaturamento
						.verificarQuantidadeImoveisMovimentoContaPreFaturada(
								arq.getAnoMesReferencia(), arq.getRota()
										.getId());
			} catch (ErroRepositorioException ex) {
				throw new ControladorException("erro.sistema", ex);
			}
			if (quantidade == 0) {
				ControladorException exception = new ControladorException(
						"atencao.nenhum_imovel_enviado");
				exception.setParametroMensagem(parametros);
				throw exception;
			}
			if (quantidade == arq.getQuantidadeImovel().intValue()) {
				ControladorException exception = new ControladorException(
						"atencao.todos_imoveis_enviados");
				exception.setParametroMensagem(parametros);
				throw exception;
			}
		}

		// Geramos
		for (String id : idsArquivos) {
			FiltroArquivoTextoRoteiroEmpresa filArq = new FiltroArquivoTextoRoteiroEmpresa();
			filArq.adicionarParametro(new ParametroSimples(
					FiltroArquivoTextoRoteiroEmpresa.ID, id));
			filArq.adicionarCaminhoParaCarregamentoEntidade("rota.leiturista");
			filArq.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupo");

			Collection<FiltroArquivoTextoRoteiroEmpresa> colArq = this
					.getControladorUtil().pesquisar(filArq,
							ArquivoTextoRoteiroEmpresa.class.getName());
			ArquivoTextoRoteiroEmpresa arq = (ArquivoTextoRoteiroEmpresa) Util
					.retonarObjetoDeColecao(colArq);

			this.gerarArquivoTextoParaFaturamento(arq.getRota(),
					arq.getAnoMesReferencia(), arq.getFaturamentoGrupo(),
					new Date(), Boolean.TRUE);
		}
	}

	/**
	 * [UC0204] Consultar Conta
	 * 
	 * Pesquisa o consumo faturado do imóvel
	 * 
	 * @author Mariana Victor
	 * @date 06/01/2011
	 * 
	 * @param [UC0204] Consultar Conta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] consultarConsumoCadastrado(Integer idImovel)
			throws ControladorException {

		Object[] retorno = null;
		try {

			retorno = repositorioFaturamento
					.consultarConsumoCadastrado(idImovel);

		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC0819] Gerar Historico do Encerramento do Faturamento
	 * 
	 * Metodo responsável pela transferência das contas canceladas.
	 * 
	 * @author Raphael Rossiter
	 * @date 08/02/2011
	 * 
	 * @param contasCanceladas
	 * @param anoMesFaturamentoSistemaParametro
	 * @throws ControladorException
	 */
	protected void gerarHistoricoDeContasCanceladasParaEncerrarFaturamento(List contasCanceladas, int anoMesFaturamentoSistemaParametro) throws ControladorException {
		try {
			Iterator iteratorContasCanceladas = contasCanceladas.iterator();

			while (iteratorContasCanceladas.hasNext()) {
				Conta conta = (Conta) iteratorContasCanceladas.next();

				this.transferirContasParaHistorico(Collections.singletonList(conta), anoMesFaturamentoSistemaParametro);
				this.atualizarIndicadorContaNoHistorico(Collections.singletonList(conta));

				iteratorContasCanceladas.remove();
				conta = null;
			}

		} catch (Exception e) {
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0819] Gerar Historico do Encerramento do Faturamento
	 * 
	 * Metodo responsável pela transferência dos débitos a cobrar cancelados
	 * 
	 * @author Raphael Rossiter
	 * @date 08/02/2011
	 * 
	 * @param colecaoDebitosTemporaria
	 * @throws ControladorException
	 */
	protected void gerarHistoricoDeDebitosACobrarCanceladosParaEncerrarFaturamento(List colecaoDebitosTemporaria) throws ControladorException {
		try {

			if (colecaoDebitosTemporaria != null && !colecaoDebitosTemporaria.isEmpty()) {
				this.transferirDebitosACobrarParaHistorico(colecaoDebitosTemporaria);
				this.atualizarIndicadorDebitoACobrarNoHistorico(colecaoDebitosTemporaria);
			}
		} catch (Exception e) {
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0819] Gerar Historico do Encerramento do Faturamento
	 * 
	 * Metodo responsável pela transferência dos créditos a realizar cancelados
	 * 
	 * @author Raphael Rossiter
	 * @date 08/02/2011
	 * 
	 * @param colecaoDebitosTemporaria
	 * @throws ControladorException
	 */
	protected void gerarHistoricoDeCreditosARealizarCanceladosParaEncerrarFaturamento(
			List colecaoCreditosTemporaria) throws ControladorException {

		try {

			if (colecaoCreditosTemporaria != null
					&& !colecaoCreditosTemporaria.isEmpty()) {
				this.transferirCreditoARealizarParaHistorico(colecaoCreditosTemporaria);
				// fim item 10

				// item 11
				this.atualizarIndicadorCreditosARealizarNoHistorico(colecaoCreditosTemporaria);
				// fim item 11
			}

		} catch (Exception e) {
			// sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0473] Consultar Dados Complementares do Imóvel
	 * 
	 * Pesquisa as matrículas associadas à mesma tarifa de consumo do imóvel.
	 * 
	 * @author Mariana Victor
	 * @date 06/01/2011
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> consultarMatriculasAssociadas(
			Integer idConsumoTarifa, Integer idImovel)
			throws ControladorException {

		Collection<Integer> retorno = null;
		try {

			retorno = repositorioFaturamento.consultarMatriculasAssociadas(
					idConsumoTarifa, idImovel);

		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC1122] Automatizar Perfis de Grandes Consumidores
	 * 
	 * Metodo responsável pela identificação dos grandes consumidores e
	 * alteração seus respectivos perfis.
	 * 
	 * @author Mariana Victor
	 * @date 07/02/2011
	 * 
	 * @param anoMesFaturamentoSistemaParametro
	 * @param idSetorComercial
	 * @throws ControladorException
	 */
	public void identificarGrandesConsumidores(Integer idLocalidade,
			int idFuncionalidadeIniciada) throws ControladorException {

		int idUnidadeIniciada = 0;

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.LOCALIDADE, idLocalidade);
		try {

			Collection<Imovel> colecaoImovel = this.repositorioImovel
					.consultarImovelLocalidade(idLocalidade);
			System.out.println("localidade: " + idLocalidade);

			if (colecaoImovel != null && !colecaoImovel.isEmpty()) {
				System.out.println("quantidade de imóveis: "
						+ colecaoImovel.size());

				Iterator iterator = colecaoImovel.iterator();
				int i = 0;

				while (iterator.hasNext()) {
					i++;
					Imovel imovel = (Imovel) iterator.next();

					Integer consumoFaturado = this.repositorioFaturamento
							.consultarImovelConsumoHistorico(imovel.getId());
					Short quantidadeEconomias = (Short) this.repositorioImovel
							.pesquisarObterQuantidadeEconomias(imovel);
					if (consumoFaturado != null) {
						if (imovel.getImovelPerfil().getId()
								.equals(ImovelPerfil.NORMAL)
								&& consumoFaturado >= (imovel.getLocalidade()
										.getConsumoGrandeUsuario() * quantidadeEconomias)) {

							this.repositorioImovel.atualizarImovelPerfil(
									imovel.getId(), ImovelPerfil.GRANDE_NO_MES);

						} else if (imovel.getImovelPerfil().getId()
								.equals(ImovelPerfil.GRANDE_NO_MES)
								&& consumoFaturado < (imovel.getLocalidade()
										.getConsumoGrandeUsuario() * quantidadeEconomias)) {

							this.repositorioImovel.atualizarImovelPerfil(
									imovel.getId(), ImovelPerfil.NORMAL);

						}
					}

				}
			}

			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) {
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0352] Emitir Contas e Cartas
	 * 
	 * [SB0048]  Obter Nome do Cliente
	 * 
	 * @author Mariana Victor
	 * @date 11/03/2011
	 * 
	 * */
	public String obterNomeCliente(Integer idConta) throws ControladorException {

		try {

			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			Cliente cliente = this.repositorioFaturamento
					.obterClienteConta(idConta);

			if (sistemaParametro.getIndicadorUsoNMCliReceitaFantasia().equals(
					ConstantesSistema.SIM)
					&& cliente.getIndicadorUsoNomeFantasiaConta().equals(
							ConstantesSistema.SIM)
					&& cliente.getNomeAbreviado() != null) {

				return cliente.getNomeAbreviado();

			} else {
				return cliente.getNome();
			}

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0366] Inserir Registro de Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @date 07/08/2009
	 * 
	 * @throws ControladorException
	 */
	public Integer verificarGeracaoBoleto(SistemaParametro sistemaParametro,
			Conta conta) throws ControladorException {

		Integer sequencialContaBoleto = null;

		/*
		 * Colocado por Raphael Rossiter em 04/03/2011 OBJ: Resolver o problema
		 * na baixa dos boletos pois a numeração que esta sendo gerada esta
		 * ultrapassando o limite de 8 caracteres que nós temos no código de
		 * barras.
		 * 
		 * Caso o valor limite definido pela empresa para identificar se uma
		 * conta será tratada como um boleto esteja nulo (PARM_VLCONTAFICHACOMP
		 * da tabela SISTEMA_PARAMETROS com valor NULO) ou esteja diferente de
		 * NULO e seja MENOR que o valor total da conta ((CNTA_VLAGUA +
		 * CNTA_VLESGOTO + CNTA_VLDEBITOS - CNTA_VLCREDITOS - CNTA_VLIMPOSTOS) <
		 * PARM_VLCONTAFICHACOMP da tabela SISTEMA_PARAMETROS), atribuir NULO;
		 * 
		 * caso contrário, atribuir a última numeração gerada para boleto mais
		 * um ( MAX (CNTA_NNBOLETO) + 1).
		 */
		if (sistemaParametro.getValorContaFichaComp() != null
				&& conta.getValorTotalContaBigDecimal().compareTo(
						sistemaParametro.getValorContaFichaComp()) > 0) {

			sequencialContaBoleto = this.gerarSequencialContaBoleto();
		}

		return sequencialContaBoleto;
	}

	/**
	 * [UC0366] Inserir Registro de Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @date 07/08/2009
	 * 
	 * @throws ControladorException
	 */
	public Integer gerarSequencialContaBoleto() throws ControladorException {

		Integer sequencialContaBoleto = null;

		try {

			sequencialContaBoleto = repositorioFaturamento
					.gerarSequencialContaBoleto();
		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

		return sequencialContaBoleto;
	}

	/**
	 * [UC0366] Inserir Registro de Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @date 07/08/2009
	 * 
	 * @throws ControladorException
	 */
	public Integer pesquisarSequencialContaBoleto(Integer idConta)
			throws ControladorException {

		Integer sequencialContaBoleto = null;

		try {

			sequencialContaBoleto = repositorioFaturamento
					.pesquisarSequencialContaBoleto(idConta);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

		return sequencialContaBoleto;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * @author Raphael Rossiter
	 * @date 11/04/2011
	 * 
	 * @param consumoTarifa
	 * @param anoMesReferencia
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection obterConsumoTarifaVigencia(ConsumoTarifa consumoTarifa,
			Integer anoMesReferencia, Date dataLeituraAnterior,
			Date dataLeituraAtual) throws ControladorException {

		Collection colecaoConsumoTarifaVigenciaTodasDatas = null;

		// SELECIONANDO as tarifas vigentes para a tarifa do imóvel
		if (consumoTarifa.getTarifaTipoCalculo().getId().intValue() == 3) {
			colecaoConsumoTarifaVigenciaTodasDatas = this
					.obterConsumoTarifaVigenciaCalcularAguaEsgotoPorMesAno(
							consumoTarifa.getId(), dataLeituraAnterior,
							dataLeituraAtual, anoMesReferencia);
		} else {
			colecaoConsumoTarifaVigenciaTodasDatas = this
					.obterConsumoTarifaVigenciaCalcularAguaEsgotoProporcionalPorData(
							consumoTarifa.getId(), dataLeituraAnterior,
							dataLeituraAtual, anoMesReferencia);
		}

		return colecaoConsumoTarifaVigenciaTodasDatas;
	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Pesquisa a quantidade de contas, agrupando por imóvel
	 * 
	 * @author: Mariana Victor
	 * @date: 12/05/2011
	 */
	public Collection<Object[]> pesquisarQuantidadeContasComandoAgrupandoPorImovel(
			MovimentarOrdemServicoEmitirOSHelper movimentarOrdemServicoEmitirOSHelper)
			throws ControladorException {

		try {

			return repositorioFaturamento
					.pesquisarQuantidadeContasComandoAgrupandoPorImovel(movimentarOrdemServicoEmitirOSHelper);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Pesquisa a quantidade de contas
	 * 
	 * @author: Mariana Victor
	 * @date: 12/05/2011
	 */
	public Object[] pesquisarQuantidadeContasComando(
			MovimentarOrdemServicoEmitirOSHelper movimentarOrdemServicoEmitirOSHelper)
			throws ControladorException {

		try {

			return repositorioFaturamento
					.pesquisarQuantidadeContasComando(movimentarOrdemServicoEmitirOSHelper);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Pesquisa as ordens de serviço selecionadas
	 * 
	 * @author: Mariana Victor
	 * @date: 19/05/2011
	 */
	public Collection<Integer[]> pesquisarOSComandoSelecionado(
			MovimentarOrdemServicoEmitirOSHelper movimentarOrdemServicoEmitirOSHelper)
			throws ControladorException {

		try {

			return repositorioFaturamento
					.pesquisarOSComandoSelecionado(movimentarOrdemServicoEmitirOSHelper);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

	}

	/**
	 * [UC1173] Informar Consumo por Parâmetros
	 * 
	 * [FS0005]  Validar mês ano maior ou igual
	 * 
	 * @author Mariana Victor
	 * @date 20/05/2011
	 * 
	 * @param anoMesReferenciaInformado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarAnoMesReferenciaMenorAnoMesReferenciaFaturamentoGrupo(
			int anoMesReferenciaInformado) throws ControladorException {

		try {

			return repositorioFaturamento
					.pesquisarAnoMesReferenciaMenorAnoMesReferenciaFaturamentoGrupo(anoMesReferenciaInformado);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

	}

	/**
	 * [UC0146] - Manter Conta
	 * 
	 * Metodo responsável por percorrer a lista de contas e retornar apenas as
	 * que não estão ligadas a algum Contrato de Parcelamento por Cliente
	 * 
	 * @author Mariana Victor
	 * @date 14/07/2011
	 * 
	 * @param colecaoContas
	 * 
	 * @return Collection<Conta>
	 */
	public Collection<Conta> obterColecaoSemContasEmContratoParcelamento(
			Collection colecaoContas) throws ControladorException {
		Collection<Conta> retorno = new ArrayList<Conta>();

		try {

			if (colecaoContas != null && !colecaoContas.isEmpty()) {
				Iterator iterator = colecaoContas.iterator();

				while (iterator.hasNext()) {
					Conta conta = (Conta) iterator.next();

					if (!repositorioCobranca
							.verificaContaVinculadaAContratoParcelAtivo(conta
									.getId())) {
						retorno.add(conta);
					}
				}
			}

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC0482] Emitir 2ª Via de Conta
	 * 
	 * Metodo responsável por percorrer a lista de contas e retornar apenas as
	 * que não estão ligadas a algum Contrato de Parcelamento por Cliente
	 * 
	 * @author Mariana Victor
	 * @date 14/07/2011
	 * 
	 * @param colecaoContas
	 * 
	 * @return Collection<Integer>
	 */
	public Collection<Integer> obterColecaoSemContasEmContratoParcelamentoIDs(
			Collection<Integer> colecaoIdsContas) throws ControladorException {
		Collection<Integer> retorno = new ArrayList<Integer>();

		try {

			if (colecaoIdsContas != null && !colecaoIdsContas.isEmpty()) {
				Iterator iterator = colecaoIdsContas.iterator();

				while (iterator.hasNext()) {
					Integer idConta = (Integer) iterator.next();

					if (!repositorioCobranca
							.verificaContaVinculadaAContratoParcelAtivo(idConta)) {
						retorno.add(idConta);
					}
				}
			}

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	

	/**
	 * [UC1187] Colocar Débito a Cobrar em Revisão
	 * 
	 * Este caso de uso permite colocar uma lista de débito a cobrar recebida em
	 * revisão.
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param colecaoDebitosACobrar
	 * @param contaMotivoRevisao
	 * @throws ControladorException
	 */
	public void colocarRevisaoDebitoACobrar(
			Collection<DebitoACobrar> colecaoDebitosACobrar,
			ContaMotivoRevisao contaMotivoRevisao, Usuario usuarioLogado)
			throws ControladorException {

		Iterator colecaoDebitosACobrarIt = colecaoDebitosACobrar.iterator();

		while (colecaoDebitosACobrarIt.hasNext()) {
			// 1. Para cada débito a cobrar da lista recebida o sistema atualiza
			// os seguintes atributos da tabela faturamento.DEBITO_A_COBRAR:
			DebitoACobrar debitoACobrar = (DebitoACobrar) colecaoDebitosACobrarIt
					.next();

			// 1.1. Data da revisão
			debitoACobrar.setDataRevisao(new Date());

			// 1.2. Motivo da revisão
			debitoACobrar.setContaMotivoRevisao(contaMotivoRevisao);

			// Ultima alteração
			debitoACobrar.setUltimaAlteracao(new Date());

			// Usuario
			debitoACobrar.setUsuario(usuarioLogado);

			try {
				repositorioFaturamento
						.colocarRevisaoDebitoACobrar(debitoACobrar);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}
		}
	}

	/**
	 * [UC1188] Retirar Débito A Cobrar de Revisão
	 * 
	 * Este caso de uso permite retirar de revisão uma lista de débito a cobrar
	 * recebida.
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param colecaoDebitosACobrar
	 * @param identificadores
	 * @throws ControladorException
	 */
	public void retirarRevisaoDebitoACobrar(
			Collection<Conta> colecaoDebitosACobrar, Usuario usuarioLogado)
			throws ControladorException {

		Iterator colecaoDebitosACobrarIt = colecaoDebitosACobrar.iterator();

		while (colecaoDebitosACobrarIt.hasNext()) {
			// 1. Para cada débito a cobrar da lista recebida o sistema atualiza
			// os seguintes atributos da tabela faturamento.DEBITO_A_COBRAR:
			DebitoACobrar debitoACobrar = (DebitoACobrar) colecaoDebitosACobrarIt
					.next();

			// 1.1. Data da revisão (DBAC _DTREVISAO =nulo)
			debitoACobrar.setDataRevisao(null);

			// 1.2. Motivo da revisão (MRVC_ID =nulo)
			debitoACobrar.setContaMotivoRevisao(null);

			// Ultima alteração
			debitoACobrar.setUltimaAlteracao(new Date());

			// Usuario
			debitoACobrar.setUsuario(usuarioLogado);

			try {
				repositorioFaturamento
						.retirarDebitoACobrarRevisao(debitoACobrar);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}
		}
	}

	/**
	 * [UC1136] Inserir Contrato de Parcelamento por Cliente
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param idDebitoACobrar
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public DebitoACobrar obterDebitoACobrar(Integer idDebitoACobrar)
			throws ControladorException {
		DebitoACobrar retorno = null;
		try {
			retorno = repositorioFaturamento
					.obterDebitoACobrar(idDebitoACobrar);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * @author Gustavo Amaral
	 * @date 20/07/2011
	 * 
	 */
	public void atualizarIndicadorContaHistorico(Integer idFaturaItem)
			throws ControladorException {

		try {

			repositorioFaturamento
					.atualizarIndicadorContaHistorico(idFaturaItem);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

	}

	/**
	 * Para testes
	 * 
	 * @author Rafael Pinto
	 * @date 30/07/2011
	 * 
	 */
	public void deletarResumoFaturamento(Integer anoMes)
			throws ControladorException {

		try {

			repositorioFaturamento.deletarResumoFaturamento(anoMes);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

	}

	/**
	 * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * [SB0002] ? Selecionar Débitos Pagos
	 * 
	 * @author Mariana Victor
	 * @date 23/08/2011
	 * 
	 * @param idImovel
	 * @param referenciaConta
	 * @return
	 * @throws ControladorException
	 */
	public Conta pesquisarContaOuContaHistoricoDigitada(String idImovel,
			String referenciaConta) throws ControladorException {

		// Variável que vai armazenar a conta pesquisada
		Conta contaDigitada = null;
		Object[] dadosConta = null;

		// Formata a referência da conta informada para o formato (AAAAMM) sem a
		// barra
		String anoMesConta = Util
				.formatarMesAnoParaAnoMesSemBarra(referenciaConta);

		// Cria o filtro de conta e seta todos os parâmetros para pesquisar a
		// conta do imóvel
		// Pesquisa imovel
		try {
			dadosConta = repositorioFaturamento
					.pesquisarContaOuContaHistoricoDigitada(idImovel,
							anoMesConta);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (dadosConta != null) {

			contaDigitada = new Conta();

			// Id da Conta
			if (dadosConta[0] != null) {
				contaDigitada.setId((Integer) dadosConta[0]);
			}

			// Referência
			if (dadosConta[1] != null) {
				contaDigitada.setReferencia((Integer) dadosConta[1]);
			}

			// Valor da Água
			if (dadosConta[2] != null) {
				contaDigitada.setValorAgua((BigDecimal) dadosConta[2]);
			}

			// Valor de Esgoto
			if (dadosConta[3] != null) {
				contaDigitada.setValorEsgoto((BigDecimal) dadosConta[3]);
			}

			// Débitos
			if (dadosConta[4] != null) {
				contaDigitada.setDebitos((BigDecimal) dadosConta[4]);
			}

			// Valor Créditos
			if (dadosConta[5] != null) {
				contaDigitada.setValorCreditos((BigDecimal) dadosConta[5]);
			}

			// Valor Imposto
			if (dadosConta[6] != null) {
				contaDigitada.setValorImposto((BigDecimal) dadosConta[6]);
			}

		}

		// Retorna a conta encontrada ou nulo se não existir a conta
		return contaDigitada;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 29/08/2011
	 * 
	 * @param idImovel
	 * 
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterPercentualColetaEsgotoImovel(Integer idImovel)
			throws ControladorException {

		BigDecimal percentualColeta = null;

		try {
			percentualColeta = repositorioFaturamento
					.obterPercentualColetaEsgotoImovel(idImovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		return percentualColeta;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 30/08/2011
	 * 
	 * @param idImovelMacro
	 * @param anoMesReferencia
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMovimentoContaPrefaturadaArquivoTextoFaturamento(
			Integer idImovelMacro, Integer anoMesReferencia)
			throws ControladorException {

		Integer qtdMovimentoContaPrefaturada = null;

		try {

			qtdMovimentoContaPrefaturada = repositorioFaturamento
					.pesquisarMovimentoContaPrefaturadaArquivoTextoFaturamento(
							idImovelMacro, anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return qtdMovimentoContaPrefaturada;
	}

	/**
	 *  Criação do método para converter um array com informações
	 * de imóveis em uma lista de objetos imóveis.
	 */
	/**
	 * @author Pamela Gatinho
	 * @date 21/02/2011
	 * 
	 * @return List<Imovel> lista de imóveis convertidos
	 * @param imoveis
	 * @param sistemaParametro
	 * @param faturamentoGrupo
	 * @param faturamentoGrupo
	 * @throws ErroRepositorioException
	 */
	private List<Imovel> converterImoveis(Collection imoveis,
			SistemaParametro sistemaParametro,
			FaturamentoGrupo faturamentoGrupo, Rota rota) {

		List<Imovel> imoveisConvertidos = null;

		// Carregando os dados dos imóveis selecionados
		if (imoveis != null && !imoveis.isEmpty()) {

			Iterator iteratorImoveis = imoveis.iterator();

			imoveisConvertidos = new ArrayList<Imovel>();

			Imovel imovel = null;

			while (iteratorImoveis.hasNext()) {

				Object[] arrayImovel = (Object[]) iteratorImoveis.next();

				imovel = new Imovel();

				// ID
				imovel.setId((Integer) arrayImovel[23]);

				// GERENCIA REGIONAL E LOCALIDADE
				GerenciaRegional gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setNome((String) arrayImovel[0]);
				gerenciaRegional.setId((Integer) arrayImovel[28]);

				Localidade localidade = new Localidade();
				localidade.setId((Integer) arrayImovel[1]);
				localidade.setDescricao((String) arrayImovel[2]);
				localidade.setGerenciaRegional(gerenciaRegional);

				imovel.setLocalidade(localidade);

				// SETOR_COMERCIAL
				SetorComercial setorComercial = new SetorComercial();
				setorComercial.setCodigo((Integer) arrayImovel[5]);
				if (arrayImovel[26] != null) {
					setorComercial.setId((Integer) arrayImovel[26]);
				}
				imovel.setSetorComercial(setorComercial);

				// LEITURISTA
				if (arrayImovel[39] != null) {
					Leiturista leiturista = rota.getLeiturista();
					if (arrayImovel[59] != null) {
						Usuario usuario = new Usuario();
						usuario.setLogin((String) arrayImovel[59]);
						usuario.setSenha((String) arrayImovel[60]);
						leiturista.setUsuario(usuario);
					}
					rota.setLeiturista(leiturista);
				}

				// GRUPO
				rota.setFaturamentoGrupo(faturamentoGrupo);

				Quadra quadra = new Quadra();
				quadra.setNumeroQuadra((Integer) arrayImovel[6]);
				quadra.setRota(rota);

				imovel.setQuadra(quadra);

				// QUADRA FACE
				if (arrayImovel[41] != null) {
					QuadraFace quadraFace = new QuadraFace();
					quadraFace.setId((Integer) arrayImovel[41]);
					if (arrayImovel[42] != null) {
						quadraFace
								.setNumeroQuadraFace((Integer) arrayImovel[42]);
					}

					imovel.setQuadraFace(quadraFace);
				}
				// SEQUENCIAL DA ROTA
				if (arrayImovel[27] != null) {
					imovel.setNumeroSequencialRota((Integer) arrayImovel[27]);
				}

				// LOTE E SUBLOTE
				imovel.setLote((Short) arrayImovel[7]);
				imovel.setSubLote((Short) arrayImovel[8]);

				// IMOVEL_NOME E CLIENTES: USUARIO E RESPONSAVEL
				imovel.setNomeImovel((String) arrayImovel[3]);

				Set colecaoClienteImovel = new HashSet();
				if (arrayImovel[4] != null) {
					ClienteRelacaoTipo clienteRelacaoTipo = new ClienteRelacaoTipo();
					clienteRelacaoTipo.setId(ClienteRelacaoTipo.USUARIO
							.intValue());

					Cliente clienteUsuario = new Cliente();
					clienteUsuario.setNome((String) arrayImovel[4]);

					if (arrayImovel[32] != null) {
						clienteUsuario.setCpf((String) arrayImovel[32]);
					}

					if (arrayImovel[33] != null) {
						clienteUsuario.setCnpj((String) arrayImovel[33]);
					}

					ClienteImovel clienteImovel = new ClienteImovel();
					clienteImovel.setCliente(clienteUsuario);
					clienteImovel.setClienteRelacaoTipo(clienteRelacaoTipo);

					colecaoClienteImovel.add(clienteImovel);
				}

				if (arrayImovel[9] != null) {
					ClienteRelacaoTipo clienteRelacaoTipo = new ClienteRelacaoTipo();
					clienteRelacaoTipo.setId(ClienteRelacaoTipo.RESPONSAVEL
							.intValue());

					Cliente clienteResponsavel = new Cliente();
					clienteResponsavel.setId((Integer) arrayImovel[9]);
					clienteResponsavel.setNome((String) arrayImovel[10]);

					ClienteImovel clienteImovel = new ClienteImovel();
					clienteImovel.setCliente(clienteResponsavel);
					clienteImovel.setClienteRelacaoTipo(clienteRelacaoTipo);

					colecaoClienteImovel.add(clienteImovel);
				}

				if (colecaoClienteImovel.size() > 0) {
					imovel.setClienteImoveis(colecaoClienteImovel);
				}

				// LIGACAO_AGUA_SITUACAO
				if (arrayImovel[11] != null) {
					LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
					ligacaoAguaSituacao.setId((Integer) arrayImovel[11]);
					ligacaoAguaSituacao
							.setIndicadorFaturamentoSituacao((Short) arrayImovel[29]);
					ligacaoAguaSituacao
							.setIndicadorAbastecimento((Short) arrayImovel[36]);
					ligacaoAguaSituacao.setDescricao((String) arrayImovel[38]);

					imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
				}

				// LIGACAO_ESGOTO_SITUACAO
				if (arrayImovel[12] != null) {
					LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
					ligacaoEsgotoSituacao.setId((Integer) arrayImovel[12]);
					ligacaoEsgotoSituacao
							.setIndicadorFaturamentoSituacao((Short) arrayImovel[30]);
					imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
				}

				// LIGACAO_ESGOTO - ConsumoMinimo
				LigacaoEsgoto ligacaoEsgoto = null;
				if (arrayImovel[14] != null) {
					ligacaoEsgoto = new LigacaoEsgoto();
					ligacaoEsgoto.setConsumoMinimo((Integer) arrayImovel[14]);

				}

				// LIGACAO_ESGOTO - Percentual
				if (arrayImovel[15] != null) {

					if (ligacaoEsgoto != null) {
						ligacaoEsgoto
								.setPercentualAguaConsumidaColetada((BigDecimal) arrayImovel[15]);
					} else {
						ligacaoEsgoto = new LigacaoEsgoto();
						ligacaoEsgoto
								.setPercentualAguaConsumidaColetada((BigDecimal) arrayImovel[15]);
					}
				}

				// percentual alternativo
				if (arrayImovel[63] != null) {
					if (ligacaoEsgoto != null) {
						ligacaoEsgoto
								.setPercentualAlternativo((BigDecimal) arrayImovel[63]);
					} else {
						ligacaoEsgoto = new LigacaoEsgoto();
						ligacaoEsgoto
								.setPercentualAlternativo((BigDecimal) arrayImovel[63]);
					}

				}
				// consumo percentual alternativo
				if (arrayImovel[64] != null) {
					if (ligacaoEsgoto != null) {
						ligacaoEsgoto
								.setNumeroConsumoPercentualAlternativo((Integer) arrayImovel[64]);
					} else {
						ligacaoEsgoto = new LigacaoEsgoto();
						ligacaoEsgoto
								.setNumeroConsumoPercentualAlternativo((Integer) arrayImovel[64]);
					}

				}
				imovel.setLigacaoEsgoto(ligacaoEsgoto);

				// FATURAMENTO_SITUACAO_TIPO
				if (arrayImovel[61] != null) {
					FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
					faturamentoSituacaoTipo.setId((Integer) arrayImovel[61]);
					faturamentoSituacaoTipo
							.setIndicadorParalisacaoFaturamento((Short) arrayImovel[16]);
					faturamentoSituacaoTipo
							.setIndicadorValidoAgua((Short) arrayImovel[17]);
					faturamentoSituacaoTipo
							.setIndicadorValidoEsgoto((Short) arrayImovel[18]);

					imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
				}

				// IMOVEL_CONDOMINIO
				if (arrayImovel[19] != null) {
					Imovel imovelCondominio = new Imovel();
					imovelCondominio.setId((Integer) arrayImovel[19]);

					imovel.setImovelCondominio(imovelCondominio);
				}

				// INDICADOR_IMOVEL_CONDOMINIO
				imovel.setIndicadorImovelCondominio((Short) arrayImovel[20]);

				// IMOVEL_PERFIL
				ImovelPerfil imovelPerfil = new ImovelPerfil();
				imovelPerfil.setId((Integer) arrayImovel[21]);

				imovel.setImovelPerfil(imovelPerfil);

				// CONSUMO_TARIFA
				ConsumoTarifa consumoTarifa = new ConsumoTarifa();
				consumoTarifa.setId((Integer) arrayImovel[22]);

				if (arrayImovel[25] != null) {
					TarifaTipoCalculo tarifaTipoCalculo = new TarifaTipoCalculo();
					tarifaTipoCalculo.setId((Integer) arrayImovel[25]);
					consumoTarifa.setTarifaTipoCalculo(tarifaTipoCalculo);
				}

				imovel.setConsumoTarifa(consumoTarifa);

				// POCO_TIPO
				if (arrayImovel[24] != null) {
					PocoTipo pocoTipo = new PocoTipo();
					pocoTipo.setId((Integer) arrayImovel[24]);

					imovel.setPocoTipo(pocoTipo);
				}

				// IMOVEL_CONTA_ENVIO
				if (arrayImovel[31] != null) {
					ImovelContaEnvio imovelContaEnvio = new ImovelContaEnvio();
					imovelContaEnvio.setId((Integer) arrayImovel[31]);

					imovel.setImovelContaEnvio(imovelContaEnvio);
				}

				boolean existeHidrometroAgua = false;
				if (arrayImovel[37] != null) {
					LigacaoAgua ligacaoAgua = new LigacaoAgua();
					ligacaoAgua.setId((Integer) arrayImovel[37]);
					if (arrayImovel[13] != null) {
						ligacaoAgua
								.setNumeroConsumoMinimoAgua((Integer) arrayImovel[13]);
					}
					if (arrayImovel[34] != null) {
						HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
						hidrometroInstalacaoHistorico
								.setId((Integer) arrayImovel[34]);
						// MEDICAO TIPO AGUA
						if (arrayImovel[44] != null) {
							MedicaoTipo medicaoTipo = new MedicaoTipo();
							medicaoTipo.setId((Integer) arrayImovel[44]);
							hidrometroInstalacaoHistorico
									.setMedicaoTipo(medicaoTipo);
						}
						// LOCAL INSTALACAO
						if (arrayImovel[53] != null) {
							HidrometroLocalInstalacao hidrometroLocalInstalacao = new HidrometroLocalInstalacao();
							hidrometroLocalInstalacao
									.setId((Integer) arrayImovel[53]);
							hidrometroInstalacaoHistorico
									.setHidrometroLocalInstalacao(hidrometroLocalInstalacao);
						}
						// DATA INSTALACAO
						if (arrayImovel[54] != null) {
							hidrometroInstalacaoHistorico
									.setDataInstalacao((Date) arrayImovel[54]);
						}
						// HIDROMETRO PROTECAO
						if (arrayImovel[55] != null) {
							HidrometroProtecao hidrometroProtecao = new HidrometroProtecao();
							hidrometroProtecao.setId((Integer) arrayImovel[55]);
							hidrometroInstalacaoHistorico
									.setHidrometroProtecao(hidrometroProtecao);
						}

						existeHidrometroAgua = true;
						ligacaoAgua
								.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
					}
					// NUMERO DO LACRE
					if (arrayImovel[46] != null) {
						ligacaoAgua.setNumeroLacre((String) arrayImovel[46]);
					}
					imovel.setLigacaoAgua(ligacaoAgua);
				}

				boolean existeHidrometroPoco = false;
				if (arrayImovel[35] != null) {
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
					hidrometroInstalacaoHistorico
							.setId((Integer) arrayImovel[35]);
					// MEDICAO TIPO AGUA
					if (arrayImovel[45] != null) {
						MedicaoTipo medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId((Integer) arrayImovel[45]);
						hidrometroInstalacaoHistorico
								.setMedicaoTipo(medicaoTipo);
					}
					// LOCAL INSTALACAO
					if (arrayImovel[56] != null) {
						HidrometroLocalInstalacao hidrometroLocalInstalacao = new HidrometroLocalInstalacao();
						hidrometroLocalInstalacao
								.setId((Integer) arrayImovel[56]);
						hidrometroInstalacaoHistorico
								.setHidrometroLocalInstalacao(hidrometroLocalInstalacao);
					}
					// DATA INSTALACAO
					if (arrayImovel[57] != null) {
						hidrometroInstalacaoHistorico
								.setDataInstalacao((Date) arrayImovel[57]);
					}
					// HIDROMETRO PROTECAO
					if (arrayImovel[58] != null) {
						HidrometroProtecao hidrometroProtecao = new HidrometroProtecao();
						hidrometroProtecao.setId((Integer) arrayImovel[58]);
						hidrometroInstalacaoHistorico
								.setHidrometroProtecao(hidrometroProtecao);
					}

					imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
					existeHidrometroAgua = true;
				}

				// NUMERO DE MORADORES
				if (arrayImovel[43] != null) {
					imovel.setNumeroMorador((Short) arrayImovel[43]);
				}

				// LOGRADOURO BAIRRO
				if (arrayImovel[47] != null) {
					LogradouroBairro logradouroBairro = new LogradouroBairro();
					logradouroBairro.setId((Integer) arrayImovel[47]);
					// LOGRADOURO
					if (arrayImovel[48] != null) {
						Logradouro logradouro = new Logradouro();
						logradouro.setId((Integer) arrayImovel[48]);
						logradouro.setNome((String) arrayImovel[49]);
						logradouroBairro.setLogradouro(logradouro);
					}
					// BAIRRO
					if (arrayImovel[50] != null) {
						Bairro bairro = new Bairro();
						bairro.setNome((String) arrayImovel[50]);
						logradouroBairro.setBairro(bairro);
					}

					imovel.setLogradouroBairro(logradouroBairro);
				}

				// NUMERO DO IMOVEL
				if (arrayImovel[51] != null) {
					imovel.setNumeroImovel((String) arrayImovel[51]);
				}

				// COMPLEMENTO ENDERECO
				if (arrayImovel[52] != null) {
					imovel.setComplementoEndereco((String) arrayImovel[52]);
				}

				// CODIGO DÉBITO AUTOMÁTICO
				if (arrayImovel[62] != null) {
					imovel.setCodigoDebitoAutomatico((Integer) arrayImovel[62]);
				}

				boolean emitir = true;
				if (sistemaParametro.getCodigoEmpresaFebraban().equals(
						SistemaParametro.CODIGO_EMPRESA_FEBRABAN_CAERN)) {
					if (imovel.getImovelContaEnvio() != null
							&& (imovel.getImovelContaEnvio().getId()
									.equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL_FINAL_GRUPO))) {
						emitir = false;
					}
				} else {
					if (sistemaParametro.getCodigoEmpresaFebraban().equals(
							SistemaParametro.CODIGO_EMPRESA_FEBRABAN_COMPESA)) {
						if (imovel.getImovelContaEnvio() != null
								&& (imovel
										.getImovelContaEnvio()
										.getId()
										.equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL) || imovel
										.getImovelContaEnvio()
										.getId()
										.equals(ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL))) {
							emitir = false;
						}
					}
				}

				if ((imovel.getImovelCondominio() != null
						&& imovel.getImovelCondominio().getId() != null && !imovel
						.getImovelCondominio().getId().equals(""))
						|| imovel.getIndicadorImovelCondominio().equals(
								ConstantesSistema.SIM)) {
					emitir = true;
				}

				// caso seja para emtir ou seja medido de água ou poço
				if (emitir || existeHidrometroAgua || existeHidrometroPoco) {
					imoveisConvertidos.add(imovel);
				}
			}
		}

		return imoveisConvertidos;
	}

	/**
	 * Recupera a data realizada do faturamento atividade cronograma
	 * 
	 * @author Sávio Luiz
	 * @date 28/08/2007
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarFaturamentoAtividadeCronogramaDataRealizada(
			Integer faturamentoGrupoId, Integer faturamentoAtividadeId,
			Integer anoMesReferencia) throws ControladorException {

		try {

			return (Date) repositorioFaturamento
					.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
							faturamentoGrupoId, faturamentoAtividadeId,
							anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 *
	 * 
	 * Método para retornar uma coleção de debitos cobrados do parcelamento
	 * */
	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0002] - Obter dados dos serviços de parcelamento
	 * 
	 * @author Adriana Muniz
	 * @date 13/05/2011
	 * 
	 * @param conta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoCobradoDeParcelamentoIS(Conta conta)
			throws ControladorException {
		try {
			return repositorioFaturamento
					.pesquisarDebitoCobradoDeParcelamentoIS(conta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @TODO - COSANPA
	 * 
	 *       Método para obter imóveis com conta PF
	 * 
	 * @author Felipe Santos
	 * @date 25/05/2011
	 */
	public Collection obterImoveisComContaPF(Integer anoMesFaturamento,
			Rota rota) throws ControladorException {

		Collection colecaoImoveisComContaPF = new ArrayList();

		try {
			colecaoImoveisComContaPF = repositorioFaturamento
					.obterImoveisComContaPF(anoMesFaturamento, rota);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return colecaoImoveisComContaPF;
	}

	/**
	 *
	 * 
	 * Método para obter todos os imóveis que já foram processados na
	 * transmissão do arquivo de retorno do IS
	 * 
	 * @author Felipe Santos
	 * @date 22/08/2011
	 * 
	 * @param idRota
	 * @return List<Integer> retorno
	 * @throws ErroRepositorioException
	 */
	public List<Integer> obterImoveisMovimentoContaPF(Integer idRota,
			Integer anoMesFaturamento) throws ControladorException {

		List<Integer> listaImoveisMovimentoContaPF = null;

		try {
			listaImoveisMovimentoContaPF = repositorioFaturamento
					.obterImoveisMovimentoContaPF(idRota, anoMesFaturamento);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return listaImoveisMovimentoContaPF;
	}

	/**
	 *
	 * 
	 * Método para obter todos os imóveis que faltam ser transmitidos na
	 * transmissão do arquivo de retorno do IS
	 * 
	 * @author Felipe Santos
	 * @date 24/08/2011
	 * 
	 * @param idRota
	 * @return List<Integer> retorno
	 * @throws ErroRepositorioException
	 */
	public List<Integer> obterImoveisFaltandoTransmitir(Integer idRota,
			Integer anoMesFaturamento) throws ControladorException {

		List<Integer> listaImoveisFaltandoTransmitir = null;

		try {
			listaImoveisFaltandoTransmitir = repositorioFaturamento
					.obterImoveisFaltandoTransmitir(idRota, anoMesFaturamento);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return listaImoveisFaltandoTransmitir;
	}

	/**
	 * 
	 * 
	 * @author Pamela Gatinho
	 * @date 04/08/2011
	 * 
	 *       Metodo que obtem a conta do imóvel, so não retorna a conta que
	 *       estiver com a situacao CANCELADA POR RETIFICACAO
	 * 
	 * @return Conta
	 * @param anoMesReferencia
	 * @param idImovel
	 * @throws ErroRepositorioException
	 */
	public Conta obterContaImovel(Integer idImovel, Integer anoMesReferencia)
			throws ControladorException {
		try {
			return repositorioFaturamento.obterContaImovel(idImovel,
					anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * 
	 * Atualizar movimento conta pre-faturada
	 * 
	 * @author Pamela Gatinho
	 * @date 19/09/2011
	 * 
	 * @param conta
	 * @throws ControladorException
	 */
	protected void atualizarMovimentoContaPreFaturada(Conta conta)
			throws ControladorException {

		FiltroMovimentoContaPrefaturada filtroMovimentoContaPrefaturada = new FiltroMovimentoContaPrefaturada();
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("imovel.hidrometroInstalacaoHistorico");
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupo");
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("imovel.ligacaoAgua");
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("leituraAnormalidadeFaturamento");
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("imovel.quadra.rota");
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("conta");
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("movimentoContaPrefaturadaCategorias");
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("conta.ligacaoAguaSituacao");
		filtroMovimentoContaPrefaturada
				.adicionarCaminhoParaCarregamentoEntidade("conta.ligacaoEsgotoSituacao");

		filtroMovimentoContaPrefaturada
				.adicionarParametro(new ParametroSimples(
						FiltroMovimentoContaPrefaturada.MATRICULA, conta
								.getImovel().getId()));

		filtroMovimentoContaPrefaturada
				.adicionarParametro(new ParametroSimples(
						FiltroMovimentoContaPrefaturada.ANO_MES_REFERENCIA_PRE_FATURAMENTO,
						conta.getReferencia()));

		Collection<MovimentoContaPrefaturada> colMovimentoContaPrefaturada = null;

		try {
			colMovimentoContaPrefaturada = (Collection<MovimentoContaPrefaturada>) repositorioUtil
					.pesquisar(filtroMovimentoContaPrefaturada,
							MovimentoContaPrefaturada.class.getName());

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		if (colMovimentoContaPrefaturada != null
				&& !colMovimentoContaPrefaturada.isEmpty()) {

			Iterator iteratorColecaoMovimentoContaPreFaturada = colMovimentoContaPrefaturada
					.iterator();

			MovimentoContaPrefaturada movimentoContaPreFaturada = null;

			if (!movimentoContaPreFaturada.getConta().getId()
					.equals(conta.getId())) {

				while (iteratorColecaoMovimentoContaPreFaturada.hasNext()) {

					try {
						movimentoContaPreFaturada = (MovimentoContaPrefaturada) iteratorColecaoMovimentoContaPreFaturada
								.next();

						movimentoContaPreFaturada.setConta(conta);

						repositorioFaturamento
								.atualizarMovimentoContaPrefaturadaProcessoMOBILE(movimentoContaPreFaturada);

					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				}
			}

			colMovimentoContaPrefaturada.clear();
			colMovimentoContaPrefaturada = null;

		}
	}

	private void atualizarVencimentoContasNaoImpressas(FaturamentoGrupo grupo,
			Integer anoMesReferencia, Date novaDataVencimento)
			throws ControladorException {

		Collection<Conta> colConta = this.obterContasNaoImpressas(grupo,
				anoMesReferencia);

		if (colConta != null && !colConta.isEmpty()) {

			Iterator iteratorColecaoConta = colConta.iterator();

			while (iteratorColecaoConta.hasNext()) {

				try {
					Conta conta = (Conta) iteratorColecaoConta.next();

					if (Util.compararData(conta.getDataVencimentoOriginal(),
							novaDataVencimento) == -1) {
						conta.setDataVencimentoConta(novaDataVencimento);

						repositorioFaturamento
								.atualizarContaProcessoMOBILE(conta);
					}
				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
			}
		}
	}

	/**
	 *  Data: 25/10/2011 Autor: Pamela Gatinho
	 * 
	 * Metodo para pesquisar todas as contas que foram emitidas mas que serao
	 * impressas somente no fechamento do faturamento do grupo
	 * 
	 * @param grupo
	 * @param anoMesReferencia
	 * @return
	 * @throws ControladorException
	 */
	private Collection obterContasNaoImpressas(FaturamentoGrupo grupo,
			Integer anoMesReferencia) throws ControladorException {

		Collection<Conta> colConta = null;

		try {
			colConta = (Collection<Conta>) repositorioFaturamento
					.obterContasNaoImpressas(grupo, anoMesReferencia);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return colConta;
	}

	/**
	 * 
	 * 
	 * @author Pamela Gatinho
	 * @date 24/02/2012
	 * 
	 *       Metodo que obtem o movimento do imóvel lido pelo IS
	 * 
	 * @return MovimentoContaPreFaturada
	 * @param anoMesReferencia
	 * @param idImovel
	 * @throws ErroRepositorioException
	 */
	public MovimentoContaPrefaturada obterMovimentoImovel(Integer idImovel,
			Integer anoMesReferencia) throws ControladorException {
		try {
			return repositorioFaturamento.obterMovimentoImovel(idImovel,
					anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 *  Pamela Gatinho - 31/05/2012
	 * 
	 * Metodo que calcula o valor de rateio por economia
	 * 
	 * @param idImovelCondominio
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	private BigDecimal[] calcularValorRateioPorEconomia(Integer idImovelCondominio, FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		BigDecimal valorAguaRateioPorEconomia = new BigDecimal("0.00");
		BigDecimal valorEsgotoRateioPorEconomia = new BigDecimal("0.00");

		BigDecimal[] valoresAguaEsgotoRateioPorEconomia = new BigDecimal[2];

		int qtdEconomiasCondominio = this.getControladorMicromedicao().obterQuantidadeEconomiasCondominio(idImovelCondominio, faturamentoGrupo.getAnoMesReferencia());
		
		System.out.println("Qtd economias: " + qtdEconomiasCondominio);
		Imovel imovelCondominio = (Imovel) getControladorImovel().pesquisarImovel(idImovelCondominio);

		BigDecimal[] valoresAguaEsgotoContaRateio = this.obterValorConsumoASerRateado(imovelCondominio, faturamentoGrupo);
		
		if (valoresAguaEsgotoContaRateio[0].compareTo(ConstantesSistema.VALOR_ZERO) > 0) {
			valoresAguaEsgotoContaRateio[0] = valoresAguaEsgotoContaRateio[0].add(new BigDecimal(0.005));

			valorAguaRateioPorEconomia = valoresAguaEsgotoContaRateio[0].divide(new BigDecimal(qtdEconomiasCondominio), BigDecimal.ROUND_FLOOR);
		}

		if (valoresAguaEsgotoContaRateio[1].compareTo(ConstantesSistema.VALOR_ZERO) > 0) {
			valoresAguaEsgotoContaRateio[1] = valoresAguaEsgotoContaRateio[1].add(new BigDecimal(0.005));

			valorEsgotoRateioPorEconomia = valoresAguaEsgotoContaRateio[1].divide(new BigDecimal(qtdEconomiasCondominio), BigDecimal.ROUND_FLOOR);

		}

		System.out.println("Valor rateio água: " + valoresAguaEsgotoContaRateio[0]);
		System.out.println("Valor rateio esgoto: " + valoresAguaEsgotoContaRateio[1]);
		valoresAguaEsgotoRateioPorEconomia[0] = valorAguaRateioPorEconomia;
		valoresAguaEsgotoRateioPorEconomia[1] = valorEsgotoRateioPorEconomia;

		return valoresAguaEsgotoRateioPorEconomia;
	}
	
	public BigDecimal[] obterValorConsumoASerRateado(Imovel imovelCondominio, FaturamentoGrupo faturamentoGrupo) throws ControladorException {
		int consumoAguaASerRateado = 0;
		int consumoEsgotoASerRateado = 0;
		logger.info("		obterValorConsumoASerRateado");
		logger.info("Ligacao agua: " );
		if (imovelCondominio.getLigacaoAgua() != null) {
			logger.info("Ligacao agua: " );
			consumoAguaASerRateado = this.getControladorMicromedicao().obterConsumoASerRateado(imovelCondominio.getId(), faturamentoGrupo.getAnoMesReferencia(),
					LigacaoTipo.LIGACAO_AGUA);
		}

		logger.info("Ligacao esgoto: " + imovelCondominio.getLigacaoEsgoto() != null);
		if (imovelCondominio.getLigacaoEsgoto() != null) {
			consumoEsgotoASerRateado = this.getControladorMicromedicao().obterConsumoASerRateado(imovelCondominio.getId(), faturamentoGrupo.getAnoMesReferencia(),
					LigacaoTipo.LIGACAO_ESGOTO);
		}

		if (consumoAguaASerRateado < 0) {
			consumoAguaASerRateado = 0;
		}
		if (consumoEsgotoASerRateado < 0) {
			consumoEsgotoASerRateado = 0;
		}

		return this.calcularValorAguaEsgotoParaRateio(imovelCondominio, consumoAguaASerRateado, consumoEsgotoASerRateado, faturamentoGrupo);
	}

	/**
	 * 
	 * 
	 * @author Pamela Gatinho
	 * @since 23/04/2012
	 * 
	 *        Método que calcula o VALOR a ser rateado, baseado no CONSUMO de
	 *        rateio do macro.
	 * 
	 * @param imovelCondominio
	 * @param consumoSerRateado
	 * @param consumoAguaSerRateado
	 * @param faturamentoGrupo
	 * 
	 * @return valorConta
	 * 
	 * @throws ControladorException
	 */
	private BigDecimal[] calcularValorAguaEsgotoParaRateio(Imovel imovelCondominio, int consumoAguaASerRateado, int consumoEsgotoASerRateado, 
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		LigacaoTipo ligacaoTipo = new LigacaoTipo();

		Collection colecaoCategoriaOUSubcategoria = getControladorImovel().obterQuantidadeEconomiasCategoria(imovelCondominio);

		BigDecimal[] valoresContaRateio = new BigDecimal[2];
		valoresContaRateio[0] = new BigDecimal("0.00");
		valoresContaRateio[1] = new BigDecimal("0.00");

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		DeterminarValoresFaturamentoAguaEsgotoHelper helperValoresAguaEsgoto = new DeterminarValoresFaturamentoAguaEsgotoHelper();

		Collection colecaoCategorias = getControladorImovel().obterColecaoCategoriaOuSubcategoriaDoImovel(imovelCondominio);

		int consumoMinimoLigacao = this.getControladorMicromedicao().obterConsumoMinimoLigacao(imovelCondominio, null);

		if (consumoAguaASerRateado > 0 && consumoAguaASerRateado <= consumoMinimoLigacao) {
			consumoAguaASerRateado = consumoMinimoLigacao;
		}

		if (consumoEsgotoASerRateado > 0 && consumoEsgotoASerRateado <= consumoMinimoLigacao) {
			consumoEsgotoASerRateado = consumoMinimoLigacao;
		}

		ConsumoHistorico consumoHistoricoAgua = null;

		if (imovelCondominio.getLigacaoAgua() != null) {
			// Consultando o consumoHistorico de ÁGUA
			ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

			consumoHistoricoAgua = this.getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovelCondominio, ligacaoTipo,
					faturamentoGrupo.getAnoMesReferencia());

			consumoHistoricoAgua.setNumeroConsumoFaturadoMes(consumoAguaASerRateado);

		}

		ConsumoHistorico consumoHistoricoEsgoto = null;

		if (imovelCondominio.getLigacaoEsgoto() != null) {
			// Consultando o consumoHistorico de ESGOTO
			ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

			consumoHistoricoEsgoto = this.getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovelCondominio, ligacaoTipo,
					faturamentoGrupo.getAnoMesReferencia());

			consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoEsgotoASerRateado);

		}

		helperValoresAguaEsgoto = this.determinarValoresFaturamentoAguaEsgoto(imovelCondominio, faturamentoGrupo.getAnoMesReferencia(),
				colecaoCategoriaOUSubcategoria, faturamentoGrupo, consumoHistoricoAgua, consumoHistoricoEsgoto);

		if (consumoAguaASerRateado > 0 && helperValoresAguaEsgoto.getValorTotalAgua() != null) {
			valoresContaRateio[0] = helperValoresAguaEsgoto.getValorTotalAgua();
		}

		if (consumoEsgotoASerRateado > 0 && helperValoresAguaEsgoto.getValorTotalEsgoto() != null) {
			valoresContaRateio[1] = helperValoresAguaEsgoto.getValorTotalEsgoto();
		}

		System.out.println("Valor agua: " + helperValoresAguaEsgoto.getValorTotalAgua());
		System.out.println("Valor esgoto: " + helperValoresAguaEsgoto.getValorTotalEsgoto());

		return valoresContaRateio;
	}

	public BigDecimal[] calcularValorRateioImovel(Imovel imovel, FaturamentoGrupo faturamentoGrupo) throws ControladorException, ErroRepositorioException {

		BigDecimal valorRateioImovelAgua = ConstantesSistema.VALOR_ZERO;
		BigDecimal valorRateioImovelEsgoto = new BigDecimal("0.00");
		BigDecimal[] valoresRateioImovel = new BigDecimal[2];

		imovel = this.getControladorImovel().pesquisarImovel(imovel.getId());

		valoresRateioImovel = this.calcularValorRateioPorEconomia(imovel.getImovelCondominio().getId(), faturamentoGrupo);

		if (valoresRateioImovel[0].compareTo(ConstantesSistema.VALOR_ZERO) > 0) {
			valorRateioImovelAgua = valoresRateioImovel[0].multiply(new BigDecimal(imovel.getQuantidadeEconomias()));
		}

		if (valoresRateioImovel[1].compareTo(ConstantesSistema.VALOR_ZERO) > 0) {
			valorRateioImovelEsgoto = valoresRateioImovel[1].multiply(new BigDecimal(imovel.getQuantidadeEconomias()));
		}

		valoresRateioImovel[0] = valorRateioImovelAgua;
		valoresRateioImovel[1] = valorRateioImovelEsgoto;

		return valoresRateioImovel;
	}

	public String[] obterDadosQualidadeAguaCosanpa(
			EmitirContaHelper emitirConta, Integer idQuadraFace)
			throws ControladorException {

		String[] retornoQualidade = new String[25];

		String padraoCor = "";
		String padraoTurbidez = "";
		String padraoFluor = "";
		String padraoCloro = "";
		String padraoColiformesTotais = "";
		String padraoColiformesTermotolerantes = "";

		String exigidaCor = "";
		String exigidaTurbidez = "";
		String exigidaFluor = "";
		String exigidaCloro = "";
		String exigidaColiformesTotais = "";
		String exigidaColiformesTermotolerantes = "";

		String analisadaCor = "";
		String analisadaTurbidez = "";
		String analisadaFluor = "";
		String analisadaCloro = "";
		String analisadaColiformesTotais = "";
		String analisadaColiformesTermotolerantes = "";

		String emConformidadeCor = "";
		String emConformidadeTurbidez = "";
		String emConformidadeFluor = "";
		String emConformidadeCloro = "";
		String emConformidadeColiformesTotais = "";
		String emConformidadeColiformesTermotolerantes = "";

		String tipoCaptacao = "";

		// Qualidade da Agua Padrao
		FiltroQualidadeAguaPadrao filtroQualidadeAguaPadrao = new FiltroQualidadeAguaPadrao();

		Collection colecaoQualidAguaPadrao = getControladorUtil().pesquisar(
				filtroQualidadeAguaPadrao, QualidadeAguaPadrao.class.getName());

		if (colecaoQualidAguaPadrao != null
				&& !colecaoQualidAguaPadrao.isEmpty()) {

			QualidadeAguaPadrao qualidadePadrao = (QualidadeAguaPadrao) colecaoQualidAguaPadrao
					.iterator().next();

			padraoCor = qualidadePadrao.getDescricaoPadraoCor();
			padraoTurbidez = qualidadePadrao.getDescricaoPadraoTurbidez();
			padraoFluor = qualidadePadrao.getDescricaoPadraoFluor();
			padraoCloro = qualidadePadrao.getDescricaoPadraoCloro();
			padraoColiformesTotais = qualidadePadrao
					.getDescricaoPadraoColiformesTotais();
			padraoColiformesTermotolerantes = qualidadePadrao
					.getDescricaoPadraoColiformesTermotolerantes();

		}

		// Qualidade da Agua em 4 Niveis

		FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();

		Collection colecaoQualidadeAgua = null;

		FiltroQuadraFace filtroQuadraFace = new FiltroQuadraFace();
		filtroQuadraFace.adicionarParametro(new ParametroSimples(
				FiltroQuadraFace.ID, idQuadraFace));

		filtroQuadraFace
				.adicionarCaminhoParaCarregamentoEntidade("distritoOperacional");
		filtroQuadraFace
				.adicionarCaminhoParaCarregamentoEntidade("distritoOperacional.setorAbastecimento");
		filtroQuadraFace
				.adicionarCaminhoParaCarregamentoEntidade("distritoOperacional.setorAbastecimento.sistemaAbastecimento");
		filtroQuadraFace
				.adicionarCaminhoParaCarregamentoEntidade("distritoOperacional.setorAbastecimento.sistemaAbastecimento.fonteCaptacao");
		filtroQuadraFace
				.adicionarCaminhoParaCarregamentoEntidade("distritoOperacional.setorAbastecimento.sistemaAbastecimento.fonteCaptacao.tipoCaptacao");

		Collection colecaoQudraFace = getControladorUtil().pesquisar(
				filtroQuadraFace, QuadraFace.class.getName());

		QuadraFace quadraFace = (QuadraFace) Util
				.retonarObjetoDeColecao(colecaoQudraFace);

		if (quadraFace.getDistritoOperacional() != null
				&& quadraFace.getDistritoOperacional().getSetorAbastecimento() != null
				&& quadraFace.getDistritoOperacional().getSetorAbastecimento()
						.getSistemaAbastecimento() != null) {

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
					FiltroQualidadeAgua.SISTEMA_ABASTECIMENTO, quadraFace
							.getDistritoOperacional().getSetorAbastecimento()
							.getSistemaAbastecimento().getId()));

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
					FiltroQualidadeAgua.ANO_MES_REFERENCIA, emitirConta
							.getAmReferencia()));

			if (quadraFace.getDistritoOperacional().getSetorAbastecimento()
					.getSistemaAbastecimento().getFonteCaptacao() != null
					&& quadraFace.getDistritoOperacional()
							.getSetorAbastecimento().getSistemaAbastecimento()
							.getFonteCaptacao().getTipoCaptacao() != null) {

				tipoCaptacao = quadraFace.getDistritoOperacional()
						.getSetorAbastecimento().getSistemaAbastecimento()
						.getFonteCaptacao().getTipoCaptacao().getId()
						+ "";
			}

			filtroQualidadeAgua
					.adicionarCaminhoParaCarregamentoEntidade("fonteCaptacao");
			filtroQualidadeAgua
					.adicionarCaminhoParaCarregamentoEntidade("fonteCaptacao.tipoCaptacao");

			colecaoQualidadeAgua = getControladorUtil().pesquisar(
					filtroQualidadeAgua, QualidadeAgua.class.getName());

		}

		// Com Localidade e Setor
		if (colecaoQualidadeAgua == null || colecaoQualidadeAgua.isEmpty()) {

			filtroQualidadeAgua.limparListaParametros();

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
					FiltroQualidadeAgua.LOCALIDADE_ID, emitirConta
							.getIdLocalidade()));

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
					FiltroQualidadeAgua.SETOR_COMERCIAL_ID, emitirConta
							.getIdSetorComercial()));

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
					FiltroQualidadeAgua.ANO_MES_REFERENCIA, emitirConta
							.getAmReferencia()));

			filtroQualidadeAgua
					.adicionarCaminhoParaCarregamentoEntidade("fonteCaptacao");
			filtroQualidadeAgua
					.adicionarCaminhoParaCarregamentoEntidade("fonteCaptacao.tipoCaptacao");

			colecaoQualidadeAgua = getControladorUtil().pesquisar(
					filtroQualidadeAgua, QualidadeAgua.class.getName());
		}

		// Com Localidade
		if (colecaoQualidadeAgua == null || colecaoQualidadeAgua.isEmpty()) {

			filtroQualidadeAgua.limparListaParametros();

			colecaoQualidadeAgua = null;
			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
					FiltroQualidadeAgua.LOCALIDADE_ID, emitirConta
							.getIdLocalidade()));

			filtroQualidadeAgua.adicionarParametro(new ParametroNulo(
					FiltroQualidadeAgua.SETOR_COMERCIAL_ID));

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
					FiltroQualidadeAgua.ANO_MES_REFERENCIA, emitirConta
							.getAmReferencia()));

			filtroQualidadeAgua
					.adicionarCaminhoParaCarregamentoEntidade("fonteCaptacao");
			filtroQualidadeAgua
					.adicionarCaminhoParaCarregamentoEntidade("fonteCaptacao.tipoCaptacao");

			colecaoQualidadeAgua = getControladorUtil().pesquisar(
					filtroQualidadeAgua, QualidadeAgua.class.getName());
		}

		// Sem Localidade e sem Setor
		if (colecaoQualidadeAgua == null || colecaoQualidadeAgua.isEmpty()) {

			filtroQualidadeAgua.limparListaParametros();

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(
					FiltroQualidadeAgua.ANO_MES_REFERENCIA, emitirConta
							.getAmReferencia()));

			filtroQualidadeAgua.adicionarParametro(new ParametroNulo(
					FiltroQualidadeAgua.LOCALIDADE_ID));

			filtroQualidadeAgua.adicionarParametro(new ParametroNulo(
					FiltroQualidadeAgua.SETOR_COMERCIAL_ID));

			filtroQualidadeAgua
					.adicionarCaminhoParaCarregamentoEntidade("fonteCaptacao");
			filtroQualidadeAgua
					.adicionarCaminhoParaCarregamentoEntidade("fonteCaptacao.tipoCaptacao");

			colecaoQualidadeAgua = getControladorUtil().pesquisar(
					filtroQualidadeAgua, QualidadeAgua.class.getName());
		}

		if (colecaoQualidadeAgua != null && !colecaoQualidadeAgua.isEmpty()) {

			QualidadeAgua qualidadeAgua = (QualidadeAgua) colecaoQualidadeAgua
					.iterator().next();

			// Exigidas
			if (qualidadeAgua.getQuantidadeCorExigidas() != null) {
				exigidaCor = qualidadeAgua.getQuantidadeCorExigidas() + "";
			}

			if (qualidadeAgua.getQuantidadeTurbidezExigidas() != null) {
				exigidaTurbidez = qualidadeAgua.getQuantidadeTurbidezExigidas()
						+ "";
			}

			if (qualidadeAgua.getQuantidadeFluorExigidas() != null) {
				exigidaFluor = qualidadeAgua.getQuantidadeFluorExigidas() + "";
			}

			if (qualidadeAgua.getQuantidadeCloroExigidas() != null) {
				exigidaCloro = qualidadeAgua.getQuantidadeCloroExigidas() + "";
			}

			if (qualidadeAgua.getQuantidadeColiformesTotaisExigidas() != null) {
				exigidaColiformesTotais = qualidadeAgua
						.getQuantidadeColiformesTotaisExigidas() + "";
			}

			if (qualidadeAgua.getQuantidadeColiformesTermotolerantesExigidas() != null) {
				exigidaColiformesTermotolerantes = qualidadeAgua
						.getQuantidadeColiformesTermotolerantesExigidas() + "";
			}

			// Analisadas
			if (qualidadeAgua.getQuantidadeCorAnalisadas() != null) {
				analisadaCor = qualidadeAgua.getQuantidadeCorAnalisadas() + "";
			}

			if (qualidadeAgua.getQuantidadeTurbidezAnalisadas() != null) {
				analisadaTurbidez = qualidadeAgua
						.getQuantidadeTurbidezAnalisadas() + "";
			}

			if (qualidadeAgua.getQuantidadeFluorAnalisadas() != null) {
				analisadaFluor = qualidadeAgua.getQuantidadeFluorAnalisadas()
						+ "";
			}

			if (qualidadeAgua.getQuantidadeCloroAnalisadas() != null) {
				analisadaCloro = qualidadeAgua.getQuantidadeCloroAnalisadas()
						+ "";
			}

			if (qualidadeAgua.getQuantidadeColiformesTotaisAnalisadas() != null) {
				analisadaColiformesTotais = qualidadeAgua
						.getQuantidadeColiformesTotaisAnalisadas() + "";
			}

			if (qualidadeAgua
					.getQuantidadeColiformesTermotolerantesAnalisadas() != null) {
				analisadaColiformesTermotolerantes = qualidadeAgua
						.getQuantidadeColiformesTermotolerantesAnalisadas()
						+ "";
			}

			// Em Conformidade
			if (qualidadeAgua.getQuantidadeCorConforme() != null) {
				emConformidadeCor = qualidadeAgua.getQuantidadeCorConforme()
						+ "";
			}

			if (qualidadeAgua.getQuantidadeTurbidezConforme() != null) {
				emConformidadeTurbidez = qualidadeAgua
						.getQuantidadeTurbidezConforme() + "";
			}

			if (qualidadeAgua.getQuantidadeFluorConforme() != null) {
				emConformidadeFluor = qualidadeAgua
						.getQuantidadeFluorConforme() + "";
			}

			if (qualidadeAgua.getQuantidadeCloroConforme() != null) {
				emConformidadeCloro = qualidadeAgua
						.getQuantidadeCloroConforme() + "";
			}

			if (qualidadeAgua.getQuantidadeColiformesTotaisConforme() != null) {
				emConformidadeColiformesTotais = qualidadeAgua
						.getQuantidadeColiformesTotaisConforme() + "";
			}

			if (qualidadeAgua.getQuantidadeColiformesTermotolerantesConforme() != null) {
				emConformidadeColiformesTermotolerantes = qualidadeAgua
						.getQuantidadeColiformesTermotolerantesConforme() + "";
			}

			if (qualidadeAgua.getFonteCaptacao() != null
					&& tipoCaptacao.trim().equalsIgnoreCase("")) {
				if (qualidadeAgua.getFonteCaptacao().getTipoCaptacao() != null) {
					tipoCaptacao = qualidadeAgua.getFonteCaptacao()
							.getTipoCaptacao().getId()
							+ "";
				}
			}

		}

		retornoQualidade[0] = padraoCor;
		retornoQualidade[1] = padraoTurbidez;
		retornoQualidade[2] = padraoFluor;
		retornoQualidade[3] = padraoCloro;
		retornoQualidade[4] = padraoColiformesTotais;
		retornoQualidade[5] = padraoColiformesTermotolerantes;

		retornoQualidade[6] = exigidaCor;
		retornoQualidade[7] = exigidaTurbidez;
		retornoQualidade[8] = exigidaFluor;
		retornoQualidade[9] = exigidaCloro;
		retornoQualidade[10] = exigidaColiformesTotais;
		retornoQualidade[11] = exigidaColiformesTermotolerantes;

		retornoQualidade[12] = analisadaCor;
		retornoQualidade[13] = analisadaTurbidez;
		retornoQualidade[14] = analisadaFluor;
		retornoQualidade[15] = analisadaCloro;
		retornoQualidade[16] = analisadaColiformesTotais;
		retornoQualidade[17] = analisadaColiformesTermotolerantes;

		retornoQualidade[18] = emConformidadeCor;
		retornoQualidade[19] = emConformidadeTurbidez;
		retornoQualidade[20] = emConformidadeFluor;
		retornoQualidade[21] = emConformidadeCloro;
		retornoQualidade[22] = emConformidadeColiformesTotais;
		retornoQualidade[23] = emConformidadeColiformesTermotolerantes;

		retornoQualidade[24] = tipoCaptacao;

		return retornoQualidade;
	}

	/**
	 * Verificar no momento em que o usuário está fazendo a prescrição de uma conta,
	 * se a mesma atende as condições necessárias para que haja a prescrição
	 * 
	 * @author Wellington Rocha
	 * @date 01/06/2012
	 */
	public boolean verificarPossibilidadePrescricaoConta(Integer idConta) {
		Conta conta = null;
		try {
			conta = (Conta) this.repositorioFaturamento
					.pesquisarContaParaPrescricao(idConta);

			Date dataPrescricao = new Date();
			int ano = dataPrescricao.getYear();
			ano = ano - 10;
			dataPrescricao.setYear(ano);

			Set<ClienteConta> clientesConta = conta.getClienteContas();

			if (conta.getDataVencimentoConta().before(dataPrescricao)) {
				boolean existeClienteEsferaPoderPublico = false;
				for (ClienteConta clienteConta : clientesConta) {
					if (!clienteConta.getCliente().getClienteTipo()
							.getEsferaPoder().equals(EsferaPoder.PARTICULAR)) {
						existeClienteEsferaPoderPublico = true;
					}
				}
				if (!existeClienteEsferaPoderPublico) {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		} catch (ErroRepositorioException e) {
			
			e.printStackTrace();
		}
		return false;
	}

	public ExtratoQuitacao obterExtratoQuitacaoImovel(Integer idImovel,
			Integer anoReferencia) throws ControladorException {
		try {
			return repositorioFaturamento.obterExtratoQuitacaoImovel(idImovel,
					anoReferencia);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	private BigDecimal[] obterDiferencaValoresCreditosRealizadosContaRetificadaDuplicidadeAte201212(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsOrigemCredito) throws ControladorException {

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal[] retorno = new BigDecimal[2];

		BigDecimal valorCreditoRealizadoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorCreditoRealizadoSituacaoRetificada = null;

		try {
			// obtém o valor dos creditos realizados cancelados do retificação
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = repositorioFaturamento
					.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoCanceladoPorRetificacaoDuplicidadeAte201212(
							anoMesReferencia, idLocalidade, idCategoria,
							idsOrigemCredito);

			// obtém o valor dos creditos realizados retificados
			valorCreditoRealizadoSituacaoRetificada = repositorioFaturamento
					.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoRetificadaDuplicidadeAte201212(
							anoMesReferencia, idLocalidade, idCategoria,
							idsOrigemCredito);

			// erro no hibernate
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		if (valorCreditoRealizadoSituacaoCanceladoPorRetificacao == null) {
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
		}

		if (valorCreditoRealizadoSituacaoRetificada == null) {
			valorCreditoRealizadoSituacaoRetificada = BigDecimal.ZERO;
		}

		// Valores cancelados acumulados
		retorno[0] = valorCreditoRealizadoSituacaoCanceladoPorRetificacao;

		// Valores incluidos acumulados
		retorno[1] = valorCreditoRealizadoSituacaoRetificada;

		return retorno;
	}

	/**
	 *
	 * 
	 * Alteração para contabilizar em contas diferentes valores arrecadados até
	 * 31/12/2012
	 * 
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsOrigemCredito
	 * 
	 * @throws ControladorException
	 */
	private BigDecimal[] obterDiferencaValoresCreditosRealizadosContaRetificadaDuplicidade(
			int anoMesReferencia, int idLocalidade, int idCategoria,
			Integer[] idsOrigemCredito) throws ControladorException {

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal[] retorno = new BigDecimal[2];

		BigDecimal valorCreditoRealizadoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorCreditoRealizadoSituacaoRetificada = null;

		try {
			// obtém o valor dos creditos realizados cancelados do retificação
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = repositorioFaturamento
					.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoCanceladoPorRetificacaoDuplicidade(
							anoMesReferencia, idLocalidade, idCategoria,
							idsOrigemCredito);

			// obtém o valor dos creditos realizados retificados
			valorCreditoRealizadoSituacaoRetificada = repositorioFaturamento
					.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoRetificadaDuplicidade(
							anoMesReferencia, idLocalidade, idCategoria,
							idsOrigemCredito);

			// erro no hibernate
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		if (valorCreditoRealizadoSituacaoCanceladoPorRetificacao == null) {
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
		}

		if (valorCreditoRealizadoSituacaoRetificada == null) {
			valorCreditoRealizadoSituacaoRetificada = BigDecimal.ZERO;
		}

		// Valores cancelados acumulados
		retorno[0] = valorCreditoRealizadoSituacaoCanceladoPorRetificacao;

		// Valores incluidos acumulados
		retorno[1] = valorCreditoRealizadoSituacaoRetificada;

		return retorno;
	}

	/**
	 * Processar Pagamento com Código de Barras Por Cliente
	 * 
	 * [SB0005] - Processar Recebimento de Acrescimos por Impontualidade
	 * 
	 * @author Adriana Muniz e Wellington Rocha
	 * @since 23/10/2013
	 * @param guiaPagamento
	 *            GuiaPagamento
	 * @throws ControladorException
	 */
	public Integer inserirGuiaPagamentoCodigoBarrasPorCliente(
			GuiaPagamento guiaPagamento, Integer idDebitoTipo,
			Integer idLocalidade) throws ControladorException {

		System.out.println("******************************************");
		System.out.println("INICIO INSERIR GUIA PAGAMENTO");
		System.out.println("******************************************");

		Integer idCliente = guiaPagamento.getCliente().getId() == null ? null
				: guiaPagamento.getCliente().getId();
		String valorDebito = guiaPagamento.getValorDebito().toString();
		Date dataVencimentoFormatada = guiaPagamento.getDataVencimento();
		GuiaPagamento guiaPagamentoInserir = new GuiaPagamento();

		GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();

		// valor fixo
		Short indicadorHistorico = 2;

		guiaPagamentoGeral.setIndicadorHistorico(indicadorHistorico);

		// Ultima Alteração
		guiaPagamentoGeral.setUltimaAlteracao(new Date());

		Integer idGuiaPagamentoGerado = (Integer) getControladorUtil().inserir(
				guiaPagamentoGeral);

		guiaPagamentoGeral.setId(idGuiaPagamentoGerado);

		guiaPagamentoInserir.setGuiaPagamentoGeral(guiaPagamentoGeral);

		guiaPagamentoInserir.setId(idGuiaPagamentoGerado);

		if (idLocalidade != null) {
			guiaPagamentoInserir.setLocalidade(new Localidade(idLocalidade));
		} else {
			throw new ControladorException("erro.sistema");

		}

		guiaPagamentoInserir.setImovel(null);
		Cliente cliente = getControladorCliente().consultarCliente(idCliente);
		guiaPagamentoInserir.setCliente(cliente);

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (sistemaParametro != null) {

			guiaPagamentoInserir.setAnoMesReferenciaContabil(new Integer(
					sistemaParametro.getAnoMesFaturamento()));
		} else {
			throw new ControladorException("erro.sistema");

		}

		DebitoTipo debitoTipo = getDebitoTipoHql(idDebitoTipo);

		if (debitoTipo != null) {
			guiaPagamentoInserir.setDebitoTipo(debitoTipo);
			guiaPagamentoInserir.setFinanciamentoTipo(debitoTipo
					.getFinanciamentoTipo());
			guiaPagamentoInserir.setLancamentoItemContabil(debitoTipo
					.getLancamentoItemContabil());

		}

		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

		guiaPagamentoInserir.setDebitoCreditoSituacaoAnterior(null);
		guiaPagamentoInserir
				.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
		guiaPagamentoInserir.setDataVencimento(dataVencimentoFormatada);
		guiaPagamentoInserir.setValorDebito(new BigDecimal(valorDebito));
		guiaPagamentoInserir.setDataEmissao(new Date());
		guiaPagamentoInserir.setRegistroAtendimento(null);
		guiaPagamentoInserir.setOrdemServico(null);
		guiaPagamentoInserir.setIndicadoCobrancaMulta(new Short("2"));
		guiaPagamentoInserir.setUltimaAlteracao(new Date());

		guiaPagamentoInserir.setNumeroPrestacaoDebito(new Short("1"));
		guiaPagamentoInserir.setNumeroPrestacaoTotal(new Short("1"));
		guiaPagamentoInserir.setIndicadorEmitirObservacao(new Short("2"));
		getControladorUtil().inserir(guiaPagamentoInserir);

		GuiaPagamentoCategoria guiaPagamentoCategoria = new GuiaPagamentoCategoria();

		ClienteTipo clienteTipo = cliente.getClienteTipo();
		FiltroClienteTipo filtroClienteTipo = new FiltroClienteTipo();
		filtroClienteTipo.adicionarParametro(new ParametroSimples(
				FiltroClienteTipo.ID, clienteTipo.getId()));
		filtroClienteTipo
				.adicionarCaminhoParaCarregamentoEntidade("esferaPoder");
		clienteTipo = (ClienteTipo) getControladorUtil()
				.pesquisar(filtroClienteTipo, ClienteTipo.class.getName())
				.iterator().next();

		Categoria categoria = null;
		if (!clienteTipo.getEsferaPoder().getId()
				.equals(EsferaPoder.PARTICULAR)) {
			categoria = new Categoria(Categoria.PUBLICO);
		} else {
			if (clienteTipo.getIndicadorPessoaFisicaJuridica().equals(
					ClienteTipo.INDICADOR_PESSOA_FISICA)) {
				categoria = new Categoria(Categoria.RESIDENCIAL);
			} else {
				categoria = new Categoria(Categoria.COMERCIAL);
			}
		}

		guiaPagamentoCategoria.setComp_id(new GuiaPagamentoCategoriaPK(
				categoria.getId(), guiaPagamentoInserir.getId()));
		guiaPagamentoCategoria.setQuantidadeEconomia(1);
		guiaPagamentoCategoria.setValorCategoria(new BigDecimal(valorDebito));
		guiaPagamentoCategoria.setUltimaAlteracao(new Date());

		getControladorUtil().inserir(guiaPagamentoCategoria);

		System.out.println("******************************************");
		System.out.println("FIM INSERIR GUIA PAGAMENTO");
		System.out.println("******************************************");
		return idGuiaPagamentoGerado;
	}

	public void prepararFaturamentoImovel(int atividade, Rota rota, Integer idImovel) throws ControladorException {
		
		ApagarDadosFaturamentoHelper helper = new ApagarDadosFaturamentoHelper();
		
		helper.setRota(rota);
		helper.setAnoMesFaturamento(rota.getFaturamentoGrupo().getAnoMesReferencia());
		helper.setIdImovel(idImovel);

		this.atualizarLigacaoEsgotoPorRota(rota, atividade);

		helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.NORMAL);

		//this.apagarDadosGeradosFaturarGrupoFaturamento(helper,atividade);
		this.apagarDadosGeradosResumoFaturamentoSimulacaoDetalhe(rota.getFaturamentoGrupo().getId(), helper);
		this.apagarDadosGeradosResumoFaturamentoSimulacao(rota.getFaturamentoGrupo().getId(), helper);

		helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.PRE_FATURADA);
		boolean possuiContasApagadas = this.apagarDadosGeradosFaturarGrupoFaturamento(helper, atividade);

		if (Util.obterMes(rota.getFaturamentoGrupo().getAnoMesReferencia()) == ConstantesSistema.NOVEMBRO) {

			helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.NORMAL);
			helper.setAnoMesFaturamento(Util.somaUmMesAnoMesReferencia(rota.getFaturamentoGrupo().getAnoMesReferencia()));

			//this.apagarDadosGeradosFaturarGrupoFaturamento(helper, atividade);
			this.apagarDadosGeradosResumoFaturamentoSimulacaoDetalhe(rota.getFaturamentoGrupo().getId(), helper);
			this.apagarDadosGeradosResumoFaturamentoSimulacao(rota.getFaturamentoGrupo().getId(), helper);

			helper.setIdDebitoCreditoSituacaoAtual(DebitoCreditoSituacao.PRE_FATURADA);

			this.apagarDadosGeradosFaturarGrupoFaturamento(helper, atividade);

		}
	}
	
	private void atualizarDataCronogramaEfetuarLeitura(FaturamentoGrupo grupo) {
			
		FaturamentoAtividadeCronograma cronograma = null;
			
		try {
			cronograma = this.pesquisarFaturamentoAtividadeCronograma(
							grupo.getId(),
							FaturamentoAtividade.EFETUAR_LEITURA,
							grupo.getAnoMesReferencia());

			if (cronograma != null) {
				if (cronograma.getDataRealizacao() == null) {
					cronograma.setDataRealizacao(cronograma.getDataPrevista());
					cronograma.setUltimaAlteracao(new Date());
					getControladorUtil().atualizar(cronograma);
				}
			}
		} catch (ControladorException e) {
			e.printStackTrace();
		}
	}
	
	private FaturamentoAtividadeCronograma pesquisarFaturamentoAtividadeCronograma(Integer faturamentoGrupoId, Integer faturamentoAtividadeId,
			Integer anoMesReferencia) throws ControladorException {
		try {
			return (FaturamentoAtividadeCronograma) repositorioFaturamento.pesquisarFaturamentoAtividadeCronograma(
							faturamentoGrupoId, faturamentoAtividadeId,
							anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	public List<RelatorioAgenciaReguladoraDTO> pesquisarContasParaRelatorioAgenciaReguladora(Integer anoMes, Integer idAgencia) throws ControladorException {
		try {
			List<RelatorioAgenciaReguladoraDTO> retorno = new ArrayList<RelatorioAgenciaReguladoraDTO>();
			Collection lancamentosAgenciaReguladora = repositorioFaturamento.pesquisarContasParaRelatorioAgenciaReguladora(anoMes, idAgencia);
			int percentualRepasse = 0;
			
			for (Object obj : lancamentosAgenciaReguladora) {
	            Object[] arrayObj = (Object[]) obj;
	            
	            percentualRepasse = (Integer)arrayObj[4]; 
	            
	            BigDecimal valorAgua = (BigDecimal)arrayObj[1];
	            BigDecimal valorEsgoto = (BigDecimal)arrayObj[2];
	            
	            RelatorioAgenciaReguladoraDTO dto = 
	                new RelatorioAgenciaReguladoraDTO(
	                    (String)arrayObj[0], 
	                    valorAgua,
	                    valorEsgoto, 
	                    (String)arrayObj[3],  
	                    valorAgua.add(valorEsgoto));
	            
	            retorno.add(dto);
	          }
			
			Map<String, BigDecimal[]> baseRepasse = new HashMap<String, BigDecimal[]>();
			Map<String, BigDecimal[]> baseRepasseFaturado = new HashMap<String, BigDecimal[]>();
			Map<String, BigDecimal[]> baseRepasseCancelado = new HashMap<String, BigDecimal[]>();
			double percentual = (double) percentualRepasse;
			
			// Preenche os valores de repasse faturados e cancelados
			for (ReportItemDTO reportItemDTO : retorno) {
				RelatorioAgenciaReguladoraDTO dto = (RelatorioAgenciaReguladoraDTO) reportItemDTO;
				
				if (dto.getSituacao().equals("Faturado")) {
					baseRepasseFaturado.put(dto.getLocalidade(), new BigDecimal[] { Util.formatarMoedaRealparaBigDecimal(dto.getValorAgua()), Util.formatarMoedaRealparaBigDecimal(dto.getValorEsgoto())});
				} else {
					baseRepasseCancelado.put(dto.getLocalidade(), new BigDecimal[] { Util.formatarMoedaRealparaBigDecimal(dto.getValorAgua()), Util.formatarMoedaRealparaBigDecimal(dto.getValorEsgoto())});
				}
				
			}
			
			// Preenche os valores base de repasse
			for (String localidade : baseRepasseFaturado.keySet()) {
				BigDecimal[] valoresFaturados = baseRepasseFaturado.get(localidade);
				BigDecimal[] valoresCancelados = baseRepasseCancelado.get(localidade);
				
				if (valoresCancelados != null) {
					baseRepasse.put(localidade, new BigDecimal[] { valoresFaturados[0].subtract(valoresCancelados[0]), valoresFaturados[1].subtract(valoresCancelados[1]) });
				} else {
					baseRepasse.put(localidade, new BigDecimal[] { valoresFaturados[0], valoresFaturados[1] });
				}
			}
			
			// Insere os valores base de repasse no relatorio
			for (String localidade : baseRepasse.keySet()) {
				BigDecimal[] valores = baseRepasse.get(localidade);
				RelatorioAgenciaReguladoraDTO r1 = new RelatorioAgenciaReguladoraDTO(localidade, valores[0], valores[1],"Base para repasse",valores[0].add(valores[1]));
				retorno.add(r1);
			}
			
			// Calcula o percentual do valor base de repasse e insere no relatorio
			for (String localidade : baseRepasse.keySet()) {
				BigDecimal[] valores = baseRepasse.get(localidade);
				RelatorioAgenciaReguladoraDTO r1 = new RelatorioAgenciaReguladoraDTO(localidade, Util.calcularPercentual(valores[0], percentual), Util.calcularPercentual(valores[1], percentual),"Valor a ser repassado", Util.calcularPercentual(valores[0].add(valores[1]), percentual));
				retorno.add(r1);
			}
			
			return retorno;
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}
		
	public LancamentoAgenciaReguladora buildLancamentoAgenciaReguladoraCancelados(Integer idLocalidade, Integer anoMesFaturamento, boolean aPartirNovembro, int tipoLancamento) throws Exception{
		FiltroSetorComercial filtroSetorComercial = new FiltroSetorComercial();
		filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.LOCALIDADE_ID, idLocalidade));
		SetorComercial setorComercial = (SetorComercial) getControladorUtil().pesquisar(filtroSetorComercial, SetorComercial.class.getName()).iterator().next();

		FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
		filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, idLocalidade));
		Localidade loca = (Localidade) getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName()).iterator().next();

		BigDecimal valorAguaLancamentoAgenciaReguladora = repositorioFaturamento.acumularValorAguaPorSituacaoContaEReferenciaContabil(anoMesFaturamento,
				idLocalidade, DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.INCLUIDA, aPartirNovembro);

		BigDecimal valorEsgotoLancamentoAgenciaReguladora = repositorioFaturamento.acumularValorEsgotoPorSituacaoContaEReferenciaContabil(
				anoMesFaturamento, idLocalidade, DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.INCLUIDA, aPartirNovembro);

		LancamentoAgenciaReguladora lar = new LancamentoAgenciaReguladora(loca, setorComercial, anoMesFaturamento, valorAguaLancamentoAgenciaReguladora,
				valorEsgotoLancamentoAgenciaReguladora, tipoLancamento);

		return lar;
	}
	
	public LancamentoAgenciaReguladora buildLancamentoAgenciaReguladoraNormais(Integer idLocalidade, Integer anoMesFaturamento, BigDecimal valorAgua, BigDecimal valorEsgoto, Integer tipoLancamento) throws Exception{
		FiltroSetorComercial filtroSetorComercial = new FiltroSetorComercial();
		filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.LOCALIDADE_ID, idLocalidade));
		SetorComercial setorComercial = (SetorComercial) getControladorUtil().pesquisar(filtroSetorComercial, SetorComercial.class.getName()).iterator().next();

		FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
		filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, idLocalidade));
		Localidade loca = (Localidade) getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName()).iterator().next();

		LancamentoAgenciaReguladora lar = new LancamentoAgenciaReguladora(loca, setorComercial, anoMesFaturamento, valorAgua, valorEsgoto, tipoLancamento);

		return lar;
	}
	
	public LancamentoAgenciaReguladora buildLancamentoAgenciaReguladoraCancelados(Integer idLocalidade, Integer anoMesFaturamento, int tipoLancamento) throws Exception{
		FiltroSetorComercial filtroSetorComercial = new FiltroSetorComercial();
		filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.LOCALIDADE_ID, idLocalidade));
		SetorComercial setorComercial = (SetorComercial) getControladorUtil().pesquisar(filtroSetorComercial, SetorComercial.class.getName()).iterator().next();

		FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
		filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, idLocalidade));
		Localidade loca = (Localidade) getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName()).iterator().next();

		BigDecimal valorAguaLancamentoAgenciaReguladora = repositorioFaturamento.calcularDiferencaValorAguaCanceladaRetificacao(anoMesFaturamento,idLocalidade);

		BigDecimal valorEsgotoLancamentoAgenciaReguladora = repositorioFaturamento.calcularDiferencaValorEsgotoCanceladaRetificacao(anoMesFaturamento,idLocalidade);

		LancamentoAgenciaReguladora lar = new LancamentoAgenciaReguladora(loca, setorComercial, anoMesFaturamento, valorAguaLancamentoAgenciaReguladora,
				valorEsgotoLancamentoAgenciaReguladora, tipoLancamento);

		return lar;
	}
	
	private boolean isContaIncluidaOuRetificadaEReferenciaContabilMaiorOuIgual(Conta contaAtual, SistemaParametro sistemaParametro) {
		return (contaAtual.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.INCLUIDA) 
						|| contaAtual.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.RETIFICADA))
					&& (Util.compararAnoMesReferencia(contaAtual.getReferenciaContabil(),sistemaParametro.getAnoMesFaturamento(), ">") 
						|| Util.compararAnoMesReferencia(contaAtual.getReferenciaContabil(),sistemaParametro.getAnoMesFaturamento(),"="));
	}

	private boolean isContaNormalIncluidaOuRetificadaEReferenciaContabilMenor(Conta contaAtual, SistemaParametro sistemaParametro) {
		return (contaAtual.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.NORMAL))
				|| ((contaAtual.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.INCLUIDA) || 
						contaAtual.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.RETIFICADA)) 
				&& Util.compararAnoMesReferencia(contaAtual.getReferenciaContabil(),sistemaParametro.getAnoMesFaturamento(),"<"));
	}
	
}