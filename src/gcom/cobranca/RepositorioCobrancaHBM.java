package gcom.cobranca;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import org.hibernate.Criteria;
import org.hibernate.FetchMode;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.StatelessSession;
import org.hibernate.criterion.Restrictions;

import gcom.arrecadacao.ArrecadadorContratoTarifa;
import gcom.arrecadacao.aviso.AvisoBancario;
import gcom.arrecadacao.aviso.AvisoDeducoes;
import gcom.arrecadacao.debitoautomatico.DebitoAutomatico;
import gcom.arrecadacao.pagamento.GuiaPagamento;
import gcom.arrecadacao.pagamento.Pagamento;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.atendimentopublico.ordemservico.ServicoTipo;
import gcom.atendimentopublico.registroatendimento.AtendimentoMotivoEncerramento;
import gcom.atendimentopublico.registroatendimento.AtendimentoRelacaoTipo;
import gcom.atendimentopublico.registroatendimento.EspecificacaoTipoValidacao;
import gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao;
import gcom.cadastro.cliente.Cliente;
import gcom.cadastro.cliente.ClienteRelacaoTipo;
import gcom.cadastro.cliente.ClienteTipo;
import gcom.cadastro.cliente.EsferaPoder;
import gcom.cadastro.cliente.FoneTipo;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.imovel.Categoria;
import gcom.cadastro.imovel.CategoriaTipo;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.imovel.ImovelPerfil;
import gcom.cadastro.localidade.GerenciaRegional;
import gcom.cadastro.localidade.Localidade;
import gcom.cadastro.localidade.Quadra;
import gcom.cadastro.localidade.SetorComercial;
import gcom.cadastro.localidade.UnidadeNegocio;
import gcom.cobranca.bean.ConsultarTransferenciasDebitoHelper;
import gcom.cobranca.bean.DadosConsultaNegativacaoHelper;
import gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper;
import gcom.cobranca.bean.EmitirDocumentoCobrancaBoletimCadastroHelper;
import gcom.cobranca.bean.EmitirDocumentoCobrancaHelper;
import gcom.cobranca.bean.FiltrarDocumentoCobrancaHelper;
import gcom.cobranca.bean.FiltrarRelacaoParcelamentoHelper;
import gcom.cobranca.bean.FiltroSupressoesReligacoesReestabelecimentoHelper;
import gcom.cobranca.bean.PesquisarQtdeRotasSemCriteriosParaAcoesCobranca;
import gcom.cobranca.bean.SituacaoEspecialCobrancaHelper;
import gcom.cobranca.cobrancaporresultado.ArquivoTextoNegociacaoCobrancaEmpresaHelper;
import gcom.cobranca.cobrancaporresultado.NegociacaoCobrancaEmpresa;
import gcom.cobranca.cobrancaporresultado.NegociacaoContaCobrancaEmpresa;
import gcom.cobranca.contratoparcelamento.ContratoParcelamento;
import gcom.cobranca.dto.CobrancaDocumentoDTO;
import gcom.cobranca.parcelamento.ParcDesctoInativVista;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.cobranca.parcelamento.ParcelamentoDescontoInatividade;
import gcom.cobranca.parcelamento.ParcelamentoFaixaValor;
import gcom.cobranca.parcelamento.ParcelamentoItem;
import gcom.cobranca.parcelamento.ParcelamentoQuantidadeReparcelamento;
import gcom.cobranca.parcelamento.ParcelamentoSituacao;
import gcom.faturamento.GuiaPagamentoGeral;
import gcom.faturamento.conta.Conta;
import gcom.faturamento.conta.ContaGeral;
import gcom.faturamento.conta.ContaMotivoCancelamento;
import gcom.faturamento.credito.CreditoARealizar;
import gcom.faturamento.debito.DebitoACobrar;
import gcom.faturamento.debito.DebitoCreditoSituacao;
import gcom.faturamento.debito.DebitoTipo;
import gcom.financeiro.FinanciamentoTipo;
import gcom.gui.ActionServletException;
import gcom.gui.cobranca.cobrancaporresultado.MovimentarOrdemServicoGerarOSHelper;
import gcom.gui.relatorio.cobranca.FaixaHelper;
import gcom.gui.relatorio.cobranca.FiltroRelatorioDocumentosAReceberHelper;
import gcom.micromedicao.consumo.ConsumoHistorico;
import gcom.micromedicao.consumo.LigacaoTipo;
import gcom.micromedicao.medicao.MedicaoTipo;
import gcom.relatorio.cobranca.ProtocoloDocumentoCobrancaRelatorioHelper;
import gcom.relatorio.cobranca.RelatorioAcompanhamentoAcoesCobrancaHelper;
import gcom.relatorio.cobranca.RelatorioAnalisePerdasCreditosBean;
import gcom.relatorio.cobranca.RelatorioBoletimMedicaoCobrancaHelper;
import gcom.relatorio.cobranca.parcelamento.RelacaoParcelamentoRelatorioHelper;
import gcom.util.CollectionUtil;
import gcom.util.ConstantesSistema;
import gcom.util.ControladorException;
import gcom.util.ErroRepositorioException;
import gcom.util.HibernateUtil;
import gcom.util.Util;
import gcom.util.filtro.Filtro;
import gcom.util.filtro.GeradorHQLCondicional;
import gcom.util.filtro.ParametroSimples;

public class RepositorioCobrancaHBM implements IRepositorioCobranca {

	private static RepositorioCobrancaHBM instancia;

	protected RepositorioCobrancaHBM() {}

	public static RepositorioCobrancaHBM getInstancia() {

		String dialect = HibernateUtil.getDialect();

		if (dialect.toUpperCase().contains("ORACLE")) {
			if (instancia == null) {
				instancia = new RepositorioCobrancaHBM();
			}
		} else {
			if (instancia == null) {
				instancia = new RepositorioCobrancaPostgresHBM();
			}
		}

		return instancia;
	}

	/**
	 * Faz parte de [UC0178] Religar Automaticamente Imóvel Cortado Author:
	 * Rafael Santos Data: 02/01/2006 Pesquisa os imoveis cortados há 60 dias ou
	 * mais a data do último dia do mês de faturamento
	 * 
	 * @return Colecção de Matriculas
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Collection pesquisarImoveisCortados(String situacaoEsgotoLigado, String situacaoAguaCortado, Date anoMesReferenciaFaturamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select i.id " + "from Imovel i " + "inner join i.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "inner join i.ligacaoAgua ligacaoAgua " + "inner join i.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "inner join i.ligacaoEsgoto ligacaoEsgoto " + "where ligacaoAguaSituacao.id = :situacao and "
					+ "ligacaoAgua.dataCorte <= :anoMesReferencia and " + "((ligacaoEsgotoSituacao.id != :situacaoEsgoto)  or "
					+ "(ligacaoEsgotoSituacao.id = :situacaoEsgoto and " + "(ligacaoEsgoto.consumoMinimo = 0 or "
					+ "ligacaoEsgoto.consumoMinimo is null)))";

			retorno = session.createQuery(consulta).setInteger("situacao", new Integer(situacaoAguaCortado).intValue())
					.setDate("anoMesReferencia", anoMesReferenciaFaturamento)
					.setInteger("situacaoEsgoto", new Integer(situacaoEsgotoLigado).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0178] Religar Automaticamente Imóvel Cortado Author:
	 * Rafael Santos Data: 02/01/2006 Caso o imovel possua hidrometro na ligação
	 * de água e o tipo do ultimo consumo faturado tenha sido real
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param anoMesFaturamento
	 *            Ano Mes Faturamento
	 * @param consumoTipoReal
	 *            Tipo de Consumo Real
	 * @param ligacaoTipoLigacaoAgua
	 *            Tipo de Ligação Agua
	 * @return Consumo Historico do Imovel
	 * @throws ErroRepositorioException
	 *             Erro no Repositorio
	 */
	public String pesquisarImoveisHidrometroAguaConsumoFaturadoReal(String id, String anoMesFaturamento, String consumoTipoReal,
			String ligacaoTipoLigacaoAgua) throws ErroRepositorioException {

		String idConsumoHistorico = null;
		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ch.id from ConsumoHistorico ch " + "inner join ch.imovel im " + "inner join ch.imovel.ligacaoAgua la "
					+ "inner join la.hidrometroInstalacaoHistorico " + "inner join ch.consumoTipo ct " + "inner join ch.ligacaoTipo lt "
					+ "where la.hidrometroInstalacaoHistorico is not null " + "and ct.id = :idConsumo and lt.id = :ligacaoAgua "
					+ " and ch.referenciaFaturamento = :anoMesReferencia " + " and im.id = :idImovel";

			retorno = session.createQuery(consulta).setInteger("idConsumo", new Integer(consumoTipoReal).intValue())
					.setInteger("ligacaoAgua", new Integer(ligacaoTipoLigacaoAgua).intValue())
					.setInteger("anoMesReferencia", new Integer(anoMesFaturamento).intValue())
					.setInteger("idImovel", new Integer(id).intValue()).setMaxResults(1).uniqueResult();

			if (retorno != null) {

				idConsumoHistorico = ((Integer) retorno).toString();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idConsumoHistorico;
	}

	/**
	 * [UC0178] Religar Automaticamente Imóvel Cortado Auhtor: Rafael Santos
	 * Data: 03/01/2006
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param situacaoAguaLigado
	 *            Situação Agua
	 * @param dataReligacaoAgua
	 *            Data Religacao Agua
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void religarImovelCortado(String id, String situacaoAguaLigado, Date dataReligacaoAgua) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;
		String atualizarLigacaoAgua;

		try {
			System.out.println("Entrou.....");
			atualizarImovel = "update gcom.cadastro.imovel.Imovel " + "set last_id = :situacaoAgua where imov_id = :id";

			session.createQuery(atualizarImovel).setInteger("situacaoAgua", new Integer(situacaoAguaLigado).intValue())
					.setInteger("id", new Integer(id).intValue()).executeUpdate();

			atualizarLigacaoAgua = "update gcom.atendimentopublico.ligacaoagua.LigacaoAgua " + "set lagu_dtreligacaoagua = :data"
					+ " where hidi_id = :id";

			session.createQuery(atualizarLigacaoAgua).setDate("data", dataReligacaoAgua).setInteger("id", new Integer(id).intValue())
					.executeUpdate();
		} catch (Exception e) {
			System.out.println("Erro");

			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente Obtem os débitos de um imóvel
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param contaSituacaoNormal
	 *            Situação Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situação Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situação Incluída de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Coleção de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImovel(Integer idImovel, int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada, String contaSituacaoIncluida,
			String contaSituacaoParcelada, String anoMesInicialReferenciaDebito, String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito, Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva,
			boolean contaComDebitoPreterito, Integer idImovelPerfil) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento "
					+ "FROM cadastro.cliente_conta cc "
					+ "INNER JOIN faturamento.conta conta ON (conta.cnta_id = cc.cnta_id)  "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id = :idImovel ";

			if (contaComDebitoPreterito) {
				consulta += "AND cc.clie_id <> (select ci.clie_id from cadastro.cliente_imovel ci where conta.imov_id = ci.imov_id and ci.crtp_id = :idClienteRelacaoTipo and ci.clim_dtrelacaofim is null) ";
			} else {
				consulta += "AND cc.clie_id = (select ci.clie_id from cadastro.cliente_imovel ci where conta.imov_id = ci.imov_id and ci.crtp_id = :idClienteRelacaoTipo and ci.clim_dtrelacaofim is null) ";
			}
			
			consulta += "and cc.crtp_id = :idClienteRelacaoTipo "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento ";
			
			if (idImovelPerfil.intValue() != ImovelPerfil.BOLSA_AGUA.intValue()) { 
				consulta += "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";
			}
			
			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0";
			}

			consulta += " ORDER BY idImovel, referencia ";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("dataRevisao", Hibernate.DATE).addScalar("referencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("idSituacaoAtual", Hibernate.INTEGER).addScalar("digitoVerificador", Hibernate.SHORT)
					.addScalar("idMotivoRevisao", Hibernate.INTEGER).addScalar("ultimaAlteracao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER).addScalar("consumoAgua", Hibernate.INTEGER)
					.addScalar("valorImpostos", Hibernate.BIG_DECIMAL).addScalar("consumoEsgoto", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("idParcelamento", Hibernate.INTEGER).setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal", new Integer(contaSituacaoNormal))
					.setInteger("situacaoRetificada", new Integer(contaSituacaoRetificada))
					.setInteger("situacaoIncluida", new Integer(contaSituacaoIncluida))
					.setInteger("situacaoParcelada", new Integer(contaSituacaoParcelada))
					.setInteger("inicialReferencia", new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia", new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
					.setDate("finalVencimento", anoMesFinalVencimentoDebito)
					.setShort("idClienteRelacaoTipo", ClienteRelacaoTipo.USUARIO).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	@SuppressWarnings("unchecked")
	public int pesquisarQuantidadeContasVencidasPorImovel(Integer idImovel, int indicadorPagamento,
			int indicadorConta, int indicadorDividaAtiva) throws ErroRepositorioException {

		List<Integer> retorno = new ArrayList<Integer>();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT conta.cnta_amreferenciaconta as referencia "
				+ " FROM faturamento.conta conta "
				+ " LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
				+ " WHERE conta.imov_id = :idImovel "
				+ " and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida) "
				+ " and conta.cnta_dtvencimentoconta < :vencimento "
				+ " and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			consulta += " GROUP BY conta.cnta_amreferenciaconta ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0";
			}

			retorno = (List<Integer>) session.createSQLQuery(consulta)
					.addScalar("referencia", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida", DebitoCreditoSituacao.INCLUIDA)
					.setDate("vencimento", new Date()).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno.size();
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imóvel ou Cliente Obtem os débitos
	 * de um cliente Author: Rafael Santos Data: 05/01/2006
	 * 
	 * @param idsContas
	 *            Coleção de Ids das Contas
	 * @param contaSituacaoNormal
	 *            Situação Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situação Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situação Incluída de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Coleção de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasCliente(Integer idCliente, Short relacaoTipo, int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada, String contaSituacaoIncluida, String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito, String anoMesFinalReferenciaDebito, Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva) throws ErroRepositorioException {
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;
		boolean isClienteSuperior = relacaoTipo == null ? false : (relacaoTipo == 99 ? true : false) ;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento,conta.parc_id as idParcelamento "
					+ "FROM cadastro.cliente_conta clieConta "
					+ "INNER JOIN faturamento.conta conta on conta.cnta_id = clieConta.cnta_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id ";
					if (isClienteSuperior){
						consulta += "INNER JOIN cadastro.cliente c on c.clie_id = clieConta.clie_id ";
						consulta += "WHERE (clieConta.clie_id = :idCliente or c.clie_cdclienteresponsavel = :idCliente)";
					}else{
					    consulta += "WHERE clieConta.clie_id = :idCliente ";	
					}
					consulta +="and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";
					/*
					 * Felipe Santos
					 * 
					 * Consultar Débitos por Cliente indicado na conta
					 */
					/*
					 * Matheus Cruz
					 * O indicador nome conta nao e considerado quando o cliente for superior
					 */
					if (!isClienteSuperior) {
						consulta += "and clieConta.clct_icnomeconta = :indicadorNomeConta ";
					}

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (isClienteSuperior) {
//				consulta += "and clieConta.crtp_id = " + ClienteRelacaoTipo.RESPONSAVEL;
				consulta += String.format("and clieConta.crtp_id in (%d,%d)", ClienteRelacaoTipo.USUARIO, ClienteRelacaoTipo.RESPONSAVEL);
			} else if (relacaoTipo != null) {
				consulta += "and clieConta.crtp_id = " + relacaoTipo.toString();
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id";// min(pagto.pgmt_dtpagamento)
																																																									// ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";
			
			Query query = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("dataRevisao", Hibernate.DATE).addScalar("referencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("idSituacaoAtual", Hibernate.INTEGER).addScalar("digitoVerificador", Hibernate.SHORT)
					.addScalar("idMotivoRevisao", Hibernate.INTEGER).addScalar("ultimaAlteracao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER).addScalar("consumoAgua", Hibernate.INTEGER)
					.addScalar("valorImpostos", Hibernate.BIG_DECIMAL).addScalar("consumoEsgoto", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("idParcelamento", Hibernate.INTEGER).setInteger("idCliente", idCliente)
					.setInteger("situacaoNormal", new Integer(contaSituacaoNormal))
					.setInteger("situacaoRetificada", new Integer(contaSituacaoRetificada))
					.setInteger("situacaoIncluida", new Integer(contaSituacaoIncluida))
					.setInteger("situacaoParcelada", new Integer(contaSituacaoParcelada))
					.setInteger("inicialReferencia", new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia", new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito).setDate("finalVencimento", anoMesFinalVencimentoDebito);

			if (!isClienteSuperior) {
				retorno = query.setInteger("indicadorNomeConta", ConstantesSistema.SIM).list();
			} else {
				retorno = query.list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imóvel ou Cliente Obtem o Valor
	 * Total dos Pagamentos da Conta Author: Rafael Santos Data: 05/01/2006
	 * 
	 * @param idConta
	 *            Id Conta
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarValorTotalPagamentoMenorDataPagamento(String idConta) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT SUM(p.valorPagamento),MIN(p.dataPagamento) " + "FROM Pagamento p " + "WHERE p.contaGeral.id = :id "
					+ "GROUP BY p.contaGeral.id";

			retorno = session.createQuery(consulta).setInteger("id", new Integer(idConta).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imóvel ou Cliente Obtem o Valor
	 * Total dos Pagamentos da Guia de Pagamento Author: Rafael Santos,Rafael
	 * Santos Data: 07/01/2006,21/03/2006
	 * 
	 * @param idGuiaPagamento
	 *            Id Guia Pagamento
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarValorTotalGuiaPagamentoMenorDataGuiaPagamento(String idGuiaPagamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select sum(p.valorPagamento), min(p.dataPagamento) from Pagamento p "
					+ "inner join p.guiaPagamento guiaPagamentoGeral "
					+ "inner join guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "where guiaPagamento.id = :id " 
					+ "group by guiaPagamento.id";

			retorno = session.createQuery(consulta).setInteger("id", new Integer(idGuiaPagamento)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006
	 * 
	 * @param idImovel
	 *            Matricula do Imovel
	 * @param situacaoNormal
	 *            situacao de debito credito
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarImovel(String idImovel, String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac,debitoTipo.descricao,debitoTipo.id  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.imovel imovel "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch dac.debitoTipo debitoTipo "
					+ "where imovel.id = :id "
					+ "and dac.numeroPrestacaoCobradas < "
					+ "(dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id)";

			retorno = session.createQuery(consulta).setInteger("id", new Integer(idImovel))
					.setInteger("normal", new Integer(situacaoNormal)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006 Pesquisa os ID dos imoveis dos cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDImoveisClienteImovel(String codigoCliente, Short relacaoTipo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		
		if (relacaoTipo != null && relacaoTipo == 99) {
			relacaoTipo = new Short("3");
		}

		try {

			consulta = "select imovel.id " + "from ClienteImovel ci " + "inner join ci.imovel imovel " + "inner join ci.cliente cliente ";

			if (relacaoTipo != null) {
				consulta = consulta + " inner join ci.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue())
						.setShort("relacao", new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 07/01/2006 Pesquisa os ID dos clientes contas
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return ID dos Imvoeis Cliente Conta
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDImoveisClienteConta(String codigoCliente, Short relacaoTipo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteConta cc " + "inner join cc.conta conta " + "inner join cc.cliente cliente "
					+ "inner join conta.imovel imovel ";

			if (relacaoTipo != null) {
				consulta = consulta + " inner join cc.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue())
						.setShort("relacao", new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 06/01/2006 Colecção de Debitos a Cobrar de Cliente
	 * 
	 * @param colecaoIdImoveis
	 *            Coleção de ID dos Imoveis
	 * @param situacaoNormal
	 *            Situação Normal
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarCliente(Collection idsImoveis, String situacaoNormal) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select dac,debitoTipo.descricao,debitoTipo.id "
					+ "from DebitoACobrar dac "
					+ "inner join dac.imovel imovel "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join dac.debitoTipo debitoTipo "
					+ "where imovel.id IN(:ids) "
					+ "and dac.numeroPrestacaoCobradas < "
					+ "(dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id)";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE " + indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session.createQuery(consulta).setInteger("normal", new Integer(situacaoNormal).intValue())
							.setParameterList("ids", particoes.get(i)).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session.createQuery(consulta).setInteger("normal", new Integer(situacaoNormal).intValue())
						.setParameterList("ids", idsImoveis).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006 Colecção de Creditos a Realizar de Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param situacaoNormal
	 *            Situação Normal
	 * @return Coleção de Creditos A Realizar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarCliente(Collection idsImoveis, String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car, creditoTipo.descricao, creditoTipo.id " + "from CreditoARealizar car "
					+ "inner join car.imovel imovel " + "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join car.creditoTipo creditoTipo " + "where imovel.id IN(:ids) "
					+ "and (car.numeroPrestacaoRealizada < car.numeroPrestacaoCredito or " + "car.valorResidualMesAnterior > 0) "
					+ " and car.debitoCreditoSituacaoAtual = :normal ";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE " + indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session.createQuery(consulta).setInteger("normal", new Integer(situacaoNormal).intValue())
							.setParameterList("ids", particoes.get(i)).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session.createQuery(consulta).setInteger("normal", new Integer(situacaoNormal).intValue())
						.setParameterList("ids", idsImoveis).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006
	 * 
	 * @param idImovel
	 *            Matricula do Imovel
	 * @return Coleção de Creditos A Realizar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarImovel(String idImovel, String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car,creditoTipo.descricao, creditoTipo.id " + "from CreditoARealizar car " + "inner join car.imovel imovel "
					+ "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual " + "inner join car.creditoTipo creditoTipo "
					+ "where imovel.id = :id " + "and (car.numeroPrestacaoRealizada < car.numeroPrestacaoCredito or "
					+ "car.valorResidualMesAnterior > 0) " + " and car.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta).setInteger("id", new Integer(idImovel).intValue())
					.setInteger("normal", new Integer(situacaoNormal).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente
	 * 
	 * Author: Rafael Santos,Rafael Santos, Ivan Sérgio Data: 07/01/2006,
	 * 21/03/2006, 07/01/2009 Alteracao: 07/01/2009 - CRC932: No HQL do primeiro
	 * IF os dois ultimos campos estvam com o alias escrito errado. No ultimo
	 * campo faltava um espaco.
	 * 
	 * Colecção de Guias de Pagamento do Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @param situacaoNormal
	 *            Situação Normal
	 * @param clienteRelacaoTipo
	 *            Relação Cliente Tipo
	 * @return Coleção de Guias de Pagamento do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoCliente(Integer idCliente, int indicadorPagamento, String situacaoNormal,
			Short clienteRelacaoTipo, Date dataVencimentoInicial, Date dataVencimentoFinal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento, "
					+ " guia.dotp_id as idDocumentoTipo " + "FROM cadastro.cliente_guia_pagamento clieGuia "
					+ "INNER JOIN faturamento.guia_pagamento guia on guia.gpag_id = clieGuia.gpag_id "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id " + "WHERE clieGuia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			if (clienteRelacaoTipo != null) {
				consulta += " and clieGuia.crtp_id = " + clienteRelacaoTipo.toString();
			}

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal, guia.dotp_id ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0 ";
			}

			consulta += "UNION ";

			consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento, "
					+ " guia.dotp_id as idDocumentoTipo " + "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id " + "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal, guia.dotp_id  ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0 ";
			}

			retorno = session.createSQLQuery(consulta).addScalar("idGuia", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("anoMesReferencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("descricaoDebitoTipo", Hibernate.STRING).addScalar("dataEmissao", Hibernate.DATE)
					.addScalar("idDebitoTipo", Hibernate.INTEGER).addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
					.addScalar("numeroPrestacoesTotal", Hibernate.SHORT).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE).addScalar("idDocumentoTipo", Hibernate.INTEGER)
					.setInteger("idCliente", idCliente).setInteger("situacaoNormal", new Integer(situacaoNormal))
					.setDate("inicialVencimento", dataVencimentoInicial).setDate("finalVencimento", dataVencimentoFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0216] Calcular Acréscimo por Impontualidade Santos Data:
	 * 09/01/2006 Dados do Indices Acrescimo Impontualidade
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano Mês de Referencia de Débito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarIndiceAcrescimoImpontualidade(int anoMesReferenciaDebito)
			throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai " + "from IndicesAcrescimosImpontualidade iai " + "where iai.anoMesReferencia =  :anoMesReferencia";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	/**
	 * Pesquisa o acréscimo da maneira correta
	 * 
	 * Data: 07/09/2009 Author: Rafael Corrêa
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano Mês de Referencia de Débito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIgualIndiceAcrescimoImpontualidade(int anoMesReferenciaDebito)
			throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai " + "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select max(iai2.anoMesReferencia) "
					+ "from IndicesAcrescimosImpontualidade iai2 where iai2.anoMesReferencia <= :anoMesReferencia)";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	/**
	 * Faz parte de [UC0216] Calcular Acréscimo por Impontualidade Santos Data:
	 * 09/01/2006 Pesquisa os dados do Indices Acrescimo Impontualidade menor ao
	 * ano mes referencia
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano Mês de Referencia de Débito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIndiceAcrescimoImpontualidade(int anoMesReferenciaDebito)
			throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai " + "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select max(iai2.anoMesReferencia) "
					+ "from IndicesAcrescimosImpontualidade iai2 where iai2.anoMesReferencia < :anoMesReferencia)";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	public Collection pesquisarGuiasPagamentoImovel(Integer idImovel, int indicadorPagamento, String situacaoNormal,
			Date dataVencimentoInicial, Date dataVencimentoFinal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, " + "min(pagto.pgmt_dtpagamento) as dataPagamento, "
					+ " guia.dotp_id as idDocumentoTipo " + "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id " + "WHERE guia.imov_id = :idImovel "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal, guia.dotp_id  ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0 ";
			}

			retorno = session.createSQLQuery(consulta).addScalar("idGuia", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("anoMesReferencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("descricaoDebitoTipo", Hibernate.STRING).addScalar("dataEmissao", Hibernate.DATE)
					.addScalar("idDebitoTipo", Hibernate.INTEGER).addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
					.addScalar("numeroPrestacoesTotal", Hibernate.SHORT).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE).addScalar("idDocumentoTipo", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).setInteger("situacaoNormal", new Integer(situacaoNormal))
					.setDate("inicialVencimento", dataVencimentoInicial).setDate("finalVencimento", dataVencimentoFinal).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0200] Inserir Débito Automático [FS0004] Verificar Data de Opção
	 * posterior já informada
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDataOpcao(String matriculaImovel, Date dataOpcao, String identificadorCliente, String codigoAgencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id " + "from DebitoAutomatico deb " + "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia " + "where imovel.id = :matricula AND "
					// Alterado Bruno Barros
					// + "((agencia.codigoAgencia = :codigoAgencia AND "
					// +
					// "deb.identificacaoClienteBanco = :identificadorCliente) OR "
					+ "(deb.dataExclusao is null " + "and deb.dataOpcaoDebitoContaCorrente >= :data)";

			retorno = session.createQuery(consultaDataOpcao).setInteger("matricula", new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0201] Excluir Débito Automático [FS0004] Verificar Data de Opção
	 * posterior já informada
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDataOpcaoExclusao(String matriculaImovel, Date dataOpcao, String identificadorCliente)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id " + "from DebitoAutomatico deb " + "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia " + "where imovel.id = :matricula AND " + "deb.dataExclusao is null "
					+ "and deb.dataOpcaoDebitoContaCorrente > :data";

			retorno = session.createQuery(consultaDataOpcao).setInteger("matricula", new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0200] Inserir Débito Automático Verificar se o Imóvel já é Débito
	 * Automático
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDebitoAutomatico(String matriculaImovel) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String verificaDebitoAutomatico;

		try {
			// Verifica se já tem débito automático
			verificaDebitoAutomatico = "select agencia.id " + "from DebitoAutomatico deb " + "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia " + "where imovel.id = :matricula " + "and deb.dataExclusao is null ";

			retorno = session.createQuery(verificaDebitoAutomatico).setInteger("matricula", new Integer(matriculaImovel).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	public void atualizarDataExclusao(String matriculaImovel, Integer idAgencia) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String update;

		try {
			update = "UPDATE gcom.arrecadacao.debitoautomatico.DebitoAutomatico "
					+ "SET deba_dtexclusao = :data, deba_tmultimaalteracao = :ultimaAlteracao " + "WHERE imov_id = :matricula "
					+ "AND deba_dtexclusao is null " + "AND agen_id = :idAgencia";

			session.createQuery(update).setInteger("matricula", new Integer(matriculaImovel).intValue()).setDate("data", new Date())
					.setTimestamp("ultimaAlteracao", new Date()).setInteger("idAgencia", idAgencia).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	public void atualizarDataExclusao(String matriculaImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String update;

		try {
			update = "UPDATE gcom.arrecadacao.debitoautomatico.DebitoAutomatico "
					+ "SET deba_dtexclusao = :data, deba_tmultimaalteracao = :ultimaAlteracao " + "WHERE imov_id = :matricula "
					+ "AND deba_dtexclusao is null";

			session.createQuery(update).setInteger("matricula", new Integer(matriculaImovel).intValue()).setDate("data", new Date())
					.setTimestamp("ultimaAlteracao", new Date()).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0200] Inserir Débito Automático
	 * 
	 * @author Roberta Costa
	 * @created 04/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @param codigoBanco
	 *            Código do Banco
	 * @param codigoAgencia
	 *            Código da Agência
	 * @param identificacaoCliente
	 *            Identificação do Cliente no Banco
	 * @param dataOpcao
	 *            Data da Opção
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void inserirDebitoAutomatico(DebitoAutomatico debitoAutomatico) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			// Inclui o débito automárico

			session.save(debitoAutomatico);
			session.flush();
			session.clear();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0200] Inserir Débito Automático Atualiza o indicador de débio
	 * automático em Imóvel
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarIndicadorDebitoAutomatico(String matriculaImovel, Integer indicadorDebito) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaIndicadorDebitoAutomatico;

		try {
			// Atualiza em débito automático a Data Exclusão com a data corrente
			atualizaIndicadorDebitoAutomatico = "update gcom.cadastro.imovel.Imovel "
					+ "set imov_icdebitoconta = :indicador,imov_tmultimaalteracao = :ultimaAlteracao where imov_id = :matricula";

			session.createQuery(atualizaIndicadorDebitoAutomatico).setInteger("matricula", new Integer(matriculaImovel).intValue())
					.setInteger("indicador", indicadorDebito).setTimestamp("ultimaAlteracao", new Date()).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0201] Remover Débito Automático Verificar se o Imóvel já é Débito
	 * Automático para o mesmo Banco e Agencia
	 * 
	 * @author Roberta Costa
	 * @created 09/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDebitoAutomaticoBancoAgencia(String codigoBanco, String codigoAgencia) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String verificaDebitoAutomatico;

		try {
			// Verifica se já tem débito automático
			verificaDebitoAutomatico = "select agencia.id " + "from Agencia agencia " + "inner join agencia.banco banco "
					+ "where banco.id = :codigoBanco " + "and agencia.codigoAgencia = :agencia ";

			retorno = session.createQuery(verificaDebitoAutomatico).setInteger("codigoBanco", new Integer(codigoBanco).intValue())
					.setString("agencia", codigoAgencia).setMaxResults(1).uniqueResult();

			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0246] Executar Atividade de Ação de Cobrança Pesquisa uma coleção de
	 * CobrancaAcaoAtividadeCronograma
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	/*
	 * public Collection<CobrancaAcaoAtividadeCronograma>
	 * pesquisarCobrancaAcaoAtividadeCronograma() throws
	 * ErroRepositorioException{
	 * 
	 * //cria a variável que vai armazenar a coleção pesquisada
	 * Collection<CobrancaAcaoAtividadeCronograma> retorno = null;
	 * 
	 * //cria uma sessão com o hibernate Session session =
	 * HibernateUtil.getSession();
	 * 
	 * //cria a variável que vai conter o hql String consulta;
	 * 
	 * try { //constroi o hql consulta = "select caac " + "from
	 * CobrancaAcaoAtividadeCronograma caac " + "where (caac.comando is not
	 * null) and " + "((caac.realizacao is null) or (caac.realizacao <
	 * caac.comando))";
	 * 
	 * //executa o hql retorno = session.createQuery(consulta).list();
	 * 
	 * //erro no hibernate } catch (HibernateException e) { // levanta a exceção
	 * para a próxima camada throw new ErroRepositorioException(e, "Erro no
	 * Hibernate"); } finally { // fecha a sessão
	 * HibernateUtil.closeSession(session); }
	 * 
	 * //retorna a coleção do resultado da pesquisa return retorno; }
	 */

	/**
	 * [UC0246] Executar Atividade de Ação de Cobrança Pesquisa uma coleção de
	 * CobrancaAcaoAtividadeComand
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	/*
	 * public Collection<CobrancaAcaoAtividadeComand>
	 * pesquisarCobrancaAcaoAtividadeComand() throws ErroRepositorioException{
	 * 
	 * //cria a variável que vai armazenar a coleção pesquisada
	 * Collection<CobrancaAcaoAtividadeComand> retorno = null;
	 * 
	 * //cria uma sessão com o hibernate Session session =
	 * HibernateUtil.getSession();
	 * 
	 * //cria a variável que vai conter o hql String consulta;
	 * 
	 * try { //constroi o hql consulta = "select cacm " + "from
	 * CobrancaAcaoAtividadeComand cacm " + "where (cacm.comando is not null)
	 * and " + "((cacm.realizacao is null) or (cacm.realizacao <
	 * cacm.comando))";
	 * 
	 * //executa o hql retorno = session.createQuery(consulta).list();
	 * 
	 * //erro no hibernate } catch (HibernateException e) { // levanta a exceção
	 * para a próxima camada throw new ErroRepositorioException(e, "Erro no
	 * Hibernate"); } finally { // fecha a sessão
	 * HibernateUtil.closeSession(session); }
	 * 
	 * //retorna a coleção do resultado da pesquisa return retorno; }
	 */

	/**
	 * Consultar Dados do Cliente Imovel Vinculado Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param inscricaoImovel
	 *            Inscrição do Imovel
	 * @return Dados do Imovel Vinculado
	 * @throws ControladorException
	 */
	public Object[] consultarDadosClienteImovelUsuario(Imovel imovel) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select cliente.id,cliente.nome " + "from ClienteImovel clienteImovel "
					+ "inner join clienteImovel.cliente cliente " + "inner join clienteImovel.imovel imovel "
					+ "inner join clienteImovel.clienteRelacaoTipo clienteRelacaoTipo "
					+ "where imovel.id = :id and clienteRelacaoTipo.id = :usuario "
					+ "and clienteImovel.clienteImovelFimRelacaoMotivo is null";

			retorno = (Object[]) session.createQuery(consulta).setInteger("id", imovel.getId().intValue())
					.setInteger("usuario", ClienteRelacaoTipo.USUARIO).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * Consultar Matriculas dos Imoveis Vinculados do Imovel condominio Auhtor:
	 * Rafael Santos Data: 23/01/2006 [UC0179] Consultar Historico Medição
	 * Indiviualizada
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarConsumoHistoricoImoveisVinculados(ConsumoHistorico consumoHistorico) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.id " + "from ConsumoHistorico consumo " + "inner join consumo.imovel imovel "
					+ "where consumo.consumoImovelCondominio = :id";

			retorno = session.createQuery(consulta).setInteger("id", consumoHistorico.getId().intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Consultar Consumo Tipo do Consumo Historico Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return Dados do Consumo Tipo
	 * @throws ControladorException
	 */
	public Object[] consultarDadosConsumoTipoConsumoHistorico(ConsumoHistorico consumoHistorico) throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select consumo.descricaoAbreviada,consumo.id " + "from ConsumoTipo consumo " + "where consumo.id = :id";

			retorno = (Object[]) session.createQuery(consulta).setInteger("id", consumoHistorico.getConsumoTipo().getId().intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consultar Consumo Historico da Medicao Individualizada Auhtor: Rafael
	 * Santos Data: 23/01/2006 [UC0179] Consultar Historico Medição
	 * Indiviualizada
	 * 
	 * @param imovel
	 *            Imovel
	 * @param ligcaoTipo
	 *            Tipo de Ligacação
	 * @param anoMesFaturamento
	 *            Ano Mes Faturamento
	 * @return
	 * @throws ControladorException
	 */
	public Object[] obterConsumoHistoricoMedicaoIndividualizada(Imovel imovel, LigacaoTipo ligacaoTipo, int anoMesFaturamento)
			throws ErroRepositorioException {
		Object[] retornoDados = null;
		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select ch.id,ch.consumoRateio, " + "ch.numeroConsumoFaturadoMes,ch.consumoTipo "
					+ "from ConsumoHistorico ch where  " + "ch.imovel.id = :id  " + "and ch.referenciaFaturamento = :anoMes "
					+ "and ch.ligacaoTipo.id = :ligacao";

			retorno = session.createQuery(consulta).setInteger("id", imovel.getId().intValue()).setInteger("anoMes", anoMesFaturamento)
					.setInteger("ligacao", ligacaoTipo.getId()).setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoDados = (Object[]) retorno;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retornoDados;

	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o debitocreditosituacao
	 * em conta
	 * 
	 * @author Fernanda Karla
	 * @created 14/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idConta
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoConta(String codigoConta, int situacaoAtual, int anoMesReferenciaContabil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoConta;

		try {
			// Atualiza em conta o DebitoCreditoSituacao
			atualizaSituacaoConta = "update gcom.faturamento.conta.Conta " + "set dcst_idatual = :situacaoAtual, dcst_idanterior = null, "
					+ "cnta_tmultimaalteracao = :ultimaAlteracao, cnta_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where cnta_id = :codigoConta";

			session.createQuery(atualizaSituacaoConta).setInteger("codigoConta", new Integer(codigoConta).intValue())
					.setInteger("situacaoAtual", new Integer(situacaoAtual).intValue()).setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o debitocreditosituacao
	 * em guia pagamento
	 * 
	 * @author Fernanda Karla
	 * @created 15/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idGuiaPagamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoGuiaPagamento(String codigoGuiaPagamento, int situacaoAtualGuia, int anoMesReferenciaContabil)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoGuiaPagamento;

		try {
			// Atualiza em guiapagamento o DebitoCreditoSituacao
			atualizaSituacaoGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set dcst_idatual = :situacaoAtualGuia, dcst_idanterior = null, "
					+ "gpag_tmultimaalteracao = :ultimaAlteracao, gpag_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where gpag_id = :codigoGuiaPagamento";

			session.createQuery(atualizaSituacaoGuiaPagamento)
					.setInteger("codigoGuiaPagamento", new Integer(codigoGuiaPagamento).intValue())
					.setInteger("situacaoAtualGuia", new Integer(situacaoAtualGuia).intValue()).setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idParcelamento
	 *            motivo parcelamentoSituacao
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarParcelamento(Integer codigoParcelamento, Integer parcelamentoSituacao, String motivo, Integer usuarioId)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaParcelamento;

		try {
			// Atualiza em guiapagamento o DebitoCreditoSituacao
			atualizaParcelamento = "update gcom.cobranca.parcelamento.Parcelamento " + "set " + "pcst_id = :parcelamentoSituacao, "
					+ "pmdz_id = :motivo, " + "parc_tmultimaalteracao = :ultimaAlteracao, " + "usur_iddesfaz = :usuarioId  "
					+ "where parc_id = :codigoParcelamento";

			session.createQuery(atualizaParcelamento).setInteger("codigoParcelamento", new Integer(codigoParcelamento).intValue())
					.setInteger("parcelamentoSituacao", new Integer(parcelamentoSituacao).intValue())
					.setInteger("motivo", new Integer(motivo).intValue()).setTimestamp("ultimaAlteracao", new Date())
					.setInteger("usuarioId", usuarioId.intValue()).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	// @TODO

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o debitocreditosituacao
	 * em debito a cobrar
	 * 
	 * @author Fernanda Karla
	 * @created 16/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            iddebitoacobrar
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoDebitoACobrar(String codigoDebitoACobrar, int situacaoAtualDebito, int anoMesReferenciaContabil)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoDebitoACobrar;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			atualizaSituacaoDebitoACobrar = "update gcom.faturamento.debito.DebitoACobrar "
					+ "set dcst_idatual = :situacaoAtualDebito, dcst_idanterior = null, "
					+ "dbac_tmultimaalteracao = :ultimaAlteracao, dbac_amreferenciacontabil =:anoMesReferenciaContabil  "
					+ "where dbac_id = :codigoDebitoACobrar";

			session.createQuery(atualizaSituacaoDebitoACobrar)
					.setInteger("codigoDebitoACobrar", new Integer(codigoDebitoACobrar).intValue())
					.setInteger("situacaoAtualDebito", new Integer(situacaoAtualDebito).intValue())
					.setTimestamp("ultimaAlteracao", new Date()).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o debitocreditosituacao
	 * em credito a realizar
	 * 
	 * @author Fernanda Karla
	 * @created 16/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idCreditoARealizar
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoCreditoARealizar(String codigoCreditoARealizar, int situacaoAtualCredito, int anoMesReferenciaContabil)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoCreditoARealizar;

		try {
			// Atualiza em creditoarealizar o DebitoCreditoSituacao
			atualizaSituacaoCreditoARealizar = "update gcom.faturamento.credito.CreditoARealizar "
					+ "set dcst_idatual = :situacaoAtualCredito, dcst_idanterior = null, "
					+ "crar_tmultimaalteracao = :ultimaAlteracao , crar_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where crar_id = :codigoCreditoARealizar";

			session.createQuery(atualizaSituacaoCreditoARealizar)
					.setInteger("codigoCreditoARealizar", new Integer(codigoCreditoARealizar).intValue())
					.setInteger("situacaoAtualCredito", new Integer(situacaoAtualCredito).intValue())
					.setTimestamp("ultimaAlteracao", new Date()).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove débitos a cobrar referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	@SuppressWarnings({ "rawtypes" })
	public void removerDebitoACobrarDoParcelamento(Integer codigoImovel, Integer codigoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerDebitoACobrarDoParcelamento;
		String consulta;
		Collection collectionIdDebito = null;

		try {

			consulta = "select dac.id  " + "from DebitoACobrar dac "
					+ "where dac.imovel.id = :codigoImovel and dac.parcelamento.id = :codigoParcelamento";

			collectionIdDebito = session.createQuery(consulta).setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento", codigoParcelamento.intValue()).list();

			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {

					String id = ((Integer) icolecaoDebitos.next()).toString();
					consulta = "delete DebitoACobrarCategoria debitoACobrarCategoria "
							+ "where debitoACobrarCategoria.debitoACobrar.id = :debito ";

					session.createQuery(consulta).setInteger("debito", new Integer(id).intValue()).executeUpdate();
				}
			}

			// deleta cobrança documento item
			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {
					
					String id = ((Integer) icolecaoDebitos.next()).toString();
					List lista = session
							.createQuery(" from CobrancaDocumentoItem cobrancaDocumentoItem where cobrancaDocumentoItem.debitoACobrarGeral.id = :debito ")
							.setInteger("debito", new Integer(id).intValue())
							.list();
					
					if(lista.size() > 0) {
						CobrancaDocumentoItem item = (CobrancaDocumentoItem) lista.get(0);
						
						CobrancaDocumentoItemHistorico cobrancaDocumentoItemHistorico = new CobrancaDocumentoItemHistorico(
								item.getId(),
								item.getValorItemCobrado(),
								item.getUltimaAlteracao(),
								item.getDebitoACobrarGeral(),
								item.getCobrancaDocumento(),
								item.getDocumentoTipo(),
								item.getContaGeral(),
								item.getGuiaPagamentoGeral(),
								item.getCreditoARealizarGeral(),
								item.getCobrancaDebitoSituacao(),
								item.getValorAcrescimos());						
						
						session.save(cobrancaDocumentoItemHistorico);
						session.flush();
						session.clear();
					}

					consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
							+ "where cobrancaDocumentoItem.debitoACobrarGeral.id = :debito ";

					session.createQuery(consulta).setInteger("debito", new Integer(id).intValue()).executeUpdate();
				}
			}

			// deleta o debito a cobrar
			removerDebitoACobrarDoParcelamento = "delete DebitoACobrar "
					+ "where imov_id = :codigoImovel and parc_id = :codigoParcelamento ";

			session.createQuery(removerDebitoACobrarDoParcelamento).setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento", codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {

					String id = ((Integer) icolecaoDebitos.next()).toString();
					consulta = "delete DebitoACobrarGeral debitoACobrarGeral " + "where debitoACobrarGeral.debitoACobrar.id = :debito ";

					session.createQuery(consulta).setInteger("debito", new Integer(id).intValue()).executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove débitos a cobrar categoria
	 * referentes ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerDebitoACobrarCategoriaDoParcelamento(Integer idDebito) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerDebitoACobrarDoParcelamento;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			removerDebitoACobrarDoParcelamento = "delete gcom.faturamento.debito.DebitoACobrarCategoria " + "where dbac_id = :idDebito ";

			session.createQuery(removerDebitoACobrarDoParcelamento).setInteger("idDebito", idDebito.intValue()).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Seleciona o débito a cobrar para
	 * remover do parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */

	@SuppressWarnings("rawtypes")
	public Collection<DebitoACobrar> pesquisarDebitoACobrarDoParcelamento(Integer codigoImovel, Integer codigoParcelamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<DebitoACobrar> retorno = null;
		String pesquisarDebitoACobrarDoParcelamento;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			pesquisarDebitoACobrarDoParcelamento = "SELECT debitoACobrar FROM DebitoACobrar debitoACobrar "
					+ "WHERE debitoACobrar.imovel.id = :codigoImovel AND debitoACobrar.parcelamento.id = :codigoParcelamento ";

			retorno = session.createQuery(pesquisarDebitoACobrarDoParcelamento).setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento", codigoParcelamento.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove credito a realizar
	 * referentes ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerCreditoARealizarDoParcelamento(Integer codigoImovel, Integer codigoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerCreditoARealizarDoParcelamento;
		String consulta;
		Collection collectionIdCredito = null;

		try {

			consulta = "select car.id  " + "from CreditoARealizar car "
					+ "where car.imovel.id = :codigoImovel and car.parcelamento.id = :codigoParcelamento";

			collectionIdCredito = session.createQuery(consulta).setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento", codigoParcelamento.intValue()).list();

			if (collectionIdCredito != null && !collectionIdCredito.isEmpty()) {

				Iterator icolecaoCreditos = collectionIdCredito.iterator();

				while (icolecaoCreditos.hasNext()) {

					String id = ((Integer) icolecaoCreditos.next()).toString();
					consulta = "delete CreditoARealizarCategoria creditoARealizarCategoria "
							+ "where creditoARealizarCategoria.creditoARealizar.id = :credito ";

					session.createQuery(consulta).setInteger("credito", new Integer(id).intValue()).executeUpdate();
				}
			}

			if (collectionIdCredito != null && !collectionIdCredito.isEmpty()) {

				Iterator icolecaoCreditos = collectionIdCredito.iterator();

				while (icolecaoCreditos.hasNext()) {

					String id = ((Integer) icolecaoCreditos.next()).toString();
					List lista = session
							.createQuery(" from CobrancaDocumentoItem cobrancaDocumentoItem where cobrancaDocumentoItem.creditoARealizarGeral.id = :credito ")
							.setInteger("credito", new Integer(id).intValue())
							.list();
					
					if(lista.size() > 0) {
						CobrancaDocumentoItem item = (CobrancaDocumentoItem) lista.get(0);
						
						CobrancaDocumentoItemHistorico cobrancaDocumentoItemHistorico = new CobrancaDocumentoItemHistorico(
								item.getId(),
								item.getValorItemCobrado(),
								item.getUltimaAlteracao(),
								item.getDebitoACobrarGeral(),
								item.getCobrancaDocumento(),
								item.getDocumentoTipo(),
								item.getContaGeral(),
								item.getGuiaPagamentoGeral(),
								item.getCreditoARealizarGeral(),
								item.getCobrancaDebitoSituacao(),
								item.getValorAcrescimos());	
						
						session.save(cobrancaDocumentoItemHistorico);
						session.flush();
						session.clear();
					}
					
					consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
							+ "where cobrancaDocumentoItem.creditoARealizarGeral.id = :credito ";

					session.createQuery(consulta).setInteger("credito", new Integer(id).intValue()).executeUpdate();
				}
			}

			removerCreditoARealizarDoParcelamento = "delete CreditoARealizar "
					+ "where imov_id = :codigoImovel and parc_id = :codigoParcelamento ";

			session.createQuery(removerCreditoARealizarDoParcelamento).setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento", codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdCredito != null && !collectionIdCredito.isEmpty()) {

				Iterator icolecaoCreditos = collectionIdCredito.iterator();

				while (icolecaoCreditos.hasNext()) {

					String id = ((Integer) icolecaoCreditos.next()).toString();
					consulta = "delete CreditoARealizarGeral creditoARealizarGeral "
							+ "where creditoARealizarGeral.creditoARealizar.id = :credito ";

					session.createQuery(consulta).setInteger("credito", new Integer(id).intValue()).executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove guia pagamento referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerGuiaPagamentoDoParcelamento(Integer codigoImovel, Integer codigoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerGuiaPagamentoDoParcelamento;
		String consulta;
		Collection collectionIdGuia = null;

		try {

			consulta = "select gui.id  " + "from GuiaPagamento gui "
					+ "where gui.imovel.id = :codigoImovel and gui.parcelamento.id = :codigoParcelamento";

			collectionIdGuia = session.createQuery(consulta).setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento", codigoParcelamento.intValue()).list();

			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					consulta = "delete GuiaPagamentoCategoria guiaPagamentoCategoria "
							+ "where guiaPagamentoCategoria.guiaPagamento.id = :guia ";

					session.createQuery(consulta).setInteger("guia", new Integer(id).intValue()).executeUpdate();
				}
			}

			// deleta cobrança documento item
			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					List lista = session
							.createQuery(" from CobrancaDocumentoItem cobrancaDocumentoItem where cobrancaDocumentoItem.guiaPagamentoGeral.id = :guia ")
							.setInteger("guia", new Integer(id).intValue())
							.list();
					
					if(lista.size() > 0) {
						CobrancaDocumentoItem item = (CobrancaDocumentoItem) lista.get(0);
						
						CobrancaDocumentoItemHistorico cobrancaDocumentoItemHistorico = new CobrancaDocumentoItemHistorico(
								item.getId(),
								item.getValorItemCobrado(),
								item.getUltimaAlteracao(),
								item.getDebitoACobrarGeral(),
								item.getCobrancaDocumento(),
								item.getDocumentoTipo(),
								item.getContaGeral(),
								item.getGuiaPagamentoGeral(),
								item.getCreditoARealizarGeral(),
								item.getCobrancaDebitoSituacao(),
								item.getValorAcrescimos());	
						
						session.save(cobrancaDocumentoItemHistorico);
						session.flush();
						session.clear();
					}
					
					consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
							+ "where cobrancaDocumentoItem.guiaPagamentoGeral.id = :guia ";

					session.createQuery(consulta).setInteger("guia", new Integer(id).intValue()).executeUpdate();
				}

			}

			// deleta o debito a cobrar
			removerGuiaPagamentoDoParcelamento = "delete GuiaPagamento "
					+ "where imov_id = :codigoImovel and parc_id = :codigoParcelamento ";

			session.createQuery(removerGuiaPagamentoDoParcelamento).setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento", codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					consulta = "delete GuiaPagamentoGeral guiaPagamentoGeral " + "where guiaPagamentoGeral.guiaPagamento.id = :guia ";

					session.createQuery(consulta).setInteger("guia", new Integer(id).intValue()).executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove guia pagamento referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerGuiaPagamentoCobrancaDoParcelamento(Integer idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerGuiaPagamentoDoParcelamento;

		try {
			// remove em credito a realizar os parcelamentos
			removerGuiaPagamentoDoParcelamento = "delete gcom.arrecadacao.pagamento.GuiaPagamentoCategoria "
					+ "where gpag_id = :idGuiaPagamento ";

			session.createQuery(removerGuiaPagamentoDoParcelamento).setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0246] Executar Atividade de Ação de Cobrança Pesquisa uma coleção de
	 * CobrancaAcaoAtividadeCronograma
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarCobrancaAcaoAtividadeCronograma() throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<CobrancaAcaoAtividadeCronograma> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select caac " + "from CobrancaAcaoAtividadeCronograma caac " + " left join fetch caac.cobrancaAcaoCronograma cac"
					+ " left join fetch caac.cobrancaAtividade" + " left join fetch cac.cobrancaAcao"
					+ " left join fetch cac.cobrancaGrupoCronogramaMes" + " left join fetch cac.cobrancaGrupoCronogramaMes cgcm"
					+ " left join fetch cgcm.cobrancaGrupo" + "where (caac.comando is not null) and "
					+ "((caac.realizacao is null) or (caac.realizacao < caac.comando))";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta).list()));

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0246] Executar Atividade de Ação de Cobrança Pesquisa uma coleção de
	 * CobrancaAcaoAtividadeComando
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public Collection<CobrancaAcaoAtividadeComando> pesquisarCobrancaAcaoAtividadeComando() throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<CobrancaAcaoAtividadeComando> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cacm " + "from CobrancaAcaoAtividadeComando cacm " + " left join fetch cacm.cobrancaAcao ca"
					+ " left join fetch cacm.cobrancaAtividade cat" + " left join fetch cacm.usuario usuario"
					+ "where (cacm.comando is not null) and " + "((cacm.realizacao is null) or (cacm.realizacao < cacm.comando))";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta).list()));

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @created 16/02/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel, int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,cd.valorTaxa,loca.id, documentoTipo.id, "
			/**
			 *  Adicionando no retorno da consulta o valor do
			 * documento de cobrança, para comparar com o valor do pagamento
			 */
			+ "cd.valorDocumento " + "FROM CobrancaDocumento cd " + "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo " + "LEFT JOIN cd.localidade loca "
					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND " + "imovel.id = :idImovel";

			retorno = (Object[]) session.createQuery(consulta).setInteger("numeroSequencialDocumento", numeroSequencialDocumento)
					.setInteger("idImovel", idImovel.intValue()).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras [SB0005] - Processar
	 * Recebimento de Acréscimos por Inpontualidade Autor: Sávio Luiz
	 * Data:06/11/2006
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarCobrancaDocumentoItemComConta(Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta " + "FROM CobrancaDocumentoItem cdi " + "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cdi.contaGeral.conta conta " + "WHERE conta.id is not null AND " + "cd.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras [SB0005] - Processar
	 * Recebimento de Acréscimos por Inpontualidade Autor: Sávio Luiz
	 * Data:06/11/2006
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarCobrancaDocumentoItemComGuiaPagamento(Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT guiaPagamento.id " + "FROM CobrancaDocumentoItem cdi " + "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento " + "WHERE guiaPagamento.id is not null AND "
					+ "cd.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Sávio Luiz, Ivan Sergio
	 * @created 16/02/2006 01/10/2010 - CRC5063 - Adicionado o id do Item para
	 *          auxiliar a CRC;
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel, int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id, " // 15
					+ "debitoACobrar.numeroPrestacaoDebito, " // 16
					+ "debitoACobrar.numeroPrestacaoCobradas, " // 17
					+ "cdi.numeroParcelasAntecipadas, " // 18
					+ "cdi.id, " // 19
					+ "debitoACobrar.parcelamento.id, " // 20
					+ "debitoACobrarHistorico.parcelamento.id " //21 
					+ "FROM CobrancaDocumentoItem cdi " + "LEFT JOIN cdi.cobrancaDocumento cd " + "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo " + "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage " + "LEFT JOIN cd.localidade loca " + "LEFT JOIN cd.imovel imov "
					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND " + "imovel.id = :idImovel";

			retorno = session.createQuery(consulta).setInteger("numeroSequencialDocumento", numeroSequencialDocumento)
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Inseri a cobrança situação historico na base passando a coleção de
	 * cobrança situação historico
	 * 
	 * [UC0177] Informar Situacao Especial de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @date 20/03/2006
	 * 
	 * @param collectionCobrancaSituacaoHistorico
	 * @return
	 */
	@SuppressWarnings("rawtypes")
	public void inserirCobrancaSituacaoHistorico(Collection collectionCobrancaSituacaoHistorico) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Iterator iteratorFSH = collectionCobrancaSituacaoHistorico.iterator();
		try {
			while (iteratorFSH.hasNext()) {
				CobrancaSituacaoHistorico cobrancaSituacaoHistorico = (CobrancaSituacaoHistorico) iteratorFSH.next();
				session.save(cobrancaSituacaoHistorico);
			}
			session.flush();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Atualiza o ano mes de cobranca situação historico
	 * 
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 17/03/2006
	 * 
	 * @param situacaoEspecialFaturamentoHelper
	 * @throws ErroRepositorioException
	 */
	public void atualizarAnoMesCobrancaSituacaoHistorico(SituacaoEspecialCobrancaHelper situacaoEspecialCobrancaHelper,
			Integer anoMesReferencia, Collection colecaoImoveis, Integer idCobrancaSituacaoConsumo) throws ErroRepositorioException {

		String consulta = "";

		Session session = HibernateUtil.getSession();
		try {

			consulta = "update gcom.cobranca.CobrancaSituacaoHistorico set " + "cbsc_idretirada = :idCobrancaSituacaoConsumo, "
					+ "cbsh_amcobrancaretirada = :anoMes," + "usur_idretira = null," + "cbsh_tmultimaalteracao = :ultimaAlteracao "
					+ "where imov_id in ( :imoveis )" + " and cbsh_amcobrancaretirada is null";

			session.createQuery(consulta).setParameterList("imoveis", colecaoImoveis).setInteger("anoMes", anoMesReferencia)
					.setInteger("idCobrancaSituacaoConsumo", idCobrancaSituacaoConsumo).setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 30/03/2006 Pesquisa os ID das Contas dos cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDContasClienteConta(String codigoCliente, Short relacaoTipo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select conta.id from ClienteConta clienteConta " + "inner join clienteConta.cliente cliente "
					+ "inner join clienteConta.conta conta ";

			if (relacaoTipo != null) {
				consulta = consulta + " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue())
						.setShort("relacao", new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito atualizar na tabela imovel o
	 * parcelamento e reparcelamento
	 * 
	 * @author Fernanda Paiva
	 * @date 29/04/2006
	 * 
	 * @param imovel
	 * @param numeroParcelamento
	 * @param numeroReparcelamento
	 * @param numeroReparcelamentoConsecutivo
	 * @throws ErroRepositorioException
	 */
	public void atualizarDadosParcelamentoImovel(Integer codigoImovel, Short numeroParcelamento, Short numeroReparcelamento,
			Short numeroReparcelamentoConsecutivo) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			atualizarImovel = "update gcom.cadastro.imovel.Imovel " + "set imov_nnparcelamento = :numeroParcelamento, "
					+ "imov_nnreparcelamento = :numeroReparcelamento, " + "imov_nnreparcmtconsec = :numeroReparcelamentoConsecutivo, "
					+ "imov_tmultimaalteracao = :ultimaAlteracao " + "where imov_id = :codigoImovel";

			session.createQuery(atualizarImovel).setInteger("codigoImovel", new Integer(codigoImovel).intValue())
					.setInteger("numeroParcelamento", new Short(numeroParcelamento).intValue())
					.setInteger("numeroReparcelamento", new Short(numeroReparcelamento).intValue())
					.setInteger("numeroReparcelamentoConsecutivo", new Short(numeroReparcelamentoConsecutivo).intValue())
					.setTimestamp("ultimaAlteracao", new Date()).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem os parcelamentos de débitos efetuados no mês de faturamento
	 * corrente e que estejam com situação normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSituacaoNormalNoMes(String parcelamentoSituacao, Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct parc.id, parc.parcelamento, imov.id  " + "FROM DebitoACobrar dbac "
					+ "INNER JOIN dbac.parcelamento parc " + "INNER JOIN parc.imovel imov "
					+ "WHERE parc.anoMesReferenciaFaturamento = :anoMesReferenciaArrecadacao "
					+ "AND parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND (parc.valorEntrada IS NOT NULL AND parc.valorEntrada > 0) " + "AND dbac.numeroPrestacaoCobradas = 0 "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta).setInteger("parcelamentoSituacao", new Integer(parcelamentoSituacao))
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem as guias de pagamentos dos parcelamentos de débitos efetuados no
	 * mês de faturamento corrente e que estejam com situação normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoDoParcelamento(String parcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT gpag.id, gpag.dataVencimento  " + "FROM GuiaPagamento gpag " + "WHERE gpag.parcelamento = :parcelamento ";

			retorno = session.createQuery(consulta).setInteger("parcelamento", new Integer(parcelamento)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Raphael
	 * Rossiter Data: 28/12/2006
	 * 
	 * Obtem as contas dos parcelamentos de débitos efetuados no mês de
	 * faturamento corrente e que estejam com situação normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaDoParcelamento(Integer parcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT cnta.id " + "FROM Conta cnta " + "WHERE cnta.parcelamento.id = :parcelamento ";

			retorno = session.createQuery(consulta).setInteger("parcelamento", parcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem os pagamentos para a guia de pagamentos dos parcelamentos de
	 * débitos efetuados no mês de faturamento corrente e que estejam com
	 * situação normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoParaGuiaPagamentoDoParcelamento(String igGuiaPagamento, Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// alterado por Vivianne Sousa - 03/09/2009 - Adriano Britto
			// alguns pagamentos não estavam guardando o id da guia,
			// para esses casos recupera o pagamento do imovel correspondente a
			// entrada de parcelamento
			consulta = " select pgmt_id as idPagamento " + " from arrecadacao.pagamento " + " where  gpag_id = :idGuiaPagamento ";

			retorno = session.createSQLQuery(consulta).addScalar("idPagamento", Hibernate.INTEGER)
					.setInteger("idGuiaPagamento", new Integer(igGuiaPagamento)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Raphael
	 * Rossiter Data: 28/12/2006
	 * 
	 * Obtem os pagamentos para a conta dos parcelamentos de débitos efetuados
	 * no mês de faturamento corrente e que estejam com situação normal
	 * 
	 * @param conta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoParaContaDoParcelamento(String idConta) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT pgmt.id  " + "FROM Pagamento pgmt " + "WHERE pgmt.contaGeral = :conta ";

			retorno = session.createQuery(consulta).setInteger("conta", new Integer(idConta)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0317] Manter Critério de Cobrança
	 * 
	 * Este caso de uso remove as linhas da cobrança critério passando a colecao
	 * de cobrança criterio
	 * 
	 * [SB0002] Excluir Critério de Cobrança
	 * 
	 * @author Sávio luiz
	 * @created 11/05/2006
	 * 
	 * @throws ControladorException
	 *             Controlador Exception
	 */
	public void removerCobrancaCriterioLinha(String[] idscobrancaCriterio) throws ErroRepositorioException {

		String remocao = null;

		/*
		 * Collection colecaoCobrancaCriterio = new ArrayList(); for(int
		 * i=0;i<idscobrancaCriterio.length;i++ ){ CobrancaCriterio
		 * cobrancaCriterio = new CobrancaCriterio(); cobrancaCriterio.setId(new
		 * Integer(idscobrancaCriterio[i]));
		 * colecaoCobrancaCriterio.add(cobrancaCriterio); }
		 */

		Session session = HibernateUtil.getSession();

		try {

			remocao = "delete gcom.cobranca.CobrancaCriterioLinha " + "where cbct_id IN(:idscobrancaCriterio)";

			session.createQuery(remocao).setParameterList("idscobrancaCriterio", idscobrancaCriterio).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	@SuppressWarnings("rawtypes")
	public Collection gerarRelacaoDebitos(String idImovelCondominio, String idImovelPrincipal, String idNomeConta,
			String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua, String idSituacaoLigacaoEsgoto,
			String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto, String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal, String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal, String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro, String municipio, String idTipoMedicao,
			String indicadorMedicao, String idSubCategoria, String idCategoria, String quantidadeEconomiasInicial,
			String quantidadeEconomiasFinal, String diaVencimento, String idCliente, String idClienteTipo, String idClienteRelacaoTipo,
			String numeroPontosInicial, String numeroPontosFinal, String numeroMoradoresInicial, String numeroMoradoresFinal,
			String idAreaConstruidaFaixa, String ordenacao, int quantidadeImovelInicio, String indicadorCpfCnpj, String cpfCnpj)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct "
					+ "gerenciaRegional.id,"
					+ "gerenciaRegional.nomeAbreviado,"
					+ "localidade.id,"
					+ "localidade.descricao,"
					+ "imovel.id,"
					+ "imovel.quantidadeEconomias,"
					+ "setorComercial.codigo, "
					+ "quadra.numeroQuadra,"
					+ "imovel.lote,"
					+ "imovel.subLote,"
					+ "ligacaoAguaSituacao.descricao,"
					+ "ligacaoEsgotoSituacao.descricao,"
					+ "ligacaoEsgoto.percentual,"
					+ "ligacaoAgua.dataCorte, "
					+ "gerenciaRegional.nome, "
					+ "clienteUsuario.nome, "
					+ "clienteResposanvel.nome, "
					+ "rota.codigo, "
					+ "imovel.numeroSequencialRota, "
					+ "(select  coalesce((sum (co.valorAgua + co.valorEsgoto + co.debitos - co.valorCreditos - coalesce(co.valorImposto,0))),0) "
					+ "from Conta co " + "where imovel.id = co.imovel.id " + "and co.debitoCreditoSituacaoAtual.id in (0, 1, 2) "
					+ "and co.id not in (select coalesce(pg.id,0) from Pagamento pg where pg.imovel.id = co.imovel.id)) "
					// "consumosHistorico.consumoMedio " +

					+ " from ImovelSubcategoria imovelSubcategoria ";
			if (idCobrancaSituacaoTipo != null && !idCobrancaSituacaoTipo.equals("")
					&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
				consulta = consulta + " , ImovelCobrancaSituacao imovelCobrancaSituacao ";
			}

			consulta = consulta
					+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
					+ " inner join imovel.localidade localidade   "
					+ " inner join localidade.gerenciaRegional gerenciaRegional "
					+ " inner join imovel.setorComercial setorComercial   "
					+ " inner join imovel.quadra quadra "
					+ " inner join quadra.rota rota "
					+ " left  join  imovelSubcategoria.comp_id.subcategoria subCategoria "
					+ " left join subCategoria.categoria categoria "
					+ " left  join imovel.logradouroBairro logradouroBairro  "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " left  join bairro.municipio municipio   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.cep cep   "
					+ " left  join logradouroCep.logradouro logradouro   "
					+ " left  join imovel.imovelCondominio imovelCondominio   "
					+ " left  join imovel.imovelPrincipal imovelPrincipal   "
					// + " left join imovel.nomeConta nomeConta "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao " + " left  join imovel.ligacaoAgua ligacaoAgua  "
					+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  " + " left  join imovel.imovelPerfil imovelPerfil  "
					+ " left  join imovel.pocoTipo pocoTipo   " + " left  join imovel.faturamentoTipo faturamentoTipo "
					+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
					+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ " left  join imovel.eloAnormalidade eloAnormalidade   " + " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
					+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  "
					+ " left  join imovel.consumoTarifa consumoTarifa   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
					+ " left join imovel.medicaoHistoricos medicaoHistorico   "
					+ " left join imovel.clienteImoveis clienteImoveis "
					+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo "
					+ " left join clienteImoveis.cliente cliente "
					+ " left join cliente.clienteTipo clienteTipo "
					// +
					// " left join imovel.clienteImoveis clienteImoveisUsuario "
					+

					" left outer join imovel.clienteImoveis clienteImoveisUsuario with (clienteImoveisUsuario.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.USUARIO.toString() + ") and clienteImoveisUsuario.dataFimRelacao is null "
					+ " left outer join clienteImoveisUsuario.cliente clienteUsuario " +

					" left outer join imovel.clienteImoveis clienteImoveisReposanvel with (clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString() + ") and clienteImoveisReposanvel.dataFimRelacao is null "
					+ " left outer join clienteImoveisReposanvel.cliente clienteResposanvel ";

			// intervalo Media Minima Imovel Inicial e Final
			if ((intervaloMediaMinimaImovelInicial != null && !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
					.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
					&& (intervaloMediaMinimaImovelFinal != null && !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
							.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
				consulta = consulta + " left join imovel.consumosHistoricos consumosHistorico ";
			}

			consulta = consulta
					+ montarCondicaoWhereFiltrarImovelOutrosCriterio(idImovelCondominio, idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal, intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial, intervaloMediaMinimaHidrometroFinal, idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo, idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa, idGerenciaRegional,
							idLocalidadeInicial, idLocalidadeFinal, setorComercialInicial, setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro, municipio, idTipoMedicao, indicadorMedicao, idSubCategoria,
							idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal, diaVencimento, idCliente, idClienteTipo,
							idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal, numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa, indicadorCpfCnpj, cpfCnpj);

			/*
			 * # COLOCANDO O VALOR NAS CONDIÇÕES#
			 */

			/*
			 * consulta = consulta +
			 * " consumosHistorico.referenciaFaturamento = " + "(select
			 * max(consumoHistorico.referenciaFaturamento) from ConsumoHistorico
			 * consumoHistorico " + " left join consumoHistorico.imovel
			 * imovelConsumoHistorico " + "where imovelConsumoHistorico.id =
			 * imovel.id) and ";
			 */

			if (ordenacao != null && !ordenacao.trim().equals("") && !ordenacao.trim().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				if (ordenacao.trim().equals("rota")) {
					consulta = consulta
							+ " order by gerenciaRegional.id, localidade.id, setorComercial.codigo, rota.codigo, imovel.numeroSequencialRota";
				}
			} else {
				consulta = consulta + " order by col_0_0_, col_2_0_, col_19_0_ desc";
			}

			Query query = session.createQuery(consulta);

			informarDadosQueryFiltrarImovelOutrosCriterio(query, idImovelCondominio, idImovelPrincipal, idNomeConta, idSituacaoLigacaoAgua,
					consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto, consumoMinimoInicialEsgoto,
					consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial, intervaloValorPercentualEsgotoFinal,
					intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal, intervaloMediaMinimaHidrometroInicial,
					intervaloMediaMinimaHidrometroFinal, idImovelPerfil, idPocoTipo, idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
					idSituacaoEspecialCobranca, idEloAnormalidade, areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia,
					idConsumoTarifa, idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal, setorComercialInicial,
					setorComercialFinal, quadraInicial, quadraFinal, loteOrigem, loteDestno, cep, logradouro, bairro, municipio,
					idTipoMedicao, indicadorMedicao, idSubCategoria, idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal,
					diaVencimento, idCliente, idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal,
					numeroMoradoresInicial, numeroMoradoresFinal, idAreaConstruidaFaixa, indicadorCpfCnpj, cpfCnpj);

			/*
			 * if(qtdImoveis != null && !qtdImoveis.equals("")){ Integer
			 * qtdImoveisInformada = new Integer (qtdImoveis) * 2; retorno =
			 * query.setMaxResults(qtdImoveisInformada).list(); }else
			 * if(qtdMaiores != null && !qtdMaiores.equals("")){ Integer
			 * qtdMaioresInformada = new Integer (qtdMaiores) * 2; retorno =
			 * query.setMaxResults(qtdMaioresInformada).list(); }else{
			 */
			retorno = query.setFirstResult(quantidadeImovelInicio).setMaxResults(500).list();
			// }

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Gerar Relação de Débitos
	 * 
	 * [UC0227] Gerar Relação de Débitos
	 * 
	 * @author Rafael Santos
	 * @date 12/06/2006
	 * 
	 */
	public Integer obterQuantidadaeRelacaoImoveisDebitos(String idImovelCondominio, String idImovelPrincipal, String idNomeConta,
			String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua, String idSituacaoLigacaoEsgoto,
			String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto, String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal, String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal, String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro, String municipio, String idTipoMedicao,
			String indicadorMedicao, String idSubCategoria, String idCategoria, String quantidadeEconomiasInicial,
			String quantidadeEconomiasFinal, String diaVencimento, String idCliente, String idClienteTipo, String idClienteRelacaoTipo,
			String numeroPontosInicial, String numeroPontosFinal, String numeroMoradoresInicial, String numeroMoradoresFinal,
			String idAreaConstruidaFaixa) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(distinct imovel.id) "
					+ " from ImovelSubcategoria imovelSubcategoria, ImovelCobrancaSituacao imovelCobrancaSituacao "
					+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
					+ " left  join  imovelSubcategoria.comp_id.subcategoria subcategoria "
					+ " left join subcategoria.categoria categoria   "
					+ " inner join imovel.localidade localidade   "
					+ " inner join localidade.gerenciaRegional gerenciaRegional "
					+ " inner join imovel.setorComercial setorComercial   "
					+ " left  join imovel.logradouroBairro logradouroBairro  "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " left  join bairro.municipio municipio   "
					+ " left  join imovel.logradouroBairro logradouroBairro "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " inner join imovel.quadra quadra   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.cep cep   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.logradouro logradouro   "
					+ " left  join imovel.imovelCondominio imovelCondominio   "
					+ " left  join imovel.imovelPrincipal imovelPrincipal   "
					// + " left join imovel.nomeConta nomeConta "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao " + " left  join imovel.ligacaoAgua ligacaoAgua  "
					+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  " + " left  join imovel.imovelPerfil imovelPerfil  "
					+ " left  join imovel.pocoTipo pocoTipo   " + " left  join imovel.faturamentoTipo faturamentoTipo "
					+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
					+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ " left  join imovel.eloAnormalidade eloAnormalidade   " + " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
					+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  " + " left  join imovel.consumoTarifa consumoTarifa   "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao " + " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left join imovel.consumosHistoricos consumosHistorico   "
					+ " left join imovel.medicaoHistoricos medicaoHistorico   " + " left join imovel.clienteImoveis clienteImoveis "
					+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo " + " left join clienteImoveis.cliente cliente "
					+ " left join cliente.clienteTipo clienteTipo " + " left join imovel.consumosHistoricos consumosHistorico ";

			consulta = consulta
					+ montarCondicaoWhereFiltrarImovelOutrosCriterioContarQuantidade(idImovelCondominio, idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal, intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial, intervaloMediaMinimaHidrometroFinal, idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo, idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa, idGerenciaRegional,
							idLocalidadeInicial, idLocalidadeFinal, setorComercialInicial, setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro, municipio, idTipoMedicao, indicadorMedicao, idSubCategoria,
							idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal, diaVencimento, idCliente, idClienteTipo,
							idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal, numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa);

			/*
			 * # COLOCANDO O VALOR NAS CONDIÇÕES#
			 */

			Query query = session.createQuery(consulta);

			informarDadosQueryFiltrarImovelOutrosCriterio(query, idImovelCondominio, idImovelPrincipal, idNomeConta, idSituacaoLigacaoAgua,
					consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto, consumoMinimoInicialEsgoto,
					consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial, intervaloValorPercentualEsgotoFinal,
					intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal, intervaloMediaMinimaHidrometroInicial,
					intervaloMediaMinimaHidrometroFinal, idImovelPerfil, idPocoTipo, idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
					idSituacaoEspecialCobranca, idEloAnormalidade, areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia,
					idConsumoTarifa, idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal, setorComercialInicial,
					setorComercialFinal, quadraInicial, quadraFinal, loteOrigem, loteDestno, cep, logradouro, bairro, municipio,
					idTipoMedicao, indicadorMedicao, idSubCategoria, idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal,
					diaVencimento, idCliente, idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal,
					numeroMoradoresInicial, numeroMoradoresFinal, idAreaConstruidaFaixa, null, null);

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Monta a condição do where
	 * 
	 * [UC0227] Gerar Relação de Débitos
	 * 
	 * @author Rafael Santos
	 * @param cpfCnpj
	 * @param indicadorCpfCnpj
	 * @date 12/06/2006
	 * 
	 */
	public String montarCondicaoWhereFiltrarImovelOutrosCriterio(String idImovelCondominio, String idImovelPrincipal, String idNomeConta,
			String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua, String idSituacaoLigacaoEsgoto,
			String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto, String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal, String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal, String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro, String municipio, String idTipoMedicao,
			String indicadorMedicao, String idSubCategoria, String idCategoria, String quantidadeEconomiasInicial,
			String quantidadeEconomiasFinal, String diaVencimento, String idCliente, String idClienteTipo, String idClienteRelacaoTipo,
			String numeroPontosInicial, String numeroPontosFinal, String numeroMoradoresInicial, String numeroMoradoresFinal,
			String idAreaConstruidaFaixa, String indicadorCpfCnpj, String cpfCnpj) {

		String consulta = "";
		/*
		 * ## CONDIÇÕES ##
		 */
		consulta = consulta + " where 1=1 ";

		// cliente
		if (idCliente != null && !idCliente.equals("")
				&& !idCliente.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and cliente.id = :idCliente  ";
		}

		// cliente tipo
		if (idClienteTipo != null && !idClienteTipo.equals("")
				&& !idClienteTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and clienteTipo.id = :idClienteTipo ";
		}

		// cliente relacao tipo
		if (idClienteRelacaoTipo != null && !idClienteRelacaoTipo.equals("")
				&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and clienteRelacaoTipo.id = :idClienteRelacaoTipo ";
		}

		if (indicadorCpfCnpj != null && indicadorCpfCnpj.equals("2")) {
			consulta = consulta + " and cliente.cpf is null and cliente.cnpj is null ";

		}

		if (cpfCnpj != null && !cpfCnpj.equals("")) {
			consulta = consulta + " and (cliente.cpf = :cpfCnpj or cliente.cnpj = :cpfCnpj) ";

			if (idClienteRelacaoTipo != null
					&& idClienteRelacaoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
				consulta = consulta + " and clienteRelacaoTipo.id = " + ClienteRelacaoTipo.USUARIO + " ";
			}

		}

		// gerencia regional
		if (idGerenciaRegional != null && !idGerenciaRegional.equals("")
				&& !idGerenciaRegional.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and gerenciaRegional.id = :idGerenciaRegional ";
		}
		// localidade inicial e final
		if (((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) && (idLocalidadeFinal != null
				&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())))) {
			consulta = consulta + " and localidade.id >= :idLocalidadeInicial and localidade.id <= :idLocalidadeFinal ";
		}
		// setor comercial inicial e final
		if (((setorComercialInicial != null && !setorComercialInicial.equals("") && !setorComercialInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) && (setorComercialFinal != null
				&& !setorComercialFinal.equals("") && !setorComercialFinal.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())))) {
			consulta = consulta + " and setorComercial.codigo >= :setorComercialInicial and setorComercial.codigo <= :setorComercialFinal ";
		}
		// quadra
		if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta + " and quadra.numeroQuadra >= :quadraInicial and quadra.numeroQuadra <= :quadraFinal ";
		}
		// lote
		if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (loteDestno != null && !loteDestno.equals("") && !loteDestno.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta + " and imovel.lote >= :loteOrigem  and  imovel.lote <= :loteDestino ";
		}

		// cep
		if (cep != null && !cep.equals("") && !cep.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and cep.codigo = :cep  ";
		}
		// logradouro
		if (logradouro != null && !logradouro.equals("")
				&& !logradouro.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and logradouro.id = :logradouro  ";
		}
		// bairro
		if (bairro != null && !bairro.equals("")
				&& !bairro.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and bairro.codigo = :bairro  ";
		}
		// municipio
		if (municipio != null && !municipio.equals("")
				&& !municipio.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and municipio.id = :municipio  ";
		}
		// consumo minimo agua inicial e final
		if ((consumoMinimoInicialAgua != null && !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (consumoMinimoFinalAgua != null && !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua.trim()
						.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta
					+ " and ligacaoAgua.numeroConsumoMinimoAgua >= :consumoMinimoInicialAgua and ligacaoAgua.numeroConsumoMinimoAgua <= :consumoMinimoFinalAgua  ";
		}
		// consumo minimo esgoto inicial e final
		if ((consumoMinimoInicialEsgoto != null && !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto.trim()
				.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (consumoMinimoFinalEsgoto != null && !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto.trim()
						.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta
					+ " and ligacaoEsgoto.consumoMinimo >= :consumoMinimoInicialEsgoto and ligacaoEsgoto.consumoMinimo <= :consumoMinimoFinalEsgoto ";
		}

		// percentual esgoto inicial e final
		if ((intervaloValorPercentualEsgotoInicial != null && !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
				.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (intervaloValorPercentualEsgotoFinal != null && !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
						.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {

			consulta = consulta
					+ " and ligacaoEsgoto.percentual >= :intervaloValorPercentualEsgotoInicial and ligacaoEsgoto.percentual <= :intervaloValorPercentualEsgotoFinal  ";
		}
		// indicador medição
		if (indicadorMedicao != null && indicadorMedicao.equals("comMedicao")) {
			// tipo medicao
			if (idTipoMedicao != null && idTipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA.toString())) {
				consulta = consulta + " and hidrometroInstalacaoHistorico.id is not null ";
			} else if (idTipoMedicao != null && idTipoMedicao.equals(MedicaoTipo.POCO.toString())) {
				consulta = consulta + " and hidrometroInstalacaoHistoricoImovel.id is not null ";
			} else {
				consulta = consulta + " and (hidrometroInstalacaoHistorico.id is not null or ";
				consulta = consulta + "hidrometroInstalacaoHistoricoImovel.id is not null)  ";
			}
		} else if (indicadorMedicao != null && indicadorMedicao.equals("semMedicao")) {
			consulta = consulta + " and (hidrometroInstalacaoHistorico.id is null and ";
			consulta = consulta + "hidrometroInstalacaoHistoricoImovel.id is null) ";
		}
		// imovel condominio
		if (idImovelCondominio != null && !idImovelCondominio.equals("")
				&& !idImovelCondominio.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and imovelCondominio.id = :idImovelCondominio  ";
		}
		// imovel principal
		if (idImovelPrincipal != null && !idImovelPrincipal.equals("")
				&& !idImovelPrincipal.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and imovelPrincipal.id = :idImovelPrincipal  ";
		}
		// nome conta

		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// consulta = consulta + " nomeConta.id = :idNomeConta and ";
		// }

		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// consulta = consulta + " nomeConta.id = :idNomeConta and ";
		// }

		// situação da ligação de agua
		if (idSituacaoLigacaoAgua != null && !idSituacaoLigacaoAgua.equals("")
				&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and ligacaoAguaSituacao.id = :idSituacaoLigacaoAgua  ";
		}
		// situação ligação de esgoto
		if (idSituacaoLigacaoEsgoto != null && !idSituacaoLigacaoEsgoto.equals("")
				&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and ligacaoEsgotoSituacao.id = :idSituacaoLigacaoEsgoto  ";
		}
		// imovel Perfil
		if (idImovelPerfil != null && !idImovelPerfil.equals("")
				&& !idImovelPerfil.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and imovelPerfil.id = :idImovelPerfil  ";
		}
		// poço tipo
		if (idPocoTipo != null && !idPocoTipo.equals("")
				&& !idPocoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and pocoTipo.id = :idPocoTipo ";
		}
		// faturamento situacao tipo
		if (idFaturamentoSituacaoTipo != null && !idFaturamentoSituacaoTipo.equals("")
				&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and faturamentoTipo.id = idFaturamentoSituacaoTipo ";
		}
		// cobranca situacao tipo
		if (idCobrancaSituacaoTipo != null && !idCobrancaSituacaoTipo.equals("")
				&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta
					// +
					// " and cobrancaSituacaoTipo.id = :idCobrancaSituacaoTipo ";
					+ " and imovelCobrancaSituacao.imovel.id = imovel.id and imovelCobrancaSituacao.cobrancaSituacao.id = :idCobrancaSituacaoTipo "
					+ " and imovelCobrancaSituacao.anoMesReferenciaFinal is null ";
		}
		// Situacao Especial Cobranca
		if (idSituacaoEspecialCobranca != null && !idSituacaoEspecialCobranca.equals("")
				&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and faturamentoSituacaoTipo.id = :idSituacaoEspecialCobranca ";
		}

		// elo anormalidade
		if (idEloAnormalidade != null && !idEloAnormalidade.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and eloAnormalidade.id = :idEloAnormalidade ";
		}
		// cadastro ocorrencia
		if (idCadastroOcorrencia != null && !idCadastroOcorrencia.equals("")
				&& !idCadastroOcorrencia.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and cadastroOcorrencia.id = :idCadastroOcorrencia ";
		}
		// area construida inicial e final
		if ((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (areaConstruidaFinal != null && !areaConstruidaFinal.equals("") && !areaConstruidaFinal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta
					+ " and imovel.areaConstruida >= :areaConstruidaInicial and imovel.areaConstruida <= :areaConstruidaFinal  ";
		}
		// consumo tarifa
		if (idConsumoTarifa != null && !idConsumoTarifa.equals("")
				&& !idConsumoTarifa.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and consumoTarifa.id = :idConsumoTarifa ";
		}
		// intervalo Media Minima Imovel Inicial e Final
		if ((intervaloMediaMinimaImovelInicial != null && !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
				.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (intervaloMediaMinimaImovelFinal != null && !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
						.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta
					+ " and consumosHistorico.consumoMedio >= :intervaloMediaMinimaImovelInicial and consumosHistorico.consumoMedio <= :intervaloMediaMinimaImovelFinal ";
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if ((intervaloMediaMinimaHidrometroInicial != null && !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
				.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (intervaloMediaMinimaHidrometroFinal != null && !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
						.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta
					+ " and medicaoHistorico.consumoMedioHidrometro >= :intervaloMediaMinimaHidrometroInicial and medicaoHistorico.consumoMedioHidrometro <= :intervaloMediaMinimaHidrometroFinal  ";
		}
		// categoria
		if (idCategoria != null && !idCategoria.equals("")
				&& !idCategoria.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and categoria.id = :idCategoria  ";
		}
		// sub categoria
		if (idSubCategoria != null && !idSubCategoria.equals("")
				&& !idSubCategoria.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and subCategoria.id = :idSubCategoria  ";
		}
		// quantidade economias inicial e final
		if ((quantidadeEconomiasInicial != null && !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial.trim()
				.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (quantidadeEconomiasFinal != null && !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal.trim()
						.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta
					+ " and imovelSubcategoria.quantidadeEconomias >= :quantidadeEconomiasInicial and imovelSubcategoria.quantidadeEconomias <= :quantidadeEconomiasFinal ";
		}

		// dia Vencimento
		if (diaVencimento != null && !diaVencimento.equals("")
				&& !diaVencimento.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			if (diaVencimento.equals("1")) {// sim
				consulta = consulta + " and imovel.diaVencimento  is not null  ";
			}
		}

		// numero prontos inicial e final
		if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta
					+ " and imove.numeroPontosUtilizacao >= :numeroPontosInicial and imovel.numeroPontosUtilizacao <= :numeroPontosFinal ";
		}

		// numero moradores inicial e final
		if ((numeroMoradoresInicial != null && !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (numeroMoradoresFinal != null && !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			consulta = consulta + " and imovel.numeroMorador >= :numeroMoradoresInicial and imovel.numeroMorador <= :numeroMoradoresFinal ";
		}
		// area construida faixa
		if (idAreaConstruidaFaixa != null && !idAreaConstruidaFaixa.equals("")
				&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			consulta = consulta + " and areaConstruidaFaixa.id = :idAreaConstruidaFaixa ";
		}

		return consulta;
	}

	/**
	 * 
	 * Seta os valores na condição do where
	 * 
	 * [UC0227] Gerar Relação de Débitos
	 * 
	 * @author Rafael Santos
	 * @param cpfCnpj
	 * @param indicadorCpfCnpj
	 * @date 12/06/2006
	 * 
	 */
	public void informarDadosQueryFiltrarImovelOutrosCriterio(Query query, String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial, String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal, String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil, String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca, String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia, String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal, String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem, String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao, String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal, String diaVencimento, String idCliente,
			String idClienteTipo, String idClienteRelacaoTipo, String numeroPontosInicial, String numeroPontosFinal,
			String numeroMoradoresInicial, String numeroMoradoresFinal, String idAreaConstruidaFaixa, String indicadorCpfCnpj,
			String cpfCnpj) {

		// gerencia regional
		if (idGerenciaRegional != null && !idGerenciaRegional.equals("")
				&& !idGerenciaRegional.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idGerenciaRegional", new Integer(idGerenciaRegional).intValue());
		}
		// localidade inicial e final
		if (((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) && (idLocalidadeFinal != null
				&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())))) {
			query.setInteger("idLocalidadeInicial", new Integer(idLocalidadeInicial).intValue());
			query.setInteger("idLocalidadeFinal", new Integer(idLocalidadeFinal).intValue());
		}
		// setor comercial inicial e final
		if (((setorComercialInicial != null && !setorComercialInicial.equals("") && !setorComercialInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) && (setorComercialFinal != null
				&& !setorComercialFinal.equals("") && !setorComercialFinal.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())))) {
			query.setInteger("setorComercialInicial", new Integer(setorComercialInicial).intValue());
			query.setInteger("setorComercialFinal", new Integer(setorComercialFinal).intValue());
		}
		// quadra inicial e final
		if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setInteger("quadraInicial", new Integer(quadraInicial).intValue());
			query.setInteger("quadraFinal", new Integer(quadraFinal).intValue());
		}
		// lote
		if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (loteDestno != null && !loteDestno.equals("") && !loteDestno.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setInteger("loteOrigem", new Integer(loteOrigem).intValue());
			query.setInteger("loteDestino", new Integer(loteDestno).intValue());
		}
		// cep
		if (cep != null && !cep.equals("") && !cep.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("cep", new Integer(cep).intValue());
		}
		// logradouro
		if (logradouro != null && !logradouro.equals("")
				&& !logradouro.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("logradouro", new Integer(logradouro).intValue());
		}
		// bairro
		if (bairro != null && !bairro.equals("")
				&& !bairro.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("bairro", new Integer(bairro).intValue());
		}
		// municipio
		if (municipio != null && !municipio.equals("")
				&& !municipio.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("municipio", new Integer(municipio).intValue());
		}
		// consumo minimo agua inicial e final
		if ((consumoMinimoInicialAgua != null && !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (consumoMinimoFinalAgua != null && !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua.trim()
						.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setInteger("consumoMinimoInicialAgua", new Integer(consumoMinimoInicialAgua).intValue());
			query.setInteger("consumoMinimoFinalAgua", new Integer(consumoMinimoFinalAgua).intValue());
		}
		// consumo minimo esgoto inicial e final
		if ((consumoMinimoInicialEsgoto != null && !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto.trim()
				.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (consumoMinimoFinalEsgoto != null && !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto.trim()
						.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setInteger("consumoMinimoInicialEsgoto", new Integer(consumoMinimoInicialEsgoto).intValue());
			query.setInteger("consumoMinimoFinalEsgoto", new Integer(consumoMinimoFinalEsgoto).intValue());
		}
		// percentual esgoto inicial e final
		if ((intervaloValorPercentualEsgotoInicial != null && !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
				.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (intervaloValorPercentualEsgotoFinal != null && !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
						.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setInteger("intervaloValorPercentualEsgotoInicial", new BigDecimal(intervaloValorPercentualEsgotoInicial).intValue());
			query.setInteger("intervaloValorPercentualEsgotoFinal", new BigDecimal(intervaloValorPercentualEsgotoFinal).intValue());
		}
		// imovel condominio
		if (idImovelCondominio != null && !idImovelCondominio.equals("")
				&& !idImovelCondominio.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idImovelCondominio", new Integer(idImovelCondominio).intValue());
		}
		// imovel principal
		if (idImovelPrincipal != null && !idImovelPrincipal.equals("")
				&& !idImovelPrincipal.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idImovelPrincipal", new Integer(idImovelPrincipal).intValue());
		}

		// nome conta
		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// query
		// .setInteger("idNomeConta", new Integer(idNomeConta)
		// .intValue());
		// }
		// Situacao Ligacao Agua
		if (idSituacaoLigacaoAgua != null && !idSituacaoLigacaoAgua.equals("")
				&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idSituacaoLigacaoAgua", new Integer(idSituacaoLigacaoAgua).intValue());
		}

		// situação ligação de esgoto
		if (idSituacaoLigacaoEsgoto != null && !idSituacaoLigacaoEsgoto.equals("")
				&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idSituacaoLigacaoEsgoto", new Integer(idSituacaoLigacaoEsgoto).intValue());
		}
		// imovel Perfil
		if (idImovelPerfil != null && !idImovelPerfil.equals("")
				&& !idImovelPerfil.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idImovelPerfil", new Integer(idImovelPerfil).intValue());
		}
		// poço tipo
		if (idPocoTipo != null && !idPocoTipo.equals("")
				&& !idPocoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idPocoTipo", new Integer(idPocoTipo).intValue());
		}
		// faturamento situacao tipo
		if (idFaturamentoSituacaoTipo != null && !idFaturamentoSituacaoTipo.equals("")
				&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idFaturamentoSituacaoTipo", new Integer(idFaturamentoSituacaoTipo).intValue());
		}
		// cobranca situacao tipo
		if (idCobrancaSituacaoTipo != null && !idCobrancaSituacaoTipo.equals("")
				&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idCobrancaSituacaoTipo", new Integer(idCobrancaSituacaoTipo).intValue());
		}
		// Situacao Especial Cobranca
		if (idSituacaoEspecialCobranca != null && !idSituacaoEspecialCobranca.equals("")
				&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idSituacaoEspecialCobranca", new Integer(idSituacaoEspecialCobranca).intValue());
		}
		// elo anormalidade
		if (idEloAnormalidade != null && !idEloAnormalidade.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idEloAnormalidade", new Integer(idEloAnormalidade).intValue());
		}
		// cadastro ocorrencia
		if (idCadastroOcorrencia != null && !idCadastroOcorrencia.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idCadastroOcorrencia", new Integer(idCadastroOcorrencia).intValue());
		}
		// area construida inicial e final
		if ((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (areaConstruidaFinal != null && !areaConstruidaFinal.equals("") && !areaConstruidaFinal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setBigDecimal("areaConstruidaInicial", Util.formatarMoedaRealparaBigDecimal(areaConstruidaInicial));
			query.setBigDecimal("areaConstruidaFinal", Util.formatarMoedaRealparaBigDecimal(areaConstruidaFinal));
		}
		// consumo tarifa
		if (idConsumoTarifa != null && !idConsumoTarifa.equals("")
				&& !idConsumoTarifa.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idConsumoTarifa", new Integer(idConsumoTarifa).intValue());
		}
		// intervalo Media Minima Imovel Inicial e Final
		if ((intervaloMediaMinimaImovelInicial != null && !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
				.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (intervaloMediaMinimaImovelFinal != null && !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
						.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setInteger("intervaloMediaMinimaImovelInicial", new Integer(intervaloMediaMinimaImovelInicial).intValue());
			query.setInteger("intervaloMediaMinimaImovelFinal", new Integer(intervaloMediaMinimaImovelFinal).intValue());
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if ((intervaloMediaMinimaHidrometroInicial != null && !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
				.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (intervaloMediaMinimaHidrometroFinal != null && !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
						.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setInteger("intervaloMediaMinimaHidrometroInicial", new Integer(intervaloMediaMinimaHidrometroInicial).intValue());
			query.setInteger("intervaloMediaMinimaHidrometroFinal", new Integer(intervaloMediaMinimaHidrometroFinal).intValue());
		}

		// quantidade economias inicial e final
		if ((quantidadeEconomiasInicial != null && !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial.trim()
				.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (quantidadeEconomiasFinal != null && !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal.trim()
						.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setShort("quantidadeEconomiasInicial", new Short(quantidadeEconomiasInicial).shortValue());
			query.setShort("quantidadeEconomiasFinal", new Short(quantidadeEconomiasFinal).shortValue());
		}

		// categoria
		if (idCategoria != null && !idCategoria.equals("")
				&& !idCategoria.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idCategoria", new Integer(idCategoria).intValue());
		}

		// sub categoria
		if (idSubCategoria != null && !idSubCategoria.equals("")
				&& !idSubCategoria.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idSubCategoria", new Integer(idSubCategoria).intValue());
		}

		// numero prontos inicial e final
		if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setShort("numeroPontosInicial", new Short(numeroPontosInicial).shortValue());
			query.setShort("numeroPontosFinal", new Short(numeroPontosFinal).shortValue());
		}

		// numero moradores inicial e final
		if ((numeroMoradoresInicial != null && !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial.trim().equalsIgnoreCase(
				new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
				&& (numeroMoradoresFinal != null && !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {
			query.setShort("numeroMoradoresInicial", new Short(numeroMoradoresInicial).shortValue());
			query.setShort("numeroMoradoresFinal", new Short(numeroMoradoresFinal).shortValue());
		}
		// area construida faixa
		if (idAreaConstruidaFaixa != null && !idAreaConstruidaFaixa.equals("")
				&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idAreaConstruidaFaixa", new Integer(idAreaConstruidaFaixa).intValue());
		}

		// cliente
		if (idCliente != null && !idCliente.equals("")
				&& !idCliente.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idCliente", new Integer(idCliente).intValue());
		}

		// cliente tipo
		if (idClienteTipo != null && !idClienteTipo.equals("")
				&& !idClienteTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idClienteTipo", new Integer(idClienteTipo).intValue());
		}

		// cliente relacao tipo
		if (idClienteRelacaoTipo != null && !idClienteRelacaoTipo.equals("")
				&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
			query.setInteger("idClienteRelacaoTipo", new Integer(idClienteRelacaoTipo).intValue());
		}

		if (cpfCnpj != null && !cpfCnpj.equals("")) {
			query.setString("cpfCnpj", cpfCnpj);
		}
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Raphael Rossiter
	 * @data 26/05/2006
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitir(Integer idCobrancaAcaoCronograma,
			Integer idCobrancaAcaoComando, Date dataEmissao, Integer idCobrancaAcao, int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "LEFT JOIN fetch cbdo.empresa as empr "
					+ "LEFT JOIN fetch cbdo.localidade as loca " + "LEFT JOIN fetch cbdo.imovel as imov "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro " + "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun " + "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep " + "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo " + "LEFT JOIN fetch log.logradouroTitulo " + "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia " + "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao " + "LEFT JOIN fetch cbdo.quadra qdr " + "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo " + "LEFT JOIN fetch cbdo.imovelPerfil " + "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional " + "LEFT JOIN fetch imov.ligacaoAgua.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN fetch hih.hidrometro " + "LEFT JOIN fetch hih.hidrometroLocalInstalacao " + "WHERE ";

			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando;
			}

			consulta = consulta + " AND cbdo.emissao >= :dataEmissao AND " + " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, " + "imov.lote, imov.subLote, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCorteAdministrativoOUFisico", idCobrancaAcao).setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio).setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Rafael Corrêa
	 * @data 02/09/2009
	 * 
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaRelatorio(Integer idCobrancaAcaoCronograma,
			Integer idCobrancaAcaoComando) throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "INNER JOIN FETCH cbdo.imovel imov "
					+ "INNER JOIN FETCH imov.quadra qdra " + "INNER JOIN FETCH qdra.rota rota " + "INNER JOIN FETCH rota.cobrancaGrupo "
					+ "INNER JOIN FETCH rota.faturamentoGrupo " + "INNER JOIN FETCH cbdo.ligacaoAguaSituacao "
					+ "INNER JOIN FETCH cbdo.ligacaoEsgotoSituacao " + "INNER JOIN FETCH cbdo.cobrancaAcao " + "WHERE ";

			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma;
			} else if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando;
			}

			consulta = consulta + " ORDER BY cbdo.localidade.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ "imov.lote, imov.subLote, cbdo.id";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), rota (ROTA_ID), sequencial da rota
	 * (IMOV_NNSEQUENCIALROTA)e cobranca documento (CBDO_ID)
	 * 
	 * @author Raphael Rossiter
	 * @data 27/06/2007
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	@SuppressWarnings("unchecked")
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitirPorRota(Integer idCobrancaAcaoCronograma,
			Integer idCobrancaAcaoComando, Date dataEmissao, Integer idCobrancaAcao, int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "LEFT JOIN fetch cbdo.empresa as empr "
					+ "LEFT JOIN fetch cbdo.localidade as loca " + "LEFT JOIN fetch cbdo.imovel as imov "
					+ "LEFT JOIN fetch imov.perimetroInicial periInicial " + "LEFT JOIN fetch periInicial.logradouroTipo "
					+ "LEFT JOIN fetch periInicial.logradouroTitulo " + "LEFT JOIN fetch imov.perimetroFinal periFinal "
					+ "LEFT JOIN fetch periFinal.logradouroTipo " + "LEFT JOIN fetch periFinal.logradouroTitulo "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro " + "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun " + "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep " + "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo " + "LEFT JOIN fetch log.logradouroTitulo " + "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia " + "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao " + "LEFT JOIN fetch cbdo.quadra qdr " + "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo " + "LEFT JOIN fetch cbdo.imovelPerfil " + "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional " + "WHERE ";

			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando;
			}
			consulta = consulta + " AND cbdo.emissao = :dataEmissao AND " + " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, rot.codigo, " + "imov.numeroSequencialRota, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCorteAdministrativoOUFisico", idCobrancaAcao).setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio).setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a conta e
	 * ordenar por ano/mês de referência da conta
	 * 
	 * @author Raphael Rossiter
	 * @data 26/05/2006
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteConta(CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit " + "FROM CobrancaDocumentoItem as cdit " + "LEFT JOIN fetch cdit.contaGeral cntaGeral "
					+ "LEFT JOIN fetch cntaGeral.conta  cnta " + "LEFT JOIN fetch cnta.debitoCreditoSituacaoAtual "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "cnta.id IS NOT NULL ORDER BY cdit.contaGeral.conta.referencia";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] Emitir Aviso de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a guia
	 * pagamento
	 * 
	 * @author Sávio Luiz
	 * @data 09/04/2007
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public Collection<Object[]> selecionarDadosCobrancaDocumentoItemReferenteGuiaPagamento(CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit.valorItemCobrado,cdit.valorAcrescimos " + "FROM CobrancaDocumentoItem as cdit "
					+ "LEFT JOIN cdit.guiaPagamentoGeral guia " + "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "guia.id IS NOT NULL ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o count do resultado da pesquisa de Cobranca Cronograma
	 * 
	 * pesquisarCobrancaCronogramaCount
	 * 
	 * @author Flávio Cordeiro
	 * @date 14/06/2006
	 * 
	 * @return Integer retorno
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarCobrancaCronogramaCount(Filtro filtro) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		// String consulta = null;

		try {
			filtro.limparCamposOrderBy();
			// filtro.adicionarCaminhoParaCarregamentoEntidade("cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes");
			retorno = (Integer) GeradorHQLCondicional.gerarCondicionalQuery(
					filtro,
					"objeto",
					"select count(distinct objeto.cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id) "
							+ "	from gcom.cobranca.CobrancaAcaoAtividadeCronograma as objeto ", session).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void removerCobrancaCronograma(Integer idGrupoCronogramaMes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String remover = null;
		try {
			remover = "delete CobrancaAcaoAtividadeCronograma objeto"
					+ "	where objeto.cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id =" + idGrupoCronogramaMes;

			session.createQuery(remover).executeUpdate();

			remover = "delete CobrancaAcaoCronograma objeto " + "	where objeto.cobrancaGrupoCronogramaMes.id = " + idGrupoCronogramaMes;

			session.createQuery(remover).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * 
	 * Consultar Relação de Debitos do Imovel Consulta o Consumo Medio do Imovel
	 * 
	 * [UC0227] - Gerar Relção de Débitos
	 * 
	 * @author Rafael Santos
	 * @date 15/06/2006
	 * 
	 * @param imovelId
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarConsumoMedioConsumoHistoricoImovel(Integer imovelId) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select consumoHistorico.consumoMedio " + "from ConsumoHistorico consumoHistorico "
					+ "inner join consumoHistorico.imovel imovel " + "inner join consumoHistorico.ligacaoTipo   ligacaoTipo "
					+ "where imovel.id = :imovelId " + "and ligacaoTipo.id = :ligacaoTipo and consumoHistorico.referenciaFaturamento = ( "
					+ "select max(consumoHistorico2.referenciaFaturamento) " + "from ConsumoHistorico consumoHistorico2 "
					+ "inner join consumoHistorico2.imovel imovel2 " + "inner join consumoHistorico2.ligacaoTipo ligacaoTipo2 "
					+ "where imovel2.id = :imovelId and ligacaoTipo2.id = :ligacaoTipo) ";

			Object resultado = session.createQuery(consulta).setInteger("imovelId", imovelId.intValue())
					.setInteger("ligacaoTipo", LigacaoTipo.LIGACAO_AGUA.intValue()).uniqueResult();

			if (resultado != null) {
				retorno = (Integer) resultado;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Monta a condição do where
	 * 
	 * [UC0227] Gerar Relação de Débitos
	 * 
	 * @author Rafael Santos
	 * @date 12/06/2006
	 * 
	 */
	public String montarCondicaoWhereFiltrarImovelOutrosCriterioContarQuantidade(String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial, String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal, String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil, String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca, String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia, String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal, String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem, String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao, String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal, String diaVencimento, String idCliente,
			String idClienteTipo, String idClienteRelacaoTipo, String numeroPontosInicial, String numeroPontosFinal,
			String numeroMoradoresInicial, String numeroMoradoresFinal, String idAreaConstruidaFaixa) {

		String consulta = "";
		consulta = consulta
				+ montarCondicaoWhereFiltrarImovelOutrosCriterio(idImovelCondominio, idImovelPrincipal, idNomeConta, idSituacaoLigacaoAgua,
						consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto, consumoMinimoInicialEsgoto,
						consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial, intervaloValorPercentualEsgotoFinal,
						intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal, intervaloMediaMinimaHidrometroInicial,
						intervaloMediaMinimaHidrometroFinal, idImovelPerfil, idPocoTipo, idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
						idSituacaoEspecialCobranca, idEloAnormalidade, areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia,
						idConsumoTarifa, idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal, setorComercialInicial,
						setorComercialFinal, quadraInicial, quadraFinal, loteOrigem, loteDestno, cep, logradouro, bairro, municipio,
						idTipoMedicao, indicadorMedicao, idSubCategoria, idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal,
						diaVencimento, idCliente, idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal,
						numeroMoradoresInicial, numeroMoradoresFinal, idAreaConstruidaFaixa, null, null);

		consulta = consulta.substring(0, (consulta.length() - 5));

		consulta = consulta + " ";

		return consulta;
	}

	/**
	 * Gerar Relatório de Critério de Cobrança
	 * 
	 * Pesquisa as linhas de critério de cobrança através do id do critério de
	 * cobrança
	 * 
	 * @author Rafael Corrêa
	 * @data 09/08/2006
	 */
	public Collection pesquisarCobrancaCriterioLinha(Integer idCriterioCobranca) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT " + "imovelPerfil.descricao, " + "categoria.descricao, " + "ccl.valorMinimoDebito, "
					+ "ccl.valorMaximoDebito, " + "ccl.quantidadeMinimaContas, " + "ccl.quantidadeMaximaContas, "
					+ "ccl.valorMinimoContaMes, " + "ccl.valorMinimoDebitoDebitoAutomatico, "
					+ "ccl.quantidadeMinimaContasDebitoAutomatico " + "FROM CobrancaCriterioLinha as ccl "
					+ "inner join ccl.imovelPerfil imovelPerfil " + "inner join ccl.categoria categoria "
					+ "WHERE ccl.cobrancaCriterio.id = :idCriterioCobranca " + "order by imovelPerfil.id, categoria.id";

			retorno = session.createQuery(consulta).setInteger("idCriterioCobranca", idCriterioCobranca).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relatório de Perfil de Parcelamento
	 * 
	 * Pesquisa os Parcelamentos Desconto Antiguidade através do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @data 22/08/2006
	 */
	public Collection pesquisarParcelamentoDescontoAntiguidade(Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "SELECT antiguidade.id, " + "antiguidade.quantidadeMinimaMesesDebito, "
					+ "antiguidade.percentualDescontoSemRestabelecimento, " + "antiguidade.percentualDescontoComRestabelecimento, "
					+ "antiguidade.percentualDescontoAtivo " + "FROM ParcelamentoDescontoAntiguidade as antiguidade "
					+ "INNER JOIN antiguidade.parcelamentoPerfil perfil " + "WHERE perfil.id = :idParcelamentoPerfil "
					+ "ORDER BY antiguidade.quantidadeMinimaMesesDebito";

			retorno = session.createQuery(consulta).setInteger("idParcelamentoPerfil", idParcelamentoPerfil).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relatório de Perfil de Parcelamento
	 * 
	 * Pesquisa os Parcelamentos Desconto Inatividade através do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @data 22/08/2006
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarParcelamentoDescontoInatividade(Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "SELECT inatividade.id, " + "inatividade.quantidadeMaximaMesesInatividade, "
					+ "inatividade.percentualDescontoSemRestabelecimento, " + "inatividade.percentualDescontoComRestabelecimento "
					+ "FROM ParcelamentoDescontoInatividade as inatividade " + "INNER JOIN inatividade.parcelamentoPerfil perfil "
					+ "WHERE perfil.id = :idParcelamentoPerfil " + " ORDER BY inatividade.quantidadeMaximaMesesInatividade";

			retorno = session.createQuery(consulta).setInteger("idParcelamentoPerfil", idParcelamentoPerfil).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relatório de Perfil de Parcelamento
	 * 
	 * Pesquisa os Reparcelamentos Consecutivos através do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @data 22/08/2006
	 */
	public Collection pesquisarReparcelamentoConsecutivo(Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT reparcelamento.id, " + "reparcelamento.quantidadeMaximaReparcelamento, "
					+ "prestacao.id, prestacao.quantidadeMaximaPrestacao, " + "prestacao.taxaJuros, prestacao.percentualMinimoEntrada "
					+ "FROM ParcelamentoQuantidadePrestacao as prestacao "
					+ "INNER JOIN prestacao.parcelamentoQuantidadeReparcelamento reparcelamento "
					+ "INNER JOIN reparcelamento.parcelamentoPerfil perfil " + "WHERE perfil.id = :idParcelamentoPerfil "
					+ "ORDER BY reparcelamento.quantidadeMaximaReparcelamento, " + "prestacao.quantidadeMaximaPrestacao";

			retorno = session.createQuery(consulta).setInteger("idParcelamentoPerfil", idParcelamentoPerfil).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite iniciar processos batch de faturamento ou
	 * cobrança previdamento comandados e processos mensais ou eventuais
	 * 
	 * [UC0001] - Iniciar Processo
	 * 
	 * Este subfluxo inicia os processo batch de cobrança do sistema
	 * 
	 * [SB0002] - Iniciar Process de Cobrança Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("unchecked")
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarCobrancaAcaoAtividadeCronogramaComandadosNaoRealizados()
			throws ErroRepositorioException {

		Collection<CobrancaAcaoAtividadeCronograma> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "FROM CobrancaAcaoAtividadeCronograma as cob "
					+ " left join fetch cob.cobrancaAcaoCronograma cobAcaoCron "
					+ " left join fetch cobAcaoCron.cobrancaGrupoCronogramaMes cobGrupoCronoMes"
					+ " left join fetch cobAcaoCron.cobrancaAcao cobAcao"
					+ " left join fetch cob.cobrancaAtividade cobAtiv"
					+ " left join fetch cobGrupoCronoMes.cobrancaGrupo cobGrup"
					+ " WHERE cob.comando is not null and (cobAtiv.id = :cobrancaAtividadeEmitir or cobAtiv.id = :cobrancaAtividadeSimular or cobAtiv.id = :cobrancaAtividadeEncerrarOS) and (cob.realizacao is null and cob.dataPrevista <=  :dataAtual) "
					+ " order by cobGrupoCronoMes.anoMesReferencia, cobGrupoCronoMes.cobrancaGrupo.descricao, cobAcao.ordemRealizacao"; // or
			// cob.realizacao
			// <
			// cob.comando
			// cobAtiv.id = :cobrancaAtividade and
			// 'A
			// pedido
			// de
			// Ana
			// Breda'

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("cobrancaAtividadeEmitir", CobrancaAtividade.EMITIR)
					.setInteger("cobrancaAtividadeSimular", CobrancaAtividade.SIMULAR)
					.setInteger("cobrancaAtividadeEncerrarOS", CobrancaAtividade.ENCERRAR_OS).setTimestamp("dataAtual", new Date()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite iniciar processos batch de faturamento ou
	 * cobrança previdamento comandados e processos mensais ou eventuais
	 * 
	 * [UC0001] - Iniciar Processo
	 * 
	 * Este subfluxo inicia os processo batch de cobrança do sistema
	 * 
	 * [SB0002] - Iniciar Process de Cobrança Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaAcaoAtividadeComando> pesquisarCobrancaAcaoAtividadeCronogramaEventuaisComandadosNaoRealizados()
			throws ErroRepositorioException {

		Collection<CobrancaAcaoAtividadeComando> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "FROM CobrancaAcaoAtividadeComando as cob "
					+ "left join fetch cob.cobrancaAtividade cobAtiv "

					+ "left join fetch cob.cobrancaAcao cobAcao "
					+ "left join fetch cob.usuario "
					+ "WHERE cob.comando is not null and (cobAtiv.id = :cobrancaAtividadeEmitir or cobAtiv.id = :cobrancaAtividadeSimular or cobAtiv.id = :cobrancaAtividadeEncerrarOS) and (cob.realizacao is null ) "
					+ " ORDER BY cob.comando";
			// + " order by cob.anoMesReferenciaContaInicial,
			// cob.cobrancaGrupo.descricao, cobAcao.ordemRealizacao"; // or;*/
			// //
			// or
			// cob.realizacao
			// <
			// cob.comando

			retorno = session.createQuery(consulta).setInteger("cobrancaAtividadeEmitir", CobrancaAtividade.EMITIR)
					.setInteger("cobrancaAtividadeSimular", CobrancaAtividade.SIMULAR)
					.setInteger("cobrancaAtividadeEncerrarOS", CobrancaAtividade.ENCERRAR_OS).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0476] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Ana Maria
	 * @data 07/09/2006
	 * 
	 * @param Collection
	 *            <CobrancaDocumento>
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<EmitirDocumentoCobrancaHelper> pesquisarCobrancaDocumentoOrdemCorte(Integer idCobrancaAcaoCronograma,
			Integer idCobrancaAcaoComando, Date dataEmissao, Integer idCobrancaAcao, int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new " + EmitirDocumentoCobrancaHelper.class.getName() + " (cbdo.id, loca.id, loca.descricao, "
					+ " cbdo.codigoSetorComercial,cbdo.numeroQuadra," + " imov.lote, imov.subLote," + " imov.id, cbac.numeroDiasValidade,"
					+ " orse.id," + " iper.descricao, cbdo.emissao," + " rota.cobrancaGrupo.id, cbdo.valorDocumento,"
					+ " empr.id, empr.descricao," + " greg.nomeAbreviado, greg.nome," + " last.id, lest.id,"
					+ " greg.id, imov.ultimaAlteracao," + " last.descricao, lest.descricao,"
					+ " ltan.id, ltan.descricao, cbdo.dataEmissaoPredecessor,"
					+ " cbdo.numeroSequenciaDocumento, cbac.numeroDiasVencimento," + " rota.codigo, imov.numeroSequencialRota)"
					+ " from OrdemServico as orse " + " left join orse.cobrancaDocumento as cbdo " + " left join cbdo.empresa as empr"
					+ " left join cbdo.localidade as loca" + " left join cbdo.imovel as imov" + " left join imov.ligacaoAguaSituacao last"
					+ " left join imov.ligacaoEsgotoSituacao lest" + " left join imov.leituraAnormalidade ltan"
					+ " left join cbdo.cobrancaAcao as cbac" + " left join cbdo.imovelPerfil as iper" + " left join cbdo.quadra as qdra"
					+ " left join qdra.rota as rota" + " left join loca.gerenciaRegional greg" + " where ";
			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando;
			}
			consulta = consulta
					// + " AND cbdo.emissao = :dataEmissao "
					+ " AND cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ " order by empr.id,greg.id ,loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ " imov.lote, imov.subLote,cbdo.id";

			retorno = session.createQuery(consulta).setInteger("idAvisoCorte", idCobrancaAcao)
			// .setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio).setMaxResults(1000).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0476] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), rota (ROTA_ID), sequencial da rota
	 * (IMOV_NNSEQUENCIALROTA)e cobranca documento (CBDO_ID)
	 * 
	 * @author Raphael Rossiter
	 * @data 07/08/2007
	 * 
	 * @return Collection<EmitirDocumentoCobrancaHelper>
	 */
	public Collection<EmitirDocumentoCobrancaHelper> pesquisarCobrancaDocumentoOrdemCortePorRota(Integer idCobrancaAcaoCronograma,
			Integer idCobrancaAcaoComando, Date dataEmissao, Integer idCobrancaAcao, int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new " + EmitirDocumentoCobrancaHelper.class.getName() + " (cbdo.id, loca.id, loca.descricao, "
					+ " cbdo.codigoSetorComercial,cbdo.numeroQuadra," + " imov.lote, imov.subLote," + " imov.id, cbac.numeroDiasValidade,"
					+ " orse.id," + " iper.descricao, cbdo.emissao," + " rota.cobrancaGrupo.id, cbdo.valorDocumento,"
					+ " empr.id, empr.descricao," + " greg.nomeAbreviado, greg.nome," + " last.id, lest.id,"
					+ " greg.id, imov.ultimaAlteracao," + " last.descricao, lest.descricao,"
					+ " ltan.id, ltan.descricao, rota.codigo, imov.numeroSequencialRota)" + " from OrdemServico as orse "
					+ " left join orse.cobrancaDocumento as cbdo " + " left join cbdo.empresa as empr"
					+ " left join cbdo.localidade as loca" + " left join cbdo.imovel as imov" + " left join imov.ligacaoAguaSituacao last"
					+ " left join imov.ligacaoEsgotoSituacao lest" + " left join imov.leituraAnormalidade ltan"
					+ " left join cbdo.cobrancaAcao as cbac" + " left join cbdo.imovelPerfil as iper" + " left join cbdo.quadra as qdra"
					+ " left join qdra.rota as rota" + " left join loca.gerenciaRegional greg" + " where ";
			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando;
			}
			consulta = consulta + " AND cbdo.emissao = :dataEmissao AND " + "cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, rota.codigo, " + "imov.numeroSequencialRota, cbdo.id";

			retorno = session.createQuery(consulta).setInteger("idAvisoCorte", idCobrancaAcao).setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio).setMaxResults(1000).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0582] Emitir Boletim de Cadastro
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Rafael Corrêa
	 * @data 16/05/2007
	 * 
	 * @param Collection
	 *            <CobrancaDocumento>
	 * @return Collection<CobrancaDocumento>
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Collection<EmitirDocumentoCobrancaBoletimCadastroHelper> pesquisarCobrancaDocumentoBoletimCadastro(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando, Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new "
					+ EmitirDocumentoCobrancaBoletimCadastroHelper.class.getName()
					+ " (cbdo.id, loca.id, " // 0, 1
					+ " cbdo.codigoSetorComercial, cbdo.numeroQuadra," // 2, 3
					+ " imov.lote, imov.subLote," // 4, 5
					+ " imov.id, rota.cobrancaGrupo.id, " // 6, 7
					+ " last.id, lest.id," // 8, 9
					+ " imov.numeroMorador, imov.areaConstruida, logr.id, " // 10,11,12
					+ " cep.codigo, bairro.codigo, imov.enderecoReferencia.id, imov.numeroImovel, " // 13,14
																									// ,15,16
					+ " imov.complementoEndereco, imov.reservatorioVolumeFaixaInferior.id, " // 17,18
					+ " imov.reservatorioVolumeFaixaSuperior.id, imov.piscinaVolumeFaixa.id, " // 19,20
					+ " imov.indicadorJardim, imov.pavimentoRua.id, imov.pavimentoCalcada.id, " // 21,22,23
					+ " imov.numeroPontosUtilizacao, imov.imovelPerfil.id, imov.despejo.id, " // 24,25,26
					+ " imov.pocoTipo.id, imov.fonteAbastecimento.id, imov.numeroIptu, imov.numeroCelpe,"// 27,28,29,30
					+ " rota.codigo,imov.numeroSequencialRota)" // 31,32
					+ " from OrdemServico as orse " + " inner join orse.cobrancaDocumento as cbdo " + " inner join cbdo.localidade as loca"
					+ " inner join cbdo.imovel as imov" + " inner join imov.quadra qdrImovel " + " inner join qdrImovel.rota rota "
					+ " inner join rota.empresaCobranca empreCobranca " + " inner join cbdo.imovelPerfil as iper"
					+ " inner join loca.gerenciaRegional greg" + " left join cbdo.empresa as empr"
					+ " left join imov.ligacaoAguaSituacao last" + " left join imov.ligacaoEsgotoSituacao lest"
					+ " left join imov.leituraAnormalidade ltan" + " left join imov.logradouroCep as logrCep"
					+ " left join logrCep.logradouro as logr" + " left join logrCep.cep as cep"
					+ " left join imov.logradouroBairro as logrBairro" + " left join logrBairro.bairro as bairro"
					+ " left join cbdo.cobrancaAcao as cbac" + " left join cbdo.quadra as qdra" + " left join qdra.rota as rota"
					+ " where ";

			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {

				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma
						+ " AND empreCobranca.indicadorEmpresaPrincipal <> " + Empresa.INDICADOR_EMPRESA_PRINCIPAL + " AND ";
			}
			if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + " cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando + " AND ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);
			consulta = consulta + " AND cbdo.emissao = :dataEmissao AND " + " cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ " order by empr.id,greg.id ,loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ " imov.lote, imov.subLote,cbdo.id";

			retorno = session.createQuery(consulta).setInteger("idAvisoCorte", idCobrancaAcao).setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio).setMaxResults(500).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta os
	 * documentos de cobrança do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection consultarImovelDocumentosCobranca(Integer idImovel, Integer numeroPagina) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT distinct cobrancaAcao.descricaoCobrancaAcao, "
					+ // 0
					"cobrancaDocumento.emissao,"
					+ // 1
					"documentoEmissaoForma.descricaoDocumentoEmissaoForma,"
					+ // 2
					"documentoTipo.descricaoDocumentoTipo,"
					+ // 3
					"cobrancaDocumento.valorDocumento,"
					+ // 4
					"cobrancaDocumento.id "
					+ // 5
					"FROM CobrancaDocumento as cobrancaDocumento " + "left JOIN cobrancaDocumento.cobrancaAcao cobrancaAcao "
					+ "left JOIN cobrancaDocumento.documentoEmissaoForma documentoEmissaoForma "
					+ "left JOIN cobrancaDocumento.documentoTipo documentoTipo " + "where cobrancaDocumento.imovel.id = :idImovel ";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta a
	 * quantidade de documentos de cobrança do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQuantidadeImovelDocumentosCobranca(Integer idImovel) throws ErroRepositorioException {
		Integer retorno = null;
		Object resultadoConsulta = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT count(distinct cobrancaDocumento.id) "
					+ // 0
					"FROM CobrancaDocumento as cobrancaDocumento "
					+ "where cobrancaDocumento.imovel.id = :idImovel and cobrancaDocumento.imovel.indicadorExclusao != 1 ";

			resultadoConsulta = session.createQuery(consulta).setInteger("idImovel", idImovel.intValue()).uniqueResult();

			if (resultadoConsulta != null) {
				retorno = (Integer) resultadoConsulta;
			} else {
				retorno = new Integer(0);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta a
	 * quantidade de documentos de itens de cobrança do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQuantidadeImovelDocumentosItemCobranca(Integer idCobrancaDocumento) throws ErroRepositorioException {
		Integer retorno = null;
		Object resultadoConsulta = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT count(distinct cobrancaDocumentoItem.id) "
					+ // 0
					"FROM CobrancaDocumentoItem as cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.cobrancaDocumento.id = :idCobrancaDocumento";

			resultadoConsulta = session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento.intValue())
					.uniqueResult();

			if (resultadoConsulta != null) {
				retorno = (Integer) resultadoConsulta;
			} else {
				retorno = new Integer(0);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados do parcelamento necessários para o relatório através do
	 * id do parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @date 25/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarParcelamentoRelatorio(Integer idParcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select imov.id, "
					+ // 0
					"imov.logradouroBairro.bairro.municipio.nome, "
					+ // 1
					"parc.parcelamento,"
					+ // 2
					" parc.valorConta, "
					+ // 3
					"parc.valorServicosACobrar, "
					+ // 4
					"parc.valorAtualizacaoMonetaria, "
					+ // 5
					"parc.valorJurosMora, "
					+ // 6
					"parc.valorMulta, "
					+ // 7
					"parc.valorGuiaPapagamento, "
					+ // 8
					"parc.valorParcelamentosACobrar, "
					+ // 9
					"parc.valorDescontoAcrescimos, "
					+ // 10
					"parc.valorDescontoAntiguidade, "
					+ // 11
					"parc.valorDescontoInatividade, "
					+ // 12
					"parc.valorCreditoARealizar, "
					+ // 13
					"parc.valorDebitoAtualizado, "
					+ // 14
					"parc.valorEntrada, "
					+ // 15
					"parc.numeroPrestacoes, "
					+ // 16
					"parc.valorPrestacao, "
					+ // 17
					"parc.indicadorRestabelecimento, "
					+ // 18
					"parc.funcionario.id, "
					+ // 19
					"clie.nome, "
					+ // 20
					"clie.cpf, "
					+ // 21
					"clie.cnpj, "
					+ // 22
					"parc.taxaJuros, "
					+ // 23
					"parc.valorDescontoSancao, "
					+ // 24
					"parc.valorDescontoTarifaSocial, "
					+ // 25
					"func.id, "
					+ // 26
					"cliDir.nome, "
					+ // 27
					"cliDir.cpf, "
					+ // 28
					"prof.descricao, "
					+ // 29
					"ct.indicadorPessoaFisicaJuridica, "
					+ // 30
					"devedor.nome, "
					+ // 31
					"devedor.cnpj, "
					+ // 32
					"devedor.id, "
					+ // 33
					"usur.nomeUsuario, "
					+ // 34
					"parc.anoMesReferenciaFaturamento, "
					+ // 35
					"imov.logradouroBairro.bairro.nome, "
					+ // 36
					"imov.quadra.rota.codigo, "
					+ // 37
					"localidade.descricao, "
					+ // 38
					"setor.codigo, " // 39
					+ "usur.cpf, " // 40
					+ "parc.valorDescontoFaixaReferenciaConta " // 41
					+ "from Parcelamento parc " + "left join parc.cliente clie " + "left join clie.profissao prof "
					+ "left join parc.usuario usur " + "left join usur.funcionario func " + "inner join parc.imovel imov "
					+ "inner join imov.localidade localidade " + "inner join imov.setorComercial setor "
					+ "left join imov.clienteImoveis ci with ( ci.clienteRelacaoTipo.id = 2 and ci.dataFimRelacao is null ) "
					+ "left join ci.cliente devedor " + "left join ci.cliente " + "left join devedor.clienteTipo ct,"
					+ "SistemaParametro sp " + "left join sp.clienteDiretorComercial cliDir " + "where parc.id = :idParcelamento";

			retorno = session.createQuery(consulta).setInteger("idParcelamento", idParcelamento.intValue()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa os itens do parcelamento necessários para o relatório através do
	 * id do parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @date 25/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarParcelamentoItemPorIdParcelamentoRelatorio(Integer idParcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "select "
					+
					// 0
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.referencia"
					+ " else"
					+ "   ch.anoMesReferenciaConta"
					+ " end,"
					+
					// 1
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorAgua"
					+ " else"
					+ "   ch.valorAgua"
					+ " end,"
					+
					// 2
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorEsgoto"
					+ " else"
					+ "   ch.valorEsgoto"
					+ " end,"
					+
					// 3
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorCreditos"
					+ " else"
					+ "   ch.valorCreditos"
					+ " end,"
					+
					// 4
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.debitos"
					+ " else"
					+ "   ch.valorDebitos"
					+ " end,"
					+ "gpag.id, " // 5
					+ "dtgpag.descricao, gpag.valorDebito, " // 6,7
					+ "dtdbac.id, dtdbac.descricao, " // 8,9
					+ "dbac.numeroPrestacaoDebito, dbac.numeroPrestacaoCobradas, " // 10,11
					+ "dbac.valorDebito, ctcrar.id, " // 12,13
					+ "ctcrar.descricao, crar.numeroPrestacaoCredito, " // 14,15
					+ "crar.numeroPrestacaoRealizada, crar.valorCredito, " // 16,17
					+ "dbac.numeroParcelaBonus , crar.numeroParcelaBonus " // 18,19
					+ "from ParcelamentoItem parcItem " + "inner join parcItem.parcelamento parc " + "left join parcItem.contaGeral cg "
					+ "left join cg.contaHistorico ch " + "left join cg.conta conta " + "left join parcItem.guiaPagamentoGeral gpg "
					+ "left join gpg.guiaPagamento gpag " + "left join gpag.debitoTipo dtgpag "
					+ "left join parcItem.debitoACobrarGeral dacg " + "left join dacg.debitoACobrar dbac "
					+ "left join dbac.debitoTipo dtdbac " + "left join parcItem.creditoARealizarGeral carg "
					+ "left join carg.creditoARealizar crar " + "left join crar.creditoTipo ctcrar " + "where parc.id = :idParcelamento "
					+ "group by cg.indicadorHistorico, conta.referencia, conta.valorAgua, " + "conta.valorEsgoto, conta.debitos, "
					+ "conta.valorCreditos, gpag.id, " + "ch.anoMesReferenciaConta, ch.valorAgua, " + "ch.valorEsgoto, ch.valorDebitos, "
					+ "ch.valorCreditos, " + "dtgpag.descricao, gpag.valorDebito, " + "dtdbac.id, dtdbac.descricao, "
					+ "dbac.numeroPrestacaoDebito, dbac.numeroPrestacaoCobradas, " + "dbac.valorDebito, ctcrar.id, "
					+ "ctcrar.descricao, crar.numeroPrestacaoCredito, " + "crar.numeroPrestacaoRealizada, crar.valorCredito, "
					+ "dbac.numeroParcelaBonus , crar.numeroParcelaBonus " + "order by conta.referencia, dtdbac.id, gpag.id, "
					+ " ctcrar.id";

			retorno = session.createQuery(consulta).setInteger("idParcelamento", idParcelamento.intValue()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Obtem os percentuais de desconto por tempo de inatividade
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 2/10/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoDescontoInatividade obterPercentualDescontoInatividade(Integer idPerfilParc, int qtdeMeses)
			throws ErroRepositorioException {

		ParcelamentoDescontoInatividade retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pdin " + "FROM ParcelamentoDescontoInatividade pdin " + "WHERE pdin.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND pdin.quantidadeMaximaMesesInatividade IN (" + "SELECT max(p.quantidadeMaximaMesesInatividade)"
					+ "FROM ParcelamentoDescontoInatividade p " + "WHERE p.quantidadeMaximaMesesInatividade <= :qtdeMeses)";

			retorno = (ParcelamentoDescontoInatividade) session.createQuery(consulta).setInteger("idPerfilParc", idPerfilParc.intValue())
					.setInteger("qtdeMeses", qtdeMeses).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consultar Serviços/Atualizações do documento de cobraça
	 * 
	 * 
	 * [UC0349] - Emitir Documento de cobrança - Ordem de Fiscalização
	 * 
	 * @author Ana Maria
	 * @date 18/10/2006
	 * 
	 * @param idDocumentoCobranca
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarServioAtualizacao(Integer idDocumentoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		String consulta = null;

		try {
			consulta = " select sum(cdit.valorItemCobrado) " + " from CobrancaDocumentoItem cdit "
					+ " inner join cdit.cobrancaDocumento cbdo " + " left join cdit.guiaPagamentoGeral.guiaPagamento gpag "
					+ " left join cdit.debitoACobrarGeral.debitoACobrar dbac "
					+ " where cbdo.id = :idDocumentoCobranca and (gpag.id is not null or dbac.id is not null) ";

			Object resultado = session.createQuery(consulta).setInteger("idDocumentoCobranca", idDocumentoCobranca.intValue())
					.uniqueResult();

			if (resultado != null) {
				retorno = (BigDecimal) resultado;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @created 23/10/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void associarContaParcelamento(Conta conta) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			// Atualiza PARC_ID da tabela CONTA com o id do parcelamento
			update = "UPDATE gcom.faturamento.conta.Conta SET " + "parc_id = :idParcelamento,"
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setInteger("idParcelamento", conta.getParcelamento().getId())
					.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao()).setInteger("idConta", conta.getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Retorna os CBCM_ID da tabela COBRANCA_GRUPO_CRONOGRAMA_MES
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaGrupoCronogramaMes() throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaGrupoCronogramaMes.id,cobrancaGrupoCronogramaMes.anoMesReferencia,cobrancaGrupoCronogramaMes.cobrancaGrupo.id from CobrancaGrupoCronogramaMes cobrancaGrupoCronogramaMes"
					// +
					// " where cobrancaGrupoCronogramaMes.cobrancaGrupo.id in (31) "
					+ " where cobrancaGrupoCronogramaMes.anoMesReferencia >= 200710 ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Retorna os CBCR_ID da tabela COBRANCA_ACAO_CRONOGRAMA com CBCM_ID da
	 * tabela COBRANCA_GRUPO_CRONOGRAMA_MES
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaAcaoCronograma(int idCobrancaGrupoCronogramaMes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAcaoCronograma.id,cobrancaAcaoCronograma.cobrancaAcao.id from CobrancaAcaoCronograma cobrancaAcaoCronograma "
					+ "where cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id = :idCobrancaGrupoCronogramaMes";

			retorno = session.createQuery(consulta).setInteger("idCobrancaGrupoCronogramaMes", idCobrancaGrupoCronogramaMes).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Retorna CAAC_TMREALIZACAO do COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarDataRelizacaoCobrancaAtividadeAcaoConograma(int idCobrancaAcaoCronograma, int idCobrancaAtividade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAtividadeAcaoCronograma.id, " + "cobrancaAtividadeAcaoCronograma.realizacao, "
					+ "cobrancaAtividadeAcaoCronograma.dataPrevista,"
					+ "cobrancaAtividadeAcaoCronograma.comando from CobrancaAcaoAtividadeCronograma cobrancaAtividadeAcaoCronograma "
					+ "where cobrancaAtividadeAcaoCronograma.cobrancaAcaoCronograma.id = :idCobrancaAcaoCronograma and "
					+ "cobrancaAtividadeAcaoCronograma.cobrancaAtividade.id = :idCobrancaAtividade ";
			retorno = session.createQuery(consulta).setInteger("idCobrancaAcaoCronograma", idCobrancaAcaoCronograma)
					.setInteger("idCobrancaAtividade", idCobrancaAtividade).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Retorna os DOTP_ID da tabela COBRANCA_ACAO com CBAC_ID de
	 * COBRANCA_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarCobrancaAcao(int idCobrancaAcao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAcao.documentoTipo.id,cobrancaAcao.servicoTipo.id,"
					+ "cobrancaAcao.indicadorDebitoInterfereAcao from CobrancaAcao cobrancaAcao "
					+ "where cobrancaAcao.id = :idCobrancaAcao";

			retorno = session.createQuery(consulta).setInteger("idCobrancaAcao", idCobrancaAcao).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documentos Cobrança
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006,28/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Collection<DadosPesquisaCobrancaDocumentoHelper> pesquisarCobrancaDocumento(int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id,"
					+ "cobrancaDocumento.emissao, " + "cobrancaDocumento.imovel.id, " + "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobCrit.percentualQuantidadeMinimoPagoParceladoCancelado, " + "cobCrit.valorLimitePrioridade)  "
					+ "from CobrancaDocumento cobrancaDocumento " + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "where cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id = :idCobrancaAtividadeAcaoCronograma "
					+ "order by cobrancaDocumento.id";

			retorno = session.createQuery(consulta).setInteger("idCobrancaAtividadeAcaoCronograma", idCobrancaAtividadeAcaoCronograma)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0002] - Determinar Situação da Ação de Cobrança
	 * 
	 * Retorna os ORSE_ID da tabela ORDEM_SERVICO com CBDO_ID da tabela
	 * COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos,Sávio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 04/06/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection<Object[]> pesquisarOrdemServico(int idDocumentoCobranca) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select orse.orse_id as idOS," + " orse.orse_cdsituacao as codigoOS,"
					+ " orse.orse_dtfiscalizacaosituacao as dataFiscalizacao," + " orse.orse_tmencerramento as dataEncerramento,"
					+ " cob.cbdo_id as idCobDocumento," + " cob.cbdo_vldocumento as valorDocumento,"
					+ " cob.cbct_id as idCriterioCobranca, " + " orse.fzst_id as idFiscalizacaoSit,"
					+ " atMotEnc.amen_icexecucao as indicadorExecucao," + " imov.imov_id as idImovel," + " imov.loca_id as idLocalidade, "
					+ " cob.cast_id as idSituacaoAcao, " + " cob.cbdo_dtsituacaoacao as dataSituacaoAcao "
					+ ", atMotEnc.amen_id as idMotivoEncerramento, " + " cob.cbdo_tmemissao as dataEmissao "
					+ "from atendimentopublico.ordem_servico orse "
					+ "inner join cobranca.cobranca_documento cob on cob.cbdo_id = orse.cbdo_id " + "left join cadastro.imovel imov "
					+ "      on imov.imov_id = orse.imov_id " + "left join  atendimentopublico.atend_motivo_encmt atMotEnc "
					+ "      on atMotEnc.amen_id = orse.amen_id " + " where cob.cbdo_id = :idDocumento ";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("codigoOS", Hibernate.SHORT)
					.addScalar("dataFiscalizacao", Hibernate.DATE).addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("idCobDocumento", Hibernate.INTEGER).addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("idCriterioCobranca", Hibernate.INTEGER).addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indicadorExecucao", Hibernate.SHORT).addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idSituacaoAcao", Hibernate.INTEGER)
					.addScalar("dataSituacaoAcao", Hibernate.DATE).addScalar("idMotivoEncerramento", Hibernate.INTEGER)
					.addScalar("dataEmissao", Hibernate.DATE).setInteger("idDocumento", idDocumentoCobranca).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0007] - Determinar Situação da Ordem de Serviço
	 * 
	 * Retorna os AMEN_ICEXECUCAO da tabela ATENDIMENTO_MOTIVO_ENCERRAMENTO com
	 * AMEN_ID da tabela ORDEM_SERVIÇO
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAtendimentoMotivoEncerramento(int idAtendimentoMotivoEncerramento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select atendimentoMotivoEncerramento.indicadorExecucao from AtendimentoMotivoEncerramento atendimentoMotivoEncerramento "
					+ "where atendimentoMotivoEncerramento.id = :idAtendimentoMotivoEncerramento";

			retorno = session.createQuery(consulta).setInteger("idAtendimentoMotivoEncerramento", idAtendimentoMotivoEncerramento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os CNTA_ID,GPAG_ID,DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM com
	 * CBDO_ID da tabela COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarCobrancaDocumentoItem(int idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaDocumentoItem.contaGeral.id, " + "cobrancaDocumentoItem.guiaPagamentoGeral.id, "
					+ "cobrancaDocumentoItem.debitoACobrarGeral.id, " + "cobrancaDocumentoItem.id,"
					+ "cobrancaDocumentoItem.valorItemCobrado, "
					/**
					 *
					 * 
					 * @data 23/10/2013
					 * @author Adriana Muniz e Wellington Rocha Adição do
					 *         atributo valor dos acrescimos no retorno da query
					 * */
					+ "cobrancaDocumentoItem.valorAcrescimos " + "from CobrancaDocumentoItem cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.cobrancaDocumento.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os CNTG_ID da tabela COBRANCA_GERAL com CNTA_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarContaGeral(int idConta) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select contaGeral.id " + "from ContaGeral contaGeral "
					+ "where contaGeral.conta.id = :idConta and contaGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).setInteger("valorIndicador", 1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,CNHI_DTCANCELAMENTO da tabela CONTA_HISTORICO com
	 * CNTA_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaHistorico(int idContaHistorico) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select contaHistorico.debitoCreditoSituacaoAtual.id," + "contaHistorico.dataCancelamento "
					+ "from ContaHistorico contaHistorico " + "where contaHistorico.id = :idContaHistorico";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idContaHistorico", idContaHistorico).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,CNTA_DTCANCELAMENTO da tabela CONTA com CNTA_ID
	 * da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006,01/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarConta(int idConta) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select conta.debitoCreditoSituacaoAtual.id," + "conta.dataCancelamento " + "from Conta conta "
					+ "where conta.id = :idConta";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com CNTA_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoConta(int idConta, int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento " + " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.contaGeral.id = :idConta and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			// consulta = "select tabelaParcelamento.parcelamento "
			// + "from Parcelamento tabelaParcelamento "
			// + " inner join tabelaParcelamento."
			// + "where tabelaParcelamento.id =(select
			// parcelamentoItem.parcelamento.id from ParcelamentoItem "
			// + "parcelamentoItem where parcelamentoItem.contaGeral.id =
			// :idConta) and "
			// + "tabelaParcelamento.parcelamentoSituacao =
			// :idParcelamentoSituacao ";

			retorno = (Date) session.createQuery(consulta).setInteger("idConta", idConta)
					.setInteger("idParcelamentoSituacao", idParcelamentoSituacao).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os GPGE_ID da tabela GUIA_PAGAMENTO_GERAL com GPAG_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("rawtypes")
	public Collection pesquisarGuiaPagamentoGeral(int idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamentoGeral.id "
					+ "from GuiaPagamentoGeral guiaPagamentoGeral "
					+ "where guiaPagamentoGeral.guiaPagamento.id = :idGuiaPagamento and guiaPagamentoGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger("valorIndicador", 1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,GPGE_DTCANCELAMENTO da tabela
	 * GUIA_PAGAMENTO_HISTORICO com GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarGuiaPagamentoHistorico(int idGuiaPagamentoHistorico) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamentoHistorico.debitoCreditoSituacaoByDcstIdatual.id," + "guiaPagamentoHistorico.ultimaAlteracao "
					+ "from GuiaPagamentoHistorico guiaPagamentoHistorico " + "where guiaPagamentoHistorico.id = :idGuiaPagamentoHistorico";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idGuiaPagamentoHistorico", idGuiaPagamentoHistorico)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,GPAG_DTCANCELAMENTO da tabela GUIA_PAGAMENTO com
	 * GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarGuiaPagamento(int idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamento.debitoCreditoSituacaoAtual.id," + "guiaPagamento.ultimaAlteracao "
					+ "from GuiaPagamento guiaPagamento " + "where guiaPagamento.id = :idGuiaPagamento";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com GPAG_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006,29/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoGuiaPagamento(int idGuiaPagamento, int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento " + " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.guiaPagamentoGeral.id = :idGuiaPagamento and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			retorno = (Date) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento)
					.setInteger("idParcelamentoSituacao", idParcelamentoSituacao).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DAGE_ID da tabela DEBITO_A_COBRAR_GERAL com DBAC_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarGeral(int idDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrarGeral.id " + "from DebitoACobrarGeral debitoACobrarGeral "
					+ "where debitoACobrarGeral.id = :idDebitoACobrar " + "and debitoACobrarGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar)
					.setInteger("valorIndicador", ConstantesSistema.SIM).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,DAGE_DTCANCELAMENTO da tabela
	 * DEBITO_A_COBRAR_HISTORICO com DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoACobrarHistorico(int idDebitoACobrarHistorico) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrarHistorico.debitoCreditoSituacaoAtual.id," + "debitoACobrarHistorico.ultimaAlteracao "
					+ "from DebitoACobrarHistorico debitoACobrarHistorico " + "where debitoACobrarHistorico.id = :idDebitoACobrarHistorico";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idDebitoACobrarHistorico", idDebitoACobrarHistorico)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,GPAG_DTCANCELAMENTO da tabela DEBITO_A_COBRAR com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoACobrar(int idDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrar.debitoCreditoSituacaoAtual.id," + "debitoACobrar.ultimaAlteracao "
					+ "from DebitoACobrar debitoACobrar " + "where debitoACobrar.id = :idDebitoACobrar";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com DBAC_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006,29/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoDebitoACobrar(int idDebitoACobrar, int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento " + " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.creditoARealizarGeral.id = :idDebitoACobrar and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			// consulta = "select tabelaParcelamento.parcelamento "
			// + "from Parcelamento tabelaParcelamento "
			// + "where tabelaParcelamento.id =(select
			// parcelamentoItem.parcelamento.id from ParcelamentoItem
			// parcelamentoItem "
			// + "where parcelamentoItem.debitoACobrar.id = :idDebitoACobrar)
			// and "
			// + "tabelaParcelamento.parcelamentoSituacao =
			// :idParcelamentoSituacao ";

			retorno = (Date) session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar)
					.setInteger("idParcelamentoSituacao", idParcelamentoSituacao).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * CNTA_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosContaHistorico(int idContaHistorico) throws ErroRepositorioException {

		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) " + "from PagamentoHistorico pagamentoHistorico "
					+ "inner join pagamentoHistorico.contaGeral contaGeral " + "inner join contaGeral.contaHistorico contaHistorico "
					+ "where contaHistorico.id = :idContaHistorico";

			Object retornoObj = session.createQuery(consulta).setInteger("idContaHistorico", idContaHistorico).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO com CNTA_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosConta(int idConta) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) " + "from Pagamento pagamento " + "where pagamento.contaGeral.id = :idConta";

			Object retornoObj = session.createQuery(consulta).setInteger("idConta", idConta).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosGuiaPagamentoHistorico(int idGuiaPagamentoHistorico) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) " + "from PagamentoHistorico pagamentoHistorico "
					+ "where pagamentoHistorico.guiaPagamento.id = :idGuiaPagamentoHistorico";

			Object retornoObj = session.createQuery(consulta).setInteger("idGuiaPagamentoHistorico", idGuiaPagamentoHistorico)
					.uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO com GPAG_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosGuiaPagamento(int idGuiaPagamento) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) " + "from Pagamento pagamento "
					+ "where pagamento.guiaPagamento.id = :idGuiaPagamento";

			Object retornoObj = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosDebitoACobrarHistorico(int idDebitoACobrarHistorico) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) " + "from PagamentoHistorico pagamentoHistorico "
					+ "where pagamentoHistorico.debitoACobrarGeral.id = :idDebitoACobrarHistorico";

			Object retornoObj = session.createQuery(consulta).setInteger("idDebitoACobrarHistorico", idDebitoACobrarHistorico)
					.uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosDebitoACobrar(int idDebitoACobrar) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) " + "from Pagamento pagamento "
					+ "where pagamento.debitoACobrar.id = :idDebitoACobrar";

			Object retornoObj = session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0005] - Determinar Situação Predominante do Débito do Documento de
	 * Cobrança
	 * 
	 * Retorna o CBCT_PCVLMINIMOPGPARCCANC, CBCBT_PCQTMINIMOPGPARCCANC da tabela
	 * COBRANCA_CRITERIO com CBCT_ID da tabela COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaCriterio(int idCobrancaCriterio) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select cobrancaCriterio.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobrancaCriterio.percentualQuantidadeMinimoPagoParceladoCancelado, " + "cobrancaCriterio.valorLimitePrioridade "
					+ "from CobrancaCriterio cobrancaCriterio " + "where cobrancaCriterio.id = :idCobrancaCriterio";

			retorno = session.createQuery(consulta).setInteger("idCobrancaCriterio", idCobrancaCriterio).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0004] - Atualizar item do documento de cobrança
	 * 
	 * Atualizar os COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaDocumentoItem(Collection colecaoCobrancaDocumentoItem) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		// posições do array com os dados que serão atualizados na cobrança
		// documento item
		final byte POSICAO_ID_COBRANCA_DOCUMENTO = 0;
		final byte POSICAO_ID_COBRANCA_DOCUMENTO_ITEM = 1;
		final byte POSICAO_ID_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM = 2;
		final byte POSICAO_DATA_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM = 3;

		try {

			Iterator iteratorColecaoCobrancaDocumentoItem = colecaoCobrancaDocumentoItem.iterator();

			while (iteratorColecaoCobrancaDocumentoItem.hasNext()) {

				Object[] cobrancaDocumentoItemParaAtualizar = (Object[]) iteratorColecaoCobrancaDocumentoItem.next();

				atualizar = "update gcom.cobranca.CobrancaDocumentoItem "
						+ " set cdst_id = :idSituacaoDebitoItem, cdit_dtsituacaodebito = :dataSituacaoDebito,cdit_tmultimaalteracao = :ultimaAlteracao "
						+ " where cbdo_id = :idCobrancaDocumento and cdit_id = :idCobrancaDocumentoItem ";

				session.createQuery(atualizar)
						.setInteger("idSituacaoDebitoItem",
								((Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM]))
						.setDate("dataSituacaoDebito",
								((Date) cobrancaDocumentoItemParaAtualizar[POSICAO_DATA_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM]))
						.setInteger("idCobrancaDocumento", ((Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_COBRANCA_DOCUMENTO]))
						.setInteger("idCobrancaDocumentoItem",
								((Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_COBRANCA_DOCUMENTO_ITEM]))
						.setTimestamp("ultimaAlteracao", new Date()).executeUpdate();
			}
		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0004] - Processar Documento de Cobrança
	 * 
	 * Atualizar os COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	// Override - Metodo sobrescrito na classe RepositorioCobrancaPostgresHBM
	public void atualizarCobrancaDocumento(Collection colecaoCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Connection con = null;
		Statement stmt = null;

		try {

			con = session.connection();
			stmt = con.createStatement();

			Iterator iteratorColecaoCobrancaDocumento = colecaoCobrancaDocumento.iterator();

			int TAM_BLOCO_ATUALIZACAO = 50;
			int i = 0;

			StringBuffer atualizar = new StringBuffer();

			while (iteratorColecaoCobrancaDocumento.hasNext()) {

				DadosPesquisaCobrancaDocumentoHelper cobrancaDocumentoParaAtualizar = (DadosPesquisaCobrancaDocumentoHelper) iteratorColecaoCobrancaDocumento
						.next();

				atualizar.append("update cobranca.cobranca_documento set ");
				if (cobrancaDocumentoParaAtualizar.getIdSituacaoAcao() != null) {
					atualizar.append("cast_id = " + cobrancaDocumentoParaAtualizar.getIdSituacaoAcao() + ",");
				}
				if (cobrancaDocumentoParaAtualizar.getDataSituacaoAcao() != null) {
					atualizar.append(" cbdo_dtsituacaoacao = to_date('"
							+ Util.formatarDataComTracoAAAAMMDD(cobrancaDocumentoParaAtualizar.getDataSituacaoAcao())
							+ "','YYYY-MM-DD') , ");
				}
				if (cobrancaDocumentoParaAtualizar.getDataSituacaoDebito() != null) {
					atualizar.append(" cbdo_dtsituacaodebito = to_date('"
							+ Util.formatarDataComTracoAAAAMMDD(cobrancaDocumentoParaAtualizar.getDataSituacaoDebito())
							+ "','YYYY-MM-DD'), ");
				} else {
					atualizar.append(" cbdo_dtsituacaodebito = null, ");
				}
				if (cobrancaDocumentoParaAtualizar.getIdCategoria() != null) {
					atualizar.append(" catg_id = " + cobrancaDocumentoParaAtualizar.getIdCategoria() + ", ");
				}
				if (cobrancaDocumentoParaAtualizar.getIcAcimaLimite() != null) {
					atualizar.append(" cbdo_icacimalimite = " + cobrancaDocumentoParaAtualizar.getIcAcimaLimite() + ", ");
				}
				if (cobrancaDocumentoParaAtualizar.getIdSituacaoDebito() != null) {
					atualizar.append(" cdst_id = " + cobrancaDocumentoParaAtualizar.getIdSituacaoDebito() + ", ");
				}
				// else {
				// atualizar.append(" cdst_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdFiscalizacao() != null) {
					atualizar.append(" fzst_id = " + cobrancaDocumentoParaAtualizar.getIdFiscalizacao() + ", ");
				}
				// else {
				// atualizar.append(" fzst_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdEsferaPoder() != null) {
					atualizar.append(" epod_id = " + cobrancaDocumentoParaAtualizar.getIdEsferaPoder() + ", ");
				}
				// else {
				// atualizar.append(" epod_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIcAntesDepois() != null) {
					atualizar.append(" cbdo_icantesapos = " + cobrancaDocumentoParaAtualizar.getIcAntesDepois() + ", ");
				}
				// else {
				// atualizar.append(" cbdo_icantesapos = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdMotivoEncerramento() != null) {
					atualizar.append(" amen_id = " + cobrancaDocumentoParaAtualizar.getIdMotivoEncerramento() + ", ");
				}

				atualizar.append(" cbdo_tmultimaalteracao = " + Util.obterSQLDataAtual() + " ");
				atualizar.append(" where cbdo_id = " + cobrancaDocumentoParaAtualizar.getIdDocumento() + "");

				stmt.addBatch(atualizar.toString());
				atualizar = new StringBuffer("");

				if ((i > 0 && i % TAM_BLOCO_ATUALIZACAO == 0) || i == (colecaoCobrancaDocumento.size() - 1)) {
					// System.out.println("SQL: " + atualizar.toString());
					// stmt.executeUpdate(atualizar.toString());
					stmt.executeBatch();
					atualizar = new StringBuffer();
					session.flush();
				}
				i++;

			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
			try {
				if (con != null)
					con.close();
				if (stmt != null)
					stmt.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documentos de Cobrança
	 * 
	 * Retorna os dados do Imovel
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosImovel(int idImovel) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct imovel.ligacaoAguaSituacao.id, "
					+ "imovel.ligacaoEsgotoSituacao.id, "
					+ "imovel.localidade.id, "
					+ "imovel.quadra.id, "
					+ "imovel.quadra.numeroQuadra, "
					+ "imovel.setorComercial.id, "
					+ "imovel.setorComercial.codigo, "
					+ "imovel.localidade.gerenciaRegional.id, "
					+ "imovel.quadra.rota.id,  "
					+ "imovel.imovelPerfil.id, "
					+ "esferaPoder.id "
					+ "from Imovel imovel  "
					+ "left outer join imovel.clienteImoveis clienteImoveisReposanvel with (clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString() + " ) " + "and clienteImoveisReposanvel.dataFimRelacao is null  "
					+ "left outer join clienteImoveisReposanvel.cliente clienteResposanvel "
					+ "left outer join clienteResposanvel.clienteTipo clienteTipo "
					+ "left outer join clienteTipo.esferaPoder esferaPoder " + "where imovel.id = :idImovel";
			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documentos de Cobrança
	 * 
	 * Retorna os dados do Imovel
	 * 
	 * @author Sávio Luiz
	 * @date 11/06/2007
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosImovelPorOS(int idOrdemServico) throws ErroRepositorioException {
		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ordemServ.imovel.id, " + "ordemServ.imovel.localidade.id " + "from OrdemServico ordemServ "
					+ "where ordemServ.id = :idOrdemServico";
			retorno = (Object[]) session.createQuery(consulta).setInteger("idOrdemServico", idOrdemServico).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documento de Cobrança
	 * 
	 * Atualizar os COBRANCA_ACAO_ATIVIDADE_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 25/10/2006
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaAcaoAtividadeCronograma(int idCobrancaAcaoAtividadeCrongrama) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		try {
			atualizar = "update gcom.cobranca.CobrancaAcaoAtividadeCronograma "
					+ " set caac_tmrealizacao = :dataRealizacao,caac_tmultimaalteracao = :dataAtual "
					+ " where caac_id = :idCobrancaAcaoAtividadeCronograma";

			session.createQuery(atualizar).setInteger("idCobrancaAcaoAtividadeCronograma", idCobrancaAcaoAtividadeCrongrama)
					.setDate("dataRealizacao", new Date()).setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0006] - Processar Ação com Ordens de Serviço
	 * 
	 * Retorna os ORSE_ID da tabela ORDEM_SERVICO com SVTP_ID da tabela
	 * COBRANCA_ACAO e ORSE_TMGERACAO entre CAAC_DTPREVISTA do Emitir e do
	 * Encerrar
	 * 
	 * @author Rafael Santos
	 * @date 25/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarOrdemServicos(int idServicoTipo, Date dataPrevistaAtividadeEncerrar, Date dataPrevistaAtividadeEmitir,
			int indice) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select ordemServico.id," + "ordemServico.situacao," + "ordemServico.fiscalizacaoSituacao.id,"
					+ "ordemServico.dataFiscalizacaoSituacao," + "ordemServico.dataEncerramento," + "atendimentoMotivoEncerramento.id,  "
					+ "imov.id, loc.id from OrdemServico ordemServico "
					+ "inner join ordemServico.atendimentoMotivoEncerramento atendimentoMotivoEncerramento "
					+ "left join ordemServico.imovel imov " + "left join imov.localidade loc "
					+ "where ordemServico.servicoTipo.id = :idServicoTipo and "
					+ " ordemServico.dataGeracao >= :dataPrevistaAtividadeEmitir and"
					+ " ordemServico.dataGeracao <= :dataPrevistaAtividadeEncerrar ";

			retorno = session.createQuery(consulta).setInteger("idServicoTipo", idServicoTipo)
					.setDate("dataPrevistaAtividadeEmitir", dataPrevistaAtividadeEmitir)
					.setDate("dataPrevistaAtividadeEncerrar", dataPrevistaAtividadeEncerrar).setFirstResult(indice).setMaxResults(500)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna o objeto ParcelamentoFaixaValor com o valor do debito(valorFaixa)
	 * com desconto maior q o da faixa e menor que próxima faixa
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 31/10/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoFaixaValor obterParcelamentoFaixaValor(Integer idParcelamentoQtdePrestacao, BigDecimal valorFaixa)
			throws ErroRepositorioException {

		ParcelamentoFaixaValor retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pfvl " + "FROM ParcelamentoFaixaValor pfvl "
					+ "WHERE pfvl.parcelamentoQuantidadePrestacao.id = :idParcelamentoQtdePrestacao " + "AND pfvl.valorFaixa IN ("
					+ "SELECT max(p.valorFaixa) " + "FROM ParcelamentoFaixaValor p " + "WHERE p.valorFaixa <= :valorFaixa)";

			retorno = (ParcelamentoFaixaValor) session.createQuery(consulta)
					.setInteger("idParcelamentoQtdePrestacao", idParcelamentoQtdePrestacao.intValue())
					.setBigDecimal("valorFaixa", valorFaixa).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0178] Processar Pagamentos com código de Barras Auhtor: Sácio Luiz
	 * Data: 06/11/2006
	 * 
	 */
	public void atualizarGuiaPagamento(Collection idsGuiaPagamento, Date dataVencimento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarGuiaPagamento;
		try {
			atualizarGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set gpag_dtvencimento = :dataVencimento,gpag_iccobrancamulta = :idCobrancaMulta, "
					+ " gpag_tmultimaalteracao = :dataAtual where gpag_id in (:idsGuiaPagamento)";

			session.createQuery(atualizarGuiaPagamento).setParameterList("idsGuiaPagamento", idsGuiaPagamento)
					.setDate("dataVencimento", dataVencimento).setShort("idCobrancaMulta", ConstantesSistema.SIM)
					.setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			System.out.println("Erro");

			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * O sistema exclui o resumo das ações de cobrança correspondente ao
	 * cronograma de ação de cobrança que esta sendo processado
	 * 
	 * @author Rafael Santos
	 * @date 08/11/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void deletarResumoCobrancaAcao(int idCobrancaAcaoCronograma) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "delete ResumoCobrancaAcao resumoCobrancaAcao "
					+ "where resumoCobrancaAcao.cobrancaAcaoCronograma.id = :idCobrancaAcaoCronograma ";

			session.createQuery(consulta).setInteger("idCobrancaAcaoCronograma", idCobrancaAcaoCronograma).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * retorna uma colecao de ResolucaoDiretoria
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 08/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaMaiorDataVigenciaInicio() throws ErroRepositorioException {

		Collection retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd " + "from ResolucaoDiretoria as rd " + "where rd.indicadorUtilizacaoLivre = :indicadorUtilizacaoLivre "
					+ "and (rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual) " + "order by rd.dataVigenciaInicio ";

			retorno = (Collection) session.createQuery(consulta).setDate("dataAtual", new Date())
					.setShort("indicadorUtilizacaoLivre", ConstantesSistema.SIM).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtem a condição referente à qtde de reparcelamentos consecutivos já
	 * realizadas para o perfil do parcelamento para o imóvel
	 * 
	 * a partir da tabela PARCELAMENTO_QUANTIDADE_REPARCELAMENTO com
	 * PCPF_ID=PCPF_ID da tabela PARCELAMENTO_PERFIL e
	 * PQTR_QTMAXIMAREPARCELAMENTO igual ou menor que
	 * IMOV_NNREPARCELAMENTOCONSECUTVOS, caso mais de uma ocorrencia seja
	 * selecionada, escolher a que tiver o maior valor de
	 * PQTR_QTMAXIMAREPARCELAMENTO
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 28/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoQuantidadeReparcelamento obterQtdeReparcelamentoPerfil(Integer idPerfilParc, Short numeroReparcelamentoConsecutivos)
			throws ErroRepositorioException {

		ParcelamentoQuantidadeReparcelamento retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parcelamentoQtdeReparcel " + "FROM ParcelamentoQuantidadeReparcelamento parcelamentoQtdeReparcel "
					+ "WHERE parcelamentoQtdeReparcel.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND parcelamentoQtdeReparcel.quantidadeMaximaReparcelamento IN (" + "SELECT max(p.quantidadeMaximaReparcelamento)"
					+ "FROM ParcelamentoQuantidadeReparcelamento p "
					+ "WHERE p.quantidadeMaximaReparcelamento <= :numeroReparcelamentoConsecutivos "
					+ "and p.parcelamentoPerfil.id = :idPerfilParc)";

			retorno = (ParcelamentoQuantidadeReparcelamento) session.createQuery(consulta)
					.setInteger("idPerfilParc", idPerfilParc.intValue())
					.setShort("numeroReparcelamentoConsecutivos", numeroReparcelamentoConsecutivos).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove ClienteGuiaPagamento
	 * referentes ao parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @created 28/11/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerClienteGuiaPagamentoDoParcelamento(Integer idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerClienteGuiaPagamentoDoParcelamento;

		try {
			// remove em credito a realizar os parcelamentos
			removerClienteGuiaPagamentoDoParcelamento = "delete gcom.cadastro.cliente.ClienteGuiaPagamento "
					+ "where gpag_id = :idGuiaPagamento ";

			session.createQuery(removerClienteGuiaPagamentoDoParcelamento).setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa o critério de cobrança linha definido para a rota
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Leonardo Vieira
	 * @created 12/12/2006
	 * 
	 * @param idRota
	 * @param idCobrancaAcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public CobrancaCriterio pesquisarCriterioCobrancaRota(Integer idRota, Integer idCobrancaAcao) throws ErroRepositorioException {

		CobrancaCriterio retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cc from RotaAcaoCriterio rac " + "inner join rac.cobrancaAcao ca " + "inner join rac.cobrancaCriterio cc "
					+ "where rac.comp_id.rotaId = :idRota and ca.id = :idCobrancaAcao";

			retorno = (CobrancaCriterio) session.createQuery(consulta).setInteger("idRota", idRota)
					.setInteger("idCobrancaAcao", idCobrancaAcao).setMaxResults(1).uniqueResult();

			retorno.setCriteriosSituacaoCobranca(new HashSet(this.pesquisarCobrancaCriterioSituacaoCobranca(retorno.getId())));
			retorno.setCriteriosSituacaoLigacaoAgua(new HashSet(this.pesquisarCobrancaCriterioSituacaoLigacaoAgua(retorno.getId())));
			retorno.setCriteriosSituacaoLigacaoEsgoto(new HashSet(this.pesquisarCobrancaCriterioSituacaoLigacaoEsgoto(retorno.getId())));
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o critério de cobrança linha definido para o critério de
	 * cobrança
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Leonardo Vieira
	 * @created 12/12/2006
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaCriterioLinha> pesquisarCobrancaCriterioLinhaCriterio(Integer idCobrancaCriterio)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select ccl  from CobrancaCriterioLinha ccl " + "inner join ccl.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idCobrancaCriterio", idCobrancaCriterio).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o critério de situacao de cobrança definido para o critério de
	 * cobrança
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoCobranca> pesquisarCobrancaCriterioSituacaoCobranca(Integer idCobrancaCriterio)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csc from CriterioSituacaoCobranca csc " + "inner join csc.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idCobrancaCriterio", idCobrancaCriterio).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o critério de situacao de ligacao de agua definido para o
	 * critério de cobrança
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoLigacaoAgua> pesquisarCobrancaCriterioSituacaoLigacaoAgua(Integer idCobrancaCriterio)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csla from CriterioSituacaoLigacaoAgua csla " + "inner join csla.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idCobrancaCriterio", idCobrancaCriterio).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o critério de situacao de ligacao de esgoto definido para o
	 * critério de cobrança
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoLigacaoEsgoto> pesquisarCobrancaCriterioSituacaoLigacaoEsgoto(Integer idCobrancaCriterio)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csle from CriterioSituacaoLigacaoEsgoto csle " + "inner join csle.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idCobrancaCriterio", idCobrancaCriterio).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaCriterio pesquisarCobrancaCriterioIdCriterio(Integer idCobrancaCriterio) throws ErroRepositorioException {

		CobrancaCriterio retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cc from cobrancaCriterio cc " + " where cc.id = :idCobrancaCriterio ";

			retorno = (CobrancaCriterio) session.createQuery(consulta).setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o documento de cobranca da acao precedente (2.3.1)
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança o Imóvel
	 * 
	 * @author Francisco do Nascimento
	 * @date 22/12/2008
	 * 
	 * @param idImovel
	 * @param idServicoTipo
	 * @param indicadorExecucao
	 * @param dataEncerramento
	 * @return Id do documento de cobrança
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDocumentoCobrancaAcaoPrecedente(Integer idImovel, Integer idServicoTipo, Short indicadorExecucao,
			Date dataEncerramento) throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select os.cobrancaDocumento.id from OrdemServico os " + "inner join os.servicoTipo st "
					+ "inner join os.imovel im " + "inner join os.atendimentoMotivoEncerramento ame "
					+ "where os.dataEncerramento is not null "
					+ "and im.id = :idImovel and st.id = :idServicoTipo and ame.indicadorExecucao = :indicadorExecucao  "
					+ "and os.dataEncerramento <= :dataEncerramento";

			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idServicoTipo", idServicoTipo)
					.setShort("indicadorExecucao", indicadorExecucao).setDate("dataEncerramento", dataEncerramento).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Integer pesquisarDocumentoCobrancaRelativoAcaoPrecedente(Integer idImovel, Integer idDocumentoTipo, Date dataEmissao,
			Date dataEmissaoValidade) throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cbdo.cbdo_id as idCobrancaDocumento  from cobranca.cobranca_documento cbdo "
					+ "inner join cobranca.documento_tipo dotp on dotp.dotp_id = cbdo.dotp_id "
					+ "left join faturamento.documento_nao_entregue done on done.cbdo_id = cbdo.cbdo_id "
					+ "where cbdo.imov_id = :idImovel and dotp.dotp_id = :idDocumentoTipo "
					+ "and (done.dotp_id is null or done.dotp_id <> dotp.dotp_id) "
					+ "and cbdo.cbdo_tmemissao <= :dataEmissao AND cbdo.cbdo_tmemissao >= :dataEmissaoValidade "
					+ "and (cbdo.cast_id is null OR cbdo.cast_id <> " + CobrancaAcaoSituacao.CANCELADA_PRAZO + ")";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("idCobrancaDocumento", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).setInteger("idDocumentoTipo", idDocumentoTipo).setDate("dataEmissao", dataEmissao)
					.setDate("dataEmissaoValidade", dataEmissaoValidade).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	public Object[] pesquisarIdDocumentoCobranca(Integer idImovel, Integer idDocumentoTipo, Date dataEmissao)
			throws ErroRepositorioException {

		Object[] retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cd.cbdo_id as idCobrancaDocumento, cd.cast_id as idCobrancaAcaoSituacao from cobranca.cobranca_documento cd "
					+ "where cd.imov_id = :idImovel and cd.dotp_id = :idDocumentoTipo " + "and cd.cbdo_tmemissao > :dataEmissao";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar("idCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("idCobrancaAcaoSituacao", Hibernate.INTEGER).setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo).setDate("dataEmissao", dataEmissao).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	public Collection pesquisarImovelCobrancaSituacao(Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select ics.cobrancaSituacao.id from ImovelCobrancaSituacao ics " + "inner join ics.imovel im "
					+ "where im.id = :idImovel and ics.dataRetiradaCobranca is null ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	public DebitoTipo pesquisarDebitoTipo(Integer idDebitoTipo) throws ErroRepositorioException {

		DebitoTipo retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select debitoTipo from DebitoTipo debitoTipo " + "where debitoTipo.id = :idDebitoTipo";

			retorno = (DebitoTipo) session.createQuery(consulta).setInteger("idDebitoTipo", idDebitoTipo).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	public CobrancaAcaoAtividadeCronograma pesquisarCobrancaAcaoAtividadeCronograma(Integer idCronogramaAtividadeAcaoCobranca)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeCronograma retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeCronograma caac " + "where caac.id = :idCronogramaAtividadeAcaoCobranca";

			retorno = (CobrancaAcaoAtividadeCronograma) session.createQuery(consulta)
					.setInteger("idCronogramaAtividadeAcaoCobranca", idCronogramaAtividadeAcaoCobranca).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaAcaoAtividadeComando pesquisarCobrancaAcaoAtividadeComando(Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeComando retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeComando caac " + "where caac.id = :idCobrancaAcaoAtividadeComando";

			retorno = (CobrancaAcaoAtividadeComando) session.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeComando", idCobrancaAcaoAtividadeComando).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public Collection pesquisarCobrancaDocumentoItemContaGuiaPagamentoDebitoACobrar(Integer idCobrancaDocumento)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cdi from CobrancaDocumentoItem cdi " + "inner join cdi.cobrancaDocumento cd "
					+ "left join fetch cdi.contaGeral ctg " + "left join fetch ctg.conta ct "
					+ "left join fetch cdi.guiaPagamentoGeral gpg " + "left join fetch gpg.guiaPagamento gp "
					+ "left join fetch cdi.debitoACobrarGeral dacg " + "left join fetch dacg.debitoACobrar dac "
					+ "where cd.id = :idCobrancaDocumento ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaDocumento pesquisarCobrancaDocumento(Integer idImovel, Integer idDocumentoTipo) throws ErroRepositorioException {

		CobrancaDocumento retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cd from CobrancaDocumento cd " + "where cd.imovel.id = :idImovel "
					+ "and cd.documentoTipo.id = :idDocumentoTipo " + "order by cd.emissao desc";

			retorno = (CobrancaDocumento) session.createQuery(consulta).setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaAcaoAtividadeCronograma pesquisarCobrancaAcaoAtividadeCronogramaId(Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeCronograma retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeCronograma caac " + "inner join fetch caac.cobrancaAcaoCronograma cac "
					+ "inner join fetch cac.cobrancaAcao ca " + "left join fetch ca.cobrancaAcaoPredecessora coAcPred "
					+ "left join fetch coAcPred.servicoTipo servicoTipo " + "left join fetch ca.ligacaoAguaSituacao "
					+ "left join fetch ca.ligacaoEsgotoSituacao " + "left join fetch ca.documentoTipo "
					+ "left join fetch caac.cobrancaAtividade cat " + "left join fetch cat.processo "
					+ "left join fetch cac.cobrancaGrupoCronogramaMes cgcm " + "left join fetch cgcm.cobrancaGrupo "
					+ "left join fetch ca.servicoTipo " + "left join fetch ca.cobrancaAcaoPredecessoraAlternativa coAcPredAlter "
					+ "left join fetch coAcPredAlter.documentoTipo documentoTipoAlter "
					+ "where caac.id = :idCobrancaAcaoAtividadeCronograma ";

			retorno = (CobrancaAcaoAtividadeCronograma) session.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeCronograma", idCobrancaAcaoAtividadeCronograma).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verifica de conta tem debito cobrado (CNTA_ID ocorre na tabela
	 * DEBITO_COBRADO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Conta verificarContaDebitoCobrado(Integer idConta) throws ErroRepositorioException {

		Conta retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select distinct conta " + "from DebitoCobrado db " + "where db.conta.id = :idConta ";

			retorno = (Conta) session.createQuery(consulta).setInteger("idConta", idConta).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * obtem o consumo médio do imovel CSHI_NNCONSUMOCONSUMOMEDIO da tabla
	 * CONSUMO_HISTORICO com IMOV_ID = IMOV_ID da tabela CONTA e o maior mês/ano
	 * de consumo(CSHI_AMFATURAMENTO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterConsumoMedioImovel(Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select consumoHistorico.consumoMedio " + "from ConsumoHistorico consumoHistorico "
					+ "where consumoHistorico.imovel.id = :idImovel " + "order by consumoHistorico.referenciaFaturamento desc";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * (DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta a ser
	 * parcelada ocorrendo na tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterIdDebitoTipoDeFiscalizacaoSituacaoServicoACobrar(Integer idConta) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select fiscalizacao.debitoTipo.id " + "from FiscalizacaoSituacaoServicoACobrar fiscalizacao "
					+ "where fiscalizacao.debitoTipo.id in " + "(select debitoCobrado.debitoTipo " + "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)";

			retorno = (Collection) session.createQuery(consulta).setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * DBCB_NNPRESTACAO da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta
	 * e DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID ocorrendo na
	 * tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR
	 * 
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterNumeroPrestacaoDebitoCobrado(Integer idConta) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select debitoCobrado.numeroPrestacao " + "from DebitoCobrado debitoCobrado  "
					+ "where debitoCobrado.conta.id = :idConta " + "and  " + "(select distinct(fiscalizacao.debitoTipo.id) "
					+ "from FiscalizacaoSituacaoServicoACobrar fiscalizacao " + "where fiscalizacao.debitoTipo.id in "
					+ "(select debitoCobrado.debitoTipo " + "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)) is not null";

			retorno = (Collection) session.createQuery(consulta).setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Metodo criado para pesquisar os parcelamentos q tenham juros e nao tenha
	 * criado o debito dos juros DBTP_ID = 44
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/02/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSemDebitos() throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String sql = "select distinct(parc.parc_id) as idParcelamento," + " parc.parc_nnprestacoes as numeroPrestacao,"
				+ " parc.parc_txjuros as taxaJuros," + " imovel.loca_id as idLocalidade," + " quadra.qdra_id as idQuadra,"
				+ " quadra.qdra_nnquadra as numeroQuadra," + " setorComercial.stcm_id as idSetor,"
				+ " setorComercial.stcm_cdsetorcomercial as codigoSetor," + " imovel.imov_nnlote as lote,"
				+ " imovel.imov_nnsublote as subLote," + " parc.parc_vljurosparcelamento as valorJurosParcelamento,"
				+ " imovel.imov_id as idImovel" + " from cobranca.parcelamento parc"
				+ " left join faturamento.debito_a_cobrar debitoCobrar on debitoCobrar.parc_id = parc.parc_id"
				+ " inner join cadastro.imovel imovel on imovel.imov_id = parc.imov_id"
				+ " inner join cadastro.setor_comercial setorComercial on setorComercial.stcm_id = imovel.stcm_id"
				+ " inner join cadastro.quadra quadra on imovel.qdra_id = quadra.qdra_id"
				+ " where (parc.parc_tmparcelamento between :inicio and :fim)" + " and parc.parc_vljurosparcelamento <> 0.00"
				+ " and parc.parc_id " + " not in " + " (select parc.parc_id" + " from cobranca.parcelamento parc"
				+ " left join faturamento.debito_a_cobrar debitoCobrar on debitoCobrar.parc_id = parc.parc_id"
				+ " where (parc.parc_tmparcelamento between :inicio and :fim)" + " and parc.parc_vljurosparcelamento <> 0.00"
				+ " and debitoCobrar.dbtp_id = 44)";

		try {
			retorno = session.createSQLQuery(sql).addScalar("idParcelamento", Hibernate.INTEGER)
					// 0
					.addScalar("numeroPrestacao", Hibernate.SHORT)
					// 1
					.addScalar("taxaJuros", Hibernate.BIG_DECIMAL)
					// 2
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 3
					.addScalar("idQuadra", Hibernate.INTEGER)
					// 4
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					// 5
					.addScalar("idSetor", Hibernate.INTEGER)
					// 6
					.addScalar("codigoSetor", Hibernate.INTEGER)
					// 7
					.addScalar("lote", Hibernate.SHORT)
					// 8
					.addScalar("subLote", Hibernate.SHORT)
					// 9
					.addScalar("valorJurosParcelamento", Hibernate.BIG_DECIMAL)
					// 10
					.addScalar("idImovel", Hibernate.INTEGER)
					// 11
					.setDate("inicio", Util.converteStringParaDate("22/02/2007")).setDate("fim", Util.converteStringParaDate("24/02/2007"))
					.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a colecao de ação de cobrança passando o id da acao precedente
	 * 
	 * 
	 * 
	 * @author Sávio Luiz
	 * @created 27/02/2007
	 * 
	 * @param idCobracaoAcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesqsuisarAcaoCobrancaPelaPrecedente(Integer idCobracaoAcao) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select docTipo.id,cobAcao.numeroDiasValidade " + "from CobrancaAcao cobAcao  "
					+ "inner join cobAcao.documentoTipo docTipo " + "left join cobAcao.cobrancaAcaoPredecessora cobAcaoPrede "
					+ "where cobAcaoPrede.id = :idCobracaoAcao ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idCobracaoAcao", idCobracaoAcao).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Obtém a menor data de pagamento para as guias de pagamento
	 * 
	 * [UC0302] Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 19/03/2007
	 * 
	 * @param idGuiaPagamento
	 * @param idImovel
	 * @param idDebitoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentoGuiaPagamento(Integer idGuiaPagamento, Integer idImovel, Integer idDebitoTipo)
			throws ErroRepositorioException {

		Date retorno = null;
		Date data1 = null;
		Date data2 = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT MIN(pgmt.dataPagamento) FROM Pagamento pgmt " 
					+ "INNER JOIN pgmt.guiaPagamento gpagGeral "
					+ "INNER JOIN gpagGeral.guiaPagamento gpag "
					+ "INNER JOIN gpag.imovel imov " + "WHERE gpag.id = :idGuiaPagamento ";

			data1 = (Date) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).uniqueResult();

			consulta = "SELECT MIN(pgmt.dataPagamento) FROM Pagamento pgmt " 
					+ "INNER JOIN pgmt.guiaPagamento gpagGeral "
					+ "INNER JOIN gpagGeral.guiaPagamento gpag "
					+ "INNER JOIN gpag.imovel imov " + "WHERE pgmt.imovel.id= :idImovel and pgmt.debitoTipo.id = :idDebitoTipo";

			data2 = (Date) session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idDebitoTipo", idDebitoTipo)
					.uniqueResult();

			if (data2 == null) {
				retorno = data1;
			} else {
				if (data1 == null) {
					retorno = data2;
				} else {
					if (data1.before(data2)) {
						retorno = data1;
					} else {
						retorno = data2;
					}
				}
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * obtem o numero de Consumo Faturado Mes CSHI_NNCONSUMOFATURADOMES da
	 * tabela CONSUMO_HISTORICO com IMOV_ID = IMOV_ID da tabela CONTA e o maior
	 * mês/ano de consumo(CSHI_AMFATURAMENTO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 19/03/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterNumeroConsumoFaturadoMes(Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select consumoHistorico.numeroConsumoFaturadoMes " + "from ConsumoHistorico consumoHistorico "
					+ "where consumoHistorico.imovel.id = :idImovel " + "order by consumoHistorico.referenciaFaturamento desc";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) conta(s) parceladas já estão no histórico [UC0252]
	 * Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarContaHistoricoParcelamento(Integer idImovel, Integer idParcelamento) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from " + "ParcelamentoItem as parcItem "
					+ "inner join parcItem.contaGeral as cntaGeral " + "left join cntaGeral.contaHistorico cntaHist "
					+ "where cntaHist.imovel.id = :idImovel and " + "parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) debito(s) a cobrar parcelados já estão no histórico
	 * [UC0252] Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarDebitoACobrarHistoricoParcelamento(Integer idImovel, Integer idParcelamento) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from " + "ParcelamentoItem as parcItem "
					+ "inner join parcItem.debitoACobrarGeral as dbacGeral " + "left join dbacGeral.debitoACobrarHistorico dbacHist "
					+ "where dbacHist.imovel.id = :idImovel " + "and parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) credito(s) a realizar utilizados no parcelados já estão
	 * no histórico [UC0252] Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarCreditoARealizarHistoricoParcelamento(Integer idImovel, Integer idParcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from " + "ParcelamentoItem as parcItem "
					+ "inner join parcItem.creditoARealizarGeral as cdarGeral " + "left join cdarGeral.creditoARealizarHistorico cdarHist "
					+ "where cdarHist.imovel.id = :idImovel " + "and parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * retorna referenciaContabil da conta cancelada por retificação [UC0252]
	 * Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 13/04/2007
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCanceladaRetificacao(Integer idImovel, int anoMesReferencia) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select conta.referenciaContabil " + "from Conta conta " + "where conta.imovel = :idImovel and "
					+ "conta.referencia = :anoMesReferencia and " + "conta.debitoCreditoSituacaoAtual.id = :debitoCreditoSituacaoAtual ";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("debitoCreditoSituacaoAtual", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna o objeto ParcelamentoFaixaValor com o valor do debito(valorFaixa)
	 * com desconto maior q o da faixa e menor que próxima faixa
	 * 
	 * [UC0575] - Emitir Parcelamento em Atraso
	 * 
	 * @author Sávio Luiz
	 * @date 14/04/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosParcelamentoComMaiorTimestemp(Integer idImovel) throws ErroRepositorioException {

		Object[] retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parc.parcelamento, "// 0
					+ "parc.valorConta, "// 1
					+ "parc.valorServicosACobrar, "// 2
					+ "parc.valorAtualizacaoMonetaria, "// 3
					+ "parc.valorJurosMora, "// 4
					+ "parc.valorMulta, "// 5
					+ "parc.valorDescontoAcrescimos, "// 6
					+ "parc.valorDescontoAntiguidade, "// 7
					+ "parc.valorDescontoInatividade, "// 8
					+ "parc.valorEntrada, "// 9
					+ "parc.numeroPrestacoes, "// 10
					+ "parc.valorPrestacao, "// 11
					+ "parc.valorJurosParcelamento, "// 12
					+ "parc.id "// 13
					+ "FROM Parcelamento parc " + "INNER JOIN parc.imovel imov "
					+ "INNER JOIN parc.parcelamentoSituacao parcSit "
					+ "WHERE imov.id = :idImovel AND parcSit.id = :parcNormal " + "ORDER BY parc.parcelamento desc ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel)
					.setInteger("parcNormal", ParcelamentoSituacao.NORMAL).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Ana Maria
	 * @created 13/04/2007
	 * 
	 * @param idCliente
	 * @param numeroSequencialDocumento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarCobrancaDocumentoItemCliente(Integer idCliente, int numeroSequencialDocumento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "// 12
					+ "imov.id, "// 13
					+ "imovGuia.id, "// 14
					+ "imovDebito.id, "// 15
					+ "localidadeConta.id, "// 16
					+ "localidadeGuiaPagamento.id, "// 17
					+ "localidadeDebitoACobrar.id, "// 18
					+ "imovelHistorico.id, "// 19
					+ "localidadeContaHistorico.id, "// 20
					+ "imovGuiaHistorico.id, "// 21
					+ "localidadeGuiaPagamentoHistorico.id, "// 22
					+ "imovDebitoHistorico.id, "// 23
					+ "localidadeDebitoACobrarHistorico.id, "// 24
					+ "cd.id, "// 25
					+ "documentoTipo.id, "// 26
					+ "debitoACobrar.numeroPrestacaoDebito, " // 27
					+ "debitoACobrar.numeroPrestacaoCobradas, " // 28
					+ "cage.id, " // 29
					+ "localidade.id, " // 30
					+ "imovel.id "// 31

					+ "FROM CobrancaDocumentoItem cdi " + "LEFT JOIN cdi.cobrancaDocumento cd " + "LEFT JOIN cd.cliente clie "
					+ "LEFT JOIN cd.documentoTipo documentoTipo " + "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN conta.imovel imov " + "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN contaHistorico.imovel imovelHistorico " + "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN guiaPagamento.imovel imovGuia "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN guiaPagamentoHistorico.imovel imovGuiaHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar " + "LEFT JOIN debitoACobrar.imovel imovDebito "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN debitoACobrarHistorico.imovel imovDebitoHistorico " + "LEFT JOIN conta.localidade localidadeConta "
					+ "LEFT JOIN contaHistorico.localidade localidadeContaHistorico "
					+ "LEFT JOIN guiaPagamento.localidade localidadeGuiaPagamento "
					+ "LEFT JOIN guiaPagamentoHistorico.localidade localidadeGuiaPagamentoHistorico "
					+ "LEFT JOIN debitoACobrar.localidade localidadeDebitoACobrar "
					+ "LEFT JOIN debitoACobrarHistorico.localidade localidadeDebitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage " + "LEFT JOIN cd.localidade localidade " + "LEFT JOIN cd.imovel imovel "

					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND " + "clie.id = :idCliente";

			retorno = session.createQuery(consulta).setInteger("numeroSequencialDocumento", numeroSequencialDocumento)
					.setInteger("idCliente", idCliente.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta o id e a situação da ordem de serviço associada ao documento de
	 * cobrança passado como parâmetro
	 * 
	 * @author Sávio Luiz
	 * @created 13/04/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object[] pesquisarDadosOrdemServicoDocumentoCobranca(Integer idDocumentoCobranca) throws ErroRepositorioException {

		Object[] retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select os.id,os.situacao from OrdemServico os " + "inner join os.cobrancaDocumento cobrancaDoc "
					+ "where cobrancaDoc.id = :idDocumentoCobranca ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idDocumentoCobranca", idDocumentoCobranca).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsParcelamentosItemDebitoACobrar(Collection idsDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select parcelamentoItem.id" + " from ParcelamentoItem parcelamentoItem "
					+ " where parcelamentoItem.debitoACobrarGeral.id in (:idsDebitoACobrar)";

			retorno = session.createQuery(consulta).setParameterList("idsDebitoACobrar", idsDebitoACobrar).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsCobrancaDocumentoItemDebitoACobrar(Collection idsDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaDocumentoItem.id" + " from CobrancaDocumentoItem cobrancaDocumentoItem "
					+ " where cobrancaDocumentoItem.debitoACobrarGeral.id in (:idsDebitoACobrar)";

			retorno = session.createQuery(consulta).setParameterList("idsDebitoACobrar", idsDebitoACobrar).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarCobrancaDocumentoItemDebitoACobrar(Collection idsDocumentoItemDebitoACobrar) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.id in (:idsDocumentoItemDebitoACobrar) ";

			session.createQuery(consulta).setParameterList("idsDocumentoItemDebitoACobrar", idsDocumentoItemDebitoACobrar).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarParcelamentosItemDebitoACobrar(Collection idsParcelamentosItemDebitoACobrar) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String atualizarImovel = "update gcom.cobranca.parcelamento.ParcelamentoItem "
					+ "set dbac_id = null where pcit_id in (:idsParcelamentosItemDebitoACobrar)";

			session.createQuery(atualizarImovel).setParameterList("idsParcelamentosItemDebitoACobrar", idsParcelamentosItemDebitoACobrar)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author Sávio Luiz,Vivianne Sousa
	 * @date 17/10/2006,30/08/2010
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoAgrupadoPorDataPrevista(int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			// CRC4529 - query alterada por Vivianne Sousa - 30/08/2010

			consulta = " select"
					+ " (select osfs.fzst_id"
					+ " from atendimentopublico.ordem_servico_fisc_sit osfs"
					+ " inner join atendimentopublico.ordem_servico orse on osfs.orse_id = orse.orse_id"
					+ " where orse.cbdo_id  = cbdo.cbdo_id "
					+ " order by osfs_dtfiscalizacaosituacao limit 1 ) as idFiscalizacaoSit,"// 0
					+ " cbdo.cbdo_icantesapos as indAntesApos,"// 1
					+ " cbdo.cbdo_icacimalimite as indAcimaLimite,"// 2
					+ " casit.cast_id as idCobrancaAcaoSit,"// 3
					+ " cdst.cdst_id as idCobrancaDebitoSit,"// 4
					+ " catg.catg_id as idCategoria,"// 5
					+ " epod.epod_id as idEsferaPoder,"// 6
					+ " cbct.cbct_id as idCobrancaCriterio,"// 7
					+ " greg.greg_id as idGerencia,"// 8
					+ " loca.loca_id as idLocalidade,"// 9
					+ " stcm.stcm_id as idSetor,"// 10
					+ " rota.rota_id as idRota,"// 11
					+ " qdra.qdra_id as idQuadra,"// 12
					+ " qdra.qdra_nnquadra as numeroQuadra,"// 13
					+ " stcm.stcm_cdsetorcomercial as codigoSetor,"// 14
					+ " iper.iper_id as idPerfilImovel,"// 15
					+ " coalesce(last.last_id,imov.last_id) as idLigacaoAguaSit,"// 16
					+ " coalesce(lest.lest_id,imov.lest_id) as idLigacaoEsgotoSit,"// 17
					+ " empr.empr_id as idEmpresa,"// 18
					+ " amen.amen_id as idAtendMotivoEnc,"// 19
					+ " loca.uneg_id as idUnidadeNegocio,"// 20
					+ " cbdo.demf_id as idDocEmissaoForma,"// 21
					+ " count(cbdo.cbdo_id) as qtdeCobrancaDocumento,"// 22
					+ " sum(cbdo.cbdo_vldocumento) as valorCobrancaDoc"// 23
					+ " from"
					+ " cobranca.cobranca_documento cbdo"
					+ " left outer join cadastro.esfera_poder epod 				on cbdo.epod_id=epod.epod_id"
					+ " left outer join cobranca.cobranca_acao_situacao casit 			on cbdo.cast_id=casit.cast_id"
					+ " left outer join cobranca.cobranca_debito_situacao cdst 			on cbdo.cdst_id=cdst.cdst_id"
					+ " left outer join cadastro.categoria catg 				on cbdo.catg_id=catg.catg_id"
					+ " left outer join cobranca.cobranca_acao_ativ_crg caac 		on cbdo.caac_id=caac.caac_id"
					+ " left outer join cobranca.cobranca_acao_cronograma cbcr 			on caac.cbcr_id=cbcr.cbcr_id"
					+ " left outer join cobranca.cobranca_acao cbac 				on cbcr.cbac_id=cbac.cbac_id"
					+ " left outer join cobranca.cobranca_grupo_crg_mes cbcm 		on cbcr.cbcm_id=cbcm.cbcm_id"
					+ " left outer join cobranca.cobranca_grupo cbgr 				on cbcm.cbgr_id=cbgr.cbgr_id"
					+ " left outer join cobranca.cobranca_criterio cbct 			on cbdo.cbct_id=cbct.cbct_id"
					+ " left outer join cadastro.imovel imov 					on cbdo.imov_id=imov.imov_id"
					+ " left outer join cadastro.localidade loca 				on imov.loca_id=loca.loca_id"
					+ " left outer join cadastro.gerencia_regional greg 			on loca.greg_id=greg.greg_id"
					+ " left outer join cadastro.setor_comercial stcm 				on imov.stcm_id=stcm.stcm_id"
					+ " left outer join cadastro.quadra qdra 					on imov.qdra_id=qdra.qdra_id"
					+ " left outer join micromedicao.rota rota 					on qdra.rota_id=rota.rota_id"
					+ " left outer join cadastro.imovel_perfil iper 				on imov.iper_id=iper.iper_id"
					+ " left outer join atendimentopublico.ligacao_esgoto_situacao lest  	on cbdo.lest_id=lest.lest_id"
					+ " left outer join atendimentopublico.ligacao_agua_situacao last 		on cbdo.last_id=last.last_id"
					+ " left outer join cadastro.empresa empr 					on cbdo.empr_id=empr.empr_id"
					+ " left outer join atendimentopublico.atend_motivo_encmt amen on cbdo.amen_id=amen.amen_id"
					+ " where"
					+ " caac.caac_id= :idCobrancaAtividadeAcaoCronograma"
					+ " group by"
					+ " idFiscalizacaoSit,cbdo.cbdo_icantesapos ,cbdo.cbdo_icacimalimite ,casit.cast_id ,cdst.cdst_id ,catg.catg_id ,"
					+ " cbcm.cbcm_amreferencia ,cbcr.cbcr_id,caac.caac_dtprevista,cbct.cbct_id ,cbgr.cbgr_id ,greg.greg_id ,"
					+ " loca.loca_id ,stcm.stcm_id ,rota.rota_id ,qdra.qdra_id ,qdra.qdra_nnquadra ,stcm.stcm_cdsetorcomercial,iper.iper_id ,"
					+ " last.last_id ,lest.lest_id ,epod.epod_id ,cbac.cbac_id ,empr.empr_id ,amen.amen_id ,loca.uneg_id ,imov.last_id ,imov.lest_id, cbdo.demf_id"
					+ " order by" + " idFiscalizacaoSit,cbdo.cbdo_icantesapos,cbdo.cbdo_icacimalimite,casit.cast_id,cdst.cdst_id,"
					+ " catg.catg_id,epod.epod_id,greg.greg_id,loca.uneg_id,loca.loca_id,stcm.stcm_id,rota.rota_id,"
					+ " qdra.qdra_id,qdra.qdra_nnquadra,stcm.stcm_cdsetorcomercial,iper.iper_id,last.last_id,lest.lest_id";

			retorno = session.createSQLQuery(consulta).addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT).addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER).addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER).addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER).addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("idRota", Hibernate.INTEGER).addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idPerfilImovel", Hibernate.INTEGER).addScalar("idLigacaoAguaSit", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER).addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("idAtendMotivoEnc", Hibernate.INTEGER).addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("idDocEmissaoForma", Hibernate.INTEGER).addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL)
					.setInteger("idCobrancaAtividadeAcaoCronograma", idCobrancaAtividadeAcaoCronograma).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id, coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id),emp.id,moen.id, loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeCronograma cobAcaoAtivCron "
			// +
			// "left join cobAcaoAtivCron.cobrancaAcaoCronograma cobAcaoCronog "
			// + "left join cobAcaoCronog.cobrancaAcao cobAcao "
			// +
			// "left join cobAcaoCronog.cobrancaGrupoCronogramaMes cobGrupCronogramaMes "
			// + "left join cobGrupCronogramaMes.cobrancaGrupo cobGrupo "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join cobrancaDocumento.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivCron.id = :idCobrancaAtividadeAcaoCronograma "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// +
			// "cobAcaoSit.id,cobDebSit.id,categ.id,cobGrupCronogramaMes.anoMesReferencia,cobAcaoCronog.id,"
			// +
			// "cobAcaoAtivCron.dataPrevista,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.unidadeNegocio.id, loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id ";
			//
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoCronograma",
			// idCobrancaAtividadeAcaoCronograma).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author Sávio Luiz,Vivianne Sousa, Ivan Sergio
	 * @date 17/10/2006,30/08/2010, 23/12/2010
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoAgrupadoPorDataComando(int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// CRC4529 - query alterada por Vivianne Sousa - 30/08/2010

			consulta = " SELECT temp.fzst_id                   AS idfiscalizacaosit,"
					+ " cbdo.cbdo_icantesapos               AS indantesapos," + " cbdo.cbdo_icacimalimite             AS indacimalimite,"
					+ " casit.cast_id                       AS idcobrancaacaosit,"
					+ " cdst.cdst_id                        AS idcobrancadebitosit,"
					+ " catg.catg_id                        AS idcategoria," + " epod.epod_id                        AS idesferapoder,"
					+ " cbct.cbct_id                        AS idcobrancacriterio," + " greg.greg_id                        AS idgerencia,"
					+ " loca.loca_id                        AS idlocalidade," + " stcm.stcm_id                        AS idsetor,"
					+ " rota.rota_id                        AS idrota," + " qdra.qdra_id                        AS idquadra,"
					+ " qdra.qdra_nnquadra                  AS numeroquadra," + " stcm.stcm_cdsetorcomercial          AS codigosetor,"
					+ " iper.iper_id                        AS idperfilimovel,"
					+ " COALESCE(LLAST.last_id,imov.last_id) AS idligacaoaguasit,"
					+ " COALESCE(lest.lest_id,imov.lest_id) AS idligacaoesgotosit," + " empr.empr_id                        AS idempresa,"
					+ " amen.amen_id                        AS idatendmotivoenc,"
					+ " loca.uneg_id                        AS idunidadenegocio,"
					+ " cbdo.demf_id                        AS iddocemissaoforma,"
					+ " COUNT(cbdo.cbdo_id)                 AS qtdecobrancadocumento,"
					+ " SUM(cbdo.cbdo_vldocumento)          AS valorcobrancadoc,"

					+ " case when (svtp.SVTP_NNCODIGOCONSTANTE = "
					+ ServicoTipo.TIPO_CORTE_LIGACAO_AGUA
					+ " and"
					+ " cbac.cbac_id = "
					+ CobrancaAcao.CORTE_FISICO
					+ " and"
					+ " casit.cast_id = "
					+ CobrancaAcaoSituacao.EXECUTADA
					+ ") then"
					+ " 		cotp.cotp_id"
					+ " end 								   AS idCorteTipo"

					+ " FROM cobranca.cobranca_documento cbdo"
					+ " LEFT OUTER JOIN"
					+ " ("
					+ " SELECT osfs.fzst_id,"
					+ "        osfs.OSFS_DTFISCALIZACAOSITUACAO,"
					+ "        cbdo.cbdo_id "
					+ "   FROM cobranca.cobranca_acao_ativ_crg caac,"
					+ "       cobranca.cobranca_documento cbdo,"
					+ "       atendimentopublico.ordem_servico orse,"
					+ "       atendimentopublico.ordem_servico_fisc_sit osfs"
					+ "  WHERE "
					+ "    caac.caac_id = :idCobrancaAtividadeAcaoCronograma"
					+ "    AND cbdo.caac_id = cbdo.caac_id"
					+ "    AND orse.cbdo_id = cbdo.cbdo_id"
					+ "    AND osfs.orse_id = orse.orse_id"
					+ " ) temp ON temp.cbdo_id = cbdo.cbdo_id"
					+ " LEFT OUTER JOIN cadastro.esfera_poder epod"
					+ " ON cbdo.epod_id=epod.epod_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_situacao casit"
					+ " ON cbdo.cast_id=casit.cast_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_debito_situacao cdst"
					+ " ON cbdo.cdst_id=cdst.cdst_id"
					+ " LEFT OUTER JOIN cadastro.categoria catg"
					+ " ON cbdo.catg_id=catg.catg_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_ativ_crg caac"
					+ " ON cbdo.caac_id=caac.caac_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_cronograma cbcr"
					+ " ON caac.cbcr_id=cbcr.cbcr_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao cbac"
					+ " ON cbcr.cbac_id=cbac.cbac_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_grupo_crg_mes cbcm"
					+ " ON cbcr.cbcm_id=cbcm.cbcm_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_grupo cbgr"
					+ " ON cbcm.cbgr_id=cbgr.cbgr_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_criterio cbct"
					+ " ON cbdo.cbct_id=cbct.cbct_id"
					+ " LEFT OUTER JOIN cadastro.imovel imov"
					+ " ON cbdo.imov_id=imov.imov_id"

					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua lagu"
					+ " ON imov.imov_id = lagu.lagu_id"
					+ " LEFT OUTER JOIN atendimentopublico.corte_tipo cotp"
					+ " ON lagu.cotp_id = cotp.cotp_id"
					+ " LEFT OUTER JOIN atendimentopublico.ordem_servico orse"
					+ " ON cbdo.cbdo_id = orse.cbdo_id"
					+ " LEFT OUTER JOIN atendimentopublico.servico_tipo svtp"
					+ " ON orse.svtp_id = svtp.svtp_id"

					+ " LEFT OUTER JOIN cadastro.localidade loca"
					+ " ON imov.loca_id=loca.loca_id"
					+ " LEFT OUTER JOIN cadastro.gerencia_regional greg"
					+ " ON loca.greg_id=greg.greg_id"
					+ " LEFT OUTER JOIN cadastro.setor_comercial stcm"
					+ " ON imov.stcm_id=stcm.stcm_id"
					+ " LEFT OUTER JOIN cadastro.quadra qdra"
					+ " ON imov.qdra_id=qdra.qdra_id"
					+ " LEFT OUTER JOIN micromedicao.rota rota"
					+ " ON qdra.rota_id=rota.rota_id"
					+ " LEFT OUTER JOIN cadastro.imovel_perfil iper"
					+ " ON imov.iper_id=iper.iper_id"
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_esgoto_situacao lest"
					+ " ON cbdo.lest_id=lest.lest_id"
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua_situacao LLAST"
					+ " ON cbdo.last_id=LLAST.last_id"
					+ " LEFT OUTER JOIN cadastro.empresa empr"
					+ " ON cbdo.empr_id=empr.empr_id"
					+ " LEFT OUTER JOIN atendimentopublico.atend_motivo_encmt amen"
					+ " ON cbdo.amen_id   =amen.amen_id"
					+ " WHERE caac.caac_id = :idCobrancaAtividadeAcaoCronograma "
					+ " GROUP BY temp.fzst_id,"
					+ "   cbdo.cbdo_icantesapos ,"
					+ "   cbdo.cbdo_icacimalimite ,"
					+ "   casit.cast_id ,"
					+ "   cdst.cdst_id ,"
					+ "   catg.catg_id ,"
					+ "   cbcm.cbcm_amreferencia ,"
					+ "   cbcr.cbcr_id ,"
					+ "   caac.caac_tmcomando ,"
					+ "   cbct.cbct_id ,"
					+ "   cbgr.cbgr_id ,"
					+ " 	 greg.greg_id ,"
					+ "   loca.loca_id ,"
					+ "   stcm.stcm_id ,"
					+ "   rota.rota_id ,"
					+ "   qdra.qdra_id ,"
					+ "   qdra.qdra_nnquadra ,"
					+ "   stcm.stcm_cdsetorcomercial ,"
					+ "   caac.caac_dtprevista ,"
					+ "   iper.iper_id ,"
					+ "   LLAST.last_id ,"
					+ "   lest.lest_id ,"
					+ "   epod.epod_id ,"
					+ "   cbac.cbac_id ,"
					+ "   empr.empr_id ,"
					+ "   amen.amen_id ,"
					+ "   loca.uneg_id ,"
					+ "   imov.last_id ,"
					+ "   imov.lest_id,"
					+ "   cbdo.demf_id,"

					+ "   case when (svtp.SVTP_NNCODIGOCONSTANTE = "
					+ ServicoTipo.TIPO_CORTE_LIGACAO_AGUA
					+ " and cbac.cbac_id = "
					+ CobrancaAcao.CORTE_FISICO
					+ " and casit.cast_id = "
					+ CobrancaAcaoSituacao.EXECUTADA
					+ ") then cotp.cotp_id end"

					+ " ORDER BY temp.fzst_id,"
					+ "   cbdo.cbdo_icantesapos,"
					+ "   cbdo.cbdo_icacimalimite,"
					+ "   casit.cast_id,"
					+ "   cdst.cdst_id,"
					+ "   catg.catg_id ,"
					+ "   epod.epod_id,"
					+ "   greg.greg_id,"
					+ "   loca.loca_id,"
					+ "   stcm.stcm_id,"
					+ "   rota.rota_id,"
					+ "   qdra.qdra_id,"
					+ "   qdra.qdra_nnquadra,"
					+ "   stcm.stcm_cdsetorcomercial," + "   iper.iper_id," + "   LLAST.last_id," + "   lest.lest_id";

			retorno = session.createSQLQuery(consulta).addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT).addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER).addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER).addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER).addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("idRota", Hibernate.INTEGER).addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idPerfilImovel", Hibernate.INTEGER).addScalar("idLigacaoAguaSit", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER).addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("idAtendMotivoEnc", Hibernate.INTEGER).addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("idDocEmissaoForma", Hibernate.INTEGER).addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL).addScalar("idCorteTipo", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoCronograma", idCobrancaAtividadeAcaoCronograma).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id,coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id),emp.id,moen.id, loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeCronograma cobAcaoAtivCron "
			// +
			// "left join cobAcaoAtivCron.cobrancaAcaoCronograma cobAcaoCronog "
			// + "left join cobAcaoCronog.cobrancaAcao cobAcao "
			// +
			// "left join cobAcaoCronog.cobrancaGrupoCronogramaMes cobGrupCronogramaMes "
			// + "left join cobGrupCronogramaMes.cobrancaGrupo cobGrupo "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join imov.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivCron.id = :idCobrancaAtividadeAcaoCronograma "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// +
			// "cobAcaoSit.id,cobDebSit.id,categ.id,cobGrupCronogramaMes.anoMesReferencia,cobAcaoCronog.id,"
			// +
			// "cobAcaoAtivCron.comando,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,cobAcaoAtivCron.dataPrevista,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id  "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id";
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoCronograma",
			// idCobrancaAtividadeAcaoCronograma).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * atualiza o sequencial de conta impressão
	 * 
	 * @author Sávio Luiz
	 * @date 18/05/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSequencialCobrancaDocumentoImpressao(Map<Integer, Integer> mapAtualizaSequencial) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = "update gcom.cobranca.CobrancaDocumento "
				+ "set cbdo_nnsequencialimpressao =:sequencialCobrancaDocumento ,cbdo_tmultimaalteracao = :dataAtual "
				+ "where cbdo_id = :idCobrancaDocumento ";
		if (mapAtualizaSequencial != null && !mapAtualizaSequencial.isEmpty()) {
			Iterator iteMapAtualizaSequencia = mapAtualizaSequencial.keySet().iterator();

			try {
				while (iteMapAtualizaSequencia.hasNext()) {
					Integer idCobrancaDocumento = (Integer) iteMapAtualizaSequencia.next();
					Integer sequencialCobrancaDocumento = mapAtualizaSequencial.get(idCobrancaDocumento);
					session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento)
							.setInteger("sequencialCobrancaDocumento", sequencialCobrancaDocumento).setDate("dataAtual", new Date())
							.executeUpdate();
				}
			} catch (HibernateException e) {
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				HibernateUtil.closeSession(session);

			}
		}

	}

	/**
	 * Pesquisar relação de protocolos de documentos de cobrança do cronograma
	 * 
	 * @author Ana Maria
	 * @date 15/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarProtocoloDocumentoCobrancaCronograma(Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " new "
					+ ProtocoloDocumentoCobrancaRelatorioHelper.class.getName()
					+ " ( "
					+ "greg.id, greg.nomeAbreviado, greg.nome, "
					+ "uneg.id, uneg.nome, loca.id, loca.descricao, "
					+ "cbdo.codigoSetorComercial, count(*), sum(cbdo.valorDocumento), "
					+ "min(cbdo.sequencialImpressao), max(cbdo.sequencialImpressao),"
					+ "empr.descricao) "
					+ "from CobrancaDocumento cbdo "
					+ "inner join cbdo.cobrancaAcaoAtividadeCronograma caac "
					+ "inner join caac.cobrancaAcaoCronograma cbcr "
					+ "inner join cbcr.cobrancaAcao cbac"
					+ "inner join cbdo.localidade loca "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join cbcr.cobrancaGrupoCronogramaMes cbcm "
					+ "inner join cbdo.empresa empr "
					+ "where caac.id = :idCobrancaAcaoAtividadeCronograma "
					+ "group by empr.id, greg.id, greg.nomeAbreviado, greg.nome, uneg.id, uneg.nome, loca.id, loca.descricao, cbdo.codigoSetorComercial, empr.descricao "
					+ "order by empr.id, greg.id, uneg.id, loca.id, cbdo.codigoSetorComercial";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeCronograma", idCobrancaAcaoAtividadeCronograma.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar relação de protocolos de documentos de cobrança do cronograma
	 * 
	 * @author Ana Maria
	 * @date 15/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarProtocoloDocumentoCobrancaEventual(Integer idCobrancaAcaoAtividadeComand) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " new "
					+ ProtocoloDocumentoCobrancaRelatorioHelper.class.getName()
					+ " ( "
					+ "greg.id, greg.nomeAbreviado, greg.nome, "
					+ "uneg.id, uneg.nome, loca.id, loca.descricao, "
					+ "cbdo.codigoSetorComercial, count(*), sum(cbdo.valorDocumento), "
					+ "min(cbdo.sequencialImpressao), max(cbdo.sequencialImpressao),"
					+ "empr.descricao) "
					+ "from CobrancaDocumento cbdo "
					+ "inner join cbdo.cobrancaAcaoAtividadeComando cacm "
					+ "inner join cacm.cobrancaAcao cbac "
					+ "inner join cbdo.localidade loca "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join cbdo.empresa empr "
					+ "where cacm.id = :idCobrancaAcaoAtividadeComand "
					+ "group by empr.id, greg.id, greg.nomeAbreviado, greg.nome, uneg.id, uneg.nome, loca.id, loca.descricao, cbdo.codigoSetorComercial, empr.descricao "
					+ "order by empr.id, greg.id, uneg.id, loca.id, cbdo.codigoSetorComercial";

			retorno = session.createQuery(consulta).setInteger("idCobrancaAcaoAtividadeComand", idCobrancaAcaoAtividadeComand.intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera a coleção de OS para o encerramento
	 * 
	 * [UC0478] - Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0007] - Determinar Situação da Ordem de Serviço
	 * 
	 * @author Sávio Luiz
	 * @date 28/05/2007
	 * 
	 * @throws ControladorException
	 */
	public void atualizarParmsOS(Collection colecaoIdsOS, Integer idMotivoEncerramento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {

			String atualizarOS = "";

			atualizarOS = "update gcom.atendimentopublico.ordemservico.OrdemServico " + "set orse_tmultimaalteracao = :ultimaAlteracao, "
					+ "amen_id = :idMotivoEncerramento, " + "orse_cdsituacao = :encerrado, " + "orse_tmencerramento = :dataEncerramento ";

			atualizarOS = atualizarOS + " where orse_id in (:idsOrdemServico)";

			if (colecaoIdsOS.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + colecaoIdsOS.size());

				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) colecaoIdsOS, 999);

				int qtdQuebras = 999;
				int indice = colecaoIdsOS.size() / qtdQuebras;
				if (colecaoIdsOS.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE  " + indice + " = " + particoes.get(i).size());

					session.createQuery(atualizarOS).setParameterList("idsOrdemServico", particoes.get(i))
							.setTimestamp("ultimaAlteracao", new Date()).setInteger("idMotivoEncerramento", idMotivoEncerramento)
							.setShort("encerrado", OrdemServico.SITUACAO_ENCERRADO).setTimestamp("dataEncerramento", new Date())
							.executeUpdate();
				}
			} else {
				session.createQuery(atualizarOS).setParameterList("idsOrdemServico", colecaoIdsOS)
						.setTimestamp("ultimaAlteracao", new Date()).setInteger("idMotivoEncerramento", idMotivoEncerramento)
						.setShort("encerrado", OrdemServico.SITUACAO_ENCERRADO).setTimestamp("dataEncerramento", new Date())
						.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera os dados de documento item
	 * 
	 * @author Sávio Luiz
	 * @created 29/05/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosCobrancaDocumentoItem(Integer idDocumentoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT "
					+ " contaG.indicadorHistorico,"// 0
					+ " guiaPagamentoG.indicadorHistorico,"// 1
					+ " debitoACobrarG.indicadorHistorico,"// 2
					+ " cdi.id,"// 3
					+ " cdi.valorItemCobrado,"// 4
					+ " contaG.id,"// 5
					+ " guiaPagamentoG.id,"// 6
					+ " debitoACobrarG.id "// 7
					+ "FROM CobrancaDocumentoItem cdi " + "LEFT JOIN cdi.cobrancaDocumento cd " + "LEFT JOIN cdi.contaGeral contaG "
					+ "LEFT JOIN cdi.guiaPagamentoGeral guiaPagamentoG " + "LEFT JOIN cdi.debitoACobrarGeral  debitoACobrarG "
					+ "WHERE cd.id = :idDocumentoCobranca ";

			retorno = session.createQuery(consulta).setInteger("idDocumentoCobranca", idDocumentoCobranca).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00609] Transferencia de Debitos/Creditos
	 * 
	 * [FS0004] Validar Registro Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @created 05/06/2007
	 * 
	 * @param idRA
	 * @exception ErroRepositorioException
	 */
	public Object[] pesquisarRegistroAtendimentoTransferenciaDebitoCredito(Integer idRA) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;

		String consulta = null;

		try {

			consulta = "SELECT "
					+ " rgat.id," // 0
					+ " step.id,"// 1
					+ " step.descricao,"// 2
					+ " imov.id," // 3
					+ " rgat.codigoSituacao " // 4
					+ "FROM RegistroAtendimento rgat " + "INNER JOIN rgat.solicitacaoTipoEspecificacao step "
					+ "LEFT JOIN rgat.imovel imov " + "WHERE rgat.id = :idRA AND imov.indicadorExclusao <> :imovelExclusao ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idRA", idRA).setShort("imovelExclusao", Imovel.IMOVEL_EXCLUIDO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00609] Transferencia de Debitos/Creditos
	 * 
	 * [FS0004] Validar Registro Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @created 05/06/2007
	 * 
	 * @param idSolicitacaoTipoEspecificacao
	 * @exception ErroRepositorioException
	 */
	public EspecificacaoTipoValidacao pesquisarEspecificacaoTipoValidacaoTransferenciaDebitoCredito(Integer idSolicitacaoTipoEspecificacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		EspecificacaoTipoValidacao retorno = null;

		String consulta = null;

		try {

			consulta = "SELECT "
					+ " estv " // 0
					+ "FROM EspecificacaoTipoValidacao estv " + "INNER JOIN estv.solicitacaoTipoEspecificacao step "
					+ "WHERE step.id = :idSolicitacaoTipoEspecificacao AND " + " estv.codigoConstante = :transferenciaDebito ";

			retorno = (EspecificacaoTipoValidacao) session.createQuery(consulta)
					.setInteger("idSolicitacaoTipoEspecificacao", idSolicitacaoTipoEspecificacao)
					.setCharacter("transferenciaDebito", EspecificacaoTipoValidacao.TRANSFERENCIA_DEBITO).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar relação de parcelamento
	 * 
	 * @author Ana Maria
	 * @date 01/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<RelacaoParcelamentoRelatorioHelper> pesquisarRelacaoParcelamento(
			FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento) throws ErroRepositorioException {

		Collection<RelacaoParcelamentoRelatorioHelper> retorno = null;
		Collection<Object[]> retornoConsulta = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		String groupBy = " GROUP BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados().isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( l.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id as idMunicipio, \n  muni.muni_nmmunicipio as municipio";
			groupBy += "muni.muni_nmmunicipio, muni.muni_id, ";
			orderBy += " muni.muni_nmmunicipio, ";
		}
		Query query = null;

		Map parameters = new HashMap();

		try {
			consulta = " select pst.pcst_dsparcelamentosituacao AS situacao,"// 0
					+ " to_char(p.loca_id,'0000')||' - '||l.loca_nmlocalidade AS localidade,"// 1
					+ " UPPER(c.clie_nmcliente)AS cliente,"// 2
					+ " cf.cfon_cdddd AS ddd,"// 3
					+ " cf.cfon_nnfone AS fone,"// 4
					+ " substr(to_char(p.imov_id,'00000000'),1,8) ||'.'|| substr(to_char(p.imov_id,'00000000'),9,1) AS matricula,"// 5
					+ " p.parc_id AS idParcelamento,"// 6
					+ " p.parc_tmparcelamento AS dataParcelamento,"// 7
					+ " to_char(cnta.cnta_dtvencimentoconta, 'DD')AS vencimento,"// 8
					+ " p.parc_vldebitoatualizado AS valorDebito,"// 9
					+ " p.parc_vlentrada AS entrada,"// 10
					+ " p.parc_vlprestacao AS valorPrestacao,"// 11
					+ " p.parc_nnprestacoes AS numeroPrestacao,"// 12
					+ " p.loca_id as idLocalidade,"// 13
					+ " greg.greg_id as idGerencia, greg.greg_nmabreviado as gerencia,"// 14,15
					+ " unid.unid_dsunidade as unidade"// 16
					+ selectMunicipio
					+ " from cobranca.parcelamento p"
					+ " inner join faturamento.conta cnta ON p.imov_id = cnta.imov_id and p.parc_amreferenciafaturamento = cnta.cnta_amreferenciaconta"
					+ " inner join cadastro.cliente c ON c.clie_id = p.clie_id"
					+ " left join seguranca.usuario usur ON usur.usur_id = p.usur_id"
					+ " left join cadastro.unidade_organizacional unid ON usur.unid_id = unid.unid_id"
					+ " inner join cadastro.localidade l ON p.loca_id = l.loca_id"
					+ joinMunicipio
					+ " inner join cadastro.gerencia_regional greg on l.greg_id = greg.greg_id"
					+ " inner join cadastro.unidade_negocio uneg on l.uneg_id = uneg.uneg_id"
					+ " inner join cobranca.parcelamento_situacao pst ON p.pcst_id = pst.pcst_id"
					+ " left join cadastro.cliente_fone cf ON c.clie_id = cf.clie_id and cf.cfon_icfonepadrao = 1"
					+ " inner join cadastro.imovel imov ON p.imov_id = imov.imov_id " + " where 1=1";

			if (filtrarRelacaoParcelamento.getParcelamento().getParcelamentoSituacao().getId() != null) {
				consulta += " and p.pcst_id = :situacao ";
				parameters.put("situacao", filtrarRelacaoParcelamento.getParcelamento().getParcelamentoSituacao().getId());
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and p.loca_id = :idLocalidade ";
				parameters.put("idLocalidade", filtrarRelacaoParcelamento.getParcelamento().getLocalidade());
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and l.muni_idprincipal IN ( :idMunicipios )";
				parameters.put("idMunicipios", filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados());
				if (!temLocalidade) {
					consulta += " and p.loca_id = l.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getCodigoSetorComercial() != null) {
				consulta += " and p.parc_cdsetorcomercial = :codigoSetorComercial ";
				parameters.put("codigoSetorComercial", filtrarRelacaoParcelamento.getParcelamento().getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and p.parc_nnquadra = :numeroQuadra ";
				parameters.put("numeroQuadra", filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra());
			}

			if (filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null
					&& filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null) {
				consulta += " and p.parc_tmparcelamento between (:dataParcelamentoInicial) and (:dataParcelamentoFinal) ";
				parameters.put("dataParcelamentoInicial", filtrarRelacaoParcelamento.getDataParcelamentoInicial());
				parameters.put("dataParcelamentoFinal", filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if (filtrarRelacaoParcelamento.getValorDebitoInicial() != null && filtrarRelacaoParcelamento.getValorDebitoFinal() != null) {
				consulta += " and p.parc_vldebitoatualizado between (:valorDebitoInicial) and (:valorDebitoFinal) ";
				parameters.put("valorDebitoInicial", filtrarRelacaoParcelamento.getValorDebitoInicial());
				parameters.put("valorDebitoFinal", filtrarRelacaoParcelamento.getValorDebitoFinal());
			}

			if (filtrarRelacaoParcelamento.getIdGerencia() != null) {
				consulta += " and greg.greg_id = :idGerencia ";
				parameters.put("idGerencia", filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null) {
				consulta += " and uneg.uneg_id in (:idUnidadeNegocio) ";
				parameters.put("idUnidadeNegocio", filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdsMotivoDesfazimento() != null
					&& !filtrarRelacaoParcelamento.getIdsMotivoDesfazimento().isEmpty()) {
				consulta += " and p.pmdz_id in (:idsMotivoDesfazimento) ";
				parameters.put("idsMotivoDesfazimento", filtrarRelacaoParcelamento.getIdsMotivoDesfazimento());
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel().isEmpty()) {
				consulta += " and imov.iper_id in (:idsPerfisImovel) ";
				parameters.put("idsPerfisImovel", filtrarRelacaoParcelamento.getColecaoPerfilImovel());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel().equals("")) {
				consulta += " and p.usur_id = :idUsuario ";
			}

			// Coleção de Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional().equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional ";
				parameters.put("idUnidadeOrganizacional", filtrarRelacaoParcelamento.getIdUnidadeOrganizacional());
			}

			consulta += groupBy
					+ "p.parc_id, p.loca_id, l.loca_nmlocalidade, c.clie_nmcliente, pst.pcst_dsparcelamentosituacao, "
					+ "p.imov_id, p.parc_tmparcelamento, cnta.cnta_dtvencimentoconta, p.parc_vldebitoatualizado, p.parc_vlentrada, "
					+ "p.parc_vlprestacao, p.parc_nnprestacoes, cf.cfon_cdddd, cf.cfon_nnfone, greg.greg_id, greg.greg_nmabreviado, unid.unid_dsunidade "
					+ orderBy + " greg.greg_id, l.loca_nmlocalidade, vencimento  ASC, " + "valorDebito DESC, cliente, numeroPrestacao ASC ";

			query = session.createQuery(consulta);

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados())) {
				query = session.createSQLQuery(consulta).addScalar("situacao", Hibernate.STRING).addScalar("localidade", Hibernate.STRING)
						.addScalar("cliente", Hibernate.STRING).addScalar("ddd", Hibernate.STRING).addScalar("fone", Hibernate.STRING)
						.addScalar("matricula", Hibernate.STRING).addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("dataParcelamento", Hibernate.TIMESTAMP).addScalar("vencimento", Hibernate.STRING)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL).addScalar("numeroPrestacao", Hibernate.SHORT)
						.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerencia", Hibernate.INTEGER)
						.addScalar("gerencia", Hibernate.STRING).addScalar("unidade", Hibernate.STRING)
						.addScalar("idMunicipio", Hibernate.INTEGER).addScalar("municipio", Hibernate.STRING);

			} else {
				query = session.createSQLQuery(consulta).addScalar("situacao", Hibernate.STRING).addScalar("localidade", Hibernate.STRING)
						.addScalar("cliente", Hibernate.STRING).addScalar("ddd", Hibernate.STRING).addScalar("fone", Hibernate.STRING)
						.addScalar("matricula", Hibernate.STRING).addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("dataParcelamento", Hibernate.TIMESTAMP).addScalar("vencimento", Hibernate.STRING)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL).addScalar("numeroPrestacao", Hibernate.SHORT)
						.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerencia", Hibernate.INTEGER)
						.addScalar("gerencia", Hibernate.STRING).addScalar("unidade", Hibernate.STRING);
			}

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

			if (retornoConsulta.size() > 0) {
				retorno = new ArrayList();
				RelacaoParcelamentoRelatorioHelper helper = null;
				for (Iterator iter = retornoConsulta.iterator(); iter.hasNext();) {
					Object[] element = (Object[]) iter.next();
					helper = new RelacaoParcelamentoRelatorioHelper();
					helper.setSituacao((String) element[0]);
					helper.setLocalidade((String) element[1]);
					helper.setCliente((String) element[2]);
					if (element[3] != null) {
						helper.setDdd((String) element[3]);
						helper.setTelefone((String) element[4]);
					}
					helper.setMatricula((String) element[5]);
					helper.setParcelamento((Integer) element[6]);
					helper.setDataParcelamento((Date) element[7]);
					helper.setVencimento((String) element[8]);
					helper.setDebitoTotal((BigDecimal) element[9]);
					helper.setValorEntrada((BigDecimal) element[10]);
					helper.setValorParcelamento((BigDecimal) element[11]);
					helper.setNumeroParcelamento((Short) element[12]);
					helper.setIdLocalidade((Integer) element[13]);
					helper.setIdGerencia((Integer) element[14]);
					helper.setGerencia((String) element[15]);
					if (element[16] != null) {
						helper.setUnidade((String) element[16]);
					}

					if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados())) {
						helper.setIdMunicipio((Integer) element[17]);
						helper.setMunicipio((String) element[18]);
					}
					retorno.add(helper);
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * @author Sávio Luiz, Anderson Italo
	 * @created 15/06/2006, 25/02/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarCobrancaAcaoAtividadeComandoSemRealizacao() throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cacm.id,ca.id,servTipo.id,doctipo.id,cacm.dataEncerramentoPrevista," + " cacm.realizacao, cacm.comando "
					+ "from CobrancaAcaoAtividadeComando cacm " + " inner join cacm.cobrancaAcao ca"
					+ " left join ca.servicoTipo servTipo " + " left join ca.documentoTipo doctipo "
					+ "where cacm.dataEncerramentoRealizada is null and cacm.realizacao is not null";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta).list()));

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das ações de cobrança
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobrança
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Sávio Luiz
	 * @date 18/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<DadosPesquisaCobrancaDocumentoHelper> pesquisarCobrancaDocumentoEventual(int idCobrancaAtividadeAcaoComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id,"
					+ "cobrancaDocumento.emissao, " + "cobrancaDocumento.imovel.id, " + "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobCrit.percentualQuantidadeMinimoPagoParceladoCancelado, " + "cobCrit.valorLimitePrioridade)  "
					+ "from CobrancaDocumento cobrancaDocumento " + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "where cobrancaDocumento.cobrancaAcaoAtividadeComando.id = :idCobrancaAtividadeAcaoComando "
					+ "order by cobrancaDocumento.id";

			retorno = session.createQuery(consulta).setInteger("idCobrancaAtividadeAcaoComando", idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das ações de cobrança
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobrança
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Sávio Luiz
	 * @date 18/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarOrdemServicoEventual(int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select orse.orse_id as idOS," + " orse.orse_cdsituacao as codigoOS,"
					+ " orse.orse_dtfiscalizacaosituacao as dataFiscalizacao," + " orse.orse_tmencerramento as dataEncerramento,"
					+ " cob.cbdo_id as idCobDocumento," + " cob.cbdo_vldocumento as valorDocumento,"
					+ " cobCrit.cbct_pcvlminimopgparccanc as pec," + " cobCrit.cbct_pcqtminimopgparccanc as qdt,"
					+ " cobCrit.cbct_vllimiteprioridade as valorLimite," + " orse.fzst_id as idFiscalizacaoSit,"
					+ " atMotEnc.amen_icexecucao as indicadorExecucao," + " imov.imov_id as idImovel," + " imov.loca_id as idLocalidade, "
					+ " atMotEnc.amen_id as idMotivoEncerramento " + "from atendimentopublico.ordem_servico orse "
					+ "inner join cobranca.cobranca_documento cob on cob.cbdo_id = orse.cbdo_id "
					+ "    and cob.cacm_id = :idCobrancaAtividadeAcaoComando " + "left join cobranca.cobranca_criterio cobCrit "
					+ "     on cobCrit.cbct_id = cob.cbct_id " + "left join cadastro.imovel imov "
					+ "      on imov.imov_id = orse.imov_id " + "left join  atendimentopublico.atend_motivo_encmt atMotEnc "
					+ "      on atMotEnc.amen_id = orse.amen_id ";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("codigoOS", Hibernate.SHORT)
					.addScalar("dataFiscalizacao", Hibernate.DATE).addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("idCobDocumento", Hibernate.INTEGER).addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("pec", Hibernate.BIG_DECIMAL).addScalar("qdt", Hibernate.BIG_DECIMAL)
					.addScalar("valorLimite", Hibernate.BIG_DECIMAL).addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indicadorExecucao", Hibernate.SHORT).addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idMotivoEncerramento", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoComando", idCobrancaAtividadeAcaoComando)

					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das ações de cobrança
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 19/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void deletarResumoCobrancaAcaoEventual(int idCobrancaAcaoCronograma) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "delete ResumoCobrancaAcaoEventual resumoCobrancaAcaoEventual "
					+ "where resumoCobrancaAcaoEventual.cobrancaAcaoAtividadeComando.id = :idCobrancaAcaoCronograma ";

			session.createQuery(consulta).setInteger("idCobrancaAcaoCronograma", idCobrancaAcaoCronograma).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author Sávio Luiz
	 * @date 19/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoEventualAgrupadoPorDataPrevista(int idCobrancaAtividadeAcaoComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = " select temp.fzst_id as idFiscalizacaoSit," + " cbdo.cbdo_icantesapos as indAntesApos,"
					+ " cbdo.cbdo_icacimalimite as indAcimaLimite," + " casit.cast_id as idCobrancaAcaoSit,"
					+ " cdst.cdst_id as idCobrancaDebitoSit," + " catg.catg_id as idCategoria," + " epod.epod_id as idEsferaPoder,"
					+ " cbct.cbct_id as idCobrancaCriterio," + " cbgr.cbgr_id as idCobrancaGrupo," + " greg.greg_id as idGerencia,"
					+ " loca.loca_id as idLocalidade," + " stcm.stcm_id as idSetor," + " rota.rota_id as idRota,"
					+ " qdra.qdra_id as idQuadra," + " qdra.qdra_nnquadra as numeroQuadra," + " stcm.stcm_cdsetorcomercial as codigoSetor,"
					+ " iper.iper_id as idPerfilImovel," + " coalesce(llast.last_id,imov.last_id) as idLigacaoAguaSit,"
					+ " coalesce(lest.lest_id,imov.lest_id) as idLigacaoEsgotoSit," + " empr.empr_id as idEmpresa,"
					+ " amen.amen_id as idAtendMotivoEnc," + " loca.uneg_id as idUnidadeNegocio,"
					+ " count(cbdo.cbdo_id) as qtdeCobrancaDocumento," + " sum(cbdo.cbdo_vldocumento) as valorCobrancaDoc"
					+ " from cobranca.cobranca_documento cbdo" + "  LEFT OUTER JOIN" + " (" + " SELECT osfs.fzst_id,"
					+ " osfs.OSFS_DTFISCALIZACAOSITUACAO," + " cbdo.cbdo_id" + " FROM cobranca.cobranca_documento cbdo,"
					+ " atendimentopublico.ordem_servico orse," + " atendimentopublico.ordem_servico_fisc_sit osfs" + " WHERE "
					+ " cbdo.cacm_id = :idCobrancaAtividadeAcaoComando" + " AND orse.cbdo_id = cbdo.cbdo_id"
					+ " AND osfs.orse_id = orse.orse_id" + " ) temp ON temp.cbdo_id = cbdo.cbdo_id"
					+ " left outer join cadastro.esfera_poder epod                         on cbdo.epod_id=epod.epod_id"
					+ " left outer join cobranca.cobranca_acao_situacao casit             on cbdo.cast_id=casit.cast_id"
					+ " left outer join cobranca.cobranca_debito_situacao cdst             on cbdo.cdst_id=cdst.cdst_id"
					+ " left outer join cadastro.categoria catg                         on cbdo.catg_id=catg.catg_id"
					+ " left outer join cobranca.cobranca_acao_ativ_cmd cacm     on cbdo.cacm_id=cacm.cacm_id"
					+ " left outer join cobranca.cobranca_acao cbac                     on cacm.cbac_id=cbac.cbac_id"
					+ " left outer join cobranca.cobranca_criterio cbct                 on cbdo.cbct_id=cbct.cbct_id"
					+ " left outer join cadastro.imovel imov                             on cbdo.imov_id=imov.imov_id"
					+ " left outer join cadastro.localidade loca                         on imov.loca_id=loca.loca_id"
					+ " left outer join cadastro.gerencia_regional greg                 on loca.greg_id=greg.greg_id"
					+ " left outer join cadastro.setor_comercial stcm                     on imov.stcm_id=stcm.stcm_id"
					+ " left outer join cadastro.quadra qdra                             on imov.qdra_id=qdra.qdra_id"
					+ " left outer join micromedicao.rota rota                             on qdra.rota_id=rota.rota_id"
					+ " left outer join cobranca.cobranca_grupo cbgr                     on rota.cbgr_id=cbgr.cbgr_id"
					+ " left outer join cadastro.imovel_perfil iper                     on imov.iper_id=iper.iper_id"
					+ " left outer join atendimentopublico.ligacao_esgoto_situacao lest on cbdo.lest_id= lest.lest_id"
					+ " left outer join atendimentopublico.ligacao_agua_situacao llast     on cbdo.last_id= llast.last_id"
					+ " left outer join cadastro.empresa empr                             on cbdo.empr_id=empr.empr_id"
					+ " left outer join atendimentopublico.atend_motivo_encmt amen on cbdo.amen_id=amen.amen_id" + " where "
					+ "  cacm.cacm_id = :idCobrancaAtividadeAcaoComando" + " group by"
					+ " temp.fzst_id ,cbdo.cbdo_icantesapos ,cbdo.cbdo_icacimalimite ,"
					+ " casit.cast_id ,cdst.cdst_id ,catg.catg_id ,cacm.cacm_dtencerramentoprevista ,"
					+ " cbct.cbct_id ,cbgr.cbgr_id ,greg.greg_id ,loca.loca_id ,stcm.stcm_id ,"
					+ " rota.rota_id ,qdra.qdra_id ,qdra.qdra_nnquadra ,stcm.stcm_cdsetorcomercial ,"
					+ " iper.iper_id ,llast.last_id ,lest.lest_id ,epod.epod_id ,cbac.cbac_id ,empr.empr_id ,"
					+ " amen.amen_id ,loca.uneg_id ,imov.last_id ,imov.lest_id" + " order by"
					+ " temp.fzst_id,cbdo.cbdo_icantesapos,cbdo.cbdo_icacimalimite,casit.cast_id,"
					+ " cdst.cdst_id,catg.catg_id,epod.epod_id,greg.greg_id,loca.loca_id,stcm.stcm_id,"
					+ " rota.rota_id,qdra.qdra_id,qdra.qdra_nnquadra,stcm.stcm_cdsetorcomercial,"
					+ " iper.iper_id, llast.last_id,lest.lest_id ";

			retorno = session.createSQLQuery(consulta).addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT).addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER).addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER).addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER).addScalar("idCobrancaGrupo", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER).addScalar("idRota", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER).addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER).addScalar("idPerfilImovel", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSit", Hibernate.INTEGER).addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("idAtendMotivoEnc", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER).addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL)
					.setInteger("idCobrancaAtividadeAcaoComando", idCobrancaAtividadeAcaoComando).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id,coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id), emp.id,moen.id,loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeComando cobAcaoAtivComando "
			// + "left join cobAcaoAtivComando.cobrancaAcao cobAcao "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join rot.cobrancaGrupo cobGrupo "
			// + "left join imov.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivComando.id = :idCobrancaAtividadeAcaoComando "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,categ.id,"
			// +
			// "cobAcaoAtivComando.dataEncerramentoPrevista,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id  "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id ";
			//
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoComando",
			// idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das ações de cobrança
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 19/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaAcaoAtividadeComando(int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		try {
			atualizar = "update gcom.cobranca.CobrancaAcaoAtividadeComando "
					+ " set cacm_dtencerramentorealizada = :dataRealizacao,cacm_tmultimaalteracao = :dataAtual "
					+ " where cacm_id = :idCobrancaAtividadeAcaoComando";

			session.createQuery(atualizar).setInteger("idCobrancaAtividadeAcaoComando", idCobrancaAtividadeAcaoComando)
					.setDate("dataRealizacao", new Date()).setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * Gerar Curva ABC de Debitos
	 * 
	 * [UC0621] Gerar Curva ABC de Debitos
	 * 
	 * @author Ivan Sérgio
	 * @date 01/08/2007
	 * 
	 */
	public Collection gerarCurvaAbcDebitos(String classificacao, String indicadorImovelMedicaoIndividualizada,
			String indicadorImovelParalizacaoFaturamentoCobranca, String[] gerenciaRegional, String idLocalidadeInicial,
			String idLocalidadeFinal, String idSetorComercialInicial, String idSetorComercialFinal, String idMunicipio,
			String[] situacaoLigacaoAgua, String[] situacaoLigacaoEsgoto, String intervaloConsumoMinimoFixadoEsgotoInicial,
			String intervaloConsumoMinimoFixadoEsgotoFinal, String indicadorMedicao, String idTipoMedicao, String idPerfilImovel,
			String idTipoCategoria, String[] categoria, String idSubCategoria) throws ErroRepositorioException {

		List retorno = null;
		Session session = HibernateUtil.getSession();
		String hqlAux = "";
		String orderBy = "";
		String joinMunicipio = " left join localidade.municipio municipio ";
		if (idMunicipio != null && !idMunicipio.equals("")) {
			joinMunicipio = " inner join localidade.municipio municipio ";
		}
		boolean finaliza = false;

		try {
			String hql = "select distinct" + "	imovel.id, " + "	ligacaoAguaSituacao.id, " + "	ligacaoAgua.dataCorte, "
					+ "	ligacaoAgua.dataSupressao, " + "	gerenciaRegional.id, " + "	gerenciaRegional.nomeAbreviado, "
					+ "	gerenciaRegional.nome, " + "	localidade.id, " + "	localidade.descricao, " + "   municipio.id, "
					+ "	municipio.nome, " + "	setorComercial.id, " + "	setorComercial.codigo, " + "	setorComercial.descricao, "
					+ "	categoria.descricao, " + "	subcategoria.descricao " +

					"from " + "	ImovelSubcategoria imovelSubcategoria " + "	inner join imovelSubcategoria.comp_id.imovel imovel "
					+ "	left  join imovelSubcategoria.comp_id.subcategoria subcategoria " + "	left  join subcategoria.categoria categoria "
					+ " 	inner join imovel.localidade localidade " + joinMunicipio
					+ " 	inner join localidade.gerenciaRegional gerenciaRegional " + "	inner join imovel.setorComercial setorComercial "
					+ "	left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao " + " 	left  join imovel.ligacaoAgua ligacaoAgua "
					+ " 	left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " 	left  join imovel.ligacaoEsgoto ligacaoEsgoto "
					+ "	left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " 	left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel "
					+ " 	left  join imovel.imovelPerfil imovelPerfil " + "   Where ";

			// Aplica as Condicoes da consulta
			// **************************************

			// Classificacao
			if (classificacao.trim().equalsIgnoreCase("ESTADO")) {
				orderBy = "";
			} else if (classificacao.trim().equalsIgnoreCase("REGIONAL")) {
				orderBy = " Order By gerenciaRegional.id ";
			} else if (classificacao.trim().equalsIgnoreCase("LOCAL")) {
				orderBy = " Order By localidade.id ";
			} else if (classificacao.trim().equalsIgnoreCase("SETORCOMERCIAL")) {
				orderBy = " Order By setorComercial.id ";
			} else if (classificacao.trim().equalsIgnoreCase("MUNICIPIO")) {
				orderBy = " Order By municipio.nome ";
			}

			// gerenciaRegional
			if ((gerenciaRegional != null) && (gerenciaRegional.length > 0)) {
				if (gerenciaRegional.length == 1
						&& !gerenciaRegional[0].trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

					hql += "gerenciaRegional.id = " + gerenciaRegional[0] + " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < gerenciaRegional.length; i++) {
						if (!gerenciaRegional[i].trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

							hqlAux += gerenciaRegional[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "gerenciaRegional.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Localidade
			if ((idLocalidadeInicial != null && !idLocalidadeInicial.equals(""))
					&& (idLocalidadeFinal != null && !idLocalidadeFinal.equals(""))) {

				hql += "localidade.id >= " + idLocalidadeInicial + " and " + "localidade.id <= " + idLocalidadeFinal + " and ";
				finaliza = true;
			}

			// Setor Comercial Inicial e Final
			if ((idSetorComercialInicial != null && !idSetorComercialInicial.equals(""))
					&& (idSetorComercialFinal != null && !idSetorComercialFinal.equals(""))) {

				hql += "setorComercial.id >= " + idSetorComercialInicial + " and " + "setorComercial.id <= " + idSetorComercialFinal
						+ " and ";
				finaliza = true;
			}

			// Município
			if ((idMunicipio != null && !idMunicipio.equals(""))) {
				hql += "municipio.id = " + idMunicipio + " and ";
				finaliza = true;
			}

			// Imoveis com Medicao Individualizada
			if (indicadorImovelMedicaoIndividualizada.equals("1")) {
				hql += "imovel.imovelCondominio is not null and ";
				finaliza = true;
			}

			// Imoveis com Paralizacao de Faturamento/Cobranca
			if (indicadorImovelParalizacaoFaturamentoCobranca.equals("1")) {
				hql += "( (imovel.faturamentoSituacaoTipo.id in (1, 4, 5)) or ";
				// hql += "(imovel.cobrancaSituacao.id in (5, 7, 8, 9)) ) and ";
				hql += " (exists( select ics.id from ImovelCobrancaSituacao ics "
						+ " where ics.imovel.id = imovel.id  and ics.dataRetiradaCobranca is null "
						+ " and ics.cobrancaSituacao.id in (5, 7, 8, 9))) ) and ";
				finaliza = true;
			}

			// Situacao da Ligacao de Agua
			if ((situacaoLigacaoAgua != null) && (situacaoLigacaoAgua.length > 0)) {
				if (situacaoLigacaoAgua.length == 1
						&& !situacaoLigacaoAgua[0].trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

					hql += "ligacaoAguaSituacao.id = " + situacaoLigacaoAgua[0] + " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < situacaoLigacaoAgua.length; i++) {
						if (!situacaoLigacaoAgua[i].trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

							hqlAux += situacaoLigacaoAgua[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "ligacaoAguaSituacao.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Situacao da Ligacao de Esgoto
			if ((situacaoLigacaoEsgoto != null) && (situacaoLigacaoEsgoto.length > 0)) {
				if (situacaoLigacaoEsgoto.length == 1
						&& !situacaoLigacaoEsgoto[0].trim()
								.equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

					hql += "ligacaoEsgotoSituacao.id = " + situacaoLigacaoEsgoto[0] + " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < situacaoLigacaoEsgoto.length; i++) {
						if (!situacaoLigacaoEsgoto[i].trim().equalsIgnoreCase(
								new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

							hqlAux += situacaoLigacaoEsgoto[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "ligacaoEsgotoSituacao.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Intervalo de Consumo Minimo Fixado de Esgoto
			if ((intervaloConsumoMinimoFixadoEsgotoInicial != null) && (!intervaloConsumoMinimoFixadoEsgotoInicial.equals(""))
					&& (intervaloConsumoMinimoFixadoEsgotoFinal != null) && (!intervaloConsumoMinimoFixadoEsgotoFinal.equals(""))) {

				hql += "ligacaoEsgoto.consumoMinimo >= " + intervaloConsumoMinimoFixadoEsgotoInicial + " and ";
				hql += "ligacaoEsgoto.consumoMinimo <= " + intervaloConsumoMinimoFixadoEsgotoFinal + " and ";
				finaliza = true;
			}

			// indicador medição
			if (indicadorMedicao != null && indicadorMedicao.equals("comMedicao")) {
				// tipo medicao
				// [SF0001 - Selecionar os Imoveis por Tipo de Medicao]
				if (idTipoMedicao != null && idTipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA.toString())) {
					hql += "hidrometroInstalacaoHistorico.id is not null and ";
					finaliza = true;
				} else if (idTipoMedicao != null && idTipoMedicao.equals(MedicaoTipo.POCO.toString())) {
					hql += "hidrometroInstalacaoHistoricoImovel.id is not null and ";
					finaliza = true;
				} else {
					hql += "(hidrometroInstalacaoHistorico.id is not null or ";
					hql += "hidrometroInstalacaoHistoricoImovel.id is not null) and ";
					finaliza = true;
				}
			} else if (indicadorMedicao != null && indicadorMedicao.equals("semMedicao")) {
				hql += "(hidrometroInstalacaoHistorico.id is null and ";
				hql += "hidrometroInstalacaoHistoricoImovel.id is null) and ";
				finaliza = true;
			}

			// imovel Perfil
			if (idPerfilImovel != null && !idPerfilImovel.equals("")
					&& !idPerfilImovel.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

				hql += "imovelPerfil.id = " + idPerfilImovel + " and ";
				finaliza = true;
			}

			// categoria
			if (categoria == null) {

				if (idTipoCategoria != null && !idTipoCategoria.equals("") && idTipoCategoria.equals(CategoriaTipo.PARTICULAR.toString())) {
					hql += "( (categoria.id = " + Categoria.RESIDENCIAL_INT + ") or ";
					hql += "  (categoria.id = " + Categoria.COMERCIAL_INT + ") or ";
					hql += "  (categoria.id = " + Categoria.INDUSTRIAL_INT + ") ) and ";
					finaliza = true;
				} else if (idTipoCategoria != null && !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PUBLICO.toString())) {
					hql += "categoria.id = " + Categoria.PUBLICO_INT + " and ";
					finaliza = true;
				}

			} else if ((categoria.length == 1)
					&& (categoria[0].trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {

				if (idTipoCategoria != null && !idTipoCategoria.equals("") && idTipoCategoria.equals(CategoriaTipo.PARTICULAR.toString())) {
					hql += "( (categoria.id = " + Categoria.RESIDENCIAL_INT + ") or ";
					hql += "  (categoria.id = " + Categoria.COMERCIAL_INT + ") or ";
					hql += "  (categoria.id = " + Categoria.INDUSTRIAL_INT + ") ) and ";
					finaliza = true;
				} else if (idTipoCategoria != null && !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PUBLICO.toString())) {
					hql += "categoria.id = " + Categoria.PUBLICO_INT + " and ";
					finaliza = true;
				}

			} else {
				for (int i = 0; i < categoria.length; i++) {
					if (!categoria[i].trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

						hqlAux += categoria[i].toString() + ",";
					}
				}

				if (!hqlAux.equals("")) {
					hql += "categoria.id in (" + hqlAux;
					hqlAux = "";

					// Retira a ultima virgula e finaliza a condicao
					hql = hql.substring(0, hql.length() - 1) + ") and ";
					finaliza = true;
				}
			}

			// SubCategoria
			if (idSubCategoria != null && !idSubCategoria.equals("")
					&& !idSubCategoria.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {
				hql += "subcategoria.id = " + idSubCategoria + " and ";
				finaliza = true;
			} else if (idTipoCategoria != null && !idTipoCategoria.equals("")
					&& !idTipoCategoria.trim().equalsIgnoreCase(new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) {

				hql += "subcategoria.categoria.id = categoria.id and ";
				hql += "subcategoria.id = imovelSubcategoria.comp_id.subcategoria.id and ";
				finaliza = true;
			}

			// Finaliza a condicao
			if (finaliza) {
				hql = hql.substring(0, hql.length() - 5) + orderBy;
			} else {
				hql = hql.substring(0, hql.length() - 9) + orderBy;
			}
			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Ana Maria Data: 08/07/2007 Pesquisa os ID dos Imovéis pelo Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @return Coleção de Ids dos Imóveis
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsImoveisCliente(String codigoCliente) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imov.id " + "from ClienteImovel clieImov " + "inner join clieImov.imovel imov "
					+ "inner join clieImov.cliente clie " + "where clie.id = :codigoCliente";

			retorno = session.createQuery(consulta).setInteger("codigoCliente", new Integer(codigoCliente).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente Obtem os débitos dos imóveis
	 * Author: Ana Maria Data: 28/06/2006
	 * 
	 * @param idsImoveis
	 *            Matriculas dos Imoveis
	 * @param contaSituacaoNormal
	 *            Situação Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situação Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situação Incluída de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Coleção de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImoveis(Collection idsImoveis, int indicadorPagamento, int indicadorConta, String contaSituacaoNormal,
			String contaSituacaoRetificada, String contaSituacaoIncluida, String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito, String anoMesFinalReferenciaDebito, Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento  "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id in (:idsImoveis) "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE " + indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitos", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							.addScalar("dataRevisao", Hibernate.DATE).addScalar("referencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
							.addScalar("idSituacaoAtual", Hibernate.INTEGER).addScalar("digitoVerificador", Hibernate.SHORT)
							.addScalar("idMotivoRevisao", Hibernate.INTEGER).addScalar("ultimaAlteracao", Hibernate.DATE)
							.addScalar("idImovel", Hibernate.INTEGER).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("valorImpostos", Hibernate.BIG_DECIMAL).addScalar("consumoEsgoto", Hibernate.INTEGER)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("idParcelamento", Hibernate.INTEGER).setParameterList("idsImoveis", particoes.get(i))
							.setInteger("situacaoNormal", new Integer(contaSituacaoNormal))
							.setInteger("situacaoRetificada", new Integer(contaSituacaoRetificada))
							.setInteger("situacaoIncluida", new Integer(contaSituacaoIncluida))
							.setInteger("situacaoParcelada", new Integer(contaSituacaoParcelada))
							.setInteger("inicialReferencia", new Integer(anoMesInicialReferenciaDebito))
							.setInteger("finalReferencia", new Integer(anoMesFinalReferenciaDebito))
							.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
							.setDate("finalVencimento", anoMesFinalVencimentoDebito).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE).addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER).addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER).addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER).addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL).addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER).setParameterList("idsImoveis", idsImoveis)
						.setInteger("situacaoNormal", new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada", new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida", new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada", new Integer(contaSituacaoParcelada))
						.setInteger("inicialReferencia", new Integer(anoMesInicialReferenciaDebito))
						.setInteger("finalReferencia", new Integer(anoMesFinalReferenciaDebito))
						.setDate("inicialVencimento", anoMesInicialVecimentoDebito).setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Ana Maria Data:
	 * 08/08/2007
	 * 
	 * @param idImoveis
	 *            Matriculas dos Imoveis
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @param situacaoNormal
	 *            Situação Normal
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @return Coleção de Guias de Pagamentos
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoIdsImoveis(Integer idCliente, Collection idsImoveis, int indicadorPagamento,
			String situacaoNormal, Date dataVencimentoInicial, Date dataVencimentoFinal) throws ErroRepositorioException {
		Collection retorno = new ArrayList();
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento, "
					+ " guia.dotp_id as idDocumentoTipo " + "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id " + "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal, guia.dotp_id ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0 ";
			}

			if (idsImoveis != null && !idsImoveis.isEmpty()) {

				consulta += "UNION ";

				consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
						+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
						+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
						+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
						+ "debTipo.dbtp_id as idDebitoTipo, "
						+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
						+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento, "
						+ " guia.dotp_id as idDocumentoTipo " + "FROM faturamento.guia_pagamento guia "
						+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
						+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id " + "WHERE guia.imov_id in (:idsImoveis) "
						+ "and guia.dcst_idatual = :situacaoNormal "
						+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

				consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
						+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal, guia.dotp_id ";

				if (indicadorPagamento == 1) {
					consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0 ";
				}

				if (idsImoveis.size() > 999) {

					System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

					List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsImoveis, 999);

					int qtdQuebras = 999;
					int indice = idsImoveis.size() / qtdQuebras;

					if (idsImoveis.size() % qtdQuebras != 0) {
						indice++;
					}

					System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

					for (int i = 0; i < indice; i++) {

						System.out.println("## TAMANHO PARTIÇÃO DE INDICE " + indice + " = " + particoes.get(i).size());

						Collection retornoPart = null;

						retornoPart = session.createSQLQuery(consulta).addScalar("idGuia", Hibernate.INTEGER)
								.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("anoMesReferencia", Hibernate.INTEGER)
								.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
								.addScalar("descricaoDebitoTipo", Hibernate.STRING).addScalar("dataEmissao", Hibernate.DATE)
								.addScalar("idDebitoTipo", Hibernate.INTEGER).addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
								.addScalar("numeroPrestacoesTotal", Hibernate.SHORT).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
								.addScalar("dataPagamento", Hibernate.DATE).addScalar("idDocumentoTipo", Hibernate.INTEGER)
								.setInteger("idCliente", idCliente).setParameterList("idsImoveis", particoes.get(i))
								.setInteger("situacaoNormal", new Integer(situacaoNormal))
								.setDate("inicialVencimento", dataVencimentoInicial).setDate("finalVencimento", dataVencimentoFinal).list();

						retorno.addAll(retornoPart);
					}
				} else {

					retorno = session.createSQLQuery(consulta).addScalar("idGuia", Hibernate.INTEGER)
							.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("anoMesReferencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
							.addScalar("descricaoDebitoTipo", Hibernate.STRING).addScalar("dataEmissao", Hibernate.DATE)
							.addScalar("idDebitoTipo", Hibernate.INTEGER).addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
							.addScalar("numeroPrestacoesTotal", Hibernate.SHORT).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE).addScalar("idDocumentoTipo", Hibernate.INTEGER)
							.setInteger("idCliente", idCliente).setParameterList("idsImoveis", idsImoveis)
							.setInteger("situacaoNormal", new Integer(situacaoNormal)).setDate("inicialVencimento", dataVencimentoInicial)
							.setDate("finalVencimento", dataVencimentoFinal).list();
				}

			} else {
				retorno = session.createSQLQuery(consulta).addScalar("idGuia", Hibernate.INTEGER)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("descricaoDebitoTipo", Hibernate.STRING).addScalar("dataEmissao", Hibernate.DATE)
						.addScalar("idDebitoTipo", Hibernate.INTEGER).addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
						.addScalar("numeroPrestacoesTotal", Hibernate.SHORT).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE).addScalar("idDocumentoTipo", Hibernate.INTEGER)
						.setInteger("idCliente", idCliente).setInteger("situacaoNormal", new Integer(situacaoNormal))
						.setDate("inicialVencimento", dataVencimentoInicial).setDate("finalVencimento", dataVencimentoFinal).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Ana Maria Data:
	 * 08/08/2007
	 * 
	 * @param idImoveis
	 *            Matriculas dos Imoveis
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @param situacaoNormal
	 *            Situação Normal
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @return Coleção de Guias de Pagamentos
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoIdsImoveis(Integer idCliente, Collection idsImoveis, int indicadorPagamento,
			String situacaoNormal, Short clienteRelacaoTipo, Date dataVencimentoInicial, Date dataVencimentoFinal)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento, "
					+ " guia.dotp_id as idDocumentoTipo " + "FROM cadastro.cliente_guia_pagamento clieGuia "
					+ "INNER JOIN faturamento.guia_pagamento guia on guia.gpag_id = clieGuia.gpag_id "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id " + "WHERE clieGuia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			if (clienteRelacaoTipo != null) {
				consulta += "clieGuia.crtp_id = " + clienteRelacaoTipo.toString();
			}

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal, guia.dotp_id";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0 ";
			}

			consulta += "UNION ";

			consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento, "
					+ " guia.dotp_id as idDocumentoTipo " + "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id " + "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal, guia.dotp_id";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0 ";
			}

			if (idsImoveis != null && !idsImoveis.isEmpty()) {

				consulta += "UNION ";

				consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
						+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
						+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
						+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
						+ "debTipo.dbtp_id as idDebitoTipo, "
						+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
						+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento, "
						+ " guia.dotp_id as idDocumentoTipo " + "FROM faturamento.guia_pagamento guia "
						+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
						+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id " + "WHERE guia.imov_id in (:idsImoveis) "
						+ "and guia.dcst_idatual = :situacaoNormal "
						+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

				consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
						+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal, guia.dotp_id";

				if (indicadorPagamento == 1) {
					consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) = 0 ";
				}

				if (idsImoveis.size() > 999) {

					System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

					List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsImoveis, 999);

					int qtdQuebras = 999;
					int indice = idsImoveis.size() / qtdQuebras;

					if (idsImoveis.size() % qtdQuebras != 0) {
						indice++;
					}

					System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

					for (int i = 0; i < indice; i++) {

						System.out.println("## TAMANHO PARTIÇÃO DE INDICE " + indice + " = " + particoes.get(i).size());

						Collection retornoPart = null;

						retornoPart = session.createSQLQuery(consulta).addScalar("idGuia", Hibernate.INTEGER)
								.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("anoMesReferencia", Hibernate.INTEGER)
								.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
								.addScalar("descricaoDebitoTipo", Hibernate.STRING).addScalar("dataEmissao", Hibernate.DATE)
								.addScalar("idDebitoTipo", Hibernate.INTEGER).addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
								.addScalar("numeroPrestacoesTotal", Hibernate.SHORT).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
								.addScalar("dataPagamento", Hibernate.DATE).addScalar("idDocumentoTipo", Hibernate.INTEGER)
								.setInteger("idCliente", idCliente).setParameterList("idsImoveis", particoes.get(i))
								.setInteger("situacaoNormal", new Integer(situacaoNormal))
								.setDate("inicialVencimento", dataVencimentoInicial).setDate("finalVencimento", dataVencimentoFinal).list();

						retorno.addAll(retornoPart);
					}
				} else {

					retorno = session.createSQLQuery(consulta).addScalar("idGuia", Hibernate.INTEGER)
							.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("anoMesReferencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
							.addScalar("descricaoDebitoTipo", Hibernate.STRING).addScalar("dataEmissao", Hibernate.DATE)
							.addScalar("idDebitoTipo", Hibernate.INTEGER).addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
							.addScalar("numeroPrestacoesTotal", Hibernate.SHORT).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE).addScalar("idDocumentoTipo", Hibernate.INTEGER)
							.setInteger("idCliente", idCliente).setParameterList("idsImoveis", idsImoveis)
							.setInteger("situacaoNormal", new Integer(situacaoNormal)).setDate("inicialVencimento", dataVencimentoInicial)
							.setDate("finalVencimento", dataVencimentoFinal).list();
				}

			} else {
				retorno = session.createSQLQuery(consulta).addScalar("idGuia", Hibernate.INTEGER)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("descricaoDebitoTipo", Hibernate.STRING).addScalar("dataEmissao", Hibernate.DATE)
						.addScalar("idDebitoTipo", Hibernate.INTEGER).addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
						.addScalar("numeroPrestacoesTotal", Hibernate.SHORT).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE).addScalar("idDocumentoTipo", Hibernate.INTEGER)
						.setInteger("idCliente", idCliente).setInteger("situacaoNormal", new Integer(situacaoNormal))
						.setDate("inicialVencimento", dataVencimentoInicial).setDate("finalVencimento", dataVencimentoFinal).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem ralação fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdImoveisClienteSemRelacaoFim(String codigoCliente, Short relacaoTipo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteImovel ci " + "inner join ci.imovel imovel " + "inner join ci.cliente cliente ";

			if (relacaoTipo != null) {
				consulta = consulta + " inner join ci.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo and ci.dataFimRelacao is null";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue())
						.setShort("relacao", new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem ralação fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdImoveisClienteSuperiorSemRelacaoFim(String codigoCliente) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id "
					+ "from ClienteImovel ci "
					+ "inner join ci.imovel imovel "
					+ "inner join ci.cliente cliente "
					+ "where ci.dataFimRelacao is null and (cliente.id =:codigo or cliente.cliente.id = :codigo) and ci.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL;

			retorno = session.createQuery(consulta).setInteger("codigo", new Integer(codigoCliente).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem ralação fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosClienteResumido(String codigoCliente, String tipoRelacao, String anoMesInicial, String anoMesFinal,
			Date dataVencimentoDebitoInicial, Date dataVencimentoDebitoFinal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT imov.imov_id as idImovel, "
					+ " sum( "
					+ " CASE "
					+ " WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null "
					+ " THEN conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - conta.cnta_vlimpostos "
					+ " END " + " ) as valorDebito, 'CONTA' as tipoDebito " + " FROM cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.conta conta "
					+ " on conta.imov_id = imov.imov_id and (conta.dcst_idatual = "
					+ DebitoCreditoSituacao.NORMAL.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.RETIFICADA.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.INCLUIDA.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.PARCELADA.toString()
					+ " ) "
					+ " left outer join arrecadacao.pagamento pagtoConta "
					+ " on conta.cnta_id = pagtoConta.cnta_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'CONTA' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum(dbac.dbac_vldebito - (trunc(dbac.dbac_vldebito/dbac.dbac_nnprestacaodebito, 2)*(dbac.dbac_nnprestacaocobradas + coalesce(dbac.dbac_nnparcelabonus,0)))) as valorDebito, "
					// +
					// " sum(dbac.dbac_vldebito - round(round(dbac.dbac_vldebito/dbac.dbac_nnprestacaodebito, 2)*dbac.dbac_nnprestacaocobradas, 2)) as valorDebito, "
					+ " 'DÉBITO A COBRAR' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.debito_a_cobrar dbac "
					+ " on dbac.imov_id = imov.imov_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'DÉBITO A COBRAR' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum( "
					+ " CASE "
					+ " WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null "
					+ " THEN gpag.gpag_vldebito "
					+ " END "
					+ " ) as valorDebito, 'GUIA DE PAGAMENTO' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.guia_pagamento gpag "
					+ " on gpag.imov_id = imov.imov_id "
					+ " left outer join arrecadacao.pagamento pagtoGuia "
					+ " on gpag.gpag_id = pagtoGuia.gpag_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'GUIA DE PAGAMENTO' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum(crar.crar_vlcredito - round(round(crar.crar_vlcredito/crar.crar_nnprestacaocredito, 2)*crar.crar_nnprestacaorealizadas, 2)) as valorDebito, "
					+ " 'CRÉDITO A REALIZAR' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.credito_a_realizar crar "
					+ " on crar.imov_id = imov.imov_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'CRÉDITO A REALIZAR' " + " order by idImovel, tipoDebito ";

			retorno = session.createSQLQuery(consulta).addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar("tipoDebito", Hibernate.STRING)
					.setInteger("codigo", new Integer(codigoCliente).intValue()).setInteger("anoMesInicial", new Integer(anoMesInicial))
					.setInteger("anoMesFinal", new Integer(anoMesFinal))
					.setDate("dataVencimentoDebitoInicial", dataVencimentoDebitoInicial)
					.setDate("dataVencimentoDebitoInicial", dataVencimentoDebitoFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emissão do Extrato de Débitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * Obtem os parcelamentos de débitos efetuados que estejam com situação
	 * normal
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSituacaoNormal(Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(parc) " + "FROM DebitoACobrar dbac " + "INNER JOIN dbac.parcelamento parc "
					+ "WHERE parc.imovel.id = :idImovel " + "AND parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND dbac.numeroPrestacaoCobradas < (dbac.numeroPrestacaoDebito - coalesce(dbac.numeroParcelaBonus,0))  "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta).setInteger("parcelamentoSituacao", ParcelamentoSituacao.NORMAL)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL).setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emissão do Extrato de Débitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarImovelParcelamento(Integer idParcelamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch dac.debitoTipo debitoTipo "
					+ "inner join dac.parcelamento parcelamento "
					+ "where parcelamento.id = :idParcelamento "
					+ "and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0))"
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id) "
					+ "and debitoTipo.id <> :debitoTipo ";

			retorno = session.createQuery(consulta).setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("debitoTipo", DebitoTipo.JUROS_SOBRE_PARCELAMENTO).setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emissão do Extrato de Débitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Creditos A Realizar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarParcelamento(Integer idParcelamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car,creditoTipo.descricao, creditoTipo.id " + "from CreditoARealizar car "
					+ "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual " + "inner join car.creditoTipo creditoTipo "
					+ "inner join car.parcelamento parcelamento " + "where parcelamento.id = :idParcelamento "
					+ "and (car.numeroPrestacaoRealizada < (car.numeroPrestacaoCredito " + " - coalesce(car.numeroParcelaBonus,0)) or "
					+ "car.valorResidualMesAnterior > 0) " + "and car.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta).setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Sávio Luiz, Raphael Rossiter
	 * @data 26/05/2006, 04/01/2008
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitirCAER(Integer idCobrancaAcaoCronograma,
			Integer idCobrancaAcaoComando, Date dataEmissao, Integer idCobrancaAcao, int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "LEFT JOIN fetch cbdo.empresa as empr "
					+ "LEFT JOIN fetch cbdo.localidade as loca " + "LEFT JOIN fetch loca.unidadeNegocio as uneg "
					+ "LEFT JOIN fetch loca.enderecoReferencia as enderecoReferenciaLocalidade "
					+ "LEFT JOIN fetch loca.logradouroCep as logCepLocalidade " + "LEFT JOIN fetch logCepLocalidade.cep as cepLocalidade "
					+ "LEFT JOIN fetch logCepLocalidade.logradouro as logLocalidade "
					+ "LEFT JOIN fetch logLocalidade.logradouroTipo as logTipoLocalidade "
					+ "LEFT JOIN fetch logLocalidade.logradouroTitulo as logTituloLocalidade "
					+ "LEFT JOIN fetch loca.logradouroBairro as logBairroLocalidade "
					+ "LEFT JOIN fetch logBairroLocalidade.bairro as bairroLocalidade "
					+ "LEFT JOIN fetch bairroLocalidade.municipio as municipioLocalidade "
					+ "LEFT JOIN fetch municipioLocalidade.unidadeFederacao as unidadeFederacaoLocalidade "
					+ "LEFT JOIN fetch cbdo.imovel as imov " + "LEFT JOIN fetch imov.leituraAnormalidade as ltan "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro " + "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun " + "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep " + "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo " + "LEFT JOIN fetch log.logradouroTitulo " + "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia " + "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao " + "LEFT JOIN fetch cbdo.quadra qdr " + "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo " + "LEFT JOIN fetch cbdo.imovelPerfil " + "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional " + "LEFT JOIN fetch imov.ligacaoAgua.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN fetch hih.hidrometro " + "LEFT JOIN fetch hih.hidrometroLocalInstalacao " + "WHERE ";

			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando;
			}
			consulta = consulta + " AND cbdo.emissao = :dataEmissao AND " + " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY loca.id, cbdo.codigoSetorComercial, rot.codigo, imov.numeroSequencialRota, "
					+ "cbdo.numeroQuadra, imov.lote, imov.subLote, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCorteAdministrativoOUFisico", idCobrancaAcao).setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio).setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 01/09/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer verificarRDUtilizadaPeloImovel(Integer idRD, Integer idImovel) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select parc.id " + "from Parcelamento as parc " + "left join parc.resolucaoDiretoria rd "
					+ "where parc.imovel.id = :idImovel " + "and rd.id = :idRD "
					+ "and rd.indicadorParcelamentoUnico = :indicadorParcelamentoUnico "
					+ "and parc.parcelamentoSituacao = :parcelamentoSituacao ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idRD", idRD)
					.setShort("indicadorParcelamentoUnico", ConstantesSistema.SIM)
					.setInteger("parcelamentoSituacao", ParcelamentoSituacao.NORMAL).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * (DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta a ser
	 * parcelada ocorrendo na tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterDebitoTipoDeFiscalizacaoSituacaoServicoACobrar(Integer idConta) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select fiscalizacao.debitoTipo.id " + "from FiscalizacaoSituacaoServicoACobrar fiscalizacao "
					+ "where fiscalizacao.debitoTipo.id in " + "(select debitoCobrado.debitoTipo " + "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)";

			retorno = (Collection) session.createQuery(consulta).setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 01/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoACobrarSancoes(Integer idImovel, Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito) throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum (dbac.dbac_vldebito) as valorDebito"
					+ " from faturamento.debito_a_cobrar  dbac where dbac.imov_id = :idImovel and"
					+ " (dbac.dbtp_id = :sancoesRegulamentares or " + " dbac.dbtp_id = :multaPorInfracao or "
					+ " dbac.dbtp_id = :instalSubstHidrometro or " + " dbac.dbtp_id = :consumoNaoContabilizado) "
					+ " and dbac.dbac_nnprestacaocobradas < dbac.dbac_nnprestacaodebito " + " and dbac.dcst_idatual = :normal "
					+ " and dbac.dbac_amreferenciadebito >= :anoMesInicialReferenciaDebito "
					+ " and dbac.dbac_amreferenciadebito <= :anoMesFinalReferenciaDebito ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel).setInteger("anoMesInicialReferenciaDebito", anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito", anoMesFinalReferenciaDebito)
					.setInteger("sancoesRegulamentares", DebitoTipo.SANCOES_REGULAMENTARES)
					.setInteger("multaPorInfracao", DebitoTipo.MULTA_POR_INFRACAO)
					.setInteger("consumoNaoContabilizado", DebitoTipo.CONSUMO_NAO_CONTABILIZADO)
					.setInteger("instalSubstHidrometro", DebitoTipo.INSTAL_SUBST_HIDROMETRO)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 06/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoACobrar(Integer idImovel, Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito) throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum (dbac.dbac_vldebito) as valorDebito"
					+ " from faturamento.debito_a_cobrar  dbac where dbac.imov_id = :idImovel and"
					+ " (dbac.dbtp_id = :atualizacaoMonetaria or "
					+ " dbac.dbtp_id = :jurosMora or "
					+ " dbac.dbtp_id = :multaImpontualidade or "
					+ " dbac.dbtp_id = :acrescImpontualidade )"
					+ " and dbac.dbac_nnprestacaocobradas < (dbac.dbac_nnprestacaodebito - coalesce(dbac.dbac_nnparcelabonus,0)) "
					+ " and dbac.dcst_idatual = :normal "
					// +
					// " and dbac.dbac_amreferenciadebito >= :anoMesInicialReferenciaDebito "
					// +
					// " and dbac.dbac_amreferenciadebito <= :anoMesFinalReferenciaDebito ";
					// alterado por Vivianne Sousa 11/09/2008
					// analista Adriano
					+ " and dbac.dbac_amcobrancadebito >= :anoMesInicialReferenciaDebito "
					+ " and dbac.dbac_amcobrancadebito <= :anoMesFinalReferenciaDebito ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel).setInteger("atualizacaoMonetaria", DebitoTipo.ATUALIZACAO_MONETARIA)
					.setInteger("jurosMora", DebitoTipo.JUROS_MORA).setInteger("multaImpontualidade", DebitoTipo.MULTA_IMPONTUALIDADE)
					.setInteger("acrescImpontualidade", DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE)
					.setInteger("anoMesInicialReferenciaDebito", anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito", anoMesFinalReferenciaDebito)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imóvel ou Cliente Obtem os débitos
	 * total de um cliente
	 */
	public Collection pesquisarDebitosCliente(Integer idCliente, Short relacaoTipo, Collection idsImoveis, int indicadorPagamento,
			int indicadorConta, String contaSituacaoNormal, String contaSituacaoRetificada, String contaSituacaoIncluida,
			String contaSituacaoParcelada, String anoMesInicialReferenciaDebito, String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito, Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento  "
					+ "FROM cadastro.cliente_conta clieConta "
					+ "INNER JOIN faturamento.conta conta on conta.cnta_id = clieConta.cnta_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE clieConta.clie_id = :idCliente "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (relacaoTipo != null) {
				consulta += "and clieConta.crtp_id = " + relacaoTipo.toString();
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " UNION ";

			consulta += "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id in (:idsImoveis) "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciacontabil is null ";
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE " + indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitos", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							.addScalar("dataRevisao", Hibernate.DATE).addScalar("referencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
							.addScalar("idSituacaoAtual", Hibernate.INTEGER).addScalar("digitoVerificador", Hibernate.SHORT)
							.addScalar("idMotivoRevisao", Hibernate.INTEGER).addScalar("ultimaAlteracao", Hibernate.DATE)
							.addScalar("idImovel", Hibernate.INTEGER).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("valorImpostos", Hibernate.BIG_DECIMAL).addScalar("consumoEsgoto", Hibernate.INTEGER)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("idParcelamento", Hibernate.INTEGER).setInteger("idCliente", idCliente)
							.setParameterList("idsImoveis", particoes.get(i))
							.setInteger("situacaoNormal", new Integer(contaSituacaoNormal))
							.setInteger("situacaoRetificada", new Integer(contaSituacaoRetificada))
							.setInteger("situacaoIncluida", new Integer(contaSituacaoIncluida))
							.setInteger("situacaoParcelada", new Integer(contaSituacaoParcelada))
							.setInteger("inicialReferencia", new Integer(anoMesInicialReferenciaDebito))
							.setInteger("finalReferencia", new Integer(anoMesFinalReferenciaDebito))
							.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
							.setDate("finalVencimento", anoMesFinalVencimentoDebito).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE).addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE).addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER).addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER).addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER).addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL).addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER).setInteger("idCliente", idCliente)
						.setParameterList("idsImoveis", idsImoveis).setInteger("situacaoNormal", new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada", new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida", new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada", new Integer(contaSituacaoParcelada))
						.setInteger("inicialReferencia", new Integer(anoMesInicialReferenciaDebito))
						.setInteger("finalReferencia", new Integer(anoMesFinalReferenciaDebito))
						.setDate("inicialVencimento", anoMesInicialVecimentoDebito).setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 14/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoCobradoContas(Integer idImovel, Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito, int indicadorDividaAtiva) throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum(dbcb_vlprestacao) as valorDebito" + " from faturamento.debito_cobrado as dbcb"
					+ " where dbcb.cnta_id in " + "    (select cnta_id from faturamento.conta c where imov_id = :idImovel and"
					+ " 	cnta_amreferenciaconta >= :anoMesInicialReferenciaDebito "
					+ "     and cnta_amreferenciaconta <= :anoMesFinalReferenciaDebito"
					+ "		and not exists (select pgmt_id from arrecadacao.pagamento p where c.cnta_id = p.cnta_id)"
					+ "     and(dcst_idatual = :situacaoNormal " + "     or dcst_idatual = :situacaoRetificada "
					+ "     or dcst_idatual = :situacaoIncluida )";

			if (indicadorDividaAtiva == 1) {
				consulta += " and cnta_amrerenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += " and cnta_amrerenciacontabil is null ";
			}

			consulta += ") and (dbcb.dbtp_id = :atualizacaoMonetaria or dbcb.dbtp_id = :jurosMora or "
					+ "dbcb.dbtp_id = :multaImpontualidade or dbcb.dbtp_id = :acrescImpontualidade) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel).setInteger("atualizacaoMonetaria", DebitoTipo.ATUALIZACAO_MONETARIA)
					.setInteger("jurosMora", DebitoTipo.JUROS_MORA).setInteger("multaImpontualidade", DebitoTipo.MULTA_IMPONTUALIDADE)
					.setInteger("acrescImpontualidade", DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE)
					.setInteger("anoMesInicialReferenciaDebito", anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito", anoMesFinalReferenciaDebito)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida", DebitoCreditoSituacao.INCLUIDA).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 20/09/2007
	 * 
	 * @param idImovel
	 * @param anoMesInicialReferenciaDebito
	 * @param anoMesFinalReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoCobradoSancoes(Integer idImovel, Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito, int indicadorDividaAtiva) throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = " select sum(dbcb_vlprestacao) as valorDebito " + " from faturamento.debito_cobrado as dbcb "
					+ " where dbcb.cnta_id in " + " (select cnta_id from faturamento.conta where imov_id = :idImovel and "
					+ " cnta_amreferenciaconta >= :anoMesInicialReferenciaDebito "
					+ " and cnta_amreferenciaconta <= :anoMesFinalReferenciaDebito " + " and (dcst_idatual = :situacaoNormal "
					+ " or dcst_idatual = :situacaoRetificada " + " or dcst_idatual = :situacaoIncluida )  ";

			if (indicadorDividaAtiva == 1) {
				consulta += " and cnta_amrerenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += " and cnta_amrerenciacontabil is null ";
			}

			consulta += ") and (dbcb.dbtp_id = :sancoesRegulamentares or " + " dbcb.dbtp_id = :multaPorInfracao or "
					+ " dbcb.dbtp_id = :consumoNaoContabilizado or " + " dbcb.dbtp_id = :instalSubstHidrometro) ";

			retorno = (BigDecimal) session.createSQLQuery(consulta).addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel).setInteger("anoMesInicialReferenciaDebito", anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito", anoMesFinalReferenciaDebito)
					.setInteger("sancoesRegulamentares", DebitoTipo.SANCOES_REGULAMENTARES)
					.setInteger("multaPorInfracao", DebitoTipo.MULTA_POR_INFRACAO)
					.setInteger("consumoNaoContabilizado", DebitoTipo.CONSUMO_NAO_CONTABILIZADO)
					.setInteger("instalSubstHidrometro", DebitoTipo.INSTAL_SUBST_HIDROMETRO)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida", DebitoCreditoSituacao.INCLUIDA).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0701] Informar Índices dos Acréscimos de Impontualidade
	 * 
	 * @author Sávio Luiz
	 * @created 26/09/2007
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMaximoAnoMesIndicesAcerscimosImpontualidade() throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = " select max(anoMesReferencia)  " + " from IndicesAcrescimosImpontualidade ";

			retorno = (Integer) session.createQuery(consulta).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * Retorna uma colecao de Debitos por Faixa de Valores dos Imoveis
	 * 
	 * @author Ivan Sergio
	 * @created 20/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoImovelPorFaixaValores(String idImovel, String valorMinimoDebito, String anoMesReferenciaInicial,
			String anoMesReferenciaFinal, String classificacao, boolean pesquisaMunicipio) throws ErroRepositorioException {

		String sql;
		String orderBy;
		String joinMunicipio = " LEFT JOIN cadastro.municipio muni on muni.muni_id = loca.muni_idprincipal ";
		if (pesquisaMunicipio) {
			joinMunicipio = " INNER JOIN cadastro.municipio muni on muni.muni_id = loca.muni_idprincipal ";
		}
		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		try {
			sql = "SELECT " + "	dfv.dfvl_vlfaixainicio as faixaInicial, " + "	dfv.dfvl_vlfaixafim as faixaFinal, "
					+ "	dfv.dfvl_id as idFaixa, " + "	count( temp.idImovel ) as quantidadeLigacoes, "
					+ "	sum( temp.totalDebitos ) as total, " + "	sum( temp.qtdeDebitos ) as qtdeDocumentos, "
					+ "	temp.idGerencia as idGerencia, " + "	temp.nomeGerencia as nomeGerencia, " + "	temp.idLocalidade as idLocalidade, "
					+ "	temp.nomeLocalidade as nomeLocalidade, " + "	temp.idSetor as idSetor, " + "	temp.codigoSetor as codigoSetor, "
					+ "	temp.nomeSetor as nomeSetor, " + " 	temp.idMunicipio as idMunicipio, " + " 	temp.nomeMunicipio as nomeMunicipio "
					+ "FROM " + "	faturamento.debito_faixa_valores dfv " + "	LEFT OUTER JOIN( " + "		SELECT	debitos.idImovel, "
					+ "			    gerencia.greg_id as idGerencia, " + "				gerencia.greg_nmabreviado as nomeGerencia, "
					+ "				loca.loca_id as idLocalidade, " + "				loca.loca_nmlocalidade as nomeLocalidade, "
					+ "				setor.stcm_id as idSetor, " + "				setor.stcm_cdsetorcomercial as codigoSetor, "
					+ "				setor.stcm_nmsetorcomercial as nomeSetor, " + "				sum( debitos.valorDebitos ) as totalDebitos, "
					+ "				sum( debitos.qtdeDebitos )  as qtdeDebitos, " + "				muni.muni_id as idMunicipio, "
					+ "				muni.muni_nmmunicipio as nomeMunicipio " + "		FROM (" + "			SELECT imov.imov_id as idImovel, "
					+ "					'CONTA' as tipoDebito, " + "					sum( "
					+ "						CASE WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null THEN " + "							conta.cnta_vlagua + "
					+ "							conta.cnta_vlesgoto + " + "							conta.cnta_vldebitos - " + "							conta.cnta_vlcreditos - "
					+ "							coalesce( conta.cnta_vlimpostos, 0 ) " + "						ELSE " + "							0.00 " + "						END "
					+ "					) as valorDebitos, " + "					count( "
					+ "						CASE WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null THEN " + "							conta.cnta_id "
					+ "						END " + "					) as qtdeDebitos " + "			FROM " + "				cadastro.imovel imov "
					+ "				LEFT OUTER JOIN faturamento.conta conta " + "					on conta.imov_id = imov.imov_id and "
					+ "					conta.dcst_idatual in ( 0, 1, 2 ) " + "				LEFT OUTER JOIN arrecadacao.pagamento pagtoConta "
					+ "					on conta.cnta_id = pagtoConta.cnta_id " + "			WHERE " + "				(conta.cnta_amreferenciaconta >= "
					+ anoMesReferenciaInicial
					+ " and "
					+ "				conta.cnta_amreferenciaconta <= "
					+ anoMesReferenciaFinal
					+ ") and "
					+ "				imov.imov_id in ( "
					+ idImovel
					+ " ) "
					+ "			GROUP BY "
					+ "				imov.imov_id, "
					+ "				tipoDebito "
					+ "			UNION "
					+

					"			SELECT "
					+ "				imov.imov_id as idImovel, "
					+ "				'GUIA' as tipoDebito, "
					+ "				sum( "
					+ "					CASE WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null THEN "
					+ "						gpag.gpag_vldebito "
					+ "					ELSE "
					+ "						0.00 "
					+ "					END "
					+ "				) as valorDebitos, "
					+ "				count( "
					+ "					CASE WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null THEN "
					+ "						gpag.gpag_id "
					+ "					END "
					+ "				) as qtdeDebitos "
					+ "			FROM "
					+ "				cadastro.imovel imov "
					+ "				LEFT OUTER JOIN faturamento.guia_pagamento gpag "
					+ "					on gpag.imov_id = imov.imov_id "
					+ "				LEFT OUTER JOIN arrecadacao.pagamento pagtoGuia "
					+ "					on gpag.gpag_id = pagtoGuia.gpag_id "
					+ "			WHERE "
					+ "				(gpag.gpag_amreferenciacontabil >= "
					+ anoMesReferenciaInicial
					+ " and "
					+ "				gpag.gpag_amreferenciacontabil <= "
					+ anoMesReferenciaFinal
					+ ") and "
					+ "				imov.imov_id in ( "
					+ idImovel
					+ " ) "
					+ "			GROUP BY "
					+ "				imov.imov_id, "
					+ " 				tipoDebito "
					+ "		) debitos "
					+ "		INNER JOIN cadastro.imovel imov "
					+ "			on debitos.idImovel = imov.imov_id "
					+ "		INNER JOIN cadastro.setor_comercial setor "
					+ "			on imov.stcm_id = setor.stcm_id "
					+ "		INNER JOIN cadastro.localidade loca "
					+ "			on imov.loca_id = loca.loca_id "
					+ joinMunicipio
					+ "		INNER JOIN cadastro.gerencia_regional gerencia "
					+ "			on loca.greg_id = gerencia.greg_id "
					+ "		WHERE "
					+ "			debitos.valorDebitos is null or "
					+ "			debitos.valorDebitos > 0 "
					+ "		GROUP BY "
					+ "			debitos.idImovel, "
					+ "			gerencia.greg_id, "
					+ "			gerencia.greg_nmabreviado, "
					+ "			loca.loca_id, "
					+ "			loca.loca_nmlocalidade, "
					+ "			setor.stcm_id, "
					+ "			setor.stcm_cdsetorcomercial, "
					+ "			setor.stcm_nmsetorcomercial, "
					+ "			muni.muni_id, "
					+ "			muni.muni_nmmunicipio "
					+ "		) temp "
					+ "	on temp.totalDebitos between dfv.dfvl_vlfaixainicio and dfv.dfvl_vlfaixafim "
					+ "WHERE "
					+ "	temp.totalDebitos > "
					+ valorMinimoDebito
					+ " "
					+ "GROUP BY "
					+ "	temp.idGerencia, "
					+ "	temp.nomeGerencia, "
					+ "	temp.idLocalidade, "
					+ "	temp.nomeLocalidade, "
					+ "	temp.idSetor, "
					+ "	temp.codigoSetor, "
					+ "	temp.nomeSetor, "
					+ "	dfv.dfvl_vlfaixainicio, "
					+ "	dfv.dfvl_vlfaixafim, "
					+ "	dfv.dfvl_id, "
					+ "	temp.idMunicipio, "
					+ "	temp.nomeMunicipio " + "ORDER BY ";

			// Classificacao
			orderBy = "";
			if (classificacao.trim().equalsIgnoreCase("ESTADO")) {
				orderBy = "	dfv.dfvl_id, " + "	temp.idGerencia, " + "	temp.idLocalidade, " + "	temp.idSetor";

			} else if (classificacao.trim().equalsIgnoreCase("REGIONAL")) {
				orderBy = "	temp.idGerencia, " + "	dfv.dfvl_id, " + "	temp.idLocalidade, " + "	temp.idSetor";

			} else if (classificacao.trim().equalsIgnoreCase("LOCAL")) {
				orderBy = "	temp.idGerencia, " + "	temp.idLocalidade, " + "	dfv.dfvl_id, " + "	temp.idSetor";
			} else if (classificacao.trim().equalsIgnoreCase("SETORCOMERCIAL")) {
				orderBy = "	temp.idGerencia, " + "	temp.idLocalidade, " + "	temp.idSetor, " + "	dfv.dfvl_id";
			} else if (classificacao.trim().equalsIgnoreCase("MUNICIPIO")) {
				orderBy = "	temp.idGerencia, " + "	temp.idMunicipio, " + "	dfv.dfvl_id, " + "	temp.idSetor";
			}

			sql += orderBy;

			retorno = session.createSQLQuery(sql).addScalar("faixaInicial", Hibernate.BIG_DECIMAL)
					.addScalar("faixaFinal", Hibernate.BIG_DECIMAL).addScalar("idFaixa", Hibernate.INTEGER)
					.addScalar("quantidadeLigacoes", Hibernate.INTEGER).addScalar("total", Hibernate.BIG_DECIMAL)
					.addScalar("qtdeDocumentos", Hibernate.INTEGER).addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER).addScalar("nomeSetor", Hibernate.STRING)
					.addScalar("idMunicipio", Hibernate.INTEGER).addScalar("nomeMunicipio", Hibernate.STRING).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC0216] Calcular Acréscimo por Impontualidade
	 * 
	 * @autor: Raphael Rossiter
	 * 
	 *         Pesquisa os dados do Indices Acrescimo Impontualidade menor ao
	 *         ano mes referencia
	 * 
	 * @param anoMesReferenciaDebito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIndiceAcrescimoImpontualidade() throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai " + "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select min(iai2.anoMesReferencia) " + "from IndicesAcrescimosImpontualidade iai2)";

			retorno = session.createQuery(consulta).setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotas(String codigoSetorComercial, String rotaInicial, String rotaFinal, String idLocalidade,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota " + " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade " + " where rota.codigo between :rotaInicial and :rotaFinal "
					+ " and setor.codigo = :setorComercial " + " and localidade.id = :idLocalidade" + " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio).setInteger("idLocalidade", new Integer(idLocalidade))
					.setInteger("setorComercial", new Integer(codigoSetorComercial)).setInteger("rotaInicial", new Integer(rotaInicial))
					.setInteger("rotaFinal", new Integer(rotaFinal)).setInteger("idCobrancaAcao", new Integer(idCobrancaAcao)).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloSetor(String codigoSetorComercialInicial, String codigoSetorComercialFinal,
			String idLocalidade, String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota " + " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade "
					+ " where setor.codigo between :codigoSetorComercialInicial and :codigoSetorComercialFinal "
					+ " and localidade.id = :idLocalidade" + " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio).setInteger("idLocalidade", new Integer(idLocalidade))
					.setInteger("codigoSetorComercialInicial", new Integer(codigoSetorComercialInicial))
					.setInteger("codigoSetorComercialFinal", new Integer(codigoSetorComercialFinal))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao)).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloLocalidade(String idLocalidadeInicial, String idLocalidadeFinal, String idCobrancaAcao)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota " + " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade "
					+ " where localidade.id between :idLocalidadeInicial and :idLocalidadeFinal " + " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio).setInteger("idLocalidadeInicial", new Integer(idLocalidadeInicial))
					.setInteger("idLocalidadeFinal", new Integer(idLocalidadeFinal))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao)).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloGerencia(String idGerenciaRegional, String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota " + " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade" + " inner join localidade.unidadeNegocio unidadeNegocio"
					+ " inner join unidadeNegocio.gerenciaRegional gerenciaRegional" + " where gerenciaRegional.id = :idGerenciaRegional "
					+ " and rota.id not in (" + " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio).setInteger("idGerenciaRegional", new Integer(idGerenciaRegional))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao)).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloGrupo(String idGrupoCobranca, String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota " + " inner join rota.setorComercial setor "
					+ " inner join rota.cobrancaGrupo cobrancaGrupo" + " where cobrancaGrupo.id = :idGrupoCobranca "
					+ " and rota.id not in (" + " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio).setInteger("idGrupoCobranca", new Integer(idGrupoCobranca))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao)).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloUnidadeNegocio(String idUnidadeNegocio, String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota " + " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade" + " inner join localidade.unidadeNegocio unidadeNegocio"
					+ " where unidadeNegocio.id = :idUnidadeNegocio " + " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio).setInteger("idUnidadeNegocio", new Integer(idUnidadeNegocio))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao)).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasPorCobrancaAcao(String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota " + " where rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio).setInteger("idCobrancaAcao", new Integer(idCobrancaAcao)).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente
	 * 
	 * @autor: Raphael Rossiter
	 * 
	 *         Verifica se existe uma devolução associada ao credito
	 * 
	 * @param creditoARealizar
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean existeDevolucao(CreditoARealizar creditoARealizar) throws ErroRepositorioException {

		Integer retornoHQL = null;
		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT devl.id " + "FROM Devolucao devl " + "INNER JOIN devl.creditoARealizarGeral crar "
					+ "WHERE crar.id = :idCreditoARealizar ";

			retornoHQL = (Integer) session.createQuery(consulta).setInteger("idCreditoARealizar", creditoARealizar.getId())
					.setMaxResults(1).uniqueResult();

			if (retornoHQL != null) {
				retorno = true;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Inserir Comando Negaivação
	 * 
	 * @autor: Ana Maria
	 * 
	 *         [FS0019] Verificar existência de Parcelamento
	 * 
	 * @param idImovel
	 * @return Cliente
	 * @throws ErroRepositorioException
	 */
	public Cliente pesquisarClienteResponsavelParcelamento(Integer idImovel) throws ErroRepositorioException {

		Cliente retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select clie " + "from Parcelamento parc " + "inner join parc.cliente clie " + "where parc.imovel.id = :idImovel "
					+ "order by parc.parcelamento desc ";

			retorno = (Cliente) session.createQuery(consulta).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0200] Inserir Débito Automático
	 * 
	 * @autor Rodrigo Silveira
	 * @date 28/01/2008 [FS0006] Verificar Data de Opção já Excluída
	 * 
	 * @param matriculaImovel
	 * @param dataOpcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String verificarDataOpcaoJaExcluida(String matriculaImovel, Date dataOpcao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id from DebitoAutomatico deb " + "inner join deb.imovel imovel "
					+ "where imovel.id = :matricula AND " + "deb.dataExclusao is not null "
					+ "and deb.dataOpcaoDebitoContaCorrente = :data";

			retorno = session.createQuery(consultaDataOpcao).setInteger("matricula", new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0737] Atualiza Quantdade de Parcela Paga Consecutiva e Parcela Bônus
	 * 
	 * Retorna dados dos parcelamentos com RD = 8 que estejam com situação
	 * normal e que não exista outro parcelamento com data posterior
	 * 
	 * @author Vivianne Sousa
	 * @date 31/01/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParcelamentoRDEspecial(Integer situacaoParcelamento, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "SELECT parc.parc_id as idParc, " + " parc.parc_tmparcelamento as dataParc, "
					+ " parc_nnprestacoes as numeroPrestacoesParc, " + " parc.imov_id as idImovel, "
					+ " parc.parc_nnparcelaspagasconsecs as numeroparcelaspagasconsecutiva " + "FROM cobranca.parcelamento parc "
					+ "WHERE parc.rdir_id = :idRD " + " AND parc.pcst_id = :situacaoParcelamento " + " AND parc.loca_id = :idLocalidade "
					+ " AND parc.parc_tmparcelamento = " + "      (SELECT max(parc_tmparcelamento) " + "       FROM cobranca.parcelamento "
					+ "       WHERE imov_id = parc.imov_id) ";

			retorno = session.createSQLQuery(consulta).addScalar("idParc", Hibernate.INTEGER).addScalar("dataParc", Hibernate.DATE)
					.addScalar("numeroPrestacoesParc", Hibernate.SHORT).addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("numeroparcelaspagasconsecutiva", Hibernate.SHORT).setInteger("idRD", 8)
					.setInteger("situacaoParcelamento", situacaoParcelamento).setInteger("idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela Bônus
	 * 
	 * @author Vivianne Sousa
	 * @created 07/02/2008
	 * 
	 * @param idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarNumeroParcelasPagasConsecutivasParcelamento(Integer idParcelamento, Short numeroParcelas)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaParcelamento;

		try {
			atualizaParcelamento = "update gcom.cobranca.parcelamento.Parcelamento "
					+ "set parc_nnparcelaspagasconsecs = :numeroParcelas, " + "parc_tmultimaalteracao = :ultimaAlteracao  "
					+ "where parc_id = :idParcelamento";

			session.createQuery(atualizaParcelamento).setInteger("idParcelamento", idParcelamento)
					.setShort("numeroParcelas", numeroParcelas).setTimestamp("ultimaAlteracao", new Date()).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0676] - Consultar Resumo da Negativacao
	 * 
	 * Pesquisa resumo Negativacao
	 * 
	 * @author Marcio Roberto
	 * @date 28/02/2008
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection consultarNegativacao(DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper, int tipo)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			switch (tipo) {
			case 1:
				// [SB0001] - Seleciona quantidade de negativações incluidas.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) " + " from ResumoNegativacao re "
						+ " inner join re.negativador neg " + " where 1 = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper) + " group by neg.id " + " order by neg.id ";
				break;
			case 2:
				// [SB0002] - Seleciona quantidade de negativações incluidas por
				// situação do Débito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) " + " from ResumoNegativacao re "
						+ " inner join re.negativador neg " + " inner join re.cobrancaDebitoSituacao stcb " + " where 1 = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper) + " group by stcb.id, stcb.descricao "
						+ " order by stcb.id, stcb.descricao ";
				break;

			case 3:
				// [SB0003] - Seleciona quantidade de negativações por situação
				// de Negativação - RNEG_ICNEGATIVCONFIRMADA = 1.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) " + " from ResumoNegativacao re "
						+ " inner join re.negativador neg " + " where 1 = 1 " + " and re.indicadorNegativacaoConfirmada = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper) + " group by neg.id " + " order by neg.id ";
				break;

			case 4:
				// [SB0003] - Seleciona quantidade de negativações por situação
				// de Negativação - RNEG_ICNEGATIVCONFIRMADA = 2.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) " + " from ResumoNegativacao re "
						+ " inner join re.negativador neg " + " where 1 = 1 " + " and re.indicadorNegativacaoConfirmada = 2 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper) + " group by neg.id " + " order by neg.id ";
				break;

			case 5:
				// [SB0004] - Seleciona quantidade de negativações por situação
				// de Negativação e cobranca do Debito.
				// [SB0002] - Seleciona quantidade de negativações incluidas por
				// situação do Débito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) " + " from ResumoNegativacao re "
						+ " inner join re.negativador neg " + " inner join re.cobrancaDebitoSituacao stcb " + " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 1 " + this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by stcb.id, stcb.descricao " + " order by stcb.id, stcb.descricao ";
				break;
			case 6:
				// [SB0002] - Seleciona quantidade de negativações incluidas por
				// situação do Débito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) " + " from ResumoNegativacao re "
						+ " inner join re.negativador neg " + " inner join re.cobrancaDebitoSituacao stcb " + " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 2 " + this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by stcb.id, stcb.descricao " + " order by stcb.id, stcb.descricao ";
				break;
			default:
				break;
			}

			if (tipo == 2) {
				// tipo 2

			} else if (tipo == 1) {
				// tipo 1

			}

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * <Breve descrição sobre o subfluxo>
	 * 
	 * <Identificador e nome do subfluxo>
	 * 
	 * <Breve descrição sobre o fluxo secundário>
	 * 
	 * <Identificador e nome do fluxo secundário>
	 * 
	 * @author Márcio Roberto
	 * @date 07/05/2008
	 * 
	 * @param dadosConsultaNegativacaoHelper
	 * @return
	 */

	public String criarCondicionaisResumosHQL(DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper) {

		String sql = " ";
		String restricao = "";
		/*
		 * A partir daqui sera montanda a parte dos condicionais da query estas
		 * condicionais serão usadas se necessarias, o q determina seus usos são
		 * os parametros que veem carregados no objeto
		 * InformarDadosGeracaoRelatorioConsultaHelper que é recebido do caso de
		 * uso [UC0304] Informar Dados para Geração de Relatorio ou COnsulta
		 */
		if (dadosConsultaNegativacaoHelper != null) {

			// Inicio Parametros simples
			if (dadosConsultaNegativacaoHelper.getIdNegativador() != null) {
				sql = sql + " and re.negativador.id = " + dadosConsultaNegativacaoHelper.getIdNegativador();
			} else {
				if (dadosConsultaNegativacaoHelper.getColecaoNegativador() != null
						&& !dadosConsultaNegativacaoHelper.getColecaoNegativador().isEmpty()) {
					boolean consulta = true;
					if (dadosConsultaNegativacaoHelper.getColecaoNegativador().size() == 1) {
						Iterator it = dadosConsultaNegativacaoHelper.getColecaoNegativador().iterator();
						while (it.hasNext()) {
							Negativador obj = (Negativador) it.next();
							if (obj != null && obj.getId() == -1) {
								consulta = false;
							}
						}
					}
					if (consulta) {
						Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoNegativador().iterator();
						Negativador negativador = null;
						restricao = restricao + " and re.negativador.id  in (";
						while (iterator.hasNext()) {
							negativador = (Negativador) iterator.next();
							restricao = restricao + negativador.getId() + ",";
						}
						restricao = Util.removerUltimosCaracteres(restricao, 1);
						restricao = restricao + ") ";
					}
				}
			}

			// if
			// (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoInicio()
			// != null) {
			// if
			// (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoFim()
			// != null) {
			// sql = sql
			// +
			// " and (re.dataProcessamentoEnvio >= '"+Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
			// .getPeriodoEnvioNegativacaoInicio())+"'"
			// +
			// " and re.dataProcessamentoEnvio <= '"+Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
			// .getPeriodoEnvioNegativacaoFim())+"'"
			// + ")";
			// }
			//
			// }

			if (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoInicio() != null
					&& dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoFim() != null) {
				sql = sql + " and (re.dataProcessamentoEnvio >= to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoInicio())
						+ "','YYYY-MM-DD')" + " and re.dataProcessamentoEnvio <= to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoFim())
						+ "','YYYY-MM-DD')" + ")";

			} else {
				if (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoInicio() != null) {
					sql = sql + " and re.dataProcessamentoEnvio >= '"
							+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoInicio()) + "'";
				}
				if (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoFim() != null) {
					sql = sql + " and re.dataProcessamentoEnvio <= '"
							+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoFim()) + "'";
				}
			}

			if (dadosConsultaNegativacaoHelper.getNumeroExecucaoResumoNegativacao() != null) {
				sql = sql + " and re.numeroExecucaoResumoNegativacao = "
						+ dadosConsultaNegativacaoHelper.getNumeroExecucaoResumoNegativacao();
			}

			if (dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo().iterator();
					while (it.hasNext()) {
						CobrancaGrupo obj = (CobrancaGrupo) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo().iterator();
					CobrancaGrupo cobrancaGrupo = null;
					restricao = restricao + " and re.cobrancaGrupo.id in (";
					while (iterator.hasNext()) {
						cobrancaGrupo = (CobrancaGrupo) iterator.next();
						restricao = restricao + cobrancaGrupo.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional().iterator();
					while (it.hasNext()) {
						GerenciaRegional gerReg = (GerenciaRegional) it.next();
						if (gerReg != null && gerReg.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional().iterator();
					GerenciaRegional gerenciaRegional = null;
					restricao = restricao + " and re.gerenciaRegional.id in (";
					while (iterator.hasNext()) {
						gerenciaRegional = (GerenciaRegional) iterator.next();
						restricao = restricao + gerenciaRegional.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio().iterator();
					while (it.hasNext()) {
						UnidadeNegocio obj = (UnidadeNegocio) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio().iterator();
					UnidadeNegocio unidadeNegocio = null;
					restricao = restricao + " and re.unidadeNegocio.id in (";
					while (iterator.hasNext()) {
						unidadeNegocio = (UnidadeNegocio) iterator.next();
						restricao = restricao + unidadeNegocio.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";

				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoCategoria() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoCategoria().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoCategoria().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper.getColecaoCategoria().iterator();
					while (it.hasNext()) {
						Categoria obj = (Categoria) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoCategoria().iterator();
					Categoria categoria = null;
					restricao = restricao + " and re.categoria.id in (";
					while (iterator.hasNext()) {
						categoria = (Categoria) iterator.next();
						restricao = restricao + categoria.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoClienteTipo() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoClienteTipo().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoClienteTipo().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper.getColecaoClienteTipo().iterator();
					while (it.hasNext()) {
						ClienteTipo obj = (ClienteTipo) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoClienteTipo().iterator();
					ClienteTipo clienteTipo = null;
					restricao = restricao + " and re.clienteTipo.id in (";
					while (iterator.hasNext()) {
						clienteTipo = (ClienteTipo) iterator.next();
						restricao = restricao + clienteTipo.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoEsferaPoder() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoEsferaPoder().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoEsferaPoder().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper.getColecaoEsferaPoder().iterator();
					while (it.hasNext()) {
						EsferaPoder obj = (EsferaPoder) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoEsferaPoder().iterator();
					EsferaPoder esferaPoder = null;
					restricao = restricao + " and re.esferaPoder.id  in (";
					while (iterator.hasNext()) {
						esferaPoder = (EsferaPoder) iterator.next();
						restricao = restricao + esferaPoder.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			// *******************************************************
			// RM3755
			// Autor: Ivan Sergio
			// Data: 14/01/2011
			// "or" por se LEFT
			// *********************************************************
			if (dadosConsultaNegativacaoHelper.getColecaoLigacaoAguaSituacao() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoLigacaoAguaSituacao().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoLigacaoAguaSituacao().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper.getColecaoLigacaoAguaSituacao().iterator();
					while (it.hasNext()) {
						LigacaoAguaSituacao obj = (LigacaoAguaSituacao) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoLigacaoAguaSituacao().iterator();
					LigacaoAguaSituacao ligacaoAguaSituacao = null;
					restricao = restricao + " or re.ligacaoAguaSituacao.id  in (";
					while (iterator.hasNext()) {
						ligacaoAguaSituacao = (LigacaoAguaSituacao) iterator.next();
						restricao = restricao + ligacaoAguaSituacao.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}
			// *******************************************************

			if (dadosConsultaNegativacaoHelper.getColecaoImovelPerfil() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoImovelPerfil().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoImovelPerfil().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper.getColecaoImovelPerfil().iterator();
					while (it.hasNext()) {
						ImovelPerfil obj = (ImovelPerfil) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper.getColecaoImovelPerfil().iterator();
					ImovelPerfil imovelPerfil = null;
					restricao = restricao + " and re.imovelPerfil.id  in (";
					while (iterator.hasNext()) {
						imovelPerfil = (ImovelPerfil) iterator.next();
						restricao = restricao + imovelPerfil.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getIdEloPolo() != null) {
				sql = sql + " and re.localidade.localidade.id = " + dadosConsultaNegativacaoHelper.getIdEloPolo();
			}

			if (dadosConsultaNegativacaoHelper.getIdLocalidade() != null) {
				sql = sql + " and re.localidade.id = " + dadosConsultaNegativacaoHelper.getIdLocalidade();
			}

			if (dadosConsultaNegativacaoHelper.getIdSetorComercial() != null) {
				sql = sql + " and re.setorComercial.id = " + dadosConsultaNegativacaoHelper.getIdSetorComercial();
			}

			if (dadosConsultaNegativacaoHelper.getIdQuadra() != null) {
				sql = sql + " and re.quadra.id = " + dadosConsultaNegativacaoHelper.getIdQuadra();
			}

			// if (dadosConsultaNegativacaoHelper.getIdGrupoCobranca() != null)
			// {
			// sql = sql
			// + " and re.cobrancaGrupo.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdGrupoCobranca();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdGerenciaRegional() !=
			// null) {
			// sql = sql
			// + " and re.gerenciaRegional.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdGerenciaRegional();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdImovelPerfil() != null) {
			// sql = sql
			// + " and re.imovelPerfil.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdImovelPerfil();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdCategoria() != null) {
			// sql = sql
			// + " and re.categoria.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdCategoria();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdEsferaPoder() != null) {
			// sql = sql
			// + " and re.esferaPoder.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdEsferaPoder();
			// }
		}

		String retorno = sql + restricao;

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documentos Cobrança Consultar os documentos de
	 * cobranca sem carregar os criterios de cobranca
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos,Sávio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 22/05/2008, 08/07/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoResumoAcaoCobranca(int idCobrancaAtividadeAcaoCronograma, int idCobrancaAtividadeAcaoComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id, "
					+ "cobrancaDocumento.emissao, "
					+ "cobrancaDocumento.imovel.id, "
					+ "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.id, "
					+ "cas.id, "
					+ "loc.id, "
					+ "cobrancaDocumento.categoria.id, "
					+ "cobrancaDocumento.esferaPoder.id, "
					+ "cobrancaDocumento.cobrancaDebitoSituacao.id ) "
					+ "from CobrancaDocumento cobrancaDocumento "
					+ "left join cobrancaDocumento.localidade loc "
					+ "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "left join cobrancaDocumento.cobrancaAcaoSituacao cas "
					+ (idCobrancaAtividadeAcaoCronograma != ConstantesSistema.NUMERO_NAO_INFORMADO ? "where cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id = :idCobrancaAtividadeAcaoCronograma "
							: "where cobrancaDocumento.cobrancaAcaoAtividadeComando.id = :idCobrancaAtividadeAcaoComando ")
					// +
					// " and (cobrancaDocumento.cobrancaDebitoSituacao is null or "
					// + "      cobrancaDocumento.cobrancaDebitoSituacao.id = "
					// + CobrancaDebitoSituacao.PENDENTE + " ) "
					+ "order by cobrancaDocumento.id";

			if (idCobrancaAtividadeAcaoCronograma != ConstantesSistema.NUMERO_NAO_INFORMADO) {
				retorno = session.createQuery(consulta).setInteger("idCobrancaAtividadeAcaoCronograma", idCobrancaAtividadeAcaoCronograma)
						.list();
			} else {
				retorno = session.createQuery(consulta).setInteger("idCobrancaAtividadeAcaoComando", idCobrancaAtividadeAcaoComando).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobrança Eventual Consultar os documentos
	 * de cobranca sem carregar os criterios de cobranca
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CACM_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_COMANDO
	 * 
	 * @author Rafael Santos,Sávio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 04/06/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoEventualSemCriterio(int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cbdo_id as idCobrancaDocumento, " + // 0
					"cbdo_tmemissao as emissao, " + // 1
					"imov_id as idImovel, " + // 2
					"cbdo_vldocumento as valorDocumento, " + // 3
					"cbct_id as idCriterio, " + // 4
					"cast_id as idSituacaoAcao " // 5
					+ " from cobranca.cobranca_documento cobranca" + " where cacm_id = :idCobrancaAtividadeAcaoComando ";

			retorno = session.createSQLQuery(consulta).addScalar("idCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("emissao", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL).addScalar("idCriterio", Hibernate.INTEGER)
					.addScalar("idSituacaoAcao", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoComando", idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Método para atualizar a situacao do documento item de acordo com a
	 * situacao da conta / guia de pagamento / debito a cobrar. Este método será
	 * usado nos métodos cancelar/desfazer cancelamento conta, incluir /
	 * desfazer parcelamento, incluir / excluir pagamento, movimento de
	 * arrecadadores
	 * 
	 * @param situacaoDebito
	 * @param dataSituacao
	 * @param idConta
	 * @param idGuiaPagamento
	 * @param idDebitoACobrar
	 * @throws ErroRepositorioException
	 * 
	 * @author Francisco do Nascimento
	 * @date 26/05/2008
	 * 
	 */
	public void atualizarSituacaoCobrancaDocumentoItem(Integer situacaoDebito, Date dataSituacao, Integer idConta, Integer idGuiaPagamento,
			Integer idDebitoACobrar, Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		// Atualizar apenas o item do documento do cobranca com a maior data de
		// emissao
		String queryAtualizar = "";
		String queryConsultar = "";
		try {

			/*
			 * * Alteração em 10/02/09 Por Francisco / Ana Breda Alterado para
			 * atualizar apenas itens contidos em documentos do tipo Aviso de
			 * corte, corte administrativo e corte fisico, por conta do Resumo
			 * de Ação de cobrança.
			 */
			String dataSituacaoParaSQL = Util.formatarDataComTracoAAAAMMDD(dataSituacao);

			queryConsultar = "select cobrancado1_.cdit_id as idItem " + " from cobranca.cobranca_documento_item cobrancado1_ "
					+ " inner join cobranca.cobranca_documento cobrancado0_ on cobrancado0_.cbdo_id = cobrancado1_.cbdo_id ";

			if (idConta != null) {

				queryConsultar = queryConsultar
						+ " inner join (select conta3_.cnta_id as idConta "
						+ " from faturamento.conta conta2_, faturamento.conta conta3_ "
						+ " where conta2_.cnta_id = "
						+ idConta
						+ " and conta2_.imov_id = conta3_.imov_id "
						+ " and conta2_.cnta_amreferenciaconta = conta3_.cnta_amreferenciaconta) conta on conta.idConta = cobrancado1_.cnta_id ";

				queryConsultar = queryConsultar + " where cobrancado0_.dotp_id <> " + DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('" + dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS')  ";
			} else if (idGuiaPagamento != null) {

				queryConsultar = queryConsultar + " where cobrancado0_.dotp_id <> " + DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('" + dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS') "
						+ "and cobrancado1_.gpag_id = " + idGuiaPagamento;
			} else if (idDebitoACobrar != null) {

				queryConsultar = queryConsultar + " where cobrancado0_.dotp_id <> " + DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('" + dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS') "
						+ "and cobrancado1_.dbac_id = " + idDebitoACobrar;
			} else {
				return;
			}
			
			if (idCobrancaDocumento != null) {
				queryConsultar = queryConsultar + " and cobrancado0_.cbdo_id = " + idCobrancaDocumento;
			}
			queryConsultar = queryConsultar + " order by cobrancado0_.cbdo_tmemissao desc ";

			Collection pesquisa = session.createSQLQuery(queryConsultar).addScalar("idItem", Hibernate.INTEGER).setMaxResults(1).list();

			session.clear();

			if (pesquisa != null && !pesquisa.isEmpty()) {
				Integer idItem = (Integer) pesquisa.iterator().next();
				queryAtualizar = "update gcom.cobranca.CobrancaDocumentoItem cdi "
						+ " set cobrancaDebitoSituacao = :situacaoDebito, dataSituacaoDebito = :dataSituacaoDebito ,"
						+ " ultimaAlteracao = :ultimaAlteracao " + "	where cdit_id = " + idItem;

				session.createQuery(queryAtualizar).setInteger("situacaoDebito", situacaoDebito)
						.setDate("dataSituacaoDebito", dataSituacao).setTimestamp("ultimaAlteracao", new Date()).executeUpdate();

			}
			session.flush();

		} catch (HibernateException e) {
			System.out.println("Erro: " + e.getMessage());

			throw new ErroRepositorioException(e, "Erro no Hibernate: " + e.getMessage());
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Recupera os dados de documento item com situacao atualizada
	 * 
	 * @author Francisco do Nascimento
	 * @created 19/05/08
	 * 
	 * @param idDocumentoCobranca
	 *            id do documento de cobranca
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosCobrancaDocumentoItemSituacaoJaAtualizada(Integer idDocumentoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT cdi.id,"// 0
					+ " cdi.valorItemCobrado,"// 1
					+ " cdi.cobrancaDebitoSituacao.id, " // 2
					+ " cdi.dataSituacaoDebito " // 3
					+ "FROM CobrancaDocumentoItem cdi " + "WHERE cdi.cobrancaDocumento.id = :idDocumentoCobranca ";

			retorno = session.createQuery(consulta).setInteger("idDocumentoCobranca", idDocumentoCobranca).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel, Date dataEmissao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,cd.valorTaxa,loca.id,documentoTipo.id "
					+ "FROM CobrancaDocumento cd " + "LEFT JOIN cd.imovel imovel " + "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca " + "WHERE to_date(cd.emissao, 'yyyy-MM-dd') = :dataEmissao AND "
					+ "imovel.id = :idImovel";

			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

			retorno = (Object[]) session.createQuery(consulta).setString("dataEmissao", sdf.format(dataEmissao))
					.setInteger("idImovel", idImovel.intValue()).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel, BigDecimal valorPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,cd.valorTaxa,loca.id,documentoTipo.id "
					+ "FROM CobrancaDocumento cd " + "LEFT JOIN cd.imovel imovel " + "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca " + "WHERE cd.valorDocumento = :valorDocumento AND " + "imovel.id = :idImovel";

			retorno = (Object[]) session.createQuery(consulta).setBigDecimal("valorDocumento", valorPagamento)
					.setInteger("idImovel", idImovel.intValue()).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel, Date dataEmissao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id " // 15
					+ "FROM CobrancaDocumentoItem cdi " + "LEFT JOIN cdi.cobrancaDocumento cd " + "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo " + "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage " + "LEFT JOIN cd.localidade loca " + "LEFT JOIN cd.imovel imov "
					+ "WHERE to_date(cd.emissao, 'yyyy-MM-dd') = :dataEmissao AND " + "imovel.id = :idImovel";

			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

			retorno = session.createQuery(consulta).setString("dataEmissao", sdf.format(dataEmissao))
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UCXXXX] - Emitir Documento de Cobrança
	 * 
	 * @author Rafael Corrêa
	 * @date 02/09/2009
	 * 
	 * @param idCobrancaDocumento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarCobrancaDocumentoItem(Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Conta> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT conta " + "FROM CobrancaDocumentoItem cdi " + "INNER JOIN cdi.cobrancaDocumento cd "
					+ "INNER JOIN cdi.contaGeral contaGeral " + "INNER JOIN contaGeral.conta conta "
					+ "WHERE cd.id = :idCobrancaDocumento " + "ORDER BY conta.referencia ";

			retorno = session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Verificar se existe pagamento para contas de um imovel as quais foram
	 * utilizadas como entrada num parcelamento
	 * 
	 * @param idImovel
	 * @param dataParcelamento
	 * @return
	 * @throws ErroRepositorioException
	 * 
	 * @author Francisco do Nascimento
	 * @date 03/07/2008
	 * 
	 */
	public boolean exitePagamentoContaEntradaParcelamento(Integer idImovel, Date dataParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;
		boolean existe = false;

		try {
			/*
			 * SELECT * FROM cobranca.parcelamento parc, faturamento.conta c,
			 * arrecadacao.pagamento pag where parc.parc_id = c.parc_id and
			 * pag.cnta_id = c.cnta_id and c.imov_id = 18604620 and
			 * cast(parc.parc_tmparcelamento as Date) = '2008-06-12'
			 */
			consulta = "SELECT parc.parc_id as id FROM cobranca.parcelamento parc, " + "faturamento.conta c, arrecadacao.pagamento pag "
					+ "where parc.parc_id = c.parc_id and pag.cnta_id = c.cnta_id and " + "c.imov_id = " + idImovel + " and "
					+ "cast(parc.parc_tmparcelamento as Date) = to_date('" + Util.formatarDataComTracoAAAAMMDD(dataParcelamento)
					+ "','YYYY-MM-DD')";
			// consulta = "SELECT parc.id FROM Parcelamento parc, "
			// + "Conta c, "
			// + "Pagamento pag "
			// + "WHERE parc.id = c.parcelamento.id "
			// + " and c.id = pag.conta.id "
			// + " and c.imovel.id = :idImovel and c.parcelamento is not null "
			// + " and cast(c.parcelamento as Date) = :dataParcelamento ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("id", Hibernate.INTEGER).setMaxResults(1).uniqueResult();

			if (retorno != null) {
				existe = true;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return existe;

	}

	/**
	 * Consulta as contas transferidas
	 * 
	 * [UC0204] - Consultar Transferências do Débito
	 * 
	 * @author Rafael Corrêa
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarContasTransferidas(ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT contaOrigem.cnta_amreferenciaconta as anoMesReferencia, contaOrigem.imov_id as idImovelOrigem, "
					+ " contaDestino.imov_id as idImovelDestino, usuario.usur_nmusuario as nomeUsuario, "
					+ " contaOrigem.cnta_tmultimaalteracao as dataTransferencia, contaOrigem.cnta_id as idConta "
					+ " FROM faturamento.conta contaDestino " + " INNER JOIN faturamento.conta contaOrigem "
					+ " on contaDestino.cnta_idorigem = contaOrigem.cnta_id " + " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on contaOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta + " contaOrigem.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta + " contaDestino.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = " + consultarTransferenciasDebitoHelper.getIdUsuario() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta + " contaOrigem.cnta_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " UNION "
					+ " SELECT contaHistOrigem.cnhi_amreferenciaconta as anoMesReferencia, contaHistOrigem.imov_id as idImovelOrigem, "
					+ " contaHistDestino.imov_id as idImovelDestino, usuario.usur_nmusuario as nomeUsuario, "
					+ " contaHistOrigem.cnhi_tmultimaalteracao as dataTransferencia, contaHistOrigem.cnta_id as idConta "
					+ " FROM faturamento.conta_historico contaHistDestino " + " INNER JOIN faturamento.conta_historico contaHistOrigem "
					+ " on contaHistDestino.cnta_idorigem = contaHistOrigem.cnta_id " + " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on contaHistOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta + " contaHistOrigem.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta + " contaHistDestino.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = " + consultarTransferenciasDebitoHelper.getIdUsuario() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta + " contaHistOrigem.cnhi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " ORDER BY idImovelOrigem, idImovelDestino, anoMesReferencia ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session.createSQLQuery(consulta).addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("idImovelOrigem", Hibernate.INTEGER).addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING).addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idConta", Hibernate.INTEGER)
						.setTimestamp("dataInicial", consultarTransferenciasDebitoHelper.getDataInicial())
						.setTimestamp("dataFinal", consultarTransferenciasDebitoHelper.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session.createSQLQuery(consulta).addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("idImovelOrigem", Hibernate.INTEGER).addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING).addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idConta", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta os débitos a cobrar transferidos
	 * 
	 * [UC0204] - Consultar Transferências do Débito
	 * 
	 * @author Rafael Corrêa
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarDebitosACobrarTransferidos(ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, debitoDestino.imov_id as idImovelDestino, "
					+ " debitoOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " debitoOrigem.dbac_tmultimaalteracao as dataTransferencia, debitoOrigem.dbac_id as idDebito "
					+ " FROM faturamento.debito_a_cobrar debitoDestino " + " INNER JOIN faturamento.debito_a_cobrar debitoOrigem "
					+ " on debitoDestino.dbac_idorigem = debitoOrigem.dbac_id " + " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on debitoOrigem.dbtp_id = debitoTipo.dbtp_id " + " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on debitoOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta + " debitoOrigem.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta + " debitoDestino.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = " + consultarTransferenciasDebitoHelper.getIdUsuario() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta + " debitoOrigem.dbac_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " UNION "
					+ " SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, debitoHistDestino.imov_id as idImovelDestino, "
					+ " debitoHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " debitoHistOrigem.dahi_tmultimaalteracao as dataTransferencia, debitoHistOrigem.dbac_id as idDebito "
					+ " FROM faturamento.deb_a_cobrar_hist debitoHistDestino "
					+ " INNER JOIN faturamento.deb_a_cobrar_hist debitoHistOrigem "
					+ " on debitoHistDestino.dbac_idorigem = debitoHistOrigem.dbac_id " + " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on debitoHistOrigem.dbtp_id = debitoTipo.dbtp_id " + " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on debitoHistOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta + " debitoHistOrigem.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta + " debitoHistDestino.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = " + consultarTransferenciasDebitoHelper.getIdUsuario() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta + " debitoHistOrigem.dahi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " ORDER BY idImovelOrigem, idImovelDestino, debitoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session.createSQLQuery(consulta).addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER).addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING).addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idDebito", Hibernate.INTEGER)
						.setTimestamp("dataInicial", consultarTransferenciasDebitoHelper.getDataInicial())
						.setTimestamp("dataFinal", consultarTransferenciasDebitoHelper.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session.createSQLQuery(consulta).addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER).addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING).addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idDebito", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta as guias de pagamento transferidas
	 * 
	 * [UC0204] - Consultar Transferências do Débito
	 * 
	 * @author Rafael Corrêa
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarGuiasDePagamentoTransferidas(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, guiaDestino.imov_id as idImovelDestino, "
					+ " guiaOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " guiaOrigem.gpag_tmultimaalteracao as dataTransferencia, guiaOrigem.gpag_id as idGuia "
					+ " FROM faturamento.guia_pagamento guiaDestino " + " INNER JOIN faturamento.guia_pagamento guiaOrigem "
					+ " on guiaDestino.gpag_idorigem = guiaOrigem.gpag_id " + " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on guiaOrigem.dbtp_id = debitoTipo.dbtp_id " + " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on guiaOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta + " guiaOrigem.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta + " guiaDestino.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = " + consultarTransferenciasDebitoHelper.getIdUsuario() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta + " guiaOrigem.gpag_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " UNION "
					+ " SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, guiaHistDestino.imov_id as idImovelDestino, "
					+ " guiaHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " guiaHistOrigem.gphi_tmultimaalteracao as dataTransferencia, guiaHistOrigem.gpag_id as idGuia "
					+ " FROM faturamento.guia_pagamento_historico guiaHistDestino "
					+ " INNER JOIN faturamento.guia_pagamento_historico guiaHistOrigem "
					+ " on guiaHistDestino.gpag_idorigem = guiaHistOrigem.gpag_id " + " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on guiaHistOrigem.dbtp_id = debitoTipo.dbtp_id " + " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on guiaHistOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta + " guiaHistOrigem.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta + " guiaHistDestino.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = " + consultarTransferenciasDebitoHelper.getIdUsuario() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta + " guiaHistOrigem.gphi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " ORDER BY idImovelOrigem, idImovelDestino, debitoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session.createSQLQuery(consulta).addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER).addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING).addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idGuia", Hibernate.INTEGER)
						.setTimestamp("dataInicial", consultarTransferenciasDebitoHelper.getDataInicial())
						.setTimestamp("dataFinal", consultarTransferenciasDebitoHelper.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session.createSQLQuery(consulta).addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER).addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING).addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idGuia", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta os créditos a realizar transferidos
	 * 
	 * [UC0204] - Consultar Transferências do Débito
	 * 
	 * @author Rafael Corrêa
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarCreditosARealizarTransferidos(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT creditoTipo.crti_dscreditotipo as creditoTipo, creditoDestino.imov_id as idImovelDestino, "
					+ " creditoOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " creditoOrigem.crar_tmultimaalteracao as dataTransferencia, creditoOrigem.crar_id as idCredito "
					+ " FROM faturamento.credito_a_realizar creditoDestino " + " INNER JOIN faturamento.credito_a_realizar creditoOrigem "
					+ " on creditoDestino.crar_idorigem = creditoOrigem.crar_id " + " INNER JOIN faturamento.credito_tipo creditoTipo "
					+ " on creditoOrigem.crti_id = creditoTipo.crti_id " + " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on creditoOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta + " creditoOrigem.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta + " creditoDestino.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = " + consultarTransferenciasDebitoHelper.getIdUsuario() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta + " creditoOrigem.crar_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " UNION "
					+ " SELECT creditoTipo.crti_dscreditotipo as creditoTipo, creditoHistDestino.imov_id as idImovelDestino, "
					+ " creditoHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " creditoHistOrigem.carh_tmultimaalteracao as dataTransferencia, creditoHistOrigem.crar_id as idCredito "
					+ " FROM faturamento.cred_a_realiz_hist creditoHistDestino "
					+ " INNER JOIN faturamento.cred_a_realiz_hist creditoHistOrigem "
					+ " on creditoHistDestino.crar_idorigem = creditoHistOrigem.crar_id "
					+ " INNER JOIN faturamento.credito_tipo creditoTipo " + " on creditoHistOrigem.crti_id = creditoTipo.crti_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario " + " on creditoHistOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta + " creditoHistOrigem.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta + " creditoHistDestino.imov_id = " + consultarTransferenciasDebitoHelper.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = " + consultarTransferenciasDebitoHelper.getIdUsuario() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta + " creditoHistOrigem.carh_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta + " ORDER BY idImovelOrigem, idImovelDestino, creditoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session.createSQLQuery(consulta).addScalar("creditoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER).addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING).addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idCredito", Hibernate.INTEGER)
						.setTimestamp("dataInicial", consultarTransferenciasDebitoHelper.getDataInicial())
						.setTimestamp("dataFinal", consultarTransferenciasDebitoHelper.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session.createSQLQuery(consulta).addScalar("creditoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER).addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING).addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idCredito", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 15/07/2008
	 */
	public Collection<Object[]> obterNomeCPFTestemunhas(Integer unidadeUsuario) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select usur.nomeUsuario,usur.cpf " + " from UnidadeOrganizacionalTestemunha unte "
					+ " inner join unte.unidadeOrganizacional un " + " inner join unte.usuario usur "
					+ " where un.id = :unidadeUsuario and " + " unte.dataFimRelacao is null " + " order by unte.id ";

			retorno = (Collection<Object[]>) session.createQuery(consulta).setInteger("unidadeUsuario", unidadeUsuario).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0852] Incluir Débito a Cobrar de Entrada de Parcelamento Não Paga
	 * 
	 * Cancela uma guia de pagamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param idGuiaPagamento
	 * @throws ErroRepositorioException
	 */
	public void cancelarGuiaPagamento(Integer idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String cancelarGuia;

		try {
			cancelarGuia = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set dcst_idanterior = (SELECT debitoCreditoSituacaoAtual.id FROM GuiaPagamento gpag "
					+ "WHERE gpag.id = :idGuiaPagamento), " + "dcst_idatual = :idCancelada, "
					+ "gpag_tmultimaalteracao = :ultimaAlteracao " + "where gpag_id = :idGuiaPagamento";

			session.createQuery(cancelarGuia).setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.setInteger("idCancelada", DebitoCreditoSituacao.CANCELADA).setTimestamp("ultimaAlteracao", new Date()).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0852] Incluir Débito a Cobrar de Entrada de Parcelamento Não Paga
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param parcelamento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaDoParcelamentoNaoPago(Integer parcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT cnta FROM Conta cnta " + "INNER JOIN cnta.parcelamento parc " + "WHERE parc.id = :parcelamento "
					+ "and cnta.debitoCreditoSituacaoAtual in (0,1,2) ";

			retorno = session.createQuery(consulta).setInteger("parcelamento", parcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	private String criarCondicionaisPesquisarContasInformarContasEmCobranca(ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta) {
		String retorno = "";

		if (comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial() != null) {
			retorno = retorno + " and conta.cnta_cdsetorcomercial between " + comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial()
					+ " and " + comandoEmpresaCobrancaConta.getCodigoSetorComercialFinal();
		}

		if (comandoEmpresaCobrancaConta.getNumeroQuadraInicial() != null) {
			retorno = retorno + " and conta.cnta_nnquadra between " + comandoEmpresaCobrancaConta.getNumeroQuadraInicial()
					+ " and " + comandoEmpresaCobrancaConta.getNumeroQuadraFinal();
		}

		if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {
			retorno = retorno + "  and conta.cnta_amreferenciaconta between " + comandoEmpresaCobrancaConta.getReferenciaContaInicial()
					+ " and " + comandoEmpresaCobrancaConta.getReferenciaContaFinal();
		}

		if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {
			retorno = retorno + "  and conta.cnta_dtvencimentoconta between to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta.getDataVencimentoContaInicial())
					+ "','YYYY-MM-DD') and to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta.getDataVencimentoContaFinal()) + "','YYYY-MM-DD')";
		}

		if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {
			retorno = retorno
					+ " and ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) between "
					+ comandoEmpresaCobrancaConta.getValorMinimoConta() + " and " + comandoEmpresaCobrancaConta.getValorMaximoConta();
		}

		return retorno;
	}

	private String criarCondicionaisPesquisarContasInformarContasEmCobrancaNegacao(ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta) {
		String retorno = " pagto.pgmt_id is null and conta.dcst_idatual in ( " + DebitoCreditoSituacao.NORMAL + ", "
				+ DebitoCreditoSituacao.INCLUIDA + ", " + DebitoCreditoSituacao.RETIFICADA + " ) and ( ";

		boolean algumCriterioContaInformado = false;

		if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {

			algumCriterioContaInformado = true;

			retorno = retorno + " conta.cnta_amreferenciaconta not between " + comandoEmpresaCobrancaConta.getReferenciaContaInicial()
					+ " and " + comandoEmpresaCobrancaConta.getReferenciaContaFinal() + " or ";
		}

		if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {

			algumCriterioContaInformado = true;

			retorno = retorno + " conta.cnta_dtvencimentoconta not between to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta.getDataVencimentoContaInicial())
					+ "','YYYY-MM-DD') and to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta.getDataVencimentoContaFinal()) + "','YYYY-MM-DD') or ";
		}

		if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

			algumCriterioContaInformado = true;

			retorno = retorno
					+ " ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) not between "
					+ comandoEmpresaCobrancaConta.getValorMinimoConta() + " and " + comandoEmpresaCobrancaConta.getValorMaximoConta()
					+ " or ";
		}

		if (algumCriterioContaInformado) {
			retorno = Util.removerUltimosCaracteres(retorno, 3) + " ) ";
		} else {
			retorno = Util.removerUltimosCaracteres(retorno, 6);
		}

		return retorno;
	}

	/**
	 * [UC0852] Incluir Débito a Cobrar de Entrada de Parcelamento Não Paga
	 * 
	 * Desassociar a conta do parcelamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public void desassociarContaParcelamento(Integer idConta) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String desassociarConta;

		try {
			desassociarConta = "update gcom.faturamento.conta.Conta " + "set parc_id = null, cnta_tmultimaalteracao = :ultimaAlteracao "
					+ "where cnta_id = :idConta";

			session.createQuery(desassociarConta).setInteger("idConta", idConta.intValue()).setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera os itens do parcelamento a partir do parcelamento
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public List<ParcelamentoItem> pesquisarItensParcelamentos(Integer idParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		List<ParcelamentoItem> retorno = null;
		StringBuilder consulta = new StringBuilder();

		try {
//			consulta.append("select cg.id," + " dacg.id, " + "CASE " + " WHEN cg.indicadorHistorico = 2  " + " THEN (conta.valorAgua + "
//					+ "conta.valorEsgoto + " + "conta.debitos - " + "(conta.valorCreditos - coalesce(conta.valorImposto,0))) "
//					+ " ELSE (ch.valorAgua + " + "ch.valorEsgoto + " + "ch.valorDebitos - "
//					+ "(ch.valorCreditos - coalesce(ch.valorImposto,0))) " + " END " + " from ParcelamentoItem pi "
//					+ " left join pi.debitoACobrarGeral dacg " + " left join pi.contaGeral cg " + " left join cg.contaHistorico ch "
//					+ " left join cg.conta conta " + " where pi.parcelamento.id = :idParcelamento";
			
			consulta.append(" select pi ")
					.append(" from ParcelamentoItem pi ")
					.append(" left join fetch pi.debitoACobrarGeral dacg ")
					.append(" left join fetch pi.contaGeral cg ")
					.append(" left join fetch cg.contaHistorico ch ")
					.append(" left join fetch cg.conta conta ")
					.append(" where pi.parcelamento.id = :idParcelamento ");

			retorno = (List<ParcelamentoItem>) session.createQuery(consulta.toString()).setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Object[] pesquisarDadosDebitoACobrar(Integer idDebitoACobrar) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select parc.id, " + " dabh.prestacaoDebito, " + " dabh.prestacaoCobradas " + " from DebitoACobrarHistorico dabh "
					+ " inner join dabh.parcelamento parc " + " where dabh.id = :idDebitoACobrar";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os itens do parcelamento a partir do parcelamento
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public Collection<Object[]> pesquisarItensParcelamentosNivel2(Integer idParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select cg.id,"// 0
					+ " dacg.id, "// 1
					+ "CASE "// 2
					+ " WHEN cg.indicadorHistorico = 2  " + " THEN (conta.valorAgua + " + "conta.valorEsgoto + "
					+ "conta.debitos - "
					+ "(conta.valorCreditos - coalesce(conta.valorImposto,0))) " + " ELSE (ch.valorAgua + "
					+ "ch.valorEsgoto + "
					+ "ch.valorDebitos - " + "(ch.valorCreditos - coalesce(ch.valorImposto,0))) " + " END "
					+ " from ParcelamentoItem pi "
					+ " left join pi.debitoACobrarGeral dacg " + " inner join pi.parcelamento parc "
					+ " left join pi.contaGeral cg "
					+ " left join cg.contaHistorico ch " + " left join cg.conta conta " + " where parc.id = :idParcelamento";

			retorno = (Collection<Object[]>) session.createQuery(consulta).setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 29/10/2008
	 */
	public Collection pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobranca(Integer idEmpresa, Date comandoInicial,
			Date comandoFinal, int numeroIndice, int quantidadeRegistros) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que já monta uma coleção de
		 * GerarArquivoTextoContasCobrancaEmpresaHelper com tudo que é
		 * necessário **
		 */
		try {
			consulta = "select new gcom.cobranca.GerarArquivoTextoContasCobrancaEmpresaHelper(" + " comandoEmpresaCobrancaConta.id,"
					+ " comandoEmpresaCobrancaConta.empresa.id," + " comandoEmpresaCobrancaConta.empresa.descricao,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal," + "	comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ " comandoEmpresaCobrancaConta.valorMaximoConta," + "	comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal," + " comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal," + " comandoEmpresaCobrancaConta.dataExecucao,"
					+ " comandoEmpresaCobrancaConta.imovel.id," + " comandoEmpresaCobrancaConta.cliente.id,"
					+ " comandoEmpresaCobrancaConta.cliente.nome," + " comandoEmpresaCobrancaConta.localidadeInicial.id,"
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id," + " comandoEmpresaCobrancaConta.unidadeNegocio.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome," + " count(ecco.comandoEmpresaCobrancaConta.id),"
					+ " sum(ecco.valorOriginalConta)," + " comandoEmpresaCobrancaConta.ultimaAlteracao) "
					+ "from EmpresaCobrancaConta ecco " + "inner join ecco.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "left join comandoEmpresaCobrancaConta.cliente cliente "
					+ "left join comandoEmpresaCobrancaConta.localidadeInicial localidadeInicial "
					+ "left join comandoEmpresaCobrancaConta.localidadeFinal localidadeFinal "
					+ "left join comandoEmpresaCobrancaConta.unidadeNegocio unidadeNegocio "
					+ "inner join comandoEmpresaCobrancaConta.empresa empresa " + "inner join ecco.contaGeral contaGeral "
					+ "inner join contaGeral.conta conta " + "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa "
					+ "and conta.debitoCreditoSituacaoAtual.id in (" + DebitoCreditoSituacao.NORMAL + ", "
					+ DebitoCreditoSituacao.RETIFICADA + ", " + DebitoCreditoSituacao.INCLUIDA + " ) "
					+ "and  NOT EXISTS (select pg.contaGeral.id from Pagamento pg  where pg.contaGeral.id = conta.id) ";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta + " and " + "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial) + "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal) + "','YYYY-MM-DD') ";

			}

			consulta = consulta + "group by new," + " comandoEmpresaCobrancaConta.empresa.id,"
					+ " comandoEmpresaCobrancaConta.empresa.descricao," + " comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal," + "	comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ " comandoEmpresaCobrancaConta.valorMaximoConta," + "	comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal," + " comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal," + " comandoEmpresaCobrancaConta.dataExecucao,"
					+ " comandoEmpresaCobrancaConta.imovel.id," + " comandoEmpresaCobrancaConta.cliente.id,"
					+ " comandoEmpresaCobrancaConta.cliente.nome," + " comandoEmpresaCobrancaConta.localidadeInicial.id,"
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id," + " comandoEmpresaCobrancaConta.unidadeNegocio.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome," + " comandoEmpresaCobrancaConta.ultimaAlteracao ";

			retorno = session.createQuery(consulta).setInteger("idEmpresa", idEmpresa).setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 */
	public Integer pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobrancaCount(Integer idEmpresa, Date comandoInicial,
			Date comandoFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT COUNT(DISTINCT comandoEmpresaCobrancaConta.id) "
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta + " and " + "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial) + "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal) + "','YYYY-MM-DD') ";

			}

			retorno = (Integer) session.createQuery(consulta).setInteger("idEmpresa", idEmpresa).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 */
	public Collection<Object[]> pesquisarDadosArquivoTextoContasCobrancaEmpresa(Collection ids, Integer idProgramaEspecial) throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();
		Collection<Object[]> retorno = null;

		try {
			String consulta = "SELECT ecco.ecco_id as idEmpresaCobrancaConta, "// 0
					+ "unidadeNegocio.uneg_id as idUnidadeNegocio, "// 1
					+ "unidadeNegocio.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 2
					+ "rota.ftgr_id as idGrupoFaturamento, "// 3
					+ "localidade.loca_id as idLocalidade, "// 4
					+ "localidade.loca_nmlocalidade as nomeLocalidade, "// 5
					+ "rota.rota_cdrota as codigoRota, "// 6
					+ "imovel.imov_nnsequencialrota as numeroSequencial, "// 7
					+ "conta.imov_id as idImovel, "// 8
					+ "cliente.clie_nmcliente as nomeCliente, "// 9
					+ "clienteTipo.cltp_icpessoafisicajuridica as idClienteTipo, "// 10
					+ "cliente.clie_nncpf as numeroCpf, "// 11
					+ "cliente.clie_nncnpj as numeroCnpj, "// 12
					+ "cliente.clie_nnrg as numeroRg, "// 13
					+ "quadra.qdra_nnquadra as numeroQuadra, "// 14
					+ "conta.cnta_id as idConta, "// 15
					+ "clienteFone.cfon_nnfone as numeroFone, "// 16
					+ "cliente.clie_nmabreviado as nomeAbreviadoCliente, "// 17
					+ "conta.cnta_amreferenciaconta as anoMesConta, "// 18
					+ "conta.cnta_dtvencimentoconta as vencimentoConta, "// 19
					+ "conta.cnta_vlagua as valorAgua, "// 20
					+ "conta.cnta_vlesgoto as valorEsgoto, "// 21
					+ "conta.cnta_vldebitos as valorDebitos, "// 22
					+ "conta.cnta_vlcreditos as valorCreditos, "// 23
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 then conta.cnta_cdsetorcomercial else stcm.stcm_cdsetorcomercial end as codigoSetorComercial, "// 24
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 then conta.cnta_nnlote else imovel.imov_nnlote end as numeroLote, "// 25
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 then conta.cnta_nnsublote else imovel.imov_nnsublote end as numeroSublote, "// 26
					+ "cliente.clie_id as idCliente, "// 27
					+ "gerenciaRegional.greg_id AS idGerenciaRegional, "// 28
					+ "gerenciaRegional.greg_nmregional AS nomeGerenciaRegional, "// 29
					+ "emco.emco_cdlayouttxt AS codigoLayout, "// 30
					+ "ecco.orse_id AS idOrdemServico, " // 31
					+ "clienteFone.cfon_cdddd as dddFone, "// 32
					+ "cecc.cecc_dtiniciociclo as dataInicioCiclo, "// 33
					+ "cecc.cecc_dtfimciclo as dataFimCiclo "// 34
					+ "FROM cobranca.empresa_cobranca_conta ecco "
					+ "INNER JOIN cobranca.cmd_empr_cobr_conta cecc ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN faturamento.conta conta ON (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ "INNER JOIN cadastro.imovel imovel ON imovel.imov_id  = conta.imov_id "
					+ "INNER JOIN cadastro.cliente_imovel clienteImovel ON clienteImovel.imov_id  = imovel.imov_id AND clim_dtrelacaofim is null AND clim_icnomeconta = 1 "
					+ "INNER JOIN cadastro.cliente cliente ON cliente.clie_id = clienteImovel.clie_id "
					+ "LEFT OUTER JOIN cadastro.cliente_fone clienteFone ON clienteFone.clie_id = cliente.clie_id AND cfon_icfonepadrao = 1 AND cfon_cdddd is not null AND cfon_nnfone is not null "
					+ "INNER JOIN cadastro.cliente_tipo clienteTipo on clienteTipo.cltp_id = cliente.cltp_id "
					+ "INNER JOIN cadastro.localidade localidade ON localidade.loca_id = imovel.loca_id "
					+ "INNER JOIN cadastro.unidade_negocio unidadeNegocio ON unidadeNegocio.uneg_id = localidade.uneg_id "
					+ "INNER JOIN cadastro.gerencia_regional gerenciaRegional ON gerenciaRegional.greg_id = localidade.greg_id "
					+ "INNER JOIN cadastro.quadra quadra ON quadra.qdra_id = imovel.qdra_id "
					+ "INNER JOIN micromedicao.rota rota ON rota.rota_id = quadra.rota_id "
					+ "LEFT JOIN cadastro.empr_contrato_cobranca emco ON emco.empr_id = ecco.empr_id "
					+ "LEFT JOIN cadastro.setor_comercial stcm ON stcm.stcm_id = imovel.stcm_id "
					+ "WHERE ecco.cecc_id in (:ids) "
					+ "AND not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			if (idProgramaEspecial != null) {
				consulta += "AND imovel.iper_id <> :idProgramaEspecial ";
			}

			consulta += "ORDER BY ecco.ecco_id, conta.imov_id ";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idEmpresaCobrancaConta", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idGrupoFaturamento", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("codigoRota", Hibernate.SHORT)
					.addScalar("numeroSequencial", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("idClienteTipo", Hibernate.INTEGER)
					.addScalar("numeroCpf", Hibernate.STRING)
					.addScalar("numeroCnpj", Hibernate.STRING)
					.addScalar("numeroRg", Hibernate.STRING)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("numeroFone", Hibernate.STRING)
					.addScalar("nomeAbreviadoCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("vencimentoConta", Hibernate.DATE)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroLote", Hibernate.SHORT)
					.addScalar("numeroSublote", Hibernate.SHORT)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerenciaRegional", Hibernate.STRING)
					.addScalar("codigoLayout", Hibernate.SHORT)
					.addScalar("idOrdemServico", Hibernate.INTEGER)
					.addScalar("dddFone", Hibernate.STRING)
					.addScalar("dataInicioCiclo", Hibernate.DATE)
					.addScalar("dataFimCiclo", Hibernate.DATE)
					.setParameterList("ids", ids);

			if (idProgramaEspecial != null) {
				query.setInteger("idProgramaEspecial", idProgramaEspecial);
			}

			retorno = query.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa se a conta está na tabela de empresa cobranca conta
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public void removerEmpresaCobrancaContaPagamentos(Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {
			consulta = consulta = "delete EmpresaCobrancaContaPagamentos empresaCobrancaContaPagamentos "
					+ "where empresaCobrancaContaPagamentos.anoMesPagamentoArrecadacao = :anoMesReferenciaArrecadacao and "
					+ "empresaCobrancaContaPagamentos.idImovel in("
					+ "select pagamento.imovel.id from Pagamento pagamento "
					+ "where pagamento.localidade.id = :idLocalidade and pagamento.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao )";

			session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Raphael Rossiter
	 * @date 13/11/2008
	 * 
	 * @return Collection<ResolucaoDiretoria>
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaMaiorDataVigenciaInicioPermissaoEspecial()
			throws ErroRepositorioException {

		Collection retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd " + "from ResolucaoDiretoria as rd "
					+ "where rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual " + "order by rd.dataVigenciaInicio ";

			retorno = (Collection) session.createQuery(consulta).setDate("dataAtual", new Date()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a quantidade de Rotas que nao possui um Criterio definido para
	 * cada uma das Acoes de Cobrancas passadas no filtro
	 * 
	 * @author Victor Cisneiros
	 * @date 10/12/2008
	 */
	public Integer pesquisarQtdeRotasSemCriteriosParaAcoesCobranca(PesquisarQtdeRotasSemCriteriosParaAcoesCobranca filtro)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (filtro.getIdGrupoCobranca() != null) {
			where += " AND r.cbgr_id = :idGrupoCobranca ";
		}
		if (filtro.getIdsRotas() != null && filtro.getIdsRotas().size() > 0) {
			where += " AND r.rota_id IN ( :idsRotas ) ";
		}

		try {
			String consulta = "SELECT count(*) as contador FROM ( "
					+

					"SELECT "
					+ "r.rota_id, "
					+ "( SELECT count(*) FROM cobranca.rota_acao_criterio rac WHERE rac.rota_id = r.rota_id AND rac.cbac_id IN (:idsAcoesCobranca) ) as existe_criterio "
					+ "FROM micromedicao.rota r WHERE 1 = 1 " + where + ") as numero_criterios_por_rotas WHERE existe_criterio < "
					+ filtro.getIdsAcoesCobranca().size();

			SQLQuery q = session.createSQLQuery(consulta);

			q.addScalar("contador", Hibernate.INTEGER);

			if (filtro.getIdGrupoCobranca() != null) {
				q.setInteger("idGrupoCobranca", filtro.getIdGrupoCobranca());
			}
			if (filtro.getIdsRotas() != null && filtro.getIdsRotas().size() > 0) {
				q.setParameterList("idsRotas", filtro.getIdsRotas());
			}
			q.setParameterList("idsAcoesCobranca", filtro.getIdsAcoesCobranca());

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Deleta as OrdemServicoUnidade geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarOrdemServicoUnidadeGeradasPelosDocumentosCobranca(Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM OrdemServicoUnidade ou " + "WHERE ou.ordemServico.id IN "
					+ "( SELECT o.id FROM OrdemServico o WHERE o.cobrancaDocumento.id IN ( :idsDocumentosCobranca ) ) ";

			if (idsDocumentosCobranca.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsDocumentosCobranca.size());

				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsDocumentosCobranca, 999);

				int qtdQuebras = 999;
				int indice = idsDocumentosCobranca.size() / qtdQuebras;

				if (idsDocumentosCobranca.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE " + indice + " = " + particoes.get(i).size());

					Query q = session.createQuery(consulta);
					q.setParameterList("idsDocumentosCobranca", particoes.get(i));

					retorno = (Integer) q.executeUpdate();
				}
			} else {
				Query q = session.createQuery(consulta);
				q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);
				retorno = (Integer) q.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Remover os debitos a cobrar das ordens de servico geradas pelos
	 * documentos
	 * 
	 * @author Francisco do Nascimento
	 * @date 18/11/2009
	 */
	public void removerDebitoACobrarOrdemServicoGeradasPelosDocumentosCobranca(Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "delete from DebitoACobrar dac where dac.ordemServico.id in " + "  (SELECT os.id FROM OrdemServico os "
					+ "   where os.cobrancaDocumento.id in (:idsDocumentoCobranca) )";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentoCobranca", idsDocumentosCobranca);

			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Deleta as OrdemServico geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarOrdemServicoGeradasPelosDocumentosCobranca(Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM OrdemServico " + "WHERE cobrancaDocumento IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta as DebitoACobrar geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarDebitoACobrarGeradasPelosDocumentosCobranca(Collection<Integer> idsDocumentosCobranca, Integer anoMesReferencia)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();
		Collection<Integer> idsDebitoACobrar = null;

		try {

			String consulta = "SELECT id FROM DebitoACobrar d " + "WHERE d.imovel.id IN "
					+ "( SELECT c.imovel.id FROM CobrancaDocumento c WHERE c.id IN ( :idsDocumentosCobranca ) ORDER BY c.id ) "
					+ " and d.anoMesReferenciaDebito = :anoMesReferenciaDebito" + " and d.debitoTipo.id = " + DebitoTipo.TAXA_COBRANCA;

			Query q = session.createQuery(consulta).setParameterList("idsDocumentosCobranca", idsDocumentosCobranca)
					.setInteger("anoMesReferenciaDebito", anoMesReferencia);

			idsDebitoACobrar = q.list();

			if (idsDebitoACobrar != null && idsDebitoACobrar.size() > 0) {

				String exclusao1 = "DELETE FROM DebitoACobrarCategoria dac " + "WHERE dac.id.debitoACobrar IN ( :idsDebitosACobrar ) ";

				q = session.createQuery(exclusao1).setParameterList("idsDebitosACobrar", idsDebitoACobrar);

				q.executeUpdate();

				String exclusao2 = "DELETE FROM DebitoACobrar dac " + "WHERE dac.id IN ( :idsDebitosACobrar ) ";

				q = session.createQuery(exclusao2).setParameterList("idsDebitosACobrar", idsDebitoACobrar);

				retorno += (Integer) q.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta as CobrancaDocumentoItem geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarCobrancaDocumentoItemGeradasPelosDocumentosCobranca(Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumentoItem cdi " + "WHERE cdi.cobrancaDocumento.id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta os Documentos de Cobranca com os Ids passados como parametro
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarCobrancaDocumentos(Collection<Integer> idsDocumentosCobranca) throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumento " + "WHERE id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deletar os registros de imoveis nao gerados
	 * 
	 * @author Francisco do Nascimento
	 * @date 17/11/2009
	 */
	public void removerImoveisNaoGerados(Integer idCobrancaComandoCronograma, Integer idCobrancaComandoEventual)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM ImovelNaoGerado ing WHERE ";
			if (idCobrancaComandoCronograma != null) {
				consulta += " ing.cobrancaAcaoAtividadeCronograma.id =  " + idCobrancaComandoCronograma;
			} else {
				consulta += " ing.cobrancaAcaoAtividadeComando.id =  " + idCobrancaComandoEventual;
			}

			Query q = session.createQuery(consulta);
			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Inserir os registros de imoveis nao gerados dos documentos excedentes
	 * 
	 * @author Francisco do Nascimento
	 * @date 18/11/2009
	 */
	public void inserirImoveisNaoGeradosParaDocumentosExcedentes(Collection<Integer> idsDocumentosCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		String sequence = Util.obterNextValSequence("cobranca.seq_imovel_nao_gerado");
		try {
			stmt = con.createStatement();

			String consulta = " insert into cobranca.imovel_nao_gerado " + " select " + sequence + ", caac_id, cacm_id, " + " imov_id, "
					+ MotivoNaoGeracaoDocCobranca.EXCEDEU_METAS + ", " + Util.obterSQLDataAtual()
					+ " FROM cobranca.cobranca_documento where cbdo_id in (-1 ";
			for (Iterator iter = idsDocumentosCobranca.iterator(); iter.hasNext();) {
				Integer id = (Integer) iter.next();
				consulta += ", " + id;
			}
			consulta += ")";

			stmt.executeUpdate(consulta);

		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no SQL");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisar Quantidade de Ordens de Serviço Encerradas
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer pesquisarQuantidadeOrdensServicoEncerradasPorCobrancaAcaoAtividade(Integer idCobrancaAcaoAtividadeCronograma,
			Integer idCobrancaAcaoAtividadeComando) throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where += " AND cd.caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where += " AND cd.cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT orse_id FROM atendimentopublico.ordem_servico os "
					+ "INNER JOIN cobranca.cobranca_documento cd ON (os.cbdo_id = cd.cbdo_id) " + "WHERE os.orse_cdsituacao <> "
					+ OrdemServico.SITUACAO_PENDENTE + " " + where + "  LIMIT 1 ";

			SQLQuery q = session.createSQLQuery(consulta);

			q.addScalar("orse_id", Hibernate.INTEGER);
			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma", idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando", idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisar Quantidade de Pagamentos por Documentos de Cobrança
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer pesquisarQuantidadePagamentosPorDocumentosCobranca(Integer idCobrancaAcaoAtividadeCronograma,
			Integer idCobrancaAcaoAtividadeComando) throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where = "caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where = " cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT pgmt_id from arrecadacao.pagamento where "
					+ "cbdo_id IN ( SELECT cbdo_id FROM cobranca.cobranca_documento cd WHERE " + where + " ) " + " LIMIT 1";

			SQLQuery q = session.createSQLQuery(consulta);
			q.addScalar("pgmt_id", Hibernate.INTEGER);
			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma", idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando", idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisar Quantidade de Comandos realizados de Ações de Cobrança
	 * sucessoras
	 * 
	 * @author Victor Cisneiros
	 * @date 23/12/2008
	 */
	public Integer pesquisarQuantidadeComandosSucessores(Integer idCobrancaAcaoAtividadeCronograma, Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where = " caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where = " cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT cd1.cbdo_id as id FROM cobranca.cobranca_documento cd1 " + "WHERE " + where + "AND exists ( "
					+ "SELECT cd2.cbdo_id FROM cobranca.cobranca_documento cd2 "
					+ "WHERE cd1.imov_id = cd2.imov_id AND cd2.cbdo_tmemissao > cd1.cbdo_tmemissao " + "AND cbac_id IN ( "
					+ "SELECT ca.cbac_id FROM cobranca.cobranca_acao ca WHERE cd1.cbac_id = ca.cbac_idacaoprecedente " + ") " + ") LIMIT 1";

			SQLQuery q = session.createSQLQuery(consulta);
			q.addScalar("id", Hibernate.INTEGER);

			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma", idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando", idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensao Comando Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 02/02/2009
	 */

	public Collection<Object[]> pesquisarDadosGerarExtensaoComandoContasCobrancaEmpresaParaCobranca(Integer idComandoEmpresaCobrancaConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select ccce.ccce_id as idExtensao, " // 0
					+ "ccce.ccce_amreferenciacontainicial as referenciaInicial, "// 1
					+ "ccce.ccce_amreferenciacontafinal as referenciaFinal, " // 2
					+ "ccce.ccce_dtexecucao as dataExecucao " // 3
					// + "count(ecco.cecc_id) as valorOriginalConta, " //4
					// + "sum(ecco.ecco_vloriginalconta) as somaContas "//5
					+ "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "left join cobranca.empresa_cobranca_conta ecco on ecco.ccce_id = ccce.ccce_id "
					+ "where ccce.cecc_id = :idComandoEmpresaCobrancaConta "
					+ "group by ccce.ccce_id, ccce.ccce_amreferenciacontainicial, ccce.ccce_amreferenciacontafinal, ccce.ccce_dtexecucao ";

			/*
			 * consulta = "select ccce.id, " // 0 +
			 * "ccce.referenciaContaInicial, "//1 +
			 * "ccce.referenciaContaFinal, " //2 + "ccce.dataExecucao, " //3 +
			 * "count(ecco.comandoEmpresaCobrancaConta.id), " //4 +
			 * "sum(ecco.valorOriginalConta) "//5 +
			 * "from EmpresaCobrancaConta ecco " +
			 * "left join ecco.comandoEmpresaCobrancaContaExtensao ccce " +
			 * "where ccce.id = :idComandoEmpresaCobrancaConta " +
			 * "group by ,,, ";
			 */

			retorno = session.createSQLQuery(consulta).addScalar("idExtensao", Hibernate.INTEGER)
					.addScalar("referenciaInicial", Hibernate.INTEGER).addScalar("referenciaFinal", Hibernate.INTEGER)
					.addScalar("dataExecucao", Hibernate.DATE)
					// .addScalar("valorOriginalConta",Hibernate.INTEGER)
					// .addScalar("somaContas",Hibernate.BIG_DECIMAL)
					.setInteger("idComandoEmpresaCobrancaConta", idComandoEmpresaCobrancaConta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer retornaAnoMesContaUltimaExtensao(Integer idComandoEmpresaCobrancaConta) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select max(ccce.ccce_amreferenciacontafinal) as anoMesFinal " + "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "where ccce.cecc_id = :idComandoEmpresaCobrancaConta";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("anoMesFinal", Hibernate.INTEGER)
					.setInteger("idComandoEmpresaCobrancaConta", idComandoEmpresaCobrancaConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0878] Gerar Relação de Parcelamento - Visão Analitica
	 * 
	 * @author Bruno Barros
	 * 
	 * @date 04/02/2009
	 */
	public Collection<Object[]> filtrarRelacaoParcelamentoAnalitico(FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento,
			Integer anoMesReferenciaFaturamento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		SQLQuery query = null;
		String consulta = null;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados().isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( loca.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id, \n  muni.muni_nmmunicipio ";
			orderBy += " muni.muni_nmmunicipio, ";
		}

		try {

			consulta = "select \n"
					+ "  distinct \n"
					+
					// 0
					"  parc.parc_id, \n"
					+
					// 1
					"  loca.loca_id, \n"
					+
					// 2
					"  loca.loca_nmlocalidade, \n"
					+
					// 3
					"  geRe.greg_id, \n"
					+
					// 4
					"  geRe.greg_nmregional, \n"
					+
					// 5
					"  clie.clie_nmcliente, \n"
					+
					// 6
					"  parc.imov_id, \n"
					+
					// 7
					"  coalesce( clieFone.cfon_cdddd || ' ' || clieFone.cfon_nnfone, '-' ) as telefone, \n"
					+
					// 8
					"  cast( to_char( cnta.cnta_dtvencimentoconta, 'dd' ) as integer ) as diaVencimento, \n"
					+
					// 9
					"  parc.parc_nnprestacoes * parc.parc_vlprestacao as debitoParcelado, \n"
					+
					// 10
					"  parc.parc_vlprestacao as valorParcela, \n"
					+
					// 11
					"  parc.parc_vlentrada as entrada, \n"
					+
					// 12
					"  parc.parc_tmparcelamento as dataParcelamento, \n"
					+
					// 13
					"  parc.parc_nnprestacoes as qtdParcelas, \n"
					+
					// 14
					"  case when deAC.dbac_id is not null then \n" + "    coalesce( deAC.dbac_nnprestacaocobradas, 0 ) \n"
					+ "  else \n"
					+ "    coalesce( deACH.dahi_nnprestacaocobradas, 0 ) \n"
					+ "  end as prestacoesCobradas, \n"
					+
					// 15
					"  case when deAC.dbac_id is not null then \n"
					+ "    coalesce( deAC.dbac_nnprestacaodebito - deAC.dbac_nnprestacaocobradas, 0 ) \n" + "  else \n"
					+ "    coalesce( deACH.dahi_nnprestacaodebito - deACH.dahi_nnprestacaocobradas, 0 ) \n" + "  end as qtdNaoCobradas, \n"
					+
					// 16
					"  unNe.uneg_nmabreviado as nomeUnidade, \n" +
					// 17
					"  usur.usur_nmlogin as login, \n" +
					// 18
					"  deAC.dbac_id as idDebitoACobrar, \n" +
					// 19
					"  deACH.dbac_id as idDebitoACobrarHistorico \n"
					+

					selectMunicipio
					+ "from \n"
					+ "    cobranca.parcelamento parc \n"
					+ "    inner join cadastro.localidade loca on ( loca.loca_id = parc.loca_id ) \n"
					+ joinMunicipio
					+ "    inner join cadastro.gerencia_regional geRe on ( geRe.greg_id = loca.greg_id ) \n"
					+ "    inner join cadastro.unidade_negocio unNe on ( loca.uneg_id = unNe.uneg_id ) \n"
					+ "    inner join cadastro.cliente clie on ( clie.clie_id = parc.clie_id ) \n"
					+ "    left join seguranca.usuario usur ON usur.usur_id = parc.usur_id \n"
					+ "    left join cadastro.unidade_organizacional unid ON usur.unid_id = unid.unid_id \n"
					+ "    inner join cadastro.imovel imo on ( imo.imov_id = parc.imov_id ) \n"
					+ "    inner join cadastro.quadra qua on ( qua.qdra_id = imo.qdra_id ) \n"
					+ "	 left join cadastro.cliente_fone clieFone on ( clieFone.clie_id = clie.clie_id and \n"
					+ "	 clieFone.cfon_icfonepadrao = 1 ) \n"
					+ "	 left join faturamento.conta cnta on ( cnta.imov_id = parc.imov_id and cnta. \n"
					+ "	 cnta_amreferenciaconta = :anoMesReferenciaFaturamento and dcst_idatual <> 4) \n"
					+ "	 left join faturamento.debito_a_cobrar deAC on ( deAC.parc_id = parc.parc_id \n"
					+ "	 and deAC.dcst_idatual in (1,0) and deAC.dbtp_id in ( 40, 41,42, 43, 45, 47,50 ) \n"
					+ "	 and \n"
					+ "	 deAC.dbac_id = (select min(auxiliar.dbac_id) from faturamento.debito_a_cobrar auxiliar \n"
					+ "	 where auxiliar.parc_id = parc.parc_id \n"
					+ "	 and auxiliar.dcst_idatual in (1,0) and auxiliar.dbtp_id in ( 40, 41,42, 43, 45, 47,50 ))) \n"
					+ "	 left join faturamento.deb_a_cobrar_hist deACH on ( deACH.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) and deACH.parc_id = parc.parc_id \n"
					+ "	 and \n"
					+ "	 deACH.dbac_id = (select min(auxiliarHistorico.dbac_id) from faturamento.deb_a_cobrar_hist auxiliarHistorico \n"
					+ "	 where auxiliarHistorico.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) and auxiliarHistorico.parc_id = parc.parc_id)) \n"
					+ "where \n"
					+ "  parc.pcst_id = 1 and \n"
					+ "  not exists ( select 'a' from cobranca.parcelamento_item parcItem where parcItem.dbac_id = deAC.dbac_id ) and \n"
					+ "  not exists ( select 'a' from cobranca.parcelamento_item parcItem where parcItem.dbac_id = deACH.dbac_id ) \n";

			// Verificamos quais os filtros informados
			if (filtrarRelacaoParcelamento.getIdGerencia() != null && !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				consulta += " and geRe.greg_id = :idGerenciaRegional \n";
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null && !filtrarRelacaoParcelamento.getIdUnidadeNegocio().equals("")) {
				consulta += " and unNe.uneg_id = :idUnidadeNegocio \n";
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null && !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				consulta += " and loca.loca_cdelo = :idElo \n";
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and parc.loca_id = :idLocalidade ";
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and loca.muni_idprincipal IN ( :idMunicipios )";
				if (!temLocalidade) {
					consulta += " and parc.loca_id = loca.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getCodigoSetorComercial() != null) {
				consulta += " and parc.parc_cdsetorcomercial = :cdSetorComercial \n";
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and qua.qdra_nnquadra = :numeroQuadra \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel().equals("")) {
				consulta += " and parc.usur_id = :idUsuario \n";
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				consulta += " and parc.parc_tmparcelamento between :dataInicial and :dataFinal \n";
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel().isEmpty()) {
				consulta += " and imo.iper_id in (:idsPerfisImovel) \n";

			}

			// Coleção Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional().equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional \n";

			}

			consulta += orderBy + "  loca_id, \n" + "  greg_id, \n" + "  clie_nmcliente \n";

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados())) {
				query = session.createSQLQuery(consulta).addScalar("parc_id", Hibernate.INTEGER).addScalar("loca_id", Hibernate.INTEGER)
						.addScalar("loca_nmlocalidade", Hibernate.STRING).addScalar("greg_id", Hibernate.INTEGER)
						.addScalar("greg_nmregional", Hibernate.STRING).addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER).addScalar("telefone", Hibernate.STRING)
						.addScalar("diaVencimento", Hibernate.INTEGER).addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL).addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE).addScalar("qtdParcelas", Hibernate.INTEGER)
						.addScalar("prestacoesCobradas", Hibernate.INTEGER).addScalar("qtdNaoCobradas", Hibernate.INTEGER)
						.addScalar("nomeUnidade", Hibernate.STRING).addScalar("login", Hibernate.STRING)
						.addScalar("muni_id", Hibernate.INTEGER).addScalar("muni_nmmunicipio", Hibernate.STRING)
						.addScalar("idDebitoACobrar", Hibernate.INTEGER).addScalar("idDebitoACobrarHistorico", Hibernate.INTEGER);
			} else {
				query = session.createSQLQuery(consulta).addScalar("parc_id", Hibernate.INTEGER).addScalar("loca_id", Hibernate.INTEGER)
						.addScalar("loca_nmlocalidade", Hibernate.STRING).addScalar("greg_id", Hibernate.INTEGER)
						.addScalar("greg_nmregional", Hibernate.STRING).addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER).addScalar("telefone", Hibernate.STRING)
						.addScalar("diaVencimento", Hibernate.INTEGER).addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL).addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE).addScalar("qtdParcelas", Hibernate.INTEGER)
						.addScalar("prestacoesCobradas", Hibernate.INTEGER).addScalar("qtdNaoCobradas", Hibernate.INTEGER)
						.addScalar("nomeUnidade", Hibernate.STRING).addScalar("login", Hibernate.STRING)
						.addScalar("idDebitoACobrar", Hibernate.INTEGER).addScalar("idDebitoACobrarHistorico", Hibernate.INTEGER);
			}

			query.setInteger("anoMesReferenciaFaturamento", anoMesReferenciaFaturamento);

			// Adicionamos os parametros necessários
			if (filtrarRelacaoParcelamento.getIdGerencia() != null && !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				query.setInteger("idGerenciaRegional", filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null && !filtrarRelacaoParcelamento.getIdUnidadeNegocio().equals("")) {
				query.setInteger("idUnidadeNegocio", filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null && !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null && !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				query.setInteger("idLocalidade", filtrarRelacaoParcelamento.getParcelamento().getLocalidade().getId());
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados().isEmpty()) {
				query.setParameterList("idMunicipios", filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getCodigoSetorComercial() != null) {
				query.setInteger("cdSetorComercial", filtrarRelacaoParcelamento.getParcelamento().getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				query.setInteger("numeroQuadra", filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra());
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				query.setTimestamp("dataInicial", filtrarRelacaoParcelamento.getDataParcelamentoInicial());
				query.setTimestamp("dataFinal", filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel().isEmpty()) {

				query.setParameterList("idsPerfisImovel", filtrarRelacaoParcelamento.getColecaoPerfilImovel());
			}

			// coleção Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional().equals("")) {

				query.setInteger("idUnidadeOrganizacional", filtrarRelacaoParcelamento.getIdUnidadeOrganizacional());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel().equals("")) {

				query.setInteger("idUsuario", filtrarRelacaoParcelamento.getIdUsuarioResponsavel());
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [FS0028] Verifica se
	 * existeParcelas em atraso [FS0029] Verificar se existe parcelamento em
	 * andamento
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterParcelamentoMaisAtualDoImovel(Integer idImovel) throws ErroRepositorioException {

		Object[] retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parc.id, "// 0
					+ "rdir.id, "// 1
					+ "rdir.numeroResolucaoDiretoria "// 2
					+ "FROM Parcelamento parc " + "INNER JOIN parc.imovel imov "
					+ "INNER JOIN parc.parcelamentoSituacao parcSit "
					+ "LEFT JOIN parc.resolucaoDiretoria rdir "
					+ "WHERE imov.id = :idImovel AND parcSit.id = :parcNormal "
					+ "ORDER BY parc.parcelamento desc ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel)
					.setInteger("parcNormal", ParcelamentoSituacao.NORMAL).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [FS0028] Verifica se
	 * existeParcelas em atraso [FS0029] Verificar se existe parcelamento em
	 * andamento
	 * 
	 * verificar se existe parcelas a serem cobradas (selecionar na tabela de
	 * debito a cobrar (FATURAMENTO.DEBITO_A_COBRAR), a linha que tenha o
	 * PARC_ID = PARC_ID da tabela COBRANCA.PARCELAMENTO e o tipo de débito
	 * (DBTP_ID) = 40) e caso o número de prestações do débito não seja igual ao
	 * número de prestações cobradas
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection obterDebitoACobrarDoParcelamento(Integer idParcelamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac.id " + " from DebitoACobrar dac " + " inner join dac.debitoTipo debitoTipo "
					+ " inner join dac.parcelamento parcelamento " + " where parcelamento.id = :idParcelamento "
					+ " and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ " and debitoTipo.id = :debitoTipo ";

			retorno = session.createQuery(consulta).setInteger("debitoTipo", DebitoTipo.PARCELAMENTO_CONTAS)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [FS0028] Verifica se
	 * existeParcelas em atraso
	 * 
	 * verificar se existe parcelas em atraso, ou seja, verificar nas contas que
	 * irão fazer parte do parcelamento, se existe algum débito de parcelamento
	 * da RDIR_ID = RDIR_IDPARCELASEMATRASO
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasComParcelasEmAtrasoDoParcelamento(Integer idImovel, Integer refInicialInformada, Integer refFinalInformada)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// consulta =
			// "select c.cnta_id as idConta from faturamento.conta c "
			// +
			// " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada  "
			// +
			// " and exists (select dbcb_id from faturamento.debito_cobrado d "
			// + " 	        where d.cnta_id = c.cnta_id "
			// + " 		    and dbtp_id = :idDebitoTipo "
			// + " 		    and d.dbac_id in (select dbac_id "
			// + "								  from faturamento.debito_a_cobrar_historico h "
			// + "								  where h.parc_id = :idParcelamento) "
			// + " 		    ) ";

			// consulta =
			// " select c.cnta_id as idConta from faturamento.conta c "
			// +
			// " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada "
			// + " and current_timestamp > cnta_dtvencimentoconta "
			// +
			// " and cnta_id in(select cnta_id from faturamento.debito_cobrado d "
			// +
			// "                where dbtp_id = :idDebitoTipo and d.dbac_id in (select dbac_id  "
			// +
			// "                                                     from faturamento.debito_a_cobrar_historico h "
			// +
			// "                                                     where h.parc_id = :idParcelamento) )"
			// ;

			consulta = " select c.cnta_id as idConta from faturamento.conta c "
					+ " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada "
					+ " and current_timestamp > cnta_dtvencimentoconta " + " and imov_id = :idImovel "
					+ " and cnta_id in(select cnta_id from faturamento.debito_cobrado d "
					+ "                where dbtp_id = :idDebitoTipo )";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
					.setInteger("refInicialInformada", refInicialInformada).setInteger("refFinalInformada", refFinalInformada)
					.setInteger("idDebitoTipo", DebitoTipo.PARCELAMENTO_CONTAS).setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0880] Gerar Movimento de Extensão de Contas em Cobrança por Empresa
	 * 
	 * Pesquisa as contas associadas ao imóvel
	 * 
	 * @author: Rômulo Aurélio
	 * @throws SQLException
	 * @date: 13/02/2009
	 */
	public void inserirMovimentoExtensaoContasEmCobranca(Integer idLocalidade, Integer idPerfil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		// Collection<Object[]> retorno = null;
		String consulta = null;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();
			String sequence = Util.obterNextValSequence("cobranca.seq_empresa_cobranca_conta");
			String dataAtualBanco = Util.obterSQLDataAtual();
			consulta = "INSERT into cobranca.empresa_cobranca_conta ( ecco_id," + "empr_id, " + "cnta_id, " + "ecco_vloriginalconta, "
					+ "ecco_pcempresaconta, " + "ecco_tmultimaalteracao, " + "cecc_id, " + "ecco_icpagamentovalido, " + "ccce_id, "
					+ "imov_id) " + "select "
					+ sequence
					+ ", "
					+ "aux.idEmpresa as idEmpresa, " // 1
					+ "cnta.cnta_id as idConta, " // 2
					+ "( coalesce( cnta.cnta_vlagua, 0 ) + "
					+ "coalesce( cnta.cnta_vlesgoto, 0 ) + "
					+ "coalesce( cnta.cnta_vldebitos, 0 ) - "
					+ "coalesce( cnta.cnta_vlcreditos, 0 ) - "
					+ "coalesce( cnta.cnta_vlimpostos, 0 ) "
					+ ") as valorConta, " // 3
					+ "aux.pcEmpresaConta as pcEmpresaConta, " // 4
					+ dataAtualBanco
					+ " as ultimaAlteracao, " // 5
					+ "aux.idComando as idComando, " // 6
					+ "1 as indicadorPagamentoValido, " // 7
					+ "aux.idExtensao as idExtensao, " // 8
					+ "aux.idImovel as idImovel " // 9
					+ "from faturamento.conta cnta "
					+ "inner join (select DISTINCT ecco.imov_id as idImovel, "
					+ "ecco.empr_id as idEmpresa, "
					+ "ecco.ecco_pcempresaconta as pcEmpresaConta, "
					+ "ecco.cecc_id as idComando, "
					+ "ccce.ccce_id as idExtensao, "
					+ "ccce.ccce_amreferenciacontainicial as referencialInicialExtensao, "
					+ "ccce.ccce_amreferenciacontafinal as referencialFinalExtensao "
					+ "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "inner join cobranca.empresa_cobranca_conta ecco on ecco.cecc_id = ccce.cecc_id "
					+ "inner join cadastro.imovel imov on imov.imov_id = ecco.imov_id "
					+ "where imov.loca_id =  "
					+ idLocalidade
					+ " "
					+ "and ccce.ccce_dtexecucao is null ";

			if (idPerfil != null) {
				consulta = consulta + " and imov.iper_id <> " + idPerfil;
			}
			consulta = consulta + " ) aux " + "on aux.idimovel = cnta.imov_id "
					+ "where  cnta.cnta_amreferenciaconta between aux.referencialInicialExtensao and aux.referencialFinalExtensao "
					+ "and cnta.dcst_idatual in (0,1,2) "
					+ "and NOT EXISTS (select pgmt.cnta_id from arrecadacao.pagamento pgmt where pgmt.cnta_id = cnta.cnta_id) "
					+ "and NOT EXISTS (select ecco.cnta_id from cobranca.empresa_cobranca_conta ecco where ecco.cnta_id = cnta.cnta_id) ";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0891] Gerar Relatorio de Imóveis com Acordo
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioImoveisComAcordo(Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal, Integer idGerenciaRegional, Date dataInicialAcordo, Date dataFinalAcordo, Integer rotaInicial,
			Integer rotaFinal, Integer sequencialRotaInicial, Integer sequencialRotaFinal, Integer idSetorComercialInicial,
			Integer idSetorComercialFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select distinct imov.imov_id as idImovel, " // 0
					+ "rota.rota_cdrota as codigoRota, "// 1
					+ "imov.imov_nnsequencialrota as sequencialRota, " // 2
					+ "last.last_dsligacaoaguasituacao as situacaoLigacaoAgua, "// 3
					+ "lest.lest_dsligacaoesgotosituacao as situacaoLigacaoEsgoto, "// 4
					+ "cbsp.cbsp_dscobrancasituacaotipo as tipoSituacaoCobranca, " // 5
					+ "cbsh.cbsh_amcobrancasituacaoinicio as anoMesInicial, "// 6
					+ "cbsh.cbsh_amcobrancasituacaofim as anoMesFinal, " // 7
					+ "cbsh.cbsh_dtfimsituacao as dataFinalSituacao, "// 8
					+ "cbsh.cbsh_dsobservacaoinforma as observacao, "// 9
					+ "usur.usur_nmusuario as nomeUsuario "// 10
					+ "from cobranca.cobranca_situacao_hist cbsh "
					+ "left join cadastro.imovel imov on imov.imov_id = cbsh.imov_id "
					+ "left join cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ "left join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id  "
					+ "left join cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id  "
					+ "left join atendimentopublico.ligacao_agua_situacao last on last.last_id = imov.last_id "
					+ "left join atendimentopublico.ligacao_esgoto_situacao lest on lest.lest_id = imov.lest_id "
					+ "left join micromedicao.rota rota on rota.rota_id = qdra.rota_id  "
					+ "left join cobranca.cobranca_situacao_tipo cbsp on cbsp.cbsp_id = cbsh.cbsp_id "
					+ "left join seguranca.usuario usur on usur.usur_id = cbsh.usur_id  "
					+ "where cbsh.cbsh_amcobrancaretirada is null "
					+ "and cbsh.cbsh_dtfimsituacao between ('" + Util.getSQLDate(dataInicialAcordo).toString()
					+ "') and ('"
					+ Util.getSQLDate(dataFinalAcordo).toString() + "') ";

			if (idUnidadeNegocio != null) {
				consulta = consulta + "and loca.uneg_id = " + idUnidadeNegocio + " ";
			}

			if (idGerenciaRegional != null) {
				consulta = consulta + "and greg.greg_id = " + idGerenciaRegional + " ";
			}

			if (idLocalidadeInicial != null && idLocalidadeFinal != null) {

				consulta = consulta + "and loca.loca_id between (' " + idLocalidadeInicial + "')" + " and ('" + idLocalidadeFinal + "') ";

				if (idSetorComercialInicial != null && idSetorComercialFinal != null) {
					consulta = consulta + "and stcm.stcm_cdsetorcomercial  between (' " + idSetorComercialInicial + "')" + " and ('"
							+ idSetorComercialFinal + "') ";
				}
				if (rotaInicial != null && rotaFinal != null) {
					consulta = consulta + "and rota.rota_id between (' " + rotaInicial + "')" + " and ('" + rotaFinal + "') ";
				}
				if (sequencialRotaInicial != null && sequencialRotaFinal != null) {
					consulta = consulta + "and imov.imov_nnsequencialrota between (' " + sequencialRotaInicial + "')" + " and ('"
							+ sequencialRotaFinal + "') ";
				}

			}

			consulta = consulta
					+ " "
					+ "group by imov.imov_id,rota.rota_cdrota,imov.imov_nnsequencialrota,last.last_dsligacaoaguasituacao,lest.lest_dsligacaoesgotosituacao,cbsp.cbsp_dscobrancasituacaotipo,cbsh.cbsh_amcobrancasituacaoinicio,cbsh.cbsh_amcobrancasituacaofim,cbsh.cbsh_dtfimsituacao,cbsh.cbsh_dsobservacaoinforma,usur.usur_nmusuario ";

			retorno = session.createSQLQuery(consulta).addScalar("idImovel", Hibernate.INTEGER).addScalar("codigoRota", Hibernate.INTEGER)
					.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("situacaoLigacaoAgua", Hibernate.STRING)
					.addScalar("situacaoLigacaoAgua", Hibernate.STRING).addScalar("tipoSituacaoCobranca", Hibernate.STRING)
					.addScalar("anoMesInicial", Hibernate.INTEGER).addScalar("anoMesFinal", Hibernate.INTEGER)
					.addScalar("dataFinalSituacao", Hibernate.DATE).addScalar("observacao", Hibernate.STRING)
					.addScalar("nomeUsuario", Hibernate.STRING).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer pesquisarDadosGerarRelatorioImoveisComAcordoCount(Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal, Integer idGerenciaRegional, Date dataInicialAcordo, Date dataFinalAcordo, Integer rotaInicial,
			Integer rotaFinal, Integer sequencialRotaInicial, Integer sequencialRotaFinal, Integer idSetorComercialInicial,
			Integer idSetorComercialFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(distinct imov.imov_id) as qtde " + "from cobranca.cobranca_situacao_hist cbsh "
					+ "left join cadastro.imovel imov on imov.imov_id = cbsh.imov_id "
					+ "left join cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ "left join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id  "
					+ "left join cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id  "
					+ "left join atendimentopublico.ligacao_agua_situacao last on last.last_id = imov.last_id "
					+ "left join atendimentopublico.ligacao_esgoto_situacao lest on lest.lest_id = imov.lest_id "
					+ "left join micromedicao.rota rota on rota.rota_id = qdra.rota_id  "
					+ "left join cobranca.cobranca_situacao_tipo cbsp on cbsp.cbsp_id = cbsh.cbsp_id "
					+ "left join seguranca.usuario usur on usur.usur_id = cbsh.usur_id  " + "where cbsh.cbsh_amcobrancaretirada is null "
					+ "and cbsh.cbsh_dtfimsituacao between (' " + Util.getSQLDate(dataInicialAcordo).toString() + "') and ('"
					+ Util.getSQLDate(dataFinalAcordo).toString() + "') ";

			if (idUnidadeNegocio != null) {
				consulta = consulta + "and loca.uneg_id = " + idUnidadeNegocio + " ";
			}

			if (idGerenciaRegional != null) {
				consulta = consulta + "and greg.greg_id = " + idGerenciaRegional + " ";
			}

			if (idLocalidadeInicial != null && idLocalidadeFinal != null) {
				consulta = consulta + "and loca.loca_id between (' " + idLocalidadeInicial + "')" + " and ('" + idLocalidadeFinal + "') ";

				if (idSetorComercialInicial != null && idSetorComercialFinal != null) {
					consulta = consulta + "and stcm.stcm_cdsetorcomercial between (' " + idSetorComercialInicial + "')" + " and ('"
							+ idSetorComercialFinal + "') ";
				}
				if (rotaInicial != null && rotaFinal != null) {
					consulta = consulta + "and rota.rota_id between (' " + rotaInicial + "')" + " and ('" + rotaFinal + "') ";
				}
				if (sequencialRotaInicial != null && sequencialRotaFinal != null) {
					consulta = consulta + "and imov.imov_nnsequencialrota between (' " + sequencialRotaInicial + "')" + " and ('"
							+ sequencialRotaFinal + "') ";
				}

			}

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("qtde", Hibernate.INTEGER).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public CicloMetaGrupo pesquisarCicloMetaGrupoPorGrupoLocalidade(int idCicloMeta, int idGrupo, int idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		CicloMetaGrupo retorno = null;
		String consulta = null;

		try {

			consulta = "select cmg " + "from gcom.cobranca.CicloMetaGrupo cmg " + "where cmg.cobrancaGrupo.id = :idCobGrupo "
					+ "and cmg.cicloMeta.id = :idCicloMeta " + "and cmg.localidade.id = :idLocalidade ";

			retorno = (CicloMetaGrupo) session.createQuery(consulta).setInteger("idCobGrupo", idGrupo)
					.setInteger("idCicloMeta", idCicloMeta).setInteger("idLocalidade", idLocalidade).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public CicloMeta pesquisarMetaCiclo(int anoMes, int idCobrancaAcao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		CicloMeta retorno = null;
		String consulta = null;

		try {

			consulta = "select cm " + "from gcom.cobranca.CicloMeta cm " + "where cm.cobrancaAcao.id = :idCobAcao "
					+ "and cm.anoMesReferencia = :anoMes ";

			retorno = (CicloMeta) session.createQuery(consulta).setInteger("idCobAcao", idCobrancaAcao).setInteger("anoMes", anoMes)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarQuantidadeDocumentosGeradosAcimaValorLimite(Integer idCAAC, Integer idCACM, Integer idLocalidade,
			BigDecimal valorLimite) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(cd.id) " + "from gcom.cobranca.CobrancaDocumento cd where ";
			if (idCAAC != null) {
				consulta += " cd.cobrancaAcaoAtividadeCronograma.id = " + idCAAC;
			} else if (idCACM != null) {
				consulta += " cd.cobrancaAcaoAtividadeComando.id = " + idCACM;
			}
			if (idLocalidade != null) {
				consulta += " and cd.localidade.id = " + idLocalidade;
			}

			consulta += " and cd.valorDocumento >= :valorLimite ";

			retorno = (Integer) session.createQuery(consulta).setBigDecimal("valorLimite", valorLimite).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarQuantidadeDocumentosGerados(Integer idCAAC, Integer idCACM, Integer idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(cd.id) " + "from gcom.cobranca.CobrancaDocumento cd where ";
			if (idCAAC != null) {
				consulta += " cd.cobrancaAcaoAtividadeCronograma.id = " + idCAAC;
			} else if (idCACM != null) {
				consulta += " cd.cobrancaAcaoAtividadeComando.id = " + idCACM;
			}
			if (idLocalidade != null) {
				consulta += " and cd.localidade.id = " + idLocalidade;
			}

			retorno = (Integer) session.createQuery(consulta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarDocumentosCobrancaExcedentes(Integer idCAAC, Integer idCACM, int quantidadeParaRemover, Integer idLocalidade)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String queryConsulta = null;
		Collection documentos = null;

		try {

			queryConsulta = "select cbdo_id as id, cbdo_vldocumento as valor from cobranca.Cobranca_Documento cd where ";
			if (idCAAC != null) {
				queryConsulta += " cd.caac_id = " + idCAAC;
			} else if (idCACM != null) {
				queryConsulta += " cd.cacm_id = " + idCACM;
			}
			if (idLocalidade != null) {
				queryConsulta += " and cd.loca_id = " + idLocalidade;
			}
			queryConsulta += " order by cd.cbdo_vldocumento limit " + quantidadeParaRemover;

			documentos = session.createSQLQuery(queryConsulta).addScalar("id", Hibernate.INTEGER).addScalar("valor", Hibernate.BIG_DECIMAL)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return documentos;
	}

	public void adicionarMetaCicloLocalidade(int idMetaCiclo, int idGrupo, int idLocalidade, int quantidadeASerAdicionada)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String query = null;

		try {

			query = "update gcom.cobranca.CicloMetaGrupo set clmg_qtmetaajustada = (clmg_qtmetaajustada + " + quantidadeASerAdicionada
					+ "), clmg_ultimaalteracao = :data where " + " clmt_id = " + idMetaCiclo + " and loca_id = " + idLocalidade
					+ " and cbgr_id = " + "(SELECT min(cm.cobrancaGrupo.id) FROM gcom.cobranca.CicloMetaGrupo cm where "
					+ " cm.cicloMeta.id = " + idMetaCiclo + " and cm.localidade.id = " + idLocalidade + " and cm.cobrancaGrupo.id > "
					+ idGrupo + " and cm.quantidadeDocumentosRestantes is null)";

			session.createQuery(query).setTimestamp("data", new Date()).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public Collection<CicloMetaGrupo> pesquisarCicloMetaGrupoPorCicloMeta(Integer idCicloMeta, Integer idGrupo)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String queryConsulta = null;
		List<CicloMetaGrupo> idsMetas = null;

		try {

			queryConsulta = "select cmg from gcom.cobranca.CicloMetaGrupo cmg where " + " cmg.cicloMeta.id = " + idCicloMeta
					+ " and cmg.cobrancaGrupo.id = " + idGrupo + " order by cmg.localidade.id ";

			idsMetas = (List) session.createQuery(queryConsulta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return idsMetas;
	}

	/**
	 * 
	 * [UC0000] - Gerar Metas do Cilo Pesquisar a quantidade de imoveis em cada
	 * grupo/localidade
	 * 
	 * @author Francisco do Nascimento
	 * @date 23/04/2009
	 * 
	 * @param idsLast
	 *            Colecao de ids de situacao de ligação de água
	 * @return Colecao no formato [idGrupo, idLocalidade, qtdImoveis]
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarQuantidadeImoveisPorGrupoLocalidade(Collection idsLast) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Collection colecao = null;

		try {
			query = "SELECT r.cbgr_id as idGrupo, l.loca_id as idLocalidade, " + "count(imov_id) as QtdImoveis FROM micromedicao.rota r "
					+ "join cadastro.quadra q on r.rota_id = q.rota_id " + "join cadastro.setor_comercial sc on sc.stcm_id = q.stcm_id "
					+ "join cadastro.localidade l on sc.loca_id = l.loca_id " + "join cadastro.imovel i on i.qdra_id = q.qdra_id "
					+ "where i.last_id in (:idsLast) " + "group by r.cbgr_id, l.loca_id " + "order by r.cbgr_id, l.loca_id ";

			colecao = (List) session.createSQLQuery(query).addScalar("idGrupo", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("QtdImoveis", Hibernate.INTEGER)
					.setParameterList("idsLast", idsLast).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return colecao;

	}

	/**
	 * [UC0216] Calcular Acrescimo por Impontualidade
	 * 
	 * Caso o imóvel tenha débito automático e o recebimento, mesmo em atraso,
	 * tenha sido através de débito automático, o sistema não calcula os
	 * acréscimos de impontualidade
	 * 
	 * (ARMV_DSIDENTIFICACAOSERVICO da tabela ARRECADADOR_MOVIMENTO com valor
	 * igual a "DEBITO AUTOMATICO" com ARMV_ID = ARMV_ID da tabela
	 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_ID = AMIT_ID da tabela PAGAMENTO com
	 * CNTA_ID = CNTA_ID recebido)
	 * 
	 * @author Raphael Rossiter
	 * @date 12/05/2009
	 * 
	 * @param idConta
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoDeContaPorDebitoAutomatico(Integer idConta) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT COUNT(*) FROM Pagamento as pgmt " + "INNER JOIN pgmt.contaGeral as cntaGeral "
					+ "INNER JOIN cntaGeral.conta as cnta " + "INNER JOIN pgmt.arrecadadorMovimentoItem as amit "
					+ "INNER JOIN amit.arrecadadorMovimento as armv "
					+ "WHERE cnta.id = :idConta AND armv.descricaoIdentificacaoServico = :debitoAutomatico ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idConta", idConta)
					.setString("debitoAutomatico", ConstantesSistema.DEBITO_AUTOMATICO).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos Author: Vivianne Sousa Data:
	 * 13/05/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarParcelamento(Integer idParcelamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join dac.parcelamento parcelamento "
					+ "inner join dac.debitoTipo debitoTipo "
					+ "where parcelamento.id = :idParcelamento "
					+ "and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id) "
					+ "and debitoTipo.id in (:jurosSobreParc, :parcContas, :parcAcrescimos) ";

			retorno = session.createQuery(consulta).setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("jurosSobreParc", DebitoTipo.JUROS_SOBRE_PARCELAMENTO)
					.setInteger("parcContas", DebitoTipo.PARCELAMENTO_CONTAS)
					.setInteger("parcAcrescimos", DebitoTipo.PARCELAMENTO_ACRESCIMOS_IMPONTUALIDADE)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos Author: Vivianne Sousa Data:
	 * 13/05/2009
	 * 
	 * @param idImovel
	 * @param referencia
	 * 
	 * @return idParcelamento
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdParcelamentoNormal(Integer idImovel, Integer referencia) throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select max(p.parc_id) as idParcelamento " + " from cobranca.parcelamento p " + " where imov_id = :idImovel "
					+ " and p.pcst_id = :normal " + " and p.parc_id in(select pi.parc_id " + " from cobranca.parcelamento_item pi "
					+ " inner join faturamento.conta_historico cnta on pi.cnta_id = cnta.cnta_id " + " where "
					+ " cnta.cnhi_amreferenciaconta <= :referencia and " + " p.parc_id = pi.parc_id )";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("idParcelamento", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).setInteger("normal", ParcelamentoSituacao.NORMAL)
					.setInteger("referencia", referencia).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos Author: Vivianne Sousa Data:
	 * 18/05/2009
	 */
	public BigDecimal pesquisarValorDebitoCobradoParcelamentoConta(Integer idConta) throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT sum(dbcb.valorPrestacao) " + "FROM DebitoCobrado as dbcb " + "INNER JOIN dbcb.financiamentoTipo as fntp "
					+ "WHERE dbcb.conta.id = :idConta " + "and (fntp.id = :parcAgua or "
					+ "fntp.id = :parcEsgoto or fntp.id = :parcServico or " + "fntp.id = :jurosParc)";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idConta", idConta)
					.setInteger("parcAgua", FinanciamentoTipo.PARCELAMENTO_AGUA.intValue())
					.setInteger("parcEsgoto", FinanciamentoTipo.PARCELAMENTO_ESGOTO.intValue())
					.setInteger("parcServico", FinanciamentoTipo.PARCELAMENTO_SERVICO.intValue())
					.setInteger("jurosParc", FinanciamentoTipo.JUROS_PARCELAMENTO.intValue()).setMaxResults(1).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0878] Gerar Relação de Parcelamento - Visão Analitica
	 * 
	 * @author Bruno Barros
	 * 
	 * @date 05/06/2009
	 */
	public Integer pesquisarQuantidadeContasNaoPagasParcelamento(Integer idParcelamento, Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select \n"
					+ "  count( distinct cnta.cnta_id ) as quantidade \n"
					+ "from \n"
					+ "  cobranca.parcelamento as parc \n"
					+ "  inner join faturamento.conta as cnta on ( cnta.imov_id = parc.imov_id and cnta.cnta_amreferenciaconta > parc.parc_amreferenciafaturamento ) \n"
					+ "  inner join faturamento.debito_cobrado as deCo on ( deCo.cnta_id = cnta.cnta_id ) \n" + "where \n"
					+ "  deCo.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) and \n" + "  deCo.dbac_id = :idDebitoACobrar and \n" +

					"  not exists ( select 'a' from arrecadacao.pagamento pgto where pgto.cnta_id = cnta.cnta_id ) and \n"
					+ "  parc.parc_id = :idParcelamento \n";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idParcelamento", idParcelamento).setInteger("idDebitoACobrar", idDebitoACobrar).setMaxResults(1)
					.uniqueResult();

			if (retorno == null) {
				retorno = 0;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * retorna id da ResolucaoDiretoria
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 08/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarResolucaoDiretoriaComPercentualDoacao() throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd.id " + "from ResolucaoDiretoria as rd "
					+ "where rd.percentualDoacao is not null or rd.percentualDoacao > :zero ";

			retorno = (Integer) session.createQuery(consulta).setBigDecimal("zero", new BigDecimal("0.00")).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// //////////////////////////////////////////////////////////
	/**
	 * retorna coleção de ids de Rota de um Grupo de faturamento
	 * 
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 11/06/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarRotasPorGrupoFaturamento(Integer idGrupoFaturamento) throws ErroRepositorioException {

		Collection<Integer> rotas = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct(rota.id) " + "from Rota rota " + "inner join rota.faturamentoGrupo ftgr "
					+ "where ftgr.id = :idFaturamentoGrupo ";
			// + "and rota.id = 3367";//apagar

			rotas = session.createQuery(consulta).setInteger("idFaturamentoGrupo", idGrupoFaturamento).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return rotas;
	}

	/**
	 * retorna coleção de idImovel de uma Rota
	 * 
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 12/06/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosImoveisPorRota(Integer idRota) throws ErroRepositorioException {

		Collection dados = new ArrayList();
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select " + " imov.imov_id as idImovel, " + " imov.loca_id as idLocalidade, "
					+ " imov.last_id as idLigacaoAguaSituacao," + " imov.lest_id as idLigacaoEsgotoSituacao,"
					+ " imov.iper_id as idImovelPerfil," + " setor.stcm_id as idSetor," + " setor.stcm_cdsetorcomercial as codigoSetor,"
					+ " qdra.qdra_id as idQuadra," + " qdra_nnquadra as numeroQuadra, "
					+ " imov.imov_nnreparcmtconsec as numeroReparcelCons " + " from cadastro.imovel imov"
					+ " left join cadastro.setor_comercial setor on imov.stcm_id= setor.stcm_id"
					+ " left join cadastro.quadra qdra on imov.qdra_id= qdra.qdra_id"
					+ " left join micromedicao.rota rota on qdra.rota_id= rota.rota_id" + " where rota.rota_id =  :idRota "
					+ " and imov_icexclusao = 2"
					+ " and ((imov.last_id in (:emFiscalizacao, :cortado, :suprimido, :suprimidoParc, :suprimidoParcPedido))"
					+ " or (imov.lest_id= :ligado and imov.last_id in (:potencial , :factivel))) ";

			dados = session.createSQLQuery(consulta).addScalar("idImovel", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER).addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPerfil", Hibernate.INTEGER).addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER).addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("numeroReparcelCons", Hibernate.SHORT)
					.setInteger("idRota", idRota).setInteger("emFiscalizacao", LigacaoAguaSituacao.EM_FISCALIZACAO)
					.setInteger("cortado", LigacaoAguaSituacao.CORTADO).setInteger("suprimido", LigacaoAguaSituacao.SUPRIMIDO)
					.setInteger("suprimidoParc", LigacaoAguaSituacao.SUPR_PARC)
					.setInteger("suprimidoParcPedido", LigacaoAguaSituacao.SUPR_PARC_PEDIDO)
					.setInteger("potencial", LigacaoAguaSituacao.POTENCIAL).setInteger("factivel", LigacaoAguaSituacao.FACTIVEL)
					.setInteger("ligado", LigacaoEsgotoSituacao.LIGADO).list();

			if (dados != null && !dados.isEmpty()) {
				retorno = new ArrayList();

				Iterator iter = dados.iterator();

				while (iter.hasNext()) {
					Object[] dadosImovel = (Object[]) iter.next();
					Imovel imovel = new Imovel();
					Localidade loca = new Localidade();
					LigacaoAguaSituacao last = new LigacaoAguaSituacao();
					LigacaoEsgotoSituacao lest = new LigacaoEsgotoSituacao();
					ImovelPerfil iper = new ImovelPerfil();
					SetorComercial setor = new SetorComercial();
					Quadra quadra = new Quadra();

					imovel.setId((Integer) dadosImovel[0]);

					loca.setId((Integer) dadosImovel[1]);
					imovel.setLocalidade(loca);

					last.setId((Integer) dadosImovel[2]);
					imovel.setLigacaoAguaSituacao(last);

					lest.setId((Integer) dadosImovel[3]);
					imovel.setLigacaoEsgotoSituacao(lest);

					iper.setId((Integer) dadosImovel[4]);
					imovel.setImovelPerfil(iper);

					setor.setId((Integer) dadosImovel[5]);
					setor.setCodigo((Integer) dadosImovel[6]);
					imovel.setSetorComercial(setor);

					quadra.setId((Integer) dadosImovel[7]);
					quadra.setNumeroQuadra((Integer) dadosImovel[8]);
					imovel.setQuadra(quadra);

					if (dadosImovel[9] != null) {
						imovel.setNumeroReparcelamentoConsecutivos((Short) dadosImovel[9]);
					}

					retorno.add(imovel);
				}

			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 17/06/2009
	 */
	public void deletarCobrancaDocumentoECobrancaDocumentoItem(Integer idRota, Integer documentoTipo) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			Collection idsCobrancaDocumento = null;
			String consulta = " select distinct(cd.id) " + " from CobrancaDocumento cd " + " inner join cd.documentoTipo dt "
					+ " inner join cd.quadra qu " + " inner join qu.rota rota " + " where rota.id = :idRota "
					+ " and  dt.id = :documentoTipo "
					+ " and not exists (select id from Pagamento p where p.cobrancaDocumento.id = cd.id ) ";

			idsCobrancaDocumento = session.createQuery(consulta).setInteger("idRota", idRota).setInteger("documentoTipo", documentoTipo)
					.list();

			if (idsCobrancaDocumento != null && !idsCobrancaDocumento.isEmpty()) {

				// deleta os itens dos documentos de cobrança
				String delete = "delete CobrancaDocumentoItem cdi " + "where cdi.cobrancaDocumento.id in (:idsCobrancaDocumento) ";

				session.createQuery(delete).setParameterList("idsCobrancaDocumento", idsCobrancaDocumento).executeUpdate();

				// deleta os documentos de cobrança
				String delete2 = "delete CobrancaDocumento cd " + "where cd.id in (:idsCobrancaDocumento) ";

				session.createQuery(delete2).setParameterList("idsCobrancaDocumento", idsCobrancaDocumento).executeUpdate();

			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da criança para
	 * Negociação a Vista
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitir(Integer idRota, Integer idDocumentoTipo)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "LEFT JOIN fetch cbdo.empresa as empr "
					+ "LEFT JOIN cbdo.localidade as loca " + "LEFT JOIN fetch cbdo.imovel as imov " + "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot " + "LEFT JOIN cbdo.documentoTipo as docTipo " + "WHERE rot.id = :idRota AND "
					+ "cbdo.documentoTipo = :idDocumentoTipo ";

			retorno = session.createQuery(consulta).setInteger("idRota", idRota).setInteger("idDocumentoTipo", idDocumentoTipo).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os itens do documento de cobrança correspondentes a debito a
	 * cobrar
	 * 
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @data 17/06/2009
	 */
	public BigDecimal selecionarValorTotalCobrancaDocumentoItemReferenteDebito(CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT sum(cdit.valorItemCobrado) " + "FROM CobrancaDocumentoItem as cdit "
					+ "LEFT JOIN cdit.debitoACobrarGeral debitoGeral " + "LEFT JOIN debitoGeral.debitoACobrar  debito "
					+ "LEFT JOIN debito.debitoCreditoSituacaoAtual " + "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "debito.id IS NOT NULL ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCobrancaDocumento", cobrancaDocumento.getId())
					.uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna a Data de Vencimento da Rota (FACR_DTCONTAVENCIMENTO da tabela
	 * FATURAMENTO_ATIV_CRON_ROTA com ROTA_ID = ROTA_ID já pesquisado antes e
	 * FTAC_ID = FTAC_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA e FTAT_ID =
	 * 5 e FTCM_ID = FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com
	 * FTGR_ID = ao grupo informado e FTCM_AMREFERENCIA = anoMesFaturamento da
	 * tabela SISTEMA_PARAMETROS )
	 * 
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @data 22/06/2009
	 */
	public Date pesquisarDataVencimentoRota(Integer idRota, Integer anoMesFaturamento, Integer grupoFaturamento)
			throws ErroRepositorioException {

		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = " select facr.facr_dtcontavencimento as vencimento " + " from faturamento.fatur_ativ_cron_rota facr "
					+ " inner join faturamento.fatur_ativ_cronograma fac on facr.ftac_id = fac.ftac_id "
					+ " inner join faturamento.fatur_grupo_crg_mensal ftcm on fac.ftcm_id = ftcm.ftcm_id "
					+ " where facr.rota_id = :idRota " + " and fac.ftat_id = 5 " + " and ftcm.ftcm_amreferencia = :anoMesFaturamento "
					+ " and ftcm.ftgr_id = :grupoFaturamento ";

			retorno = (Date) session.createSQLQuery(consulta).addScalar("vencimento", Hibernate.DATE).setInteger("idRota", idRota)
					.setInteger("anoMesFaturamento", anoMesFaturamento).setInteger("grupoFaturamento", grupoFaturamento).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Esse metodo pesquisa as faturas de um cliente responsável federal, de
	 * acordo com o Mes/Ano, e de acordo com o id do Cliente de acordo com o
	 * RELATORIO SINTETICO DO UC0919
	 * 
	 * Se os dois parametros tiverem sido passados, procura usando os dois
	 * parametros, senão usa apenas o parametro anoMes que é obrigatorio
	 * 
	 * @author Jose Guilherme Macedo Vieira
	 * @date 08/07/2009
	 * 
	 * @param Integer
	 *            anoMes
	 * @param Integer
	 *            clienteID
	 * @return Collection - uma colecao de objetos Fatura
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaFaturaClienteResponsavelFederal(Integer anoMes, Integer clienteID) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT fatura " + "FROM Fatura fatura " + "INNER JOIN fetch fatura.cliente cliente "
					+ "INNER JOIN fetch cliente.clienteTipo clienteTipo " + "INNER JOIN fetch clienteTipo.esferaPoder esferaPoder "
					+ "WHERE  fatura.anoMesReferencia = :anoMes " + "AND  esferaPoder.id = :idEsferaPoder ";

			if (clienteID != null) {
				consulta += " and cliente.id = :clienteID ";
				consulta += " ORDER BY fatura.id";

				retorno = (Collection) session.createQuery(consulta).setInteger("clienteID", clienteID).setInteger("anoMes", anoMes)
						.setInteger("idEsferaPoder", EsferaPoder.FEDERAL).list();
			} else {
				consulta += " ORDER BY fatura.id";
				retorno = (Collection) session.createQuery(consulta).setInteger("anoMes", anoMes)
						.setInteger("idEsferaPoder", EsferaPoder.FEDERAL).list();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * 
	 * Pesquisa por todos os impostos a partir de uma fatura de um cliente
	 * responsavel federal e/ou de um imovel.
	 * 
	 * A fatura é obrigatória.
	 * 
	 * OBS: O id da fatura passado tem que ser de uma fatura de um cliente
	 * responsavel federal
	 * 
	 * @author Jose Guilherme Macedo Vieira, Fernando Fontelles Filho
	 * @date 08/07/2009, 28/09/2010
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaImpostoFaturaClienteResponsavelFederal(/*
																	 * Integer
																	 * idFatura
																	 */Integer anoMesFerencia, Integer idCliente/*
																												 * Integer
																												 * idImovel
																												 */)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			Query query = null;

			if (idCliente != null) {

				consulta = "select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cnid.cnid_pcaliquota as percAliquota, "
						+ " sum(cnid.cnid_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, "
						+ "clie.clie_nncnpj as cnpj "
						+ " from		faturamento.conta_impostos_deduzidos cnid "
						+ " inner	join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) "
						+ " inner	join cadastro.cliente_conta clct on (cnta.cnta_id = clct.cnta_id and clct.crtp_id = 3) "
						+ " inner	join cadastro.cliente clie on (clct.clie_id = clie.clie_id) "
						+ " inner	join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ " inner	join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) "
						+ " where	cnta.cnta_amreferenciaconta = :anoMesReferencia "
						+ " and		clct.clie_id = :idCliente "
						+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj "
						+ " union all "
						+ " select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cidh.cidh_pcaliquota as percAliquota, "
						+ " sum(cidh.cidh_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, "
						+ "clie.clie_nncnpj as cnpj "
						+ " from		faturamento.conta_impostos_dedz_hist cidh "
						+ " inner	join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) "
						+ " inner	join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) "
						+ " inner	join cadastro.cliente clie on (clch.clie_id = clie.clie_id) "
						+ " inner	join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ " inner	join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) "
						+ " where	cnhi.cnhi_amreferenciaconta = :anoMesReferencia "
						+ " and		clch.clie_id = :idCliente "
						+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj "
						+ " ORDER BY cliente, impostoTipo ";

				query = session.createSQLQuery(consulta).addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING).addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL).addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING).addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("cnpj", Hibernate.STRING).setInteger("anoMesReferencia", anoMesFerencia)
						.setInteger("idCliente", idCliente);

			} else {

				consulta = "select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cnid.cnid_pcaliquota as percAliquota, "
						+ " sum(cnid.cnid_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, "
						+ "clie.clie_nncnpj as cnpj "
						+ " from		faturamento.conta_impostos_deduzidos cnid "
						+ " inner	join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) "
						+ " inner	join cadastro.cliente_conta clct on (cnta.cnta_id = clct.cnta_id and clct.crtp_id = 3) "
						+ " inner	join cadastro.cliente clie on (clct.clie_id = clie.clie_id) "
						+ " inner	join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ " inner	join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) "
						+ " where	cnta.cnta_amreferenciaconta = :anoMesReferencia "
						+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj "
						+ " union all "
						+ " select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cidh.cidh_pcaliquota as percAliquota, "
						+ " sum(cidh.cidh_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, "
						+ "clie.clie_nncnpj as cnpj "
						+ " from		faturamento.conta_impostos_dedz_hist cidh "
						+ " inner	join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) "
						+ " inner	join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) "
						+ " inner	join cadastro.cliente clie on (clch.clie_id = clie.clie_id) "
						+ " inner	join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ " inner	join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) "
						+ " where	cnhi.cnhi_amreferenciaconta = :anoMesReferencia "
						+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj "
						+ " ORDER BY cliente, impostoTipo ";

				query = session.createSQLQuery(consulta).addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING).addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL).addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING).addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("cnpj", Hibernate.STRING).setInteger("anoMesReferencia", anoMesFerencia);
			}

			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * 
	 * Pesquisa por todos os impostos arrecadados a partir de um mês de
	 * referência de um determinado cliente federal ou de TODOS os clientes
	 * federais.
	 * 
	 * @author Diogo Peixoto
	 * @date 23/03/2011
	 * 
	 * @param Integer
	 *            anoMesFerencia
	 * @param Integer
	 *            idCliente
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImpostosArrecadacaoClienteResponsavelFederal(Integer anoMesFerencia, Integer idCliente)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer sbConsulta = new StringBuffer();

		try {

			Query query = null;

			if (idCliente != null) {
				sbConsulta.append(" ");

				sbConsulta.append("select imtp.imtp_id as impostoTipo, ");
				sbConsulta.append("imtp.imtp_dsimposto as descricaoImposto, ");
				sbConsulta.append("cnid.cnid_pcaliquota as percAliquota, ");
				sbConsulta.append("sum(cnid.cnid_vlimposto) as valorImposto, ");
				sbConsulta.append("clie.clie_id as cliente, ");
				sbConsulta.append("clie_nmcliente as nomeCliente, ");
				sbConsulta
						.append("sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, ");
				sbConsulta.append("clie.clie_nncnpj as cnpj ");
				sbConsulta.append("from	faturamento.conta_impostos_deduzidos cnid ");
				sbConsulta.append("inner join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) ");
				sbConsulta
						.append("inner join arrecadacao.pagamento pgmt on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null) ");
				sbConsulta.append("inner join cadastro.cliente_conta clct on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = 3) ");
				sbConsulta.append("inner join cadastro.cliente clie on (clct.clie_id = clie.clie_id) ");
				sbConsulta.append("inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) ");
				sbConsulta.append("inner join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) ");
				sbConsulta.append("where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferencia ");
				sbConsulta.append("and clct.clie_id = :idCliente ");
				sbConsulta
						.append("GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj ");
				sbConsulta.append("union all ");
				sbConsulta.append("select imtp.imtp_id impostoTipo, ");
				sbConsulta.append("imtp.imtp_dsimposto as descricaoImposto, ");
				sbConsulta.append("cidh.cidh_pcaliquota as percAliquota, ");
				sbConsulta.append("sum(cidh.cidh_vlimposto) as valorImposto, ");
				sbConsulta.append("clie.clie_id as cliente, ");
				sbConsulta.append("clie_nmcliente as nomeCliente, ");
				sbConsulta
						.append("sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, ");
				sbConsulta.append("clie.clie_nncnpj as cnpj ");
				sbConsulta.append("from	faturamento.conta_impostos_dedz_hist cidh ");
				sbConsulta.append("inner join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) ");
				sbConsulta
						.append("inner join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) ");
				sbConsulta.append("inner join arrecadacao.pagamento_historico pgmth on (clch.cnta_id = pgmth.cnta_id) ");
				sbConsulta.append("inner join cadastro.cliente clie on (clch.clie_id = clie.clie_id) ");
				sbConsulta.append("inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) ");
				sbConsulta.append("inner join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) ");
				sbConsulta.append("where pgmth.pghi_amreferenciaarrecadacao = :anoMesReferencia ");
				sbConsulta.append("and clch.clie_id = :idCliente ");
				sbConsulta
						.append("GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj ");
				sbConsulta.append("ORDER BY cliente, impostoTipo ");

				query = session.createSQLQuery(sbConsulta.toString()).addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING).addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL).addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING).addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("cnpj", Hibernate.STRING).setInteger("anoMesReferencia", anoMesFerencia)
						.setInteger("idCliente", idCliente);

			} else {

				sbConsulta.append("select imtp.imtp_id as impostoTipo, ");
				sbConsulta.append("imtp.imtp_dsimposto as descricaoImposto, ");
				sbConsulta.append("cnid.cnid_pcaliquota as percAliquota, ");
				sbConsulta.append("sum(cnid.cnid_vlimposto) as valorImposto, ");
				sbConsulta.append("clie.clie_id as cliente, ");
				sbConsulta.append("clie_nmcliente as nomeCliente, ");
				sbConsulta
						.append("sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, ");
				sbConsulta.append("clie.clie_nncnpj as cnpj ");
				sbConsulta.append("from	faturamento.conta_impostos_deduzidos cnid ");
				sbConsulta.append("inner join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) ");
				sbConsulta
						.append("inner join arrecadacao.pagamento pgmt on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null) ");
				sbConsulta.append("inner join cadastro.cliente_conta clct on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = 3) ");
				sbConsulta.append("inner join cadastro.cliente clie on (clct.clie_id = clie.clie_id) ");
				sbConsulta.append("inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) ");
				sbConsulta.append("inner join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) ");
				sbConsulta.append("where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferencia ");
				sbConsulta
						.append("GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj ");
				sbConsulta.append("union all ");
				sbConsulta.append("select imtp.imtp_id as impostoTipo, ");
				sbConsulta.append("imtp.imtp_dsimposto as descricaoImposto, ");
				sbConsulta.append("cidh.cidh_pcaliquota as percAliquota, ");
				sbConsulta.append("sum(cidh.cidh_vlimposto) as valorImposto, ");
				sbConsulta.append("clie.clie_id as cliente, ");
				sbConsulta.append("clie_nmcliente as nomeCliente, ");
				sbConsulta
						.append("sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, ");
				sbConsulta.append("clie.clie_nncnpj as cnpj ");
				sbConsulta.append("from	faturamento.conta_impostos_dedz_hist cidh ");
				sbConsulta.append("inner join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) ");
				sbConsulta
						.append("inner join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) ");
				sbConsulta.append("inner join arrecadacao.pagamento_historico pgmth on (clch.cnta_id = pgmth.cnta_id) ");
				sbConsulta.append("inner join cadastro.cliente clie on (clch.clie_id = clie.clie_id) ");
				sbConsulta.append("inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) ");
				sbConsulta.append("inner join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) ");
				sbConsulta.append("where pgmth.pghi_amreferenciaarrecadacao = :anoMesReferencia ");
				sbConsulta
						.append("GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj ");
				sbConsulta.append("ORDER BY cliente, impostoTipo ");

				query = session.createSQLQuery(sbConsulta.toString()).addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING).addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL).addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING).addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("cnpj", Hibernate.STRING).setInteger("anoMesReferencia", anoMesFerencia);
			}
			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Pesquisa por todos os impostos arrecadados a partir de um mês de
	 * referência de um determinado cliente federal ou de TODOS os clientes
	 * federais.
	 * 
	 * @author Diogo Peixoto
	 * @date 24/03/2011
	 * 
	 * @param Integer
	 *            anoMesFerencia
	 * @param Integer
	 *            idCliente
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImpostosArrecadacaoClienteResponsavelFederalAnalitico(Integer anoMesFerencia, Integer idCliente)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			Query query = null;

			if (idCliente != null) {

				consulta = "select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cnid.cnid_pcaliquota as percAliquota, "
						+ " sum(cnid.cnid_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, "
						+ " cnta.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ "from	faturamento.conta_impostos_deduzidos cnid "
						+ "inner join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) "
						+ "inner join arrecadacao.pagamento pgmt on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null) "
						+ "inner join cadastro.cliente_conta clct on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = 3) "
						+ "inner join cadastro.cliente clie on (clct.clie_id = clie.clie_id) "
						+ "inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ "inner join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) "
						+ "where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferencia "
						+ " and		clct.clie_id = :idCliente "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnta.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj "
						+ " union all "
						+ " select	imtp.imtp_id impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cidh.cidh_pcaliquota as percAliquota, "
						+ " sum(cidh.cidh_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, "
						+ " cnhi.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ "from	faturamento.conta_impostos_dedz_hist cidh "
						+ "inner join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) "
						+ "inner join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) "
						+ "inner join arrecadacao.pagamento_historico pgmth on (clch.cnta_id = pgmth.cnta_id) "
						+ "inner join cadastro.cliente clie on (clch.clie_id = clie.clie_id) "
						+ "inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ "inner join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) "
						+ " where	pgmth.pghi_amreferenciaarrecadacao = :anoMesReferencia "
						+ " and		clch.clie_id = :idCliente "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnhi.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj "
						+ " ORDER BY cliente, imovel, impostoTipo ";

				query = session.createSQLQuery(consulta).addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING).addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL).addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING).addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("imovel", Hibernate.INTEGER).addScalar("cnpj", Hibernate.STRING)
						.setInteger("anoMesReferencia", anoMesFerencia).setInteger("idCliente", idCliente);

			} else {

				consulta = "select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cnid.cnid_pcaliquota as percAliquota, "
						+ " sum(cnid.cnid_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, "
						+ " cnta.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ "from	faturamento.conta_impostos_deduzidos cnid "
						+ "inner join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) "
						+ "inner join arrecadacao.pagamento pgmt on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null) "
						+ "inner join cadastro.cliente_conta clct on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = 3) "
						+ "inner join cadastro.cliente clie on (clct.clie_id = clie.clie_id) "
						+ "inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ "inner join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) "
						+ "where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferencia "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnta.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj "
						+ " union all "
						+ " select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cidh.cidh_pcaliquota as percAliquota, "
						+ " sum(cidh.cidh_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, "
						+ " cnhi.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ "from	faturamento.conta_impostos_dedz_hist cidh "
						+ "inner join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) "
						+ "inner join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) "
						+ "inner join arrecadacao.pagamento_historico pgmth on (clch.cnta_id = pgmth.cnta_id) "
						+ "inner join cadastro.cliente clie on (clch.clie_id = clie.clie_id) "
						+ "inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ "inner join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) "
						+ " where	pgmth.pghi_amreferenciaarrecadacao = :anoMesReferencia "

						+ " GROUP BY clie.clie_id, clie_nmcliente, cnhi.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj "
						+ " ORDER BY cliente, imovel, impostoTipo ";

				query = session.createSQLQuery(consulta).addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING).addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL).addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING).addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("imovel", Hibernate.INTEGER).addScalar("cnpj", Hibernate.STRING)
						.setInteger("anoMesReferencia", anoMesFerencia);
			}
			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Esse método está de acordo com o UC0919 - Gerar Relatório de Impostos Por
	 * Cliente Responsável, no caso do Relatório Analítico o qual necessita
	 * recuperar os Imóveis que estão associados a uma Fatura (cujo id é passado
	 * como parâmetro Integer), a partir da tabela fatura_item.
	 * 
	 * @author Jose Guilherme Macedo Vieira
	 * @date 13/07/2009
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection<Imovel> - a colecao de imoveis associadas a uma fatura
	 * @throws ErroRepositorioException
	 */
	public Collection<Imovel> pesquisarImoveisFaturaClienteResponsavel(Integer idFatura) throws ErroRepositorioException {

		Collection<Imovel> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT imo " + "FROM FaturaItem fatIt " + "INNER JOIN fatIt.imovel imo  "
					+ "INNER JOIN imo.clienteImoveis cliImo with " + "(cliImo.clienteRelacaoTipo.id = 2 and "
					+ "cliImo.dataFimRelacao = null)" + "INNER JOIN fetch fatIt.fatura.cliente cli "
					+ "WHERE  fatIt.fatura.id = :idFatura ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idFatura", idFatura).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * Atualizar total de documentos, itens e valores realizados nos comandos de
	 * acao de cobranca
	 * 
	 * Data: 28/07/2009
	 * 
	 * @author Francisco do Nascimento
	 * 
	 * @param idCAAC
	 *            Identificador de CobrancaAcaoAtividadeCronograma
	 * @return Array de objetos com valores de 0 - quantidade de itens cobrados
	 *         1 - valor total dos documentos 2 - quantidade de documentos
	 */
	public Object[] calcularTotaisCronogramaAcaoCobranca(Integer idCAAC) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Object[] retorno = new Object[3];

		try {

			Date dataAtual = new Date();

			// usou-se a condicao ultimaAlteracao > xxxxxx para melhorar o tempo
			// da query
			String consulta = "SELECT count(cdi.id) FROM CobrancaDocumentoItem cdi where " + "cdi.ultimaAlteracao > :dataGeracaoItem "
					+ " and cdi.cobrancaDocumento.id in "
					+ "(select cd.id from CobrancaDocumento cd where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC) ";

			// quantidade de itens cobrados
			retorno[0] = (Integer) session.createQuery(consulta).setInteger("idCAAC", idCAAC)
					.setDate("dataGeracaoItem", Util.subtrairNumeroDiasDeUmaData(dataAtual, 2)).uniqueResult();

			consulta = "SELECT sum(cd.valorDocumento) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC ";

			// valor total dos documentos
			retorno[1] = (BigDecimal) session.createQuery(consulta).setInteger("idCAAC", idCAAC).uniqueResult();

			consulta = "SELECT count(cd.id) FROM CobrancaDocumento cd " + "where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC ";

			// quantidade de documentos
			retorno[2] = (Integer) session.createQuery(consulta).setInteger("idCAAC", idCAAC).uniqueResult();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Pesquisa todas as localidades do cicloMeta agrupando por localidade,
	 * unidade e gerencia.
	 * 
	 * 
	 * @author Genival Barbosa
	 * @date 03/08/2009
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public List consultarColecaoCicloMetaGrupoRelatorio(Integer idCicloMeta) throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select  ger.id, " + "ger.nome, " + "uni.id, " + "uni.nome, " + "loc.id, " + "loc.descricao, "
					+ "sum(cmg.metaCalculada) as metaCalculada, " + "sum(cmg.metaAjustada) as metaAjustada, "
					+ "sum(cmg.quantidadeImoveisSituacaoAgua) as quantidadeImoveis, "
					+ "sum(cmg.quantidadeRealizada) as quantidadeRealizada, " + "sum(cmg.valorRealizado) as valorRealizado, "
					+ "sum(cmg.quantidadeDocumentosRestantes) as quantidadeDocumentosRestantes, "
					+ "sum(cmg.valorTotalDocumentosRestantes) as valorTotalDocumentosRestantes " + "from CicloMetaGrupo cmg "
					+ "inner join cmg.cicloMeta cme " + "inner join cmg.localidade loc " + "inner join loc.gerenciaRegional ger "
					+ "inner join loc.unidadeNegocio uni " + "where cmg.cicloMeta = :idCicloMeta "
					+ "group by loc.id ,uni.id,ger.id ,ger.nome, uni.nome, loc.descricao " + "order by ger.nome, uni.nome, loc.descricao ";

			retorno = session.createQuery(consulta).setInteger("idCicloMeta", idCicloMeta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel, BigDecimal valorPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id " // 15
					+ "FROM CobrancaDocumentoItem cdi " + "LEFT JOIN cdi.cobrancaDocumento cd " + "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo " + "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage " + "LEFT JOIN cd.localidade loca " + "LEFT JOIN cd.imovel imov "
					+ "WHERE cd.valorDocumento = :valorDocumento AND " + "imovel.id = :idImovel";

			retorno = session.createQuery(consulta).setBigDecimal("valorDocumento", valorPagamento)
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	

	/**
	 * 
	 * UC0905 - Gerar Relatorio Acompanhamento Acao Cobrança
	 * 
	 * @author Genival Barbosa
	 * @date 26/08/2009
	 * 
	 * @param RelatorioAcompanhamentoAcoesCobrancaHelper
	 *            helper
	 * 
	 * @return Lista de acoes de cobranca
	 */
	public List consultarColecaoAcaoCobranca(RelatorioAcompanhamentoAcoesCobrancaHelper helper) throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();

		String idCobrancaAcao = helper.getIdCobrancaAcao();
		String dataInicial = helper.getDataInicial() + " 00:00:00";
		String dataFinal = helper.getDataFinal() + " 23:59:59";
		String idGerenciaRegional = helper.getIdGerenciaRegional();
		String idUnidadeNegocio = helper.getIdUnidadeNegocio();
		String idLocalidade = helper.getIdLocalidade();
		String idEmpresa = helper.getIdEmpresa();

		String consulta;

		try {
			consulta = "select ger.id, "

			+ "ger.nome, " + "uni.id, " + "uni.nome, " + "loc.id, " + "loc.descricao, " + "cas.id, " + "cas.descricao, "
					+ "count(cod.id) as quantidadeSituacao, " + "sum(cod.valorDocumento) as valorSituacao, ";

			// ainda falta resolver o problema da empresa
			if (!idEmpresa.trim().equals("-1")) {

				consulta = consulta + "empr.id, empr.descricao, ";
			}

			consulta = consulta + "coa.id, " + "coa.descricaoCobrancaAcao " + "from CobrancaDocumento cod "
					+ "inner join cod.cobrancaAcaoSituacao cas " + "inner join cod.localidade loc "
					+ "inner join loc.gerenciaRegional ger " + "inner join loc.unidadeNegocio uni " + "inner join cod.empresa empr "
					+ "inner join cod.cobrancaAcao coa " + "where coa.id = " + idCobrancaAcao + " and "
					+ "cod.emissao >= :dataInicial and " + "cod.emissao <= :dataFinal ";

			if (!idGerenciaRegional.trim().equals("-1")) {
				consulta = consulta + "and ger.id = " + idGerenciaRegional + " ";
			}
			if (!idUnidadeNegocio.trim().equals("-1")) {
				consulta = consulta + "and uni.id = " + idUnidadeNegocio + " ";
			}
			if (!idLocalidade.trim().equals("-1")) {
				consulta = consulta + "and loc.id = " + idLocalidade + " ";
			}

			// ainda falta resolver o problema da empresa
			if (!idEmpresa.trim().equals("-1")) {
				consulta = consulta + "and cod.empresa = " + idEmpresa + " ";
				consulta = consulta
						+ "group by cas.id, loc.id, uni.id, ger.id , empr.descricao, coa.id, ger.nome, uni.nome, loc.descricao, cas.descricao, empr.id , coa.descricaoCobrancaAcao ";
			} else {
				consulta = consulta
						+ "group by cas.id, loc.id, uni.id, ger.id , coa.id, ger.nome, uni.nome, loc.descricao, cas.descricao, coa.descricaoCobrancaAcao ";
			}
			consulta = consulta + "order by ger.nome, uni.nome, loc.descricao, cas.id ";

			Query query = null;
			query = session.createQuery(consulta).setDate("dataInicial", Util.converteStringParaDateHora(dataInicial))
					.setDate("dataFinal", Util.converteStringParaDateHora(dataFinal));
			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Esse método está de acordo com o UC0258 - Filtrar Documentos de Cobrança,
	 * retorna conjunto de CAAC_ID(ações do ciclo) selecionados
	 * 
	 * @author Anderson Italo
	 * @date 03/08/2009
	 * 
	 * @param Collection
	 *            <Integer> idsAcao
	 * @param Integer
	 *            anoMesReferencia
	 * @return Collection<CobrancaAcaoAtividadeCronograma> - a colecao de
	 *         cobrancaAcaoAtividadeCronograma associados as acoes e
	 *         anoMesReferencia Informados
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarAcoesCiclo(Collection idsAcao, Integer anoMesReferencia)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select caac.id " + "from gcom.cobranca.CobrancaAcaoAtividadeCronograma caac "
					+ "inner join fetch caac.cobrancaAcaoCronograma cacr " + "inner join cacr.cobrancaGrupoCronogramaMes cgcm "
					+ "where cgcm.anoMesReferencia = :anoMesReferencia " + "and cacr.cobrancaAcao.id in (:ids) "
					+ "and caac.cobrancaAtividade.id = 2";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setParameterList("ids", idsAcao)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o UC[0258]Filtrar Documento de Cobranca, é
	 * utilizado pelo relatório filtrar documentos de cobrança
	 * 
	 * @author Anderson Italo
	 * @date 19/08/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List filtrarCobrancaDocumento(FiltrarDocumentoCobrancaHelper filtro) throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emissão cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2 || filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select " + "doc.cbdo_id as idDocumento, " + "a.imov_id as idImovel, " + "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, " + "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, " + "a.imov_nnsublote as subLote, " + "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, " + "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, " + "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, " + "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc " + "LEFT OUTER JOIN cadastro.imovel a " + "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b " + "on a.loca_id = b.loca_id " + "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id " + "inner join cadastro.quadra d " + "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null " + "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id " + "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id " + "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id " + "inner join cadastro.imovel_perfil i " + "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j " + "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k " + "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l " + "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id=" + filtro.getIdsDocumentoEmissaoForma()[0].toString() + " and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i].toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0, consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissao
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a união dos 2 selects o primeiro trata apenas ações de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += " union ";

				consulta += " select " + "doc.cbdo_id as idDocumento, " + "a.imov_id as idImovel, " + "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, " + "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, " + "a.imov_nnsublote as subLote, " + "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, " + "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, " + "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, " + "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc " + "left outer join cadastro.imovel a " + "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b " + "on a.loca_id = b.loca_id " + "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id " + "inner join cadastro.quadra d " + "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null " + "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id " + "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id " + "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id " + "inner join cadastro.imovel_perfil i " + "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j " + "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k " + "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l " + "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i].equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			} else {
				consulta += " select " + "doc.cbdo_id as idDocumento, " + "a.imov_id as idImovel, " + "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, " + "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, " + "a.imov_nnsublote as subLote, " + "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, " + "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, " + "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, " + "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc " + "left outer join cadastro.imovel a " + "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b " + "on a.loca_id = b.loca_id " + "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id " + "inner join cadastro.quadra d " + "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null " + "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id " + "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id " + "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id " + "inner join cadastro.imovel_perfil i " + "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j " + "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k " + "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l " + "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i].toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0, consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta).addScalar("idDocumento", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("codSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.INTEGER)
					.addScalar("subLote", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("descricaoLigAguaSituacao", Hibernate.STRING).addScalar("descricaoLigEsgotoSituacao", Hibernate.STRING)
					.addScalar("descricaoImovelPerfil", Hibernate.STRING).addScalar("descricaoCategoria", Hibernate.STRING)
					.addScalar("data_emissao", Hibernate.TIMESTAMP).addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("descricaoSituacaoAcao", Hibernate.STRING).addScalar("descricaoSituacaoDebito", Hibernate.STRING);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o UC[0258]Filtrar Documento de Cobranca, é
	 * utilizado pelo relatório filtrar documentos de cobrança para totalizar os
	 * registros filtrados
	 * 
	 * @author Anderson Italo
	 * @date 19/08/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer filtrarCobrancaDocumentoCount(FiltrarDocumentoCobrancaHelper filtro) throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emissão cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2 || filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select (select " + " count(doc.cbdo_id) " + "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a " + "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b " + "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c " + "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d " + "on doc.empr_id = d.empr_id " + "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id " + "left outer join cadastro.localidade f " + "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id=" + filtro.getIdsDocumentoEmissaoForma()[0].toString() + " and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i].toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0, consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissao
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a união dos 2 selects o primeiro trata apenas ações de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += ") + ";

				consulta += " (select " + "count(doc.cbdo_id) " + "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a " + "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b " + "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c " + "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d " + "on doc.empr_id = d.empr_id " + "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id " + "left outer join cadastro.localidade f " + "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i].equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += ") as totalDocumentos";

			} else {
				consulta += " select " + "count(doc.cbdo_id) as totalDocumentos " + "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a " + "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b " + "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c " + "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d " + "on doc.empr_id = d.empr_id " + "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id " + "left outer join cadastro.localidade f " + "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i].toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0, consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}
			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta).addScalar("totalDocumentos", Hibernate.INTEGER);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o [UC0906] Gerar Relatório de
	 * Acompanhamento das Supressões, Religações e Reestabelecimentos. É
	 * utilizado pelo relatório filtrar os registros do relatorio
	 * 
	 * @author Anderson Italo
	 * @date 28/08/2009
	 * 
	 * @param FiltroSupressoesReligacoesReestabelecimentoHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List filtrarSupressoesReligacoesReestabelecimentos(FiltroSupressoesReligacoesReestabelecimentoHelper filtro)
			throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicio() + " 00:00:00");
		Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFim() + " 23:59:59");
		Integer limiteReligacaoCorteDias = new Integer(filtro.getLimititeReligacaoPosCorte());

		try {

			consulta = "select d.nomeAbreviado, d.nome, e.nome, b.descricao, "
					+ "sum(case when ((la.dataReligacao - la.dataCorte) < :limiteReligacaoCorteDias) "
					+ "and  (la.dataReligacao >= :dataInicial "
					+ "and la.dataReligacao <= :dataFinal)then 1 else 0 end) as religacaoMenosDeLimiteDias, "

					+ "sum(case when ((la.dataReligacao - la.dataCorte) >= :limiteReligacaoCorteDias) "
					+ "and  (la.dataReligacao >= :dataInicial "
					+ "and la.dataReligacao <= :dataFinal) then 1 else 0 end) as religacaoMaiorDeLimiteDias, "

					+ "sum(case when ((la.dataSupressao is not null) " + "and (la.dataSupressao >= :dataInicial "
					+ "and la.dataSupressao <= :dataFinal)) then 1 else 0 end) as supressao, "

					+ "sum(case when ((la.dataRestabelecimentoAgua is not null) " + "and (la.dataRestabelecimentoAgua >= :dataInicial "
					+ "and la.dataRestabelecimentoAgua <= :dataFinal)) then 1 else 0 end) as reestabelecimento, "

					+ "sum(case when ((la.dataCorte is not null) " + "and (la.dataCorte >= :dataInicial "
					+ "and la.dataCorte <= :dataFinal)) then 1 else 0 end) as cortes "

					+ "from gcom.atendimentopublico.ligacaoagua.LigacaoAgua la, " + "gcom.cadastro.imovel.Imovel im, "
					+ "gcom.cadastro.localidade.Localidade b, " + "gcom.cadastro.empresa.Empresa c, "
					+ "gcom.cadastro.localidade.GerenciaRegional d, " + "gcom.cadastro.localidade.UnidadeNegocio e, "
					+ "gcom.atendimentopublico.ordemservico.OrdemServico f, "
					+ "gcom.atendimentopublico.ordemservico.OrdemServicoUnidade g, " + "gcom.seguranca.acesso.usuario.Usuario h "
					+ "where la.id = im.id " + "and im.localidade.id = b.id " + "and b.gerenciaRegional.id = d.id "
					+ "and b.unidadeNegocio.id = e.id " + "and im.id = f.imovel.id " + "and f.atendimentoMotivoEncerramento.id = 2 "
					+ "and f.id = g.ordemServico.id " + "and g.atendimentoRelacaoTipo.id = 3 " + "and g.usuario.id = h.id "
					+ "and h.empresa.id = c.id "
					+ "and  ((la.dataReligacao = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataReligacao >= :dataInicial " + "and   la.dataReligacao <= :dataFinal " + "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo " + "FROM ServicoTipoOperacao stop " + "WHERE stop.comp_id.idOperacao = 50)"
					+ ") " + "or    (la.dataSupressao = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataSupressao >= :dataInicial " + "and   la.dataSupressao <= :dataFinal " + "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo " + "FROM ServicoTipoOperacao stop " + "WHERE stop.comp_id.idOperacao = 685)"
					+ ") " + "or    (la.dataRestabelecimentoAgua = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataRestabelecimentoAgua >= :dataInicial " + "and   la.dataRestabelecimentoAgua <= :dataFinal "
					+ "and   f.servicoTipo.id in " + "(SELECT stop.comp_id.idServicoTipo " + "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao in (51,879))" + ")"
					+ "or    (la.dataCorte = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataCorte >= :dataInicial " + "and   la.dataCorte <= :dataFinal " + "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo " + "FROM ServicoTipoOperacao stop " + "WHERE stop.comp_id.idOperacao in (48))"
					+ ")" + ") " + "and ";

			// idGerenciaRegional
			if (filtro.getIdGerenciaRegional() != null && !filtro.getIdGerenciaRegional().equals("")) {
				consulta += "d.id = " + filtro.getIdGerenciaRegional() + " and ";
			}

			// unidadeNegocio
			if (filtro.getIdUnidadeNegocio() != null && !filtro.getIdUnidadeNegocio().equals("")) {
				consulta += "e.id = " + filtro.getIdUnidadeNegocio() + " and ";
			}

			// Localidade
			if (filtro.getIdLocalidade() != null && !filtro.getIdLocalidade().equals("")) {
				consulta += "b.id = " + filtro.getIdLocalidade() + " and ";
			}

			// Empresa
			if (filtro.getIdEmpresa() != null && !filtro.getIdEmpresa().equals("")) {
				consulta += "c.id = " + filtro.getIdEmpresa() + " and ";
			}

			// retira o and do final se houver
			if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
				consulta = consulta.substring(0, consulta.length() - 4);
			}

			consulta += " group by " + "d.nomeAbreviado, d.nome, " + "e.nome, b.descricao " + "order by " + "d.nomeAbreviado, d.nome, "
					+ "e.nome, b.descricao";

			retorno = session.createQuery(consulta).setParameter("limiteReligacaoCorteDias", limiteReligacaoCorteDias)
					.setParameter("dataInicial", dataInicial).setParameter("dataFinal", dataFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o UC[0258]Filtrar Documento de Cobranca
	 * 
	 * @author Anderson Italo
	 * @date 16/09/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List consultarDocumentosCobranca(FiltrarDocumentoCobrancaHelper filtro) throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emissão cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2 || filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select " + "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, " + "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc " + "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id " + "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id " + "left outer join cobranca.documento_tipo c " + "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d " + "on doc.empr_id = d.empr_id " + "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id " + "left outer join cadastro.localidade f " + "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id=" + filtro.getIdsDocumentoEmissaoForma()[0].toString() + " and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i].toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0, consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissao
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a união dos 2 selects o primeiro trata apenas ações de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += " union ";

				consulta += " select " + "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, " + "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc " + "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id " + "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id " + "left outer join cobranca.documento_tipo c " + "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d " + "on doc.empr_id = d.empr_id " + "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id " + "left outer join cadastro.localidade f " + "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i].equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			} else {
				consulta += " select " + "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, " + "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc " + "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id " + "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id " + "left outer join cobranca.documento_tipo c " + "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d " + "on doc.empr_id = d.empr_id " + "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id " + "left outer join cadastro.localidade f " + "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString() + " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null && filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id=" + filtro.getIdGerenciaRegional().toString() + " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null && filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id=" + filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null && filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0 && filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in(" + filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString() + ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null && filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0 && filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in(" + filtro.getIdSetorComercialInicial().toString() + ","
							+ filtro.getIdSetorComercialFinal().toString() + ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null && filtro.getIdQuadraFinal() != null && filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in(" + filtro.getIdQuadraInicial().toString() + "," + filtro.getIdQuadraFinal().toString()
							+ ") and ";
				}

				// forma de emissão
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null && filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null && filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null && filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null && !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null && !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '" + filtro.getValorDocumentoInicial().toEngineeringString() + "' and '"
							+ filtro.getValorDocumentoFinal().toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null && filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null && filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null && filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null && filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i].toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0, consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null && !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null && !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta.substring(consulta.length() - 4, consulta.length()).equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta).addScalar("idDocumento", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idCobrancaAcao", Hibernate.INTEGER).addScalar("descricaoCobrancaAcao", Hibernate.STRING)
					.addScalar("data_emissao", Hibernate.TIMESTAMP).addScalar("idEmissaoForma", Hibernate.INTEGER)
					.addScalar("descricaoEmissaoForma", Hibernate.STRING).addScalar("idDocumentoTipo", Hibernate.INTEGER)
					.addScalar("descricaoDocumentoTipo", Hibernate.STRING).addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("nomeEmpresa", Hibernate.STRING).addScalar("valorDocumento", Hibernate.BIG_DECIMAL);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0959] Gerar Arquivo Texto de Pagamentos das Contas em Cobrança por
	 * Empresa
	 * 
	 * @author: Hugo Amorim
	 * @date: 05/10/2009
	 */
	public Collection pesquisarDadosArquivoTextoPagamentosContasCobrancaEmpresa(Integer idEmpresa)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		StringBuilder consulta = new StringBuilder();

		try {

			StringBuilder from = new StringBuilder();
			
			String colunaAnoMesHistorico = " cnta.cnhi_amreferenciaconta ";
			String colunaCodigoSetorHistorico = " cnta.cnhi_cdsetorcomercial ";
			String tabelaContaHistorico = " faturamento.conta_historico as cnta ";
			
			String colunaAnoMes = " cnta.cnta_amreferenciaconta ";
			String colunaCodigoSetor = " cnta.cnta_cdsetorcomercial ";
			String tabelaConta = " faturamento.conta as cnta ";
			
			
			consulta.append(obterConsultaDadosArquivoTextoPagamentosContasCobrancaEmpresa(colunaAnoMesHistorico, colunaCodigoSetorHistorico, tabelaContaHistorico))
					.append(" UNION ")
					.append(obterConsultaDadosArquivoTextoPagamentosContasCobrancaEmpresa(colunaAnoMes, colunaCodigoSetor, tabelaConta))
					.append(" order by 12, 14, 1,3 ");

			retorno = session.createSQLQuery(consulta.toString())
					.addScalar("idImovel", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER).addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferenciaPagamento", Hibernate.INTEGER).addScalar("tipoPagamento", Hibernate.INTEGER)
					.addScalar("numParcelas", Hibernate.INTEGER).addScalar("numParcelasTotal", Hibernate.INTEGER)
					.addScalar("valorPrincipal", Hibernate.BIG_DECIMAL).addScalar("valorEncargos", Hibernate.BIG_DECIMAL)
					.addScalar("percentualEmpresa", Hibernate.BIG_DECIMAL).addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("quadra", Hibernate.INTEGER)
					.addScalar("lote", Hibernate.INTEGER).addScalar("sublote", Hibernate.INTEGER)
					.addScalar("codigoRota", Hibernate.INTEGER).addScalar("sequenciaRota", Hibernate.INTEGER)
					.addScalar("codSetor", Hibernate.INTEGER).addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("idCobrancaContaPagamento", Hibernate.INTEGER)
					.setInteger("idEmpresa", idEmpresa)
					.setShort("indicadorGeracaoArquivo", ConstantesSistema.NAO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	private StringBuilder obterConsultaDadosArquivoTextoPagamentosContasCobrancaEmpresa(String colunaAnoMes, String colunaCodigoSetor, String tabelaConta) {
		StringBuilder consulta = new StringBuilder();
		
		consulta.append(" select cc.imov_id as idImovel, ") // 0
	        .append(" clie_nmcliente as nomeCliente, ") // 1
	        .append( colunaAnoMes + " as anoMesConta, ") // 2
	        .append(" ecco_vloriginalconta as valorConta, ") // 3
	        .append(" eccp_ampagamento as anoMesReferenciaPagamento, ")// 4
	        .append("  eccp_ictipopagamento as tipoPagamento,") // 5
	        .append("  eccp_nnparcelaatual as numParcelas,") // 6
	        .append("  eccp_nntotalparcelas as numParcelasTotal,") // 7
	        .append(" sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) ")
	        .append(" then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, ") // 8
	        .append(" sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) ")
	        .append(" then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, ") // 9
	        .append(" cc.ecco_pcempresaconta as percentualEmpresa, ") // 10
	        .append("  lc.uneg_id as idUnidadeNegocio, ")// 11
	        .append("  un.uneg_nmunidadenegocio as nomeUnidadeNegocio, ")// 12
	        .append("  im.loca_id as idLocalidade, ")// 13
	        .append("  lc.loca_nmlocalidade as nomeLocalidade, ")// 14
	        .append("  qd.qdra_nnquadra as quadra, ")// 15
	        .append("  im.imov_nnlote as lote, ")// 16
	        .append("  im.imov_nnsublote as sublote, ")// 17
	        .append("  rt.rota_cdrota as codigoRota, ")// 18
	        .append("  im.imov_nnsequencialrota as sequenciaRota, ")// 19
	        .append( colunaCodigoSetor + " as codSetor, ")// 20
	        .append("  ccp.eccp_dtpagamento as dataPagamento, ") // 21
	        .append("  ccp.eccp_id as idCobrancaContaPagamento ") // 22
	        .append(" from   cobranca.empr_cobr_conta_pagto ccp ")
	        .append(" inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa ")
	        .append(" inner join "+  tabelaConta + " on cnta.cnta_id  = cc.cnta_id ")
	        .append(" inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 ")
	        .append("   and ci.clim_dtrelacaofim is null) ")
	        .append(" inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) ")
	        .append(" inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id ")
	        .append(" inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id ")
	        .append(" inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id ")
	        .append(" inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id ")
	        .append(" inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id ")
	        .append(" inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id ")
	        .append(" where cc.empr_id = :idEmpresa ")
	        .append(" and ccp.eccp_icgeracaoarquivo = :indicadorGeracaoArquivo ")
	        .append(" group by cc.imov_id, clie_nmcliente, " +  colunaAnoMes + " , ecco_vloriginalconta, eccp_ampagamento, ")
	        .append(" eccp_ictipopagamento, eccp_nnparcelaatual, eccp_nntotalparcelas, cc.ecco_pcempresaconta, lc.uneg_id, ")
	        .append(" un.uneg_nmunidadenegocio, im.loca_id, lc.loca_nmlocalidade, qd.qdra_nnquadra, im.imov_nnlote, ")
	        .append(" im.imov_nnsublote,rt.rota_cdrota,im.imov_nnsequencialrota, " + colunaCodigoSetor + " ,ccp.eccp_dtpagamento, ccp.eccp_id ");
		
		return consulta;
	}

	public Collection obterUnidadeNegocioPagamentosEmpresaCobrancaConta() throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct loca.uneg_id as idUnidadeNegocio " + "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join cadastro.imovel imov on imov.imov_id = ecco.imov_id "
					+ "inner join cadastro.localidade loca on loca.loca_id = imov.loca_id ";

			retorno = session.createSQLQuery(consulta).addScalar("idUnidadeNegocio", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Sávio Luiz
	 */
	public CobrancaDocumento pesquisarCobrancaDocumentoImpressaoSimultanea(Date dataEmissao, Integer idImovel)
			throws ErroRepositorioException {

		CobrancaDocumento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "LEFT JOIN fetch cbdo.localidade as loca "
					+ "WHERE cbdo.imovel.id = :idImovel AND " + "cbdo.documentoTipo.id = :idDocumentoTipo AND "
					+ "cbdo.cobrancaDebitoSituacao.id = :idCobrancaDebitoSituacao AND " + "cbdo.emissao >= :dataEmissao "
					+ "order by cbdo.emissao desc ";

			retorno = (CobrancaDocumento) session.createQuery(consulta).setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", DocumentoTipo.AVISO_CORTE)
					.setInteger("idCobrancaDebitoSituacao", CobrancaDebitoSituacao.PENDENTE).setTimestamp("dataEmissao", dataEmissao)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC????] Relatorio Comando Documento Cobranca Alterado para verificar
	 * tipo da ação a partir da tabela documento_tipo
	 * 
	 * @author Rômulo Aurélio, Anderson Italo
	 * 
	 * @data 20/10/2009, 04/05/2010
	 */
	public DocumentoTipo pesquisarTipoAcaoCobrancaParaRelatorio(Integer cobrancaAcaoAtividadeComando,
			Integer cobrancaAcaoAtividadeCronograma) throws ErroRepositorioException {

		DocumentoTipo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cobrancaDocumento.documentoTipo " + "FROM CobrancaDocumento cobrancaDocumento ";

			if (cobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta + "WHERE cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id =  " + cobrancaAcaoAtividadeCronograma
						+ " ";
			} else if (cobrancaAcaoAtividadeComando != null) {
				consulta = consulta + "WHERE cobrancaDocumento.cobrancaAcaoAtividadeComando.id = " + cobrancaAcaoAtividadeComando + " ";
			}

			retorno = (DocumentoTipo) session.createQuery(consulta).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<CobrancaDocumento> pesquisarDocumentoCobrancaParaRelatorio(Integer idCobrancaAcaoCronograma,
			Integer idCobrancaAcaoComando) throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "INNER JOIN FETCH cbdo.imovel imov "
					+ "INNER JOIN FETCH imov.quadra qdra " + "INNER JOIN FETCH qdra.rota " + "INNER JOIN FETCH cbdo.ligacaoAguaSituacao "
					+ "INNER JOIN FETCH cbdo.ligacaoEsgotoSituacao " + "WHERE ";

			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma;
			} else if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando;
			}

			consulta = consulta + " ORDER BY cbdo.localidade.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ "imov.lote, imov.subLote, cbdo.id";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer obterOrdemServicoAssociadaDocumentoCobranca(Integer idCobrancaDocumento) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select orse_id as idOrdemServico "
			// + "from cobranca.cobranca_documento cbdo "
					+ "from atendimentopublico.ordem_servico " + "where cbdo_id  = " + idCobrancaDocumento + " ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("idOrdemServico", Hibernate.INTEGER).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * @author Rômulo Aurélio
	 * @date 20/10/2009
	 * 
	 * @param idCobrancaDocumento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public CobrancaDocumento pesquisarCobrancaDocumento(Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		CobrancaDocumento retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT cobrancaDocumento  " + "FROM cobrancaDocumento cd " + "inner join fetch cd.cobrancaAcao "
					+ "WHERE cd.id = :idCobrancaDocumento ";

			retorno = (CobrancaDocumento) session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o [UC0901] Gerar Metas do Ciclo
	 * 
	 * @author Anderson Italo
	 * @date 21/09/2009
	 * 
	 * @param Integer
	 *            idCicloMeta
	 * @throws ErroRepositorioException
	 */
	public void removerCicloMetaGrupo(Integer idCicloMeta) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "delete CicloMetaGrupo c " + "where c.cicloMeta.id = :idCicloMeta ";

			session.createQuery(consulta).setInteger("idCicloMeta", new Integer(idCicloMeta).intValue()).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * retorna coleção de idEmpresaCobranca de uma Rota
	 * 
	 * @author Arthur Carvalho
	 * @date 06/11/2009
	 * 
	 * @param id
	 *            da localidade
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarEmpresaCobrancaDaRota(Integer idLocalidade) throws ErroRepositorioException {

		Collection<Integer> idEmpresaCobranca = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(rota.empr_idcobranca) as idCobranca " + " FROM micromedicao.rota rota "
					+ " INNER JOIN cadastro.setor_comercial setor " + " ON setor.stcm_id = rota.stcm_id " + " WHERE setor.loca_id = "
					+ idLocalidade + " ";

			idEmpresaCobranca = session.createSQLQuery(consulta).addScalar("idCobranca", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return idEmpresaCobranca;
	}

	/**
	 * [UC0630] - Solicitar Emissão do Extrato de Débitos Author: Rômulo Aurélio
	 * Data: 05/11/2009
	 * 
	 * Obtem os débitos a cobrar que estejam com PARC_ID = NULL, com SITUACAO
	 * NORMAL E FINANCIAMENTO_TIPO = 2
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarParceladoComIDNulo(Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(dbac) " + "FROM DebitoACobrar dbac " + "inner join fetch dbac.debitoTipo debitoTipo "
					+ "where dbac.imovel.id = :idImovel  " + "AND dbac.financiamentoTipo = 2 " + "AND dbac.parcelamento is null "
					+ "AND dbac.numeroPrestacaoCobradas < (dbac.numeroPrestacaoDebito - coalesce(dbac.numeroParcelaBonus,0)) "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta).setInteger("normal", DebitoCreditoSituacao.NORMAL).setInteger("idImovel", idImovel)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * atualiza o valor do documento e o valor de desconto do documento de
	 * cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorDocumentoEValorDescontoCobrancaDocumento(Integer idCobrancaDocumento, BigDecimal valorDocumento,
			BigDecimal valorDesconto) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String consulta = "update gcom.cobranca.CobrancaDocumento " + "set cbdo_vldocumento = :valorDocumento , "
					+ "cbdo_vldesconto = :valorDesconto , " + "cbdo_tmultimaalteracao = :dataAtual "
					+ "where cbdo_id = :idCobrancaDocumento ";

			session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setBigDecimal("valorDocumento", valorDocumento).setBigDecimal("valorDesconto", valorDesconto)
					.setDate("dataAtual", new Date()).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);

		}
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * pesquisa o documento de cobranca do imovel e do documento tipo passado
	 * como parametro
	 * 
	 * @author Vivianne Sousa
	 * @date 19/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoDoImovel(Integer idImovel, Integer idDocumentoTipo)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "LEFT JOIN cbdo.imovel as imov "
					+ "LEFT JOIN cbdo.documentoTipo as docTipo " + "WHERE " + "imov.id = :idImovel and docTipo = :idDocumentoTipo ";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idDocumentoTipo", idDocumentoTipo).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Criança para
	 * Negociação a Vista
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos das cartas
	 * de fim de ano
	 * 
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirCartaFinalAno(Integer idCobrancaGrupo, Integer idEmpresa, Integer idLocalidade, Integer codigoSetor,
			Integer numeroQuadra, Integer lote, Integer subLote, Integer sequencial, String txt_parte1, String txt_parte2, Integer idRota)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into public.carta_final_ano values (" + idCobrancaGrupo + "," + idEmpresa + "," + idLocalidade + ","
					+ codigoSetor + "," + numeroQuadra + "," + lote + "," + subLote + "," + sequencial + "," + "'" + txt_parte1 + "',"
					+ "'" + txt_parte2 + "'," + idRota + ")";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [0968] - Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCartaFinalAnoGrupo(Integer idCobrancaGrupo) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		Collection retorno = new ArrayList();

		try {
			stmt = con.createStatement();

			consulta = " select txt_parte1  as parte1 , txt_parte2 as parte2 " + " from carta_final_ano " + " where cbgr_id = "
					+ idCobrancaGrupo
					+ " order by  empr_id,loca_id,stcm_cdsetorcomercial, qdra_nnqdra,imon_nnlote ,imov_nnsublote, sequencial";

			ResultSet set = stmt.executeQuery(consulta);

			while (set.next()) {
				Object[] objs = new Object[2];
				objs[0] = set.getString("parte1");
				objs[1] = set.getString("parte2");
				retorno.add(objs);
			}

			return retorno;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarCartaFinalAno(Integer idRota) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "delete from carta_final_ano where  rota_id = " + idRota;

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Anderson Italo
	 * @date 26/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeImoveisPorGrupoCobranca(Integer idCobrancaGrupo, Integer gerencia, Integer unidade,
			Integer localidade, Integer setorComercial, Integer quadra) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Integer quantidadeImoveis = 0;
		Short indicadorExcluido = ConstantesSistema.INDICADOR_USO_DESATIVO;

		try {
			query = "SELECT count(distinct i.imov_id) as QtdImoveis" + " FROM cadastro.imovel i"
					+ " join cadastro.localidade l on l.loca_id = i.loca_id"
					+ " join cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id" + " join cadastro.quadra q on q.qdra_id = i.qdra_id"
					+ " join micromedicao.rota r on r.rota_id = q.rota_id" + " where r.cbgr_id = :idCobrancaGrupo "
					+ " and i.imov_icexclusao = :indicadorExcluido";

			if (gerencia != null && gerencia.intValue() != -1)
				query += " and l.greg_id = :gerencia";
			if (unidade != null && unidade.intValue() != -1)
				query += " and l.uneg_id = :unidade";
			if (localidade != null && localidade.intValue() != -1)
				query += " and i.loca_id = :localidade";
			if (setorComercial != null && setorComercial.intValue() != -1)
				query += " and sc.stcm_cdsetorcomercial = :setorComercial";
			if (quadra != null && quadra.intValue() != -1)
				query += " and q.qdra_nnquadra = :quadra";

			Query q = session.createSQLQuery(query).addScalar("QtdImoveis", Hibernate.INTEGER)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo).setShort("indicadorExcluido", indicadorExcluido);

			if (gerencia != null && gerencia.intValue() != -1)
				q.setInteger("gerencia", gerencia);
			if (unidade != null && unidade.intValue() != -1)
				q.setInteger("unidade", unidade);
			if (localidade != null && localidade.intValue() != -1)
				q.setInteger("localidade", localidade);
			if (setorComercial != null && setorComercial.intValue() != -1)
				q.setInteger("setorComercial", setorComercial);
			if (quadra != null && quadra.intValue() != -1)
				q.setInteger("quadra", quadra);

			quantidadeImoveis = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return quantidadeImoveis;

	}

	/**
	 * @author Anderson Italo
	 * @date 30/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeImoveisPorComandoEventual(Integer idCobrancaAcaoAtividadeComando, Integer gerencia, Integer unidade,
			Integer localidade, Integer setorComercial, Integer quadra) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Integer quantidadeImoveis = 0;
		Short indicadorExcluido = ConstantesSistema.INDICADOR_USO_DESATIVO;

		try {
			query = "SELECT count(distinct i.imov_id) as QtdImoveis" + " FROM cadastro.imovel i"
					+ " join cadastro.localidade l on l.loca_id = i.loca_id"
					+ " join cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id" + " join cadastro.quadra q on q.qdra_id = i.qdra_id"
					+ " join micromedicao.rota r on r.rota_id = q.rota_id"
					+ " join cobranca.cobranca_ativ_cmd_rota c on c.rota_id = r.rota_id"
					+ " where c.cacm_id = :idCobrancaAcaoAtividadeComando " + " and i.imov_icexclusao = :indicadorExcluido";

			if (gerencia != null && gerencia.intValue() != -1)
				query += " and l.greg_id = :gerencia";
			if (unidade != null && unidade.intValue() != -1)
				query += " and l.uneg_id = :unidade";
			if (localidade != null && localidade.intValue() != -1)
				query += " and i.loca_id = :localidade";
			if (setorComercial != null && setorComercial.intValue() != -1)
				query += " and sc.stcm_cdsetorcomercial = :setorComercial";
			if (quadra != null && quadra.intValue() != -1)
				query += " and q.qdra_nnquadra = :quadra";

			Query q = session.createSQLQuery(query).addScalar("QtdImoveis", Hibernate.INTEGER)
					.setInteger("idCobrancaAcaoAtividadeComando", idCobrancaAcaoAtividadeComando)
					.setShort("indicadorExcluido", indicadorExcluido);

			if (gerencia != null && gerencia.intValue() != -1)
				q.setInteger("gerencia", gerencia);
			if (unidade != null && unidade.intValue() != -1)
				q.setInteger("unidade", unidade);
			if (localidade != null && localidade.intValue() != -1)
				q.setInteger("localidade", localidade);
			if (setorComercial != null && setorComercial.intValue() != -1)
				q.setInteger("setorComercial", setorComercial);
			if (quadra != null && quadra.intValue() != -1)
				q.setInteger("quadra", quadra);

			quantidadeImoveis = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return quantidadeImoveis;

	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * [FS0008]  Verificar validade da data
	 * 
	 * @author Raphael Rossiter
	 * @date 07/01/2010
	 * 
	 * @param idCliente
	 * @param idArrecadacaoForma
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short pesquisarNumeroDiasFloatCartao(Integer idCliente, Integer idArrecadacaoForma) throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT actf.numeroDiaFloat " + "FROM ArrecadadorContratoTarifa actf " + "INNER JOIN actf.arrecadadorContrato arct "
					+ "INNER JOIN arct.arrecadador arrc " + "INNER JOIN arrc.cliente clie " + "INNER JOIN actf.arrecadacaoForma arfm "
					+ "WHERE clie.id = :idCliente AND arfm.id = :idFormaArrecadacao";

			retorno = (Short) session.createQuery(consulta).setInteger("idCliente", idCliente)
					.setInteger("idFormaArrecadacao", idArrecadacaoForma).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * @author Raphael Rossiter
	 * @date 11/01/2010
	 * 
	 * @param idCliente
	 * @param dataVencimento
	 * @return GuiaPagamento
	 * @throws ErroRepositorioException
	 */
	public GuiaPagamento pesquisarGuiaPagamentoCartaoCredito(Integer idCliente, Date dataVencimento) throws ErroRepositorioException {

		GuiaPagamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gpag FROM GuiaPagamento gpag " 
					+ "INNER JOIN FETCH gpag.cliente clie "
					+ "INNER JOIN FETCH gpag.debitoTipo dbtp " 
					+ "INNER JOIN FETCH gpag.localidade loca "
					+ "INNER JOIN FETCH gpag.guiaPagamentoGeral ggeral "
					+ "WHERE clie.id = :idCliente AND gpag.dataVencimento = :dataVencimento";

			retorno = (GuiaPagamento) session.createQuery(consulta).setInteger("idCliente", idCliente)
					.setDate("dataVencimento", dataVencimento).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @param guiaPagamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarGuiaPagamentoCartaoCredito(GuiaPagamento guiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaValorGuiaPagamento;

		try {

			// GUIA DE PAGAMENTO
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set gpag_vldebito = :valorDebito, gpag_tmultimaalteracao = :ultimaAlteracao, "
					+ "usur_id = :usuarioLogado where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento).setInteger("idGuiaPagamento", guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito", guiaPagamento.getValorDebito()).setTimestamp("ultimaAlteracao", new Date())
					.setInteger("usuarioLogado", guiaPagamento.getUsuario().getId().intValue()).executeUpdate();

			// GUIA DE PAGAMENTO ITEM
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamentoItem "
					+ "set gpai_vldebito = :valorDebito, gpai_tmultimaalteracao = :ultimaAlteracao " + "where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento).setInteger("idGuiaPagamento", guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito", guiaPagamento.getValorDebito()).setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

			// GUIA DE PAGAMENTO CATEGORIA
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamentoCategoria "
					+ "set gpcg_vlcategoria = :valorDebito, gpcg_tmultimaalteracao = :ultimaAlteracao "
					+ "where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento).setInteger("idGuiaPagamento", guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito", guiaPagamento.getValorDebito()).setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @return Localidade
	 * @throws ErroRepositorioException
	 */
	public Localidade pesquisarLocalidadeSede() throws ErroRepositorioException {

		Localidade retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT loca " + "FROM Localidade loca WHERE loca.indicadorLocalidadeSede = :indicadorAtivo";

			retorno = (Localidade) session.createQuery(consulta).setShort("indicadorAtivo", ConstantesSistema.INDICADOR_USO_ATIVO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @return DebitoTipo
	 * @throws ErroRepositorioException
	 */
	public DebitoTipo pesquisarDebitoTipoCartaoCredito() throws ErroRepositorioException {

		DebitoTipo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT dbtp " + "FROM DebitoTipo dbtp WHERE dbtp.indicadorDebitoCartaoCredito = :indicadorAtivo";

			retorno = (DebitoTipo) session.createQuery(consulta).setShort("indicadorAtivo", ConstantesSistema.INDICADOR_USO_ATIVO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0004]  Incluir Dados da Confirmação dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 18/01/2010
	 * 
	 * @param idArrecadador
	 * @param dataLancamento
	 * @return AvisoBancario
	 * @throws ErroRepositorioException
	 */
	public AvisoBancario pesquisarAvisoBancario(Integer idArrecadador, Date dataLancamento) throws ErroRepositorioException {

		AvisoBancario retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT avbc " + "FROM AvisoBancario avbc " + "INNER JOIN avbc.arrecadador arrc "
					+ "WHERE arrc.id = :idArrecadador " + "AND avbc.dataLancamento = :dataLancamento";

			retorno = (AvisoBancario) session.createQuery(consulta).setInteger("idArrecadador", idArrecadador)
					.setDate("dataLancamento", dataLancamento).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0005  Calcular Valor da Dedução]
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idArrecadador
	 * @param idArrecadacaoForma
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ArrecadadorContratoTarifa pesquisarArrecadadorContratoTarifa(Integer idArrecadador, Integer idArrecadacaoForma)
			throws ErroRepositorioException {

		ArrecadadorContratoTarifa retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT actf " + "FROM ArrecadadorContratoTarifa actf " + "INNER JOIN FETCH actf.arrecadadorContrato arct "
					+ "INNER JOIN arct.arrecadador arrc " + "INNER JOIN actf.arrecadacaoForma arfm "
					+ "WHERE arrc.id = :idArrecadador AND arfm.id = :idFormaArrecadacao";

			retorno = (ArrecadadorContratoTarifa) session.createQuery(consulta).setInteger("idArrecadador", idArrecadador)
					.setInteger("idFormaArrecadacao", idArrecadacaoForma).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0004]  Incluir Dados da Confirmação dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 28/04/2010
	 * 
	 * @param avisoBancario
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorAvisoBancario(AvisoBancario avisoBancario) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarValorAvisoBancario;

		try {

			atualizarValorAvisoBancario = "update gcom.arrecadacao.aviso.AvisoBancario " + "set avbc_vlrealizado = :valorRealizado, "
					+ "avbc_vlarrecadacaoinformado = :valorArrecadacaoInformado, "
					+ "avbc_vldevolucaocalculado = :valorDevolucaoCalculado, " + "avbc_tmultimaalteracao = :ultimaAlteracao "
					+ "where avbc_id = :idAvisoBancario";

			session.createQuery(atualizarValorAvisoBancario).setInteger("idAvisoBancario", avisoBancario.getId())
					.setBigDecimal("valorRealizado", avisoBancario.getValorRealizado())
					.setBigDecimal("valorArrecadacaoInformado", avisoBancario.getValorArrecadacaoInformado())
					.setBigDecimal("valorDevolucaoCalculado", avisoBancario.getValorDevolucaoCalculado())
					.setTimestamp("ultimaAlteracao", new Date()).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0004]  Incluir Dados da Confirmação dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public AvisoDeducoes pesquisarAvisoDeducoes(Integer idAvisoBancario) throws ErroRepositorioException {

		AvisoDeducoes retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT avdd " + "FROM AvisoDeducoes avdd " + "INNER JOIN avdd.avisoBancario avbc "
					+ "WHERE avbc.id = :idAvisoBancario ";

			retorno = (AvisoDeducoes) session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0004]  Incluir Dados da Confirmação dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idAvisoBancario
	 * @param valorTotalAvisoDeducoes
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorAvisoDeducoes(Integer idAvisoBancario, BigDecimal valorTotalAvisoDeducoes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarValorAvisoDeducoes;

		try {

			atualizarValorAvisoDeducoes = "update gcom.arrecadacao.aviso.AvisoDeducoes "
					+ "set avdd_vldeducao = :valorTotalAvisoDeducoes, " + "avdd_tmultimaalteracao = :ultimaAlteracao "
					+ "where avbc_id = :idAvisoBancario";

			session.createQuery(atualizarValorAvisoDeducoes).setInteger("idAvisoBancario", idAvisoBancario)
					.setBigDecimal("valorTotalAvisoDeducoes", valorTotalAvisoDeducoes).setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	// /////////////////////////////////////////////////////////////
	/**
	 * [UC0349] Emitir Documento de Cobrança  Aviso de Corte
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos do aviso de
	 * corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirDocumentoCobrancaImpressao(Integer idCobrancaDocumento, String linhaTxt, Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma, Integer sequencialImpressao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into cobranca.cobranca_documento_impr values (" + idCobrancaDocumento + "," + "'" + linhaTxt + "',"
					+ idCobrancaAcaoAtividadeComando + "," + idCobrancaAcaoAtividadeCronograma + "," + sequencialImpressao + ","
					+ Util.obterSQLDataAtual() + ", null )";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobrança  Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDocumentoCobrancaImpressao(Integer idCobrancaAcaoAtividadeComando, Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdim.linhaTxt " + "FROM CobrancaDocumentoImpressao cdim ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " INNER JOIN cdim.cobrancaAcaoAtividadeComando cacm " + " WHERE  cacm.id = "
						+ idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " INNER JOIN cdim.cobrancaAcaoAtividadeCronograma caac " + " WHERE  caac.id = "
						+ idCobrancaAcaoAtividadeCronograma;
			}

			consulta = consulta + " order by cdim.sequencialImpressao ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0349] Emitir Documento de Cobrança  Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDocumentoCobrancaImpressao(Integer idCobrancaAcaoAtividadeComando, Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "delete from cobranca.cobranca_documento_impr where ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " cacm_id = " + idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " caac_id = " + idCobrancaAcaoAtividadeCronograma;
			}

			int teste = stmt.executeUpdate(consulta);

			System.out.println("teste " + teste);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobrança  Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDocumentoCobrancaImpressao(Collection<Integer> idsDocumentosCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumentoImpressao " + "WHERE id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * [UC0987] Inserir Faixa de Dias Vencidos para Documentos a Receber
	 * 
	 * Verificar se existe Faixa inicial já cadastrada.
	 * 
	 * @author Hugo Leonardo
	 * @param valorInicialFaixa
	 * @throws ControladorException
	 * @data 22/02/2010
	 * 
	 * @return Boolean
	 * @throws ErroRepositorioException
	 */
	public String verificarExistenciaFaixaInicial(Integer valorInicialFaixa) throws ErroRepositorioException {

		String retorno = "";

		Session session = HibernateUtil.getSession();

		String consulta = "";

		consulta += " select drfx_dsfaixa as cont " + " from cobranca.docs_a_rec_fx_dias_vcdos " + " where (drfx_vlfaixainicio <= "
				+ valorInicialFaixa + " and drfx_vlfaixafim >= " + valorInicialFaixa + " )";
		try {
			retorno = (String) session.createSQLQuery(consulta).addScalar("cont", Hibernate.STRING).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0987] Inserir Faixa de Dias Vencidos para Documentos a Receber
	 * 
	 * Verificar se existe Faixa final já cadastrada.
	 * 
	 * @author Hugo Leonardo
	 * @param valorFinalFaixa
	 * @throws ControladorException
	 * @data 22/02/2010
	 * 
	 * @return Boolean
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaFaixaFinal(Integer valorFinalFaixa) throws ErroRepositorioException {

		int retorno = 0;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		consulta += " select count(drfx_id) as cont " + " from cobranca.docs_a_rec_fx_dias_vcdos " + " where (drfx_vlfaixainicio <= "
				+ valorFinalFaixa + " and drfx_vlfaixafim >= " + valorFinalFaixa + " )";
		try {
			retorno = (Integer) session.createSQLQuery(consulta).addScalar("cont", Hibernate.INTEGER).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC990] Gerar Relatório de Documentos a Receber
	 * 
	 * @author Hugo Amorim
	 * @date 22/02/2010
	 * 
	 */
	public Collection pesquisarRelatorioDocumentosAReceber(FiltroRelatorioDocumentosAReceberHelper helper, String tipoTotalizacao,
			int quantidadeInicio, int quantidadeMaxima) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		SQLQuery query = null;

		Map parameters = new HashMap();

		try {

			consulta += " SELECT " + " dar.catg_id as idCat, " + " cat.catg_dscategoria as dsCat, "
					+ " dar.dotp_id as idDt, " + " dt.dotp_dsdocumentotipo as dsDt, " + " drrs_icsituacaodocumentos as icSit, "
					+ " case drrs_icsituacaodocumentos " + "    when 1 then 'A VENCER' " + "    when 2 then 'VENCIDOS' "
					+ " end as dsSit,  " + " drrs_qtdiasvencidos as faixa, " + " sum(drrs_qtdocumentos) as qtDoc,  "
					+ " sum(drrs_vldocumentos) as vlDoc, " + " sum(drrs_vldocumentossemparcelaatual) as vlDocSemParcAtual ";

			if (tipoTotalizacao.equals("LOCALIDADE")) {//10, 11, 12, 13, 14, 15
				consulta += ", dar.greg_id as idGer, " + " gr.greg_nmregional as dsGer, " + " dar.uneg_id as idUn , "
						+ " un.uneg_nmunidadenegocio as dsUn, " + " dar.loca_id as idLoca, " + " loc.loca_nmlocalidade as dsLoca  ";
			} else if (tipoTotalizacao.equals("UNIDADE")) {//10, 11, 12, 13
				consulta += ", dar.greg_id as idGer, " + " gr.greg_nmregional as dsGer, " + " dar.uneg_id as idUn , "
						+ " un.uneg_nmunidadenegocio as dsUn ";
			} else if (tipoTotalizacao.equals("GERENCIA")) {//10, 11
				consulta += ", dar.greg_id as idGer, " + " gr.greg_nmregional as dsGer ";
			}

			consulta += " FROM financeiro.docs_a_rec_resumo dar "
					+ " INNER JOIN cobranca.documento_tipo dt on dt.dotp_id = dar.dotp_id "
					+ " INNER JOIN cadastro.categoria cat on cat.catg_id = dar.catg_id "
					+ " LEFT JOIN cadastro.categoria_tipo catTipo on catTipo.cgtp_id = cat.cgtp_id "
					+ " INNER JOIN cadastro.gerencia_regional gr on gr.greg_id = dar.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio un on un.uneg_id = dar.uneg_id "
					+ " INNER JOIN cadastro.localidade loc on loc.loca_id = dar.loca_id "
					+ " WHERE drrs_amreferenciarecebimentos = :anoMes and ";

			/**
			 *
			 * 
			 * @author Adriana Muniz
			 * @date 29/03/2012
			 * 
			 *       Quando o usuário solicitar sem guia de pagamento.
			 * */
			if (helper.getIndicadorGuiaPagamento() != null && helper.getIndicadorGuiaPagamento().equals("2")) {
				consulta += " dar.dotp_id <> 7 and ";
			}

			parameters.put("anoMes", helper.getMesAno());

			if (helper.getIdCategoriaTipo() != null && !helper.getIdCategoriaTipo().equals("-1")) {
				consulta += " catTipo.cgtp_id in(:idCategoriaTipo) and ";
				parameters.put("idCategoriaTipo", helper.getIdCategoriaTipo());

			}

			if (helper.getIdsCategoria() != null && helper.getIdsCategoria().length != 0) {

				Collection idsCategorias = new ArrayList();
				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					String idCategoria = helper.getIdsCategoria()[i];
					if (!idCategoria.equals("-1")) {
						idsCategorias.add(new Integer(idCategoria));
					}
				}
				if (idsCategorias.size() > 0) {
					consulta += " dar.catg_id in(:idsCategorias) and ";
					parameters.put("idsCategorias", idsCategorias);
				}
			}

			if (helper.getIdsPerfilImovel() != null && helper.getIdsPerfilImovel().length != 0) {

				Collection idsPerfis = new ArrayList();
				for (int i = 0; i < helper.getIdsPerfilImovel().length; i++) {
					String idPerfil = helper.getIdsPerfilImovel()[i];
					if (!idPerfil.equals("-1")) {
						idsPerfis.add(new Integer(idPerfil));
					}
				}
				if (idsPerfis.size() > 0) {
					consulta += " dar.iper_id in(:idsPerfis) and ";
					parameters.put("idsPerfis", idsPerfis);
				}
			}

			if (helper.getIdsEsferaPoder() != null && helper.getIdsEsferaPoder().length != 0) {

				Collection idsEsferas = new ArrayList();
				for (int i = 0; i < helper.getIdsEsferaPoder().length; i++) {
					String idsEsfera = helper.getIdsEsferaPoder()[i];
					if (!idsEsfera.equals("-1")) {
						idsEsferas.add(new Integer(idsEsfera));
					}
				}
				if (idsEsferas.size() > 0) {
					consulta += " dar.epod_id in(:idsEsferas) and ";
					parameters.put("idsEsferas", idsEsferas);
				}
			}

			if (helper.getIdGerencia() != null && !helper.getIdGerencia().equals("-1")) {
				consulta += " dar.greg_id = :idGerencia and ";
				parameters.put("idGerencia", helper.getIdGerencia());
			}
			if (helper.getIdUnidade() != null && !helper.getIdUnidade().equals("-1")) {
				consulta += " dar.uneg_id = :idUnidade and ";
				parameters.put("idUnidade", helper.getIdUnidade());
			}
			if (helper.getIdLocalidade() != null && !helper.getIdLocalidade().equals("")) {
				consulta += " dar.loca_id = :idLocalidade and ";
				parameters.put("idLocalidade", helper.getIdLocalidade());
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			// INCLUI FAIXAS
			consulta += " and (drrs_qtdiasvencidos = 0 or ";
			for (Iterator iterator = helper.getColecaoFaixas().iterator(); iterator.hasNext();) {
				FaixaHelper faixaHelper = (FaixaHelper) iterator.next();

				consulta += " drrs_qtdiasvencidos between " + faixaHelper.getValorInicial() + " and " + faixaHelper.getValorFinal()
						+ " or ";

			}
			consulta = Util.removerUltimosCaracteres(consulta, 3);
			consulta += ")";
			// FIM INCLUSÃO DAS FAIXAS

			// AGRUPAMENTO POR TIPO DE TOTALIZAÇÃO
			String orderBy = " order by";
			String groupBy = " group by";

			if (tipoTotalizacao.equals("LOCALIDADE")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,dar.uneg_id,un.uneg_nmunidadenegocio,dar.loca_id,loc.loca_nmlocalidade,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,dar.uneg_id,dar.loca_id,drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id   ";
			} else if (tipoTotalizacao.equals("UNIDADE")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,dar.uneg_id,un.uneg_nmunidadenegocio,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,dar.uneg_id,drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			} else if (tipoTotalizacao.equals("GERENCIA")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,drrs_icsituacaodocumentos ,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			} else if (tipoTotalizacao.equals("ESTADO")) {
				groupBy += " drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			}
			// FIM DO AGRUPAMENTO

			consulta = consulta + groupBy + orderBy;

			query = session.createSQLQuery(consulta)
					.addScalar("idCat", Hibernate.INTEGER)
					.addScalar("dsCat", Hibernate.STRING)
					.addScalar("idDt", Hibernate.INTEGER)
					.addScalar("dsDt", Hibernate.STRING)
					.addScalar("icSit", Hibernate.INTEGER)
					.addScalar("dsSit", Hibernate.STRING)
					.addScalar("faixa", Hibernate.STRING)
					.addScalar("qtDoc", Hibernate.INTEGER)
					.addScalar("vlDoc", Hibernate.BIG_DECIMAL)
					.addScalar("vlDocSemParcAtual", Hibernate.BIG_DECIMAL);
			
			if (!tipoTotalizacao.equals("ESTADO")){
				query.addScalar("idGer", Hibernate.INTEGER)
				.addScalar("dsGer", Hibernate.STRING);
			}
			
			if (tipoTotalizacao.equals("LOCALIDADE")) {
				query.addScalar("idUn", Hibernate.INTEGER)
					.addScalar("dsUn", Hibernate.STRING)
					.addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("dsLoca", Hibernate.STRING);
			} else if (tipoTotalizacao.equals("UNIDADE")) {
				query.addScalar("idUn", Hibernate.INTEGER)
					.addScalar("dsUn", Hibernate.STRING);
			}

			// ITERA OS PARAMETROS E COLOCA
			// OS MESMOS NA QUERY
			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			// REALIZA A PESQUISA
			retorno = query.setFirstResult(quantidadeInicio).setMaxResults(quantidadeMaxima).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC990] Count Relatório de Documentos a Receber
	 * 
	 * @author Hugo Amorim
	 * @date 22/02/2010
	 * 
	 */
	public Integer countRelatorioDocumentosAReceber(FiltroRelatorioDocumentosAReceberHelper helper) throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		Query query = null;

		Map parameters = new HashMap();

		try {

			consulta += " SELECT " + " count(*) as contador " + " FROM financeiro.docs_a_rec_resumo dar "
					+ " INNER JOIN cobranca.documento_tipo dt on dt.dotp_id = dar.dotp_id "
					+ " INNER JOIN cadastro.categoria cat on cat.catg_id = dar.catg_id "
					+ " LEFT JOIN cadastro.categoria_tipo catTipo on catTipo.cgtp_id = cat.cgtp_id "
					+ " INNER JOIN cadastro.gerencia_regional gr on gr.greg_id = dar.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio un on un.uneg_id = dar.uneg_id "
					+ " INNER JOIN cadastro.localidade loc on loc.loca_id = dar.loca_id "
					+ " WHERE drrs_amreferenciarecebimentos = :anoMes and ";

			parameters.put("anoMes", helper.getMesAno());

			if (helper.getIdCategoriaTipo() != null && !helper.getIdCategoriaTipo().equals("-1")) {
				consulta += " catTipo.cgtp_id in(:idCategoriaTipo) and ";
				parameters.put("idCategoriaTipo", helper.getIdCategoriaTipo());

			}

			if (helper.getIdsCategoria() != null && helper.getIdsCategoria().length != 0) {

				Collection idsCategorias = new ArrayList();
				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					String idCategoria = helper.getIdsCategoria()[i];
					if (!idCategoria.equals("-1")) {
						idsCategorias.add(new Integer(idCategoria));
					}
				}
				if (idsCategorias.size() > 0) {
					consulta += " dar.catg_id in(:idsCategorias) and ";
					parameters.put("idsCategorias", idsCategorias);
				}
			}

			if (helper.getIdsPerfilImovel() != null && helper.getIdsPerfilImovel().length != 0) {

				Collection idsPerfis = new ArrayList();
				for (int i = 0; i < helper.getIdsPerfilImovel().length; i++) {
					String idPerfil = helper.getIdsPerfilImovel()[i];
					if (!idPerfil.equals("-1")) {
						idsPerfis.add(new Integer(idPerfil));
					}
				}
				if (idsPerfis.size() > 0) {
					consulta += " dar.iper_id in(:idsPerfis) and ";
					parameters.put("idsPerfis", idsPerfis);
				}
			}

			if (helper.getIdsEsferaPoder() != null && helper.getIdsEsferaPoder().length != 0) {

				Collection idsEsferas = new ArrayList();
				for (int i = 0; i < helper.getIdsEsferaPoder().length; i++) {
					String idsEsfera = helper.getIdsEsferaPoder()[i];
					if (!idsEsfera.equals("-1")) {
						idsEsferas.add(new Integer(idsEsfera));
					}
				}
				if (idsEsferas.size() > 0) {
					consulta += " dar.epod_id in(:idsEsferas) and ";
					parameters.put("idsEsferas", idsEsferas);
				}
			}

			if (helper.getIdGerencia() != null && !helper.getIdGerencia().equals("-1")) {
				consulta += " dar.greg_id = :idGerencia and ";
				parameters.put("idGerencia", helper.getIdGerencia());
			}
			if (helper.getIdUnidade() != null && !helper.getIdUnidade().equals("-1")) {
				consulta += " dar.uneg_id = :idUnidade and ";
				parameters.put("idUnidade", helper.getIdUnidade());
			}
			if (helper.getIdLocalidade() != null && !helper.getIdLocalidade().equals("")) {
				consulta += " dar.loca_id = :idLocalidade and ";
				parameters.put("idLocalidade", helper.getIdLocalidade());
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			// INCLUI FAIXAS
			consulta += " and (drrs_qtdiasvencidos = 0 or ";
			for (Iterator iterator = helper.getColecaoFaixas().iterator(); iterator.hasNext();) {
				FaixaHelper faixaHelper = (FaixaHelper) iterator.next();

				consulta += " drrs_qtdiasvencidos between " + faixaHelper.getValorInicial() + " and " + faixaHelper.getValorFinal()
						+ " or ";

			}
			consulta = Util.removerUltimosCaracteres(consulta, 3);
			consulta += ")";
			// FIM INCLUSÃO DAS FAIXAS

			query = session.createSQLQuery(consulta).addScalar("contador", Hibernate.INTEGER);

			// ITERA OS PARAMETROS E COLOCA
			// OS MESMOS NA QUERY
			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			// REALIZA A PESQUISA
			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// ////////////////////////////////////////////////////////////////////
	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarQuantidadeCobrancaDocumento(Integer idCobrancaDocumentoControleGeracao, Integer quantidadeCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = ? + (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumento);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(3, Util.getSQLTimesTemp(new Date()));
			st.setInt(4, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();
			session.flush();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSomar(Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumento, Integer quantidadeCobrancaDocumentoItem, BigDecimal valorTotalCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = ? + (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_qtcobrancadocumentoitem = ? + (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_vltotaldoccob = ? + (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumento);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setInt(3, quantidadeCobrancaDocumentoItem);
			st.setInt(4, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(5, valorTotalCobrancaDocumento);
			st.setInt(6, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(7, Util.getSQLTimesTemp(new Date()));
			st.setInt(8, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public Integer pesquisarQuantidadeCobrancaDocumento(Integer idCobrancaDocumentoControleGeracao) throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {

			String hql = " select cdcg.quantidadeCobrancaDocumento "
					+ " from gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao cdcg "
					+ " where cdcg.id = :idCobrancaDocumentoControleGeracao ";

			retorno = (Integer) session.createQuery(hql)
					.setInteger("idCobrancaDocumentoControleGeracao", idCobrancaDocumentoControleGeracao).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSomar(Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumentoItem, BigDecimal valorTotalCobrancaDocumento) throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumentoitem = ? + (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_vltotaldoccob = ? + (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumentoItem);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(3, valorTotalCobrancaDocumento);
			st.setInt(4, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(5, Util.getSQLTimesTemp(new Date()));
			st.setInt(6, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public CobrancaDocumentoControleGeracao pesquisarCobrancaDocumentoControleGeracao(Integer idCobrancaDocumentoControleGeracao)
			throws ErroRepositorioException {

		CobrancaDocumentoControleGeracao retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String hql = " select cdcg " + " from gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao cdcg "
					+ " where cdcg.id = :idCobrancaDocumentoControleGeracao ";

			retorno = (CobrancaDocumentoControleGeracao) session.createQuery(hql)
					.setInteger("idCobrancaDocumentoControleGeracao", idCobrancaDocumentoControleGeracao).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 19/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSubtrair(Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumento, Integer quantidadeCobrancaDocumentoItem, BigDecimal valorTotalCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_qtcobrancadocumentoitem = (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_vltotaldoccob = (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, idCobrancaDocumentoControleGeracao);
			st.setInt(2, quantidadeCobrancaDocumento);
			st.setInt(3, idCobrancaDocumentoControleGeracao);
			st.setInt(4, quantidadeCobrancaDocumentoItem);
			st.setInt(5, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(6, valorTotalCobrancaDocumento);
			st.setTimestamp(7, Util.getSQLTimesTemp(new Date()));
			st.setInt(8, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 19/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracao(Integer quantidadeCobrancaDocumento, Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento, Integer idCobrancaAcaoAtividadeComando, Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set " + " cdcg_qtcobrancadocumento = ?,"
					+ " cdcg_qtcobrancadocumentoitem = ?," + " cdcg_vltotaldoccob = ?," + " cdcg_tmultimaalteracao =  ?" + " where ";

			if (idCobrancaAcaoAtividadeComando != null) {
				consulta = consulta + " cacm_id = ? ";

				st = jdbcCon.prepareStatement(consulta);
				st.setInt(1, quantidadeCobrancaDocumento);
				st.setInt(2, quantidadeCobrancaDocumentoItem);
				st.setBigDecimal(3, valorTotalCobrancaDocumento);
				st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
				st.setInt(5, idCobrancaAcaoAtividadeComando);

			} else if (idCobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta + " caac_id = ? ";

				st = jdbcCon.prepareStatement(consulta);
				st.setInt(1, quantidadeCobrancaDocumento);
				st.setInt(2, quantidadeCobrancaDocumentoItem);
				st.setBigDecimal(3, valorTotalCobrancaDocumento);
				st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
				st.setInt(5, idCobrancaAcaoAtividadeCronograma);
			}

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Vivianne Sousa
	 * @date 29/04/2010
	 */
	public Collection pesquisarImovelCobrancaSituacaoPorImovel(Integer idImovel) throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		Session session = HibernateUtil.getSession();

		try {
			String hql = " select ics" + " from gcom.cadastro.imovel.ImovelCobrancaSituacao as ics"
					+ " inner join fetch ics.cobrancaSituacao as cbst " + " where ics.imovel.id = :idImovel "
					+ " and ics.dataRetiradaCobranca is null " + " order by ics.dataImplantacaoCobranca desc ";

			retorno = (List) session.createQuery(hql).setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 03/05/2010
	 */
	public Collection pesquisarDadosImovelCobrancaSituacaoPorImovel(Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String hql = " select cbst.descricao, ics.anoMesReferenciaInicio, "
					+ " ics.anoMesReferenciaFinal, ics.dataImplantacaoCobranca, " + " ics.dataRetiradaCobranca , ics.cliente.id  "
					+ " ,escritorio.nome, advogado.nome " + " from gcom.cadastro.imovel.ImovelCobrancaSituacao as ics"
					+ " inner join ics.cobrancaSituacao as cbst " + " left join ics.escritorio as escritorio "
					+ " left join ics.advogado as advogado " + " where ics.imovel.id = :idImovel "
					+ " order by ics.dataImplantacaoCobranca desc ";

			retorno = session.createQuery(hql).setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Atualiza valores do Documento de Cobrança de cartas.
	 * 
	 * @author Hugo Amorim
	 * @data 29/04/2010
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarValoresDocumentoCobrancaCartas(Integer id, BigDecimal descontoTotalPagamentoAVista,
			BigDecimal valorTotalImpostosConta) throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update cobranca.cobranca_documento set " + " cbdo_vldocumento = ? ," + " cbdo_vldesconto = ? ,"
					+ " cbdo_tmultimaalteracao =  " + new Date() + " where cbdo_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setBigDecimal(1, descontoTotalPagamentoAVista);
			st.setBigDecimal(2, valorTotalImpostosConta);
			st.setInt(3, id);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC????] Relatorio Comando Documento Cobranca Retorna a ação de cobrança
	 * para exibição de parametros do relatório
	 * 
	 * @author Anderson Italo
	 * @data 04/05/2010
	 */
	public CobrancaAcao pesquisarAcaoCobrancaParaRelatorio(Integer cobrancaAcaoAtividadeComando, Integer cobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		CobrancaAcao retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cobrancaDocumento.cobrancaAcao " + "FROM CobrancaDocumento cobrancaDocumento ";

			if (cobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta + "WHERE cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id =  " + cobrancaAcaoAtividadeCronograma
						+ " ";
			} else if (cobrancaAcaoAtividadeComando != null) {
				consulta = consulta + "WHERE cobrancaDocumento.cobrancaAcaoAtividadeComando.id = " + cobrancaAcaoAtividadeComando + " ";
			}

			retorno = (CobrancaAcao) session.createQuery(consulta).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Parcelamentos por Entrada Não Paga Author: Arthur Carvalho
	 * Paiva Data: 17/05/2010
	 * 
	 * Obtem os parcelamentos de débitos efetuados que estejam com situação
	 * normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarTodosParcelamentosSituacaoNormal(String parcelamentoSituacao) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct parc.id, parc.parcelamento, imov.id  " + "FROM DebitoACobrar dbac "
					+ "INNER JOIN dbac.parcelamento parc " + "INNER JOIN parc.imovel imov "
					+ "WHERE parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND (parc.valorEntrada IS NOT NULL AND parc.valorEntrada > 0) " + "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta).setInteger("parcelamentoSituacao", new Integer(parcelamentoSituacao))
					.setInteger("normal", DebitoCreditoSituacao.NORMAL).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0998] Gerar Relação de Parcelamento - Visão Cartão de Crédito
	 * 
	 * Bean que preencherá o relatorio
	 * 
	 * @author Hugo Amorim
	 * @date 11/06/2010
	 * 
	 */
	public Collection<Object[]> filtrarRelacaoParcelamentoCartaoCredito(FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		SQLQuery query = null;
		String consulta = null;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados().isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( loca.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id, \n  muni.muni_nmmunicipio ";
			orderBy += " muni.muni_nmmunicipio, ";
		}

		try {

			consulta = "select " + " distinct \n" + " parc.parc_id, \n" + " loca.loca_id, \n" + " loca.loca_nmlocalidade, \n"
					+ " geRe.greg_id, \n" + " geRe.greg_nmregional, \n" + " clie.clie_nmcliente, \n" + " parc.imov_id, \n"
					+ " parc.parc_nnprestacoes * parc.parc_vlprestacao as debitoParcelado, \n"
					+ " parc.parc_vlprestacao as valorParcela, \n" + " parc.parc_tmultimaalteracao as dataParcelamento, \n"
					+ " parc.parc_nnprestacoes as qtdParcelas, \n" + " ar.clie_id as clienteArrecadador, \n"
					+ " u.usur_nmusuario as nomeUsuarioConfirmacao, \n" + " pcc.pacc_dtconfirmacao as dtConfirmacao, \n"
					+ " pacc_dtconfirmadooperadora as dtConfirmadooperadora, \n" + " pacc_vlconfirmadooperadora as valorConfirmado \n"
					+ selectMunicipio + " from \n" + "     cobranca.parcelamento parc \n"
					+ "     inner join cadastro.localidade as loca on ( loca.loca_id = parc.loca_id ) \n" + joinMunicipio
					+ "     inner join cadastro.gerencia_regional as geRe on ( geRe.greg_id = loca.greg_id ) \n"
					+ "     inner join cadastro.unidade_negocio as unNe on ( loca.uneg_id = unNe.uneg_id ) \n"
					+ "     inner join cadastro.cliente as clie on ( clie.clie_id = parc.clie_id ) \n"
					+ "     inner join cadastro.imovel as imo on ( imo.imov_id = parc.imov_id ) \n"
					+ "     inner join cadastro.quadra as qua on ( qua.qdra_id = imo.qdra_id ) \n"
					+ "     inner join cobranca.parcel_pagto_cartao_cred as pcc on (pcc.parc_id = parc.parc_id) \n"
					+ "     inner join arrecadacao.arrecadador ar on (ar.arrc_id  = pcc.arrc_id) \n"
					+ "     inner join seguranca.usuario u on (u.usur_id = pcc.usur_idconfirmacao) \n"
					+ "     left join cadastro.unidade_organizacional unid ON u.unid_id = unid.unid_id \n" + " where \n"
					+ "  parc.pcst_id = :parcelamentoSituacao";

			// Verificamos quais os filtros informados
			if (filtrarRelacaoParcelamento.getIdGerencia() != null && !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				consulta += " and geRe.greg_id = :idGerenciaRegional \n";
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null && !filtrarRelacaoParcelamento.getIdUnidadeNegocio().equals("")) {
				consulta += " and unNe.uneg_id = :idUnidadeNegocio \n";
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null && !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				consulta += " and loca.loca_cdelo = :idElo \n";
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and parc.loca_id = :idLocalidade ";
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and loca.muni_idprincipal IN ( :idMunicipios )";
				if (!temLocalidade) {
					consulta += " and parc.loca_id = loca.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getCodigoSetorComercial() != null) {
				consulta += " and parc.parc_cdsetorcomercial = :cdSetorComercial \n";
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and qua.qdra_nnquadra = :numeroQuadra \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel().equals("")) {
				consulta += " and parc.usur_id = :idUsuario \n";
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				consulta += " and parc.parc_tmparcelamento between :dataInicial and :dataFinal \n";
			}

			if ((filtrarRelacaoParcelamento.getDataConfirmacaoInicial() != null && !filtrarRelacaoParcelamento.getDataConfirmacaoInicial()
					.equals(""))
					&& (filtrarRelacaoParcelamento.getDataConfirmacaoFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoFinal().equals(""))) {
				consulta += " and pcc.pacc_dtconfirmacao between :dataConfirmacaoIncial and :dataConfirmacaoFinal \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioConfirmacao() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioConfirmacao().equals("")) {
				consulta += " and pcc.usur_idconfirmacao = :idUsuarioConfirmacao \n";
			}

			if (filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora() != null
					&& !filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora().equals("")) {
				consulta += " and pcc.pacc_icconfirmadooperadora = :indicadorConfirmacaoOperadora \n";
			}

			if ((filtrarRelacaoParcelamento.getDataConfirmacaoOperadoraInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataConfirmacaoOperadoraFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal().equals(""))) {
				consulta += " and pcc.pacc_dtconfirmadooperadora between :dataConfirmacaoOperadoraIncial and :dataConfirmacaoOperadoraFinal \n";
			}

			// Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional().equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional \n";

			}

			consulta += orderBy + "  loca_id, \n" + "  greg_id, \n" + "  pcc.pacc_dtconfirmacao, \n" + "  clie_nmcliente \n";

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados())) {
				query = session.createSQLQuery(consulta).addScalar("parc_id", Hibernate.INTEGER).addScalar("loca_id", Hibernate.STRING)
						.addScalar("loca_nmlocalidade", Hibernate.STRING).addScalar("greg_id", Hibernate.STRING)
						.addScalar("greg_nmregional", Hibernate.STRING).addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER).addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL).addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.STRING).addScalar("clienteArrecadador", Hibernate.INTEGER)
						.addScalar("nomeUsuarioConfirmacao", Hibernate.STRING).addScalar("dtConfirmacao", Hibernate.DATE)
						.addScalar("dtConfirmadooperadora", Hibernate.DATE).addScalar("valorConfirmado", Hibernate.BIG_DECIMAL)
						.addScalar("muni_id", Hibernate.INTEGER).addScalar("muni_nmmunicipio", Hibernate.STRING);
			} else {
				query = session.createSQLQuery(consulta).addScalar("parc_id", Hibernate.INTEGER).addScalar("loca_id", Hibernate.STRING)
						.addScalar("loca_nmlocalidade", Hibernate.STRING).addScalar("greg_id", Hibernate.STRING)
						.addScalar("greg_nmregional", Hibernate.STRING).addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER).addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL).addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.STRING).addScalar("clienteArrecadador", Hibernate.INTEGER)
						.addScalar("nomeUsuarioConfirmacao", Hibernate.STRING).addScalar("dtConfirmacao", Hibernate.DATE)
						.addScalar("dtConfirmadooperadora", Hibernate.DATE).addScalar("valorConfirmado", Hibernate.BIG_DECIMAL);
			}
			query.setInteger("parcelamentoSituacao", ParcelamentoSituacao.NORMAL);

			// Adicionamos os parametros necessários
			if (filtrarRelacaoParcelamento.getIdGerencia() != null && !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				query.setInteger("idGerenciaRegional", filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null && !filtrarRelacaoParcelamento.getIdUnidadeNegocio().equals("")) {
				query.setInteger("idUnidadeNegocio", filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null && !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null && !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				query.setInteger("idLocalidade", filtrarRelacaoParcelamento.getParcelamento().getLocalidade().getId());
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados().isEmpty()) {
				query.setParameterList("idMunicipios", filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getCodigoSetorComercial() != null) {
				query.setInteger("cdSetorComercial", filtrarRelacaoParcelamento.getParcelamento().getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				query.setInteger("numeroQuadra", filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra());
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				query.setTimestamp("dataInicial", filtrarRelacaoParcelamento.getDataParcelamentoInicial());
				query.setTimestamp("dataFinal", filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if ((filtrarRelacaoParcelamento.getDataConfirmacaoInicial() != null && !filtrarRelacaoParcelamento.getDataConfirmacaoInicial()
					.equals(""))
					&& (filtrarRelacaoParcelamento.getDataConfirmacaoFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoFinal().equals(""))) {
				query.setTimestamp("dataConfirmacaoIncial", filtrarRelacaoParcelamento.getDataConfirmacaoInicial());
				query.setTimestamp("dataConfirmacaoFinal", filtrarRelacaoParcelamento.getDataConfirmacaoFinal());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel().equals("")) {
				query.setInteger("idUsuario", filtrarRelacaoParcelamento.getIdUsuarioResponsavel());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioConfirmacao() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioConfirmacao().equals("")) {
				query.setInteger("idUsuarioConfirmacao", filtrarRelacaoParcelamento.getIdUsuarioConfirmacao());
			}

			if (filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora() != null
					&& !filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora().equals("")) {
				query.setShort("indicadorConfirmacaoOperadora", filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora());
			}

			if ((filtrarRelacaoParcelamento.getDataConfirmacaoOperadoraInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataConfirmacaoOperadoraFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal().equals(""))) {
				query.setTimestamp("dataConfirmacaoOperadoraIncial", filtrarRelacaoParcelamento.getDataConfirmacaoOperadoraInicial());
				query.setTimestamp("dataConfirmacaoOperadoraFinal", filtrarRelacaoParcelamento.getDataConfirmacaoOperadoraFinal());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional().equals("")) {

				query.setInteger("idUnidadeOrganizacional", filtrarRelacaoParcelamento.getIdUnidadeOrganizacional());
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC1038] Prescrever Débitos de Imóveis
	 * 
	 * @author Hugo Leonardo
	 * @date 07/07/2010
	 * 
	 * @param idFuncionalidadeIniciada
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public void prescreverDebitosDeImoveis(Integer anoMesFaturamento, String dataFormatada, Integer usuario)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {

			// declara o tipo de conexao
			Connection jdbcCon = session.connection();
			/**
			 * Alterações para colocar em funcionamento processo
			 * de prescrição de contas
			 * 
			 * @author Wellington Rocha
			 * @date 28/12/2011
			 */
			// Atualiza Contas

			System.out.println("************Iniciando Processo de Prescrição de Débitos com data inferior a " + dataFormatada+ "****************");
			
			update = " update faturamento.conta c " 
					+ " set 	dcst_idatual = " + DebitoCreditoSituacao.DEBITO_PRESCRITO + ","
					+ "         usur_id = " + usuario.intValue() + ", " 
					+ " 		dcst_idanterior = NULL, " 
					+ " 		cnta_dtcancelamento = now(), "
					+ " 		cmcn_id = " + ContaMotivoCancelamento.DEBITO_PRESCRITO + "," 
					+ "         cnta_amreferenciacontabil = " + anoMesFaturamento.intValue() + ", " 
					+ "         cnta_tmultimaalteracao = now() "
					+ " where c.cnta_dtvencimentoconta < '" + dataFormatada + "'" 
					+ " and   c.cnta_amreferenciacontabil < " + anoMesFaturamento.intValue()
					+ " and   c.dcst_idatual in ( " + DebitoCreditoSituacao.NORMAL + ", " + DebitoCreditoSituacao.RETIFICADA + ")"
					+ " and not exists (select cnta_id from arrecadacao.pagamento as pgmt where c.cnta_id = pgmt.cnta_id ) ";

			st = jdbcCon.prepareStatement(update);

			// executa o update
			st.executeUpdate();

			// erro no hibernate
		} catch (SQLException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	public void prescreverDebitosDeImoveisContasInlcuidas(Integer anoMesFaturamento, String dataFormatada, Integer usuario)
			throws ErroRepositorioException {

		String updateContasIncluidas;
		Session session = HibernateUtil.getSession();

		PreparedStatement stContasIncluidas = null;

		try {

			// declara o tipo de conexao
			System.out.println("****Iniciando Processo de Prescrição de Débitos de Contas Incluídas com data inferior a " + dataFormatada
					+ "***");
			Connection jdbcCon = session.connection();
			updateContasIncluidas = " update faturamento.conta c "
					+ " set 	dcst_idatual = " + DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS 
					+ ", usur_id = " + usuario.intValue() 
					+ ", dcst_idanterior = NULL"
					+ ", cnta_dtcancelamento = now()"
					+ ", cmcn_id = " + ContaMotivoCancelamento.DEBITO_PRESCRITO + "," + "       cnta_amreferenciacontabil = " + anoMesFaturamento.intValue()
					+ ", cnta_tmultimaalteracao = now() "
					+ " where c.cnta_dtvencimentoconta < '" + dataFormatada + "'"
					+ " and   c.cnta_amreferenciacontabil < " + anoMesFaturamento.intValue() 
					+ " and   c.dcst_idatual = "+ DebitoCreditoSituacao.INCLUIDA
					+ " and not exists (select cnta_id from arrecadacao.pagamento as pgmt where c.cnta_id = pgmt.cnta_id ) ";

			stContasIncluidas = jdbcCon.prepareStatement(updateContasIncluidas);
			stContasIncluidas.executeUpdate();

			// erro no hibernate
		} catch (SQLException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != stContasIncluidas)
				try {
					stContasIncluidas.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * [UC1038] Prescrever Débitos de Imóveis
	 * 
	 * @author Hugo Leonardo
	 * @date 07/07/2010
	 * 
	 * @param idFuncionalidadeIniciada
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection obterCobrancaSituacaoParaPrescreverDebitos() throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = " select cosi.id " + " from gcom.cobranca.CobrancaSituacao as cosi "
					+ " where cosi.indicadorPrescricaoImoveisParticulares = 2 ";

			retorno = (Collection) session.createQuery(consulta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC1038] Prescrever Débitos de Imóveis Pesquisa imoveis para execução do
	 * batch
	 * 
	 * @author Hugo Leonardo
	 * @date 19/07/2010
	 */
	public Collection obterContasPrescreverDebitosDeImoveis(Integer idLocalidade, Integer anoMesFaturamento, String idsCobrancaSituacao,
			int numeroIndice, int quantidadeRegistros) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = " SELECT  c.cnta_id as idConta" + " FROM faturamento.conta c " + " WHERE loca_id = " + idLocalidade + " AND ("
					+ anoMesFaturamento + " - c.cnta_amreferenciaconta) > 1000" + " AND c.cnta_amreferenciacontabil < " + anoMesFaturamento
					+ " AND dcst_idatual in ( 0,1,2 )" + " AND NOT EXISTS ( " + " 	SELECT cnta_id "
					+ "  	FROM faturamento.conta_categoria g " + "  	WHERE c.cnta_id = g.cnta_id " + " 	AND catg_id = 4 )"
					+ " AND NOT EXISTS ( " + "  	SELECT ics.imov_id " + " 	FROM cadastro.imovel_cobranca_situacao ics "
					+ " 	WHERE c.imov_id = ics.imov_id " + " 	AND iscb_dtretiradacobranca is null " + " 	AND cbst_id in ( "
					+ idsCobrancaSituacao + ") )";

			retorno = (Collection) session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER)
					.setMaxResults(quantidadeRegistros).setFirstResult(numeroIndice).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0244] Manter Comando Ação de Cobrança
	 * 
	 * @author Hugo Amorim
	 * @created 14/07/2010
	 * 
	 * @exception ErroRepositorioException
	 * 
	 */
	public void removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao(Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao;

		try {
			removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao = "delete CobrancaAcaoAtividadeComandoFiscalizacaoSituacao "
					+ "where cobrancaAcaoAtividadeComando = :idComando ";

			session.createQuery(removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao).setInteger("idComando", idComando).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Obtem os percentuais de desconto por tempo de inatividade a vista
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 20/07/2010
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcDesctoInativVista obterPercentualDescontoInatividadeAVista(Integer idPerfilParc, int qtdeMeses)
			throws ErroRepositorioException {

		ParcDesctoInativVista retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pdin " + "FROM ParcDesctoInativVista pdin " + "WHERE pdin.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND pdin.quantidadeMaximaMesesInatividade IN (" + "SELECT max(p.quantidadeMaximaMesesInatividade)"
					+ "FROM ParcelamentoDescontoInatividade p " + "WHERE p.quantidadeMaximaMesesInatividade <= :qtdeMeses)";

			retorno = (ParcDesctoInativVista) session.createQuery(consulta).setInteger("idPerfilParc", idPerfilParc.intValue())
					.setInteger("qtdeMeses", qtdeMeses).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * Atualizar total de documentos, itens e valores realizados nos comandos de
	 * acao de cobranca
	 * 
	 * Data: 19/07/2010
	 * 
	 * @author Arthur Carvalho
	 * 
	 * @param idCACM
	 *            Identificador de CobrancaAcaoAtividadeComando
	 * @return Array de objetos com valores de 0 - quantidade de itens cobrados
	 *         1 - valor total dos documentos 2 - quantidade de documentos
	 */
	public Object[] calcularTotaisComandoAcaoCobranca(Integer idCACM) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Object[] retorno = new Object[3];

		try {

			Date dataAtual = new Date();

			// usou-se a condicao ultimaAlteracao > xxxxxx para melhorar o tempo
			// da query
			String consulta = "SELECT count(cdi.id) FROM CobrancaDocumentoItem cdi where " + "cdi.ultimaAlteracao > :dataGeracaoItem "
					+ " and cdi.cobrancaDocumento.id in "
					+ "(select cd.id from CobrancaDocumento cd where cd.cobrancaAcaoAtividadeComando.id = :idCACM) ";

			// quantidade de itens cobrados
			retorno[0] = (Integer) session.createQuery(consulta).setInteger("idCACM", idCACM)
					.setDate("dataGeracaoItem", Util.subtrairNumeroDiasDeUmaData(dataAtual, 2)).uniqueResult();

			consulta = "SELECT sum(cd.valorDocumento) FROM CobrancaDocumento cd " + "where cd.cobrancaAcaoAtividadeComando.id = :idCACM ";

			// valor total dos documentos
			retorno[1] = (BigDecimal) session.createQuery(consulta).setInteger("idCACM", idCACM).uniqueResult();

			consulta = "SELECT count(cd.id) FROM CobrancaDocumento cd " + "where cd.cobrancaAcaoAtividadeComando.id = :idCACM ";

			// quantidade de documentos
			retorno[2] = (Integer) session.createQuery(consulta).setInteger("idCACM", idCACM).uniqueResult();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * atualiza a forma da emissão do documento de cobrança
	 * 
	 * @author Sávio Luiz
	 * @date 12/08/2010
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarFormaEmissaoCobrancaDocumento(Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String consulta = "update gcom.cobranca.CobrancaDocumento " + "set demf_id = :formaEmissao , "
					+ "cbdo_tmultimaalteracao = :dataAtual " + "where cbdo_id = :idCobrancaDocumento ";

			session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setInteger("formaEmissao", DocumentoEmissaoForma.IMPRESSAO_SIMULTANEA).setDate("dataAtual", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);

		}
	}

	/**
	 * Pesquisa Documentos de cobranças validos para imovel para determinado
	 * tipo de documento
	 * 
	 * @author Hugo Amorim
	 * @date 09/09/2010
	 */
	public Collection<CobrancaDocumento> pesquisarDadosCobrancaDocumentoValidoImovel(Integer idImovel, Integer idDocumentoTipo,
			Integer idAcaoCobranca) throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT cd " + " FROM CobrancaDocumento cd " + " INNER JOIN FETCH cd.documentoTipo dt"
					+ " INNER JOIN FETCH cd.cobrancaAcao ca" + " WHERE dt.id = :idDocumentoTipo AND" + " cd.imovel.id = :idImovel AND"
					+ " ca.id = :idAcaoCobranca AND"
					+ " (TO_DATE (TO_CHAR (cd.emissao, 'YYYY-MON-DD HH24:MI:SS'), 'YYYY-MON-DD HH24:MI:SS') + ca.numeroDiasValidade) >= "
					+ Util.obterSQLDataAtual() + " ";

			retorno = session.createQuery(consulta).setInteger("idDocumentoTipo", idDocumentoTipo).setInteger("idImovel", idImovel)
					.setInteger("idAcaoCobranca", idAcaoCobranca)
					// .setDate("dataAtual", Util.obterSQLDataAtual())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Data: 16/09/2010
	 * 
	 * @author Vivianne Sousa
	 */
	public Integer pesquisarCobrancaDocumentoFisc(Integer idFiscalizacaoSituacao, Integer idOrdemServico, Integer idCobrancaDocumento)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cdfz.id " + "from CobrancaDocumentoFisc cdfz " + "where "
					+ " cdfz.fiscalizacaoSituacao.id = :idFiscalizacaoSituacao " + " and cdfz.ordemServico.id = :idOrdemServico "
					+ " and cdfz.cobrancaDocumento.id = :idCobrancaDocumento ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idFiscalizacaoSituacao", idFiscalizacaoSituacao)
					.setInteger("idOrdemServico", idOrdemServico).setInteger("idCobrancaDocumento", idCobrancaDocumento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0852]  Incluir Débito a Cobrar de Entrada de Parcelamento Não Paga
	 * 
	 * --- --- Pesquisa a guia de pagamento do parcelamento --- ---
	 * 
	 * @author Arthur Carvalho
	 * @date 22/09/2010
	 * @param parcelamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoDoParcelamentoPorEntradaNaoPaga(String parcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT gpag.id, gpag.dataVencimento  " + "FROM GuiaPagamento gpag " + "WHERE gpag.parcelamento = :parcelamento "
					+ "and gpag.debitoCreditoSituacaoAtual in (0,1,2) ";

			retorno = session.createQuery(consulta).setInteger("parcelamento", new Integer(parcelamento)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Pesquisa por todos os impostos a partir de uma fatura de um cliente
	 * responsavel federal e/ou de um imovel.
	 * 
	 * A fatura é obrigatória.
	 * 
	 * OBS: O id da fatura passado tem que ser de uma fatura de um cliente
	 * responsavel federal
	 * 
	 * @author Fernando Fontelles, Mariana Victor
	 * @date 24/09/2010, 24/02/2011
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaImpostoFaturaClienteResponsavelFederalAnalitico(/*
																			 * Integer
																			 * idFatura
																			 */Integer anoMesFerencia, Integer idCliente/*
																														 * Integer
																														 * idImovel
																														 */)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			Query query = null;

			if (idCliente != null) {

				consulta = "select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cnid.cnid_pcaliquota as percAliquota, "
						+ " sum(cnid.cnid_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, "
						+ " cnta.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ " from		faturamento.conta_impostos_deduzidos cnid "
						+ " inner	join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) "
						+ " inner	join cadastro.cliente_conta clct on (cnta.cnta_id = clct.cnta_id and clct.crtp_id = 3) "
						+ " inner	join cadastro.cliente clie on (clct.clie_id = clie.clie_id) "
						+ " inner	join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ " inner	join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) "
						+ " where	cnta.cnta_amreferenciaconta = :anoMesReferencia "
						+ " and		clct.clie_id = :idCliente "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnta.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj "
						+ " union all "
						+ " select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cidh.cidh_pcaliquota as percAliquota, "
						+ " sum(cidh.cidh_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, "
						+ " cnhi.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ " from		faturamento.conta_impostos_dedz_hist cidh "
						+ " inner	join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) "
						+ " inner	join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) "
						+ " inner	join cadastro.cliente clie on (clch.clie_id = clie.clie_id) "
						+ " inner	join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ " inner	join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) "
						+ " where	cnhi.cnhi_amreferenciaconta = :anoMesReferencia "
						+ " and		clch.clie_id = :idCliente "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnhi.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj "
						+ " ORDER BY cliente, imovel, impostoTipo ";

				query = session.createSQLQuery(consulta).addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING).addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL).addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING).addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("imovel", Hibernate.INTEGER).addScalar("cnpj", Hibernate.STRING)
						.setInteger("anoMesReferencia", anoMesFerencia).setInteger("idCliente", idCliente);

			} else {

				consulta = "select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cnid.cnid_pcaliquota as percAliquota, "
						+ " sum(cnid.cnid_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, "
						+ " cnta.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ " from		faturamento.conta_impostos_deduzidos cnid "
						+ " inner	join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) "
						+ " inner	join cadastro.cliente_conta clct on (cnta.cnta_id = clct.cnta_id and clct.crtp_id = 3) "
						+ " inner	join cadastro.cliente clie on (clct.clie_id = clie.clie_id) "
						+ " inner	join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ " inner	join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) "
						+ " where	cnta.cnta_amreferenciaconta = :anoMesReferencia "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnta.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj "
						+ " union all "
						+ " select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cidh.cidh_pcaliquota as percAliquota, "
						+ " sum(cidh.cidh_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, "
						+ " cnhi.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ " from		faturamento.conta_impostos_dedz_hist cidh "
						+ " inner	join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) "
						+ " inner	join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) "
						+ " inner	join cadastro.cliente clie on (clch.clie_id = clie.clie_id) "
						+ " inner	join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ " inner	join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) "
						+ " where	cnhi.cnhi_amreferenciaconta = :anoMesReferencia "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnhi.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj "
						+ " ORDER BY cliente, imovel, impostoTipo ";

				query = session.createSQLQuery(consulta).addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING).addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL).addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING).addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("imovel", Hibernate.INTEGER).addScalar("cnpj", Hibernate.STRING)
						.setInteger("anoMesReferencia", anoMesFerencia);
			}

			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC676] Consultar Resumo Negativação
	 * 
	 * @author Ivan Sergio
	 * @date 14/01/2011
	 * 
	 * @param dadosConsultaNegativacaoHelper
	 * @param idSituacaoDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarNegativacaoLigacaoAguaPorSituacaoDebito(DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper,
			int idSituacaoDebito) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (last.id, last.descricao, "
					+ " sum(re.quantidadeInclusoes),sum(coalesce(re.valorDebito,0)), sum(coalesce(re.valorPendente,0)), "
					+ " sum(coalesce(re.valorPago,0)), sum(coalesce(re.valorParcelado,0)), sum(coalesce(re.valorCancelado,0))) "
					+ " from ResumoNegativacao re " + " inner join re.negativador neg " + " left outer join re.ligacaoAguaSituacao last "
					+ " where re.cobrancaDebitoSituacao.id = :idSituacaoDebito "
					+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper) + " group by last.id, last.descricao "
					+ " order by last.id, last.descricao ";

			retorno = session.createQuery(consulta).setInteger("idSituacaoDebito", idSituacaoDebito).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Serviço da Ação de Cobrança
	 * 
	 * @author Mariana Victor
	 * @created 02/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Integer> pesquisarOrdemServicoParaEncerrar(Integer idCobrancaAcaoCronograma) throws ErroRepositorioException {
		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Integer> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caac.caac_id AS ativCronograma " + "   FROM cobranca.cobranca_acao_ativ_crg caac "
					+ " WHERE caac.cbcr_id = :idCobrancaAcaoCronograma " + " GROUP BY caac.caac_id " + " ORDER BY caac.caac_id ";

			// executa o hql
			Query query = session.createSQLQuery(consulta).addScalar("ativCronograma", Hibernate.INTEGER)
					.setInteger("idCobrancaAcaoCronograma", idCobrancaAcaoCronograma);
			retorno = (Collection<Integer>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Serviço da Ação de Cobrança
	 * 
	 * @author Mariana Victor
	 * @created 10/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarAtivCronogOrdemServicoParaEncerrar(Integer idAtividadeCronograma) throws ErroRepositorioException {
		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caatcr.caac_id AS ativCronograma, caatcr.caac_tmcomando AS comando, "
					+ " caatcr.caac_dtprevista AS dataPrevista, os.orse_id AS ordemServico, cbat_id as idCobrancaAtividade "
					+ " FROM atendimentopublico.ordem_servico os "
					+ " INNER JOIN cobranca.cobranca_documento cd ON os.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao ca ON cd.cbac_id = ca.cbac_id "
					+ " INNER JOIN cobranca.cobranca_acao_ativ_crg caatcr ON caatcr.caac_id = cd.caac_id AND caatcr.caac_id = :idAtividadeCronograma"
					+ " WHERE os.orse_cdsituacao = 1 ";

			// executa o hql
			Query query = session.createSQLQuery(consulta).addScalar("ativCronograma", Hibernate.INTEGER)
					.addScalar("comando", Hibernate.TIMESTAMP).addScalar("dataPrevista", Hibernate.DATE)
					.addScalar("ordemServico", Hibernate.INTEGER).addScalar("idCobrancaAtividade", Hibernate.INTEGER)
					.setInteger("idAtividadeCronograma", idAtividadeCronograma);
			retorno = (Collection) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Serviço da Ação de Cobrança
	 * 
	 * @author Mariana Victor
	 * @created 07/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarAtividadeCronograma(Integer idCobrancaAcao) throws ErroRepositorioException {
		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caatcr.caac_id AS atividadeCronograma " + " FROM atendimentopublico.ordem_servico os "
					+ " INNER JOIN cobranca.cobranca_documento cd ON os.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao ca ON cd.cbac_id = ca.cbac_id AND ca.cbac_id = :idCobrancaAcao "
					+ " INNER JOIN cobranca.cobranca_acao_atividade_cronog caatcr ON caatcr.caac_id = cd.caac_id "
					+ " WHERE os.orse_cdsituacao = 1 " + " GROUP BY caatcr.caac_id ";

			// executa o hql
			Query query = session.createSQLQuery(consulta).addScalar("atividadeCronograma", Hibernate.INTEGER)
					.setInteger("idCobrancaAcao", idCobrancaAcao);
			retorno = (Collection) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	public Collection<Object[]> pesquisarLocalidade(int idOrdemServico) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select imv.loca_id AS idLocalidade " + " from atendimentopublico.ordem_servico os "
					+ " INNER JOIN cadastro.imovel imv ON os.imov_id = imv.imov_id " + " WHERE os.orse_id = :idOrdemServico ";

			retorno = session.createSQLQuery(consulta).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idOrdemServico", idOrdemServico).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança para Imóvel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	public Collection pesquisarIdDocumentoCobrancaParaImovel(Integer idImovel, Integer idDocumentoTipo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select cbdo.id " + " from CobrancaDocumento cbdo " + " where cbdo.imovel.id = :idImovel "
					+ " and cbdo.documentoTipo = :idDocumentoTipo " + " order by cbdo.id desc " + " limit 6 ";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idDocumentoTipo", idDocumentoTipo).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança para Imóvel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança para Imóvel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	public Integer pesquisarQtdeDocumentoCobrancaItemConta(Collection idsCobrancaDocumento, Collection colecaoConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataLimite = Util.adicionarNumeroDiasDeUmaData(new Date(), -30);
		try {

			consulta = "select count(cdit.id) " + " from CobrancaDocumentoItem cdit "
					+ " where cdit.cobrancaDocumento.id in (:idsCobrancaDocumento) " + " and cdit.contaGeral.id in (:colecaoConta) "
					+ " and cdit.cobrancaDocumento.emissao <= :dataLimite";

			retorno = (Integer) session.createQuery(consulta).setParameterList("idsCobrancaDocumento", idsCobrancaDocumento)
					.setParameterList("colecaoConta", colecaoConta).setDate("dataLimite", Util.formatarDataFinal(dataLimite))
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança para Imóvel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	public Integer pesquisarQtdeDocumentoCobrancaItemDebitoACobrar(Collection idsCobrancaDocumento, Collection colecaoDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataLimite = Util.adicionarNumeroDiasDeUmaData(new Date(), -30);
		try {

			consulta = "select count(cdit.id) " + " from CobrancaDocumentoItem cdit "
					+ " where cdit.cobrancaDocumento.id in (:idsCobrancaDocumento) "
					+ " and cdit.debitoACobrarGeral.id in (:colecaoDebitoACobrar) " + " and cdit.cobrancaDocumento.emissao <= :dataLimite";

			retorno = (Integer) session.createQuery(consulta).setParameterList("idsCobrancaDocumento", idsCobrancaDocumento)
					.setParameterList("colecaoDebitoACobrar", colecaoDebitoACobrar)
					.setDate("dataLimite", Util.formatarDataFinal(dataLimite)).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobrança Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 20/01/2011
	 **/
	public Integer pesquisarQuantidadeContasDebito(Integer idCobrancaDocumento) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT count(conta) " + " FROM CobrancaDocumentoItem cdit " + " INNER JOIN cdit.contaGeral contaGeral "
					+ " INNER JOIN contaGeral.conta conta " + " WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobrança Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 20/01/2011
	 **/
	public List<String> pesquisarTipoDeCorte() throws ErroRepositorioException {

		List<String> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cotp_dscortetipo AS descricao " + "FROM atendimentopublico.corte_tipo "
					+ "WHERE cotp_icform = 1 ORDER BY cotp_id ";

			retorno = (List<String>) session.createSQLQuery(consulta).addScalar("descricao", Hibernate.STRING).setMaxResults(5).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobrança Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 26/01/2011
	 **/
	public List<String> pesquisarOcorrenciasFiscalizacao() throws ErroRepositorioException {

		List<String> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT fzst_dsfiscalizacaosituacao AS descricao " + " FROM atendimentopublico.fiscalizacao_situacao"
					+ " WHERE fzst_icform = 1 ORDER BY fzst_id ";

			retorno = (List<String>) session.createSQLQuery(consulta).addScalar("descricao", Hibernate.STRING).setMaxResults(15).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobrança Em Lote
	 * 
	 * @author Rômulo Aurélio
	 * @created 17/02/2011
	 **/

	public void atualizarDataRealizacaoCobrancaAcaoAtivCronograma(Integer idCobAcaoAtivCron) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String hql = "";
		try {
			hql = "update gcom.cobranca.CobrancaAcaoAtividadeCronograma " + "set realizacao = " + Util.obterSQLDataAtual()
					+ " where id = :id ";

			session.createQuery(hql).setInteger("id", idCobAcaoAtivCron).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a guia
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteGuia(CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit " + "FROM CobrancaDocumentoItem cdit " + "LEFT JOIN fetch cdit.guiaPagamentoGeral guia "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND " + "guia.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a débito à
	 * cobrar
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteDebitoACobrar(CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit " + "FROM CobrancaDocumentoItem cdit " + "LEFT JOIN fetch cdit.debitoACobrarGeral debitoACobrar "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND " + "debitoACobrar.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a credito à
	 * cobrar
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteCreditoACobrar(CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit " + "FROM CobrancaDocumentoItem cdit " + "LEFT JOIN fetch cdit.creditoARealizarGeral creditoACobrar "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND " + "creditoACobrar.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0968] Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos do aviso de
	 * corte
	 * 
	 * @author Mariana Victor
	 * @date 17/03/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirDocumentoCobrancaImpressaoFichaCompensasao(Integer idCobrancaDocumento, String linhaTxt,
			String conteudoFichaCompensacao, Integer idCobrancaAcaoAtividadeComando, Integer idCobrancaAcaoAtividadeCronograma,
			Integer sequencialImpressao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into cobranca.cobranca_documento_impr values (" + idCobrancaDocumento + "," + "'" + linhaTxt + "',"
					+ idCobrancaAcaoAtividadeComando + "," + idCobrancaAcaoAtividadeCronograma + "," + sequencialImpressao + ","
					+ Util.obterSQLDataAtual() + "," + "'" + conteudoFichaCompensacao + "')";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0968] Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * @author Mariana Victor
	 * @date 17/03/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDocumentoCobrancaImpressaoFichaCompensacao(Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma) throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdim.linhaTxt, cdim.conteudoFichaCompensacao " + "FROM CobrancaDocumentoImpressao cdim ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " INNER JOIN cdim.cobrancaAcaoAtividadeComando cacm " + " WHERE  cacm.id = "
						+ idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " INNER JOIN cdim.cobrancaAcaoAtividadeCronograma caac " + " WHERE  caac.id = "
						+ idCobrancaAcaoAtividadeCronograma;
			}

			consulta = consulta + " order by cdim.sequencialImpressao ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 22/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarItemServicoContrato(Integer idGrupoCobranca) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT its.itse_cdconstantecalculo as cdConstante, "// 0
					+ "itsc.itsc_id as idItemServicoContrato, "// 1
					+ "itsc.itsc_vlitemservcontr as vlItemServicoContrato, "// 2
					+ "ces.cese_id as idContratoEmpresaServico, "// 3
					+ "cogr.cbgr_dsemail as emailResponsavel "// 4
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cadastro.empresa emp on emp.empr_id = ces.empr_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id " + "WHERE cogr.cbgr_id = :idGrupoCobranca ";

			consulta = consulta + " order by its.itse_cdconstantecalculo ";

			retorno = session.createSQLQuery(consulta).addScalar("cdConstante", Hibernate.INTEGER)
					.addScalar("idItemServicoContrato", Hibernate.INTEGER).addScalar("vlItemServicoContrato", Hibernate.BIG_DECIMAL)
					.addScalar("idContratoEmpresaServico", Hibernate.INTEGER).addScalar("emailResponsavel", Hibernate.STRING)
					.setInteger("idGrupoCobranca", idGrupoCobranca).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletim(Integer idGrupoCobranca, Integer idItemServicoContrato, Integer referencia)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and os.orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO).setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRotaAlternativa(Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and os.orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO).setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimento(Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO).setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR).setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoRotaAlternativa(Integer idGrupoCobranca,
			Integer idItemServicoContrato, Short indicadorPavimento, Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO).setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR).setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepAsfalto(Integer idGrupoCobranca, Integer idItemServicoContrato, Integer referencia)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepasfalto is not null and osBo.orbo_nnrepasfalto <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepAsfalto", Hibernate.BIG_DECIMAL).setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR).setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepAsfaltoRotaAlternativa(Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepasfalto is not null and osBo.orbo_nnrepasfalto <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepAsfalto", Hibernate.BIG_DECIMAL).setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR).setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepParalalo(Integer idGrupoCobranca, Integer idItemServicoContrato, Integer referencia)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepparalelo as numeroRepParalelo "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepparalelo is not null and osBo.orbo_nnrepparalelo <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepParalelo", Hibernate.BIG_DECIMAL).setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR).setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepParalaloRotaAlternativa(Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepparalelo as numeroRepParalelo "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepparalelo is not null and osBo.orbo_nnrepparalelo <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepParalelo", Hibernate.BIG_DECIMAL).setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR).setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepCalcada(Integer idGrupoCobranca, Integer idItemServicoContrato, Integer referencia)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepcalcada as numeroRepCalcada "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepcalcada is not null and osBo.orbo_nnrepcalcada <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepCalcada", Hibernate.BIG_DECIMAL).setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR).setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepCalcadaRotaAlternativa(Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepcalcada as numeroRepCalcada "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepcalcada is not null and osBo.orbo_nnrepcalcada <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id)";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepCalcada", Hibernate.BIG_DECIMAL).setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR).setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDesconto(Integer idGrupoCobranca, Integer idItemServicoContrato, Integer referencia)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 and os.cbdo_id = dc.cbdo_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id = :atenMotivoEnce and im.rota_idalternativa is null";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("atenMotivoEnce", AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoRotaAlternativa(Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 and os.cbdo_id = dc.cbdo_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id = :atenMotivoEnce and im.rota_idalternativa is not null";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("atenMotivoEnce", AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoSemDecursoPrazo(Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 2 "
					+ "INNER JOIN cobranca.cob_ac_os_nao_aceitas caosnaceitas on os.orse_id = caosnaceitas.orse_id and caon_icaceita = 2 and caon_icdescontado = 2 and os.cbdo_id = dc.cbdo_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id <> :atenMotivoEnce and im.rota_idalternativa is null";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("atenMotivoEnce", AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoSemDecursoPrazoRotaAlternativa(Integer idGrupoCobranca,
			Integer idItemServicoContrato, Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 2 "
					+ "INNER JOIN cobranca.cob_ac_os_nao_aceitas caosnaceitas on os.orse_id = caosnaceitas.orse_id and caon_icaceita = 2 and caon_icdescontado = 2 and os.cbdo_id = dc.cbdo_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id <> :atenMotivoEnce and im.rota_idalternativa is not null";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("atenMotivoEnce", AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection<Object[]> pesquisarSituacaoAtualContaPeloCronogramaCobranca(Integer idGrupoCobranca, Integer referencia)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select "
					+ "cd.imov_id as idImovel, "// 0
					+ "cd.loca_id as idLocalidade, "// 1
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.dcst_idatual "
					+ " else "
					+ "   cthist.dcst_idatual"
					+ " end as situacaoAtualConta," // 2
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   pg.pgmt_vlpagamento "
					+ " else "
					+ "   pghistContaHist.pghi_vlpagamento "
					+ " end as valorPagamento, " // 3
					+ " ces.cese_pctaxasucesso as percentualTaxaSucesso, "// 4
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.cnta_amreferenciaconta "
					+ " else "
					+ "   cthist.cnhi_amreferenciaconta"
					+ " end as referenciaConta, " // 5
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.cnta_vlagua + ct.cnta_vlesgoto + ct.cnta_vldebitos - ct.cnta_vlcreditos - ct.cnta_vlimpostos "
					+ " else "
					+ "   cthist.cnhi_vlagua + cthist.cnhi_vlesgoto + cthist.cnhi_vldebitos - cthist.cnhi_vlcreditos - cthist.cnhi_vlimpostos "
					+ " end as valorConta " // 6
					+ " from cobranca.cobranca_documento_item cdi "
					+ " INNER JOIN cobranca.cobranca_documento cd on cdi.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.caac_id = cd.caac_id "
					+ " INNER join cobranca.cobranca_acao_cronograma cac on cac.cbcr_id = caac.cbcr_id "
					+ " INNER join cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbcm_id = cac.cbcm_id "
					+ " INNER join cobranca.cobranca_grupo cg on cg.cbgr_id = cgcm.cbgr_id "
					+ " INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = cg.cese_id "
					+ " INNER join atendimentopublico.ordem_servico os on os.cbdo_id = cd.cbdo_id  "
					+ " INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ " LEFT JOIN faturamento.conta ct on ct.cnta_id = cdi.cnta_id "
					+ " LEFT JOIN arrecadacao.pagamento pg on pg.cnta_id = ct.cnta_id "
					+ " LEFT JOIN faturamento.conta_historico cthist on cthist.cnta_id = cdi.cnta_id "
					+ " LEFT JOIN arrecadacao.pagamento_historico pghistContaHist on pghistContaHist.cnta_id = cthist.cnta_id "
					+ " where cg.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and cac.cbac_id = :idCobrancaAcao and "
					+ " os.orse_cdsituacao = :cdSituacao " + " order by cd.imov_id";

			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("situacaoAtualConta", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("percentualTaxaSucesso", Hibernate.BIG_DECIMAL)
					.addScalar("referenciaConta", Hibernate.INTEGER).addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idGrupoCobranca", idGrupoCobranca).setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("referencia", referencia).setInteger("idCobrancaAcao", CobrancaAcao.VISITA_COBRANCA).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public void atualizaIndicadorBoletimOS(Collection idsOS) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em débito automático a Data Exclusão com a data corrente
			atualizaDataExclusao = "update gcom.atendimentopublico.ordemservico.OrdemServico "
					+ "set orse_icboletim = 1,orse_tmultimaalteracao = :ultimaAlteracao where orse_id in(:idsOS)";

			session.createQuery(atualizaDataExclusao).setParameterList("idsOS", idsOS).setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public void atualizaIndicadorCobrancaAcaoOSNaoAceitas(Collection idsOSNaoAceitas) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em débito automático a Data Exclusão com a data corrente
			atualizaDataExclusao = "update gcom.cobranca.CobrancaAcaoOrdemServicoNaoAceitas "
					+ "set caon_icdescontado = 1,caon_tmultimaltarecao = :ultimaAlteracao where orse_id in (:idsOSNaoAceitas) and "
					+ " caac_id = :idCobrancaAcao ";

			session.createQuery(atualizaDataExclusao).setParameterList("idsOSNaoAceitas", idsOSNaoAceitas)
					.setTimestamp("ultimaAlteracao", new Date()).setInteger("idCobrancaAcao", CobrancaAcao.VISITA_COBRANCA).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1153] Solicitar Geração/Emissão Boletim de Medição de Cobrança
	 * 
	 * [FS0002]  Ações não encerradas no cronograma.
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Integer pesquisarAcoesEncerradasCronograma(Integer anoMesReferencia, Integer idCobrancaGrupo) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT count(*) AS contador " + " FROM cobranca.cobranca_acao_ativ_crg caac "
					+ "   INNER JOIN cobranca.cobranca_acao_cronograma cbcr ON cbcr.cbcr_id = caac.cbcr_id "
					+ "   INNER JOIN cobranca.cobranca_grupo_crg_mes cbcm ON cbcm.cbcm_id = cbcr.cbcm_id "
					+ " WHERE cbcm.cbcm_amreferencia = :anoMesReferencia " + "   AND cbcm.cbgr_id = :idCobrancaGrupo "
					+ "   AND caac.caac_tmrealizacao IS NULL ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("contador", Hibernate.INTEGER)
					.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idCobrancaGrupo", idCobrancaGrupo).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Pesquisa os Itens de Serviço relacionados ao boletim de medição de
	 * cobrança selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimDesconto(Integer anoMesReferencia, Integer idCobrancaGrupo,
			Integer idGerenciaRegional, Integer idUnidadeNegocio, Integer idLocalidadeInicial, Integer idLocalidadeFinal)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  itse.itse_id AS idItemServico, " // 1
					+ "  itse.itse_dsitemservico AS descricao, " // 2
					+ "  itse.itse_cdconstantecalculo AS constante, " // 3
					+ "  cobm_dtgeracao AS dataGeracao, " // 4
					+ "  itse_cditem AS codigoItem, " // 5
					+ "  loca.loca_nmlocalidade AS localidade, " // 6
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 7
					+ "  loca.loca_id AS idLoca, " // 8
					+ "  greg.greg_id AS idGerencia, " // 9
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 10
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_desc cbds ON cbds.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbds.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cbgr_id = :idCobrancaGrupo " + "   AND cobm.cobm_amreferencia = :anoMesReferencia ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbds.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta + "  AND cbds.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem";

			Query query = session.createSQLQuery(consulta).addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("idItemServico", Hibernate.INTEGER).addScalar("descricao", Hibernate.STRING)
					.addScalar("constante", Hibernate.STRING).addScalar("dataGeracao", Hibernate.DATE)
					.addScalar("codigoItem", Hibernate.LONG).addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING).addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER).addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idCobrancaGrupo", idCobrancaGrupo);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Pesquisa os Itens de Serviço relacionados ao boletim de medição de
	 * cobrança selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimExecutados(Integer anoMesReferencia, Integer idCobrancaGrupo,
			Integer idGerenciaRegional, Integer idUnidadeNegocio, Integer idLocalidadeInicial, Integer idLocalidadeFinal)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  itse.itse_id AS idItemServico, " // 1
					+ "  itse.itse_dsitemservico AS descricao, " // 2
					+ "  itse.itse_cdconstantecalculo AS constante, " // 3
					+ "  cobm_dtgeracao AS dataGeracao, " // 4
					+ "  itse_cditem AS codigoItem, " // 5
					+ "  loca.loca_nmlocalidade AS localidade, " // 6
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 7
					+ "  loca.loca_id AS idLoca, " // 8
					+ "  greg.greg_id AS idGerencia, " // 9
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 10
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbex.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cbgr_id = :idCobrancaGrupo " + "   AND cobm.cobm_amreferencia = :anoMesReferencia ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbex.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta + "  AND cbex.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			Query query = session.createSQLQuery(consulta).addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("idItemServico", Hibernate.INTEGER).addScalar("descricao", Hibernate.STRING)
					.addScalar("constante", Hibernate.STRING).addScalar("dataGeracao", Hibernate.DATE)
					.addScalar("codigoItem", Hibernate.LONG).addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING).addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER).addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idCobrancaGrupo", idCobrancaGrupo);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Pesquisa os Itens de Serviço relacionados ao boletim de medição de
	 * cobrança selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimSucesso(Integer anoMesReferencia, Integer idCobrancaGrupo,
			Integer idGerenciaRegional, Integer idUnidadeNegocio, Integer idLocalidadeInicial, Integer idLocalidadeFinal)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  cobm_dtgeracao AS dataGeracao, " // 1
					+ "  loca.loca_nmlocalidade AS localidade, " // 2
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 3
					+ "  loca.loca_id AS idLoca, " // 4
					+ "  greg.greg_id AS idGerencia, " // 5
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 6
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_sucesso cbsu ON cbsu.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbsu.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cbgr_id = :idCobrancaGrupo " + "   AND cobm.cobm_amreferencia = :anoMesReferencia ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbsu.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta + "  AND cbsu.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, cobm.cobm_dtgeracao ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, cobm.cobm_dtgeracao ";

			Query query = session.createSQLQuery(consulta).addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("dataGeracao", Hibernate.DATE).addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING).addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER).addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idCobrancaGrupo", idCobrancaGrupo);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0 && idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * De acordo com o código da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 22/03/2011
	 **/
	public Object[] obterQuantidadeOSBoletimMedicaoCobranca(RelatorioBoletimMedicaoCobrancaHelper helper) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(orse.orse_id) AS contador, "
					+ " itsc.itsc_vlitemservcontr AS valorItem, cbex.cbex_vlservico AS valorServico "
					+ " FROM atendimentopublico.ordem_servico orse "
					+ "  INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.orse_id = orse.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbex.cobm_id = cobm.cobm_id ";

			switch (helper.getItemServico().getCodigoConstanteCalculo()) {

			case 2:
			case 6:
				consulta = consulta + " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 3 ";
				break;

			case 3:
			case 7:
			case 9:
			case 11:
			case 13:
				consulta = consulta + " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 2 ";
				break;

			case 4:
			case 8:
			case 10:
			case 12:
			case 14:
				consulta = consulta + " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 ";
				break;

			default:
				break;
			}

			consulta = consulta
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON orse.svtp_id = itsc.svtp_id AND cobm.cese_id = itsc.cese_id  "
					+ " WHERE itsc.itse_id = :idItemServico " + "  AND cbex.cobm_id = :idCobBolMedicao "
					+ "  AND cbex.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY itsc.itsc_vlitemservcontr, cbex.cbex_vlservico ";

			Query query = session.createSQLQuery(consulta).addScalar("contador", Hibernate.INTEGER)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL).addScalar("valorServico", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServico", helper.getItemServico().getId())
					.setInteger("idCobBolMedicao", helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * De acordo com o código da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 22/03/2011
	 **/
	public Object[] obterSomatorioOSBoletimMedicaoCobranca(RelatorioBoletimMedicaoCobrancaHelper helper) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			switch (helper.getItemServico().getCodigoConstanteCalculo()) {

			case 15:
				consulta = consulta + " SELECT sum(orbo.orbo_nnrepasfalto) AS somatorio, ";
				break;

			case 16:
				consulta = consulta + " SELECT sum(orbo.orbo_nnrepparalelo) AS somatorio, ";
				break;

			case 17:
				consulta = consulta + " SELECT sum(orbo.orbo_nnrepcalcada) AS somatorio, ";
				break;

			default:
				break;
			}

			consulta = consulta + " itsc.itsc_vlitemservcontr AS valorItem " + " FROM atendimentopublico.ordem_servico_boletim orbo "
					+ "  INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.orse_id = orbo.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbex.cobm_id = cobm.cobm_id "
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON cobm.cese_id = itsc.cese_id "
					+ " WHERE itsc.itse_id = :idItemServico " + "  AND cbex.cobm_id = :idCobBolMedicao "
					+ "  AND cbex.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY itsc.itsc_vlitemservcontr";

			Query query = session.createSQLQuery(consulta).addScalar("somatorio", Hibernate.BIG_DECIMAL)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL).setInteger("idItemServico", helper.getItemServico().getId())
					.setInteger("idCobBolMedicao", helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * De acordo com o código da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 23/03/2011
	 **/
	public Object[] obterQuantidadeOSBoletimMedicaoCobrancaDesconto(RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(orse.orse_id) AS contador, " + " itsc.itsc_vlitemservcontr AS valorItem "
					+ " FROM atendimentopublico.ordem_servico orse "
					+ "  INNER JOIN cobranca.cobr_boletim_desc cbde ON cbde.orse_id = orse.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbde.cobm_id = cobm.cobm_id "
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON orse.svtp_id = itsc.svtp_id  "
					+ "    AND cobm.cese_id = itsc.cese_id " + " WHERE itsc.itse_id = :idItemServico "
					+ "  AND cbde.cobm_id = :idCobBolMedicao " + "  AND cbde.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY itsc.itsc_vlitemservcontr ";

			Query query = session.createSQLQuery(consulta).addScalar("contador", Hibernate.INTEGER)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL).setInteger("idItemServico", helper.getItemServico().getId())
					.setInteger("idCobBolMedicao", helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Consulta os valores da totalização da taxa de sucesso.
	 * 
	 * @author Mariana Victor
	 * @created 23/03/2011
	 **/
	public Object[] obterTotalizacaoOSBoletimMedicaoCobrancaSucesso(RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(cbsu.imov_id) AS contador, cese.cese_pctaxasucesso AS pcTxSucesso, "
					+ "    sum(cbsu.cbsu_vlrecuperado) AS somatorio, sum(cbsu.cbsu_vltxsucesso) AS comatorioCalculado "
					+ " FROM cobranca.cobr_boletim_sucesso cbsu "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cobm_id = cbsu.cobm_id "
					+ "   INNER JOIN micromedicao.contrato_empresa_servico cese ON cobm.cese_id = cese.cese_id "
					+ " WHERE cbsu.cobm_id = :idCobBolMedicao " + "   AND cbsu.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY cese.cese_pctaxasucesso ";

			Query query = session.createSQLQuery(consulta).addScalar("contador", Hibernate.INTEGER)
					.addScalar("pcTxSucesso", Hibernate.BIG_DECIMAL).addScalar("somatorio", Hibernate.BIG_DECIMAL)
					.addScalar("comatorioCalculado", Hibernate.BIG_DECIMAL)
					.setInteger("idCobBolMedicao", helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Pesquisa dados da empresa e do contrado do boletim de cobrança
	 * 
	 * @author Mariana Victor
	 * @created 24/03/2011
	 **/
	public Object[] pesquisarDadosBoletimMedicaoCobranca(Integer anoMesReferencia, Integer idCobrancaGrupo) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT empr.empr_nmempresa AS nome, cese.cese_dsnumerocontrato AS numero, cobm.cobm_vltotal AS valorTotal "
					+ " FROM cobranca.cobr_boletim_medicao cobm "
					+ "  INNER JOIN micromedicao.contrato_empresa_servico cese ON cobm.cese_id = cese.cese_id "
					+ "  INNER JOIN cadastro.empresa empr ON cese.empr_id = empr.empr_id " + " WHERE cobm.cbgr_id = :idCobrancaGrupo "
					+ "   AND cobm.cobm_amreferencia = :anoMesReferencia ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar("nome", Hibernate.STRING).addScalar("numero", Hibernate.STRING)
					.addScalar("valorTotal", Hibernate.BIG_DECIMAL).setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relatório de Análise de Perdas com Crédito
	 * 
	 * [UC1155] Gerar Relatório de Análise de Perdas com Crédito
	 * 
	 * 
	 * @author Paulo Diniz
	 * @date 16/03/2011
	 * 
	 * @param mesAno
	 *            para análise
	 * @throws ErroRepositorioException
	 */
	public RelatorioAnalisePerdasCreditosBean gerarRelatorioAnalisePerdasCreditos(String anoMesReferencia) throws ErroRepositorioException {
		RelatorioAnalisePerdasCreditosBean retorno = new RelatorioAnalisePerdasCreditosBean();
		List<Object[]> retornoBanco = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		SQLQuery query = null;

		try {

			consulta = " select  	 "
					+ " sum( case when (drrs.drrs_qtdiasvencidos > 0 and drrs.drrs_qtdiasvencidos <= 180 and fdrc.fdrc_id = 1 ) "
					+ " then drfx.drfx_vldocumentos end) as vencidoAte180, "
					+ " sum( case when (drrs.drrs_qtdiasvencidos > 180 and fdrc.fdrc_id = 1 ) "
					+ " then drfx.drfx_vldocumentos end) as vencidoMais180, " +

					"  sum( case when (drrs.drrs_qtdiasvencidos > 0 and drrs.drrs_qtdiasvencidos <= 360 and fdrc.fdrc_id != 1) "
					+ " 	 then drfx.drfx_vldocumentos end) as vencidoAte360, "
					+ "  sum( case when (drrs.drrs_qtdiasvencidos > 360 and fdrc.fdrc_id != 1) "
					+ " 	 then drfx.drfx_vldocumentos end) as vencidoMais360, " +

					" sum( case when (drrs.drrs_qtdiasvencidos <=0 or  drrs.drrs_qtdiasvencidos is null) "
					+ " then drfx.drfx_vldocumentos end) as a_vencer, " + " sum(drfx.drfx_qtdocumentos) as qtd_documentos, "
					+ " sum(drfx.drfx_vldocumentos) as valor_total , " + " fdrc.fdrc_vlfaixainicial as faixaInicial, "
					+ " fdrc.fdrc_vlfaixafinal as faixaFinal " + " from  	financeiro.docs_a_rec_resumo drrs  "
					+ " inner join financeiro.doc_receber_faixa_resumo drfx on drfx.drrs_id = drrs.drrs_id "
					+ " inner join financeiro.faixa_docs_a_receber fdrc on fdrc.fdrc_id = drfx.fdrc_id"
					+ " where 	drrs.drrs_amreferenciarecebimentos = " + anoMesReferencia
					+ " group by fdrc.fdrc_vlfaixainicial, fdrc.fdrc_vlfaixafinal " + " order by fdrc.fdrc_vlfaixainicial";

			query = session.createSQLQuery(consulta);
			query.addScalar("vencidoAte180", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoMais180", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoAte360", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoMais360", Hibernate.BIG_DECIMAL);
			query.addScalar("a_vencer", Hibernate.BIG_DECIMAL);
			query.addScalar("qtd_documentos", Hibernate.INTEGER);
			query.addScalar("valor_total", Hibernate.BIG_DECIMAL);
			query.addScalar("faixaInicial", Hibernate.BIG_DECIMAL);
			query.addScalar("faixaFinal", Hibernate.BIG_DECIMAL);
			query.setMaxResults(3);
			retornoBanco = (List<Object[]>) query.list();

			if (retornoBanco != null && retornoBanco.size() == 3) {

				if (retornoBanco.get(0)[0] != null) {
					retorno.setPrimeiraFaixaVencidosAteSeisMeses(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(0)[0] + "")));
				} else {
					retorno.setPrimeiraFaixaVencidosAteSeisMeses("");
				}
				if (retornoBanco.get(0)[1] != null) {
					retorno.setPrimeiraFaixaVencidosSuperiorSeisMeses(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(0)[1] + "")));
				} else {
					retorno.setPrimeiraFaixaVencidosSuperiorSeisMeses("");
				}
				if (retornoBanco.get(0)[4] != null) {
					retorno.setPrimeiraFaixaVencer(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(0)[4] + "")));
				} else {
					retorno.setPrimeiraFaixaVencer("");
				}
				if (retornoBanco.get(0)[6] != null) {
					retorno.setPrimeiraFaixaTotal(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(0)[6] + "")));
				} else {
					retorno.setPrimeiraFaixaTotal("");
				}

				if (retornoBanco.get(1)[2] != null) {
					retorno.setSegundaFaixaVencidosAteDoseMeses(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(1)[2] + "")));
				} else {
					retorno.setSegundaFaixaVencidosAteDoseMeses("");
				}
				if (retornoBanco.get(1)[3] != null) {
					retorno.setSegundaFaixaVencidosSuperiorDoseMeses(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(1)[3] + "")));
				} else {
					retorno.setSegundaFaixaVencidosSuperiorDoseMeses("");
				}
				if (retornoBanco.get(1)[4] != null) {
					retorno.setSegundaFaixaVencer(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(1)[4] + "")));
				} else {
					retorno.setSegundaFaixaVencer("");
				}
				if (retornoBanco.get(1)[6] != null) {
					retorno.setSegundaFaixaTotal(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(1)[6] + "")));
				} else {
					retorno.setSegundaFaixaTotal("");
				}

				if (retornoBanco.get(2)[2] != null) {
					retorno.setTerceiraFaixaVencidosAteDoseMeses(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(2)[2] + "")));
				} else {
					retorno.setTerceiraFaixaVencidosAteDoseMeses("");
				}
				if (retornoBanco.get(2)[3] != null) {
					retorno.setTerceiraFaixaVencidosSuperiorDoseMeses(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(2)[3] + "")));
				} else {
					retorno.setTerceiraFaixaVencidosSuperiorDoseMeses("");
				}
				if (retornoBanco.get(2)[4] != null) {
					retorno.setTerceiraFaixaVencer(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(2)[4] + "")));
				} else {
					retorno.setTerceiraFaixaVencer("");
				}
				if (retornoBanco.get(2)[6] != null) {
					retorno.setTerceiraFaixaTotal(Util.formatarMoedaReal(new BigDecimal(retornoBanco.get(2)[6] + "")));
				} else {
					retorno.setTerceiraFaixaTotal("");
				}
			} else {
				retorno = null;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o maior ano mesReferencia da tabela docs_a_rec_resumo
	 * 
	 * [UC1155] Gerar Relatório de Análise de Perdas com Crédito
	 * 
	 * 
	 * @author Paulo Diniz
	 * @date 16/03/2011
	 * 
	 * @param mesAno
	 *            para análise
	 * @throws ErroRepositorioException
	 * @throws ErroRepositorioException
	 */
	public int maiorAnoMesReferenciaDocumentosAReceberResumo() throws ErroRepositorioException {
		int retorno = 0;
		Object retornoBanco = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		SQLQuery query = null;

		try {

			consulta = " select max(drrs.drrs_amreferenciarecebimentos) as max from  	financeiro.docs_a_rec_resumo drrs 	 ";

			query = session.createSQLQuery(consulta);
			query.addScalar("max", Hibernate.INTEGER);
			retornoBanco = (Object) query.uniqueResult();

			if (retornoBanco != null) {
				retorno = Integer.parseInt(retornoBanco + "");
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection<BigDecimal> pesquisarValorContaouContaHistorico(Integer idImovel, Integer referencia) throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<BigDecimal> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select "
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   pg.pgmt_vlpagamento "
					+ " else "
					+ "   pghistContaHist.pghi_vlpagamento "
					+ " end as valorPagamento  " // 0
					+ " from cadastro.imovel im "
					+ " LEFT JOIN faturamento.conta ct on ct.imov_id = im.imov_id and ct.cnta_amreferenciaconta = :referencia and ct.dcst_idatual = :retificada "
					+ " LEFT JOIN arrecadacao.pagamento pg on pg.cnta_id = ct.cnta_id "
					+ " LEFT JOIN faturamento.conta_historico cthist on cthist.imov_id = im.imov_id and cthist.cnhi_amreferenciaconta = :referencia and cthist.dcst_idatual = :retificada "
					+ " LEFT JOIN arrecadacao.pagamento_historico pghistContaHist on pghistContaHist.cnta_id = cthist.cnta_id "
					+ " where im.imov_id = :idImovel ";
			// executa o hql
			retorno = session.createSQLQuery(consulta).addScalar("valorPagamento", Hibernate.BIG_DECIMAL).setInteger("idImovel", idImovel)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("referencia", referencia).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoImovelPerfil(Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "iper.iper_id as idImovelPerfil, "// 16
					+ "iper.iper_dsimovelperfil as dsImovelPerfil "// 17
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_per ceip on ceip.cecc_id = cecc.cecc_id "
					+ "left join cadastro.imovel_perfil iper on ceip.iper_id = iper.iper_id " + "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta).addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("dsImovelPerfil", Hibernate.STRING).setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoGerenciaRegional(Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "greg.greg_id as idGerenciaRegional, "// 16
					+ "greg.greg_nmregional as nmGerenciaRegional "// 17
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_ger cecg on cecg.cecc_id = cecc.cecc_id "
					+ "left join cadastro.gerencia_regional greg on cecg.greg_id = greg.greg_id " + "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta).addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nmGerenciaRegional", Hibernate.STRING).setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoUnidadeNegocio(Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "uneg.uneg_id as idUnidadeNegocio, "// 0
					+ "uneg.uneg_nmunidadenegocio as dsUnidadeNegocio "// 1
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_uneg ceun on ceun.cecc_id = cecc.cecc_id "
					+ "left join cadastro.unidade_negocio uneg on ceun.uneg_id = uneg.uneg_id " + "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta).addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("dsUnidadeNegocio", Hibernate.STRING).setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 */
	public Integer pesquisarQuantidadeContasArquivoTextoContasCobrancaEmpresa(Collection ids, Integer idImovel) throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();
		Integer retorno = null;

		try {

			String consulta = " SELECT COUNT(DISTINCT conta.cnta_id) AS quantidadeContas " // 1
					+ " FROM cobranca.empresa_cobranca_conta ecco "
					+ " INNER JOIN faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ " INNER JOIN cadastro.imovel imovel  on imovel.imov_id = conta.imov_id and imovel.imov_id = :idImovel "
					+ " WHERE ecco.cecc_id in (:ids) "
					+ " AND not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) "
					+ " GROUP BY ecco.ecco_id "
					+ " ORDER BY ecco.ecco_id ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidadeContas", Hibernate.INTEGER)
					.setParameterList("ids", ids)
					.setInteger("idImovel", idImovel)
					.setMaxResults(1)
					.uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * Pesquisa a Situação de cobrança a partir do código constante.
	 * 
	 * @author: Mariana Victor
	 * @date: 18/04/2011
	 */
	public Integer pesquisarCobrancaSituacao(Integer idSituacao) throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = " SELECT cbst_id AS id " + " FROM cobranca.cobranca_situacao " + " WHERE cbst_id = :idSituacao ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("id", Hibernate.INTEGER)
					.setInteger("idSituacao", idSituacao).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisar Debito Cobrado de Parcelamento
	 * 
	 * @author Rogério Peixoto
	 * @throws ErroRepositorioException
	 * @date 29/03/2011
	 */
	public boolean parecelamentoPossuiDebitoJaCobrado(Integer codigoParcelamento) throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeDebito = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade FROM " + "cobranca.parcelamento parc "
					+ "INNER JOIN faturamento.debito_a_cobrar dac ON (parc.parc_id = dac.parc_id)"
					+ "INNER JOIN faturamento.debito_cobrado dec ON (dac.dbac_id = dec.dbac_id)"
					+ "WHERE parc.parc_id = :codigoParcelamento";

			quantidadeDebito = (Integer) session.createSQLQuery(consulta).addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("codigoParcelamento", codigoParcelamento).setMaxResults(1).uniqueResult();

			if (quantidadeDebito != null && quantidadeDebito > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarReferenciaContaPorId(Integer idConta) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String consulta;
		Integer referencia = null;

		try {

			consulta = "SELECT cnta_amreferenciaconta as referencia FROM " + "faturamento.conta cnta " + "WHERE cnta_id = "
					+ idConta.intValue();

			referencia = (Integer) session.createSQLQuery(consulta).addScalar("referencia", Hibernate.INTEGER).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return referencia;
	}

	public boolean verificaContaVinculadaAContratoParcelAtivo(Integer idConta) throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeContas = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from COBRANCA.contrato_parcel_item item "
					+ "inner join COBRANCA.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.cnta_id = :idConta and cpar.pcst_id = " + ParcelamentoSituacao.NORMAL;

			quantidadeContas = (Integer) session.createSQLQuery(consulta).addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idConta", idConta).setMaxResults(1).uniqueResult();

			if (quantidadeContas != null && quantidadeContas > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public boolean verificaGuiaVinculadaAContratoParcelAtivo(Integer idGuia) throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeContas = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from COBRANCA.contrato_parcel_item item "
					+ "inner join COBRANCA.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.gpag_id = :idGuia and cpar.pcst_id = " + ParcelamentoSituacao.NORMAL;

			quantidadeContas = (Integer) session.createSQLQuery(consulta).addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idGuia", idGuia).setMaxResults(1).uniqueResult();

			if (quantidadeContas != null && quantidadeContas > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1140] Cancelar Contrato de Parcelamento por Cliente
	 * 
	 * @author Rômulo Aurélio
	 * @throws ErroRepositorioException
	 * @date 12/05/2011
	 */
	public ContratoParcelamento pesquisarContratoParcelamento(String numeroParcelamento) throws ErroRepositorioException {
		ContratoParcelamento retorno = null;
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = "SELECT  contratoParcelamento AS contratoParcelamento " + "FROM  ContratoParcelamento contratoParcelamento "
					+ "INNER JOIN FETCH contratoParcelamento.parcelamentoSituacao parcelamentoSituacao "
					+ "LEFT JOIN FETCH contratoParcelamento.contratoAnterior contratoAnterior "
					+ "LEFT JOIN FETCH contratoParcelamento.relacaoAnterior relacaoAnterior "
					+ "LEFT JOIN FETCH contratoParcelamento.usuarioResponsavel usuarioResponsavel "
					+ "LEFT JOIN FETCH contratoParcelamento.relacaoCliente relacaoCliente "
					+ "LEFT JOIN FETCH contratoParcelamento.resolucaoDiretoria resolucaoDiretoria "
					+ "LEFT JOIN FETCH contratoParcelamento.cobrancaForma cobrancaForma "
					+ "LEFT JOIN FETCH contratoParcelamento.motivoDesfazer motivoDesfazer "

					+ "WHERE contratoParcelamento.numero = :numeroParcelamento ";

			retorno = (ContratoParcelamento) session.createQuery(consulta).setString("numeroParcelamento", numeroParcelamento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1140] Cancelar Contrato de Parcelamento por Cliente
	 * 
	 * @author Rômulo Aurélio, Mariana Victor
	 * @throws ErroRepositorioException
	 * @date 12/05/2011, 18/07/2011
	 */
	public Collection pesquisarDebitoContratoParcelamentoPorTipoDocumento(ContratoParcelamento contratoParcelamento, Integer idDocumentoTipo)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = "SELECT  contratoParcelamentoItem AS contratoParcelamentoItem "
					+ "FROM  ContratoParcelamentoItem contratoParcelamentoItem "
					+ " LEFT JOIN fetch contratoParcelamentoItem.contrato contratoParcelamento "
					+ " LEFT JOIN fetch contratoParcelamentoItem.contaGeral contageral "
					+ " LEFT JOIN fetch contratoParcelamentoItem.guiaPagamentoGeral guiaPagamentoGeral "
					+ " LEFT JOIN fetch guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ " LEFT JOIN fetch contratoParcelamentoItem.debitoACobrarGeral debitoACobrarGeral "
					+ " LEFT JOIN fetch debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "WHERE contratoParcelamento.numero = :numeroParcelamento " + " and contratoParcelamentoItem.documentoTipo.id = "
					+ idDocumentoTipo + " "
					+ " and contratoParcelamentoItem.valorItem not in (select  coalesce(sum(prestacaoItem.valorPago), 0) "
					+ "  from PrestacaoItemContratoParcelamento prestacaoItem " + "  inner join prestacaoItem.prestacao b "
					+ "  where contratoParcelamento.id = b.contratoParcelamento.id "
					+ "  and contratoParcelamentoItem.id = prestacaoItem.item.id) ";

			retorno = (Collection) session.createQuery(consulta).setParameter("numeroParcelamento", contratoParcelamento.getNumero())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * Pesquisa os dados de um comando para exibir no popup
	 * 
	 * @author: Mariana Victor
	 * @date: 04/05/2011
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosPopupExtensaoComandoCobranca(Integer idComando) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "empre.empr_nmempresa as empresa, "// 0
					+ "cecc.cecc_dtiniciociclo as dataInicioCiclo, "// 1
					+ "cecc.cecc_dtfimciclo as dataFimCiclo, "// 2
					+ "cecc.cecc_dtexecucao as dataExecucao, "// 3
					+ "cecc.cecc_dtencerramento as dataEncerramento, "// 4
					+ "imov_id as imovel, "// 5
					+ "cli.clie_id as idCliente, "// 6
					+ "cli.clie_nmcliente as cliente, "// 7
					+ "cecc.cecc_icresidencial as icResidencial, "// 8
					+ "cecc.cecc_iccomercial as icComercial, "// 9
					+ "cecc.cecc_icindustrial as icIndustrial, "// 10
					+ "cecc.cecc_icpublico as icPublico, "// 11
					+ "iper.iper_id as idImovelPerfil, "// 12
					+ "iper.iper_dsimovelperfil as dsImovelPerfil, "// 13
					+ "greg.greg_id as idGerenciaRegional, "// 14
					+ "greg.greg_nmregional as dsGerenciaRegional, "// 15
					+ "uneg.uneg_id as idUneg, "// 16
					+ "uneg.uneg_nmunidadenegocio as nomeUneg, "// 17
					+ "loca_idinicial as locaIncial, "// 18
					+ "loca_idfinal as locaFinal, "// 19
					+ "cecc_cdsetorcomercialinicial as setorInicial, "// 20
					+ "cecc_cdsetorcomercialfinal as setorFinal, "// 21
					+ "cecc_nnquadrainicial as idQuadraInicial, "// 22
					+ "cecc_nnquadrafinal as idQuadraFinal, "// 23
					+ "cecc.cecc_amreferenciacontainicial as anoMesContaInicial, "// 24
					+ "cecc.cecc_amreferenciacontafinal as anoMesContaFinal, "// 25
					+ "cecc.cecc_dtvencimentocontainicial as vencimentoIncial, "// 26
					+ "cecc.cecc_dtvencimentocontafinal as vencimentoFinal, "// 27
					+ "cecc_vlminimoconta as vlMinino, "// 28
					+ "cecc_vlmaximoconta as vlMaximo, "// 29
					+ "emco.emco_id as idEmpContrCob, "// 30
					+ "emco.emco_pcpagamentodevido as pcPagDevido, "// 31
					+ "cecc.cecc_icgeracaotxt as indicadorGeracaoTxt, "// 32
					+ "cecc.cecc_qtdcontasinicial as qtdContasInicial, "// 33
					+ "cecc.cecc_qtdcontasfinal as qtdContasFinal, "// 34
					+ "cecc.cecc_qtddiasvencimento as qtdDiasVencimento, "// 35
					+ "las.last_dsligacaoaguasituacao as situacaoAgua "// 36
					+ "from cobranca.cmd_empr_cobr_conta cecc " 
					+ "inner join cadastro.empresa empre 						on cecc.empr_id = empre.empr_id "
					+ "left join cadastro.empr_contrato_cobranca emco 			on emco.empr_id = empre.empr_id "
					+ "left join cadastro.cliente cli 							on cli.clie_id = cecc.clie_id "
					
					+ "left join cobranca.cmd_empr_cobr_conta_uneg ceuneg 		on ceuneg.cecc_id = cecc.cecc_id "
					+ "left join cadastro.unidade_negocio uneg 					on uneg.uneg_id = ceuneg.uneg_id "

					+ "left join cobranca.cmd_empr_cobr_conta_per ceiper		on ceiper.cecc_id = cecc.cecc_id "
					+ "left join cadastro.imovel_perfil iper 					on iper.iper_id = ceiper.iper_id "
					
					+ "left join cobranca.cmd_empr_cobr_conta_ger cegreg 		on cegreg.cecc_id = cecc.cecc_id "
					+ "left join cadastro.gerencia_regional greg 				on greg.greg_id = cegreg.greg_id "
					
					+ "left join cobranca.cmd_empr_cobr_conta_last celas 	    on cecc.cecc_id = celas.cecc_id "
					+ "left join atendimentopublico.ligacao_agua_situacao las 	on celas.last_id = las.last_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta).addScalar("empresa", Hibernate.STRING).addScalar("dataInicioCiclo", Hibernate.DATE)
					.addScalar("dataFimCiclo", Hibernate.DATE).addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("dataEncerramento", Hibernate.DATE).addScalar("imovel", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER).addScalar("cliente", Hibernate.STRING)
					.addScalar("icResidencial", Hibernate.SHORT).addScalar("icComercial", Hibernate.SHORT)
					.addScalar("icIndustrial", Hibernate.SHORT).addScalar("icPublico", Hibernate.SHORT)
					.addScalar("idImovelPerfil", Hibernate.INTEGER).addScalar("dsImovelPerfil", Hibernate.STRING)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER).addScalar("dsGerenciaRegional", Hibernate.STRING)
					.addScalar("idUneg", Hibernate.INTEGER).addScalar("nomeUneg", Hibernate.STRING)
					.addScalar("locaIncial", Hibernate.INTEGER).addScalar("locaFinal", Hibernate.INTEGER)
					.addScalar("setorInicial", Hibernate.INTEGER).addScalar("setorFinal", Hibernate.INTEGER)
					.addScalar("idQuadraInicial", Hibernate.INTEGER).addScalar("idQuadraFinal", Hibernate.INTEGER)
					.addScalar("anoMesContaInicial", Hibernate.INTEGER).addScalar("anoMesContaFinal", Hibernate.INTEGER)
					.addScalar("vencimentoIncial", Hibernate.DATE).addScalar("vencimentoFinal", Hibernate.DATE)
					.addScalar("vlMinino", Hibernate.BIG_DECIMAL).addScalar("vlMaximo", Hibernate.BIG_DECIMAL)
					.addScalar("idEmpContrCob", Hibernate.INTEGER).addScalar("pcPagDevido", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorGeracaoTxt", Hibernate.INTEGER).addScalar("qtdContasInicial", Hibernate.INTEGER)
					.addScalar("qtdContasFinal", Hibernate.INTEGER).addScalar("qtdDiasVencimento", Hibernate.INTEGER)
					.addScalar("situacaoAgua", Hibernate.STRING).setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * - Pesquisa dados da cobrança
	 * 
	 * @author: Mariana Victor
	 * @date: 06/05/2011
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobrancaComandoEmpresa(Integer idComando) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select " + " ecc.ecco_vloriginalconta as valor" + " from cobranca.empresa_cobranca_conta ecc"
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ecc.cecc_id = cecc.cecc_id"
					+ " inner join faturamento.conta conta on ecc.cnta_id = conta.cnta_id " + " where cecc.cecc_id = :idComando"
					+ " and not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=ecc.cnta_id)"
					+ " and (conta.dcst_idatual in " + "(" + DebitoCreditoSituacao.NORMAL + ", " + DebitoCreditoSituacao.RETIFICADA + ", "
					+ DebitoCreditoSituacao.INCLUIDA + " )) ";

			retorno = session.createSQLQuery(consulta).addScalar("valor", Hibernate.BIG_DECIMAL).setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * Pesquisa a quantidade de contas, agrupando por imóvel
	 * 
	 * @author: Mariana Victor
	 * @date: 06/05/2011
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobrancaComandoEmpresaPorImovel(Integer idComando) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT COUNT(emprCobConta.imov_id)      AS qtdContas, "
					+ "  SUM(emprCobConta.ecco_vloriginalconta)     AS valorTotalDebitos "
					+ " FROM cobranca.empresa_cobranca_conta emprCobConta " + " WHERE emprCobConta.cecc_id = :idComando "
					+ "  and emprcobconta.ecco_icpagamentovalido = :indicadorPgValido " + " GROUP BY emprCobConta.imov_id ";

			retorno = session.createSQLQuery(consulta).addScalar("qtdContas", Hibernate.INTEGER)
					.addScalar("valorTotalDebitos", Hibernate.BIG_DECIMAL).setInteger("idComando", idComando)
					.setInteger("indicadorPgValido", ConstantesSistema.SIM).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobrança por Empresa
	 */
	public void atualizarIndicadorGeracaoTxt(Collection idsComandos) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "UPDATE gcom.cobranca.ComandoEmpresaCobrancaConta "
					+ "SET cecc_icgeracaotxt = :icGeracao, cecc_tmultimaalteracao = :ultimaAlteracao "
					+ "WHERE cecc_id in (:idsComandos)";

			session.createQuery(consulta)
					.setInteger("icGeracao", ConstantesSistema.SIM)
					.setTimestamp("ultimaAlteracao", new Date())
					.setParameterList("idsComandos", idsComandos)
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * [UC1168] Encerrar Comandos de Cobrança por Empresa
	 * 
	 * @author Mariana Victor
	 * @data 09/05/2011
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarDataEncerramentoComando(Integer idComando) throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "update gcom.cobranca.ComandoEmpresaCobrancaConta "
					+ " set cecc_dtencerramento = :dataEncerramento, cecc_tmultimaalteracao = :ultimaAlteracao "
					+ " where cecc_id = :idComando ";

			session.createQuery(consulta).setTimestamp("dataEncerramento", new Date()).setTimestamp("ultimaAlteracao", new Date())
					.setInteger("idComando", idComando).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * 
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Gerar OS
	 * 
	 * @author Mariana Victor
	 * @data 17/05/2011
	 */
	public Collection<Integer> pesquisarIdsImoveis(MovimentarOrdemServicoGerarOSHelper helper) throws ErroRepositorioException {

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select imov.imov_id as idImovel " + " from cadastro.imovel imov "
					+ "   inner join cobranca.empresa_cobranca_conta ecco on ecco.imov_id = imov.imov_id "
					+ "   inner join cobranca.cmd_empr_cobr_conta cecc on ecco.cecc_id = cecc.cecc_id "
					+ "   inner join cadastro.imovel_subcategoria imsb on imsb.imov_id = imov.imov_id "
					+ "   inner join cadastro.subcategoria scat on scat.scat_id = imsb.scat_id " + " where cecc.cecc_id = :idComando ";

			if (helper.getIdsCategoria() != null && helper.getIdsCategoria().length != 0) {
				consulta += "   and scat.catg_id in (";

				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					consulta += helper.getIdsCategoria()[i] + ", ";
				}
				// remove a virgula do final e coloca o parêntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getIdsImovelPerfil() != null && helper.getIdsImovelPerfil().length != 0) {
				consulta += "   and imov.iper_id in (";

				for (int i = 0; i < helper.getIdsImovelPerfil().length; i++) {
					consulta += helper.getIdsImovelPerfil()[i] + ", ";
				}
				// remove a virgula do final e coloca o parêntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getIdsLigacaoAguaSituacao() != null && helper.getIdsLigacaoAguaSituacao().length != 0) {
				consulta += "   and imov.last_id in (";

				for (int i = 0; i < helper.getIdsLigacaoAguaSituacao().length; i++) {
					consulta += helper.getIdsLigacaoAguaSituacao()[i] + ", ";
				}
				// remove a virgula do final e coloca o parêntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getValorMinimo() != null && helper.getValorMaximo() != null) {

				consulta = consulta + " and ( (select sum(ecc.ecco_vloriginalconta)  " + " from cobranca.empresa_cobranca_conta ecc "
						+ " where ecc.ecco_id = ecco.ecco_id) between :valorInicial and :valorFinal) ";
			}

			consulta = consulta + " group by imov.imov_id ";

			Query query = session.createSQLQuery(consulta).addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", helper.getIdComandoContaCobranca());

			if (helper.getValorMinimo() != null && helper.getValorMaximo() != null) {
				retorno = query.setBigDecimal("valorInicial", helper.getValorMinimo()).setBigDecimal("valorFinal", helper.getValorMaximo())
						.list();
			} else {
				retorno = query.list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Emitir OS Gerada pela Empresa
	 * 
	 * @author Mariana Victor
	 * @data 18/05/2011
	 */
	public Collection<Object[]> pesquisarDadosOSGeradasPelaEmpresa(Integer idComando, Integer idTipoServico)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select orse.orse_id as idOS, svtp.svtp_dsservicotipo as servicoTipo, orse.imov_id as idImovel, clie.clie_nmcliente as nomeCliente "
					+ " from cobranca.cmd_empr_cobr_conta cecc "
					+ "   inner join cadastro.unidade_organizacional unid on unid.empr_id = cecc.empr_id "
					+ "   inner join atendimentopublico.ordem_servico_unidade osun on unid.unid_id = osun.unid_id "
					+ "   inner join atendimentopublico.ordem_servico orse on osun.orse_id = orse.orse_id "
					+ "   inner join atendimentopublico.servico_tipo svtp on svtp.svtp_id = orse.svtp_id "
					+ "   inner join cadastro.cliente_imovel clim on clim.imov_id = orse.imov_id "
					+ "   inner join cadastro.cliente clie on clie.clie_id = clim.clie_id "
					+ " where cecc.cecc_id = :idComando "
					+ "   and osun.attp_id = 1 "
					+ "   and clim.crtp_id = 2 "
					+ "   and clim.clim_dtrelacaofim is null "
					+ "   and orse.orse_cdsituacao = 1 "
					+ "   and orse.orse_id not in (select eccc.orse_id from cobranca.empresa_cobranca_conta eccc where cecc.cecc_id = eccc.cecc_id) ";

			if (idTipoServico != null && idTipoServico.compareTo(new Integer(-1)) != 0) {
				consulta += "   and orse.svtp_id = " + idTipoServico;
			}

			consulta = consulta + " group by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente "
					+ " order by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente ";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("servicoTipo", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING).setInteger("idComando", idComando)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Emitir OS de Registro de Atendimento
	 * 
	 * @author Mariana Victor
	 * @data 18/05/2011
	 */
	public Collection<Object[]> pesquisarDadosOSRegistroAtendimento(Integer idComando, Integer idTipoServico)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select distinct(orse.orse_id) as idOS, svtp.svtp_dsservicotipo as servicoTipo, orse.imov_id as idImovel, clie.clie_nmcliente as nomeCliente "
					+ " from cobranca.cmd_empr_cobr_conta cecc "
					+ "   inner join cadastro.unidade_organizacional unid on unid.empr_id = cecc.empr_id "
					+ "   inner join atendimentopublico.tramite tram on tram.unid_iddestino = unid.unid_id "
					+ "   inner join atendimentopublico.ordem_servico orse on tram.rgat_id = orse.rgat_id "
					+ "   inner join atendimentopublico.servico_tipo svtp on svtp.svtp_id = orse.svtp_id "
					+ "   inner join cadastro.cliente_imovel clim on clim.imov_id = orse.imov_id "
					+ "   inner join cadastro.cliente clie on clie.clie_id = clim.clie_id "
					+ " where cecc.cecc_id = :idComando "
					+ "   and clim.crtp_id = 2 " + "   and clim.clim_dtrelacaofim is null " + "   and orse.orse_cdsituacao = 1 ";

			if (idTipoServico != null && idTipoServico.compareTo(new Integer(-1)) != 0) {
				consulta += "   and orse.svtp_id = " + idTipoServico;
			}

			consulta = consulta + " group by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente "
					+ " order by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente ";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("servicoTipo", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING).setInteger("idComando", idComando)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * obtem contas em débito do imóvel, comparando a data de vencimento
	 * original usado no emitir contas da CAEMA
	 * 
	 * Author: Vivianne Sousa Data: 15/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImovelDataVencimentoOriginal(Integer idImovel, int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada, String contaSituacaoIncluida, String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito, Date anoMesInicialVecimentoDebito, Date anoMesFinalVencimentoDebito,
			int indicadorDividaAtiva) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id = :idImovel "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentooriginal between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal", new Integer(contaSituacaoNormal))
					.setInteger("situacaoRetificada", new Integer(contaSituacaoRetificada))
					.setInteger("situacaoIncluida", new Integer(contaSituacaoIncluida))
					.setInteger("inicialReferencia", new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia", new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito).setDate("finalVencimento", anoMesFinalVencimentoDebito)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobrança
	 * 
	 * Consulta chamada pelo "[FS0006  Validar Comando]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public ComandoEmpresaCobrancaConta pesquisarComandoEmpresaCobrancaConta(Integer idComando) throws ErroRepositorioException {

		ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = null;
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT empr_id AS idEmpresa, " // 0
					+ "    cecc_dtencerramento AS dataEncerramento, " // 1
					+ "    cecc_icgeracaotxt AS icGeracaoArqTxt " // 2
					+ "  FROM cobranca.cmd_empr_cobr_conta " + "  WHERE cecc_id = :idComando ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("dataEncerramento", Hibernate.DATE).addScalar("icGeracaoArqTxt", Hibernate.INTEGER)
					.setInteger("idComando", idComando).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		if (retorno != null) {
			comandoEmpresaCobrancaConta = new ComandoEmpresaCobrancaConta();

			comandoEmpresaCobrancaConta.setId(idComando);

			if (retorno[0] != null) {
				Empresa empresa = new Empresa();
				empresa.setId((Integer) retorno[0]);

				comandoEmpresaCobrancaConta.setEmpresa(empresa);
			}

			if (retorno[1] != null) {
				comandoEmpresaCobrancaConta.setDataEncerramento((Date) retorno[1]);
			}

			if (retorno[2] != null) {
				comandoEmpresaCobrancaConta.setIndicadorGeracaoTxt((Integer) retorno[2]);
			}

		}

		return comandoEmpresaCobrancaConta;

	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobrança
	 * 
	 * Consulta chamada pelo "[FS0007  Validar OS]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public Short pesquisarSituacaoOrdemServico(Integer numeroOS) throws ErroRepositorioException {

		Short retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT orse_cdsituacao AS situacao " // 0
					+ "  FROM atendimentopublico.ordem_servico " + "  WHERE orse_id = :numeroOS ";

			retorno = (Short) session.createSQLQuery(consulta).addScalar("situacao", Hibernate.SHORT).setInteger("numeroOS", numeroOS)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobrança
	 * 
	 * Consulta chamada pelo "[FS0007  Validar OS]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public Boolean verificarOrdemServicoComando(Integer numeroOS, Integer idComando) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(*) AS quantidade " // 0
					+ "  FROM cobranca.empresa_cobranca_conta " + "  WHERE cecc_id = :idComando " + "    AND orse_id = :numeroOS ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idComando", idComando).setInteger("numeroOS", numeroOS).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		if (retorno != null && retorno.compareTo(new Integer(0)) > 0) {
			return true;
		}

		return false;

	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * @author Paulo Diniz
	 * @throws ErroRepositorioException
	 * @data 30/06/2011
	 */
	public List<Object[]> pesquisarOrdensServicoContasPagasParceladas() throws ErroRepositorioException {
		List<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select orse.orse_id as orse_id, cecc.cecc_id as cecc_id  " + "from COBRANCA.cmd_empr_cobr_conta cecc "
					+ "inner join COBRANCA.empresa_cobranca_conta ecco on ecco.cecc_id = cecc.cecc_id  "
					+ "inner join ATENDIMENTOPUBLICO.ordem_servico orse on ecco.orse_id = orse.orse_id "
					+ "inner join CADASTRO.imovel imov on orse.imov_id = imov.imov_id "
					+ "inner join FATURAMENTO.conta cnta on cnta.cnta_id = ecco.cnta_id "
					+ "where cecc.cecc_dtexecucao is not null and cecc.cecc_dtencerramento is null and cecc.cecc_icgeracaotxt = 1  and ( "
					+ "exists (select pgmt.cnta_id from arrecadacao.pagamento pgmt  " + "where pgmt.cnta_id=ecco.cnta_id)"
					+ " or exists (select pghi.cnta_id from arrecadacao.pagamento_historico pghi" + " where pghi.cnta_id=ecco.cnta_id) "
					+ " or cnta.dcst_idatual = 5" + " or exists (select cnhi.cnta_id from FATURAMENTO.conta_historico cnhi "
					+ "where cnhi.cnta_id=ecco.cnta_id and cnhi.dcst_idatual = 5 )" + ") group by orse.orse_id,  cecc.cecc_id ";

			retorno = session.createSQLQuery(consulta).addScalar("orse_id", Hibernate.INTEGER).addScalar("cecc_id", Hibernate.INTEGER)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1186] Gerar Relatório Ordem de Serviço Cobrança p/Resultado
	 * 
	 * Pesquisar EmpresaCobrancaConta a partir do imóvel
	 * 
	 * @author Hugo Azevedo
	 * @data 02/07/2011
	 */

	public Collection obterColecaoEmpresaCobrancaContaResultadoporImovel(Integer id) throws ErroRepositorioException {
		Session sessao = HibernateUtil.getSession();
		Collection retorno = new ArrayList();

		try {

			Criteria crit = sessao.createCriteria(EmpresaCobrancaConta.class);
			crit.setFetchMode("imovel", FetchMode.JOIN);
			crit.setFetchMode("contaGeral", FetchMode.JOIN);
			crit.setFetchMode("contaGeral.conta", FetchMode.JOIN);
			crit.setFetchMode("contaGeral.contaHistorico", FetchMode.JOIN);
			crit.setFetchMode("contaGeral.conta.debitoCreditoSituacaoAtual", FetchMode.JOIN);
			crit.setFetchMode("contaGeral.contaHistorico.debitoCreditoSituacaoAtual", FetchMode.JOIN);
			crit.add(Restrictions.eq("imovel.id", id));

			retorno = crit.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(sessao);
		}

		return retorno;

	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 * */
	public Collection<Object[]> pesquisarEmpresasComandosCobrancaAtivosExecutados() throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT distinct cecc.empr_id AS idEmpresa, empr.empr_dsemail AS emailEmpresa "
					+ "  FROM cobranca.cmd_empr_cobr_conta cecc " + "    INNER JOIN cadastro.empresa empr ON empr.empr_id = cecc.empr_id "
					+ "  WHERE cecc.cecc_dtexecucao is not null " + "    AND cecc.cecc_dtencerramento is null "
					+ "    AND cecc.cecc_icgeracaotxt = 1 ";

			retorno = session.createSQLQuery(consulta).addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("emailEmpresa", Hibernate.STRING).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2. O sistema deverá verificar todos os comandos de cobrança por
	 * resultados ativos e executados
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Collection<Integer> pesquisarComandosCobrancaAtivosExecutados(Integer idEmpresa) throws ErroRepositorioException {

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cecc.cecc_id AS idComando " + "   FROM cobranca.cmd_empr_cobr_conta cecc "
					+ " WHERE cecc.cecc_dtexecucao is not null " + "   AND cecc.cecc_dtencerramento is null "
					+ "   AND cecc.cecc_icgeracaotxt = 1 " + "   AND cecc.empr_id = :idEmpresa ";

			retorno = session.createSQLQuery(consulta).addScalar("idComando", Hibernate.INTEGER).setInteger("idEmpresa", idEmpresa).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2.1. Para cada comando selecionado o sistema deverá selecionar os ordens
	 * de serviço ativas associadas ao mesmo
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Collection<Object[]> pesquisarOrdensServicoAtivasComando(Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT distinct orse.orse_id AS idOS, ecco.imov_id AS idImovel " + "  FROM ATENDIMENTOPUBLICO.ordem_servico orse "
					+ "    INNER JOIN cobranca.empresa_cobranca_conta ecco ON ecco.orse_id = orse.orse_id "
					+ "  WHERE ecco.cecc_id = :idComando " + "    AND orse.orse_cdsituacao = 1 ";

			retorno = session.createSQLQuery(consulta).addScalar("idOS", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", idComando).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2.1.1. Para cada Ordem de Serviço selecionada, o sistema deverá verificar
	 * se as contas associadas ao imóvel da ordem de serviço estão quitadas ou
	 * parceladas
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Boolean verificarExisteContasEmAberto(Integer idOS) throws ErroRepositorioException {

		Boolean retorno = null;
		Integer dados = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(ecco.cnta_id) AS quantidadeConta "
					+ "  FROM cobranca.empresa_cobranca_conta ecco "
					+ "  WHERE ecco.orse_id = :idOS "
					+ "    AND ( NOT EXISTS (SELECT pgmt.cnta_id FROM arrecadacao.pagamento pgmt WHERE pgmt.cnta_id = ecco.cnta_id) "
					+ "    AND NOT EXISTS (SELECT pghi.cnta_id FROM arrecadacao.pagamento_historico pghi WHERE pghi.cnta_id = ecco.cnta_id) "
					+ "    AND NOT EXISTS (SELECT cnta.cnta_id FROM faturamento.conta cnta WHERE cnta.cnta_id = ecco.cnta_id AND cnta.dcst_idatual = 5) "
					+ "    AND NOT EXISTS (SELECT cntahi.cnta_id FROM faturamento.conta_historico cntahi WHERE cntahi.cnta_id = ecco.cnta_id AND cntahi.dcst_idatual = 5)) ";

			dados = (Integer) session.createSQLQuery(consulta).addScalar("quantidadeConta", Hibernate.INTEGER).setInteger("idOS", idOS)
					.setMaxResults(1).uniqueResult();

			if (dados == null || dados.compareTo(new Integer(0)) == 0) {
				retorno = false;
			} else {
				retorno = true;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param idDebitoACobrar
	 * 
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean verificaDebitoACobrarVinculadoAContratoParcelAtivo(Integer idDebitoACobrar) throws ErroRepositorioException {

		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeDebitosACobrar = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from cobranca.contrato_parcel_item item "
					+ "inner join cobranca.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.dbac_id = :idDebitoACobrar and cpar.pcst_id = " + ParcelamentoSituacao.NORMAL;

			quantidadeDebitosACobrar = (Integer) session.createSQLQuery(consulta).addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idDebitoACobrar", idDebitoACobrar).setMaxResults(1).uniqueResult();

			if (quantidadeDebitosACobrar != null && quantidadeDebitosACobrar > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0020] - Processar Pagamento de Contrato Parcelamento
	 * 
	 * @author Mariana Victor
	 * @data 03/08/2011
	 */
	public Object[] obterDadosDocumentoCobrancaItemContratoParcelamento(Integer idPrestacao) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cdit.cdit_vlitemcobrado AS valorItem, " + "   cppr.cppr_nnprestacao AS numeroPrestacao, "
					+ "   cppr.cpar_id AS idContrato " + " FROM cobranca.cobranca_documento_item cdit "
					+ "   INNER JOIN cobranca.contrato_parcel_prest cppr ON cppr.cppr_id = cdit.cppr_id "
					+ " WHERE cdit.cppr_id = :idPrestacao ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.addScalar("numeroPrestacao", Hibernate.INTEGER).addScalar("idContrato", Hibernate.INTEGER)
					.setInteger("idPrestacao", idPrestacao).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa Pesquisa dados do
	 * popup
	 * 
	 * @author Hugo Azevedo
	 * @date 25/08/2011
	 */

	public Collection pesquisarDadosPopupExtensaoComandoAguaSituacao(Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT las.last_id AS id," + " las.last_dsligacaoaguasituacao as descricao "
					+ " from cobranca.cmd_empr_cobr_conta_last cecc "
					+ " inner join atendimentopublico.ligacao_agua_situacao las on cecc.last_id = las.last_id "
					+ " where cecc.cecc_id = :idComando";

			retorno = session.createSQLQuery(consulta).addScalar("id", Hibernate.INTEGER).addScalar("descricao", Hibernate.STRING)
					.setInteger("idComando", idComando).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 0869] Gerar Arqv Texto das Contas em Cobrança por Empresa
	 * 
	 * @author Paulo Diniz
	 * @data 03/08/2011
	 * 
	 */
	public Object[] pesquisarDadosQtdContasEDiasVencidos(Integer idComando) throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cecc.CECC_QTDCONTASINICIAL AS qtdContasInicial, " 
					+ "   cecc.cecc_qtdcontasfinal AS qtdContasFinal, "
					+ "   cecc.CECC_QTDDIASVENCIMENTO AS qtdDiasVencidos "
					+ " FROM cobranca.cmd_empr_cobr_conta cecc "
					+ " WHERE cecc.cecc_id = :idComando ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("qtdContasInicial", Hibernate.INTEGER)
					.addScalar("qtdContasFinal", Hibernate.INTEGER)
					.addScalar("qtdDiasVencidos", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0869] Gerar Arqv Texto das Contas em Cobrança por Empresa
	 * 
	 * @author Paulo Diniz
	 * @data 03/08/2011
	 * 
	 */
	public Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao> pesquisarColecaoLigacaoAguaSituacaoPorComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao> retorno = null;
		String consulta;

		try {
			consulta = "select \n " + "	comandoLigacao \n " + "from \n "
					+ "   CmdEmpresaCobrancaContaLigacaoAguaSituacao comandoLigacao \n "
					+ "   inner join fetch comandoLigacao.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta \n "
					+ "   inner join fetch comandoLigacao.ligacaoAguaSituacao ligacaoAguaSituacao \n "
					+ "where comandoEmpresaCobrancaConta.id = :idComando";

			retorno = (Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao>) session.createQuery(consulta)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente
	 * 
	 * @author Raphael Rossiter
	 * @date 19/09/2011
	 * 
	 * @param idImovel
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short obterIndicadorAcrescimosClienteResponsavel(Integer idImovel) throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select cli.indicadorAcrescimos from ClienteImovel cliImo " + "inner join cliImo.clienteRelacaoTipo crt "
					+ "inner join cliImo.cliente cli " + "inner join cliImo.imovel imo " + "where imo.id = :idImovel AND "
					+ "crt.id = :idResponsavel AND " + "cliImo.dataFimRelacao is null ";
			retorno = (Short) session.createQuery(consulta).setInteger("idImovel", idImovel)
					.setInteger("idResponsavel", ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente
	 * 
	 * @author Raphael Rossiter
	 * @date 19/09/2011
	 * 
	 * @param idImovel
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short obterIndicadorAcrescimosCliente(Integer idCliente) throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select clie.indicadorAcrescimos from Cliente clie " + "where clie.id = :idCliente ";

			retorno = (Short) session.createQuery(consulta).setInteger("idCliente", idCliente).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoEmitirEtiquetasEnderecoAlternativo(Integer idCobrancaAcaoCronograma,
			Integer idCobrancaAcaoComando, Date dataEmissao, Integer idCobrancaAcao) throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo " + "LEFT JOIN fetch cbdo.empresa as empr "
					+ "LEFT JOIN fetch cbdo.localidade as loca " + "LEFT JOIN fetch loca.unidadeNegocio as uneg "
					+ "LEFT JOIN fetch loca.enderecoReferencia as enderecoReferenciaLocalidade "
					+ "LEFT JOIN fetch loca.logradouroCep as logCepLocalidade " + "LEFT JOIN fetch logCepLocalidade.cep as cepLocalidade "
					+ "LEFT JOIN fetch logCepLocalidade.logradouro as logLocalidade "
					+ "LEFT JOIN fetch logLocalidade.logradouroTipo as logTipoLocalidade "
					+ "LEFT JOIN fetch logLocalidade.logradouroTitulo as logTituloLocalidade "
					+ "LEFT JOIN fetch loca.logradouroBairro as logBairroLocalidade "
					+ "LEFT JOIN fetch logBairroLocalidade.bairro as bairroLocalidade "
					+ "LEFT JOIN fetch bairroLocalidade.municipio as municipioLocalidade "
					+ "LEFT JOIN fetch municipioLocalidade.unidadeFederacao as unidadeFederacaoLocalidade "
					+ "LEFT JOIN fetch cbdo.imovel as imov " + "LEFT JOIN fetch imov.leituraAnormalidade as ltan "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro " + "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun " + "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep " + "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo " + "LEFT JOIN fetch log.logradouroTitulo " + "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia " + "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao " + "LEFT JOIN fetch cbdo.quadra qdr " + "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo " + "LEFT JOIN fetch cbdo.imovelPerfil " + "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional " + "LEFT JOIN fetch imov.ligacaoAgua.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN fetch hih.hidrometro " + "LEFT JOIN fetch hih.hidrometroLocalInstalacao " + "WHERE ";

			if (idCobrancaAcaoCronograma != null && !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeCronograma.id = " + idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null && !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = " + idCobrancaAcaoComando;
			}
			consulta = consulta + " AND cbdo.emissao = :dataEmissao AND " + " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY loca.id, cbdo.codigoSetorComercial, rot.codigo, imov.numeroSequencialRota, "
					+ "cbdo.numeroQuadra, imov.lote, imov.subLote, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
					.setInteger("idCorteAdministrativoOUFisico", idCobrancaAcao).setTimestamp("dataEmissao", dataEmissao).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public void atualizarDocumentoDeCobrancaHistorico(Integer codigoImovel, Integer codigoParcelamento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String consulta;
		List lista = null;

		try {

			consulta = " select cd.* as id from cobranca.cobranca_documento_item cdi "
					 + " inner join faturamento.credito_a_realizar credito on credito.crar_id = cdi.crar_id "
					 + " inner join cobranca.cobranca_documento cd on cd.cbdo_id = cdi.cbdo_id "
					 + " where credito.parc_id = :codigoParcelamento and credito.imov_id = :codigoImovel ";
			
			lista = session.createSQLQuery(consulta)
					.addEntity(CobrancaDocumento.class)
					.setInteger("codigoImovel", codigoImovel)
					.setInteger("codigoParcelamento", codigoParcelamento)
					.list();
			
			if(lista.size() == 0) {
				consulta = " select cd.* from cobranca.cobranca_documento_item cdi "
						 + " inner join faturamento.debito_a_cobrar debito on debito.dbac_id = cdi.dbac_id "
						 + " inner join cobranca.cobranca_documento cd on cd.cbdo_id = cdi.cbdo_id "
						 + " where debito.parc_id = :codigoParcelamento and debito.imov_id = :codigoImovel ";
				
				lista = session.createSQLQuery(consulta)
						.addEntity(CobrancaDocumento.class)
						.setInteger("codigoImovel", codigoImovel.intValue())
						.setInteger("codigoParcelamento", codigoParcelamento.intValue())
						.list();
			}			
			
			if(lista.size() == 0) {
				consulta = consulta = " select cd.* from cobranca.cobranca_documento_item cdi "
						 + " inner join faturamento.guia_pagamento guia on guia.gpag_id = cdi.gpag_id "
						 + " inner join cobranca.cobranca_documento cd on cd.cbdo_id = cdi.cbdo_id "
						 + " where guia.parc_id = :codigoParcelamento and guia.imov_id = :codigoImovel ";
				
				lista = session.createSQLQuery(consulta)
						.addEntity(CobrancaDocumento.class)
						.setInteger("codigoImovel", codigoImovel.intValue())
						.setInteger("codigoParcelamento", codigoParcelamento.intValue())
						.list();
			}
			
			if (lista != null && !lista.isEmpty()) {

				CobrancaDocumento item = (CobrancaDocumento) lista.get(0);
				
				CobrancaDocumentoHistorico cobrancaDocumentoHistorico = new CobrancaDocumentoHistorico(
						item.getId(),
						item.getNumeroSequenciaDocumento(),
						item.getEmissao(),
						item.getValorDesconto(),
						item.getNumeroQuadra(),
						item.getValorDocumento(),
						item.getValorTaxa(),
						item.getCodigoSetorComercial(),
						item.getUltimaAlteracao(),
						item.getDocumentoEmissaoForma(),
						item.getCobrancaAcaoAtividadeComando(),
						item.getImovel(),
						item.getEmpresa(),
						item.getDocumentoTipo(),
						item.getImovelPerfil(),
						item.getQuadra(),
						item.getLocalidade(),
						item.getCobrancaAcaoAtividadeCronograma(),
						item.getMotivoNaoEntregaDocumento(),
						item.getCobrancaCriterio(),
						item.getCobrancaAcao(),
						item.getValorAcrescimos(),
						item.getDataSituacaoAcao(),
						item.getDataSituacaoDebito(),
						item.getSequencialImpressao(),
						item.getIndicadorAntesApos(),
						item.getIndicadorLimite(),
						item.getCobrancaDebitoSituacao(),
						item.getCobrancaAcaoSituacao(),
						item.getCliente(),
						item.getCategoria(),
						item.getEsferaPoder(),
						item.getFiscalizacaoSituacao(),
						item.getMotivoEncerramento(),
						item.getResolucaoDiretoria());

				session.save(cobrancaDocumentoHistorico);
				session.flush();
				session.clear();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	public BigDecimal getPercentualDescontoPorFaixa(Integer referencia) throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		String consulta;
		BigDecimal valorDesconto;

		try {

			consulta = "SELECT pfds_percentual_desconto as percentual "
					+ "FROM cobranca.parcelamento_faixa_desconto "
					+ "WHERE pfds_referencia_minima <= :referencia AND pfds_referencia_maxima >= :referencia ";

			valorDesconto = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("percentual", Hibernate.BIG_DECIMAL)
					.setInteger("referencia", referencia)
					.setMaxResults(1)
					.uniqueResult();
			
			if (valorDesconto == null)
				valorDesconto = new BigDecimal(0.0);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return valorDesconto;
	}
	
	public boolean isParcelamentoEfetivado(Integer idParcelamento) throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();
		boolean efetivado = false;

		try {

			consulta.append("SELECT pagamento from Pagamento pagamento ")
					.append("INNER JOIN pag.guiaPagamento guia ")
					.append("WHERE guia.parcelamento.id = :idParcelamento ")
					.append("AND guia.debitoTipo.id = :entradaParcelamento ");

			Pagamento pagamento = (Pagamento) session.createQuery(consulta.toString())
					.setInteger("idParcelamento", idParcelamento)
					.setInteger("entradaParcelamento", DebitoTipo.ENTRADA_PARCELAMENTO)
					.setMaxResults(1)
					.uniqueResult();
			
			if (pagamento != null)
				efetivado = true;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return efetivado;
	}
	
	public List<Parcelamento> obterParcelamentosCobrancaEmpresa(Integer idEmpresa) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		List<Parcelamento> retorno = new ArrayList<Parcelamento>();
		
		StringBuilder consulta = new StringBuilder();

		try {
			
			consulta.append(" select distinct parcelamento.* ") 
					.append(" from cobranca.parcelamento_item item  ")
					.append(" inner join cobranca.parcelamento parcelamento on parcelamento.parc_id = item.parc_id ")
					.append(" where item.cnta_id in (select cnta_id from cobranca.empresa_cobranca_conta where empr_id = :idEmpresa) ") 
					.append(" and parcelamento.pcst_id = :normal ")
					.append(" and parcelamento.parc_id not in  (select negociacao.parc_id from cobranca.negociacao_cobranca_empresa negociacao ) "); 

			retorno = (List<Parcelamento>) session.createSQLQuery(consulta.toString())
					.addEntity(Parcelamento.class)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("normal", ParcelamentoSituacao.NORMAL)
					.list();
			
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public List<CobrancaDocumento> obterExtratosCobrancaEmpresa(Integer idEmpresa) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		List<CobrancaDocumento> retorno = new ArrayList<CobrancaDocumento>();

		StringBuilder consulta = new StringBuilder();

		try {
			
			this.aumentarMemoriaPostgres(session);
			
			consulta.append(" select distinct documento.* ") 
					.append(" from cobranca.cobranca_documento_item item  ")
					.append(" inner join cobranca.cobranca_documento documento on documento.cbdo_id = item.cbdo_id ")
					.append(" where item.cnta_id in (select cnta_id from cobranca.empresa_cobranca_conta where empr_id = :idEmpresa) ") 
					.append(" and documento.cbdo_id not in ")
					.append(" 			(select negociacao.cbdo_id ")
					.append(" 			 from cobranca.negociacao_cobranca_empresa negociacao ")
					.append(" 			 where negociacao.cbdo_id is not null )")
					.append(" and documento.dotp_id = :extrato "); 

			retorno = (List<CobrancaDocumento>) session.createSQLQuery(consulta.toString())
					.addEntity(CobrancaDocumento.class)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("extrato", DocumentoTipo.EXTRATO_DE_DEBITO)
					.list();
			
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	private void aumentarMemoriaPostgres(Session session) throws ErroRepositorioException {
		Connection con = session.connection();
		try {
			con.createStatement().executeUpdate("set local work_mem='100MB';");
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro ao aumntar memoria da consulta");
		} 
	}
	
	public List<GuiaPagamentoGeral> obterGuiasCobrancaEmpresa(Integer idEmpresa) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		List<GuiaPagamentoGeral> retorno = new ArrayList<GuiaPagamentoGeral>();
		
		StringBuilder consulta = new StringBuilder();

		try {

			consulta.append(" select distinct guiaGeral.* ") 
					.append(" from faturamento.guia_pagamento_item item  ")
					.append(" inner join faturamento.guia_pagamento guia on guia.gpag_id = item.gpag_id ")
					.append(" inner join faturamento.guia_pagamento_geral guiaGeral on guiaGeral.gpag_id = guia.gpag_id ")
					.append(" where item.cnta_id in (select cnta_id from cobranca.empresa_cobranca_conta where empr_id = :idEmpresa) ") 
					.append(" and guia.gpag_id not in ")
					.append(" 			(select negociacao.gpag_id ")
					.append(" 			 from cobranca.negociacao_cobranca_empresa negociacao ")
					.append(" 			 where negociacao.gpag_id is not null ) ")
					.append(" and guia.dbtp_id = :parcelamento "); 

			retorno = (List<GuiaPagamentoGeral>) session.createSQLQuery(consulta.toString())
					.addEntity(GuiaPagamentoGeral.class)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("parcelamento", DebitoTipo.PARCELAMENTO_CONTAS)
					.list();
			
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	
	public List<ContaGeral> obterContasParcelamentosCobrancaEmpresa(Integer idParcelamento, Integer idEmpresa) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		List<ContaGeral> retorno = new ArrayList<ContaGeral>();
		StringBuilder consulta = new StringBuilder();

		try {
//			consulta.append("select item.contaGeral ")
//					.append(" from ParcelamentoItem item ")
//					//.append(" inner join item.parcelamento parcelamento ")
//					//.append(" inner join item.conta conta ")
//					.append(" where item.contaGeral.id in (select contaGeral.id from EmpresaCobrancaConta where empresa.id = :idEmpresa) ")
//					.append(" and item.parcelamento.id = :idParcelamento ");
//
//			retorno = (List<ContaGeral>) session.createQuery(consulta.toString())
//							.setInteger("idEmpresa", idEmpresa)
//							.setInteger("idParcelamento", idParcelamento).list();

			consulta.append("select contaGeral.* ") 
			 .append(" from cobranca.parcelamento_item item ") 
			 .append(" inner join faturamento.conta_geral contaGeral on contaGeral.cnta_id = item.cnta_id ")
			 .append(" where item.cnta_id in (select cnta_id from cobranca.empresa_cobranca_conta where empr_id = :idEmpresa) ") 
			 .append(" and item.parc_id = :idParcelamento ");
			 
			retorno = (List<ContaGeral>) session.createSQLQuery(consulta.toString())
					.addEntity(ContaGeral.class)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("idParcelamento", idParcelamento).list();
					
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public List<ContaGeral> obterContasExtratosCobrancaEmpresa(Integer idExtrato, Integer idEmpresa) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		List<ContaGeral> retorno = new ArrayList<ContaGeral>();
		StringBuilder consulta = new StringBuilder();

		try {

			consulta.append("select contaGeral.* ") 
			 .append(" from cobranca.cobranca_documento_item item ") 
			 .append(" inner join faturamento.conta_geral contaGeral on contaGeral.cnta_id = item.cnta_id ")
			 .append(" where item.cnta_id in (select cnta_id from cobranca.empresa_cobranca_conta where empr_id = :idEmpresa) ") 
			 .append(" and item.cbdo_id = :idExtrato ");
			 
			retorno = (List<ContaGeral>) session.createSQLQuery(consulta.toString())
					.addEntity(ContaGeral.class)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("idExtrato", idExtrato).list();
					
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public List<ContaGeral> obterContasGuiaCobrancaEmpresa(Integer idGuia, Integer idEmpresa) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		List<ContaGeral> retorno = new ArrayList<ContaGeral>();
		StringBuilder consulta = new StringBuilder();

		try {

			consulta.append("select contaGeral.* ") 
			 .append(" from faturamento.guia_pagamento_item item ") 
			 .append(" inner join faturamento.conta_geral contaGeral on contaGeral.cnta_id = item.cnta_id ")
			 .append(" where item.cnta_id in (select cnta_id from cobranca.empresa_cobranca_conta where empr_id = :idEmpresa) ") 
			 .append(" and item.gpag_id = :idGuia ");
			 
			retorno = (List<ContaGeral>) session.createSQLQuery(consulta.toString())
					.addEntity(ContaGeral.class)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("idGuia", idGuia).list();
					
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	
	public Collection<ArquivoTextoNegociacaoCobrancaEmpresaHelper> pesquisarDadosArquivoTextoParcelamentosContasCobrancaEmpresa(Integer idEmpresa, Integer referenciaInicial,
			Integer referenciaFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<ArquivoTextoNegociacaoCobrancaEmpresaHelper> retorno = new ArrayList<ArquivoTextoNegociacaoCobrancaEmpresaHelper>();
		StringBuilder consultaMovimentoParcelamentos = new StringBuilder();
		StringBuilder consultaParcelamentos = new StringBuilder();

		try {

			// PARCELAMENTOS
			consultaParcelamentos.append(" (select parcelamento.id from ParcelamentoItem item ")
								.append(" inner join item.parcelamento parcelamento ")
								.append(" where item.conta in (select conta from EmpresaCobrancaConta )) ")
								.append(" and parcelamento.id not in (select movimento.idParcelamento from EmpresaCobrancaConta )) ");
			
			consultaMovimentoParcelamentos.append("select new GerarArquivoTextoMovimentoContasCobrancaEmpresaHelper ")
					.append(" (1, parcelamento.id, parcelamento.parcelamento, guia.dataVencimento, parcelamento.valorConta, parcelamento.valorDescontoAcrescimos,  ")
					.append("  parcelamento.valorEntrada, parcelamento.valorPrestacao, parcelamento.numeroPrestacoes) ")
					.append(" from GuiaPagamento guia ")
					.append(" inner join guia.parcelamento parcelamento")
					.append(" where  guia.documentoTipo.id = :entradaParcelamento ")
					.append(" and parcelamento.id in ")
					.append(consultaParcelamentos.toString())
					.append(" order by parcelamento.parcelamento ");

			retorno = session.createQuery(consultaMovimentoParcelamentos.toString())
							.setInteger("entradaParcelamento", DocumentoTipo.ENTRADA_DE_PARCELAMENTO)
							.list();


		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		System.out.println(retorno.size());
		return retorno;
	}
	
	public Collection<ArquivoTextoNegociacaoCobrancaEmpresaHelper> pesquisarDadosArquivoTextoExtratosContasCobrancaEmpresa(Integer idEmpresa, Integer referenciaInicial,
			Integer referenciaFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<ArquivoTextoNegociacaoCobrancaEmpresaHelper> retorno = new ArrayList<ArquivoTextoNegociacaoCobrancaEmpresaHelper>();

		StringBuilder consultaMovimentoExtratos = new StringBuilder();
		
		try {

			consultaMovimentoExtratos.append("select new GerarArquivoTextoMovimentoContasCobrancaEmpresaHelper ")
					.append(" (2, documento.id, documento.emissao, null, documento.valorDocumento, documento.valorDesconto, null, null, null) ")
					.append(" from CobrancaDocumentoItem item ")
					.append(" inner join item.cobrancaDocumento documento")
					.append(" where  documento.documentoTipo.id = :extrato ")
					.append(" and item.conta in (select conta from EmpresaCobrancaConta )) ")
					.append(" order by documento.emissao ");
			
			retorno = session.createQuery(consultaMovimentoExtratos.toString())
					.setInteger("extrato", DocumentoTipo.EXTRATO_DE_DEBITO)
					.list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public List<NegociacaoCobrancaEmpresa> obterNegociacoesEmpresa(List<Integer> idNegociacoes) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		List<NegociacaoCobrancaEmpresa> negociacoes = new ArrayList<NegociacaoCobrancaEmpresa>();

		StringBuilder consulta = new StringBuilder();
		
		try {

			consulta.append("select negociacao ")
					.append(" from NegociacaoCobrancaEmpresa negociacao ")
					.append(" left join  fetch negociacao.parcelamento parcelamento ")
					.append(" left join  fetch parcelamento.imovel imovel ")
					.append(" left join  fetch negociacao.parcelamento.cliente ")
					.append(" left join  fetch negociacao.cobrancaDocumento cobrancaDocumento ")
					.append(" left join  fetch cobrancaDocumento.imovel ")
					.append(" left join  fetch cobrancaDocumento.cliente ")
					.append(" left join  fetch negociacao.guiaPagamentoGeral guiaGeral ")
					.append(" left join  fetch guiaGeral.guiaPagamento guia ")
					.append(" left join  fetch guia.imovel ")
					.append(" left join  fetch guia.cliente ")
					.append(" left join  fetch guiaGeral.guiaPagamentoHistorico guiaHistorico ")
					.append(" left join  fetch guiaHistorico.imovel ")
					.append(" left join  fetch guiaHistorico.cliente ")
					.append(" where  negociacao.id in (:negociacoes) ");
			
			negociacoes = session.createQuery(consulta.toString())
					.setParameterList("negociacoes", idNegociacoes)
					.list();
			
			
			for (NegociacaoCobrancaEmpresa negociacao : negociacoes) {
				StringBuilder consultaContas = new StringBuilder();
				
				consultaContas.append("select distinct cotasNegociadas ")
								.append(" from NegociacaoContaCobrancaEmpresa cotasNegociadas ")
								.append(" left join  fetch cotasNegociadas.contaGeral ")
								.append(" where  cotasNegociadas.negociacao.id = :idNegociacao ");
		
				List<NegociacaoContaCobrancaEmpresa> contasNegociadas = session.createQuery(consultaContas.toString())
																				.setParameter("idNegociacao", negociacao.getId())
																				.list();
				
				negociacao.setContasNegociadas(contasNegociadas);
				
			}
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return negociacoes;
	}
	
	public void atualizarPagamentosCobrancaPorEmpresaGerados(List<Integer> idsPagamentos) throws ErroRepositorioException {
		StringBuilder consulta = new StringBuilder();
		Session session = HibernateUtil.getSession();

		try {
			consulta.append("update EmpresaCobrancaContaPagamentos ")
					.append(" set indicadorGeracaoArquivo = :arquivoGerado, ultimaAlteracao = :ultimaAlteracao ")
					.append(" where id in (:idsPagamentos) ");

			session.createQuery(consulta.toString())
					.setTimestamp("ultimaAlteracao", new Date())
					.setShort("arquivoGerado", ConstantesSistema.SIM)
					.setParameterList("idsPagamentos", idsPagamentos).executeUpdate();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	public Date obterDataVencimentoEntradaParcelamento(Integer idParcelamento) throws ErroRepositorioException {
		StringBuilder consulta = new StringBuilder();
		Session session = HibernateUtil.getSession();
		Date retorno = null;
		try {
			consulta.append("select guia.gpag_dtvencimento as vencimento ")
					.append(" from faturamento.guia_pagamento  guia ")
					.append(" where guia.parc_id = :idParcelamento ")
					.append(" and guia.fntp_id = :entrada ");

			retorno = (Date) session.createSQLQuery(consulta.toString())
					.addScalar("vencimento", Hibernate.DATE)
					.setInteger("idParcelamento", idParcelamento)
					.setInteger("entrada", FinanciamentoTipo.ENTRADA_PARCELAMENTO).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
			
	public Integer[] obterPeriodoContasParceladas(Integer idParcelamento) throws ErroRepositorioException {
		Integer[] retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();
	
		try {
			consulta.append("select min(conta.referencia) as menorReferencia, max(conta.referencia) as maiorReferencia")
					.append(" from ParcelamentoItem item ")
					.append(" inner join item.contaGeral contaGeral ")
					.append(" inner join contaGeral.conta conta ")
					.append(" where item.parcelamento.id = :idParcelamento ");
	
			Object[] referencias = (Object[]) session.createQuery(consulta.toString())
						.setInteger("idParcelamento", idParcelamento).setMaxResults(1).uniqueResult();
	
			retorno = new Integer[2];

			if (referencias[0] != null && referencias[1] != null) {
				retorno[0] = (Integer)referencias[0];
				retorno[1] = (Integer)referencias[1];
			} else {
				consulta = new StringBuilder();
				
				consulta.append("select min(contaHistorico.anoMesReferenciaConta) as menorReferencia, max(contaHistorico.anoMesReferenciaConta) as maiorReferencia")
				.append(" from ParcelamentoItem item ")
				.append(" inner join item.contaGeral contaGeral ")
				.append(" inner join contaGeral.contaHistorico contaHistorico ")
				.append(" where item.parcelamento.id = :idParcelamento ");
				
				referencias = (Object[]) session.createQuery(consulta.toString())
						.setInteger("idParcelamento", idParcelamento).setMaxResults(1).uniqueResult();
				
				retorno[0] = (Integer)referencias[0];
				retorno[1] = (Integer)referencias[1];
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	
		return retorno;
	}
	
	public Integer[] obterPeriodoDebitosParcelados(Integer idParcelamento) throws ErroRepositorioException {
		Integer[] retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();
	
		try {
			consulta.append("select min(debitoACobrar.anoMesReferenciaDebito) as menorReferencia, max(debitoACobrar.anoMesReferenciaDebito) as maiorReferencia")
					.append(" from ParcelamentoItem item ")
					.append(" inner join item.debitoACobrarGeral debitoGeral ")
					.append(" inner join debitoGeral.debitoACobrar debitoACobrar ")
					.append(" where item.parcelamento.id = :idParcelamento ");
	
		Object[] referencias = (Object[]) session.createQuery(consulta.toString())
					.setInteger("idParcelamento", idParcelamento).setMaxResults(1).uniqueResult();
	
		retorno = new Integer[2];
		
		retorno[0] = (Integer)referencias[0];
		retorno[1] = (Integer)referencias[1];
		
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	
		return retorno;
	}
	
	public void removerBoletoInfo(Integer idParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String delete;

		try {
			delete = "delete gcom.arrecadacao.BoletoInfo where parcelamento.id = :idParcelamento ";

			session.createQuery(delete).setInteger("idParcelamento", idParcelamento.intValue()).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	public Collection pesquisarParcelamentosSituacaoNormal(String parcelamentoSituacao, int numeroIncial, int numeroFinal) throws ErroRepositorioException {

	    Collection retorno = null;

	    Session session = HibernateUtil.getSession();
	    String consulta;

	    try {

	      consulta = "SELECT distinct parc.id, parc.parcelamento, imov.id  " + "FROM DebitoACobrar dbac "
	          + "INNER JOIN dbac.parcelamento parc " + "INNER JOIN parc.imovel imov "
	          + "WHERE parc.parcelamentoSituacao = :parcelamentoSituacao "
	          + "AND (parc.valorEntrada IS NOT NULL AND parc.valorEntrada > 0) " + "AND dbac.numeroPrestacaoCobradas = 0 "
	          + "AND dbac.debitoCreditoSituacaoAtual = :normal ";

	      retorno = session.createQuery(consulta).setInteger("parcelamentoSituacao", new Integer(parcelamentoSituacao))
	          .setInteger("normal", DebitoCreditoSituacao.NORMAL)
	          .setFirstResult(numeroIncial)
	          .setMaxResults(numeroFinal)
	          .list();

	    } catch (HibernateException e) {
	      // levanta a exceção para a próxima camada
	      throw new ErroRepositorioException(e, "Erro no Hibernate");
	    } finally {
	      // fecha a sessão
	      HibernateUtil.closeSession(session);
	    }

	    return retorno;
	  }
	
	public Parcelamento obterParcelamentoDaConta(Integer idConta, Integer idSituacao) throws ErroRepositorioException {
		Parcelamento retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try {
			consulta.append("SELECT parcelamento from ParcelamentoItem item ")
					.append(" inner join item.contaGeral conta ")
					.append(" inner join item.parcelamento parcelamento ")
					.append("WHERE parcelamento.parcelamentoSituacao.id = :idSituacao ")
					.append("AND conta.id = :idConta")
					.append(" order by parcelamento.parcelamento desc ");

			retorno = (Parcelamento) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setInteger("idSituacao", idSituacao)
					.setMaxResults(1).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
		
	public Parcelamento obterUltimoParcelamento(Integer idImovel) throws ErroRepositorioException {

	    Parcelamento retorno = null;

	    Session session = HibernateUtil.getSession();
	    StringBuilder consulta = new StringBuilder();

	    try {
	    	consulta.append("SELECT parc  FROM Parcelamento parc ")
  			.append("WHERE parc.imovel.id = :idImovel ")
  			.append("order by parc.parcelamento desc ");

	    	retorno = (Parcelamento) session.createQuery(consulta.toString())
	    			.setInteger("idImovel", idImovel)
	    			.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
		  throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
		  HibernateUtil.closeSession(session);
		}
	    return retorno;
	}

	public Collection<CobrancaAcaoAtividadeComando> obterListaAtividadesEventuaisAcaoCobrancaComandadasRecentes() throws ErroRepositorioException {

		Collection<CobrancaAcaoAtividadeComando> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuilder consulta = new StringBuilder();

		try {
			// constroi o hql
			consulta.append("select comando from CobrancaAcaoAtividadeComando comando ")
					.append(" inner join fetch comando.cobrancaAcao acao ")
					.append(" inner join fetch comando.cobrancaAtividade atividade ")
					.append(" inner join fetch comando.cobrancaCriterio criterio ")
					.append(" where comando.comando is not null ")
					.append(" and comando.dataEncerramentoRealizada is not null ")
					.append(" order by comando.realizacao desc ");

			// executa o hql
			retorno = new ArrayList(session.createQuery(consulta.toString()).setMaxResults(50).list());

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	public Collection pesquisarNumeroQuadraPorAtividadeComando(Integer idAtividadeComando) throws ErroRepositorioException {
		
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();

		String consulta;
		
		try {
			
			consulta = "Select DISTINCT cdoc.cbdo_nnquadra as numeroQuadra "
					 + "FROM cobranca.cobranca_documento AS cdoc "
					 + "WHERE cdoc.cacm_id = :idAtividadeComando";
					 
			retorno = session.createSQLQuery(consulta)
					 .addScalar("numeroQuadra", Hibernate.INTEGER)
					 .setInteger("idAtividadeComando", idAtividadeComando)
					 .list();
			
			
			
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
		
	}
	
	public Collection pesquisarAvisosParaNotificacao(Integer idRota) throws ErroRepositorioException {
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try {
			consulta.append("select cd.cbdo_id as idAviso,") //0
					.append(" c.clie_id as idCliente, ") //1
					.append(" c.clie_nmcliente as nomeCliente, ") //2
					.append(" c.clie_dsemail as email, ") //3
					.append(" cf.cfon_cdddd as ddd, ") //4
					.append(" cf.cfon_nnfone as celular ") //5
					.append(" from cobranca.cobranca_documento cd ")
					.append(" inner join cadastro.imovel i on i.imov_id = cd.imov_id ")
					.append(" inner join cadastro.cliente_imovel ci on ci.imov_id = i.imov_id  ")
					.append(" inner join cadastro.cliente c on c.clie_id = ci.clie_id ")
					.append(" inner join cadastro.quadra q on q.qdra_id = i.qdra_id ")
					.append(" left join cadastro.cliente_fone cf on cf.clie_id = c.clie_id  and cf.fnet_id = :celular and cf.cfon_icfonepadrao = :sim ")
					.append(" where cd.dotp_id = :avisoCorte ")
					.append(" and aviso.cbdo_tmemissao >= :dataEmissao")
					.append(" and ci.clim_dtrelacaofim is null and ci.clim_icnomeconta = :sim ")
					.append(" and q.rota_id = :idRota ")
					.append(" and c.clie_icenvioemail = :sim ");

			retorno = session.createSQLQuery(consulta.toString())
					.addScalar("idAviso", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("email", Hibernate.STRING)
					.addScalar("ddd", Hibernate.STRING)
					.addScalar("celular", Hibernate.STRING)
	    			.setDate("dataEmissao", new Date())
	    			.setInteger("avisoCorte", DocumentoTipo.AVISO_CORTE)
	    			.setInteger("celular", FoneTipo.CELULAR)
	    			.setShort("sim", ConstantesSistema.SIM)
	    			.setInteger("idRota", idRota)
	    			.list();

		} catch (HibernateException e) {
		  throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
		  HibernateUtil.closeSession(session);
		}
		return retorno;

	}
}
