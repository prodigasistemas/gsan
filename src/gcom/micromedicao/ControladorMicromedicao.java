package gcom.micromedicao;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.sql.Timestamp;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Vector;
import java.util.zip.ZipOutputStream;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.mail.SendFailedException;

import org.apache.commons.fileupload.FileItem;
import org.jboss.logging.Logger;

import gcom.atendimentopublico.IRepositorioAtendimentoPublico;
import gcom.atendimentopublico.RepositorioAtendimentoPublicoHBM;
import gcom.atendimentopublico.ligacaoagua.LigacaoAgua;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgoto;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.atendimentopublico.registroatendimento.FiltroRegistroAtendimento;
import gcom.atendimentopublico.registroatendimento.FiltroSolicitacaoTipoEspecificacao;
import gcom.atendimentopublico.registroatendimento.RegistroAtendimento;
import gcom.atendimentopublico.registroatendimento.SolicitacaoTipoEspecificacao;
import gcom.batch.FiltroFuncionalidadeIniciada;
import gcom.batch.FiltroProcessoIniciado;
import gcom.batch.FuncionalidadeIniciada;
import gcom.batch.FuncionalidadeSituacao;
import gcom.batch.Processo;
import gcom.batch.ProcessoIniciado;
import gcom.batch.ProcessoSituacao;
import gcom.batch.UnidadeProcessamento;
import gcom.cadastro.EnvioEmail;
import gcom.cadastro.cliente.Cliente;
import gcom.cadastro.cliente.ClienteImovel;
import gcom.cadastro.cliente.EsferaPoder;
import gcom.cadastro.cliente.IRepositorioClienteImovel;
import gcom.cadastro.cliente.RepositorioClienteImovelHBM;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.endereco.Logradouro;
import gcom.cadastro.endereco.LogradouroBairro;
import gcom.cadastro.funcionario.Funcionario;
import gcom.cadastro.funcionario.IRepositorioFuncionario;
import gcom.cadastro.funcionario.RepositorioFuncionarioHBM;
import gcom.cadastro.geografico.Bairro;
import gcom.cadastro.imovel.Categoria;
import gcom.cadastro.imovel.FiltroImovel;
import gcom.cadastro.imovel.IRepositorioImovel;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.imovel.ImovelPerfil;
import gcom.cadastro.imovel.ImovelRegistrarTransacaoHelper;
import gcom.cadastro.imovel.ImovelSubcategoria;
import gcom.cadastro.imovel.PavimentoCalcada;
import gcom.cadastro.imovel.PavimentoRua;
import gcom.cadastro.imovel.PocoTipo;
import gcom.cadastro.imovel.RepositorioImovelHBM;
import gcom.cadastro.imovel.Subcategoria;
import gcom.cadastro.imovel.bean.GerarRelatorioAnaliseImovelCorporativoGrandeHelper;
import gcom.cadastro.imovel.bean.ImovelMicromedicao;
import gcom.cadastro.localidade.FiltroLocalidade;
import gcom.cadastro.localidade.FiltroQuadra;
import gcom.cadastro.localidade.FiltroSetorComercial;
import gcom.cadastro.localidade.GerenciaRegional;
import gcom.cadastro.localidade.Localidade;
import gcom.cadastro.localidade.Quadra;
import gcom.cadastro.localidade.QuadraFace;
import gcom.cadastro.localidade.SetorComercial;
import gcom.cadastro.sistemaparametro.FiltroSistemaParametro;
import gcom.cadastro.sistemaparametro.NacionalFeriado;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cadastro.unidade.UnidadeOrganizacional;
import gcom.cobranca.CobrancaAcao;
import gcom.cobranca.CobrancaGrupo;
import gcom.cobranca.FiltroCobrancaAcao;
import gcom.cobranca.FiltroRotaAcaoCriterio;
import gcom.cobranca.RotaAcaoCriterio;
import gcom.cobranca.RotaAcaoCriterioHelper;
import gcom.cobranca.RotaAcaoCriterioPK;
import gcom.fachada.Fachada;
import gcom.faturamento.FaturamentoAtividade;
import gcom.faturamento.FaturamentoAtividadeCronograma;
import gcom.faturamento.FaturamentoGrupo;
import gcom.faturamento.FaturamentoParametro;
import gcom.faturamento.FaturamentoSituacaoHistorico;
import gcom.faturamento.FaturamentoSituacaoTipo;
import gcom.faturamento.FiltroFaturamentoGrupo;
import gcom.faturamento.FiltroFaturamentoImediatoAjuste;
import gcom.faturamento.FiltroFaturamentoSituacaoHistorico;
import gcom.faturamento.FiltroMovimentoContaPrefaturada;
import gcom.faturamento.IRepositorioFaturamento;
import gcom.faturamento.MotivoInterferenciaTipo;
import gcom.faturamento.MovimentoContaPrefaturada;
import gcom.faturamento.RepositorioFaturamentoHBM;
import gcom.faturamento.bean.DeterminarValoresFaturamentoAguaEsgotoHelper;
import gcom.faturamento.consumotarifa.ConsumoTarifa;
import gcom.faturamento.consumotarifa.ConsumoTarifaCategoria;
import gcom.faturamento.consumotarifa.ConsumoTarifaVigencia;
import gcom.faturamento.consumotarifa.FiltroConsumoTarifa;
import gcom.faturamento.conta.ContaCategoria;
import gcom.faturamento.conta.ContaCategoriaConsumoFaixa;
import gcom.faturamento.conta.ContaImpressao;
import gcom.faturamento.conta.FiltroContaCategoria;
import gcom.faturamento.conta.FiltroContaCategoriaConsumoFaixa;
import gcom.faturamento.conta.FiltroContaImpressao;
import gcom.faturamento.debito.DebitoCreditoSituacao;
import gcom.gui.faturamento.ImovelFaturamentoSeletivo;
import gcom.gui.faturamento.bean.AnalisarImoveisReleituraHelper;
import gcom.gui.micromedicao.ColetaMedidorEnergiaHelper;
import gcom.gui.micromedicao.DadosMovimentacao;
import gcom.gui.relatorio.micromedicao.FiltroRelatorioLeituraConsultarArquivosTextoHelper;
import gcom.gui.relatorio.micromedicao.RelatorioNotificacaoDebitosImpressaoSimultaneaHelper;
import gcom.interceptor.Interceptador;
import gcom.interceptor.RegistradorOperacao;
import gcom.micromedicao.bean.AnaliseConsumoRelatorioOSHelper;
import gcom.micromedicao.bean.AnormalidadeLeituraHelper;
import gcom.micromedicao.bean.AssociarConjuntoRotasCriterioCobrancaHelper;
import gcom.micromedicao.bean.ComparativoLeiturasEAnormalidadesRelatorioHelper;
import gcom.micromedicao.bean.ConsultarHistoricoMedicaoIndividualizadaHelper;
import gcom.micromedicao.bean.ConsumoHistoricoCondominio;
import gcom.micromedicao.bean.FaixasFalsasLeituraRelatorioHelper;
import gcom.micromedicao.bean.FiltrarLeiturasTelemetriaHelper;
import gcom.micromedicao.bean.GerarRAOSAnormalidadeConsumoHelper;
import gcom.micromedicao.bean.HidrometroRelatorioOSHelper;
import gcom.micromedicao.bean.ImovelFaltandoSituacaoLeituraHelper;
import gcom.micromedicao.bean.ImovelPorRotaHelper;
import gcom.micromedicao.bean.InformarSubdivisoesDeRotaHelper;
import gcom.micromedicao.bean.LigacaoMedicaoIndividualizadaHelper;
import gcom.micromedicao.bean.MedicaoHistoricoAnteriorHelper;
import gcom.micromedicao.bean.MonitorarLeituraMobilePopupHelper;
import gcom.micromedicao.bean.PesquisarRelatorioRotasOnlinePorEmpresaHelper;
import gcom.micromedicao.bean.SituacaoLeituraHelper;
import gcom.micromedicao.bean.TelemetriaDadosLeituraHelper;
import gcom.micromedicao.bean.TelemetriaInformacoesGeraisHelper;
import gcom.micromedicao.consumo.ConsumoAnormalidade;
import gcom.micromedicao.consumo.ConsumoAnormalidadeAcao;
import gcom.micromedicao.consumo.ConsumoHistorico;
import gcom.micromedicao.consumo.ConsumoTipo;
import gcom.micromedicao.consumo.FiltroConsumoHistorico;
import gcom.micromedicao.consumo.LigacaoTipo;
import gcom.micromedicao.hidrometro.FiltroHidrometro;
import gcom.micromedicao.hidrometro.FiltroHidrometroCapacidade;
import gcom.micromedicao.hidrometro.FiltroHidrometroLocalArmazenagem;
import gcom.micromedicao.hidrometro.FiltroHidrometroMarca;
import gcom.micromedicao.hidrometro.Hidrometro;
import gcom.micromedicao.hidrometro.HidrometroCapacidade;
import gcom.micromedicao.hidrometro.HidrometroClasseMetrologica;
import gcom.micromedicao.hidrometro.HidrometroDiametro;
import gcom.micromedicao.hidrometro.HidrometroInstalacaoHistorico;
import gcom.micromedicao.hidrometro.HidrometroLocalArmazenagem;
import gcom.micromedicao.hidrometro.HidrometroMarca;
import gcom.micromedicao.hidrometro.HidrometroMotivoMovimentacao;
import gcom.micromedicao.hidrometro.HidrometroMovimentacao;
import gcom.micromedicao.hidrometro.HidrometroMovimentado;
import gcom.micromedicao.hidrometro.HidrometroMovimentadoPK;
import gcom.micromedicao.hidrometro.HidrometroProtecao;
import gcom.micromedicao.hidrometro.HidrometroSituacao;
import gcom.micromedicao.hidrometro.HidrometroTipo;
import gcom.micromedicao.hidrometro.IRepositorioHidrometro;
import gcom.micromedicao.hidrometro.RepositorioHidrometroHBM;
import gcom.micromedicao.leitura.FiltroLeituraAnormalidade;
import gcom.micromedicao.leitura.FiltroLeituraFiscalizacao;
import gcom.micromedicao.leitura.LeituraAnormalidade;
import gcom.micromedicao.leitura.LeituraAnormalidadeConsumo;
import gcom.micromedicao.leitura.LeituraAnormalidadeLeitura;
import gcom.micromedicao.leitura.LeituraFaixaFalsa;
import gcom.micromedicao.leitura.LeituraFiscalizacao;
import gcom.micromedicao.leitura.LeituraSituacao;
import gcom.micromedicao.leitura.LeituraTipo;
import gcom.micromedicao.medicao.FiltroMedicaoHistorico;
import gcom.micromedicao.medicao.FiltroMedicaoHistoricoSql;
import gcom.micromedicao.medicao.MedicaoHistorico;
import gcom.micromedicao.medicao.MedicaoTipo;
import gcom.relatorio.atendimentopublico.RelatorioHistoricoMedicaoPocoHelper;
import gcom.relatorio.cadastro.micromedicao.FiltrarRelatorioImoveisComLeiturasHelper;
import gcom.relatorio.cadastro.micromedicao.RelatorioImoveisComLeiturasQuantitativosBean;
import gcom.relatorio.cadastro.micromedicao.RelatorioImoveisComLeiturasRelacaoBean;
import gcom.relatorio.cadastro.micromedicao.RelatorioImoveisComLeiturasTipo7Bean;
import gcom.relatorio.cadastro.micromedicao.RelatorioResumoLigacoesCapacidadeHidrometroBean;
import gcom.relatorio.cadastro.micromedicao.RelatorioResumoLigacoesCapacidadeHidrometroHelper;
import gcom.relatorio.micromedicao.AvisoAnormalidadeRelatorioHelper;
import gcom.relatorio.micromedicao.FiltrarAnaliseExcecoesLeiturasHelper;
import gcom.relatorio.micromedicao.FiltrarRelatorioAnormalidadeLeituraPeriodoHelper;
import gcom.relatorio.micromedicao.FiltrarRelatorioBoletimMedicaoHelper;
import gcom.relatorio.micromedicao.GerarDadosLeituraHelper;
import gcom.relatorio.micromedicao.RelatorioAcompanhamentoLeituristaAnormalidadesHelper;
import gcom.relatorio.micromedicao.RelatorioAcompanhamentoLeituristaHelper;
import gcom.relatorio.micromedicao.RelatorioAcompanhamentoLeituristaHorariosHelper;
import gcom.relatorio.micromedicao.RelatorioAnormalidadeLeituraPeriodoBean;
import gcom.relatorio.micromedicao.RelatorioAtualizarLeiturasAnormalidadesCelular;
import gcom.relatorio.micromedicao.RelatorioAtualizarLeiturasAnormalidadesCelularBean;
import gcom.relatorio.micromedicao.RelatorioBoletimMedicaoHelper;
import gcom.relatorio.micromedicao.RelatorioGerarDadosLeituraBean;
import gcom.relatorio.micromedicao.RelatorioLeiturasRealizadasHelper;
import gcom.relatorio.micromedicao.RelatorioRegistrarLeiturasAnormalidades;
import gcom.relatorio.micromedicao.RelatorioRotasOnlinePorEmpresaBean;
import gcom.seguranca.acesso.Abrangencia;
import gcom.seguranca.acesso.Funcionalidade;
import gcom.seguranca.acesso.Operacao;
import gcom.seguranca.acesso.OperacaoEfetuada;
import gcom.seguranca.acesso.usuario.Usuario;
import gcom.seguranca.acesso.usuario.UsuarioAcao;
import gcom.seguranca.acesso.usuario.UsuarioAcaoUsuarioHelper;
import gcom.seguranca.transacao.AlteracaoTipo;
import gcom.tarefa.TarefaRelatorio;
import gcom.util.ConstantesAplicacao;
import gcom.util.ConstantesSistema;
import gcom.util.ControladorComum;
import gcom.util.ControladorException;
import gcom.util.Criptografia;
import gcom.util.ErroRepositorioException;
import gcom.util.IRepositorioUtil;
import gcom.util.IoUtil;
import gcom.util.RemocaoInvalidaException;
import gcom.util.RemocaoRegistroNaoExistenteException;
import gcom.util.RepositorioUtilHBM;
import gcom.util.Util;
import gcom.util.ZipUtil;
import gcom.util.email.ErroEmailException;
import gcom.util.email.ServicosEmail;
import gcom.util.filtro.Filtro;
import gcom.util.filtro.FiltroParametro;
import gcom.util.filtro.ParametroNulo;
import gcom.util.filtro.ParametroSimples;

public class ControladorMicromedicao extends ControladorComum {
	
	private static final long serialVersionUID = 1L;

	protected IRepositorioHidrometro repositorioHidrometro                 = null;
	protected IRepositorioMicromedicao repositorioMicromedicao             = null;
	protected IRepositorioFaturamento repositorioFaturamento               = null;
	protected IRepositorioClienteImovel repositorioClienteImovel           = null;
	protected IRepositorioAtendimentoPublico repositorioAtendimentoPublico = null;
	protected IRepositorioUtil repositorioUtil                             = null;
	protected IRepositorioImovel repositorioImovel                         = null;
	protected IRepositorioFuncionario repositorioFuncionario               = null;

	private static Logger logger = Logger.getLogger(ControladorMicromedicao.class);

	public void ejbCreate() throws CreateException {
		repositorioUtil               = RepositorioUtilHBM.getInstancia();
		repositorioHidrometro         = RepositorioHidrometroHBM.getInstancia();
		repositorioMicromedicao       = RepositorioMicromedicaoHBM.getInstancia();
		repositorioFaturamento        = RepositorioFaturamentoHBM.getInstancia();
		repositorioClienteImovel      = RepositorioClienteImovelHBM.getInstancia();
		repositorioImovel             = RepositorioImovelHBM.getInstancia();
		repositorioFuncionario        = RepositorioFuncionarioHBM.getInstancia();
		repositorioAtendimentoPublico = RepositorioAtendimentoPublicoHBM.getInstancia();
	}


	/**
	 * [UC0083] Gerar Dados para Leitura [SB0004] Gerar Movimento do Roteiro
	 * Empresa
	 * 
	 * @author Rodrigo Silveira, Pedro Alexandre
	 * @date 25/07/2007, 15/10/2007
	 * @param colecaoRota
	 * @param anoMesCorrente
	 * @param idGrupoFaturamento
	 * @param idUnidadeIniciada
	 * @throws ControladorException
	 */
	public void gerarDadosPorLeituraCelularMobile(Collection<Rota> colecaoRota,
			Integer anoMesCorrente, Integer idGrupoFaturamentoRota,
			Integer idFuncionalidadeIniciada) throws ControladorException {
		int idUnidadeIniciada = 0;

		try {
			Integer idLeituraTipo = LeituraTipo.CELULAR_MOBILE;

			// -------------------------
			//
			// Registrar o início do processamento da Unidade de
			// Processamento
			// do Batch
			//
			// -------------------------
			idUnidadeIniciada = getControladorBatch()
					.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			SistemaParametro sistemaParametro =  getControladorUtil().pesquisarParametrosDoSistema();

			repositorioMicromedicao.removerMovimentoRoteiroEmpresa(
					anoMesCorrente, idGrupoFaturamentoRota);

			int numeroIndice = 0;
			int quantidadeRegistrosPesquisa = 1000;
			boolean flagTerminou = false;

			// inicializa uma coleção de imoveis
			Collection<Imovel> objetosImoveis = new ArrayList<Imovel>();

			while (!flagTerminou) {

				// cria uma coleção de imóvel por rota
				Collection<Object[]> imoveisPorRota = null;
				try {
					// recupera todos os imóveis da coleção de rotas do tipo
					// convencional

					imoveisPorRota = repositorioMicromedicao
							.pesquisarImoveisPorRotaOrdenadoPorInscricao(
									colecaoRota, idLeituraTipo, numeroIndice,
									sistemaParametro.getNomeAbreviadoEmpresa());

				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}

				if (imoveisPorRota != null && !imoveisPorRota.isEmpty()) {

					if (imoveisPorRota.size() < quantidadeRegistrosPesquisa) {
						flagTerminou = true;
					} else {
						numeroIndice = numeroIndice
								+ quantidadeRegistrosPesquisa;
					}

					Iterator<Object[]> imovelporRotaIterator = imoveisPorRota
							.iterator();
					while (imovelporRotaIterator.hasNext()) {
						// cria um array de objetos para pegar os parametros
						// de
						// retorno da pesquisa
						Object[] arrayImoveisPorRota = imovelporRotaIterator
								.next();

						// instancia um imóvel
						Imovel imovel = new Imovel();
						if (arrayImoveisPorRota[0] != null) {
							// seta o id no imovel
							imovel.setId((Integer) arrayImoveisPorRota[0]);
						}

						if (arrayImoveisPorRota[1] != null) {
							// instancia uma localidade para ser setado no
							// imóvel
							Localidade localidade = new Localidade();
							localidade.setId((Integer) arrayImoveisPorRota[1]);
							imovel.setLocalidade(localidade);
						}

						if (arrayImoveisPorRota[2] != null) {
							// instancia um setor comercial para ser setado
							// no
							// imóvel
							SetorComercial setorComercial = new SetorComercial();
							setorComercial
									.setCodigo(Integer
											.parseInt(arrayImoveisPorRota[2]
													.toString()));
							imovel.setSetorComercial(setorComercial);
						}
						Quadra quadra = new Quadra();
						if (arrayImoveisPorRota[3] != null) {
							// instancia uma quadra para ser setado no
							// imóvel

							Integer numeroQuadra = (Integer) arrayImoveisPorRota[3];
							quadra.setNumeroQuadra(numeroQuadra);
							imovel.setQuadra(quadra);
						}

						if (arrayImoveisPorRota[4] != null) {
							// seta o lote no imóvel
							imovel.setLote(Short
									.parseShort(arrayImoveisPorRota[4]
											.toString()));
						}

						if (arrayImoveisPorRota[5] != null) {
							// seta o lote no imóvel
							imovel.setSubLote(Short
									.parseShort(arrayImoveisPorRota[5]
											.toString()));
						}
						if (arrayImoveisPorRota[6] != null) {
							// instancia uma imovel perfil para ser setado
							// no
							// imóvel
							ImovelPerfil imovelPerfil = new ImovelPerfil();
							imovelPerfil
									.setId((Integer) arrayImoveisPorRota[6]);
							imovel.setImovelPerfil(imovelPerfil);
						}

						LigacaoAgua ligacaoAgua = new LigacaoAgua();
						if (arrayImoveisPorRota[7] != null) {
							// instancia uma ligação agua para ser setado no
							// imóvel

							ligacaoAgua.setId((Integer) arrayImoveisPorRota[7]);
						}
						// instancia um hidrometro instalação historico para
						// ser
						// colocado na ligacao agua

						if (arrayImoveisPorRota[30] != null) {

							HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoLigacaoAgua = (HidrometroInstalacaoHistorico) arrayImoveisPorRota[30];
							MedicaoTipo medicaoTipo = new MedicaoTipo();
							medicaoTipo
									.setId((Integer) arrayImoveisPorRota[26]);
							hidrometroInstalacaoHistoricoLigacaoAgua
									.setMedicaoTipo(medicaoTipo);
							ligacaoAgua
									.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoLigacaoAgua);

						}
						imovel.setLigacaoAgua(ligacaoAgua);

						// //instancia um hidrometro instalação historico
						// para
						// ser colocado no imovel

						if (arrayImoveisPorRota[31] != null) {

							HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel = (HidrometroInstalacaoHistorico) arrayImoveisPorRota[31];
							MedicaoTipo medicaoTipo = new MedicaoTipo();
							medicaoTipo
									.setId((Integer) arrayImoveisPorRota[27]);
							hidrometroInstalacaoHistoricoImovel
									.setMedicaoTipo(medicaoTipo);
							imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoImovel);

						}
						// instancia a rota
						Rota rotaImovel = new Rota();

						if (arrayImoveisPorRota[10] != null) {
							// seta o id da rota
							rotaImovel.setId((Integer) arrayImoveisPorRota[10]);
						}
						if (arrayImoveisPorRota[11] != null) {
							// seta o indicador fiscalizador suprimido na
							// rota
							rotaImovel.setIndicadorFiscalizarSuprimido(Short
									.parseShort(arrayImoveisPorRota[11]
											.toString()));
						}
						if (arrayImoveisPorRota[12] != null) {
							// seta o indicador fiscalizador cortado na rota
							rotaImovel.setIndicadorFiscalizarCortado(Short
									.parseShort(arrayImoveisPorRota[12]
											.toString()));
						}
						if (arrayImoveisPorRota[13] != null) {
							// seta o indicador gerar fiscalizacao na rota
							rotaImovel.setIndicadorGerarFiscalizacao(Short
									.parseShort(arrayImoveisPorRota[13]
											.toString()));
						}
						if (arrayImoveisPorRota[14] != null) {
							// seta o indicador fgerar falsa faixa na rota
							rotaImovel.setIndicadorGerarFalsaFaixa(Short
									.parseShort(arrayImoveisPorRota[14]
											.toString()));
						}
						if (arrayImoveisPorRota[15] != null) {
							// seta o percentual geracao fiscalizacao na
							// rota
							rotaImovel
									.setPercentualGeracaoFiscalizacao((BigDecimal) (arrayImoveisPorRota[15]));
						}
						if (arrayImoveisPorRota[16] != null) {
							// seta o percentual geracao faixa falsa na rota
							rotaImovel
									.setPercentualGeracaoFaixaFalsa((BigDecimal) (arrayImoveisPorRota[16]));
						}
						// instancia a empresa
						Empresa empresa = new Empresa();
						if (arrayImoveisPorRota[17] != null) {

							// seta o id na empresa
							empresa.setId((Integer) arrayImoveisPorRota[17]);

						}
						if (arrayImoveisPorRota[18] != null) {

							// seta a descrição abreviada na empresa
							empresa.setDescricaoAbreviada(arrayImoveisPorRota[18]
									.toString());

						}
						if (arrayImoveisPorRota[19] != null) {

							// seta email da empresa
							empresa.setEmail(arrayImoveisPorRota[19].toString());

						}
						if (arrayImoveisPorRota[28] != null) {

							// seta email da empresa
							empresa.setDescricao(arrayImoveisPorRota[28]
									.toString());

						}
						// seta a empresa na rota
						rotaImovel.setEmpresa(empresa);
						// instancia o faturamento
						FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
						if (arrayImoveisPorRota[20] != null) {
							// seta o id no faturamentGrupo
							faturamentoGrupo
									.setId((Integer) arrayImoveisPorRota[20]);

						}
						if (arrayImoveisPorRota[21] != null) {
							// seta o descrição no faturamentGrupo
							faturamentoGrupo
									.setDescricao((String) arrayImoveisPorRota[21]);
						}
						// seta o faturamento na rota
						rotaImovel.setFaturamentoGrupo(faturamentoGrupo);
						if (arrayImoveisPorRota[22] != null) {
							// instancia a ligação esgoto situação
							LeituraTipo leituraTipo = new LeituraTipo();
							// seta o id na ligação esgoto situação
							leituraTipo
									.setId((Integer) arrayImoveisPorRota[22]);
							// seta a ligação esgoto situação no imovel
							rotaImovel.setLeituraTipo(leituraTipo);
						}

						// seta a rota na quadra
						quadra.setRota(rotaImovel);

						// seta o roteiro empresa na quadra
						quadra.setRoteiroEmpresa((RoteiroEmpresa) arrayImoveisPorRota[29]);

						// seta a quadra no imovel
						imovel.setQuadra(quadra);
						if (arrayImoveisPorRota[23] != null) {
							// instancia a ligação agua situação
							LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
							// seta o id na ligação agua situação
							ligacaoAguaSituacao
									.setId((Integer) arrayImoveisPorRota[23]);
							// seta a ligação agua situação no imovel
							imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
						}
						if (arrayImoveisPorRota[24] != null) {
							// instancia a ligação esgoto situação
							LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
							// seta o id na ligação esgoto situação
							ligacaoEsgotoSituacao
									.setId((Integer) arrayImoveisPorRota[24]);
							// seta a ligação esgoto situação no imovel
							imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
						}

						if (arrayImoveisPorRota[25] != null) {
							// instancia o faturamento situacao tipo
							FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
							// seta o id no faturamento situacao tipo
							faturamentoSituacaoTipo
									.setIndicadorParalisacaoLeitura((Short) arrayImoveisPorRota[25]);
							// seta a ligação esgoto situação no imovel
							imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
						}

						if (arrayImoveisPorRota[32] != null) {
							imovel.getQuadra().getRota().getEmpresa()
									.setId((Integer) arrayImoveisPorRota[32]);
						}

						if (arrayImoveisPorRota[33] != null) {
							imovel.getLigacaoAguaSituacao()
									.setIndicadorFaturamentoSituacao(
											(Short) arrayImoveisPorRota[33]);
						}

						if (arrayImoveisPorRota[34] != null) {
							imovel.getLigacaoEsgotoSituacao()
									.setIndicadorFaturamentoSituacao(
											(Short) arrayImoveisPorRota[34]);
						}

						// adiciona na coleção de imoveis
						objetosImoveis.add(imovel);
						arrayImoveisPorRota = null;
					}

				} else {
					flagTerminou = true;
				}
			}

			/*
			 * Instancia uma coleção que será usada para gerar o arquivo txt.
			 */
			Collection<Imovel> imoveisParaSerGerados = new ArrayList<Imovel>();

			Iterator<Imovel> imovelIterator = objetosImoveis.iterator();
			while (imovelIterator.hasNext()) {
				// Recupera o imovel da coleção
				Imovel imovel = imovelIterator.next();

				/*
				 * variavel responsável para entrar em uma das 4 condicões
				 * abaixo
				 */
				if (sistemaParametro.getNomeAbreviadoEmpresa().toUpperCase()
						.equals("COMPESA")) {

					boolean achouImovel = false;

					/**
					 * [SF0002] - Verificar situação especial de faturamento
					 * Autor: Sávio Luiz Data: 21/12/2005
					 */
					/*
					 * caso no imovel o faturamento situação grupo seja
					 * diferente de nulo e igual a leitura não realizada então
					 * não seleciona o imovel caso contrario seleciona.
					 */
					if (imovel.getFaturamentoSituacaoTipo() == null
							|| !imovel
									.getFaturamentoSituacaoTipo()
									.equals(FaturamentoSituacaoTipo.INDICADOR_PARALIZACAO_LEITURA_NAO_REALIZADA)) {

						if (!achouImovel) {
							/*
							 * Verifica se a situação da ligação agua é
							 * diferente de nulo Se for verifica se está ligado
							 * ou cortado
							 */
							if (imovel.getLigacaoAguaSituacao() != null
									&& imovel.getLigacaoAguaSituacao()
											.getIndicadorFaturamentoSituacao() != null
									&& (imovel.getLigacaoAguaSituacao()
											.getIndicadorFaturamentoSituacao()
											.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO))) {
								/*
								 * Se for ligado ou cortado então Verifica se a
								 * ligação agua é diferente de nulo se for
								 * verifica se o id da ligação agua é igual ao
								 * id do imovel e se o id do histórico da
								 * instalação do hidrometro é diferente de null
								 */
								if (imovel.getLigacaoAgua() != null
										&& imovel.getLigacaoAgua().getId() != null
										&& (imovel.getLigacaoAgua().getId()
												.equals(imovel.getId())
												&& imovel
														.getLigacaoAgua()
														.getHidrometroInstalacaoHistorico() != null && imovel
												.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico()
												.getId() != null)) {
									imoveisParaSerGerados.add(imovel);
									achouImovel = true;
								}
							}
						}
						if (!achouImovel) {
							/*
							 * Verifica se a situação da ligação esgoto é
							 * diferente de nulo Se for verifica se está ligado
							 */
							if (imovel.getLigacaoEsgotoSituacao() != null
									&& imovel.getLigacaoEsgotoSituacao()
											.getIndicadorFaturamentoSituacao() != null
									&& (imovel.getLigacaoEsgotoSituacao()
											.getIndicadorFaturamentoSituacao()
											.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO))) {
								/*
								 * Verifica se o id do hidrometro historico é
								 * diferente de nulo na tabela imovel
								 */
								if (imovel.getHidrometroInstalacaoHistorico() != null
										&& imovel
												.getHidrometroInstalacaoHistorico()
												.getId() != null) {
									imoveisParaSerGerados.add(imovel);
									achouImovel = true;
								}
							}
						}
						if (!achouImovel) {
							/*
							 * Verifica se a situação da ligação agua é
							 * diferente de nulo Se for verifica se está
							 * suprimido
							 */
							if (imovel.getLigacaoAguaSituacao() != null
									&& imovel.getLigacaoAguaSituacao().getId() != null
									&& imovel
											.getLigacaoAguaSituacao()
											.getId()
											.equals(LigacaoAguaSituacao.SUPRIMIDO)) {
								/*
								 * verifica se o indicador de fiscalização
								 * suprimido é diferente de nulo se for verifica
								 * se está ativo
								 */
								if (imovel.getQuadra().getRota()
										.getIndicadorFiscalizarSuprimido() != null
										&& imovel
												.getQuadra()
												.getRota()
												.getIndicadorFiscalizarSuprimido()
												.equals(Rota.INDICADOR_SUPRIMIDO_ATIVO)) {
									imoveisParaSerGerados.add(imovel);
									achouImovel = true;
								}

							}
						}
						if (!achouImovel) {
							/*
							 * Verifica se a situação da ligação agua é
							 * diferente de nulo Se for verifica se está cortado
							 */
							if ((imovel.getLigacaoAguaSituacao() != null && imovel
									.getLigacaoAguaSituacao().getId() != null)
									&& (imovel.getLigacaoAguaSituacao().getId()
											.equals(LigacaoAguaSituacao.CORTADO))) {

								/*
								 * Se for cortado então Verifica se a ligação
								 * agua é diferente de nulo se for verifica se o
								 * id da ligação agua é igual ao id do imovel e
								 * se o id do histórico da instalação do
								 * hidrometro é null
								 */
								if (imovel.getLigacaoAgua() != null
										&& imovel.getLigacaoAgua().getId() != null
										&& (imovel.getLigacaoAgua().getId()
												.equals(imovel.getId()) && (imovel
												.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico() == null || imovel
												.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico()
												.getId() == null))) {

									/*
									 * verifica se o indicador de fiscalização
									 * cortado é diferente de nulo se for
									 * verifica se está ativo
									 */
									if (imovel.getQuadra().getRota()
											.getIndicadorFiscalizarCortado() != null
											&& imovel
													.getQuadra()
													.getRota()
													.getIndicadorFiscalizarCortado()
													.intValue() == Rota.INDICADOR_CORTADO_ATIVO) {
										imoveisParaSerGerados.add(imovel);
										achouImovel = true;
									}
								}

							}
						}

					}
				} else if (sistemaParametro.getNomeAbreviadoEmpresa()
						.toUpperCase().equals("CAERN")) {
					boolean validarImovel = this
							.validarImovelGerarDadosLeituraConvencional(imovel,
									anoMesCorrente);
					if (validarImovel) {
						imoveisParaSerGerados.add(imovel);
					}
				}

			}

			objetosImoveis = null;

			if (imoveisParaSerGerados != null
					&& !imoveisParaSerGerados.isEmpty()) {

				// pega o id da empresa do objeto imovel.
				Integer idEmpresaOld = null;

				// cria uma variavel do tipo boolean para saber se é a mesma
				// empresa
				// ou
				// outra empresa.
				boolean mesmaEmpresa = false;

				// é usado para na faixa falsa saber se o hidrometro foi
				// selecionado
				// ou
				// não
				boolean hidrometroSelecionado = false;

				Integer quantidadeRegistros = 0;

				Integer quantidadeImoveis = 0;

				ListIterator<Imovel> imovelParaSerGeradoIterator = ((List<Imovel>) imoveisParaSerGerados)
						.listIterator(0);

				Imovel imovelParaSerGerado = null;
				// ListIterator imovelParaSerGeradoIterator = (ListIterator)
				// imoveisParaSerGerados
				// .iterator();

				while (imovelParaSerGeradoIterator.hasNext()) {
					boolean ligacaoAgua = false;
					boolean ligacaoPoco = false;

					imovelParaSerGerado = imovelParaSerGeradoIterator.next();

					// pega o id da empresa do objeto imovel.
					idEmpresaOld = imovelParaSerGerado.getQuadra().getRota()
							.getEmpresa().getId();

					// Verifica se a empresa da rota que está na coleção é
					// igual
					// a
					// empresa anterior
					if (imovelParaSerGerado.getQuadra().getRota().getEmpresa()
							.getId().equals(idEmpresaOld)) {
						mesmaEmpresa = true;

					} else {
						mesmaEmpresa = false;

					}

					if (mesmaEmpresa) {
						// incrementa a quantidade de registros
						quantidadeRegistros = quantidadeRegistros + 1;

						quantidadeImoveis = quantidadeImoveis + 1;

						if (imovelParaSerGerado.getLigacaoAgua() != null
								&& imovelParaSerGerado.getLigacaoAgua().getId() != null
								&& imovelParaSerGerado.getLigacaoAgua()
										.getHidrometroInstalacaoHistorico() != null
								&& imovelParaSerGerado.getLigacaoAgua()
										.getHidrometroInstalacaoHistorico()
										.getId() != null) {
							ligacaoAgua = true;
						}
						if (imovelParaSerGerado
								.getHidrometroInstalacaoHistorico() != null
								&& imovelParaSerGerado
										.getHidrometroInstalacaoHistorico()
										.getId() != null) {
							ligacaoPoco = true;
						}

						if (ligacaoAgua && ligacaoPoco) {
							quantidadeRegistros = quantidadeRegistros + 1;
						}

						MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = new MovimentoRoteiroEmpresa();

						movimentoRoteiroEmpresa
								.setAnoMesMovimento(anoMesCorrente);

						if (imovelParaSerGerado.getQuadra() != null) {

							if (sistemaParametro.getIndicadorRoteiroEmpresa() == 1) {
								if (imovelParaSerGerado.getQuadra()
										.getRoteiroEmpresa() == null) {

									continue;
								}
							}

							movimentoRoteiroEmpresa
									.setRoteiroEmpresa(imovelParaSerGerado
											.getQuadra().getRoteiroEmpresa());
							movimentoRoteiroEmpresa
									.setNumeroQuadra(imovelParaSerGerado
											.getQuadra().getNumeroQuadra());

							if (imovelParaSerGerado.getQuadra().getRota() != null) {
								// id do grupo de faturamento
								movimentoRoteiroEmpresa
										.setFaturamentoGrupo(imovelParaSerGerado
												.getQuadra().getRota()
												.getFaturamentoGrupo());
							}

							if (imovelParaSerGerado.getQuadra()
									.getRoteiroEmpresa() != null) {
								movimentoRoteiroEmpresa
										.setEmpresa(imovelParaSerGerado
												.getQuadra()
												.getRoteiroEmpresa()
												.getEmpresa());
							} else {
								movimentoRoteiroEmpresa
										.setEmpresa(imovelParaSerGerado
												.getQuadra().getRota()
												.getEmpresa());
							}
						}

						movimentoRoteiroEmpresa
								.setLocalidade(imovelParaSerGerado
										.getLocalidade());
						movimentoRoteiroEmpresa
								.setCodigoSetorComercial(imovelParaSerGerado
										.getSetorComercial().getCodigo());

						movimentoRoteiroEmpresa.setNumeroLoteImovel(/*
																	 * Util .
																	 * adicionarZerosEsquedaNumero
																	 * (4,
																	 */""
								+ imovelParaSerGerado.getLote());
						movimentoRoteiroEmpresa.setNumeroSubloteImovel(/*
																		 * Util
																		 * .
																		 * adicionarZerosEsquedaNumero
																		 * (3,
																		 */""
								+ imovelParaSerGerado.getSubLote());

						movimentoRoteiroEmpresa
								.setImovelPerfil(imovelParaSerGerado
										.getImovelPerfil());

						// caso seja tipo ligação agua e poço cria a string
						// primeiro
						// com
						// tipo
						// ligação agua
						if (ligacaoAgua && ligacaoPoco) {

							if (imovelParaSerGerado.getLigacaoAgua() != null
									&& imovelParaSerGerado.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico() != null
									&& imovelParaSerGerado.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico()
											.getId() != null
									&& !imovelParaSerGerado.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico()
											.getId().equals("")) {

								movimentoRoteiroEmpresa
										.setMedicaoTipo(imovelParaSerGerado
												.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico()
												.getMedicaoTipo());
							}
							// caso não seja
						} else {
							// caso seja tipo ligação agua cria a string com
							// tipo
							// ligação agua
							if (ligacaoAgua) {
								if (imovelParaSerGerado.getLigacaoAgua() != null
										&& imovelParaSerGerado
												.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico() != null
										&& imovelParaSerGerado
												.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico()
												.getId() != null
										&& !imovelParaSerGerado
												.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico()
												.getId().equals("")) {
									movimentoRoteiroEmpresa
											.setMedicaoTipo(imovelParaSerGerado
													.getLigacaoAgua()
													.getHidrometroInstalacaoHistorico()
													.getMedicaoTipo());
								}
							} else {
								// caso seja tipo ligação poço cria a string
								// com
								// tipo
								// ligação poço
								if (ligacaoPoco) {
									if (imovelParaSerGerado
											.getHidrometroInstalacaoHistorico() != null
											&& imovelParaSerGerado
													.getHidrometroInstalacaoHistorico()
													.getId() != null
											&& !imovelParaSerGerado
													.getHidrometroInstalacaoHistorico()
													.getId().equals("")) {
										movimentoRoteiroEmpresa
												.setMedicaoTipo(imovelParaSerGerado
														.getHidrometroInstalacaoHistorico()
														.getMedicaoTipo());
									}
								}
							}
						}

						// Matricula do imóvel
						movimentoRoteiroEmpresa.setImovel(imovelParaSerGerado);

						// Perfil do imovel
						movimentoRoteiroEmpresa
								.setImovelPerfil(imovelParaSerGerado
										.getImovelPerfil());

						String nomeClienteUsuario = null;
						try {

							// Pesquisa o nome do cliente que tem o tipo de
							// relação
							// usuário.
							nomeClienteUsuario = repositorioClienteImovel
									.pesquisarNomeClientePorImovel(imovelParaSerGerado
											.getId());
						} catch (ErroRepositorioException e) {
							throw new ControladorException("erro.sistema", e);
						}
						// nome do cliente usuário
						movimentoRoteiroEmpresa.setNomeCliente(/*
																 * completaString(
																 */
						nomeClienteUsuario/* , 25) */);

						// Pesquisa o endereço do imovel passando o id
						String enderecoImovel = getControladorEndereco()
								.pesquisarEnderecoFormatado(
										imovelParaSerGerado.getId());
						if (enderecoImovel != null
								&& !enderecoImovel.equals("")) {
							// endereço do imóvel
							movimentoRoteiroEmpresa.setEnderecoImovel(/*
																	 * completaString
																	 * (
																	 */
							enderecoImovel/* , 50) */);
						} else {
							movimentoRoteiroEmpresa
									.setEnderecoImovel(completaString("", 50));
						}

						// Dados do Hidrometro

						// caso seja tipo ligação agua e poço cria a string
						// primeiro
						// com
						// tipo
						// ligação agua
						Short numeroDigitosHidrometro = null;
						StringBuilder dadosHidrometro = null;
						Integer capacidadeHidrometro = null;
						Integer marcaHidrometro = null;

						if (ligacaoAgua && ligacaoPoco) {

							Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);

							dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
							numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
							capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
							marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

							HidrometroCapacidade capacidade = new HidrometroCapacidade();
							capacidade.setId(capacidadeHidrometro);
							movimentoRoteiroEmpresa
									.setHidrometroCapacidade(capacidade);

							HidrometroMarca hidrometroMarca = new HidrometroMarca();
							hidrometroMarca.setId(marcaHidrometro);
							movimentoRoteiroEmpresa
									.setHidrometroMarca(hidrometroMarca);

							movimentoRoteiroEmpresa
									.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
							// caso não seja
						} else {
							// caso seja tipo ligação agua cria a string com
							// tipo
							// ligação agua
							if (ligacaoAgua) {

								Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);

								dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
								numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
								capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
								marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

								HidrometroCapacidade capacidade = new HidrometroCapacidade();
								capacidade.setId(capacidadeHidrometro);
								movimentoRoteiroEmpresa
										.setHidrometroCapacidade(capacidade);

								HidrometroMarca hidrometroMarca = new HidrometroMarca();
								hidrometroMarca.setId(marcaHidrometro);
								movimentoRoteiroEmpresa
										.setHidrometroMarca(hidrometroMarca);

								movimentoRoteiroEmpresa
										.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);

								// caso não seja
							} else {
								// caso seja tipo ligação poço cria a string
								// com
								// tipo
								// ligação poço
								if (ligacaoPoco) {

									Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);

									dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
									numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
									capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
									marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

									HidrometroCapacidade capacidade = new HidrometroCapacidade();
									capacidade.setId(capacidadeHidrometro);
									movimentoRoteiroEmpresa
											.setHidrometroCapacidade(capacidade);

									HidrometroMarca hidrometroMarca = new HidrometroMarca();
									hidrometroMarca.setId(marcaHidrometro);
									movimentoRoteiroEmpresa
											.setHidrometroMarca(hidrometroMarca);

									movimentoRoteiroEmpresa
											.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);

									// caso não seja nem um nem outro então
									// pode
									// chamar
									// qualquer um dos métodos
									// pois os dois fazem a verificação e
									// retorna
									// strings
									// vazia e
									// a data cpm zeros
								} else {
									Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);

									dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
									numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
									capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
									marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

									HidrometroCapacidade capacidade = new HidrometroCapacidade();
									capacidade.setId(capacidadeHidrometro);
									movimentoRoteiroEmpresa
											.setHidrometroCapacidade(capacidade);

									HidrometroMarca hidrometroMarca = new HidrometroMarca();
									hidrometroMarca.setId(marcaHidrometro);
									movimentoRoteiroEmpresa
											.setHidrometroMarca(hidrometroMarca);

									movimentoRoteiroEmpresa
											.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
								}
							}
						}

						if (imovelParaSerGerado
								.getHidrometroInstalacaoHistorico() != null) {

							movimentoRoteiroEmpresa
									.setHidrometroLocalInstalacao(imovelParaSerGerado
											.getHidrometroInstalacaoHistorico()
											.getHidrometroLocalInstalacao());

							movimentoRoteiroEmpresa
									.setDataInstalacaoHidrometro(imovelParaSerGerado
											.getHidrometroInstalacaoHistorico()
											.getDataInstalacao());

							movimentoRoteiroEmpresa
									.setHidrometroProtecao(imovelParaSerGerado
											.getHidrometroInstalacaoHistorico()
											.getHidrometroProtecao());

						}

						if (imovelParaSerGerado.getLigacaoAgua()
								.getHidrometroInstalacaoHistorico() != null) {

							movimentoRoteiroEmpresa
									.setHidrometroLocalInstalacao(imovelParaSerGerado
											.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico()
											.getHidrometroLocalInstalacao());

							movimentoRoteiroEmpresa
									.setDataInstalacaoHidrometro(imovelParaSerGerado
											.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico()
											.getDataInstalacao());

							movimentoRoteiroEmpresa
									.setHidrometroProtecao(imovelParaSerGerado
											.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico()
											.getHidrometroProtecao());

						}

						// id da ligacao agua situação
						if (imovelParaSerGerado.getLigacaoAguaSituacao() != null
								&& imovelParaSerGerado.getLigacaoAguaSituacao()
										.getId() != null) {
							// Situação da ligação de agua
							movimentoRoteiroEmpresa
									.setLigacaoAguaSituacao(imovelParaSerGerado
											.getLigacaoAguaSituacao());
						}

						// id da ligacao esgoto situação
						if (imovelParaSerGerado.getLigacaoEsgotoSituacao() != null
								&& imovelParaSerGerado
										.getLigacaoEsgotoSituacao().getId() != null) {
							// Situação de ligação esgoto
							movimentoRoteiroEmpresa
									.setLigacaoEsgotoSituacao(imovelParaSerGerado
											.getLigacaoEsgotoSituacao());
						}

						// pega as descrições das categorias do imovel

						Categoria categoria = getControladorImovel()
								.obterDescricoesCategoriaImovel(
										imovelParaSerGerado);

						// quantidade de economias
						movimentoRoteiroEmpresa
								.setDescricaoAbreviadaCategoriaImovel(categoria
										.getDescricaoAbreviada());

						// [UC0086 - Obter quantidade de economias]
						int quantidadeEconomias = getControladorImovel()
								.obterQuantidadeEconomias(imovelParaSerGerado);
						// quantidade de economias
						movimentoRoteiroEmpresa
								.setQuantidadeEconomias(new Integer(
										quantidadeEconomias).shortValue());

						// Leitura anterior

						Integer anoMesAnterior = Util
								.subtrairData(anoMesCorrente);
						String leituraAnterior = null;
						Integer idMedicaoTipo = null;
						MedicaoHistorico medicaoHistorico = null;
						Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua,
								ligacaoPoco, anoMesAnterior,
								imovelParaSerGerado);
						// verifica se a leitura anterior é diferente de
						// nula
						if (retorno[0] != null) {
							leituraAnterior = retorno[0].toString();
						}
						// verifica se a leitura situação atual é diferente
						// de
						// nula
						if (retorno[1] != null) {
							medicaoHistorico = (MedicaoHistorico) retorno[1];
						}
						// verifica se o id da medição tipo é diferente de
						// nula
						if (retorno[2] != null) {
							idMedicaoTipo = (Integer) retorno[2];
						}

						// verifica se a leitura anterior é diferente de
						// nula
						// para
						// ser
						// jogado no arquivo
						// txt
						if (leituraAnterior != null) {
							movimentoRoteiroEmpresa
									.setNumeroLeituraAnterior(new Integer(
											leituraAnterior));
							// caso contrario coloca a string com zeros
						}

						// Faixa de leitura esperada

						Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsaCelular(
								imovelParaSerGerado, dadosHidrometro,
								leituraAnterior, medicaoHistorico,
								idMedicaoTipo, sistemaParametro,
								hidrometroSelecionado, numeroDigitosHidrometro);

						// hidrometroSelecionado = Boolean
						// .parseBoolean(faixaInicialFinal[1]
						// .toString());

						// boolean faixaFalsaLeitura = Boolean
						// .parseBoolean(faixaInicialFinal[2]
						// .toString());

						int faixaInicialEsperada = 0;
						int faixaFinalEsperada = 0;
						// if (faixaFalsaLeitura) {
						faixaInicialEsperada = Integer
								.parseInt(faixaInicialFinal[3].toString());

						faixaFinalEsperada = Integer
								.parseInt(faixaInicialFinal[4].toString());
						// }

						movimentoRoteiroEmpresa
								.setNumeroFaixaLeituraEsperadaInicial(faixaInicialEsperada);
						movimentoRoteiroEmpresa
								.setNumeroFaixaLeituraEsperadaFinal(faixaFinalEsperada);

						movimentoRoteiroEmpresa.setUltimaAlteracao(new Date());

						/* alterado por pedro alexandre dia 15/10/2007 */
						movimentoRoteiroEmpresa.setRota(imovelParaSerGerado
								.getQuadra().getRota());

						getControladorUtil().inserir(movimentoRoteiroEmpresa);

						// Caso Imovel tenha Ligacao de Agua e de Poço
						if (ligacaoAgua && ligacaoPoco) {

							// Medicao Tipo
							MedicaoTipo medicaoTipo = new MedicaoTipo();
							medicaoTipo.setId(MedicaoTipo.POCO);

							movimentoRoteiroEmpresa.setMedicaoTipo(medicaoTipo);

							Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);

							dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
							numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
							capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
							marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

							// Capacidade Hidrometro
							HidrometroCapacidade capacidade = new HidrometroCapacidade();
							capacidade.setId(capacidadeHidrometro);
							movimentoRoteiroEmpresa
									.setHidrometroCapacidade(capacidade);

							// Marca do Hidrometro
							HidrometroMarca hidrometroMarca = new HidrometroMarca();
							hidrometroMarca.setId(marcaHidrometro);
							movimentoRoteiroEmpresa
									.setHidrometroMarca(hidrometroMarca);

							// Numero Hidrometro
							movimentoRoteiroEmpresa
									.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);

							if (imovelParaSerGerado
									.getHidrometroInstalacaoHistorico() != null) {

								// Local de Instalação
								movimentoRoteiroEmpresa
										.setHidrometroLocalInstalacao(imovelParaSerGerado
												.getHidrometroInstalacaoHistorico()
												.getHidrometroLocalInstalacao());

								// Data de Instalação
								movimentoRoteiroEmpresa
										.setDataInstalacaoHidrometro(imovelParaSerGerado
												.getHidrometroInstalacaoHistorico()
												.getDataInstalacao());

								// Proteção do Hidrometro
								movimentoRoteiroEmpresa
										.setHidrometroProtecao(imovelParaSerGerado
												.getHidrometroInstalacaoHistorico()
												.getHidrometroProtecao());

							}

							// verifica se a leitura anterior é diferente de
							// nula
							if (retorno[3] != null) {
								leituraAnterior = retorno[3].toString();
							} else {
								leituraAnterior = "0";
							}
							// verifica se a leitura situação atual é diferente
							// de
							// nula
							if (retorno[4] != null) {
								medicaoHistorico = (MedicaoHistorico) retorno[4];
							} else {
								medicaoHistorico = new MedicaoHistorico();
							}
							// verifica se o id da medição tipo é diferente de
							// nula
							if (retorno[5] != null) {
								idMedicaoTipo = (Integer) retorno[5];
							} else {
								idMedicaoTipo = MedicaoTipo.POCO;
							}

							// verifica se a leitura anterior é diferente de
							// nula
							// para
							// ser
							// jogado no arquivo
							// txt
							if (leituraAnterior != null) {
								movimentoRoteiroEmpresa
										.setNumeroLeituraAnterior(new Integer(
												leituraAnterior));
								// caso contrario coloca a string com zeros
							} else {
								movimentoRoteiroEmpresa
										.setNumeroLeituraAnterior(new Integer(0));
							}

							// Faixa de leitura esperada
							faixaInicialFinal = pesquisarFaixaEsperadaOuFalsaCelular(
									imovelParaSerGerado, dadosHidrometro,
									leituraAnterior, medicaoHistorico,
									idMedicaoTipo, sistemaParametro,
									hidrometroSelecionado,
									numeroDigitosHidrometro);

							faixaInicialEsperada = 0;
							faixaFinalEsperada = 0;

							faixaInicialEsperada = Integer
									.parseInt(faixaInicialFinal[3].toString());

							faixaFinalEsperada = Integer
									.parseInt(faixaInicialFinal[4].toString());

							movimentoRoteiroEmpresa
									.setNumeroFaixaLeituraEsperadaInicial(faixaInicialEsperada);
							movimentoRoteiroEmpresa
									.setNumeroFaixaLeituraEsperadaFinal(faixaFinalEsperada);

							movimentoRoteiroEmpresa
									.setUltimaAlteracao(new Date());

							getControladorUtil().inserir(
									movimentoRoteiroEmpresa);

						}

					}

					imovelParaSerGerado = null;

				}
			}

			// Encerra a unidade de Faturamento

			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) { // Este catch serve para interceptar
			// qualquer exceção que o processo batch
			// venha a lançar e garantir que a unidade
			// de processamento do batch será atualizada
			// com o erro ocorrido
			e.printStackTrace();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);

			throw new EJBException(e);
		}

	}

	/**
	 * @param faturamentoGrupo
	 * @param sistemaParametro
	 * @param colecaoRotas
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	@SuppressWarnings("unchecked")
	public void consistirLeiturasCalcularConsumos(FaturamentoGrupo faturamentoGrupo,SistemaParametro sistemaParametro, Collection<Rota> colecaoRotas,
			int idFuncionalidadeIniciada) throws ControladorException {

		int idUnidadeIniciada = 0;
		Integer matricula = null;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,((Rota) Util.retonarObjetoDeColecao(colecaoRotas)).getId());

		try {

			Collection<MedicaoHistorico> colecaoInserirMedicaoHistoricoAgua = new ArrayList<MedicaoHistorico>();
			Collection<MedicaoHistorico> colecaoAtualizarMedicaoHistoricoAgua = new ArrayList<MedicaoHistorico>();
			Collection<ConsumoHistorico> colecaoInserirConsumoHistoricoAgua = new ArrayList<ConsumoHistorico>();

			Collection<MedicaoHistorico> colecaoInserirMedicaoHistoricoEsgoto = new ArrayList<MedicaoHistorico>();
			Collection<MedicaoHistorico> colecaoAtualizarMedicaoHistoricoEsgoto = new ArrayList<MedicaoHistorico>();
			Collection<ConsumoHistorico> colecaoInserirConsumoHistoricoEsgoto = new ArrayList<ConsumoHistorico>();

			Iterator<Rota> rotasIterator = colecaoRotas.iterator();

			sistemaParametro.setAnoMesFaturamento(faturamentoGrupo.getAnoMesReferencia());

			while (rotasIterator.hasNext()) {

				Rota rota = rotasIterator.next();

				Imovel imovel = null;

				Collection<Object[]> colecaoImoveis = null;

				int quantidadeEconomias = 0;
				Object[] arrayImovel = null;

				colecaoInserirMedicaoHistoricoAgua.clear();
				colecaoAtualizarMedicaoHistoricoAgua.clear();
				colecaoInserirConsumoHistoricoAgua.clear();
				colecaoInserirConsumoHistoricoEsgoto.clear();

				Integer idConta = null;

				if (rota.getLeituraTipo().getId().equals(LeituraTipo.LEITURA_E_ENTRADA_SIMULTANEA)) {
					colecaoImoveis = getControladorFaturamento().obterImoveisComConta(faturamentoGrupo.getAnoMesReferencia(), rota);

				} else {
					colecaoImoveis = this.pesquisarImovelParaConsistirLeitura(rota);
				}

				if (colecaoImoveis != null && !colecaoImoveis.isEmpty()) {

					Iterator<Object[]> iteratorColecaoImoveis = colecaoImoveis.iterator();

					while (iteratorColecaoImoveis.hasNext()) {

						arrayImovel = iteratorColecaoImoveis.next();

						imovel = obterImovelLigadoCortadoAguaLigadoEsgoto(arrayImovel);
						matricula = imovel.getId();

						EsferaPoder esferaPoder = null;

						if (arrayImovel[26] != null) {
							esferaPoder = new EsferaPoder();
							esferaPoder.setId((Integer) arrayImovel[26]);
						}
						
						if (imovel.getIndicadorImovelCondominio() != null && imovel.getIndicadorImovelCondominio().equals(ConstantesSistema.SIM)) {

							idConta = (Integer) getControladorImovel().pesquisarImovelCondominioIdComContaNaoPreFaturada(imovel.getId(), faturamentoGrupo.getAnoMesReferencia());

							if (idConta != null && !idConta.equals("")) {
								FiltroConsumoHistorico filtroConsumoHistorico = new FiltroConsumoHistorico();
								filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, imovel.getId()));
								filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANO_MES_FATURAMENTO, faturamentoGrupo.getAnoMesReferencia()));
								Collection colecaoConsumoHistorico = getControladorUtil().pesquisar(filtroConsumoHistorico, ConsumoHistorico.class.getName());
								
								// Caso exista conta para algum imóvel micro do imóvel macro, mas o imóvel Macro esteja sem consumo_historico, então
								// informa que não existe conta para que possa ser criado consumo_historico para o macro
								if (colecaoConsumoHistorico == null || colecaoConsumoHistorico.isEmpty()) {
									idConta = null;
								}
							}

						} else {
							idConta = (Integer) getControladorImovel().pesquisarImovelIdComConta(imovel.getId(), faturamentoGrupo.getAnoMesReferencia());
						}

						Integer idDebitoCreditoSituacaoAtual = this.getControladorFaturamento().pesquisarDebitoCreditoSituacaoAtualConta(imovel.getId(),
								faturamentoGrupo.getAnoMesReferencia());

						// CASO NÃO EXISTA CONTA PARA O IMÓVEL NO ANO/MÊS DE REFERÊNCIA OU DEBITO CREDITO SITUACAO ATUAL SEJA DE CONTA PRE FATURADA
						if (idConta == null
								|| idConta.equals("")
								|| (idDebitoCreditoSituacaoAtual != null && idDebitoCreditoSituacaoAtual.intValue() == DebitoCreditoSituacao.PRE_FATURADA.intValue())) {

							Collection<MovimentoContaPrefaturada> colMovimentoContaPrefaturada = null;

							// Caso exista conta e esta conta esteja com a situação pré-faturada e caso exsita dados na tabela de movimento conta
							// pré-faturada, então faz o processo de inserir medição/consumo histórico e atualizar a conta pelo processo de retorno usado
							// na impressão simultânea

							if (idConta != null && !idConta.equals("") && idDebitoCreditoSituacaoAtual.intValue() == DebitoCreditoSituacao.PRE_FATURADA.intValue()) {
								
								FiltroMovimentoContaPrefaturada filtroMovimentoContaPrefaturada = new FiltroMovimentoContaPrefaturada();
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("imovel.hidrometroInstalacaoHistorico");
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupo");
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("imovel.ligacaoAgua");
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("leituraAnormalidadeFaturamento");
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("imovel.quadra.rota");
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("conta");
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("movimentoContaPrefaturadaCategorias");
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("conta.ligacaoAguaSituacao");
								filtroMovimentoContaPrefaturada.adicionarCaminhoParaCarregamentoEntidade("conta.ligacaoEsgotoSituacao");

								filtroMovimentoContaPrefaturada.adicionarParametro(new ParametroSimples(FiltroMovimentoContaPrefaturada.MATRICULA, imovel.getId()));
								filtroMovimentoContaPrefaturada.adicionarParametro(new ParametroSimples(FiltroMovimentoContaPrefaturada.ANO_MES_REFERENCIA_PRE_FATURAMENTO, faturamentoGrupo.getAnoMesReferencia()));

								try {
									colMovimentoContaPrefaturada = (Collection<MovimentoContaPrefaturada>) repositorioUtil.pesquisar(
											filtroMovimentoContaPrefaturada, MovimentoContaPrefaturada.class.getName());
								} catch (ErroRepositorioException e) {
									throw new ControladorException("erro.sistema", e);
								}
							}

							if (colMovimentoContaPrefaturada != null && !colMovimentoContaPrefaturada.isEmpty()) {

								rota.setFaturamentoGrupo(faturamentoGrupo);

								FiltroContaCategoriaConsumoFaixa filtroContaCategoriaConsumoFaixa = new FiltroContaCategoriaConsumoFaixa();
								filtroContaCategoriaConsumoFaixa.adicionarParametro(new ParametroSimples(FiltroContaCategoriaConsumoFaixa.CONTA_ID, idConta));
								Collection<Object> colContaCategoriaConsumoFaixa = getControladorUtil().pesquisar(filtroContaCategoriaConsumoFaixa, ContaCategoriaConsumoFaixa.class.getName());
								getControladorBatch().removerColecaoObjetoParaBatch(colContaCategoriaConsumoFaixa);

								FiltroFaturamentoImediatoAjuste filtroFaturamentoImediatoAjuste = new FiltroFaturamentoImediatoAjuste();
								filtroFaturamentoImediatoAjuste.adicionarParametro(new ParametroSimples(FiltroFaturamentoImediatoAjuste.ID_CONTA, idConta));

								FiltroContaImpressao filtroContaImpressao = new FiltroContaImpressao();
								filtroContaImpressao.adicionarParametro(new ParametroSimples(FiltroContaImpressao.ID, idConta));
								Collection<Object> colContaImpressao = getControladorUtil().pesquisar(filtroContaImpressao, ContaImpressao.class.getName());

								getControladorBatch().removerColecaoObjetoParaBatch(colContaImpressao);

								Short isImovelAnalisado = this.repositorioMicromedicao.pesquisarMedicaoHistoricoLigacaoAguaAnalisado(imovel.getId(), faturamentoGrupo.getAnoMesReferencia(), MedicaoTipo.LIGACAO_AGUA);
								if (isImovelAnalisado != null && isImovelAnalisado.equals(ConstantesSistema.NAO))
									getControladorFaturamento().processarMovimentoContaPrefaturada(rota, colMovimentoContaPrefaturada, false);

							} else {

								repositorioMicromedicao.deletarConsumoHistoricoCondominioRETIRAR(imovel.getId(), sistemaParametro.getAnoMesFaturamento().intValue());
								repositorioMicromedicao.deletarConsumoHistoricoRETIRAR(imovel.getId(), sistemaParametro.getAnoMesFaturamento().intValue());

								if (Util.obterMes(sistemaParametro.getAnoMesFaturamento()) == 11) {
									if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)) {
										Integer anoMesReferenciaFaturamentoAntecipado = Util.somarData(sistemaParametro.getAnoMesFaturamento());

										repositorioMicromedicao.deletarConsumoHistoricoCondominioRETIRAR(imovel.getId(), anoMesReferenciaFaturamentoAntecipado);
										repositorioMicromedicao.deletarConsumoHistoricoRETIRAR(imovel.getId(), anoMesReferenciaFaturamentoAntecipado);
									}
								}

								quantidadeEconomias = this.getControladorImovel().obterQuantidadeEconomiasVirtuais(imovel.getId());

								MedicaoHistorico medicaoHistorico = null;
								ConsumoHistorico consumoHistoricoAgua = null;
								ConsumoHistorico consumoHistoricoEsgoto = null;

								LigacaoTipo ligacaoTipo = new LigacaoTipo();

								Short ligacaoAguaSituacaoIndicadorFaturamento = imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao();
								Short ligacaoEsgotoSituacaoIndicadorFaturamento = imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao();

								if (ligacaoAguaSituacaoIndicadorFaturamento.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
										|| (imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null)) {

									ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

									rota.setFaturamentoGrupo(faturamentoGrupo);

									consumoHistoricoAgua = new ConsumoHistorico();
									consumoHistoricoAgua.setRota(rota);
									consumoHistoricoAgua.setLigacaoTipo(ligacaoTipo);
									consumoHistoricoAgua.setImovel(imovel);

									determinarDadosFaturamentoAgua(medicaoHistorico, consumoHistoricoAgua, sistemaParametro, quantidadeEconomias,
											colecaoInserirMedicaoHistoricoAgua, colecaoAtualizarMedicaoHistoricoAgua, colecaoInserirConsumoHistoricoAgua,
											esferaPoder);
								}

								if (ligacaoEsgotoSituacaoIndicadorFaturamento.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO) || (imovel.getHidrometroInstalacaoHistorico() != null)) {

									ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

									consumoHistoricoEsgoto = new ConsumoHistorico();
									consumoHistoricoEsgoto.setRota(rota);

									consumoHistoricoEsgoto.setLigacaoTipo(ligacaoTipo);

									determinarDadosFaturamentoEsgoto(imovel, consumoHistoricoEsgoto, consumoHistoricoAgua, quantidadeEconomias,
											sistemaParametro, rota, colecaoInserirConsumoHistoricoEsgoto, faturamentoGrupo,
											colecaoInserirMedicaoHistoricoEsgoto, colecaoAtualizarMedicaoHistoricoEsgoto, esferaPoder);

								}
							}
						}

					}

					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirMedicaoHistoricoAgua);
					getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoAtualizarMedicaoHistoricoAgua);
					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirConsumoHistoricoAgua);

					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirMedicaoHistoricoEsgoto);
					getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoAtualizarMedicaoHistoricoEsgoto);
					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirConsumoHistoricoEsgoto);

				}
				getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);
			}
		} catch (Exception e) {
			logger.error("ERRO NO IMÓVEL:" + matricula);
			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e, idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * 
	 * Método utilizado para obter dados do imóvel ligado ou cortado de água ou
	 * ligado de esgoto
	 */

	private Imovel obterImovelLigadoCortadoAguaLigadoEsgoto(Object[] arrayImovel) {

		// Cria objetos
		Imovel imovel = new Imovel();
		LigacaoAgua ligacaoAgua = new LigacaoAgua();
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
		Hidrometro hidrometro = new Hidrometro();
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
		PocoTipo pocoTipo = new PocoTipo();
		LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
		LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
		LigacaoEsgoto ligacaoEsgoto = new LigacaoEsgoto();
		ConsumoTarifa consumoTarifa = new ConsumoTarifa();
		ImovelPerfil imovelPerfil = new ImovelPerfil();

		// Se existe ligação de água
		if (arrayImovel[3] != null) {
			ligacaoAgua.setId((Integer) arrayImovel[3]);

			// Seta o consumo mínimo de água da ligação de água
			if (arrayImovel[12] != null) {
				ligacaoAgua
						.setNumeroConsumoMinimoAgua((Integer) arrayImovel[12]);
			}

			// Se existe hidrômetro instalado na ligação de água
			if (arrayImovel[4] != null) {
				hidrometroInstalacaoHistorico.setId((Integer) arrayImovel[4]);

				// Seta a data de instalação do hidrômetro
				if (arrayImovel[18] != null) {
					hidrometroInstalacaoHistorico
							.setDataInstalacao((Date) arrayImovel[18]);
				}

				// Seta a leitura de instalação do hidrômetro
				if (arrayImovel[32] != null) {
					hidrometroInstalacaoHistorico
							.setNumeroLeituraInstalacao((Integer) arrayImovel[32]);
				}

				// Seta o hidrômetro
				if (arrayImovel[5] != null) {
					hidrometro.setId((Integer) arrayImovel[5]);

					// Seta o número de digitos da leitura (esse valor será
					// usado no UC calcularFaixaLeituraEsperada)
					if (arrayImovel[6] != null) {
						hidrometro
								.setNumeroDigitosLeitura((Short) arrayImovel[6]);
					}

					//Seta a data de ligacao de agua
					if (arrayImovel[34] != null) {
						ligacaoAgua.setDataLigacao((Date)arrayImovel[34]);
					}
					
					hidrometroInstalacaoHistorico.setHidrometro(hidrometro);
				}

				// Seta o hidrômetro instalação histórico na ligação de água
				ligacaoAgua
						.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
			}
		}
		// Se existe ligação de esgoto
		if (arrayImovel[16] != null) {
			ligacaoEsgoto.setId((Integer) arrayImovel[16]);

			// Seta o consumo mínimo de ligação de esgoto
			if (arrayImovel[17] != null) {
				ligacaoEsgoto.setConsumoMinimo((Integer) arrayImovel[17]);
			}

			// Seta o percentual de coleta de ligação do esgoto
			if (arrayImovel[20] != null) {
				ligacaoEsgoto
						.setPercentualAguaConsumidaColetada((BigDecimal) arrayImovel[20]);
			}
			
			//Seta a data de ligacao de agua
			if (arrayImovel[35] != null) {
				ligacaoAgua.setDataLigacao((Date)arrayImovel[34]);
			}

		}
		// Seta faturamento situacao tipo
		if (arrayImovel[7] != null) {
			faturamentoSituacaoTipo.setId((Integer) arrayImovel[7]);
			// Seta o indicador de faturamento paralisação
			if (arrayImovel[14] != null) {
				faturamentoSituacaoTipo
						.setIndicadorParalisacaoFaturamento((Short) arrayImovel[14]);
			}

			// Seta o indicador de validade de água
			if (arrayImovel[24] != null) {
				faturamentoSituacaoTipo
						.setIndicadorValidoAgua((Short) arrayImovel[24]);
			}

			// Seta o indicador de validade de esgoto
			if (arrayImovel[25] != null) {
				faturamentoSituacaoTipo
						.setIndicadorValidoEsgoto((Short) arrayImovel[25]);
			}

			imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
		}

		// Seta o tipo do poço
		if (arrayImovel[8] != null) {
			pocoTipo.setId((Integer) arrayImovel[8]);
			imovel.setPocoTipo(pocoTipo);
		}

		// Seta o indicador imóvel condomínio
		if (arrayImovel[13] != null) {
			imovel.setIndicadorImovelCondominio((Short) arrayImovel[13]);
		}

		// Seta o consumo tipo
		if (arrayImovel[19] != null) {
			consumoTarifa.setId((Integer) arrayImovel[19]);
			imovel.setConsumoTarifa(consumoTarifa);
		}

		// Seta o indicador débito conta
		if (arrayImovel[15] != null) {
			imovel.setIndicadorDebitoConta((Short) arrayImovel[15]);
		}

		if (arrayImovel[1] != null) {
			ligacaoAguaSituacao.setId((Integer) arrayImovel[1]);
			ligacaoAguaSituacao
					.setIndicadorFaturamentoSituacao((Short) arrayImovel[27]);
			ligacaoAguaSituacao
					.setConsumoMinimoFaturamento((Integer) arrayImovel[29]);

			ligacaoAguaSituacao
					.setIndicadorAbastecimento((Short) arrayImovel[31]);

			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		}

		if (arrayImovel[2] != null) {
			ligacaoEsgotoSituacao.setId((Integer) arrayImovel[2]);
			ligacaoEsgotoSituacao
					.setIndicadorFaturamentoSituacao((Short) arrayImovel[28]);
			ligacaoEsgotoSituacao
					.setVolumeMinimoFaturamento((Integer) arrayImovel[30]);

			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
		}

		if (arrayImovel[21] != null) {
			imovel.setQuantidadeEconomias((Short) arrayImovel[21]);
		}

		if (arrayImovel[9] != null) {

			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoPoco = new HidrometroInstalacaoHistorico();
			hidrometroInstalacaoHistoricoPoco.setId((Integer) arrayImovel[9]);

			// Seta a data de instalação do hidrômetro
			if (arrayImovel[23] != null) {
				hidrometroInstalacaoHistoricoPoco
						.setDataInstalacao((Date) arrayImovel[23]);
			}

			// Seta a leitura de instalação do hidrômetro
			if (arrayImovel[33] != null) {
				hidrometroInstalacaoHistoricoPoco
						.setNumeroLeituraInstalacao((Integer) arrayImovel[33]);
			}

			// Seta o hidrômetro
			Hidrometro hidrometroPoco = null;
			if (arrayImovel[10] != null) {

				hidrometroPoco = new Hidrometro();
				hidrometroPoco.setId((Integer) arrayImovel[10]);

				// Seta o número de digitos da leitura (esse valor será
				// usado no UC calcularFaixaLeituraEsperada)
				if (arrayImovel[22] != null) {
					hidrometroPoco
							.setNumeroDigitosLeitura((Short) arrayImovel[22]);
				}
			}

			hidrometroInstalacaoHistoricoPoco.setHidrometro(hidrometroPoco);

			imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoPoco);
		}

		// Seta o id do imóvel
		imovel.setId((Integer) arrayImovel[0]);
		// Seta a ligação de água
		if (ligacaoAgua.getId() != null) {
			imovel.setLigacaoAgua(ligacaoAgua);
		}
		// Seta a ligacao de esgoto
		if (ligacaoEsgoto.getId() != null) {
			imovel.setLigacaoEsgoto(ligacaoEsgoto);
		}
		//Seta Id Perfil do Imovel 
		if (arrayImovel[36] != null) {
			imovelPerfil.setId((Integer) arrayImovel[36]);
			imovel.setImovelPerfil(imovelPerfil);
		}
		
		
		return imovel;

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0001] - Determinar
	 * Dados para Faturamento de Água
	 * 
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings({ "rawtypes", "unchecked", "unlikely-arg-type" })
	protected void determinarDadosFaturamentoAgua(
			MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistorico, 
			SistemaParametro sistemaParametro, int quantidadeEconomias,
			Collection colecaoInserirMedicaoHistoricoAgua,
			Collection colecaoAtualizarMedicaoHistoricoAgua,
			Collection colecaoInserirConsumoHistoricoAgua,
			EsferaPoder esferaPoder) throws ControladorException,
			ErroRepositorioException {

		medicaoHistorico = new MedicaoHistorico();
		MedicaoTipo medicaoTipo = new MedicaoTipo(MedicaoTipo.LIGACAO_AGUA);
		
		Integer consumoMinimoBolsaAgua = Integer.valueOf(Fachada.getInstancia().getFaturamentoParametro(FaturamentoParametro.NOME_PARAMETRO_FATURAMENTO.CONSUMO_MINIMO_BOLSA_AGUA.toString()));
		
		boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(consumoHistorico.getImovel().getId(), medicaoTipo);
		medicaoTipo = new MedicaoTipo();
		
		boolean isLeituraMaiorCapacidade = false;

		Integer leituraMaiorCapacidade = null;

		FaturamentoGrupo faturamentoGrupo = consumoHistorico.getRota().getFaturamentoGrupo();
		Rota rota = consumoHistorico.getRota();
		
		logger.info("Consistindo imóvel " + consumoHistorico.getImovel().getId());
		
		int[] consumoMedioHidrometro = this.obterVolumeMedioAguaEsgoto(
				consumoHistorico.getImovel().getId(), faturamentoGrupo.getAnoMesReferencia(),
				consumoHistorico.getLigacaoTipo().getId(), houveIntslacaoHidrometro);
		
		if (consumoHistorico.getImovel().getLigacaoAgua() != null && consumoHistorico.getImovel().getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) {

			medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);
			medicaoHistorico = obterDadosHistoricoMedicao(faturamentoGrupo, consumoHistorico.getImovel(), medicaoTipo, sistemaParametro);
			medicaoHistorico.setImovel(consumoHistorico.getImovel());
			medicaoHistorico.setConsumoMedioHidrometro(new Integer(consumoMedioHidrometro[0]));

			int leituraAnterior = obterLeituraAnterior(medicaoHistorico);

			if (verificarSubstituicaoHidrometro(consumoHistorico.getImovel(), medicaoHistorico,	sistemaParametro)) {

				Integer leituraInstalacaoHidrometro = this.obterLeituraInstalacaoHidrometro(faturamentoGrupo, consumoHistorico.getImovel());

				if (medicaoHistorico.getLeituraAtualInformada() != null && medicaoHistorico.getLeituraAtualInformada() > leituraInstalacaoHidrometro) {

					consumoHistorico.setConsumoTipo(determinarConsumoTipo(medicaoHistorico));
					consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getLeituraAtualInformada() - leituraInstalacaoHidrometro);
					medicaoHistorico.setNumeroConsumoMes(medicaoHistorico.getLeituraAtualInformada() - leituraInstalacaoHidrometro);
					medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

					Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasCategoria(consumoHistorico.getImovel());

					if (verificarEstouroConsumo(consumoHistorico, consumoMedioHidrometro, consumoMedioHidrometro, faturamentoGrupo, medicaoTipo, colecaoCategoria, medicaoHistorico, leituraAnterior)) {
						
						verificarAltoConsumo(consumoHistorico, colecaoCategoria, consumoHistorico.getImovel(), faturamentoGrupo, 
								consumoMedioHidrometro, medicaoTipo, medicaoHistorico);
					}
				}  else {
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioHidrometro[0]);
					
					medicaoHistorico.setNumeroConsumoMes(null);
					medicaoHistorico.setLeituraAtualFaturamento(leituraInstalacaoHidrometro + consumoMedioHidrometro[0]);

					ConsumoTipo consumoTipo = new ConsumoTipo(ConsumoTipo.MEDIA_HIDROMETRO);
					consumoHistorico.setConsumoTipo(consumoTipo);
				}

				determinarAjusteMensal(medicaoHistorico, consumoHistorico, consumoHistorico.getImovel(), rota, consumoMedioHidrometro[0], sistemaParametro);

				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO);
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

				medicaoHistorico.setLeituraAnteriorFaturamento(leituraInstalacaoHidrometro);

				if (consumoHistorico.getImovel().getLigacaoAgua() != null && consumoHistorico.getImovel().getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) {
					medicaoHistorico.setHidrometroInstalacaoHistorico(consumoHistorico.getImovel().getLigacaoAgua().getHidrometroInstalacaoHistorico());
				} else {
					medicaoHistorico.setHidrometroInstalacaoHistorico(consumoHistorico.getImovel().getHidrometroInstalacaoHistorico());
				}

			}

			if (medicaoHistorico.getLeituraAtualInformada() != null && !verificarSubstituicaoHidrometro(consumoHistorico.getImovel(), medicaoHistorico, sistemaParametro)) {

				Double numeroLimite = obterNumeroLimiteHidrometro(medicaoHistorico, consumoHistorico.getImovel());

				if (medicaoHistorico.getLeituraAtualInformada().intValue() > numeroLimite) {
					isLeituraMaiorCapacidade = true;
					leituraMaiorCapacidade = medicaoHistorico.getLeituraAtualInformada();

					medicaoHistorico.setLeituraAtualInformada(numeroLimite.intValue());
				}

				if (medicaoHistorico.getLeituraAtualInformada().intValue() > leituraAnterior) {
					dadosFaturamentoLeituraMaiorAnterior(medicaoHistorico, consumoHistorico, consumoMedioHidrometro[0], consumoHistorico.getImovel(), rota, sistemaParametro);

				} else if (medicaoHistorico.getLeituraAtualInformada().intValue() == leituraAnterior) {
					dadosFaturamentoLeituraIgualAnterior(medicaoHistorico, consumoHistorico, medicaoTipo, consumoHistorico.getImovel(), null, rota, consumoMedioHidrometro, sistemaParametro);

				} else if (medicaoHistorico.getLeituraAtualInformada().intValue() < leituraAnterior) {
					dadosFaturamentoLeituraMenorAnterior(consumoHistorico.getImovel(), consumoHistorico, medicaoHistorico,
							sistemaParametro, leituraAnterior, medicaoTipo, consumoMedioHidrometro, consumoMedioHidrometro, rota);

				}
			} else if (medicaoHistorico.getLeituraAtualInformada() == null && medicaoHistorico.getLeituraAnormalidadeFaturamento() == null) {
				dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(medicaoHistorico, consumoHistorico, consumoMedioHidrometro, leituraAnterior, sistemaParametro, rota);
			}

			if (medicaoHistorico.getLeituraAnormalidadeFaturamento() != null) {
				dadosFaturamentoAnormalidadeLeitura(medicaoHistorico, consumoHistorico, consumoMedioHidrometro, leituraAnterior, consumoHistorico.getImovel(), rota);
			}

			Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasCategoria(consumoHistorico.getImovel());

			if (consumoHistorico.getConsumoAnormalidade() == null
					|| (consumoHistorico.getConsumoAnormalidade() != null
							&& consumoHistorico.getConsumoAnormalidade().getId() != null
							&& !consumoHistorico.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_ANTERIOR) 
							&& !consumoHistorico.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_PROJETADA))
					&& !consumoHistorico.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO)) {

				if (!verificarEstouroConsumo(consumoHistorico, consumoMedioHidrometro, consumoMedioHidrometro, faturamentoGrupo, medicaoTipo,
						colecaoCategoria, medicaoHistorico, leituraAnterior)) {

					verificarAltoConsumo(consumoHistorico, colecaoCategoria, consumoHistorico.getImovel(), faturamentoGrupo, consumoMedioHidrometro,medicaoTipo, medicaoHistorico);
				}

				if (!consumoHistorico.getImovel().getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO)
						&& (consumoHistorico.getImovel().getPocoTipo() == null 
							|| consumoHistorico.getImovel().getPocoTipo().getId() == null)
						&& (medicaoHistorico.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.CONFIRMADA.intValue() 
							|| medicaoHistorico.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.REALIZADA.intValue())
						&& medicaoHistorico.getLeituraAnormalidadeFaturamento() == null) {

					verificarBaixoConsumo(consumoHistorico, colecaoCategoria, consumoHistorico.getImovel(), faturamentoGrupo, consumoMedioHidrometro,
							medicaoTipo, medicaoHistorico);
				}
			}

			Double numeroLimiteDoHidrometro = obterNumeroLimiteHidrometro(medicaoHistorico, consumoHistorico.getImovel());

			if (medicaoHistorico.getLeituraAtualFaturamento() > numeroLimiteDoHidrometro.intValue()) {
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualFaturamento() - numeroLimiteDoHidrometro.intValue());

			}

			ConsumoTipo consumoTipo = new ConsumoTipo();
			ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

			if (verificarSituacaoEspecialFaturamentoImovel(consumoHistorico.getImovel(), faturamentoGrupo)) {
				dadosFaturamentoEspecialMedido(medicaoHistorico, consumoHistorico, consumoHistorico.getImovel(), consumoMedioHidrometro, leituraAnterior, faturamentoGrupo);
			}

			verificarConsumoMinimoCobrado(medicaoHistorico, consumoHistorico, consumoHistorico.getImovel(), consumoTipo, consumoAnormalidade);

			if (consumoTipo.getId() != null) {
				consumoHistorico.setConsumoTipo(consumoTipo);
			}

			if (consumoAnormalidade.getId() != null) {
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
			}

		} else {
			// [SF0004] - Determinar Dados para Faturamento de Água do Não Medido
			ConsumoTipo consumoTipo = new ConsumoTipo();

			if (consumoHistorico.getImovel().getLigacaoAgua() != null && consumoHistorico.getImovel().getLigacaoAgua().getNumeroConsumoMinimoAgua() != null) {

				consumoHistorico.setNumeroConsumoFaturadoMes(consumoHistorico.getImovel().getLigacaoAgua().getNumeroConsumoMinimoAgua());
				consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

			} else {

				int consumoCobradoMes = 0;

				if (sistemaParametro.getIndicadorNaoMedidoTarifa().equals(ConstantesSistema.SIM)) {
					consumoCobradoMes = obterConsumoMinimoLigacao(consumoHistorico.getImovel(), null);

				} else {
					if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null && sistemaParametro.getCodigoTipoCalculoNaoMedido().equals(new Integer(1))) {

						consumoCobradoMes = this.obterConsumoNaoMedido(consumoHistorico.getImovel());

					} else if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& (sistemaParametro.getCodigoTipoCalculoNaoMedido().equals(new Integer(2)) 
									|| sistemaParametro.getCodigoTipoCalculoNaoMedido().equals(new Integer(3)))) {

						consumoCobradoMes = this.obterConsumoNaoMedidoPorParametro(consumoHistorico.getImovel().getId(),sistemaParametro.getAnoMesFaturamento(),null);
					}
				}

				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(consumoCobradoMes));
				consumoTipo.setId(ConsumoTipo.NAO_MEDIDO);
			}
			
			boolean indicadorBolsaAgua  = consumoHistorico.getImovel().getImovelPerfil().getId().equals(ImovelPerfil.BOLSA_AGUA);
			if (indicadorBolsaAgua
					&& (consumoHistorico.getNumeroConsumoFaturadoMes() <= consumoMinimoBolsaAgua)) {
				// Seta o consumo histórico
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoBolsaAgua);
				consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_BOLSA_AGUA);
			}

			if (consumoTipo.getId() != null) {
				consumoHistorico.setConsumoTipo(consumoTipo);
			}

			FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = obterSituacaoEspecialFaturamentoImovel(consumoHistorico.getImovel());

			if (faturamentoSituacaoHistorico != null
					&& faturamentoGrupo != null
					&& faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio()
					&& faturamentoGrupo.getAnoMesReferencia() <= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoFim()
					&& consumoHistorico.getImovel().getFaturamentoSituacaoTipo() != null
					&& consumoHistorico.getImovel().getFaturamentoSituacaoTipo().getIndicadorValidoAgua() != null
					&& consumoHistorico.getImovel().getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue() == 1
					&& !indicadorBolsaAgua) {

				dadosFaturamentoEspecialNaoMedido(consumoHistorico,consumoMedioHidrometro, consumoHistorico.getImovel(), faturamentoGrupo);
			}
				
		}		
			

		if (consumoHistorico.getImovel().getLigacaoAgua() != null && consumoHistorico.getImovel().getLigacaoAgua().getId() != null) {
			// 2. Caso imovel tenha situacao da ligacao de agua com indicador de consumo real igual a 1
			LigacaoAguaSituacao ligacaoAguaSituacao = (LigacaoAguaSituacao) this.repositorioMicromedicao
					.obterDadosSituacaoLigacaoAgua(consumoHistorico.getImovel().getLigacaoAguaSituacao().getId());
			
			if (ligacaoAguaSituacao != null && ligacaoAguaSituacao.getIndicadorConsumoReal().equals(ConstantesSistema.SIM)) {
				// 2.1 Caso o numero de dias de corte da tabela da situacao da ligacao de agua do imovel seja diferente de null e maior que zero
				if (ligacaoAguaSituacao.getNumeroDiasCorte() != null && ligacaoAguaSituacao.getNumeroDiasCorte().shortValue() > ConstantesSistema.ZERO.shortValue()) {
					
					// 2.1.1 Caso o imovel seja medido (hidi_id na tabela de ligacao de agua)
					if (consumoHistorico.getImovel().getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
							&& consumoHistorico.getImovel().getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null) {
						
						// 2.1.1.1 Caso a data do corte do imovel seja menor que 30 dias da data de leitura anterior faturada
						Object[] objetoLigacaoAgua = repositorioAtendimentoPublico.pesquisarDadosLigacaoAgua(consumoHistorico.getImovel().getId());
						
						Date dataCorte = (Date) objetoLigacaoAgua[3];
						Date dataLeituraAnterior = medicaoHistorico.getDataLeituraAnteriorFaturamento();
						
						if (dataCorte != null) {
							int numeroDiasDiferecaDatas = Util.obterQuantidadeDiasEntreDuasDatasPositivo(dataLeituraAnterior, dataCorte);

							if (numeroDiasDiferecaDatas <= 30) {
								// 2.1.1.1.1 Caso a diferenca entre as datas (data corte - dataLeituraAnteriorFaturada) for maior do que LAST_NNDIASCORTE da 
								// ligacao de água
								if (numeroDiasDiferecaDatas < ligacaoAguaSituacao.getNumeroDiasCorte()) {
									// o sistema informara que o indicador de faturamento do consumo historico será igual a 2 (Não)
									consumoHistorico.setIndicadorFaturamento(ConstantesSistema.NAO);
								} else {
									consumoHistorico.setIndicadorFaturamento(ConstantesSistema.SIM);
								}
							}
							// 2.1.1.2 Caso a diferenca de datas seja maior que 1 mes (30 dias)
							else {
								// // 2.1.1.2.2 Caso o Tipo de Consumo seja diferente de real
								if (consumoHistorico.getConsumoTipo() != null && !consumoHistorico.getConsumoTipo().getId().equals(ConsumoTipo.REAL)
										&& consumoHistorico.getNumeroConsumoFaturadoMes() > 0) {
									// O sistema informara que o indicador de faturamento do consumo historico será igual a 2 (Não)
									consumoHistorico.setIndicadorFaturamento(ConstantesSistema.NAO);
								} else {
									consumoHistorico.setIndicadorFaturamento(ConstantesSistema.SIM);
								}
							}
						}
					}
					
					// 2.1.2 Caso o imovel seja não medido (não tenha hidi_id em ligacao de agua)
					else {
						// 2.1.2.1 Caso a data do corte do imovel seja menor que 1 mes (30 dias) em relacao a data prevista da atividade de faturamento

						// obtendo a data do corte
						Object[] objetoLigacaoAgua = repositorioAtendimentoPublico.pesquisarDadosLigacaoAgua(consumoHistorico.getImovel().getId());
						Date dataCorte = (Date) objetoLigacaoAgua[3];
						
						// obtendo a data prevista
						FaturamentoAtividade faturamentoAtividade = new FaturamentoAtividade();
						faturamentoAtividade.setId(FaturamentoAtividade.EFETUAR_LEITURA);
						
						Integer anoMesAnterior = Util.subtraiAteSeisMesesAnoMesReferencia(faturamentoGrupo.getAnoMesReferencia(),1);
						Object[] datasPrevistasERealizadas = repositorioFaturamento.obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
										faturamentoGrupo, anoMesAnterior, faturamentoAtividade);
						
						Date dataPrevistaAtividadeLeitura = (Date) datasPrevistasERealizadas[1];
						
						if (dataPrevistaAtividadeLeitura == null) {
							dataPrevistaAtividadeLeitura = (Date) datasPrevistasERealizadas[0];
						}
						
						if (dataCorte != null && dataPrevistaAtividadeLeitura != null) {
							
							int numeroDiasDiferecaDatas = Util.obterQuantidadeDiasEntreDuasDatasPositivo(dataPrevistaAtividadeLeitura,dataCorte);
							
							if (numeroDiasDiferecaDatas <= 30) {
								// 2.1.1.1.1 Caso a diferenca entre as datas (data corte - dataLeituraAnteriorFaturada) for maior do que 
								// LAST_NNDIASCORTE da ligacao de água
								if (ligacaoAguaSituacao.getNumeroDiasCorte() != null  
										&& ligacaoAguaSituacao.getNumeroDiasCorte().shortValue() > ConstantesSistema.ZERO.shortValue()
										&& numeroDiasDiferecaDatas < ligacaoAguaSituacao.getNumeroDiasCorte()) {
									
									// o sistema informara que o indicador de faturamento do consumo historico será igual a 2 (Não)
									consumoHistorico.setIndicadorFaturamento(ConstantesSistema.NAO);
								} else {
									consumoHistorico.setIndicadorFaturamento(ConstantesSistema.SIM);
								}
							}
							// 2.1.1.2 Caso a diferenca de datas seja maior que 1 mes (30 dias)
							else {
								// O sistema informara que o indicador de faturamento do consumo historico será igual a 2 (Não)
								consumoHistorico.setIndicadorFaturamento(ConstantesSistema.NAO);
							}
						}

					}
				}

			}
		}

		if (quantidadeEconomias > 1) {
			ajusteConsumoMultiploQuantidadeEconomias(consumoHistorico.getImovel(), medicaoHistorico,  consumoHistorico, quantidadeEconomias, sistemaParametro,faturamentoGrupo);
		}

		medicaoHistorico.setUltimaAlteracao(new Date());

		if (consumoHistorico.getImovel().getLigacaoAgua() != null && consumoHistorico.getImovel().getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) {

			if (medicaoHistorico.getId() == null) {
				colecaoInserirMedicaoHistoricoAgua.add(medicaoHistorico);
			} else {
				colecaoAtualizarMedicaoHistoricoAgua.add(medicaoHistorico);
			}

			int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());

			if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)) {

				if (consumoHistorico.getImovel().getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
						&& (mes == 11)
						&& esferaPoder != null
						&& (esferaPoder.getId().equals(new Integer(EsferaPoder.MUNICIPAL))
								|| esferaPoder.getId().equals(new Integer(EsferaPoder.ESTADUAL)) 
								|| esferaPoder.getId().equals(new Integer(EsferaPoder.FEDERAL)))) {

					MedicaoHistorico medicaoHistoricoPosterior = new MedicaoHistorico();

					Integer anoMesFaturamentoAntecipado = (Util.somaMesAnoMesReferencia(sistemaParametro.getAnoMesFaturamento(), 1));

					sistemaParametro.setAnoMesFaturamento(anoMesFaturamentoAntecipado);
					
					faturamentoGrupo.setAnoMesReferencia(anoMesFaturamentoAntecipado);

					medicaoHistoricoPosterior = obterDadosHistoricoMedicao(faturamentoGrupo, consumoHistorico.getImovel(), medicaoTipo, sistemaParametro);

					Integer anoMesFaturamentoAtual = Util.subtrairMesDoAnoMes(anoMesFaturamentoAntecipado, 1);

					sistemaParametro.setAnoMesFaturamento(anoMesFaturamentoAtual);

					faturamentoGrupo.setAnoMesReferencia(anoMesFaturamentoAtual);

					
					medicaoHistoricoPosterior.setLeituraAnormalidadeFaturamento(medicaoHistorico.getLeituraAnormalidadeFaturamento());
					medicaoHistoricoPosterior.setLeituraAnteriorFaturamento(medicaoHistorico.getLeituraAtualFaturamento());
					medicaoHistoricoPosterior.setDataLeituraAnteriorFaturamento(medicaoHistorico.getDataLeituraAtualFaturamento());

					Date dataAtual = new Date();

					int qtdDIas = (int) getControladorFaturamento().obterDiferencaDiasCronogramas(sistemaParametro.getAnoMesFaturamento(), rota, FaturamentoAtividade.EFETUAR_LEITURA);
					
					medicaoHistoricoPosterior.setDataLeituraAtualFaturamento(Util.adicionarNumeroDiasDeUmaData(dataAtual,qtdDIas));

					Integer leituraAtual = medicaoHistorico.getLeituraAtualFaturamento() + consumoHistorico.getNumeroConsumoFaturadoMes();

					medicaoHistoricoPosterior.setLeituraAtualFaturamento(leituraAtual);
					medicaoHistoricoPosterior.setConsumoMedioHidrometro(medicaoHistorico.getConsumoMedioHidrometro());
					medicaoHistoricoPosterior.setUltimaAlteracao(new Date());

					if (medicaoHistoricoPosterior.getId() == null) {
						colecaoInserirMedicaoHistoricoAgua.add(medicaoHistoricoPosterior);
					} else {
						colecaoAtualizarMedicaoHistoricoAgua.add(medicaoHistoricoPosterior);
					}
				}
			}
		}

		consumoHistorico.setImovel(consumoHistorico.getImovel());

		LigacaoTipo ligacaoTipo = new LigacaoTipo(LigacaoTipo.LIGACAO_AGUA);

		consumoHistorico.setLigacaoTipo(ligacaoTipo);
		consumoHistorico.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
		consumoHistorico.setIndicadorAlteracaoUltimosConsumos(ConstantesSistema.NAO);
		consumoHistorico.setIndicadorAjuste(rota.getIndicadorAjusteConsumo());
		consumoHistorico.setConsumoRateio(null);
		consumoHistorico.setConsumoHistoricoCondominio(null);
		consumoHistorico.setIndicadorImovelCondominio(consumoHistorico.getImovel().getIndicadorImovelCondominio());
		consumoHistorico.setConsumoMedio(new Integer(consumoMedioHidrometro[0]));
		
		if(consumoHistorico.getImovel().getImovelPerfil().getId().equals(ImovelPerfil.BOLSA_AGUA)) {
			consumoHistorico.setConsumoMinimo(consumoMinimoBolsaAgua);
		} else {
			consumoHistorico.setConsumoMinimo(consumoHistorico.getImovel().getLigacaoAgua() != null ? consumoHistorico.getImovel().getLigacaoAgua().getNumeroConsumoMinimoAgua() : null);
		}
		
		consumoHistorico.setPercentualColeta(null);
		consumoHistorico.setUltimaAlteracao(new Date());

		if (consumoHistorico.getId() == null) {
			RateioTipo rateioTipo = new RateioTipo();
			rateioTipo.setId(RateioTipo.SEM_RATEIO);
			consumoHistorico.setRateioTipo(rateioTipo);
		}
		
		consumoHistorico.setPocoTipo(consumoHistorico.getImovel().getPocoTipo());

		FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = obterSituacaoEspecialFaturamentoImovel(consumoHistorico.getImovel());

		if (consumoHistorico.getImovel().getFaturamentoSituacaoTipo() != null
				&& faturamentoSituacaoHistorico != null
				&& faturamentoGrupo != null
				&& faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio()
				&& faturamentoGrupo.getAnoMesReferencia() <= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoFim()) {
			consumoHistorico.setFaturamentoSituacaoTipo(consumoHistorico.getImovel().getFaturamentoSituacaoTipo());
		} else {
			consumoHistorico.setFaturamentoSituacaoTipo(null);
		}
		
		consumoHistorico.setNumeroConsumoCalculoMedia(consumoHistorico.getNumeroConsumoFaturadoMes());

		boolean faturar = this.getControladorFaturamento().permiteFaturamentoParaAgua(consumoHistorico.getImovel().getLigacaoAguaSituacao(),
						consumoHistorico.getNumeroConsumoFaturadoMes(), consumoHistorico.getConsumoTipo());

		if (consumoHistorico.getIndicadorFaturamento() != null && consumoHistorico.getIndicadorFaturamento().shortValue() == ConstantesSistema.NAO.shortValue()) {
			faturar = false;
		}

		if (consumoHistorico.getImovel().getFaturamentoSituacaoTipo() == null && faturar) {
			consumoHistorico.setIndicadorFaturamento(ConstantesSistema.SIM);
		} else if ((faturamentoSituacaoHistorico != null
						&& faturamentoGrupo != null
						&& faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio() 
						&& faturamentoGrupo.getAnoMesReferencia() <= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoFim())
					&& (consumoHistorico.getImovel().getFaturamentoSituacaoTipo() != null
						&& consumoHistorico.getImovel().getFaturamentoSituacaoTipo().getIndicadorParalisacaoFaturamento().intValue() == 1 
						&& consumoHistorico.getImovel().getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue() == 1) 
					|| (!faturar)) {
			consumoHistorico.setIndicadorFaturamento(ConstantesSistema.NAO);
		} else {
			if (faturar) {
				consumoHistorico.setIndicadorFaturamento(ConstantesSistema.SIM);
			} else {
				consumoHistorico.setIndicadorFaturamento(ConstantesSistema.NAO);
			}
		}

		colecaoInserirConsumoHistoricoAgua.add(consumoHistorico);

		int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());

		if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)) {

			if (consumoHistorico.getImovel().getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
					&& (mes == 11)
					&& esferaPoder != null
					&& (esferaPoder.getId().equals(new Integer(EsferaPoder.MUNICIPAL))
						|| esferaPoder.getId().equals(new Integer(EsferaPoder.ESTADUAL)) 
						|| esferaPoder.getId().equals(new Integer(EsferaPoder.FEDERAL)))) {

				ConsumoHistorico consumoHistoricoPosterior = new ConsumoHistorico(consumoHistorico);

				consumoHistoricoPosterior.setReferenciaFaturamento(Util.somaMesAnoMesReferencia(consumoHistorico.getReferenciaFaturamento(), 1));
				consumoHistoricoPosterior.setUltimaAlteracao(new Date());

				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade(ConsumoAnormalidade.FATURAMENTO_ANTECIPADO);

				consumoHistoricoPosterior.setConsumoAnormalidade(consumoAnormalidade);

				colecaoInserirConsumoHistoricoAgua.add(consumoHistoricoPosterior);

			}
		}

		if (!faturar) {
			consumoHistorico.setNumeroConsumoFaturadoMes(0);
		}

		if (isLeituraMaiorCapacidade) {
			medicaoHistorico.setLeituraAtualInformada(leituraMaiorCapacidade);
		}
		logger.info("*****************************");
		logger.info("Imovel: " + consumoHistorico.getImovel().getId());
		logger.info("Consumo Agua:  " + consumoHistorico.getNumeroConsumoFaturadoMes());
		logger.info("Consumo Calculo Media: " + consumoHistorico.getNumeroConsumoCalculoMedia());
		
		if (consumoHistorico.getConsumoTipo() != null) {
			logger.info("Consumo Tipo:  " + (consumoHistorico.getConsumoTipo().getId() == null ? null: consumoHistorico.getConsumoTipo().getId()));
		} else {
			logger.info("Consumo Tipo:  " + consumoHistorico.getConsumoTipo());
		}
		logger.info("*****************************");
		
	}

	protected MedicaoHistorico obterDadosHistoricoMedicao(FaturamentoGrupo faturamentoGrupo, Imovel imovel,MedicaoTipo medicaoTipo, 
			SistemaParametro sistemaParametro) throws ControladorException {

		MedicaoHistorico retorno = null;
		Collection<MedicaoHistorico> colecaoMedicaoHistorico = null;

		try {
			colecaoMedicaoHistorico = repositorioMicromedicao.pesquisarObterDadosHistoricoMedicao(imovel, medicaoTipo,faturamentoGrupo);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		MedicaoHistorico medicaoHistorico = obterHistoricoMedicao(colecaoMedicaoHistorico);

		retorno = verificarExistenciaHistoricoMedicao(faturamentoGrupo,medicaoHistorico, imovel, medicaoTipo, sistemaParametro);

		/**
		 * Recupera a data de leitura informada para a data de leitura faturada.
		 * Isso é necessário para quando o processo for re-executado, levar em
		 * consideração a data que foi colhida em campo, e não a data já
		 * ajustada na primeira execução
		 * 
		 * Data: 17/10/2008 Analista: Aryed Programadores: Rossiter/Bruno
		 */
		if (retorno.getDataLeituraAtualInformada() != null) {
			retorno.setDataLeituraAtualFaturamento(retorno
					.getDataLeituraAtualInformada());
		}

		return retorno;
	}

	public MedicaoHistorico obterHistoricoMedicao(Collection<MedicaoHistorico> colecaoMedicaoHistorico) {

		MedicaoHistorico retorno = null;

		if (colecaoMedicaoHistorico != null && !colecaoMedicaoHistorico.isEmpty()) {
			retorno = (MedicaoHistorico) Util.retonarObjetoDeColecao(colecaoMedicaoHistorico);
		}

		return retorno;
	}

	/**
	 * Método utilizado obter o consumo histórico de um imóvel de acordo com o
	 * tipo de ligação e ano mês de referência
	 */

	public ConsumoHistorico obterConsumoHistorico(Imovel imovel,
			LigacaoTipo ligacaoTipo, int anoMesReferencia)
			throws ControladorException {
		
		try {
			return repositorioMicromedicao.pesquisarConsumoHistorico(imovel, ligacaoTipo, anoMesReferencia);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}
//
//		ConsumoHistorico consumoHistorico = null;
//
//		Collection colecaoConsumoHistoricoArray = null;
//
//		try {
//			colecaoConsumoHistoricoArray = repositorioMicromedicao
//					.pesquisarConsumoHistorico(imovel, ligacaoTipo,
//							anoMesReferencia);
//		} catch (ErroRepositorioException ex) {
//			sessionContext.setRollbackOnly();
//			throw new ControladorException("erro.sistema", ex);
//		}
//
//		if (colecaoConsumoHistoricoArray != null
//				&& !colecaoConsumoHistoricoArray.isEmpty()) {
//
//			Object[] consumoHistoricoArray = (Object[]) Util
//					.retonarObjetoDeColecaoArray(colecaoConsumoHistoricoArray);
//
//			consumoHistorico = new ConsumoHistorico();
//
//			// Seta o id do histórico
//			if (consumoHistoricoArray[0] != null) {
//				consumoHistorico.setId((Integer) consumoHistoricoArray[0]);
//			}
//			// Seta o id do imóvel
//			if (consumoHistoricoArray[1] != null) {
//				imovel.setId(imovel.getId());
//			}
//			// Seta o tipo de ligação
//			if (consumoHistoricoArray[2] != null) {
//				consumoHistorico.setLigacaoTipo(ligacaoTipo);
//			}
//
//			// Seta o ano mes de referência
//			if (consumoHistoricoArray[3] != null) {
//				consumoHistorico.setReferenciaFaturamento(anoMesReferencia);
//			}
//			// Seta o indicador de alteração dos últimos consumos
//			if (consumoHistoricoArray[4] != null) {
//				consumoHistorico
//						.setIndicadorAlteracaoUltimosConsumos(new Short("2"));
//			}
//
//			// Seta o indicador de ajuste
//			if (consumoHistoricoArray[5] != null) {
//				consumoHistorico
//						.setIndicadorAjuste((Short) consumoHistoricoArray[5]);
//			}
//
//			// Não necessário, será calculado
//			// Seta o consumo a ser cobrado no mês
//			/*
//			 * if (consumoHistoricoArray[6] != null) { consumoHistorico
//			 * .setNumeroConsumoFaturadoMes((Integer) consumoHistoricoArray[6]);
//			 * }
//			 */
//
//			// Seta o consumo rateio
//			if (consumoHistoricoArray[7] != null) {
//				consumoHistorico
//						.setConsumoRateio((Integer) consumoHistoricoArray[7]);
//			}
//
//			// Seta o consumo histórico condomínio
//			if (consumoHistoricoArray[8] != null) {
//				ConsumoHistorico consumoHistoricoCondominio = new ConsumoHistorico();
//
//				consumoHistoricoCondominio
//						.setId((Integer) consumoHistoricoArray[8]);
//				consumoHistorico
//						.setConsumoHistoricoCondominio(consumoHistoricoCondominio);
//			}
//
//			// Seta o indicador imóvel condomínio
//			if (consumoHistoricoArray[9] != null) {
//				consumoHistorico
//						.setIndicadorImovelCondominio((Short) consumoHistoricoArray[9]);
//			}
//
//			// Seta o consumo médio
//			if (consumoHistoricoArray[10] != null) {
//				consumoHistorico
//						.setConsumoMedio((Integer) consumoHistoricoArray[10]);
//			}
//
//			// Seta o consumo mínimo de água
//			if (consumoHistoricoArray[11] != null) {
//				consumoHistorico
//						.setConsumoMinimo((Integer) consumoHistoricoArray[11]);
//			}
//
//			// Seta o percentual de coleta
//			if (consumoHistoricoArray[12] != null) {
//				consumoHistorico
//						.setPercentualColeta((BigDecimal) consumoHistoricoArray[12]);
//			}
//
//			// Seta a última alteração
//			if (consumoHistoricoArray[13] != null) {
//				consumoHistorico
//						.setUltimaAlteracao((Date) consumoHistoricoArray[13]);
//			}
//
//			// Seta o rateio tipo
//			if (consumoHistoricoArray[14] != null) {
//				RateioTipo rateioTipo = new RateioTipo();
//
//				rateioTipo.setId((Integer) consumoHistoricoArray[14]);
//				consumoHistorico.setRateioTipo(rateioTipo);
//			}
//
//			// Não necessário, será definido
//			// Seta o consumo tipo
//
//			if (consumoHistoricoArray[15] != null) {
//				ConsumoTipo consumoTipo = new ConsumoTipo();
//
//				consumoTipo.setId((Integer) consumoHistoricoArray[15]);
//				consumoHistorico.setConsumoTipo(consumoTipo);
//			}
//
//			// Seta o poço tipo
//			if (consumoHistoricoArray[17] != null) {
//				PocoTipo pocoTipo = new PocoTipo();
//
//				pocoTipo.setId((Integer) consumoHistoricoArray[17]);
//				consumoHistorico.setPocoTipo(pocoTipo);
//			}
//
//			// Seta o faturamento situação tipo
//			if (consumoHistoricoArray[18] != null) {
//				FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
//
//				faturamentoSituacaoTipo.setId((Integer) consumoHistoricoArray[18]);
//				consumoHistorico.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
//			}
//
//			// Seta o faturamento situação tipo
//			if (consumoHistoricoArray[19] != null) {
//				consumoHistorico.setIndicadorFaturamento((Short) consumoHistoricoArray[19]);
//			}
//
//			if (consumoHistoricoArray[20] != null) {
//				consumoHistorico.setConsumoImovelVinculadosCondominio((Integer) consumoHistoricoArray[20]);
//			}
//			
//			// Seta o faturamento situação tipo
//			if (consumoHistoricoArray[21] != null) {
//				consumoHistorico.setNumeroConsumoFaturadoMes((Integer) consumoHistoricoArray[21]);
//			}
//		}
//
//		return consumoHistorico;
//	}

	protected MedicaoHistorico verificarExistenciaHistoricoMedicao(FaturamentoGrupo faturamentoGrupo, MedicaoHistorico medicaoHistorico, Imovel imovel,
			MedicaoTipo medicaoTipo, SistemaParametro sistemaParametro) throws ControladorException {

		MedicaoHistorico retorno = null;

		if (medicaoHistorico == null || medicaoHistorico.getId() == null) {
			retorno = gerarHistoricoMedicao(medicaoTipo, imovel, faturamentoGrupo, sistemaParametro);

		} else {
			retorno = medicaoHistorico;
		}

		return retorno;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param faturamentoGrupo
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 */
	protected Object[] obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
			FaturamentoGrupo faturamentoGrupo, Integer anoMesFaturamento)
			throws ControladorException {

		FaturamentoAtividade faturamentoAtividade = new FaturamentoAtividade();

		faturamentoAtividade.setId(FaturamentoAtividade.EFETUAR_LEITURA);

		Object[] datas = null;

		Date dataPrevista = new Date();

		try {
			datas = repositorioFaturamento
					.obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
							faturamentoGrupo, anoMesFaturamento,
							faturamentoAtividade);

			if (datas != null) {
				dataPrevista = (Date) datas[0];
			} else {
				datas = new Object[1];
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (!dataPrevista.before(new Date())) {
			datas[0] = (new Date());
		}

		return datas;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param numeroConsumoFaturadoMes
	 *            Descrição do parâmetro
	 * @param percentual
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 */
	public int calculoConsumoLigacaoEsgoto(int consumoCalculoMedia,
			BigDecimal percentual) {

		BigDecimal numerador = new BigDecimal(consumoCalculoMedia * 100);
		BigDecimal denominador = percentual;
		BigDecimal resultado = numerador.divide(denominador,
				BigDecimal.ROUND_HALF_UP);
		Integer consumoFaturadoMesEsgoto = new Integer(resultado.intValue());

		return consumoFaturadoMesEsgoto.intValue();
	}

	/**
	 * Método para obter a coleção de um período informado (quantidade de meses)
	 * e de acordo com o mes e ano de referencia
	 */
	/*
	 * protected Collection obterColecaoPeriodoInformado(int periodoInformado,
	 * int mesAnoReferencia, Filtro filtro, Imovel imovel, MedicaoTipo
	 * medicaoTipo) throws ControladorException {
	 * 
	 * Collection retorno = null; // Obtém a coleção de acordo com - > MEDIÇÃO
	 * HISTÓRICO if (filtro instanceof FiltroMedicaoHistorico) {
	 * 
	 * FiltroMedicaoHistorico filtroMedicaoHistorico = (FiltroMedicaoHistorico)
	 * filtro;
	 * 
	 * ParametroSimples parametroSimples = new ParametroSimples(
	 * FiltroMedicaoHistorico.IMOVEL_ID, imovel.getId()); // Laço de acordo com
	 * o período informado for (int i = 0; i < periodoInformado; i++) {
	 * 
	 * mesAnoReferencia = Util.subtrairData(mesAnoReferencia); // Adiciona o
	 * parametro de acordo como o período informado
	 * filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
	 * FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO, new
	 * Integer(mesAnoReferencia), ParametroSimples.CONECTOR_AND)); } // Define o
	 * filtro de acordo com o tipo de medição filtroMedicaoHistorico
	 * .adicionarParametro(new ParametroSimples(
	 * FiltroMedicaoHistorico.MEDICAO_TIPO_ID, medicaoTipo .getId())); //
	 * Realiza a pesquisa try { retorno =
	 * repositorioUtil.pesquisar(filtroMedicaoHistorico,
	 * MedicaoHistorico.class.getName()); } catch (ErroRepositorioException ex)
	 * { sessionContext.setRollbackOnly(); throw new
	 * ControladorException("erro.sistema", ex); } }
	 * 
	 * return retorno; }
	 */

	protected int obterLeituraAnterior(MedicaoHistorico medicaoHistorico) {
		int retorno = 0;

		if (medicaoHistorico.getLeituraAnteriorInformada() != null && medicaoHistorico.getLeituraAtualInformada() != null) {

			if (medicaoHistorico.getLeituraAnteriorInformada().intValue() == medicaoHistorico.getLeituraAtualInformada().intValue()) {
				retorno = medicaoHistorico.getLeituraAnteriorInformada().intValue();
			} else {
				retorno = medicaoHistorico.getLeituraAnteriorFaturamento();
			}

		} else {

			retorno = medicaoHistorico.getLeituraAnteriorFaturamento();
		}

		return retorno;
	}

	/**
	 * [UC0086] - Calcular Faixa de Leitura Esperada
	 */
	public int[] calcularFaixaLeituraEsperada(int media,
			MedicaoHistorico medicaoHistorico, Hidrometro hidrometro,
			Integer leituraAnteriorPesquisada) {

		int[] retorno = new int[2];

		// Criação de variáveis
		BigDecimal faixaInicial = null;
		BigDecimal faixaFinal = null;

		BigDecimal leituraAnterior = null;

		// Alterado por Sávio data:20/03/2007
		// Caso seja usado o método pelo consistirLeituraECalcularConsumo então
		// a leituraAnteriorPesquisada vem nulo para ser calculado a leitura
		// anterior
		if (leituraAnteriorPesquisada == null) {
			leituraAnterior = new BigDecimal(
					obterLeituraAnterior(medicaoHistorico));
			// Essa situação vem do gerarDadosParaLeitura que já vem com a
			// leituraAnteriorPesquisada
		} else {
			leituraAnterior = new BigDecimal(leituraAnteriorPesquisada);
		}

		BigDecimal mediaConsumo = new BigDecimal(media);

		// Caso a média seja até 10
		if (media <= 10) {
			faixaInicial = leituraAnterior;
			faixaFinal = leituraAnterior.add(mediaConsumo).add(
					new BigDecimal(10));
		}
		// Caso a média seja de 11 a 20
		else if (media >= 11 && media <= 20) {
			faixaInicial = leituraAnterior.add((new BigDecimal(0.4))
					.multiply(mediaConsumo));
			faixaFinal = leituraAnterior.add((new BigDecimal(1.6))
					.multiply(mediaConsumo));
		}
		// Caso a média seja de 21 a 45
		else if (media >= 21 && media <= 45) {
			faixaInicial = leituraAnterior.add((new BigDecimal(0.5))
					.multiply(mediaConsumo));
			faixaFinal = leituraAnterior.add((new BigDecimal(1.5))
					.multiply(mediaConsumo));
		}
		// Caso a média seja seja de 46 a 100
		else if (media >= 46 && media <= 100) {
			faixaInicial = leituraAnterior.add((new BigDecimal(0.6))
					.multiply(mediaConsumo));
			faixaFinal = leituraAnterior.add((new BigDecimal(1.4))
					.multiply(mediaConsumo));
		} else if (media > 100) {
			faixaInicial = leituraAnterior.add((new BigDecimal(0.7))
					.multiply(mediaConsumo));
			faixaFinal = leituraAnterior.add((new BigDecimal(1.3))
					.multiply(mediaConsumo));
		}

		int[] faixaEsperada = new int[2];

		// Faixa Inicial
		faixaEsperada[0] = Util.arredondar(faixaInicial);

		// Faixa Final
		faixaEsperada[1] = Util.arredondar(faixaFinal);

		retorno = verificarViradaHidrometroFaixaEsperada(hidrometro,
				faixaEsperada);

		return retorno;
	}

	/**
	 * [UC0086] - Calcular Faixa de Leitura Esperada [FS0001] - Verificar Virada
	 * do Hidrômetro
	 */
	protected int[] verificarViradaHidrometroFaixaEsperada(
			Hidrometro hidrometro, int[] faixaEsperada) {

		// Obtém o número de digitos da leitura
		if (hidrometro != null && !hidrometro.equals("")
				&& hidrometro.getNumeroDigitosLeitura() != null) {

			int numeroDigitosLeitura = hidrometro.getNumeroDigitosLeitura()
					.intValue();

			// 10 elevado ao número de digitos leitura
			Double valor = new Double((Math.pow(10.0, numeroDigitosLeitura)));
			int valorDigitos = valor.intValue() - 1;

			// Faixa Inicial
			if (faixaEsperada[0] > valorDigitos) {
				faixaEsperada[0] = faixaEsperada[0] - valor.intValue();

			}

			// Faixa Final
			if (faixaEsperada[1] > valorDigitos) {
				faixaEsperada[1] = faixaEsperada[1] - valor.intValue();
			}

		}

		return faixaEsperada;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0009] - Dados para
	 * Faturamento para Leitura Menor que a Anterior
	 */
	protected void dadosFaturamentoLeituraMenorAnterior(Imovel imovel,
			ConsumoHistorico consumoHistorico,
			MedicaoHistorico medicaoHistorico,
			SistemaParametro sistemaParametro, int leituraAnterior,
			MedicaoTipo medicaoTipo, int[] consumoMedioImovel,
			int[] consumoMedioHidrometro, Rota rota) {

		// int[] retorno = new int[1];

		int numeroDigitosLeitura = 0;
		Hidrometro hidrometro = null;
		Integer numeroLeituraInstalacao = null;

		// Identifica e armazena a data de instalação de acordo com o tipo de
		// medição
		if (medicaoTipo.getId() == MedicaoTipo.LIGACAO_AGUA) {
			// Obtém o hidrômetro
			hidrometro = imovel.getLigacaoAgua()
					.getHidrometroInstalacaoHistorico().getHidrometro();
			// Obtém o número de digitos da leitura
			numeroDigitosLeitura = imovel.getLigacaoAgua()
					.getHidrometroInstalacaoHistorico().getHidrometro()
					.getNumeroDigitosLeitura().intValue();
			// Obtém a leitura de instalação do hidrômetro
			numeroLeituraInstalacao = imovel.getLigacaoAgua()
					.getHidrometroInstalacaoHistorico()
					.getNumeroLeituraInstalacao();

			// Caso seja medição de <<<POÇO>>>
		} else if (medicaoTipo.getId() == MedicaoTipo.POCO) {
			// Obtém o hidrômetro
			hidrometro = imovel.getHidrometroInstalacaoHistorico()
					.getHidrometro();
			// Obtém o número de digitos da leitura
			numeroDigitosLeitura = imovel.getHidrometroInstalacaoHistorico()
					.getHidrometro().getNumeroDigitosLeitura().intValue();
			// Obtém a leitura de instalação do hidrômetro
			numeroLeituraInstalacao = imovel.getHidrometroInstalacaoHistorico()
					.getNumeroLeituraInstalacao();
		}

		// Criação de objetos
		ConsumoTipo consumoTipo = new ConsumoTipo();
		ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

		Double valor = new Double((Math.pow(10.0, numeroDigitosLeitura)));
		// Obtém o consumo calculado
		int consumoCalculado = (medicaoHistorico.getLeituraAtualInformada() + valor
				.intValue()) - leituraAnterior;

		// Caso exista virada de hidrômetro
		if (verificarViradaDeHidrometro(medicaoHistorico, imovel,
				leituraAnterior, consumoMedioHidrometro[0])) {
			// O Consumo medido e cobrado no mês serão iguais ao consumo
			// calculado

			medicaoHistorico.setNumeroConsumoMes(new Integer(consumoCalculado));
			consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
					consumoCalculado));

			// Caso a leitura situação anterior e atual estejam como a leitura
			// situação como leitura real
			if ((medicaoHistorico.getLeituraSituacaoAnterior().getId()
					.intValue() == LeituraSituacao.REALIZADA.intValue() || medicaoHistorico
					.getLeituraSituacaoAnterior().getId().intValue() == LeituraSituacao.CONFIRMADA
					.intValue())
					&& (medicaoHistorico.getLeituraSituacaoAtual().getId()
							.intValue() == LeituraSituacao.REALIZADA.intValue() || medicaoHistorico
							.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.CONFIRMADA
							.intValue())) {
				consumoTipo.setId(ConsumoTipo.REAL);
			} else {
				consumoTipo.setId(ConsumoTipo.ESTIMADO);
			}

			consumoHistorico.setConsumoTipo(consumoTipo);

			/**
			 *  12/04/2011 Pamela Gatinho Adicionando o calculo de
			 * ajuste
			 */
			determinarAjusteMensal(medicaoHistorico, consumoHistorico, imovel,
					rota, consumoMedioHidrometro[0], sistemaParametro);

			if (medicaoHistorico.getLeituraAtualFaturamento() < medicaoHistorico
					.getLeituraAnteriorFaturamento()) {
				// Seta a anormalidade de consumo como virada de hidrômetro
				consumoAnormalidade
						.setId(ConsumoAnormalidade.VIRADA_HIDROMETRO);
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
			}
			
			// Calcula a faixa de leitura esperada
			int[] faixaLeituraEsperada = calcularFaixaLeituraEsperada(
					consumoMedioHidrometro[0], medicaoHistorico, hidrometro,
					null);

			// Verifica se ouve virada de hidrômetro
			if (faixaLeituraEsperada[0] > faixaLeituraEsperada[1]) {

				Double numeroLimite = obterNumeroLimiteHidrometro(medicaoHistorico, imovel);
				
				boolean numeroForaFaixaInicial = false;
				boolean numeroForaFaixaFinal = false;

				if (medicaoHistorico.getLeituraAtualInformada() < faixaLeituraEsperada[0]
						|| medicaoHistorico.getLeituraAtualInformada() > numeroLimite
								.intValue()) {
					numeroForaFaixaInicial = true;
				}

				if (medicaoHistorico.getLeituraAtualInformada() > faixaLeituraEsperada[1]) {
					numeroForaFaixaFinal = true;
				}

				if (numeroForaFaixaInicial && numeroForaFaixaFinal) {
					// Define a anormalidade de consumo como fora da faixa
					consumoAnormalidade.setId(ConsumoAnormalidade.FORA_FAIXA);
				}

			}
		} else {

			medicaoHistorico.setNumeroConsumoMes(null);
			consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
					consumoMedioHidrometro[0]));

			/**
			 *  Ajuste da leitura faturada = leitura anterior
			 * faturada + media
			 */
			medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico
					.getLeituraAnteriorFaturamento()
					+ consumoMedioHidrometro[0]);

			// Seta tipo de consumo
			consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

			if (medicaoHistorico.getLeituraSituacaoAnterior().getId()
					.intValue() == LeituraSituacao.REALIZADA.intValue()
					|| medicaoHistorico.getLeituraSituacaoAnterior().getId()
							.intValue() == LeituraSituacao.CONFIRMADA
							.intValue()) {

				// Seta a anormalidade de consumo
				consumoAnormalidade
						.setId(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_ANTERIOR);

			} else if (medicaoHistorico.getLeituraSituacaoAnterior().getId()
					.intValue() != LeituraSituacao.REALIZADA.intValue()
					&& medicaoHistorico.getLeituraSituacaoAnterior().getId()
							.intValue() != LeituraSituacao.CONFIRMADA
							.intValue()) {
				// Seta a anormalidade de consumo
				consumoAnormalidade
						.setId(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_PROJETADA);

			}

			consumoHistorico.setConsumoTipo(consumoTipo);
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

			/**
			 *  12/04/2011 Pamela Gatinho Adicionando o calculo de
			 * ajuste
			 */
			determinarAjusteMensal(medicaoHistorico, consumoHistorico, imovel,
					rota, consumoMedioHidrometro[0], sistemaParametro);

		}

		// Atualiza o consumo histórico
		if (consumoAnormalidade.getId() != null) {
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
		}
		if (consumoTipo.getId() != null) {
			consumoHistorico.setConsumoTipo(consumoTipo);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0010] - Dados para
	 * Faturamento para Leitura Não Informada e Sem Anormalidade de Leitura
	 */
	protected void dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(
			MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistorico, int[] consumoMedioHidrometro,
			int leituraAnterior, SistemaParametro sistemaParametro, Rota rota)
			throws ControladorException {

		// Cria objeto consumo anormalidade
		ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

		// Cria objeto tipo consumo
		ConsumoTipo consumoTipo = new ConsumoTipo();

		Integer anoMesReferenciaAnterior = Util.subtrairMesDoAnoMes(
				sistemaParametro.getAnoMesFaturamento(), 1);

		Date dataLeituraAnteriorNaoMedido = this
				.obterDataLeituraAnteriorCronograma(rota.getFaturamentoGrupo(),
						anoMesReferenciaAnterior);

		if (verificarSubstituicaoHidrometro(medicaoHistorico.getImovel(),
				medicaoHistorico, sistemaParametro)) {
			consumoAnormalidade
					.setId(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO);
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
		}

		if (consumoHistorico.getConsumoAnormalidade() != null
				&& !consumoHistorico
						.getConsumoAnormalidade()
						.getId()
						.equals(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO)) {

			// Seta o consumo anormalidade para leitura não informada
			consumoAnormalidade
					.setId(ConsumoAnormalidade.LEITURA_NAO_INFORMADA);
		} else if (consumoHistorico.getConsumoAnormalidade() != null
				&& consumoHistorico
						.getConsumoAnormalidade()
						.getId()
						.equals(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO)) {

			consumoAnormalidade
					.setId(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO);
		}

		// Obtém a quantidade de dias de consumo
		long quantidadeDiasConsumo = IoUtil.diferencaEntreDatas(
				dataLeituraAnteriorNaoMedido,
				medicaoHistorico.getDataLeituraAtualFaturamento());

		// Caso a quantidade de dias seja menor que zero, seta a quantidade zero
		if (quantidadeDiasConsumo < 0) {
			quantidadeDiasConsumo = 0;
		}

		/*
		 * Colocado por Raphael Rossiter em 16/01/2009 - Analista: Rosana
		 * Carvalho
		 * 
		 * Caso a quantidade de dias esteja entre ((30 -
		 * PARM_NNDIASVARIACAOCONSUMO ) e 30 + PARM_NNDIASVARIACAOCONSUMO)) o
		 * Consumo a Ser Cobrado no Mês será o consumo médio do hidrômetro e o
		 * Tipo de Consumo será o valor correspondente à média do hidrômetro na
		 * tabela CONSUMO_TIPO;
		 */
		long variacaoConsumoInicio = 30 - sistemaParametro
				.getNumeroDiasVariacaoConsumo().intValue();
		long variacaoConsumoFim = 30 + sistemaParametro
				.getNumeroDiasVariacaoConsumo().intValue();

		if (quantidadeDiasConsumo >= variacaoConsumoInicio
				&& quantidadeDiasConsumo <= variacaoConsumoFim) {

			consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
					consumoMedioHidrometro[0]));

			consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

			/**
			 *  Ajuste da leitura faturada = leitura anterior
			 * faturada + media
			 */
			medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico
					.getLeituraAnteriorFaturamento()
					+ consumoMedioHidrometro[0]);

		} else {

			// Realiza cálculo para obter o consumo cobrado no mês
			// Consumo cobrado mês = (consumo médio hidrômetro / 30) *
			// quantidade dias consumo
			BigDecimal numerador = new BigDecimal(consumoMedioHidrometro[0]);
			BigDecimal denominador = null;

			denominador = new BigDecimal(getControladorFaturamento().obterDiferencaDiasCronogramas(
					sistemaParametro.getAnoMesFaturamento(), rota, FaturamentoAtividade.EFETUAR_LEITURA));
			
			BigDecimal resultado = numerador.divide(denominador, 3,
					BigDecimal.ROUND_HALF_DOWN);
			BigDecimal diasConsumo = new BigDecimal(quantidadeDiasConsumo);
			resultado = resultado.multiply(diasConsumo);

			// Seta o consumo a ser faturado mês (consumo cobrado mês)
			consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(Util
					.arredondar(resultado)));

			// Seta o tipo de consumo com consumo médio ajustado
			consumoTipo.setId(ConsumoTipo.CONSUMO_MEDIO_AJUSTADO);

			/**
			 *  Ajuste da leitura faturada = leitura anterior
			 * faturada + consumo
			 */
			medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico
					.getLeituraAnteriorFaturamento()
					+ consumoHistorico.getNumeroConsumoFaturadoMes());

		}

		// Seta a leitura atual de faturamento, que será a leitura anterior da
		// medição, mais consumo médio do hidrometro
		medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
				+ consumoMedioHidrometro[0]);

		// Seta o consumo tipo
		consumoHistorico.setConsumoTipo(consumoTipo);
		// Seta o consumo anormalidade
		consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

		Date dataLeituraNaoMedidoAtual = new Date();

		int qtdDIas = (int) getControladorFaturamento().obterDiferencaDiasCronogramas(
				sistemaParametro.getAnoMesFaturamento(), rota, 
				FaturamentoAtividade.EFETUAR_LEITURA);
		
		dataLeituraNaoMedidoAtual = Util.adicionarNumeroDiasDeUmaData(
				dataLeituraAnteriorNaoMedido,qtdDIas);
		
			medicaoHistorico
				.setDataLeituraAtualFaturamento(dataLeituraNaoMedidoAtual);
	}

	protected void dadosFaturamentoLeituraMaiorAnterior(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico, int consumoMedioHidrometro, 
			Imovel imovel, Rota rota, SistemaParametro sistemaParametro) {

		consumoHistorico.setConsumoTipo(determinarConsumoTipo(medicaoHistorico));

		int consumoMedidoMes = medicaoHistorico.getLeituraAtualInformada() - obterLeituraAnterior(medicaoHistorico);
		int consumoFaturadoMes = consumoMedidoMes;

		consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(consumoFaturadoMes));
		medicaoHistorico.setNumeroConsumoMes(new Integer(consumoMedidoMes));

		medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

		determinarAjusteMensal(medicaoHistorico, consumoHistorico, imovel, rota, consumoMedioHidrometro, sistemaParametro);

		if (verificarConsumoForaDeFaixa(medicaoHistorico, consumoHistorico, consumoMedioHidrometro, imovel)) {
			ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade(ConsumoAnormalidade.FORA_FAIXA);
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0008] - Dados para
	 * Faturamento para Leitura Igual que a Anterior
	 */
	protected void dadosFaturamentoLeituraIgualAnterior(
			MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistoricoEsgoto, MedicaoTipo medicaoTipo,
			Imovel imovel, ConsumoHistorico consumoHistoricoAgua, Rota rota,
			int[] consumoMedioHidrometro, SistemaParametro sistemaParametro)
			throws ControladorException {

		// O consumo medido no mês e consumo a ser cobrado serão zero
		medicaoHistorico.setNumeroConsumoMes(new Integer("0"));
		consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(new Integer("0"));

		// Seta o tipo de consumo
		ConsumoTipo consumoTipo = determinarConsumoTipo(medicaoHistorico);
		consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);

		/**
		 *  12/04/2011 Pamela Gatinho Adicionando o calculo de
		 * ajuste
		 */
		determinarAjusteMensal(medicaoHistorico, consumoHistoricoEsgoto,
				imovel, rota, consumoMedioHidrometro[0], sistemaParametro);

		// Cria o objeto leitura anormalidade
		LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();

		/*
		 * Caso a Leitura Atual Informada seja maior que um e a Anormalidade de
		 * Leitura de Faturamento esteja com o valor nulo.
		 */
		if (medicaoHistorico.getLeituraAtualInformada() > 1
				&& medicaoHistorico.getLeituraAnormalidadeFaturamento() == null) {

			/*
			 * Colocado por Raphael Rossiter em 16/01/2009 - Analista: Rosana
			 * Carvalho
			 * 
			 * O sistema verifica se não houve consumo OU se o hidrômetro está
			 * parado OU se a subcategoria do imóvel tem o indicador de
			 * sazonalidade igual a SIM (1) OU se a situação da ligação de água
			 * não tem abastecimento
			 */
			boolean imovelSazonal = false;

			// [UC0108] - Obter Quantidade de Economias por Subcategoria
			Collection colecaoCategoriaOUSubcategoria = this
					.getControladorImovel()
					.obterQuantidadeEconomiasSubCategoria(imovel.getId());

			Iterator itSubcategoria = colecaoCategoriaOUSubcategoria.iterator();

			while (itSubcategoria.hasNext()) {

				Subcategoria subcategoria = (Subcategoria) itSubcategoria
						.next();

				if (subcategoria.getIndicadorSazonalidade().equals(
						ConstantesSistema.SIM)) {

					imovelSazonal = true;
					break;
				}
			}

			if (imovel.getLigacaoAguaSituacao().getIndicadorAbastecimento()
					.equals(ConstantesSistema.SIM)
					&& !imovelSazonal) {

				// Tipo medição <<ÁGUA>>
				if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA
						.intValue()) {

					// [SB0019] - Verificar Hidrômetro Parado para Ligação de
					// Água
					leituraAnormalidade = this
							.verificarHidrometroParadoLigacaoAgua(imovel);

				}

				// Tipo medição <<POÇO>>
				else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO
						.intValue()) {

					// [SB0020] - Verificar Hidrômetro Parado para Poço
					leituraAnormalidade = this.verificarHidrometroParadoPoco(
							imovel, consumoHistoricoAgua);

				}

				// Seta no histórico de medição a leitura anormalidade
				medicaoHistorico
						.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
			}
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * 
	 * [SB0020] - Verificar Hidrômetro Parado para Poço
	 * 
	 * @author Raphael Rossiter
	 * @date 16/01/2009
	 * 
	 * @param imovel
	 * @param consumoHistorico
	 * @return LeituraAnormalidade
	 */
	protected LeituraAnormalidade verificarHidrometroParadoPoco(Imovel imovel,
			ConsumoHistorico consumoHistoricoAgua) {

		/*
		 * Caso o imóvel não seja ligado de água ou, caso seja, tenha hidrômetro
		 * e tenha Anormalidade de Consumo com o valor correspondente a BAIXO
		 * CONSUMO.
		 */
		LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();

		if ((imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
				.shortValue() != LigacaoAguaSituacao.FATURAMENTO_ATIVO
				.shortValue())
				|| ((imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null && imovel
						.getLigacaoAgua().getHidrometroInstalacaoHistorico()
						.getId() != null) && (consumoHistoricoAgua != null
						&& consumoHistoricoAgua.getConsumoAnormalidade() != null && consumoHistoricoAgua
						.getConsumoAnormalidade().getId().intValue() == ConsumoAnormalidade.BAIXO_CONSUMO
						.intValue()))) {

			/*
			 * O sistema gera a Anormalidade de Leitura de Faturamento com o
			 * valor correspondente a hidrômetro parado
			 */
			leituraAnormalidade.setId(LeituraAnormalidade.HIDROMETRO_PARADO);

		} else {

			/*
			 * O sistema gera a Anormalidade de Leitura de Faturamento com o
			 * valor correspondente a hidrômetro parado sem consumo.
			 */
			leituraAnormalidade
					.setId(LeituraAnormalidade.HIDROMETRO_PARADO_SEM_CONSUMO);
		}

		return leituraAnormalidade;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * 
	 * [SB0019] - Verificar Hidrômetro Parado para Ligação de Água
	 * 
	 * @author Raphael Rossiter
	 * @date 16/01/2009
	 * 
	 * @param imovel
	 * @return LeituraAnormalidade
	 */
	protected LeituraAnormalidade verificarHidrometroParadoLigacaoAgua(
			Imovel imovel) {

		/*
		 * Caso todas as condições seguintes sejam satisfeitas, o sistema gera a
		 * Anormalidade de Leitura de Faturamento com o valor correspondente a
		 * hidrômetro parado da tabela LEITURA_ ANORMALIDADE
		 */
		LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();

		boolean primeiraCondicao = false;
		boolean hidrometroParado = false;

		// Não exista ligação de esgoto
		if (!imovel.getLigacaoEsgotoSituacao()
				.getIndicadorFaturamentoSituacao()
				.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)) {

			primeiraCondicao = true;
		}

		// Caso exista, o valor do consumo mínimo fixado de esgoto seja igual a
		// nulo
		else if (imovel.getLigacaoEsgoto().getConsumoMinimo() == null) {

			primeiraCondicao = true;
		}

		// Não exista poço no imóvel
		if (primeiraCondicao
				&& (imovel.getPocoTipo() == null
						|| imovel.getPocoTipo().getId() == null || imovel
						.getPocoTipo().getId() == 0)) {

			hidrometroParado = true;
		}

		if (hidrometroParado) {

			/*
			 * O sistema gera a Anormalidade de Leitura de Faturamento com o
			 * valor correspondente a hidrômetro parado
			 */
			leituraAnormalidade.setId(LeituraAnormalidade.HIDROMETRO_PARADO);

		}

		/*
		 * Caso exista poço no imóvel OU exista ligação de esgoto com o valor do
		 * consumo mínimo fixado de esgoto diferente de nulo.
		 */
		else if ((imovel.getPocoTipo() != null && imovel.getPocoTipo().getId() != null)
				|| (imovel.getLigacaoEsgotoSituacao()
						.getIndicadorFaturamentoSituacao()
						.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO) && imovel
						.getLigacaoEsgoto().getConsumoMinimo() != null)) {

			/*
			 * o sistema gera a Anormalidade de Leitura de Faturamento com o
			 * valor correspondente a hidrômetro parado sem consumo.
			 */
			leituraAnormalidade
					.setId(LeituraAnormalidade.HIDROMETRO_PARADO_SEM_CONSUMO);
		}

		return leituraAnormalidade;
	}

	/**
	 * Método utlizado para receber uma coleção e retornar um objeto do tipo
	 * Anormalidade de Leitura
	 */
	public LeituraAnormalidade obterAnormalidadeLeitura(
			Collection colecaoAnormalidadeLeitura) {

		// Cria os objetos
		LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
		LeituraAnormalidadeConsumo leituraAnormalidadeConsumoSemLeitura = new LeituraAnormalidadeConsumo();
		LeituraAnormalidadeConsumo leituraAnormalidadeConsumoComLeitura = new LeituraAnormalidadeConsumo();
		LeituraAnormalidadeLeitura leituraAnormalidadeLeituraSemLeitura = new LeituraAnormalidadeLeitura();
		LeituraAnormalidadeLeitura leituraAnormalidadeLeituraComLeitura = new LeituraAnormalidadeLeitura();

		// Verifica se a coleção é nula
		if (!Util.isVazioOrNulo(colecaoAnormalidadeLeitura)) {

			Object[] anormalidadeLeituraArray = (Object[]) Util
					.retonarObjetoDeColecaoArray(colecaoAnormalidadeLeitura);

			// Seta o id da anormalidade de leitura
			if (anormalidadeLeituraArray[0] != null) {
				leituraAnormalidade
						.setId((Integer) anormalidadeLeituraArray[0]);

				// Seta o consumo sem leitura
				if (anormalidadeLeituraArray[1] != null) {
					leituraAnormalidadeConsumoSemLeitura
							.setId((Integer) anormalidadeLeituraArray[1]);
				}

				// Seta o consumo com leitura
				if (anormalidadeLeituraArray[2] != null) {
					leituraAnormalidadeConsumoComLeitura
							.setId((Integer) anormalidadeLeituraArray[2]);
				}

				// Seta a leitura sem leitura
				if (anormalidadeLeituraArray[3] != null) {
					leituraAnormalidadeLeituraSemLeitura
							.setId((Integer) anormalidadeLeituraArray[3]);
				}

				// Seta a leitura com leitura
				if (anormalidadeLeituraArray[4] != null) {
					leituraAnormalidadeLeituraComLeitura
							.setId((Integer) anormalidadeLeituraArray[4]);
				}

				// Seta Numero Fator Sem Leitura
				if (anormalidadeLeituraArray[5] != null) {
					leituraAnormalidade
							.setNumeroFatorSemLeitura((BigDecimal) anormalidadeLeituraArray[5]);
				}

				// Seta Numero Fator Com Leitura
				if (anormalidadeLeituraArray[6] != null) {
					leituraAnormalidade
							.setNumeroFatorComLeitura((BigDecimal) anormalidadeLeituraArray[6]);
				}

				// Associa seta a anormalidade de leitura
				leituraAnormalidade
						.setLeituraAnormalidadeConsumoSemleitura(leituraAnormalidadeConsumoSemLeitura);
				leituraAnormalidade
						.setLeituraAnormalidadeConsumoComleitura(leituraAnormalidadeConsumoComLeitura);
				leituraAnormalidade
						.setLeituraAnormalidadeLeituraSemleitura(leituraAnormalidadeLeituraSemLeitura);
				leituraAnormalidade
						.setLeituraAnormalidadeLeituraComleitura(leituraAnormalidadeLeituraComLeitura);
			}

		}

		// Retorna a anormalidade de leitura
		return leituraAnormalidade;

	}

	/**
	 * Método utlizado para receber uma coleção e retornar um objeto do tipo
	 * faturamento situação tipo
	 */

	public FaturamentoSituacaoTipo obterFaturamentoSituacaoTipo(
			Collection colecaoFaturamentoSituacaoTipo) {

		// Cria os objetos
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
		LeituraAnormalidadeConsumo leituraAnormalidadeConsumoSemLeitura = new LeituraAnormalidadeConsumo();
		LeituraAnormalidadeConsumo leituraAnormalidadeConsumoComLeitura = new LeituraAnormalidadeConsumo();
		LeituraAnormalidadeLeitura leituraAnormalidadeLeituraSemLeitura = new LeituraAnormalidadeLeitura();
		LeituraAnormalidadeLeitura leituraAnormalidadeLeituraComLeitura = new LeituraAnormalidadeLeitura();

		// Verifica se a coleção é nula
		if (!Util.isVazioOrNulo(colecaoFaturamentoSituacaoTipo)) {

			Object[] faturamentoSituacaoTipoArray = (Object[]) Util
					.retonarObjetoDeColecaoArray(colecaoFaturamentoSituacaoTipo);

			// Seta o id da anormalidade de leitura
			if (faturamentoSituacaoTipoArray[0] != null) {
				faturamentoSituacaoTipo
						.setId((Integer) faturamentoSituacaoTipoArray[0]);

				// Seta o consumo sem leitura
				if (faturamentoSituacaoTipoArray[1] != null) {
					leituraAnormalidadeConsumoSemLeitura
							.setId((Integer) faturamentoSituacaoTipoArray[1]);
				}

				// Seta o consumo com leitura
				if (faturamentoSituacaoTipoArray[2] != null) {
					leituraAnormalidadeConsumoComLeitura
							.setId((Integer) faturamentoSituacaoTipoArray[2]);
				}

				// Seta a leitura sem leitura
				if (faturamentoSituacaoTipoArray[3] != null) {
					leituraAnormalidadeLeituraSemLeitura
							.setId((Integer) faturamentoSituacaoTipoArray[3]);
				}

				// Seta a leitura com leitura
				if (faturamentoSituacaoTipoArray[4] != null) {
					leituraAnormalidadeLeituraComLeitura
							.setId((Integer) faturamentoSituacaoTipoArray[4]);
				}

				// Associa seta a anormalidade de leitura
				faturamentoSituacaoTipo
						.setLeituraAnormalidadeConsumoSemLeitura(leituraAnormalidadeConsumoSemLeitura);
				faturamentoSituacaoTipo
						.setLeituraAnormalidadeConsumoComLeitura(leituraAnormalidadeConsumoComLeitura);
				faturamentoSituacaoTipo
						.setLeituraAnormalidadeLeituraSemLeitura(leituraAnormalidadeLeituraSemLeitura);
				faturamentoSituacaoTipo
						.setLeituraAnormalidadeLeituraComLeitura(leituraAnormalidadeLeituraComLeitura);
			}

		}

		// Retorna a anormalidade de leitura
		return faturamentoSituacaoTipo;

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0011] - Dados para
	 * Faturamento com Anormalidade de Leitura
	 */
	protected void dadosFaturamentoAnormalidadeLeitura(
			MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistorico, int[] consumoMedioHidrometro,
			int leituraAnterior, Imovel imovel, Rota rota) throws ControladorException {

		// Cria objeto consumo tipo
		ConsumoTipo consumoTipo = new ConsumoTipo();
		Collection colecaoAnormalidadeLeitura = null;
		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		try {
			// Pesquisa a anormalidade de leitura de faturamento
			colecaoAnormalidadeLeitura = repositorioMicromedicao
					.pesquisarAnormalidadeLeitura(medicaoHistorico
							.getLeituraAnormalidadeFaturamento());

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém a leitura anormalidade
		LeituraAnormalidade leituraAnormalidade = obterAnormalidadeLeitura(colecaoAnormalidadeLeitura);

		// Seta a leitura anormalidade faturamento
		medicaoHistorico.getLeituraAnormalidadeFaturamento()
				.setLeituraAnormalidadeConsumoSemleitura(
						leituraAnormalidade
								.getLeituraAnormalidadeConsumoSemleitura());

		medicaoHistorico.getLeituraAnormalidadeFaturamento()
				.setLeituraAnormalidadeConsumoComleitura(
						leituraAnormalidade
								.getLeituraAnormalidadeConsumoComleitura());

		medicaoHistorico.getLeituraAnormalidadeFaturamento()
				.setLeituraAnormalidadeLeituraSemleitura(
						leituraAnormalidade
								.getLeituraAnormalidadeLeituraSemleitura());

		medicaoHistorico.getLeituraAnormalidadeFaturamento()
				.setLeituraAnormalidadeLeituraComleitura(
						leituraAnormalidade
								.getLeituraAnormalidadeLeituraComleitura());

		// Caso a leitura atual informada seja zero
		if (medicaoHistorico.getLeituraAtualInformada() == null) {

			// Vivianne Sousa 19/08/2009 analista:Rosana
			// O sistema gera a Anormalidade de Consumo com o valor
			// correspondente
			// a anormalidade de leitura da tabela CONSUMO_ANORMALIDADE
			if (consumoHistorico.getConsumoAnormalidade() != null
					&& !consumoHistorico
							.getConsumoAnormalidade()
							.getId()
							.equals(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO)) {

				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				consumoAnormalidade
						.setId(ConsumoAnormalidade.ANORMALIDADE_DE_LEITURA);
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
			}

			// Caso a leitura anormalidade consumo sem leitura seja igual a
			// leitura anormalidade consumo não ocorre
			if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoSemleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
					.intValue()) {
				// Consumo a ser cobrado no mês será o consumo médio do
				// hidrômetro
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
				// Caso a leitura anormalidade consumo sem leitura seja igual a
				// leitura anormalidade consumo mínimo
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoSemleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MINIMO.intValue()) {
				/*
				 * Data: 21/05/2009 Autor: Bruno Barros Analista: Sávio
				 * 
				 * Alteração solicitada: O consumo a ser cobrado no mes será o
				 * valor retornado <<inclui>> [UC0105] - Obter consumo minino da
				 * ligação.
				 */
				// Consumo a ser cobrado no mês será zero
				consumoHistorico.setNumeroConsumoFaturadoMes(this
						.obterConsumoMinimoLigacao(imovel, null));
				/*
				 * FIM ALTERAÇÃO BRUNO BARROS
				 * 
				 * Código Anterior: // Consumo a ser cobrado no mês será zero
				 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(0));
				 */

				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoSemleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MEDIA.intValue()) {
				// Consumo a ser cobrado no mês será o consumo médio do
				// hidrômetro

				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoSemleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NAO_MEDIDO
					.intValue()) {

				Short IndicadorNaoMedidoTarifa = sistemaParametro
						.getIndicadorNaoMedidoTarifa();
				Integer consumo = new Integer(0);

				if (IndicadorNaoMedidoTarifa.compareTo(ConstantesSistema.SIM) == 0) {
					// Consumo a ser cobrado no mês será o consumo para ligação
					// não medida
					// por tarifa
					consumo = this.obterConsumoMinimoLigacao(imovel, null);
					consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
				} else if (IndicadorNaoMedidoTarifa
						.compareTo(ConstantesSistema.NAO) == 0) {
					/*
					 * RM 954  Alteração para adequação da implantação da
					 * COSAMA. Cálculo do consumo não medido por ponto de
					 * utilização ou número de moradores. Mariana Victor em
					 * 23/05/2011 - Analista: Rosana Carvalho
					 */
					if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& sistemaParametro.getCodigoTipoCalculoNaoMedido()
									.equals(new Integer(1))) {

						// Consumo a ser cobrado no mês será o consumo para
						// ligação não medida
						// sem ser por tarifa
						consumo = this.obterConsumoNaoMedidoSemTarifa(imovel.getId(),
								sistemaParametro.getAnoMesFaturamento());
						consumoHistorico.setNumeroConsumoFaturadoMes(consumo);

					} else if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& (sistemaParametro
									.getCodigoTipoCalculoNaoMedido().equals(
											new Integer(2)) || sistemaParametro
									.getCodigoTipoCalculoNaoMedido().equals(
											new Integer(3)))) {

						/**
						 * Colocado por Mariana Victor em 23/05/2011 - Analista:
						 * Rosana Carvalho [UC0000] - Obter Consumo Não Medido
						 * Por Parâmetro
						 */
						consumo = this.obterConsumoNaoMedidoPorParametro(
								imovel.getId(),
								sistemaParametro.getAnoMesFaturamento(), null);
						consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
					}
				}

				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.ESTIMADO);
			}
			// Identifica a anormalidade leitura sem leitura
			if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeLeituraSemleitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA
					.intValue()) {
				// Leitura atual de faturamento será a anterior mais a média
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
						+ consumoMedioHidrometro[0]);
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeLeituraSemleitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR
					.intValue()) {
				// Leitura atual de faturamento será a igual a anterior
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeLeituraSemleitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO
					.intValue()) {
				// Leitura atual de faturamento será a leitura anterior mais
				// consumo cobrado mes
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
						+ consumoHistorico.getNumeroConsumoFaturadoMes()
								.intValue());
			}

			// 1.1.4. O sistema deverá aplicar o fator definido sem leitura no
			// sistema ao consumo apurado
			// de acordo com o definido na anormalidade especificada
			// (LTAN_NNFATORSEMLEITURA da tabela LEITURA_ANORMALIDADE
			// com LTAN_ID = anormalidade informada).
			if (consumoHistorico.getNumeroConsumoFaturadoMes() != null
					&& leituraAnormalidade.getNumeroFatorSemLeitura() != null) {

				BigDecimal consumoFaturadoMesSemLeitura = new BigDecimal(
						consumoHistorico.getNumeroConsumoFaturadoMes());

				consumoFaturadoMesSemLeitura = leituraAnormalidade
						.getNumeroFatorSemLeitura().multiply(
								consumoFaturadoMesSemLeitura);

				consumoHistorico
						.setNumeroConsumoFaturadoMes(consumoFaturadoMesSemLeitura
								.intValue());

			}
			
			consumoHistorico.setConsumoTipo(consumoTipo);

			determinarAjusteMensal(medicaoHistorico, consumoHistorico, imovel,
					rota, consumoMedioHidrometro[0], sistemaParametro);
			
			// Caso leitura atual informada diferente de zero
		} else if (medicaoHistorico.getLeituraAtualInformada() != null) {
			// Caso a leitura anormalidade leitura com leitura seja igual a
			// leitura anormalidade consumo não ocorre
			if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoComleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
					.intValue()) {
				// O consumo a ser cobrado no mes será o consumo médio do
				// hidrômetro
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
			}
			// Caso a leitura anormalidade leitura com leitura seja igual a
			// leitura anormalidade consumo mínimo
			else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoComleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MINIMO.intValue()) {
				// Consumo a ser cobrado no mês será zero
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(0));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);
				// Caso a leitura anormalidade leitura com leitura seja igual a
				// leitura anormalidade consumo médio
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoComleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MEDIA.intValue()) {
				// Consumo a ser cobrado no mês será o consumo médio do
				// hidrômetro

				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
				// Caso a leitura anormalidade leitura com leitura seja igual a
				// leitura anormalidade consumo normal
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoComleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NORMAL.intValue()) {
				// Consumo a ser cobrado no mês será o já calculado
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoHistorico
						.getNumeroConsumoFaturadoMes());

				// Caso a leitura anormalidade leitura com leitura seja igual a
				// leitura anormalidade consumo medido
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoComleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO
					.intValue()) {
				// Caso o consumo médio hidrômetro seja maior que o consumo
				// medido
				if (consumoMedioHidrometro[0] > consumoHistorico
						.getNumeroConsumoFaturadoMes().intValue()) {
					// Consumo a ser cobrado no mês será o já calculado
					consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
							consumoMedioHidrometro[0]));
					// Seta o tipo de consumo
					consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
				} else {
					consumoHistorico
							.setNumeroConsumoFaturadoMes(consumoHistorico
									.getNumeroConsumoFaturadoMes());

				}

			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoComleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO
					.intValue()) {
				// Caso o consumo médio hidrômetro seja menor que o consumo
				// medido
				if (consumoMedioHidrometro[0] < consumoHistorico
						.getNumeroConsumoFaturadoMes().intValue()) {
					// Consumo a ser cobrado no mês será o consumo médio do
					// hidrômetro
					consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
							consumoMedioHidrometro[0]));
					// Seta o tipo de consumo
					consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
				} else {
					consumoHistorico
							.setNumeroConsumoFaturadoMes(medicaoHistorico
									.getNumeroConsumoMes());

				}

			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeConsumoComleitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NAO_MEDIDO
					.intValue()) {

				Short IndicadorNaoMedidoTarifa = sistemaParametro
						.getIndicadorNaoMedidoTarifa();
				Integer consumo = new Integer(0);
				if (IndicadorNaoMedidoTarifa.compareTo(ConstantesSistema.SIM) == 0) {
					// Consumo a ser cobrado no mês será o consumo para ligação
					// não medida
					// por tarifa
					consumo = this.obterConsumoMinimoLigacao(imovel, null);
					consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
				} else if (IndicadorNaoMedidoTarifa
						.compareTo(ConstantesSistema.NAO) == 0) {
					/*
					 * RM 954  Alteração para adequação da implantação da
					 * COSAMA. Cálculo do consumo não medido por ponto de
					 * utilização ou número de moradores. Mariana Victor em
					 * 23/05/2011 - Analista: Rosana Carvalho
					 */
					if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& sistemaParametro.getCodigoTipoCalculoNaoMedido()
									.equals(new Integer(1))) {

						// Consumo a ser cobrado no mês será o consumo para
						// ligação não medida
						// sem ser por tarifa
						consumo = this.obterConsumoNaoMedidoSemTarifa(imovel.getId(),
								sistemaParametro.getAnoMesFaturamento());
						consumoHistorico.setNumeroConsumoFaturadoMes(consumo);

					} else if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& (sistemaParametro
									.getCodigoTipoCalculoNaoMedido().equals(
											new Integer(2)) || sistemaParametro
									.getCodigoTipoCalculoNaoMedido().equals(
											new Integer(3)))) {

						/**
						 * Colocado por Mariana Victor em 23/05/2011 - Analista:
						 * Rosana Carvalho [UC0000] - Obter Consumo Não Medido
						 * Por Parâmetro
						 */
						consumo = this.obterConsumoNaoMedidoPorParametro(
								imovel.getId(),
								sistemaParametro.getAnoMesFaturamento(), null);
						consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
					}
				}

				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.ESTIMADO);
			}
			// Caso a leitura anormalidade leitura com leitura
			// seja igual a leitura anormaliade leitura ->
			// <<anterior mais média>>
			if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeLeituraComleitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA
					.intValue()) {
				// Seta a leitura atual de faturamento
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
						+ consumoMedioHidrometro[0]);
				// <<anterior>>
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeLeituraComleitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR
					.intValue()) {
				// Seta a leitura atual de faturamento
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
				// <<anterior mais consumo>>
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeLeituraComleitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO
					.intValue()) {

				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
						+ consumoHistorico.getNumeroConsumoFaturadoMes()
								.intValue());
				// <<leitura informada>>
			} else if (medicaoHistorico.getLeituraAnormalidadeFaturamento()
					.getLeituraAnormalidadeLeituraComleitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.INFORMADA
					.intValue()) {
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico
						.getLeituraAtualFaturamento());
			}

			// 1.2.3. O sistema deverá aplicar o fator definido com leitura no
			// sistema ao consumo apurado de acordo com o
			// definido na anormalidade especificada (LTAN_NNFATORCOMLEITURA da
			// tabela LEITURA_ANORMALIDADE
			// com LTAN_ID = anormalidade informada).
			if (consumoHistorico.getNumeroConsumoFaturadoMes() != null
					&& leituraAnormalidade.getNumeroFatorComLeitura() != null) {

				BigDecimal consumoFaturadoMesComLeitura = new BigDecimal(
						consumoHistorico.getNumeroConsumoFaturadoMes());

				consumoFaturadoMesComLeitura = leituraAnormalidade
						.getNumeroFatorComLeitura().multiply(
								consumoFaturadoMesComLeitura);

				consumoHistorico
						.setNumeroConsumoFaturadoMes(consumoFaturadoMesComLeitura
								.intValue());

			}
		}

		// Atualiza o consumo histórico
		if (consumoTipo.getId() != null) {
			consumoHistorico.setConsumoTipo(consumoTipo);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * 
	 * [SB0021] - Dados para Faturamento Especial Medido
	 * 
	 * @author Raphael Rossiter
	 * @date 12/08/2008
	 * 
	 * @param medicaoHistorico
	 * @param consumoHistorico
	 * @param imovel
	 * @param consumoMedioHidrometro
	 * @param leituraAnterior
	 */
	protected void dadosFaturamentoEspecialMedido(
			MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistorico, Imovel imovel,
			int[] consumoMedioHidrometro, int leituraAnterior,
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {

		// Cria objeto consumo tipo
		ConsumoTipo consumoTipo = new ConsumoTipo();
		// / Declara coleção
		Collection colecaoFaturamentoSituacaoTipo = null;

		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		try {
			// Pesquisa a anormalidade de leitura de faturamento
			colecaoFaturamentoSituacaoTipo = repositorioMicromedicao
					.pesquisarFaturamentoSituacaoTipo(imovel
							.getFaturamentoSituacaoTipo());

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém a leitura anormalidade
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = obterFaturamentoSituacaoTipo(colecaoFaturamentoSituacaoTipo);

		// Seta a leitura anormalidade faturamento
		imovel.getFaturamentoSituacaoTipo()
				.setLeituraAnormalidadeConsumoSemLeitura(
						faturamentoSituacaoTipo
								.getLeituraAnormalidadeConsumoSemLeitura());
		imovel.getFaturamentoSituacaoTipo()
				.setLeituraAnormalidadeConsumoComLeitura(
						faturamentoSituacaoTipo
								.getLeituraAnormalidadeConsumoComLeitura());
		imovel.getFaturamentoSituacaoTipo()
				.setLeituraAnormalidadeLeituraSemLeitura(
						faturamentoSituacaoTipo
								.getLeituraAnormalidadeLeituraSemLeitura());
		imovel.getFaturamentoSituacaoTipo()
				.setLeituraAnormalidadeLeituraComLeitura(
						faturamentoSituacaoTipo
								.getLeituraAnormalidadeLeituraComLeitura());

		/*
		 * Colocado por Raphael Rossiter em 12/08/2008 - Analista: Rosana
		 * Carvalho
		 * 
		 * OBJ: Verificar a situação especial de faturamento quando o consumo de
		 * água e/ou volume de esgoto está fixo.
		 */
		FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = null;

		try {
			faturamentoSituacaoHistorico = repositorioMicromedicao
					.pesquisarFaturamentoSituacaoHistoricoConsumoVolumeFixo(
							imovel, faturamentoGrupo);

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		// Caso a leitura atual informada seja zero
		if (medicaoHistorico.getLeituraAtualInformada() == null) {
			// Caso a leitura anormalidade consumo sem leitura seja igual a
			// leitura anormalidade consumo não ocorre
			if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoSemLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
					.intValue()) {
				// Consumo a ser cobrado no mês será o consumo médio do
				// hidrômetro
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
				// Caso a leitura anormalidade consumo sem leitura seja igual a
				// leitura anormalidade consumo mínimo
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoSemLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MINIMO.intValue()
					&& faturamentoSituacaoHistorico != null) {
				/*
				 * Data: 21/05/2009 Autor: Bruno Barros Analista: Sávio
				 * 
				 * Alteração solicitada: O consumo a ser cobrado no mes será o
				 * valor retornado <<inclui>> [UC0105] - Obter consumo minino da
				 * ligação.
				 */

				// Consumo a ser cobrado no mês será zero
				consumoHistorico.setNumeroConsumoFaturadoMes(this
						.obterConsumoMinimoLigacao(imovel, null));

				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.FIXO_SITUACAO_ESPECIAL);

				/*
				 * FIM ALTERAÇÃO BRUNO BARROS
				 * 
				 * Código Anterior: // Consumo a ser cobrado no mês será zero
				 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(0));
				 * 
				 * // Seta o tipo de consumo
				 * consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);
				 */
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoSemLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MEDIA.intValue()) {
				// Consumo a ser cobrado no mês será o consumo médio do
				// hidrômetro
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
			}

			/*
			 * Colocado por Raphael Rossiter em 12/08/2008 - Analista: Rosana
			 * Carvalho
			 * 
			 * OBJ: Verificar a situação especial de faturamento quando o
			 * consumo de água e/ou volume de esgoto está fixo.
			 */
			else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoSemLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.FIXO.intValue()
					&& faturamentoSituacaoHistorico != null) {

				// ConsumoTipo
				consumoTipo.setId(ConsumoTipo.FIXO_SITUACAO_ESPECIAL);

				// Consumo a ser cobrado no mês será o consumo fixado no
				// histórico da situação especial
				if (consumoHistorico.getLigacaoTipo().getId()
						.equals(LigacaoTipo.LIGACAO_AGUA)) {

					if (faturamentoSituacaoHistorico
							.getNumeroConsumoAguaMedido() != null) {

						consumoHistorico
								.setNumeroConsumoFaturadoMes(faturamentoSituacaoHistorico
										.getNumeroConsumoAguaMedido());
					}
				} else if (faturamentoSituacaoHistorico
						.getNumeroVolumeEsgotoMedido() != null) {

					consumoHistorico
							.setNumeroConsumoFaturadoMes(faturamentoSituacaoHistorico
									.getNumeroVolumeEsgotoMedido());
				}
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoSemLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NAO_MEDIDO
					.intValue()) {

				Short IndicadorNaoMedidoTarifa = sistemaParametro
						.getIndicadorNaoMedidoTarifa();
				Integer consumo = new Integer(0);
				if (IndicadorNaoMedidoTarifa.compareTo(ConstantesSistema.SIM) == 0) {
					// Consumo a ser cobrado no mês será o consumo para ligação
					// não medida
					// por tarifa
					consumo = this.obterConsumoMinimoLigacao(imovel, null);
					consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
				} else if (IndicadorNaoMedidoTarifa
						.compareTo(ConstantesSistema.NAO) == 0) {
					/*
					 * RM 954  Alteração para adequação da implantação da
					 * COSAMA. Cálculo do consumo não medido por ponto de
					 * utilização ou número de moradores. Mariana Victor em
					 * 23/05/2011 - Analista: Rosana Carvalho
					 */
					if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& sistemaParametro.getCodigoTipoCalculoNaoMedido()
									.equals(new Integer(1))) {

						// Consumo a ser cobrado no mês será o consumo para
						// ligação não medida
						// sem ser por tarifa
						consumo = this.obterConsumoNaoMedidoSemTarifa(imovel.getId(),
								sistemaParametro.getAnoMesFaturamento());
						consumoHistorico.setNumeroConsumoFaturadoMes(consumo);

					} else if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& (sistemaParametro
									.getCodigoTipoCalculoNaoMedido().equals(
											new Integer(2)) || sistemaParametro
									.getCodigoTipoCalculoNaoMedido().equals(
											new Integer(3)))) {

						/**
						 * Colocado por Mariana Victor em 23/05/2011 - Analista:
						 * Rosana Carvalho [UC0000] - Obter Consumo Não Medido
						 * Por Parâmetro
						 */
						consumo = this.obterConsumoNaoMedidoPorParametro(
								imovel.getId(),
								sistemaParametro.getAnoMesFaturamento(), null);
						consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
					}
				}

				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.ESTIMADO);
			}

			// Identifica a anormalidade leitura sem leitura
			if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeLeituraSemLeitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA
					.intValue()) {
				// Leitura atual de faturamento será a anterior mais a média
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
						+ consumoMedioHidrometro[0]);
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeLeituraSemLeitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR
					.intValue()) {
				// Leitura atual de faturamento será a igual a anterior
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeLeituraSemLeitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO
					.intValue()) {
				// Leitura atual de faturamento será a leitura anterior mais
				// consumo cobrado mes
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
						+ consumoHistorico.getNumeroConsumoFaturadoMes()
								.intValue());
			}
			// Caso leitura atual informada diferente de zero
		} else if (medicaoHistorico.getLeituraAtualInformada() != null) {
			// Caso a leitura anormalidade leitura com leitura seja igual a
			// leitura anormalidade consumo não ocorre
			if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoComLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
					.intValue()) {
				// O consumo a ser cobrado no mes será o consumo médio do
				// hidrômetro
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
			}
			// Caso a leitura anormalidade leitura com leitura seja igual a
			// leitura anormalidade consumo mínimo
			else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoComLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MINIMO.intValue()) {
				/*
				 * Data: 21/05/2009 Autor: Bruno Barros Analista: Sávio
				 * 
				 * Alteração solicitada: O consumo a ser cobrado no mes será o
				 * valor retornado <<inclui>> [UC0105] - Obter consumo minino da
				 * ligação.
				 */

				// Consumo a ser cobrado no mês será zero
				consumoHistorico.setNumeroConsumoFaturadoMes(this
						.obterConsumoMinimoLigacao(imovel, null));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.FIXO_SITUACAO_ESPECIAL);

				/*
				 * FIM ALTERAÇÃO BRUNO BARROS
				 * 
				 * Código Anterior: // Consumo a ser cobrado no mês será zero
				 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(0));
				 * 
				 * // Seta o tipo de consumo
				 * consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);
				 */
				// Caso a leitura anormalidade leitura com leitura seja igual a
				// leitura anormalidade consumo médio
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoComLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MEDIA.intValue()) {
				// Consumo a ser cobrado no mês será o consumo médio do
				// hidrômetro
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
				// Caso a leitura anormalidade leitura com leitura seja igual a
				// leitura anormalidade consumo normal
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoComLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NORMAL.intValue()) {
				// Consumo a ser cobrado no mês será o já calculado
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoHistorico
						.getNumeroConsumoFaturadoMes());
				// Caso a leitura anormalidade leitura com leitura seja igual a
				// leitura anormalidade consumo medido
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoComLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO
					.intValue()) {
				// Caso o consumo médio hidrômetro seja maior que o consumo
				// medido
				if (consumoMedioHidrometro[0] > consumoHistorico
						.getNumeroConsumoFaturadoMes().intValue()) {
					// Consumo a ser cobrado no mês será o já calculado
					consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
							consumoMedioHidrometro[0]));
					// Seta o tipo de consumo
					consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
				} else {
					consumoHistorico
							.setNumeroConsumoFaturadoMes(consumoHistorico
									.getNumeroConsumoFaturadoMes());
				}

			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoComLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO
					.intValue()) {
				// Caso o consumo médio hidrômetro seja menor que o consumo
				// medido
				if (consumoMedioHidrometro[0] < consumoHistorico
						.getNumeroConsumoFaturadoMes().intValue()) {
					// Consumo a ser cobrado no mês será o consumo médio do
					// hidrômetro
					consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
							consumoMedioHidrometro[0]));
					// Seta o tipo de consumo
					consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
				} else {
					consumoHistorico
							.setNumeroConsumoFaturadoMes(medicaoHistorico
									.getNumeroConsumoMes());
				}

			}

			/*
			 * Colocado por Raphael Rossiter em 12/08/2008 - Analista: Rosana
			 * Carvalho
			 * 
			 * OBJ: Verificar a situação especial de faturamento quando o
			 * consumo de água e/ou volume de esgoto está fixo.
			 */
			else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoSemLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.FIXO.intValue()
					&& faturamentoSituacaoHistorico != null) {

				// ConsumoTipo
				consumoTipo.setId(ConsumoTipo.FIXO_SITUACAO_ESPECIAL);

				// Consumo a ser cobrado no mês será o consumo fixado no
				// histórico da situação especial
				if (consumoHistorico.getLigacaoTipo().getId()
						.equals(LigacaoTipo.LIGACAO_AGUA)) {

					if (faturamentoSituacaoHistorico
							.getNumeroConsumoAguaMedido() != null) {

						consumoHistorico
								.setNumeroConsumoFaturadoMes(faturamentoSituacaoHistorico
										.getNumeroConsumoAguaMedido());
					}
				} else if (faturamentoSituacaoHistorico
						.getNumeroVolumeEsgotoMedido() != null) {

					consumoHistorico
							.setNumeroConsumoFaturadoMes(faturamentoSituacaoHistorico
									.getNumeroVolumeEsgotoMedido());
				}
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeConsumoComLeitura().getId()
					.intValue() == LeituraAnormalidadeConsumo.NAO_MEDIDO
					.intValue()) {

				Short IndicadorNaoMedidoTarifa = sistemaParametro
						.getIndicadorNaoMedidoTarifa();
				Integer consumo = new Integer(0);
				if (IndicadorNaoMedidoTarifa.compareTo(ConstantesSistema.SIM) == 0) {
					// Consumo a ser cobrado no mês será o consumo para ligação
					// não medida
					// por tarifa
					consumo = this.obterConsumoMinimoLigacao(imovel, null);
					consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
				} else if (IndicadorNaoMedidoTarifa
						.compareTo(ConstantesSistema.NAO) == 0) {
					/*
					 * RM 954  Alteração para adequação da implantação da
					 * COSAMA. Cálculo do consumo não medido por ponto de
					 * utilização ou número de moradores. Mariana Victor em
					 * 23/05/2011 - Analista: Rosana Carvalho
					 */
					if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& sistemaParametro.getCodigoTipoCalculoNaoMedido()
									.equals(new Integer(1))) {

						// Consumo a ser cobrado no mês será o consumo para
						// ligação não medida
						// sem ser por tarifa
						consumo = this.obterConsumoNaoMedidoSemTarifa(imovel.getId(),
								sistemaParametro.getAnoMesFaturamento());
						consumoHistorico.setNumeroConsumoFaturadoMes(consumo);

					} else if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& (sistemaParametro
									.getCodigoTipoCalculoNaoMedido().equals(
											new Integer(2)) || sistemaParametro
									.getCodigoTipoCalculoNaoMedido().equals(
											new Integer(3)))) {

						/**
						 * Colocado por Mariana Victor em 23/05/2011 - Analista:
						 * Rosana Carvalho [UC0000] - Obter Consumo Não Medido
						 * Por Parâmetro
						 */
						consumo = this.obterConsumoNaoMedidoPorParametro(
								imovel.getId(),
								sistemaParametro.getAnoMesFaturamento(), null);
						consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
					}
				}

				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.ESTIMADO);
			}

			// Caso a leitura anormalidade leitura com leitura
			// seja igual a leitura anormaliade leitura ->
			// <<anterior mais média>>
			if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeLeituraComLeitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA
					.intValue()) {
				// Seta a leitura atual de faturamento
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
						+ consumoMedioHidrometro[0]);
				// <<anterior>>
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeLeituraComLeitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR
					.intValue()) {
				// Seta a leitura atual de faturamento
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
				// <<anterior mais consumo>>
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeLeituraComLeitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO
					.intValue()) {
				// Seta a leitura atual de faturamento
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
						+ consumoHistorico.getNumeroConsumoFaturadoMes()
								.intValue());
				// <<leitura informada>>
			} else if (imovel.getFaturamentoSituacaoTipo()
					.getLeituraAnormalidadeLeituraComLeitura().getId()
					.intValue() == LeituraAnormalidadeLeitura.INFORMADA
					.intValue()) {
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico
						.getLeituraAtualFaturamento());
			}
		}

		// Atualiza o consumo histórico
		if (consumoTipo.getId() != null) {
			consumoHistorico.setConsumoTipo(consumoTipo);
		}

	}

	@SuppressWarnings("rawtypes")
	protected boolean verificarEstouroConsumo(ConsumoHistorico consumoHistorico, 
			int[] consumoMedioImovel, int[] consumoMedioHidrometro,
			FaturamentoGrupo faturamentoGrupo, MedicaoTipo medicaoTipo,
			Collection colecaoCategoria, MedicaoHistorico medicaoHistorico,
			int leituraAnterior) throws ControladorException {

		boolean retorno = false;

		try {

			int consumoTotalReferencia = 0;
			int consumoMaximoCobrancaEstouroConsumo = 0;
			int maiorQuantidadeEconomia = 0;

			BigDecimal vezesMediaEstouro = new BigDecimal(0);
			Integer idCategoriaComMaisEconomias = null;
			Iterator colecaoCategoriaIterator = colecaoCategoria.iterator();
			while (colecaoCategoriaIterator.hasNext()) {

				Categoria categoria = (Categoria) colecaoCategoriaIterator.next();

				int qtdEconomias = categoria.getQuantidadeEconomiasCategoria().intValue();

				consumoTotalReferencia = consumoTotalReferencia	+ (categoria.getConsumoEstouro().intValue() * qtdEconomias);

				consumoMaximoCobrancaEstouroConsumo = consumoMaximoCobrancaEstouroConsumo
						+ (categoria.getNumeroConsumoMaximoEc().intValue() * qtdEconomias);

				if (maiorQuantidadeEconomia < qtdEconomias) {
					maiorQuantidadeEconomia = qtdEconomias;
					vezesMediaEstouro = categoria.getVezesMediaEstouro();
					idCategoriaComMaisEconomias = categoria.getId();

				}
			}

			BigDecimal consumoMedioImovelAuxiliar = new BigDecimal(new Integer(consumoMedioHidrometro[0]).toString());
			BigDecimal resultado = consumoMedioImovelAuxiliar.multiply(vezesMediaEstouro);

			int consumoMedioFatorMultiplicacao = Util.arredondar(resultado);
			int consumoASerCobradoMes = consumoHistorico.getNumeroConsumoFaturadoMes().intValue();

			if (consumoASerCobradoMes > consumoTotalReferencia && consumoASerCobradoMes > consumoMedioFatorMultiplicacao) {

				LigacaoTipo ligacaoTipo = new LigacaoTipo();

				if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()) {
					ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

				} else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()) {
					ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

				}

				ImovelPerfil imovelPerfil = getControladorImovel().obterImovelPerfil(consumoHistorico.getImovel().getId());
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				ConsumoTipo consumoTipo = new ConsumoTipo();

				ConsumoAnormalidadeAcao consumoAnormalidadeAcao = verificaAcaoASerTomada(ConsumoAnormalidade.ESTOURO_CONSUMO,
						idCategoriaComMaisEconomias, imovelPerfil.getId());

				if (consumoAnormalidadeAcao != null) {

					Integer idLeituraAnormalidadeConsumo = null;
					BigDecimal numerofatorConsumo = new BigDecimal("0.00");

					int anoMesReferenciaAnterior = Util.subtrairData(faturamentoGrupo.getAnoMesReferencia());

					Collection consumoHistoricoMesAnterior = repositorioMicromedicao
							.pesquisarConsumoHistoricoConsumoAnormalidade(
									consumoHistorico.getImovel(), ligacaoTipo,
									anoMesReferenciaAnterior,
									ConsumoAnormalidade.ESTOURO_CONSUMO);

					Collection consumoHistoricoSegundoMesAnterior = null;

					if (consumoHistoricoMesAnterior == null || consumoHistoricoMesAnterior.isEmpty()) {

						idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao.getLeituraAnormalidadeConsumoMes1().getId();
						numerofatorConsumo = consumoAnormalidadeAcao.getNumerofatorConsumoMes1();

					} else {

						consumoHistoricoSegundoMesAnterior = repositorioMicromedicao
								.pesquisarConsumoHistoricoConsumoAnormalidade(
										consumoHistorico.getImovel(),
										ligacaoTipo,
										Util.subtrairData(anoMesReferenciaAnterior),
										ConsumoAnormalidade.ESTOURO_CONSUMO);

						if (consumoHistoricoSegundoMesAnterior == null
								|| consumoHistoricoSegundoMesAnterior.isEmpty()) {
							// caso não tenha ocorrido, então o sistema verifica
							// a ação a ser tomada no segundo mês (LACS_IDMES2):
							idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao
									.getLeituraAnormalidadeConsumoMes2()
									.getId();

							numerofatorConsumo = consumoAnormalidadeAcao
									.getNumerofatorConsumoMes2();

						} else {
							// Caso tenha ocorrido no segundo mês anterior,
							// então o sistema verifica a ação a ser tomada no
							// terceiro mês (LACS_IDMES3):
							idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao
									.getLeituraAnormalidadeConsumoMes3()
									.getId();

							numerofatorConsumo = consumoAnormalidadeAcao
									.getNumerofatorConsumoMes3();
						}

					}

					// 3.1.1.1. O sistema gera a Anormalidade de Consumo com o
					// valor
					// correspondente a estouro de consumo da tabela
					// CONSUMO_ANORMALIDADE
					consumoAnormalidade
							.setId(ConsumoAnormalidade.ESTOURO_CONSUMO);
					consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);

					if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.NAO_OCORRE)) {

						// Consumo a ser cobrado no mês será o consumo médio do
						// hidrômetro
						consumoHistorico
								.setNumeroConsumoFaturadoMes(new Integer(
										consumoMedioHidrometro[0]));
						// Seta o tipo de consumo
						consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
						
						/**
						 *  Ajuste da leitura faturada = leitura
						 * anterior faturada + media
						 */
						medicaoHistorico
								.setLeituraAtualFaturamento(medicaoHistorico
										.getLeituraAnteriorFaturamento()
										+ consumoMedioHidrometro[0]);

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MINIMO)) {

						// O Consumo a Ser Cobrado no Mês será o valor retornado
						// por [UC0105 - Obter Consumo Mínimo da Ligação
						consumoHistorico.setNumeroConsumoFaturadoMes(this
								.obterConsumoMinimoLigacao(consumoHistorico.getImovel(), null));
						// Seta o tipo de consumo
						consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);

						// 3.5.1
					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MEDIA)) {
						// ALTERADO POR BRUNO BARROS
						// ANALISTA - FÁTIMA
						// DATA - 14/02/2011
						// CÓDIGO ANTERIOR *************************************
						/*
						 * // Consumo a ser cobrado no mês será o consumo médio
						 * do hidrômetro
						 * consumoHistorico.setNumeroConsumoFaturadoMes(new
						 * Integer( consumoMedioHidrometro[0]));
						 */
						// FIM CÓDIGO ANTERIOR *********************************

						// 3.1.5.1
						if ((consumoHistoricoMesAnterior == null || consumoHistoricoMesAnterior
								.isEmpty())
								|| (consumoHistoricoSegundoMesAnterior == null || consumoHistoricoSegundoMesAnterior
										.isEmpty())) {

							BigDecimal consumofaturadoMes = new BigDecimal(
									new Integer(consumoMedioHidrometro[0]));
							consumofaturadoMes = consumofaturadoMes
									.multiply(numerofatorConsumo);
							consumofaturadoMes = consumofaturadoMes.setScale(0,
									BigDecimal.ROUND_HALF_UP);

							// 3.1.5.1.1
							if (consumofaturadoMes.intValue() > consumoTotalReferencia) {
								consumoHistorico
										.setNumeroConsumoFaturadoMes(consumofaturadoMes
												.intValue());
							} else {
								consumoHistorico
										.setNumeroConsumoFaturadoMes(consumoTotalReferencia);
							}
						}

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.NORMAL)) {

						// Consumo a ser cobrado no mês será o já calculado
						consumoHistorico
								.setNumeroConsumoFaturadoMes(consumoHistorico
										.getNumeroConsumoFaturadoMes());

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO)) {

						// Caso o consumo médio hidrômetro seja maior que o
						// consumo calculado
						if (consumoMedioHidrometro[0] > consumoHistorico
								.getNumeroConsumoFaturadoMes().intValue()) {

							// Consumo a ser cobrado no mês será o consumo médio
							// hidrômetro
							consumoHistorico
									.setNumeroConsumoFaturadoMes(new Integer(
											consumoMedioHidrometro[0]));
							// Seta o tipo de consumo
							consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
							
							/**
							 *  Ajuste da leitura faturada =
							 * leitura anterior faturada + media
							 */
							medicaoHistorico
									.setLeituraAtualFaturamento(medicaoHistorico
											.getLeituraAnteriorFaturamento()
											+ consumoMedioHidrometro[0]);

						} else {
							consumoHistorico
									.setNumeroConsumoFaturadoMes(consumoHistorico
											.getNumeroConsumoFaturadoMes());

						}

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO)) {

						// Caso o consumo médio hidrômetro seja menor que o
						// consumo calculado
						if (consumoMedioHidrometro[0] < consumoHistorico
								.getNumeroConsumoFaturadoMes().intValue()) {

							// Consumo a ser cobrado no mês será o consumo médio
							// do hidrômetro
							consumoHistorico
									.setNumeroConsumoFaturadoMes(new Integer(
											consumoMedioHidrometro[0]));
							// Seta o tipo de consumo
							consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
							
							/**
							 *  Ajuste da leitura faturada =
							 * leitura anterior faturada + media
							 */
							medicaoHistorico
									.setLeituraAtualFaturamento(medicaoHistorico
											.getLeituraAnteriorFaturamento()
											+ consumoMedioHidrometro[0]);
						} else {
							consumoHistorico
									.setNumeroConsumoFaturadoMes(medicaoHistorico
											.getNumeroConsumoMes());

						}

					}

					// 3.1.4. O consumo a Ser Cobrado no Mês será igual
					// ao Consumo a Ser Cobrado no Mês multiplicado pelo
					// fator de multiplicação da quantidade de vezes a média
					// (CSAA_NNFATORCONSUMOMES(1,2 ou 3), dependendo do mês
					// calculado anteriormente
					if (numerofatorConsumo != null
							&& !idLeituraAnormalidadeConsumo
									.equals(LeituraAnormalidadeConsumo.MEDIA)) {
						BigDecimal consumofaturadoMes = new BigDecimal(
								consumoHistorico.getNumeroConsumoFaturadoMes());
						consumofaturadoMes = consumofaturadoMes
								.multiply(numerofatorConsumo);
						consumofaturadoMes = consumofaturadoMes.setScale(0,
								BigDecimal.ROUND_HALF_DOWN);
						consumoHistorico
								.setNumeroConsumoFaturadoMes(consumofaturadoMes
										.intValue());
					}

					// Atualiza o consumo histórico
					if (consumoTipo.getId() != null) {
						consumoHistorico.setConsumoTipo(consumoTipo);
					}

				} else {

					// Obtém o ano e mês de referência anterior
					int anoMesReferenciaAnterior = Util
							.subtrairData(faturamentoGrupo
									.getAnoMesReferencia());

					Collection consumoHistoricoAnterior = null;

					// Pesquisa o consumo histórico
					consumoHistoricoAnterior = repositorioMicromedicao
							.pesquisarConsumoHistoricoConsumoAnormalidade(
									consumoHistorico.getImovel(), ligacaoTipo,
									anoMesReferenciaAnterior);

					// Verifica se a pesquisa retornou objetos
					if (consumoHistoricoAnterior != null
							&& !consumoHistoricoAnterior.isEmpty()) {

						Object[] consumoHistoricoAnteriorArray = Util
								.retonarObjetoDeColecaoArray(consumoHistoricoAnterior);

						consumoAnormalidade
								.setId((Integer) consumoHistoricoAnteriorArray[1]);

					}

					// Verifica se o consumo anormalidade é diferente de estouro
					// de
					// consumo e estouro consumo cobranca media ou não tem
					// consumo
					// histórico do mês anterior
					if ((consumoAnormalidade.getId() != null
							&& consumoAnormalidade.getId().intValue() != ConsumoAnormalidade.ESTOURO_CONSUMO
									.intValue()
							&& (consumoAnormalidade.getId().intValue() != ConsumoAnormalidade.ESTOURO_CONSUMO_COBRANCA_MEDIA) || consumoASerCobradoMes > consumoMaximoCobrancaEstouroConsumo)
							|| (consumoHistoricoAnterior == null || consumoHistoricoAnterior
									.isEmpty())) {

						// Seta o consumo anormalidade
						consumoAnormalidade
								.setId(ConsumoAnormalidade.ESTOURO_CONSUMO_COBRANCA_MEDIA);
						
						/**
						 *  ESTOURO DE CONSUMO e ALTO CONSUMO
						 * devem calcular pela média
						 */
						// Seta o consumo a ser cobrado no mês
						consumoHistorico
								.setNumeroConsumoFaturadoMes(new Integer(
										consumoMedioHidrometro[0]));
						// Seta o consumo tipo
						consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

						/*
						 * Comentado por Raphael Rossiter em 25/10/2007 -
						 * Analista: Aryed
						 */
						// Seta a leitura atual de faturamento
						
						medicaoHistorico.setLeituraAtualFaturamento(
						leituraAnterior + consumoMedioHidrometro[0]);
						 
						consumoHistorico.setConsumoTipo(consumoTipo);

					} else {

						// Seta o consumo anormalidade
						consumoAnormalidade
								.setId(ConsumoAnormalidade.ESTOURO_CONSUMO);

					}

					// Seta a anormalidade e o tipo de consumo
					consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);
					
					// Atualiza o consumo histórico
					if (consumoTipo.getId() != null) {
						consumoHistorico.setConsumoTipo(consumoTipo);
					}

				}// Final do codigo antigo

				retorno = true;

			}

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);

		}

		return retorno;
	}

	protected boolean verificarEstouroConsumoANTIGO(
			ConsumoHistorico consumoHistorico, Imovel imovel,
			int[] consumoMedioImovel, int[] consumoMedioHidrometro,
			SistemaParametro sistemaParametro, MedicaoTipo medicaoTipo,
			Collection colecaoCategoria, MedicaoHistorico medicaoHistorico,
			int leituraAnterior)  {

		boolean retorno = false;

		int consumoTotalReferencia = 0;
		int consumoMaximoCobrancaEstouroConsumo = 0;
		int maiorQuantidadeEconomia = 0;

		BigDecimal vezesMediaEstouro = new BigDecimal(0);

		Iterator colecaoCategoriaIterator = colecaoCategoria.iterator();

		while (colecaoCategoriaIterator.hasNext()) {

			Categoria categoria = (Categoria) colecaoCategoriaIterator.next();

			int qtdEconomias = categoria.getQuantidadeEconomiasCategoria()
					.intValue();

			// Multiplica o consumo por economia de referencia (consumo estouro)
			// pr número de economias do imóvel
			consumoTotalReferencia = consumoTotalReferencia
					+ (categoria.getConsumoEstouro().intValue() * qtdEconomias);

			consumoMaximoCobrancaEstouroConsumo = consumoMaximoCobrancaEstouroConsumo
					+ (categoria.getNumeroConsumoMaximoEc().intValue() * qtdEconomias);

			// Obtém a maior quantidade de economias e a vezes média de estouro
			if (maiorQuantidadeEconomia < qtdEconomias) {

				maiorQuantidadeEconomia = qtdEconomias;
				vezesMediaEstouro = categoria.getVezesMediaEstouro();
			}
		}

		// Converte o consumo médio para big decimal
		BigDecimal consumoMedioImovelAuxiliar = new BigDecimal(new Integer(
				consumoMedioImovel[0]).toString());

		// Multiplica o consumo médio do imóvel pela média da categoria do
		// imóvel que tenha maior número de economias
		BigDecimal resultado = consumoMedioImovelAuxiliar
				.multiply(vezesMediaEstouro);

		// Arredonda o resultado
		int consumoMedioFatorMultiplicacao = Util.arredondar(resultado);

		// Caso o consumo a ser cobrado no mês seja superior ao consumo total de
		// referência obtido
		// e ao consumo médio do imóvel multiplicado pelo fator de multiplicação
		// da média da categoria
		int consumoASerCobradoMes = consumoHistorico
				.getNumeroConsumoFaturadoMes().intValue();

		if (consumoASerCobradoMes > consumoTotalReferencia
				&& consumoASerCobradoMes > consumoMedioFatorMultiplicacao) {

			// Cria o objeto ligação tipo
			LigacaoTipo ligacaoTipo = new LigacaoTipo();

			// Caso a medição seja para água o tipo de ligação é de água
			if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA
					.intValue()) {

				ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

			} else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO
					.intValue()) {

				ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

			}

			// Obtém o ano e mês de referência anterior
			int anoMesReferenciaAnterior = Util.subtrairData(sistemaParametro
					.getAnoMesFaturamento());

			Collection consumoHistoricoAnterior = null;

			// Pesquisa o consumo histórico
			try {
				consumoHistoricoAnterior = repositorioMicromedicao
						.pesquisarConsumoHistoricoConsumoAnormalidade(imovel,
								ligacaoTipo, anoMesReferenciaAnterior);
			} catch (ErroRepositorioException ex) {
				// sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);

			}

			// Cria objetos
			ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
			ConsumoTipo consumoTipo = new ConsumoTipo();

			// Verifica se a pesquisa retornou objetos
			if (consumoHistoricoAnterior != null
					&& !consumoHistoricoAnterior.isEmpty()) {

				Object[] consumoHistoricoAnteriorArray = Util
						.retonarObjetoDeColecaoArray(consumoHistoricoAnterior);

				consumoAnormalidade
						.setId((Integer) consumoHistoricoAnteriorArray[1]);

			}

			// Verifica se o consumo anormalidade é diferente de estouro de
			// consumo e estouro consumo cobranca media ou não tem consumo
			// histórico do mês anterior
			if ((consumoAnormalidade.getId() != null
					&& consumoAnormalidade.getId().intValue() != ConsumoAnormalidade.ESTOURO_CONSUMO
							.intValue()
					&& (consumoAnormalidade.getId().intValue() != ConsumoAnormalidade.ESTOURO_CONSUMO_COBRANCA_MEDIA) || consumoASerCobradoMes > consumoMaximoCobrancaEstouroConsumo)
					|| (consumoHistoricoAnterior == null || consumoHistoricoAnterior
							.isEmpty())) {

				// Seta o consumo anormalidade
				consumoAnormalidade
						.setId(ConsumoAnormalidade.ESTOURO_CONSUMO_COBRANCA_MEDIA);
				// Seta o consumo a ser cobrado no mês
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				// Seta o consumo tipo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

				/*
				 * Comentado por Raphael Rossiter em 25/10/2007 - Analista:
				 * Aryed
				 */
				// Seta a leitura atual de faturamento
				/*
				 * medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior +
				 * consumoMedioHidrometro[0]);
				 */

				consumoHistorico.setConsumoTipo(consumoTipo);

			} else {

				// Seta o consumo anormalidade
				consumoAnormalidade.setId(ConsumoAnormalidade.ESTOURO_CONSUMO);

				// Calcula pela media
				consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
						consumoMedioHidrometro[0]));
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

				// Seta a anormalidade e o tipo de consumo
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
				consumoHistorico.setConsumoTipo(consumoTipo);

				/**
				 *  Ajuste da leitura faturada = leitura anterior
				 * faturada + media
				 */
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico
						.getLeituraAnteriorFaturamento()
						+ consumoMedioHidrometro[0]);
			}

			// Seta consumo histórico
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

			retorno = true;
		}

		return retorno;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param consumoMedioImovel
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	/*
	 * protected int[]
	 * obterConsumoTotalReferenciaConsumoMedioFatorMultiplicacao( Imovel imovel,
	 * int[] consumoMedioImovel) throws ControladorException {
	 * 
	 * int[] retorno = new int[1]; try { int consumoTotalReferencia = 0; // Cria
	 * o filtro de Imóvel SubCategoria FiltroImovelSubCategoria
	 * filtroImovelSubCategoria = new FiltroImovelSubCategoria(); // Cria e
	 * define o parametro para o filtro de imóvel subcategoria ParametroSimples
	 * parametroSimples = new ParametroSimples(
	 * FiltroImovelSubCategoria.IMOVEL_ID, imovel.getId()); // Pesquisar colecao
	 * de Imóvel Subcategoria Collection colecaoImovelSubCategoria =
	 * repositorioUtil.pesquisar( filtroImovelSubCategoria,
	 * ImovelSubcategoria.class .getName());
	 * 
	 * int maiorQuantidadeEconomias = 0; // Cria objeto categoria Categoria
	 * categoria = new Categoria();
	 * 
	 * BigDecimal consumoMedioFatorMultiplicacao = null; // Verifica se a
	 * coleção retornou objetos if (colecaoImovelSubCategoria != null &&
	 * !colecaoImovelSubCategoria.isEmpty()) {
	 * 
	 * Iterator colecaoImovelSubCategoriaIterator = colecaoImovelSubCategoria
	 * .iterator();
	 * 
	 * while (colecaoImovelSubCategoriaIterator.hasNext()) { // Obtém o Imóvel
	 * Subcategoria ImovelSubcategoria imovelSubcategoria = (ImovelSubcategoria)
	 * colecaoImovelSubCategoriaIterator .next(); // Obtém o consumo de
	 * referência int consumoReferencia = (imovelSubcategoria.getComp_id()
	 * .getSubcategoria().getCategoria() .getConsumoEstouro().intValue() *
	 * imovelSubcategoria .getQuantidadeEconomias()); // Obtém a quantidade de
	 * economias int quantidadeEconomias = imovelSubcategoria
	 * .getQuantidadeEconomias(); // Verifica qual a maior quantidade de
	 * economias if (quantidadeEconomias > maiorQuantidadeEconomias) {
	 * maiorQuantidadeEconomias = quantidadeEconomias; // Obtém a categoria com
	 * a maior quantidade de economias categoria =
	 * imovelSubcategoria.getComp_id() .getSubcategoria().getCategoria(); } //
	 * Acumula o consumo total de referência consumoTotalReferencia +=
	 * consumoReferencia; } // Armazena o consumo médio do imóvel BigDecimal
	 * consumoMedioImovel1 = new BigDecimal( consumoMedioImovel[0]); // Obtém o
	 * consumo médio X fator de multiplicação consumoMedioFatorMultiplicacao =
	 * consumoMedioImovel1 .multiply(categoria.getVezesMediaEstouro()); //
	 * Arredonda o consumo médio consumoMedioFatorMultiplicacao =
	 * consumoMedioFatorMultiplicacao .setScale(0, BigDecimal.ROUND_UP); } else
	 * { // Caso a coleção não tenha retornado objetos
	 * sessionContext.setRollbackOnly(); throw new ControladorException(
	 * "atencao.nao_cadastrado.imovel_subcategoria", null); } // Armazena o
	 * consumo total de referência retorno[0] = consumoTotalReferencia; //
	 * Armazena o consumo médio fator multiplicação retorno[1] =
	 * consumoMedioFatorMultiplicacao.intValue(); } catch
	 * (ErroRepositorioException ex) { sessionContext.setRollbackOnly(); throw
	 * new ControladorException("erro.sistema", ex); } return retorno; }
	 */

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0015] - Verificar
	 * Alto Consumo
	 */
	/**
	 *  29/04/2011 - Pamela Gatinho Retirando o parametro
	 * consumoMedioImovel, pois não é utilizado no método.
	 */
	protected boolean verificarAltoConsumo(ConsumoHistorico consumoHistorico,
			Collection colecaoCategoria,
			Imovel imovel, FaturamentoGrupo faturamentoGrupo,
			int[] consumoMedioHidrometro, MedicaoTipo medicaoTipo,
			MedicaoHistorico medicaoHistorico) throws ControladorException {

		boolean retorno = false;

		try {

			int consumoTotalReferencia = 0;
			int maiorQuantidadeEconomia = 0;
			BigDecimal vezesMediaAltoConsumo = new BigDecimal(0);
			Integer idCategoriaComMaisEconomias = null;
			Iterator colecaoCategoriaIterator = colecaoCategoria.iterator();

			while (colecaoCategoriaIterator.hasNext()) {

				Categoria categoria = (Categoria) colecaoCategoriaIterator
						.next();

				// Multiplica o consumo por economia de referencia (consumo
				// estouro)
				// pr número de economias do imóvel
				consumoTotalReferencia = consumoTotalReferencia
						+ (categoria.getConsumoAlto().intValue() * categoria
								.getQuantidadeEconomiasCategoria().intValue());

				// Obtém a maior quantidade de economias e a vezes média de
				// estouro
				if (maiorQuantidadeEconomia < categoria
						.getQuantidadeEconomiasCategoria().intValue()) {

					maiorQuantidadeEconomia = categoria
							.getQuantidadeEconomiasCategoria().intValue();

					vezesMediaAltoConsumo = categoria
							.getVezesMediaAltoConsumo();

					idCategoriaComMaisEconomias = categoria.getId();
				}
			}

			// CALCULO MÉDIA IMÓVEL
			/*
			 * BigDecimal consumoMedioImovelAuxiliar = new BigDecimal(new
			 * Integer( consumoMedioImovel[0]).toString());
			 */

			// CALCULO MÉDIA HIDRÔMETRO
			BigDecimal consumoMedioImovelAuxiliar = new BigDecimal(new Integer(
					consumoMedioHidrometro[0]).toString());

			// Multiplica o consumo médio do imóvel pela média da categoria do
			// imóvel que tenha maior número de economias
			BigDecimal resultado = consumoMedioImovelAuxiliar
					.multiply(vezesMediaAltoConsumo);

			// Arredonda o resultado
			int consumoMedioFatorMultiplicacao = Util.arredondar(resultado);

			ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

			// Verifica se houve consumo alto
			if (consumoHistorico.getNumeroConsumoFaturadoMes().intValue() > consumoTotalReferencia
					&& consumoHistorico.getNumeroConsumoFaturadoMes()
							.intValue() > consumoMedioFatorMultiplicacao) {

				ImovelPerfil imovelPerfil = getControladorImovel()
						.obterImovelPerfil(imovel.getId());
				ConsumoTipo consumoTipo = new ConsumoTipo();

				// alterado por Vivianne Sousa - 17/12/2009 - analista: Savio
				// Cavalcante
				// Acessar a tabela de MICROMEDICAO.CONSUMO_ANORMALIDADE_ACAO
				// para
				// determinar a ação a ser tomada nas anormalidades de Baixo
				// Consumo,
				// Alto Consumo e Estouro de Consumo
				// 2.1
				ConsumoAnormalidadeAcao consumoAnormalidadeAcao = verificaAcaoASerTomada(
						ConsumoAnormalidade.ALTO_CONSUMO,
						idCategoriaComMaisEconomias, imovelPerfil.getId());

				// [FS0006] - Verificar existência de consumo anormalidade ação
				// do imóvel
				if (consumoAnormalidadeAcao != null) {

					// Cria o objeto ligação tipo
					LigacaoTipo ligacaoTipo = new LigacaoTipo();

					// Caso a medição seja para água o tipo de ligação é de água
					if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA
							.intValue()) {

						ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

					} else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO
							.intValue()) {

						ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

					}

					Integer idLeituraAnormalidadeConsumo = null;
					BigDecimal numerofatorConsumo = new BigDecimal("0.00");

					// Obtém o ano e mês de referência de faturamento
					int anoMesReferenciaAnterior = Util
							.subtrairData(faturamentoGrupo
									.getAnoMesReferencia());

					// Pesquisa o consumo histórico
					Collection consumoHistoricoMesAnterior = repositorioMicromedicao
							.pesquisarConsumoHistoricoConsumoAnormalidade(
									imovel, ligacaoTipo,
									anoMesReferenciaAnterior,
									ConsumoAnormalidade.ALTO_CONSUMO);

					// 2.1.1. Caso não tenha ocorrido estouro de consumo no mês
					// anterior
					// (CSAN_ID da tabela CONSUMO_HISTORICO com o valor
					// diferente de alto consumo
					// com IMOV_ID=matrícula do imóvel, LGTI_ID com o valor
					// correspondente a ligação de água
					// ou com o valor correspondente a ligação de esgoto e
					// CSHI_AMFATURAMENTO igual ao ano /mês de faturamento menos
					// um mês),
					// então verifica a ação a ser tomada no primeiro mês
					// (LACS_IDMES1):
					if (consumoHistoricoMesAnterior == null
							|| consumoHistoricoMesAnterior.isEmpty()) {

						idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao
								.getLeituraAnormalidadeConsumoMes1().getId();

						numerofatorConsumo = consumoAnormalidadeAcao
								.getNumerofatorConsumoMes1();

					} else {

						// 3.1.2.Caso contrário, ou seja, tenha ocorrido estouro
						// de consumo no mês anterior,
						// o sistema verifica se tenha ocorrido estouro de
						// consumo no segundo mês anterior
						// (CSAN_ID da tabela CONSUMO_HISTORICO com o valor
						// diferente de alto consumo
						// com IMOV_ID=matrícula do imóvel, LGTI_ID com o valor
						// correspondente a ligação de água
						// ou com o valor correspondente a ligação de esgoto e
						// CSHI_AMFATURAMENTO igual ao ano /mês de faturamento
						// menos dois meses)

						Collection consumoHistoricoSegundoMesAnterior = repositorioMicromedicao
								.pesquisarConsumoHistoricoConsumoAnormalidade(
										imovel,
										ligacaoTipo,
										Util.subtrairData(anoMesReferenciaAnterior),
										ConsumoAnormalidade.ALTO_CONSUMO);

						if (consumoHistoricoSegundoMesAnterior == null
								|| consumoHistoricoSegundoMesAnterior.isEmpty()) {
							// caso não tenha ocorrido, então o sistema verifica
							// a ação a ser tomada no segundo mês (LACS_IDMES2):
							idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao
									.getLeituraAnormalidadeConsumoMes2()
									.getId();

							numerofatorConsumo = consumoAnormalidadeAcao
									.getNumerofatorConsumoMes2();

						} else {
							// Caso tenha ocorrido no segundo mês anterior,
							// então o sistema verifica a ação a ser tomada no
							// terceiro mês (LACS_IDMES3):
							idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao
									.getLeituraAnormalidadeConsumoMes3()
									.getId();

							numerofatorConsumo = consumoAnormalidadeAcao
									.getNumerofatorConsumoMes3();
						}

					}

					// 2.1.1.1. O sistema gera a Anormalidade de Consumo com o
					// valor
					// correspondente a alto consumo da tabela
					// CONSUMO_ANORMALIDADE
					consumoAnormalidade.setId(ConsumoAnormalidade.ALTO_CONSUMO);
					consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);

					if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.NAO_OCORRE)) {

						// Consumo a ser cobrado no mês será o consumo médio do
						// hidrômetro
						consumoHistorico
								.setNumeroConsumoFaturadoMes(new Integer(
										consumoMedioHidrometro[0]));
						// Seta o tipo de consumo
						consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
						
						/**
						 *  Ajuste da leitura faturada = leitura
						 * anterior faturada + media
						 */
						medicaoHistorico
								.setLeituraAtualFaturamento(medicaoHistorico
										.getLeituraAnteriorFaturamento()
										+ consumoMedioHidrometro[0]);

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MINIMO)) {

						// O Consumo a Ser Cobrado no Mês será o valor retornado
						// por [UC0105 - Obter Consumo Mínimo da Ligação
						consumoHistorico.setNumeroConsumoFaturadoMes(this
								.obterConsumoMinimoLigacao(imovel, null));
						// Seta o tipo de consumo
						consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MEDIA)) {
						// ALTERADO POR BRUNO BARROS
						// ANALISTA - FÁTIMA
						// DATA - 14/02/2011
						// CÓDIGO ANTERIOR *************************************
						/*
						 * // Consumo a ser cobrado no mês será o consumo médio
						 * do hidrômetro
						 * consumoHistorico.setNumeroConsumoFaturadoMes(new
						 * Integer( consumoMedioHidrometro[0]));
						 */
						// FIM CÓDIGO ANTERIOR *********************************

						BigDecimal consumofaturadoMes = new BigDecimal(
								consumoMedioHidrometro[0]);
						consumofaturadoMes = consumofaturadoMes
								.multiply(numerofatorConsumo);
						consumofaturadoMes = consumofaturadoMes.setScale(0,
								BigDecimal.ROUND_HALF_UP);

						// 2.1.5.1
						if (consumoHistoricoMesAnterior == null
								|| consumoHistoricoMesAnterior.isEmpty()) {
							// 2.1.5.1.1
							if (consumofaturadoMes.intValue() > consumoTotalReferencia) {
								consumoHistorico
										.setNumeroConsumoFaturadoMes(consumofaturadoMes
												.intValue());
								/**
								 *  Ajuste da leitura faturada = leitura
								 * anterior faturada + media
								 */
								medicaoHistorico
										.setLeituraAtualFaturamento(medicaoHistorico
												.getLeituraAnteriorFaturamento()
												+ consumoMedioHidrometro[0]);
							} else {
								consumoHistorico
										.setNumeroConsumoFaturadoMes(consumoTotalReferencia);
							}

							// 2.1.5.2
						} else {
							consumoHistorico
									.setNumeroConsumoFaturadoMes(consumofaturadoMes
											.intValue());
							/**
							 *  Ajuste da leitura faturada = leitura
							 * anterior faturada + media
							 */
							medicaoHistorico
									.setLeituraAtualFaturamento(medicaoHistorico
											.getLeituraAnteriorFaturamento()
											+ consumoMedioHidrometro[0]);
						}
					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.NORMAL)) {

						// Consumo a ser cobrado no mês será o já calculado
						consumoHistorico
								.setNumeroConsumoFaturadoMes(consumoHistorico
										.getNumeroConsumoFaturadoMes());

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO)) {

						// Caso o consumo médio hidrômetro seja maior que o
						// consumo calculado
						if (consumoMedioHidrometro[0] > consumoHistorico
								.getNumeroConsumoFaturadoMes().intValue()) {

							// Consumo a ser cobrado no mês será o consumo médio
							// hidrômetro
							consumoHistorico
									.setNumeroConsumoFaturadoMes(new Integer(
											consumoMedioHidrometro[0]));
							// Seta o tipo de consumo
							consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
							
							/**
							 *  Ajuste da leitura faturada =
							 * leitura anterior faturada + media
							 */
							medicaoHistorico
									.setLeituraAtualFaturamento(medicaoHistorico
											.getLeituraAnteriorFaturamento()
											+ consumoMedioHidrometro[0]);

						} else {
							consumoHistorico
									.setNumeroConsumoFaturadoMes(consumoHistorico
											.getNumeroConsumoFaturadoMes());

						}

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO)) {

						// Caso o consumo médio hidrômetro seja menor que o
						// consumo calculado
						if (consumoMedioHidrometro[0] < consumoHistorico
								.getNumeroConsumoFaturadoMes().intValue()) {

							// Consumo a ser cobrado no mês será o consumo médio
							// do hidrômetro
							consumoHistorico
									.setNumeroConsumoFaturadoMes(new Integer(
											consumoMedioHidrometro[0]));
							// Seta o tipo de consumo
							consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
							
							/**
							 *  Ajuste da leitura faturada =
							 * leitura anterior faturada + media
							 */
							medicaoHistorico
									.setLeituraAtualFaturamento(medicaoHistorico
											.getLeituraAnteriorFaturamento()
											+ consumoMedioHidrometro[0]);
						} else {
							consumoHistorico
									.setNumeroConsumoFaturadoMes(medicaoHistorico
											.getNumeroConsumoMes());

						}

					}

					// 3.1.4. O consumo a Ser Cobrado no Mês será igual
					// ao Consumo a Ser Cobrado no Mês multiplicado pelo
					// fator de multiplicação da quantidade de vezes a média
					// (CSAA_NNFATORCONSUMOMES(1,2 ou 3), dependendo do mês
					// calculado anteriormente

					// ALTERADO POR BRUNO BARROS
					// ANALISTA - FÁTIMA
					// DATA - 14/02/2011
					// CÓDIGO ANTERIOR *************************************
					// if( numerofatorConsumo != null ){
					// FIM CÓDIGO ANTERIOR *********************************
					if (numerofatorConsumo != null
							&& !idLeituraAnormalidadeConsumo
									.equals(LeituraAnormalidadeConsumo.MEDIA)) {
						BigDecimal consumofaturadoMes = new BigDecimal(
								consumoHistorico.getNumeroConsumoFaturadoMes());
						consumofaturadoMes = consumofaturadoMes
								.multiply(numerofatorConsumo);
						consumofaturadoMes = consumofaturadoMes.setScale(0,
								BigDecimal.ROUND_HALF_DOWN);
						consumoHistorico
								.setNumeroConsumoFaturadoMes(consumofaturadoMes
										.intValue());
					}

					// Atualiza o consumo histórico
					if (consumoTipo.getId() != null) {
						consumoHistorico.setConsumoTipo(consumoTipo);
					}

				} else {

					consumoAnormalidade.setId(ConsumoAnormalidade.ALTO_CONSUMO);
					consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);
				}

				// Houve consumo alto
				retorno = true;

			}

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0016] - Verificar
	 * Baixo Consumo
	 */
	protected boolean verificarBaixoConsumo(ConsumoHistorico consumoHistorico,
			Collection colecaoCategoria, Imovel imovel,
			FaturamentoGrupo faturamentoGrupo, int[] consumoMedioHidrometro,
			MedicaoTipo medicaoTipo, MedicaoHistorico medicaoHistorico)
			throws ControladorException {

		boolean retorno = false;

		try {
			int consumoTotalReferencia = 0;
			int maiorQuantidadeEconomia = 0;
			BigDecimal percentualDeterminacaoBaixoConsumo = new BigDecimal(
					"0.00");
			Integer idCategoriaComMaisEconomias = null;
			Iterator colecaoCategoriaIterator = colecaoCategoria.iterator();

			while (colecaoCategoriaIterator.hasNext()) {

				Categoria categoria = (Categoria) colecaoCategoriaIterator
						.next();

				// Multiplica o consumo por economia de referencia (consumo
				// estouro)
				// pr número de economias do imóvel
				consumoTotalReferencia = consumoTotalReferencia
						+ (categoria.getMediaBaixoConsumo().intValue() * categoria
								.getQuantidadeEconomiasCategoria().intValue());

				// Obtém a maior quantidade de economias e a vezes média de
				// estouro
				if (maiorQuantidadeEconomia < categoria
						.getQuantidadeEconomiasCategoria().intValue()) {

					maiorQuantidadeEconomia = categoria
							.getQuantidadeEconomiasCategoria().intValue();

					percentualDeterminacaoBaixoConsumo = categoria
							.getPorcentagemMediaBaixoConsumo();

					idCategoriaComMaisEconomias = categoria.getId();
				}
			}

			// Multiplica o consumo médio do imóvel pela percentual para
			// determinação de baixo consumo da categoria do imóvel que tenha
			// maior
			// número de economias

			/**
			 * TRECHO DE CÓDIGO QUE DEVE SER ALTERADO NA ITERAÇÃO 5 COM RELAÇÃO
			 * AO PERCENTUAL DETERMINACAO BAIXO CONSUMO
			 */

			BigDecimal percentual = percentualDeterminacaoBaixoConsumo;

			BigDecimal divisao = percentual.divide(new BigDecimal("100"));

			// CALCULO MÉDIA IMÓVEL
			/*
			 * double resultadoMultiplicacao = new
			 * BigDecimal(consumoMedioImovel[0])
			 * .multiply(divisao).doubleValue();
			 */

			// CALCULO MÉDIA HIDRÔMETRO
			double resultadoMultiplicacao = new BigDecimal(
					consumoMedioHidrometro[0]).multiply(divisao).doubleValue();

			ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

			// CALCULO MÉDIA HIDRÔMETRO
			if (consumoMedioHidrometro[0] > consumoTotalReferencia
					&& consumoHistorico.getNumeroConsumoFaturadoMes()
							.intValue() < resultadoMultiplicacao) {

				ImovelPerfil imovelPerfil = getControladorImovel()
						.obterImovelPerfil(imovel.getId());
				ConsumoTipo consumoTipo = new ConsumoTipo();

				// alterado por Vivianne Sousa - 17/12/2009 - analista: Savio
				// Cavalcante
				// Acessar a tabela de MICROMEDICAO.CONSUMO_ANORMALIDADE_ACAO
				// para
				// determinar a ação a ser tomada nas anormalidades de Baixo
				// Consumo,
				// Alto Consumo e Estouro de Consumo
				// 2.1
				ConsumoAnormalidadeAcao consumoAnormalidadeAcao = verificaAcaoASerTomada(
						ConsumoAnormalidade.BAIXO_CONSUMO,
						idCategoriaComMaisEconomias, imovelPerfil.getId());

				// [FS0006] - Verificar existência de consumo anormalidade ação
				// do imóvel
				if (consumoAnormalidadeAcao != null) {

					// Cria o objeto ligação tipo
					LigacaoTipo ligacaoTipo = new LigacaoTipo();

					// Caso a medição seja para água o tipo de ligação é de água
					if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA
							.intValue()) {

						ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

					} else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO
							.intValue()) {

						ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

					}

					Integer idLeituraAnormalidadeConsumo = null;
					BigDecimal numerofatorConsumo = new BigDecimal("0.00");

					// Obtém o ano e mês de referência de faturamento
					int anoMesReferenciaAnterior = Util
							.subtrairData(faturamentoGrupo
									.getAnoMesReferencia());

					// Pesquisa o consumo histórico
					Collection consumoHistoricoMesAnterior = repositorioMicromedicao
							.pesquisarConsumoHistoricoConsumoAnormalidade(
									imovel, ligacaoTipo,
									anoMesReferenciaAnterior,
									ConsumoAnormalidade.BAIXO_CONSUMO);

					// 2.1.1. Caso não tenha ocorrido estouro de consumo no mês
					// anterior
					// (CSAN_ID da tabela CONSUMO_HISTORICO com o valor
					// diferente de baixo consumo
					// com IMOV_ID=matrícula do imóvel, LGTI_ID com o valor
					// correspondente a ligação de água
					// ou com o valor correspondente a ligação de esgoto e
					// CSHI_AMFATURAMENTO igual ao ano /mês de faturamento menos
					// um mês),
					// então verifica a ação a ser tomada no primeiro mês
					// (LACS_IDMES1):
					if (consumoHistoricoMesAnterior == null
							|| consumoHistoricoMesAnterior.isEmpty()) {

						idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao
								.getLeituraAnormalidadeConsumoMes1().getId();

						numerofatorConsumo = consumoAnormalidadeAcao
								.getNumerofatorConsumoMes1();

					} else {

						// 3.1.2.Caso contrário, ou seja, tenha ocorrido estouro
						// de consumo no mês anterior,
						// o sistema verifica se tenha ocorrido estouro de
						// consumo no segundo mês anterior
						// (CSAN_ID da tabela CONSUMO_HISTORICO com o valor
						// diferente de baixo consumo
						// com IMOV_ID=matrícula do imóvel, LGTI_ID com o valor
						// correspondente a ligação de água
						// ou com o valor correspondente a ligação de esgoto e
						// CSHI_AMFATURAMENTO igual ao ano /mês de faturamento
						// menos dois meses)

						Collection consumoHistoricoSegundoMesAnterior = repositorioMicromedicao
								.pesquisarConsumoHistoricoConsumoAnormalidade(
										imovel,
										ligacaoTipo,
										Util.subtrairData(anoMesReferenciaAnterior),
										ConsumoAnormalidade.BAIXO_CONSUMO);

						if (consumoHistoricoSegundoMesAnterior == null
								|| consumoHistoricoSegundoMesAnterior.isEmpty()) {
							// caso não tenha ocorrido, então o sistema verifica
							// a ação a ser tomada no segundo mês (LACS_IDMES2):
							idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao
									.getLeituraAnormalidadeConsumoMes2()
									.getId();

							numerofatorConsumo = consumoAnormalidadeAcao
									.getNumerofatorConsumoMes2();

						} else {
							// Caso tenha ocorrido no segundo mês anterior,
							// então o sistema verifica a ação a ser tomada no
							// terceiro mês (LACS_IDMES3):
							idLeituraAnormalidadeConsumo = consumoAnormalidadeAcao
									.getLeituraAnormalidadeConsumoMes3()
									.getId();

							numerofatorConsumo = consumoAnormalidadeAcao
									.getNumerofatorConsumoMes3();
						}

					}

					// 2.1.1.1. O sistema gera a Anormalidade de Consumo com o
					// valor
					// correspondente a alto consumo da tabela
					// CONSUMO_ANORMALIDADE
					consumoAnormalidade
							.setId(ConsumoAnormalidade.BAIXO_CONSUMO);
					consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);

					if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.NAO_OCORRE)) {

						// Consumo a ser cobrado no mês será o consumo médio do
						// hidrômetro
						consumoHistorico
								.setNumeroConsumoFaturadoMes(new Integer(
										consumoMedioHidrometro[0]));
						// Seta o tipo de consumo
						consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

						/**
						 *  Ajuste da leitura faturada = leitura
						 * anterior faturada + media
						 */
						medicaoHistorico
								.setLeituraAtualFaturamento(medicaoHistorico
										.getLeituraAnteriorFaturamento()
										+ consumoMedioHidrometro[0]);
					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MINIMO)) {

						// O Consumo a Ser Cobrado no Mês será o valor retornado
						// por [UC0105  Obter Consumo Mínimo da Ligação
						consumoHistorico.setNumeroConsumoFaturadoMes(this
								.obterConsumoMinimoLigacao(imovel, null));
						// Seta o tipo de consumo
						consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MEDIA)) {

						// Consumo a ser cobrado no mês será o consumo médio do
						// hidrômetro
						consumoHistorico
								.setNumeroConsumoFaturadoMes(new Integer(
										consumoMedioHidrometro[0]));

						/**
						 *  Ajuste da leitura faturada = leitura
						 * anterior faturada + media
						 */
						medicaoHistorico
								.setLeituraAtualFaturamento(medicaoHistorico
										.getLeituraAnteriorFaturamento()
										+ consumoMedioHidrometro[0]);

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.NORMAL)) {

						// Consumo a ser cobrado no mês será o já calculado
						consumoHistorico
								.setNumeroConsumoFaturadoMes(consumoHistorico
										.getNumeroConsumoFaturadoMes());

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO)) {

						// Caso o consumo médio hidrômetro seja maior que o
						// consumo calculado
						if (consumoMedioHidrometro[0] > consumoHistorico
								.getNumeroConsumoFaturadoMes().intValue()) {

							// Consumo a ser cobrado no mês será o consumo médio
							// hidrômetro
							consumoHistorico
									.setNumeroConsumoFaturadoMes(new Integer(
											consumoMedioHidrometro[0]));
							// Seta o tipo de consumo
							consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

							/**
							 *  Ajuste da leitura faturada =
							 * leitura anterior faturada + media
							 */
							medicaoHistorico
									.setLeituraAtualFaturamento(medicaoHistorico
											.getLeituraAnteriorFaturamento()
											+ consumoMedioHidrometro[0]);

						} else {
							consumoHistorico
									.setNumeroConsumoFaturadoMes(consumoHistorico
											.getNumeroConsumoFaturadoMes());

						}

					} else if (idLeituraAnormalidadeConsumo
							.equals(LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_HIDROMETRO_CONSUMO_MEDIDO)) {

						// Caso o consumo médio hidrômetro seja menor que o
						// consumo calculado
						if (consumoMedioHidrometro[0] < consumoHistorico
								.getNumeroConsumoFaturadoMes().intValue()) {

							// Consumo a ser cobrado no mês será o consumo médio
							// do hidrômetro
							consumoHistorico
									.setNumeroConsumoFaturadoMes(new Integer(
											consumoMedioHidrometro[0]));
							// Seta o tipo de consumo
							consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

							/**
							 *  Ajuste da leitura faturada =
							 * leitura anterior faturada + media
							 */
							medicaoHistorico
									.setLeituraAtualFaturamento(medicaoHistorico
											.getLeituraAnteriorFaturamento()
											+ consumoMedioHidrometro[0]);

						} else {
							consumoHistorico
									.setNumeroConsumoFaturadoMes(medicaoHistorico
											.getNumeroConsumoMes());

						}

					}

					// 3.1.4. O consumo a Ser Cobrado no Mês será igual
					// ao Consumo a Ser Cobrado no Mês multiplicado pelo
					// fator de multiplicação da quantidade de vezes a média
					// (CSAA_NNFATORCONSUMOMES(1,2 ou 3), dependendo do mês
					// calculado anteriormente
					if (numerofatorConsumo != null) {
						BigDecimal consumofaturadoMes = new BigDecimal(
								consumoHistorico.getNumeroConsumoFaturadoMes());
						consumofaturadoMes = consumofaturadoMes
								.multiply(numerofatorConsumo);
						consumofaturadoMes = consumofaturadoMes.setScale(0,
								BigDecimal.ROUND_HALF_DOWN);
						consumoHistorico
								.setNumeroConsumoFaturadoMes(consumofaturadoMes
										.intValue());
					}

					// Atualiza o consumo histórico
					if (consumoTipo.getId() != null) {
						consumoHistorico.setConsumoTipo(consumoTipo);
					}

				} else {
					consumoAnormalidade
							.setId(ConsumoAnormalidade.BAIXO_CONSUMO);
					consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);

					/** ALTERACAO - ANORMALIDADE DE CONSUMO **/
					// // Calcula pela media
					// consumoHistorico.setNumeroConsumoFaturadoMes(new
					// Integer(consumoMedioHidrometro[0]));
					// consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
					//
					// /**
					// * 
					// * Ajuste da leitura faturada = leitura anterior faturada
					// + media
					// */
					// medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAnteriorFaturamento()
					// + consumoMedioHidrometro[0] );
				}

				// Houve consumo baixo
				retorno = true;
			}

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);

		}
		return retorno;
	}

	protected void ajusteMensalConsumo(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico, Imovel imovel, MedicaoTipo medicaoTipo, Rota rota, int consumoMedioHidrometro,
			SistemaParametro sistemaParametro) {

		try {

			int quantidadeDiasConsumoAjustado = 0;

			int quantidadeDiasConsumo = 0;

			ConsumoTipo consumoTipo = new ConsumoTipo();

			Integer anoMesReferenciaAnterior = Util.subtrairMesDoAnoMes(rota.getFaturamentoGrupo().getAnoMesReferencia(), 1);

			Date dataInstalacaoHidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();

			Date dataLeituraAnteriorNaoMedido = this.obterDataLeituraAnteriorCronograma(rota.getFaturamentoGrupo(),anoMesReferenciaAnterior);

			int leituraAjustada = 0;

			Date dataLeituraNaoMedidoAtual = null;
			
			int diferencaDiasCronograma = (int) getControladorFaturamento().obterDiferencaDiasCronogramas(rota.getFaturamentoGrupo().getAnoMesReferencia(), 
					rota, FaturamentoAtividade.EFETUAR_LEITURA); 
			
			dataLeituraNaoMedidoAtual = Util.adicionarNumeroDiasDeUmaData(dataLeituraAnteriorNaoMedido, diferencaDiasCronograma);

			try {
				if (verificarImovelFixoAgoraHidrometrado(imovel,medicaoHistorico, sistemaParametro)) {

					if (medicaoHistorico.getDataLeituraAtualInformada() != null) {
						quantidadeDiasConsumo = (int) Util.diferencaEntreDatas(dataLeituraAnteriorNaoMedido,medicaoHistorico.getDataLeituraAtualInformada());
					} else {
						quantidadeDiasConsumo = (int) Util.diferencaEntreDatas(dataLeituraAnteriorNaoMedido, dataLeituraNaoMedidoAtual);
					}

				} else {
					quantidadeDiasConsumo = (int) Util.diferencaEntreDatas(dataLeituraAnteriorNaoMedido, medicaoHistorico.getDataLeituraAtualFaturamento());
				}
			} catch (ParseException e) {
				e.printStackTrace();
			}

			if (quantidadeDiasConsumo > 0) {
				/**
				 *  Hidrometro novo em imóvel sem histórico de
				 * hidrometro, não reajusta data. Para hidrometros novos, a data
				 * da leitura anterior é igual a data da instalação do
				 * hidrometro
				 */

				int diasConsumoLido = 0;
				if (dataInstalacaoHidrometro != null && medicaoHistorico.getDataLeituraAtualInformada() != null) {
					diasConsumoLido = (int) IoUtil.diferencaEntreDatas(dataInstalacaoHidrometro, medicaoHistorico.getDataLeituraAtualInformada());

				}

				int diasConsumoLidoAjustado = 0;
				
				if (verificarImovelNovaLigacaoAgua(imovel, medicaoHistorico, sistemaParametro)) {

					quantidadeDiasConsumoAjustado = (int) IoUtil.diferencaEntreDatas(dataInstalacaoHidrometro,dataLeituraNaoMedidoAtual);

				} else if (verificarImovelFixoAgoraHidrometrado(imovel,medicaoHistorico, sistemaParametro)) {
					quantidadeDiasConsumoAjustado = diferencaDiasCronograma;

				} else if (rota.getDataAjusteLeitura() != null) {
					quantidadeDiasConsumoAjustado = (int) IoUtil.diferencaEntreDatas(dataLeituraAnteriorNaoMedido,rota.getDataAjusteLeitura());

				} else {
					quantidadeDiasConsumoAjustado = diferencaDiasCronograma;
				}

				int diasAjuste = quantidadeDiasConsumoAjustado - quantidadeDiasConsumo;

				boolean houveSubstituicaoHidrometro = verificarSubstituicaoHidrometro(imovel, medicaoHistorico, sistemaParametro);

				if (diasAjuste < -3 || diasAjuste > 3 || houveSubstituicaoHidrometro) {

					BigDecimal consumoDiario = new BigDecimal(-1);

					Integer leituraInstalacaoHidrometro = this.obterLeituraInstalacaoHidrometro(rota.getFaturamentoGrupo(), imovel);

					try {
						if (medicaoHistorico.getLeituraAtualInformada() != null
								&& medicaoHistorico.getDataLeituraAtualFaturamento() != null
								&& (verificarSubstituicaoHidrometro(imovel,medicaoHistorico, sistemaParametro))
								&& consumoHistorico != null
								&& consumoHistorico.getConsumoTipo() != null
								&& consumoHistorico.getConsumoTipo().getId() != null
								&& !consumoHistorico.getConsumoTipo().getId()
										.equals(ConsumoTipo.MEDIA_HIDROMETRO)) {

							BigDecimal numerador = new BigDecimal(
									medicaoHistorico.getLeituraAtualInformada()
											- leituraInstalacaoHidrometro);
							BigDecimal denominador = new BigDecimal(
									diasConsumoLido);

							// ok
							if (diasConsumoLido != 0) {
								consumoDiario = numerador.divide(denominador,
										3, BigDecimal.ROUND_HALF_DOWN);
							}

							Integer qtdDias = diferencaDiasCronograma;

							Date dataLeituraReferenciaAtual = Util
									.adicionarNumeroDiasDeUmaData(
											dataLeituraAnteriorNaoMedido,
											qtdDias);

							diasConsumoLidoAjustado = (int) IoUtil
									.diferencaEntreDatas(
											dataInstalacaoHidrometro,
											dataLeituraReferenciaAtual);

							BigDecimal resultado = consumoDiario
									.multiply(new BigDecimal(
											(Integer) diasConsumoLidoAjustado));

							leituraAjustada = new Integer(
									Util.arredondar(resultado))
									+ leituraInstalacaoHidrometro;
							// leituraAjustada = new
							// Integer(Util.arredondar(resultado));

							medicaoHistorico
									.setLeituraAtualFaturamento(leituraAjustada);

						} else if (medicaoHistorico.getLeituraAtualInformada() != null
								&& (verificarImovelFixoAgoraHidrometrado(imovel, medicaoHistorico,sistemaParametro))
								&& consumoHistorico != null
								&& consumoHistorico.getConsumoTipo() != null
								&& consumoHistorico.getConsumoTipo().getId() != null
								&& !consumoHistorico.getConsumoTipo().getId()
										.equals(ConsumoTipo.MEDIA_HIDROMETRO)) {

							int consumoMedidoMes = medicaoHistorico
									.getLeituraAtualInformada()
									- obterLeituraAnterior(medicaoHistorico);

//							int consumoFaturadoMes = consumoMedidoMes;

							BigDecimal numerador = new BigDecimal(
									consumoMedidoMes);
							BigDecimal denominador = new BigDecimal(
									diasConsumoLido);

							if (diasConsumoLido != 0) {
								consumoDiario = numerador.divide(denominador,
										3, BigDecimal.ROUND_HALF_DOWN);
							}

							diasConsumoLidoAjustado = (int) Util
									.diferencaEntreDatas(
											dataInstalacaoHidrometro,
											dataLeituraNaoMedidoAtual);

							BigDecimal resultado = consumoDiario
									.multiply(new BigDecimal(
											(Integer) diasConsumoLidoAjustado));
							leituraAjustada = new Integer(
									Util.arredondar(resultado))
									+ medicaoHistorico
											.getLeituraAnteriorFaturamento();

							medicaoHistorico
									.setLeituraAtualFaturamento(leituraAjustada);

						} else if (medicaoHistorico.getLeituraAtualInformada() != null
								&& (consumoHistorico != null
										&& consumoHistorico.getConsumoTipo().getId() != null 
										&& !consumoHistorico.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_HIDROMETRO))) {

							// Cálculo para obter a leitura ajustada
							leituraAjustada = medicaoHistorico.getLeituraAtualInformada()  + Util.divideDepoisMultiplica(consumoHistorico.getNumeroConsumoFaturadoMes().intValue(),
											quantidadeDiasConsumo, diasAjuste);
							
						} else if ((consumoHistorico.getConsumoTipo() != null 
								&& consumoHistorico.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_HIDROMETRO))
								|| (medicaoHistorico.getLeituraAtualInformada() == null 
								&& medicaoHistorico.getLeituraAnormalidadeFaturamento() != null)) {
							
							leituraAjustada = medicaoHistorico.getLeituraAtualFaturamento();
						}

						else {
							leituraAjustada = medicaoHistorico.getLeituraAtualInformada();
						}

					} catch (ParseException e) {
						e.printStackTrace();
					}

					if ((leituraAjustada != 0
							|| (leituraAjustada == 0 && diasConsumoLido == 0)
							|| (leituraAjustada == 0 && diasConsumoLidoAjustado == 0) 
							|| (leituraAjustada == 0 && consumoDiario.intValue() == 0))
						&& medicaoHistorico.getLeituraAtualInformada() != null
						&& (verificarSubstituicaoHidrometro(imovel,medicaoHistorico, sistemaParametro) 
							|| verificarImovelFixoAgoraHidrometrado(imovel, medicaoHistorico, sistemaParametro))
						&& consumoHistorico != null
						&& consumoHistorico.getConsumoTipo() != null
						&& consumoHistorico.getConsumoTipo().getId() != null
						&& !consumoHistorico.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_HIDROMETRO)) {

						int consumoFaturadoMes = 0;

						if (diasConsumoLido > 9) {

							BigDecimal resultado = consumoDiario.multiply(new BigDecimal(quantidadeDiasConsumoAjustado));

							consumoFaturadoMes = new Integer(Util.arredondar(resultado));
							consumoTipo.setId(ConsumoTipo.ESTIMADO);
						} else {

							if (sistemaParametro.getIndicadorNaoMedidoTarifa().equals(ConstantesSistema.SIM)) {
								consumoFaturadoMes = this.obterConsumoMinimoLigacao(imovel, null);
								
							} else {
								consumoFaturadoMes = this.obterConsumoNaoMedidoSemTarifa(imovel.getId(), sistemaParametro.getAnoMesFaturamento());
							}

							consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);
						}

						consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(consumoFaturadoMes));
						consumoHistorico.setConsumoTipo(consumoTipo);
						
					} else if ((leituraAjustada != 0
									|| (leituraAjustada == 0 && diasConsumoLido == 0)
									|| (leituraAjustada == 0 && diasConsumoLidoAjustado == 0) 
									|| (leituraAjustada == 0 && consumoDiario.intValue() == 0))
								&& medicaoHistorico.getLeituraAtualInformada() != null
								&& !consumoHistorico.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_HIDROMETRO)) {
						
						int consumoASerCobradoMes = Util.divideDepoisMultiplica(consumoHistorico.getNumeroConsumoFaturadoMes(),
										quantidadeDiasConsumo, quantidadeDiasConsumoAjustado);

						consumoHistorico.setNumeroConsumoFaturadoMes(consumoASerCobradoMes);

					}
					
					Date dataLeituraAtualFaturamento = IoUtil.adicionarDias(medicaoHistorico.getDataLeituraAtualFaturamento(), diasAjuste);
				
					medicaoHistorico.setDataLeituraAtualFaturamento(dataLeituraAtualFaturamento);

					if (!consumoHistorico.getConsumoTipo().getId()
							.equals(ConsumoTipo.MEDIA_HIDROMETRO)
							&& !consumoHistorico.getConsumoTipo().getId()
									.equals(ConsumoTipo.CONSUMO_MINIMO_FIXADO)
							&& !consumoHistorico.getConsumoTipo().getId()
									.equals(ConsumoTipo.NAO_MEDIDO)
							&& !consumoHistorico.getConsumoTipo().getId()
									.equals(ConsumoTipo.FIXO_SITUACAO_ESPECIAL)) {

						consumoTipo.setId(ConsumoTipo.CONSUMO_MEDIO_AJUSTADO);
						consumoHistorico.setConsumoTipo(consumoTipo);
					}
				} else {
					if (medicaoHistorico.getDataLeituraAtualInformada() != null) {
						medicaoHistorico
								.setDataLeituraAtualFaturamento(medicaoHistorico
										.getDataLeituraAtualInformada());
					}

					if (medicaoHistorico.getLeituraAtualInformada() != null) {
						medicaoHistorico
								.setLeituraAtualFaturamento(medicaoHistorico
										.getLeituraAtualInformada());
					}
				}

				int numeroDigitosHidrometro = 0;

				// Verifica qual o tipo de medicação e obtém o número de
				// dígitos do
				// hidrômetro
				if (medicaoTipo.getId().equals(MedicaoTipo.LIGACAO_AGUA)) {
					numeroDigitosHidrometro = imovel.getLigacaoAgua()
							.getHidrometroInstalacaoHistorico().getHidrometro()
							.getNumeroDigitosLeitura().intValue();
				} else if (medicaoTipo.getId() == MedicaoTipo.POCO) {
					numeroDigitosHidrometro = imovel
							.getHidrometroInstalacaoHistorico().getHidrometro()
							.getNumeroDigitosLeitura().intValue();
				}

				// Obtém 10 elevado ao numeroDigitosHidrometro
				int dezElevadoNumeroDigitos = (int) Math.pow(10,
						numeroDigitosHidrometro);

				// Obtém 10 elevado ao numeroDigitosHidrometro - 1
				int dezElevadoNumeroDigitosMenosUm = ((int) Math.pow(10,
						numeroDigitosHidrometro)) - 1;

				if (leituraAjustada == 0) {

					if (medicaoHistorico.getLeituraAtualFaturamento() > dezElevadoNumeroDigitosMenosUm) {
						medicaoHistorico
								.setLeituraAtualFaturamento(medicaoHistorico
										.getLeituraAtualFaturamento()
										- dezElevadoNumeroDigitosMenosUm);

						if (consumoHistorico.getConsumoAnormalidade() == null
								|| consumoHistorico
										.getConsumoAnormalidade()
										.equals(ConsumoAnormalidade.ANORMALIDADE_DE_LEITURA)) {

							ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
							consumoAnormalidade
									.setId(ConsumoAnormalidade.VIRADA_HIDROMETRO);
							consumoHistorico
									.setConsumoAnormalidade(consumoAnormalidade);
						}
					}

				}
				// Caso a leitura ajustada menor que 0
				else if (leituraAjustada < 0) {

					medicaoHistorico.setLeituraAtualFaturamento(leituraAjustada
							+ dezElevadoNumeroDigitos);

				} else if (leituraAjustada > dezElevadoNumeroDigitosMenosUm) {

					medicaoHistorico.setLeituraAtualFaturamento(leituraAjustada
							- dezElevadoNumeroDigitosMenosUm);

					if (consumoHistorico.getConsumoAnormalidade() == null
							|| consumoHistorico
									.getConsumoAnormalidade()
									.equals(ConsumoAnormalidade.ANORMALIDADE_DE_LEITURA)) {

						ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
						consumoAnormalidade
								.setId(ConsumoAnormalidade.VIRADA_HIDROMETRO);
						consumoHistorico
								.setConsumoAnormalidade(consumoAnormalidade);
					}
				} else {
					medicaoHistorico
							.setLeituraAtualFaturamento(leituraAjustada);
				}
			}
		} catch (ControladorException e1) {
			
			e1.printStackTrace();
		}
	}

	/**
	 * [UC0105] - Obter Consumo Mínimo da Ligação
	 */
	/*
	 * public int obterConsumoMinimoLigacao(Imovel imovel, Collection
	 * colecaoCategorias) throws ControladorException {
	 * 
	 * // Declaração de variáveis int consumoMinimoLigacao = 0;
	 * 
	 * // Declaração de objetos Collection colecaoDataVigencia = null; Integer
	 * consumoMinimo = null;
	 * 
	 * // Obtém o id do consumo tarifa vigência da maior data de vigência da //
	 * tarifa do imóvel try { colecaoDataVigencia = repositorioMicromedicao
	 * .pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(), imovel); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * new ControladorException("erro.sistema", ex); }
	 * 
	 * // Obtém o id do array e atribui na variável Object[]
	 * consumoTarifaVigenciaIdArray = (Object[]) Util
	 * .retonarObjetoDeColecaoArray(colecaoDataVigencia); Integer
	 * consumoTarifaVigenciaId = null;
	 * 
	 * if (consumoTarifaVigenciaIdArray == null) { throw new
	 * ControladorException( "erro.nao_cadastrada_consumo_tarifa_vigencia",
	 * null, String .valueOf(imovel.getId())); }
	 * 
	 * if (consumoTarifaVigenciaIdArray[0] != null) { consumoTarifaVigenciaId =
	 * (Integer) consumoTarifaVigenciaIdArray[0]; }
	 * 
	 * // Cria o objeto consumo tarifa vigência e seta o id
	 * ConsumoTarifaVigencia consumoTarifaVigencia = new
	 * ConsumoTarifaVigencia();
	 * consumoTarifaVigencia.setId(consumoTarifaVigenciaId);
	 * 
	 * // [UC0108] - Obter Quantidade de Economias por Categoria if
	 * (colecaoCategorias == null) { colecaoCategorias = getControladorImovel()
	 * .obterQuantidadeEconomiasCategoria(imovel); }
	 * 
	 * Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();
	 * 
	 * while (colecaoCategoriasIterator.hasNext()) {
	 * 
	 * Categoria categoria = (Categoria) colecaoCategoriasIterator.next();
	 * 
	 * try { // Obtém o consumo mínimo da tarifa da categoria do imóvel Object
	 * consumoMinimoObjeto = repositorioMicromedicao
	 * .pesquisarConsumoMinimoTarifaCategoriaVigencia( categoria,
	 * consumoTarifaVigencia); consumoMinimo = (Integer) consumoMinimoObjeto; }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * new ControladorException("erro.sistema", ex); }
	 * 
	 * if (consumoMinimo != null) { // Multiplica a quantidade de economias da
	 * categoria pelo // consumo // mínimo e acumula consumoMinimoLigacao =
	 * consumoMinimoLigacao + (categoria.getQuantidadeEconomiasCategoria()
	 * .intValue() * consumoMinimo.intValue()); }
	 * 
	 * }
	 * 
	 * // Retorna o consumo mínimo da ligação return consumoMinimoLigacao;
	 * 
	 * }
	 */

	/**
	 * < <Descrição do método>>
	 */
	/*
	 * protected Collection obterQuantidadeEconomiasCategoria(Imovel imovel) {
	 * //Criação das coleções Collection retorno = null; Collection
	 * colecaoCategoria = null; //Filtro para obter o imóvel subcategoria
	 * FiltroImovelSubCategoria filtroImovelSubCategoria = new
	 * FiltroImovelSubCategoria(); ParametroSimples parametroSimples = new
	 * ParametroSimples( filtroImovelSubCategoria.IMOVEL_ID, imovel.getId());
	 * //Pesquisa imóvel subcategoria passado como parâmetro um imóvel
	 * Collection colecaoImovelSubCategoria =
	 * pesquisar(filtroImovelSubCategoria, ImovelSubcategoria.class.getName());
	 * if (colecaoImovelSubCategoria != null &&
	 * !colecaoImovelSubCategoria.isEmpty()) { Iterator
	 * colecaoImovelSubCategoriaIterator = colecaoImovelSubCategoria.iterator();
	 * int idCategoria = 0; int idCategoriaFixa = 0; boolean primeiroId = true;
	 * int totalQuantidadeEconomiasPorCategoria = 0; while
	 * (colecaoImovelSubCategoriaIterator.hasNext()) { //Obtém o imóvel
	 * subcategoria ImovelSubcategoria imovelSubcategoria = (ImovelSubcategoria)
	 * colecaoImovelSubCategoriaIterator.next(); //Obtém a quantidade de
	 * economias int quantidadeEconomias =
	 * imovelSubcategoria.getQuantidadeEconomias(); //Obtém o id da categoria
	 * idCategoria = imovelSubcategoria.getComp_id().getSubcategoria().
	 * getCategoria().getId().intValue(); //Cria os objetos categoria Categoria
	 * categoria = new Categoria(); Categoria categoriaAnterior = new
	 * Categoria(); //Acumula a quantidade de economias por categoria
	 * totalQuantidadeEconomiasPorCategoria += quantidadeEconomias; //Seta a
	 * categoria categoria.setId(new Integer(idCategoria));
	 * categoria.setQuantidadeEconomiasCategoria(
	 * totalQuantidadeEconomiasPorCategoria); //Verifica se é o primeiro objeto
	 * da coleção if (primeiroId) { //Armazena o id da categoria idCategoriaFixa
	 * = idCategoria; //Deixa se ser o primeiro objeto da coleção primeiroId =
	 * false; //Verifica se o id mudou } else if (idCategoria !=
	 * idCategoriaFixa) { idCategoriaFixa = idCategoria; //O total de quantidade
	 * de economias recebe novo valor sem acumular
	 * totalQuantidadeEconomiasPorCategoria = quantidadeEconomias;
	 * categoria.setQuantidadeEconomiasCategoria(
	 * totalQuantidadeEconomiasPorCategoria); //Caso ainda tenha mais objetos na
	 * coleção adiciona a anterior if
	 * (colecaoImovelSubCategoriaIterator.hasNext()) {
	 * colecaoCategoria.add(categoriaAnterior); } } //Caso a coleção só tenha
	 * apenas um imóvel subcategoria if
	 * (!colecaoImovelSubCategoriaIterator.hasNext()) {
	 * colecaoCategoria.add(categoria); } else { //Armazena a categoria para que
	 * possa ser utilizada posteriormente categoriaAnterior.setId(new
	 * Integer(idCategoria)); categoriaAnterior.setQuantidadeEconomiasCategoria(
	 * totalQuantidadeEconomiasPorCategoria); } } } else { //Caso a coleção não
	 * tenha retornado objetos throw new ControladorException(
	 * "atencao.nao_cadastrado.imovel_subcategoria", null); } return
	 * colecaoCategoria; }
	 */
	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0022] ? Dados para
	 * Faturamento Especial do Não Medido
	 */
	protected void dadosFaturamentoEspecialNaoMedido(
			ConsumoHistorico consumoHistorico, int[] consumoMedioImovel,
			Imovel imovel, FaturamentoGrupo faturamentoGrupo)
			throws ControladorException {

		Collection colecaoFaturamentoSituacaoTipo = null;

		ConsumoTipo consumoTipo = new ConsumoTipo();

		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		try {
			// Pesquisa a anormalidade de leitura de faturamento
			colecaoFaturamentoSituacaoTipo = repositorioMicromedicao
					.pesquisarFaturamentoSituacaoTipo(imovel
							.getFaturamentoSituacaoTipo());

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém a leitura anormalidade
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = obterFaturamentoSituacaoTipo(colecaoFaturamentoSituacaoTipo);

		// Seta a leitura anormalidade faturamento
		imovel.getFaturamentoSituacaoTipo()
				.setLeituraAnormalidadeConsumoSemLeitura(
						faturamentoSituacaoTipo
								.getLeituraAnormalidadeConsumoSemLeitura());
		imovel.getFaturamentoSituacaoTipo()
				.setLeituraAnormalidadeConsumoComLeitura(
						faturamentoSituacaoTipo
								.getLeituraAnormalidadeConsumoComLeitura());
		imovel.getFaturamentoSituacaoTipo()
				.setLeituraAnormalidadeLeituraSemLeitura(
						faturamentoSituacaoTipo
								.getLeituraAnormalidadeLeituraSemLeitura());
		imovel.getFaturamentoSituacaoTipo()
				.setLeituraAnormalidadeLeituraComLeitura(
						faturamentoSituacaoTipo
								.getLeituraAnormalidadeLeituraComLeitura());

		/*
		 * Colocado por Raphael Rossiter em 12/08/2008 - Analista: Rosana
		 * Carvalho
		 * 
		 * OBJ: Verificar a situação especial de faturamento quando o consumo de
		 * água e/ou volume de esgoto está fixo.
		 */
		FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = null;

		try {
			faturamentoSituacaoHistorico = repositorioMicromedicao
					.pesquisarFaturamentoSituacaoHistoricoConsumoVolumeFixo(
							imovel, faturamentoGrupo);

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (imovel.getFaturamentoSituacaoTipo()
				.getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
				.intValue()) {
			// Consumo a ser cobrado no mês será o consumo médio do imóvel
			consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
					consumoMedioImovel[0]));
			// Seta o tipo de consumo
			consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);
			// Caso a leitura anormalidade consumo sem leitura seja igual a
			// leitura anormalidade consumo mínimo
		} else if (imovel.getFaturamentoSituacaoTipo()
				.getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MINIMO
				.intValue() && faturamentoSituacaoHistorico != null) {
			/*
			 * Data: 21/05/2009 Autor: Bruno Barros Analista: Sávio
			 * 
			 * Alteração solicitada: O consumo a ser cobrado no mes será o valor
			 * retornado <<inclui>> [UC0105] - Obter consumo minino da ligação.
			 */

			// Consumo a ser cobrado no mês será zero
			consumoHistorico.setNumeroConsumoFaturadoMes(this
					.obterConsumoMinimoLigacao(imovel, null));

			// Seta o tipo de consumo
			consumoTipo.setId(ConsumoTipo.FIXO_SITUACAO_ESPECIAL);

			/*
			 * FIM ALTERAÇÃO BRUNO BARROS
			 * 
			 * Código Anterior: // Consumo a ser cobrado no mês será zero
			 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(0));
			 * 
			 * // Seta o tipo de consumo
			 * consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);
			 */
		} else if (imovel.getFaturamentoSituacaoTipo()
				.getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MEDIA
				.intValue()) {
			// Consumo a ser cobrado no mês será o consumo médio do imóvel
			consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
					consumoMedioImovel[0]));
			// Seta o tipo de consumo
			consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);
		}

		/*
		 * Colocado por Raphael Rossiter em 12/08/2008 - Analista: Rosana
		 * Carvalho
		 * 
		 * OBJ: Verificar a situação especial de faturamento quando o consumo de
		 * água e/ou volume de esgoto está fixo.
		 */
		else if (imovel.getFaturamentoSituacaoTipo()
				.getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.FIXO
				.intValue() && faturamentoSituacaoHistorico != null) {

			// ConsumoTipo
			consumoTipo.setId(ConsumoTipo.FIXO_SITUACAO_ESPECIAL);

			// Consumo a ser cobrado no mês será o consumo fixado no histórico
			// da situação especial
			if (consumoHistorico.getLigacaoTipo().getId()
					.equals(LigacaoTipo.LIGACAO_AGUA)) {

				if (faturamentoSituacaoHistorico
						.getNumeroConsumoAguaNaoMedido() != null) {

					/*
					 * Colocado por Raphael Rossiter em 16/01/2009 - Analista:
					 * Rosana Carvalho
					 * 
					 * Caso o consumo calculado seja MENOR que o consumo fixo,
					 * colocar o consumo calculado; caso contrário, colocar o
					 * consumo fixo.
					 */
					if (consumoHistorico.getNumeroConsumoFaturadoMes()
							.intValue() > faturamentoSituacaoHistorico
							.getNumeroConsumoAguaNaoMedido()) {

						consumoHistorico
								.setNumeroConsumoFaturadoMes(faturamentoSituacaoHistorico
										.getNumeroConsumoAguaNaoMedido());
					}
				}
			} else if (faturamentoSituacaoHistorico
					.getNumeroVolumeEsgotoNaoMedido() != null) {

				/*
				 * Colocado por Raphael Rossiter em 16/01/2009 - Analista:
				 * Rosana Carvalho
				 * 
				 * Caso o volume calculado seja MENOR que o volume fixo, colocar
				 * o volume calculado; caso contrário, colocar o volume fixo.
				 */
				if (consumoHistorico.getNumeroConsumoFaturadoMes().intValue() > faturamentoSituacaoHistorico
						.getNumeroVolumeEsgotoNaoMedido()) {

					consumoHistorico
							.setNumeroConsumoFaturadoMes(faturamentoSituacaoHistorico
									.getNumeroVolumeEsgotoNaoMedido());
				}

			}
		} else if (imovel.getFaturamentoSituacaoTipo()
				.getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.NAO_MEDIDO
				.intValue()) {

			Short IndicadorNaoMedidoTarifa = sistemaParametro
					.getIndicadorNaoMedidoTarifa();
			Integer consumo = new Integer(0);
			if (IndicadorNaoMedidoTarifa.compareTo(ConstantesSistema.SIM) == 0) {
				// Consumo a ser cobrado no mês será o consumo para ligação não
				// medida
				// por tarifa
				consumo = this.obterConsumoMinimoLigacao(imovel, null);
				consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
			} else if (IndicadorNaoMedidoTarifa
					.compareTo(ConstantesSistema.NAO) == 0) {
				/*
				 * RM 954  Alteração para adequação da implantação da COSAMA.
				 * Cálculo do consumo não medido por ponto de utilização ou
				 * número de moradores. Mariana Victor em 23/05/2011 - Analista:
				 * Rosana Carvalho
				 */
				if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
						&& sistemaParametro.getCodigoTipoCalculoNaoMedido()
								.equals(new Integer(1))) {

					// Consumo a ser cobrado no mês será o consumo para ligação
					// não medida
					// sem ser por tarifa
					consumo = this.obterConsumoNaoMedidoSemTarifa(imovel.getId(),
							sistemaParametro.getAnoMesFaturamento());
					consumoHistorico.setNumeroConsumoFaturadoMes(consumo);

				} else if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
						&& (sistemaParametro.getCodigoTipoCalculoNaoMedido()
								.equals(new Integer(2)) || sistemaParametro
								.getCodigoTipoCalculoNaoMedido().equals(
										new Integer(3)))) {

					/**
					 * Colocado por Mariana Victor em 23/05/2011 - Analista:
					 * Rosana Carvalho [UC0000] - Obter Consumo Não Medido Por
					 * Parâmetro
					 */
					consumo = this.obterConsumoNaoMedidoPorParametro(
							imovel.getId(),
							sistemaParametro.getAnoMesFaturamento(), null);
					consumoHistorico.setNumeroConsumoFaturadoMes(consumo);
				}
			}

			// Seta o tipo de consumo
			consumoTipo.setId(ConsumoTipo.ESTIMADO);
		}

		// Seta o consumo tipo
		if (consumoTipo.getId() != null) {
			consumoHistorico.setConsumoTipo(consumoTipo);
		}
	}

	/**
	 * < <Descrição do método>>
	 */
	/*
	 * protected int obterQuantidadeEconomias(Imovel imovel) { //Filtro para
	 * obter o imóvel subcategoria FiltroImovelSubCategoria
	 * filtroImovelSubCategoria = new FiltroImovelSubCategoria();
	 * ParametroSimples parametroSimples = new
	 * ParametroSimples(filtroImovelSubCategoria.IMOVEL_ID, imovel.getId());
	 * //Pesquisa imóvel subcategoria passado como parâmetro um imóvel
	 * Collection colecaoImovelSubCategoria =
	 * pesquisar(filtroImovelSubCategoria, ImovelSubcategoria.class.getName());
	 * int totalQuantidadeEconomias = 0; if (colecaoImovelSubCategoria != null
	 * && !colecaoImovelSubCategoria.isEmpty()) { Iterator
	 * colecaoImovelSubCategoriaIterator = colecaoImovelSubCategoria.iterator();
	 * while (colecaoImovelSubCategoriaIterator.hasNext()) { //Obtém o imóvel
	 * subcategoria ImovelSubcategoria imovelSubcategoria = (ImovelSubcategoria)
	 * colecaoImovelSubCategoriaIterator.next(); //Obtém a quantidade de
	 * economias int quantidadeEconomias =
	 * imovelSubcategoria.getQuantidadeEconomias(); //Acumula a quantidade de
	 * economias por categoria totalQuantidadeEconomias += quantidadeEconomias;
	 * } } else { //Caso a coleção não tenha retornado objetos throw new
	 * ControladorException("atencao.nao_cadastrado.imovel_subcategoria", null);
	 * } return totalQuantidadeEconomias; }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param medicaoHistorico
	 *            Descrição do parâmetro
	 * @param consumoHistorico
	 *            Descrição do parâmetro
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param faturamentoGrupo
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param medicaoTipo
	 *            Descrição do parâmetro
	 * @param consumoMedioImovel
	 *            Descrição do parâmetro
	 * @param consumoHistoricoLigacaoAgua
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	/*
	 * protected void determinarDadosFaturamentoEsgotoMedidoPoco(
	 * MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico,
	 * Imovel imovel, FaturamentoGrupo faturamentoGrupo, SistemaParametro
	 * sistemaParametro, MedicaoTipo medicaoTipo, int[] consumoMedioImovel,
	 * ConsumoHistorico consumoHistoricoLigacaoAgua) throws ControladorException
	 * {
	 * 
	 * medicaoHistorico = new MedicaoHistorico();
	 * 
	 * if (consumoHistorico == null) { consumoHistorico = new
	 * ConsumoHistorico(); } // Obtém o histórico de medição medicaoHistorico =
	 * obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo,
	 * sistemaParametro); // Obtém consumo médio do hidrometro int[]
	 * consumoMedioHidrometro = obterConsumoMedioHidrometro(imovel,
	 * sistemaParametro, medicaoTipo); // Determinar o consumo medido do mês, o
	 * consumo a ser cobrado no mês e // a leitura atual de faturamento
	 * 
	 * int leituraAnterior = 0; // Caso a leitura atual informada diferente de
	 * zero if (medicaoHistorico.getLeituraAtualInformada() != null) { // Obtém
	 * a leitura anterior leituraAnterior =
	 * obterLeituraAnterior(medicaoHistorico); // Caso leitura atual informada
	 * maior que a leitura anterior if
	 * (medicaoHistorico.getLeituraAtualInformada() > leituraAnterior) { //
	 * Definir dados para faturamento para leitura MAIOR que a // anterior
	 * dadosFaturamentoLeituraMaiorAnterior(medicaoHistorico, consumoHistorico,
	 * consumoMedioHidrometro[0], imovel); // Caso a leitura atual informada
	 * igual a leitura anterior } else if
	 * (medicaoHistorico.getLeituraAtualInformada() == leituraAnterior) { //
	 * Definir dados para faturamento leitura IGUAL a anteior
	 * dadosFaturamentoLeituraIgualAnterior(medicaoHistorico, consumoHistorico,
	 * medicaoTipo, imovel); // Caso a leitura atual informada menor que a
	 * leitura anterior } else if (medicaoHistorico.getLeituraAtualInformada() <
	 * leituraAnterior) { // Definir dados para faturamento leitura MENOR que a
	 * anterior dadosFaturamentoLeituraMenorAnterior(imovel, consumoHistorico,
	 * medicaoHistorico, sistemaParametro, leituraAnterior, medicaoTipo,
	 * consumoMedioImovel, consumoMedioHidrometro); } // Caso a leitura atual
	 * inforamda seja zero e a leitura anormalidade // faturamento diferente de
	 * null } else if (medicaoHistorico.getLeituraAtualInformada() == null &&
	 * medicaoHistorico.getLeituraAnormalidadeFaturamento() == null) {
	 * dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(
	 * medicaoHistorico, consumoHistorico, consumoMedioHidrometro); } // Caso a
	 * anormalidade de leitura de faturamento esteja com valor // diferente de
	 * nulo if (medicaoHistorico.getLeituraAnormalidadeFaturamento() != null) {
	 * // Definir dados para faturamento com anormalidade leitura
	 * dadosFaturamentoAnormalidadeLeitura(medicaoHistorico, consumoHistorico,
	 * consumoMedioHidrometro, leituraAnterior); } // Caso o imóvel esteja com a
	 * situação de faturamento especial if
	 * (imovel.getFaturamentoSituacaoTipo().getId() !=
	 * FaturamentoSituacaoTipo.FATURAMENTO_NORMAL) { // Define dados para
	 * faturamento especial do medido
	 * dadosFaturamentoEspecialMedido(medicaoHistorico, consumoHistorico,
	 * imovel, consumoMedioHidrometro, leituraAnterior); }
	 * 
	 * Collection colecaoCategoria = null; // (Chamar método para obter
	 * quantidade de economias por categoria) // Verifica se houve estouro de
	 * consumo // Caso não tenha estouro de consumo if
	 * (!verificarEstouroConsumo(consumoHistorico, imovel, consumoMedioImovel,
	 * consumoMedioHidrometro, sistemaParametro, medicaoTipo, colecaoCategoria,
	 * medicaoHistorico, leituraAnterior)) { // Verifica se houve alto consumo
	 * verificarAltoConsumo(consumoHistorico, consumoMedioImovel,
	 * colecaoCategoria); } // Caso a leitura atual tenha sido real e
	 * anormalidade de leitura e // faturamento esteja com valor nulo if
	 * ((medicaoHistorico.getLeituraSituacaoAtual().getId() ==
	 * LeituraSituacao.REALIZADA || medicaoHistorico
	 * .getLeituraSituacaoAtual().getId() == LeituraSituacao.CONFIRMADA) &&
	 * (medicaoHistorico.getLeituraAnormalidadeFaturamento() .getId() == null))
	 * { // Verifica se houve baixo consumo
	 * verificarBaixoConsumo(consumoHistorico, consumoMedioImovel,
	 * colecaoCategoria); } // Caso o indicador de ajuste de consumo esteja
	 * definido como um if
	 * (imovel.getQuadra().getRota().getIndicadorAjusteConsumo() .shortValue()
	 * == new Short("1").shortValue()) { // Realiza o ajuste mensal // /---
	 * FALTA ADICIONAR ROTA ajusteMensalConsumo(medicaoHistorico, //
	 * consumoHistorico, imovel, // medicaoTipo, rota); } // Caso existe consumo
	 * a ser cobrado no mês para água if (consumoHistoricoLigacaoAgua != null &&
	 * consumoHistoricoLigacaoAgua.getNumeroConsumoFaturadoMes() != null) { //
	 * Consumo a ser cobrado no mês de esgoto vai ser consumo cobrado // mês de
	 * ligação de água + consumo a ser cobrado mês de esgoto int
	 * consumoCobradoMesEsgoto = consumoHistoricoLigacaoAgua.getId() .intValue()
	 * + consumoHistorico.getNumeroConsumoFaturadoMes().intValue(); // Seta o
	 * consumo a ser cobrado consumoHistorico.setNumeroConsumoFaturadoMes(new
	 * Integer( consumoCobradoMesEsgoto)); } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param consumoHistorico
	 *            Descrição do parâmetro
	 * @param consumoHistoricoLigacaoAgua
	 *            Descrição do parâmetro
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param consumoMedioImovel
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarDadosFaturamentoEsgotoSemPocoComPocoSemMedicao(
	 * ConsumoHistorico consumoHistorico, ConsumoHistorico
	 * consumoHistoricoLigacaoAgua, Imovel imovel, int[] consumoMedioImovel)
	 * throws ControladorException { // Caso exista consumo a ser cobrado no
	 * consumo histórico de ligação de // água if (consumoHistoricoLigacaoAgua
	 * != null && consumoHistoricoLigacaoAgua.getNumeroConsumoFaturadoMes() !=
	 * null) { // Seta o consumo a ser cobrado no mês será o mesmo do consumo //
	 * histórico de ligação de água consumoHistorico
	 * .setNumeroConsumoFaturadoMes(consumoHistoricoLigacaoAgua
	 * .getNumeroConsumoFaturadoMes()); // Seta o tipo de consumo setá o mesmo
	 * do consumo histórico ligação // de água
	 * consumoHistorico.setConsumoTipo(consumoHistoricoLigacaoAgua
	 * .getConsumoTipo()); } else { // Obtém o consumo mínimo da ligação int
	 * consumoMinimoLigacao = obterConsumoMinimoLigacao(imovel, null); // O
	 * consumo a ser cobrado no mês será o consumo mínimo de ligação // de
	 * ligação consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoMinimoLigacao));
	 * 
	 * ConsumoTipo consumoTipo = new ConsumoTipo(); // O tipo de consumo será
	 * não medido consumoTipo.setId(ConsumoTipo.NAO_MEDIDO); } // Caso o
	 * faturamento situação tipo seja diferente de normal if
	 * (imovel.getFaturamentoSituacaoTipo().getId() !=
	 * FaturamentoSituacaoTipo.FATURAMENTO_NORMAL) { // Determinar dados para
	 * faturamento especial do não medido
	 * dadosFaturamentoEspecialNaoMedido(consumoHistorico, consumoMedioImovel,
	 * imovel); } }
	 */

	/**
	 * Determinar Rateio de Água
	 * 
	 * @param imovelCondominio
	 *            Descrição do parâmetro
	 * @param somaNumeroConsumoFaturadoMesAgua
	 *            Descrição do parâmetro
	 * @param somaConsumosMinimos
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasMedidasAgua
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasNaoMedidasAgua
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoAgua
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominioAgua
	 *            Descrição do parâmetro
	 */

	/*
	 * protected void determinarRateioAgua(Imovel imovelCondominio, int
	 * somaNumeroConsumoFaturadoMesAgua, int somaConsumosMinimos,
	 * SistemaParametro sistemaParametro, int quantidadeEconomiasMedidasAgua,
	 * int quantidadeEconomiasNaoMedidasAgua, Collection
	 * colecaoConsumoHistoricoAgua, ConsumoHistorico
	 * consumoHistoricoCondominioAgua) throws ControladorException { // Obtém o
	 * consumo a ser rateado int consumoAguaSerRateado =
	 * consumoHistoricoCondominioAgua .getNumeroConsumoFaturadoMes().intValue()
	 * - somaNumeroConsumoFaturadoMesAgua; // Negativa // Caso o consumo de água
	 * a ser rateado seja menor ou igual a zero e o // número do consumo
	 * faturado no mês seja superior a soma dos consumos // mínimos if
	 * (consumoAguaSerRateado <= 0 &&
	 * consumoHistoricoCondominioAgua.getNumeroConsumoFaturadoMes() .intValue()
	 * > somaConsumosMinimos) { // Realização de cálculo BigDecimal numerador =
	 * sistemaParametro .getPercentualToleranciaRateio().multiply( new
	 * BigDecimal(consumoHistoricoCondominioAgua
	 * .getNumeroConsumoFaturadoMes().toString())); BigDecimal resultado =
	 * numerador.divide(new BigDecimal("100"), BigDecimal.ROUND_UP); // Caso o
	 * consumo de água a ser rateado seja maior que o resultado // do cálculo if
	 * (consumoAguaSerRateado > resultado.intValue()) { // Caso a quantidade de
	 * economias não medidas seja diferente de // zero if
	 * (quantidadeEconomiasNaoMedidasAgua != 0) { // Determinar rateio de água
	 * do não medido determinarRateioAguaNaoMedido(consumoAguaSerRateado,
	 * quantidadeEconomiasNaoMedidasAgua, colecaoConsumoHistoricoAgua,
	 * consumoHistoricoCondominioAgua); } else if
	 * (quantidadeEconomiasMedidasAgua != 0) { // Determinar rateio de água
	 * medido determinarRateioAguaMedido(consumoAguaSerRateado,
	 * quantidadeEconomiasMedidasAgua, sistemaParametro,
	 * colecaoConsumoHistoricoAgua, consumoHistoricoCondominioAgua); } } } }
	 */

	/**
	 * Determinar Rateio de Água Não Medido
	 * 
	 * @param consumoAguaSerRateado
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasNaoMedidasAgua
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoAgua
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominio
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioAguaNaoMedido(int consumoAguaSerRateado,
	 * int quantidadeEconomiasNaoMedidasAgua, Collection
	 * colecaoConsumoHistoricoAgua, ConsumoHistorico consumoHistoricoCondominio)
	 * throws ControladorException { // Obtém o consumo de água a ser rateado
	 * por economia double consumoAguaSerRateadoEconomia =
	 * (consumoAguaSerRateado / quantidadeEconomiasNaoMedidasAgua); // Realiza o
	 * arredondamento do cálculo acima BigDecimal
	 * arredondamentoConsumoAguaSerRateadoEconomia = new BigDecimal(
	 * consumoAguaSerRateadoEconomia);
	 * 
	 * arredondamentoConsumoAguaSerRateadoEconomia =
	 * arredondamentoConsumoAguaSerRateadoEconomia .setScale(0,
	 * BigDecimal.ROUND_UP); // Caso o consumo a ser rateado por economia seja
	 * maior que zero if (arredondamentoConsumoAguaSerRateadoEconomia.intValue()
	 * > 0) {
	 * 
	 * Iterator colecaoConsumoHistoricoAguaIterator =
	 * colecaoConsumoHistoricoAgua .iterator(); // Laço nos imóveis vinculados
	 * ao imóvel condomínio while
	 * (colecaoConsumoHistoricoAguaIterator.hasNext()) {
	 * 
	 * ConsumoHistorico consumoHistorico = (ConsumoHistorico)
	 * colecaoConsumoHistoricoAguaIterator .next(); // Para cada imóvel
	 * vinculado ao imóvel condomínio que seja // ligado ou cortado de água e
	 * não medido na ligação de água if
	 * ((consumoHistorico.getImovel().getLigacaoAgua()
	 * .getHidrometroInstalacaoHistorico().getId() == null) &&
	 * (consumoHistorico.getImovel() .getLigacaoAguaSituacao().getId() ==
	 * LigacaoAguaSituacao.LIGADO || consumoHistorico
	 * .getImovel().getLigacaoAguaSituacao().getId() ==
	 * LigacaoAguaSituacao.CORTADO)) { // Obtém o número do consumo rateio int
	 * numeroConsumoRateio = arredondamentoConsumoAguaSerRateadoEconomia
	 * .intValue() consumoHistorico.getImovel()
	 * .getQuantidadeEconomias().intValue(); // Seta o consumo histórico
	 * consumoHistorico.setConsumoRateio(new Integer( numeroConsumoRateio));
	 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() +
	 * consumoHistorico.getConsumoRateio() .intValue())); consumoHistorico
	 * .setConsumoHistoricoCondominio(consumoHistoricoCondominio); // Atualiza o
	 * consumo histórico try { repositorioUtil.atualizar(consumoHistorico); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param consumoAguaSerRateado
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasMedidasAgua
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoAgua
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominio
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioAguaMedido(int consumoAguaSerRateado, int
	 * quantidadeEconomiasMedidasAgua, SistemaParametro sistemaParametro,
	 * Collection colecaoConsumoHistoricoAgua, ConsumoHistorico
	 * consumoHistoricoCondominio) throws ControladorException { // Obtém o
	 * consumo de água a ser rateado por economia double
	 * consumoAguaSerRateadoEconomia = consumoAguaSerRateado /
	 * quantidadeEconomiasMedidasAgua; // Realiza o arredondamento do cálculo
	 * acima BigDecimal arredondamentoConsumoAguaSerRateadoEconomia = new
	 * BigDecimal( consumoAguaSerRateadoEconomia); // Obtém o consumo de água a
	 * ser rateado por economia arredondado
	 * arredondamentoConsumoAguaSerRateadoEconomia =
	 * arredondamentoConsumoAguaSerRateadoEconomia .setScale(0,
	 * BigDecimal.ROUND_UP); // Caso o consumo de água a ser rateado por
	 * economia seja inferior ao // decremento máximo de consumo por economia if
	 * (arredondamentoConsumoAguaSerRateadoEconomia.intValue() <
	 * (sistemaParametro .getDecrementoMaximoConsumoRateio().intValue() * -1)) {
	 * 
	 * arredondamentoConsumoAguaSerRateadoEconomia =
	 * arredondamentoConsumoAguaSerRateadoEconomia .multiply(new
	 * BigDecimal("-1")); } else if
	 * (arredondamentoConsumoAguaSerRateadoEconomia.intValue() >
	 * sistemaParametro .getDecrementoMaximoConsumoRateio().intValue()) {
	 * 
	 * arredondamentoConsumoAguaSerRateadoEconomia = new BigDecimal(
	 * sistemaParametro.getDecrementoMaximoConsumoRateio() .toString()); }
	 * 
	 * Iterator colecaoConsumoHistoricoAguaIterator =
	 * colecaoConsumoHistoricoAgua .iterator(); // Laço nos imóveis vinculados
	 * ao imóvel condomínio while
	 * (colecaoConsumoHistoricoAguaIterator.hasNext()) {
	 * 
	 * ConsumoHistorico consumoHistorico = (ConsumoHistorico)
	 * colecaoConsumoHistoricoAguaIterator .next(); // Para cada imóvel
	 * vinculado ao imóvel condomínio que seja ligado // ou cortado de água e
	 * não medido na ligação de água if
	 * ((consumoHistorico.getImovel().getLigacaoAgua()
	 * .getHidrometroInstalacaoHistorico().getId() != null) &&
	 * (consumoHistorico.getImovel().getLigacaoAguaSituacao() .getId() ==
	 * LigacaoAguaSituacao.LIGADO || consumoHistorico
	 * .getImovel().getLigacaoAguaSituacao().getId() ==
	 * LigacaoAguaSituacao.CORTADO)) { // Obtém o número do consumo rateio int
	 * numeroConsumoRateio = arredondamentoConsumoAguaSerRateadoEconomia
	 * .intValue() consumoHistorico.getImovel().getQuantidadeEconomias()
	 * .intValue(); // Caso o consumo faturado mês seja menor que o consumo
	 * rateio // multiplicado por -1 if
	 * (consumoHistorico.getNumeroConsumoFaturadoMes().intValue() <
	 * (consumoHistorico .getConsumoRateio().intValue() * -1)) { // Seta o
	 * consumo rateio consumoHistorico.setConsumoRateio(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() -1)); } //
	 * Seta o consumo faturado mês
	 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() +
	 * consumoHistorico.getConsumoRateio() .intValue())); // Seta o consumo
	 * imóvel condomínio consumoHistorico
	 * .setConsumoHistoricoCondominio(consumoHistoricoCondominio); // Atualiza o
	 * consumo histórico try { repositorioUtil.atualizar(consumoHistorico); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovelCondominio
	 *            Descrição do parâmetro
	 * @param somaNumeroConsumoFaturadoMesEsgoto
	 *            Descrição do parâmetro
	 * @param somaConsumosMinimos
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasMedidasEsgoto
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasNaoMedidasEsgoto
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoEsgoto
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominioEsgoto
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioEsgoto(Imovel imovelCondominio, int
	 * somaNumeroConsumoFaturadoMesEsgoto, int somaConsumosMinimos,
	 * SistemaParametro sistemaParametro, int quantidadeEconomiasMedidasEsgoto,
	 * int quantidadeEconomiasNaoMedidasEsgoto, Collection
	 * colecaoConsumoHistoricoEsgoto, ConsumoHistorico
	 * consumoHistoricoCondominioEsgoto) throws ControladorException { // Obtém
	 * o consumo a ser rateado int consumoEsgotoSerRateado =
	 * consumoHistoricoCondominioEsgoto
	 * .getNumeroConsumoFaturadoMes().intValue() -
	 * somaNumeroConsumoFaturadoMesEsgoto; // Negativa // Caso o consumo de
	 * esgoto a ser rateado seja menor ou igual a zero e o // número do consumo
	 * faturado no mês seja superior a soma dos consumos // mínimos if
	 * (consumoEsgotoSerRateado <= 0 && consumoHistoricoCondominioEsgoto
	 * .getNumeroConsumoFaturadoMes().intValue() > somaConsumosMinimos) { //
	 * Realização de cálculo BigDecimal numerador = sistemaParametro
	 * .getPercentualToleranciaRateio().multiply( new
	 * BigDecimal(consumoHistoricoCondominioEsgoto
	 * .getNumeroConsumoFaturadoMes().toString())); BigDecimal resultado =
	 * numerador.divide(new BigDecimal("100"), BigDecimal.ROUND_UP); // Caso o
	 * consumo de água a ser rateado seja maior que o resultado // do cálculo if
	 * (consumoEsgotoSerRateado > resultado.intValue()) { // Caso a quantidade
	 * de economias não medidas seja diferente de // zero if
	 * (quantidadeEconomiasNaoMedidasEsgoto != 0) { // Determinar rateio de água
	 * do não medido determinarRateioEsgotoNaoMedido(consumoEsgotoSerRateado,
	 * quantidadeEconomiasNaoMedidasEsgoto, colecaoConsumoHistoricoEsgoto,
	 * consumoHistoricoCondominioEsgoto); } else if
	 * (quantidadeEconomiasMedidasEsgoto != 0) { // Determinar rateio de água
	 * medido determinarRateioEsgotoMedido(consumoEsgotoSerRateado,
	 * quantidadeEconomiasMedidasEsgoto, sistemaParametro,
	 * colecaoConsumoHistoricoEsgoto, consumoHistoricoCondominioEsgoto); } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param consumoEsgotoSerRateado
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasNaoMedidasEsgoto
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoEsgoto
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominio
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioEsgotoNaoMedido(int
	 * consumoEsgotoSerRateado, int quantidadeEconomiasNaoMedidasEsgoto,
	 * Collection colecaoConsumoHistoricoEsgoto, ConsumoHistorico
	 * consumoHistoricoCondominio) throws ControladorException { // Obtém o
	 * consumo de água a ser rateado por economia double
	 * consumoEsgotoSerRateadoEconomia = (consumoEsgotoSerRateado /
	 * quantidadeEconomiasNaoMedidasEsgoto); // Realiza o arredondamento do
	 * cálculo acima BigDecimal arredondamentoConsumoEsgotoSerRateadoEconomia =
	 * new BigDecimal( consumoEsgotoSerRateadoEconomia);
	 * 
	 * arredondamentoConsumoEsgotoSerRateadoEconomia =
	 * arredondamentoConsumoEsgotoSerRateadoEconomia .setScale(0,
	 * BigDecimal.ROUND_UP); // Caso o consumo a ser rateado por economia seja
	 * maior que zero if
	 * (arredondamentoConsumoEsgotoSerRateadoEconomia.intValue() > 0) {
	 * 
	 * Iterator colecaoConsumoHistoricoEsgotoIterator =
	 * colecaoConsumoHistoricoEsgoto .iterator(); // Laço nos imóveis vinculados
	 * ao imóvel condomínio while
	 * (colecaoConsumoHistoricoEsgotoIterator.hasNext()) {
	 * 
	 * ConsumoHistorico consumoHistorico = (ConsumoHistorico)
	 * colecaoConsumoHistoricoEsgotoIterator .next(); // Para cada imóvel
	 * vinculado ao imóvel condomínio que seja // ligado ou cortado de água e
	 * não medido na ligação de água if ((consumoHistorico.getImovel()
	 * .getHidrometroInstalacaoHistorico().getId() == null) &&
	 * (consumoHistorico.getImovel() .getLigacaoEsgotoSituacao().getId() ==
	 * LigacaoEsgotoSituacao.LIGADO)) { // Obtém o número do consumo rateio int
	 * numeroConsumoRateio = arredondamentoConsumoEsgotoSerRateadoEconomia
	 * .intValue() consumoHistorico.getImovel()
	 * .getQuantidadeEconomias().intValue(); // Seta o consumo histórico
	 * consumoHistorico.setConsumoRateio(new Integer( numeroConsumoRateio));
	 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() +
	 * consumoHistorico.getConsumoRateio() .intValue())); consumoHistorico
	 * .setConsumoHistoricoCondominio(consumoHistoricoCondominio); // Atualiza o
	 * consumo histórico try { repositorioUtil.atualizar(consumoHistorico); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param consumoEsgotoSerRateado
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasMedidasEsgoto
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoEsgoto
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominio
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioEsgotoMedido(int consumoEsgotoSerRateado,
	 * int quantidadeEconomiasMedidasEsgoto, SistemaParametro sistemaParametro,
	 * Collection colecaoConsumoHistoricoEsgoto, ConsumoHistorico
	 * consumoHistoricoCondominio) throws ControladorException { // Obtém o
	 * consumo de esgoto a ser rateado por economia double
	 * consumoEsgotoSerRateadoEconomia = consumoEsgotoSerRateado /
	 * quantidadeEconomiasMedidasEsgoto; // Realiza o arredondamento do cálculo
	 * acima BigDecimal arredondamentoConsumoEsgotoSerRateadoEconomia = new
	 * BigDecimal( consumoEsgotoSerRateadoEconomia);
	 * 
	 * arredondamentoConsumoEsgotoSerRateadoEconomia =
	 * arredondamentoConsumoEsgotoSerRateadoEconomia .setScale(0,
	 * BigDecimal.ROUND_UP); // Caso o consumo de esgoto a ser rateado por
	 * economia seja maior que // zero if
	 * (arredondamentoConsumoEsgotoSerRateadoEconomia.intValue() > 0) { // Caso
	 * o consumo esgoto rateado por economia seja maior que o // incremento
	 * máximo do do consumo rateio if
	 * (arredondamentoConsumoEsgotoSerRateadoEconomia.intValue() >
	 * sistemaParametro .getIncrementoMaximoConsumoRateio().intValue()) {
	 * 
	 * arredondamentoConsumoEsgotoSerRateadoEconomia = new BigDecimal(
	 * sistemaParametro.getIncrementoMaximoConsumoRateio() .toString()); }
	 * 
	 * Iterator colecaoConsumoHistoricoEsgotoIterator =
	 * colecaoConsumoHistoricoEsgoto .iterator(); // Laço nos imóveis vinculados
	 * ao imóvel condomínio while
	 * (colecaoConsumoHistoricoEsgotoIterator.hasNext()) {
	 * 
	 * ConsumoHistorico consumoHistorico = (ConsumoHistorico)
	 * colecaoConsumoHistoricoEsgotoIterator .next(); // Para cada imóvel
	 * vinculado ao imóvel condomínio que seja // ligado e medido de poço if
	 * ((consumoHistorico.getImovel()
	 * .getHidrometroInstalacaoHistorico().getId() != null) &&
	 * (consumoHistorico.getImovel() .getLigacaoEsgotoSituacao().getId() ==
	 * LigacaoEsgotoSituacao.LIGADO)) { // Obtém o número do consumo rateio int
	 * numeroConsumoRateio = arredondamentoConsumoEsgotoSerRateadoEconomia
	 * .intValue() consumoHistorico.getImovel()
	 * .getQuantidadeEconomias().intValue(); // Caso o consumo faturado mês seja
	 * menor que o consumo // rateio multiplicado por -1 if
	 * (consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() <
	 * (consumoHistorico.getConsumoRateio() .intValue() * -1)) { // Seta o
	 * consumo rateio consumoHistorico.setConsumoRateio(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() -1)); } //
	 * Seta o consumo faturado mês
	 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() +
	 * consumoHistorico.getConsumoRateio() .intValue())); // Seta o consumo
	 * imóvel condomínio consumoHistorico
	 * .setConsumoHistoricoCondominio(consumoHistoricoCondominio); // Atualiza o
	 * consumo histórico try { repositorioUtil.atualizar(consumoHistorico); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param hidrometro
	 *            Descrição do parâmetro
	 * @param fixo
	 *            Descrição do parâmetro
	 * @param faixaInicial
	 *            Descrição do parâmetro
	 * @param faixaFinal
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public void inserirHidrometro(Hidrometro hidrometro, String fixo,
			Integer faixaInicial, Integer faixaFinal)
			throws ControladorException {

		// Obtém o intervalo da faixa final - inicial + 1
		int quantidade = (faixaFinal.intValue() - faixaInicial.intValue()) + 1;

		Collection colecaoHidrometro = null;

		colecaoHidrometro = pesquisarNumeroHidrometroFaixa(fixo,
				faixaInicial.toString(), faixaFinal.toString());

		if (colecaoHidrometro != null && !colecaoHidrometro.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.ja.existem.hidrometros.numeracao.dentro.faixa.informada",
					null, new Integer(colecaoHidrometro.size()).toString());
		}

		for (int i = 0; i < quantidade; i++) {

			String intervalo = (new Integer(faixaInicial.intValue() + i)).toString();

			hidrometro.setNumero(fixo + Util.adicionarZerosEsquedaNumero(6, intervalo));

			try {
				repositorioUtil.inserir(hidrometro);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

		}
	}

	/**
	 * Insere a marca de um hidrômetro
	 * 
	 * @param hidrometroMarca
	 *            Marca de hidrometro a ser inserida
	 * @return código da marca que foi inserida
	 * @throws ControladorException
	 */
	public Integer inserirHidrometroMarca(HidrometroMarca hidrometroMarca,
			Usuario usuarioLogado) throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_INSERIR_MARCA_HIDROMETRO,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_INSERIR_MARCA_HIDROMETRO);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		// [FS-0002] - Verificar existencia de hidrômetro
		Collection colFiltros;
		FiltroHidrometroMarca filtro = new FiltroHidrometroMarca();
		filtro.adicionarParametro(new ParametroSimples(
				FiltroHidrometroMarca.DESCRICAO, hidrometroMarca.getDescricao()));
		colFiltros = getControladorUtil().pesquisar(filtro,
				hidrometroMarca.getClass().getName());

		if (colFiltros != null && colFiltros.size() > 0) {
			throw new ControladorException("atencao.hidrometro_marca.existente");
		}

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		hidrometroMarca.setOperacaoEfetuada(operacaoEfetuada);
		hidrometroMarca.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(hidrometroMarca);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		return (Integer) this.getControladorUtil().inserir(hidrometroMarca);
	}

	@SuppressWarnings("rawtypes")
	public Collection pesquisarNumeroHidrometroFaixa(String fixo,
			String faixaInicial, String faixaFinal) throws ControladorException {
		try {
			return repositorioMicromedicao.pesquisarNumeroHidrometroFaixa( (fixo + faixaInicial), (fixo + faixaFinal));
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param fixo
	 *            Descrição do parâmetro
	 * @param faixaInicial
	 *            Descrição do parâmetro
	 * @param faixaFinal
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroFaixaBatch(String fixo,
			String faixaInicial, String faixaFinal, Integer qtd)
			throws ControladorException {
		try {

			String numeroFormatadoInicial = "";
			String numeroFormatadoFinal = "";

			numeroFormatadoInicial = Util.adicionarZerosEsquedaNumero(6,
					faixaInicial);
			numeroFormatadoFinal = Util.adicionarZerosEsquedaNumero(6,
					faixaFinal);

			return repositorioMicromedicao.pesquisarNumeroHidrometroFaixaBatch(
					(fixo + numeroFormatadoInicial),
					(fixo + numeroFormatadoFinal), qtd);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Pesquisa uma coleção de hidrômetros de acordo com fixo, faixa inicial e
	 * faixa final
	 * 
	 * @param fixo
	 *            Descrição do parâmetro
	 * @param faixaInicial
	 *            Descrição do parâmetro
	 * @param faixaFinal
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroFaixaRelatorio(String fixo,
			String faixaInicial, String faixaFinal) throws ControladorException {
		try {

			String numeroFormatadoInicial = "";
			String numeroFormatadoFinal = "";

			numeroFormatadoInicial = Util.adicionarZerosEsquedaNumero(6,
					faixaInicial);
			numeroFormatadoFinal = Util.adicionarZerosEsquedaNumero(6,
					faixaFinal);

			return repositorioMicromedicao
					.pesquisarNumeroHidrometroFaixaRelatorio(
							(fixo + numeroFormatadoInicial),
							(fixo + numeroFormatadoFinal));
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param fixo
	 *            Descrição do parâmetro
	 * @param faixaInicial
	 *            Descrição do parâmetro
	 * @param faixaFinal
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroFaixaPaginacao(String fixo,
			String faixaInicial, String faixaFinal, Integer numeroPagina)
			throws ControladorException {
		try {

			String numeroFormatadoInicial = "";
			String numeroFormatadoFinal = "";

			numeroFormatadoInicial = Util.adicionarZerosEsquedaNumero(6,
					faixaInicial);
			numeroFormatadoFinal = Util.adicionarZerosEsquedaNumero(6,
					faixaFinal);

			return repositorioMicromedicao
					.pesquisarNumeroHidrometroFaixaPaginacao(
							(fixo + numeroFormatadoInicial),
							(fixo + numeroFormatadoFinal), numeroPagina);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param fixo
	 *            Descrição do parâmetro
	 * @param faixaInicial
	 *            Descrição do parâmetro
	 * @param faixaFinal
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroFaixaComLimite(String fixo,
			String faixaInicial, String faixaFinal) throws ControladorException {
		try {

			String zerosInicial = "";
			String zerosFinal = "";

			zerosInicial = Util.adicionarZerosEsquedaNumero(6, faixaInicial);
			if (faixaFinal == null || faixaFinal.equals("")) {
				zerosFinal = "999999";
			} else {
				zerosFinal = Util.adicionarZerosEsquedaNumero(6, faixaFinal);
			}

			return repositorioMicromedicao
					.pesquisarNumeroHidrometroFaixaComLimite(
							(fixo + zerosInicial), (fixo + zerosFinal));
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Description of the Method
	 * 
	 * @param hidrometro
	 *            Description of the Parameter
	 * @throws ControladorException
	 */
	public void atualizarHidrometro(Hidrometro hidrometro)
			throws ControladorException {

		FiltroHidrometro filtroHidrometro = new FiltroHidrometro();

		try {
			// -------------Parte que atualiza um logradouro na
			// base----------------------
			filtroHidrometro
					.adicionarParametro(new ParametroSimples(
							FiltroHidrometro.NUMERO_HIDROMETRO, hidrometro
									.getNumero()));

			Collection hidrometrosPesquisados = repositorioUtil.pesquisar(
					filtroHidrometro, Hidrometro.class.getName());

			if (hidrometrosPesquisados != null
					&& !hidrometrosPesquisados.isEmpty()) {
				Hidrometro hidrometroPesquisado = (Hidrometro) ((List) hidrometrosPesquisados)
						.get(0);

				if (!hidrometro.getId().equals(hidrometroPesquisado.getId())) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.hidrometro_ja_existente", null,
							hidrometro.getNumero());
				}
			}

			filtroHidrometro.limparListaParametros();
			// Seta o filtro para buscar o hidrometro na base
			filtroHidrometro.adicionarParametro(new ParametroSimples(
					FiltroHidrometro.ID, hidrometro.getId()));

			// Procura o hidrometro na base
			Hidrometro hidrometroNaBase = (Hidrometro) ((List) (repositorioUtil
					.pesquisar(filtroHidrometro, Hidrometro.class.getName())))
					.get(0);

			// Verificar se o hidrometro já foi atualizado por outro usuário
			// durante
			// esta atualização
			if (hidrometroNaBase.getUltimaAlteracao().after(
					hidrometro.getUltimaAlteracao())) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

			// Atualiza a data de última alteração
			hidrometro.setUltimaAlteracao(new Date());

			// Atualiza o hidrometro
			repositorioUtil.atualizar(hidrometro);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Description of the Method
	 * 
	 * @param hidrometros
	 *            Description of the Parameter
	 * @param hidrometroAtualizado
	 *            Description of the Parameter
	 * @throws ControladorException
	 */
	public void atualizarConjuntoHidrometro(String fixo, String inicialFixo,
			String finalFixo, Hidrometro hidrometroAtualizado,
			Usuario usuarioLogado) throws ControladorException {

		Collection hidrometros = this.pesquisarNumeroHidrometroFaixa(fixo,
				inicialFixo, finalFixo);

		Iterator hidrometroIterator = hidrometros.iterator();

		while (hidrometroIterator.hasNext()) {
			try {
				Hidrometro hidrometro = (Hidrometro) hidrometroIterator.next();

				// seta os valoes do hidrometro atualizado que veio do
				// hidrometro_atualizar_conjunto
				hidrometro.setHidrometroClasseMetrologica(hidrometroAtualizado
						.getHidrometroClasseMetrologica());
				hidrometro.setHidrometroMarca(hidrometroAtualizado
						.getHidrometroMarca());
				hidrometro.setHidrometroCapacidade(hidrometroAtualizado
						.getHidrometroCapacidade());
				hidrometro.setHidrometroDiametro(hidrometroAtualizado
						.getHidrometroDiametro());
				hidrometro.setHidrometroTipo(hidrometroAtualizado
						.getHidrometroTipo());
				hidrometro.setHidrometroRelojoaria(hidrometroAtualizado
						.getHidrometroRelojoaria());
				hidrometro.setDataAquisicao(hidrometroAtualizado
						.getDataAquisicao());
				hidrometro.setAnoFabricacao(hidrometroAtualizado
						.getAnoFabricacao());
				hidrometro.setIndicadorMacromedidor(hidrometroAtualizado
						.getIndicadorMacromedidor());
				hidrometro.setNumeroDigitosLeitura(hidrometroAtualizado
						.getNumeroDigitosLeitura());
				hidrometro.setVazaoTransicao(hidrometroAtualizado
						.getVazaoTransicao());
				hidrometro.setVazaoNominal(hidrometroAtualizado
						.getVazaoNominal());
				hidrometro
						.setVazaoMinima(hidrometroAtualizado.getVazaoMinima());
				hidrometro.setNotaFiscal(hidrometroAtualizado.getNotaFiscal());
				hidrometro.setTempoGarantiaAnos(hidrometroAtualizado
						.getTempoGarantiaAnos());

				this.repositorioUtil.atualizar(hidrometro);

			} catch (ErroRepositorioException e) {
				throw new ControladorException("Erro o repositorio");
			}
		}

	}

	/**
	 * Description of the Method
	 * 
	 * @param hidrometros
	 *            Description of the Parameter
	 * @param hidrometroAtualizado
	 *            Description of the Parameter
	 * @throws ControladorException
	 */
	public void atualizarConjuntoHidrometroBatch(String fixo,
			String inicialFixo, String finalFixo,
			Hidrometro hidrometroAtualizado, Usuario usuarioLogado,
			int idFuncionalidadeIniciada, int indice)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		Collection hidrometros = this.pesquisarNumeroHidrometroFaixaBatch(fixo,
				inicialFixo, finalFixo, indice);

		Iterator hidrometroIterator = hidrometros.iterator();

		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.HIDROMETRO, indice + 1);

		while (hidrometroIterator.hasNext()) {

			Hidrometro hidrometro = (Hidrometro) hidrometroIterator.next();

			try {
				// seta os valoes do hidrometro atualizado que veio do
				// hidrometro_atualizar_conjunto
				hidrometro.setHidrometroClasseMetrologica(hidrometroAtualizado
						.getHidrometroClasseMetrologica());
				hidrometro.setHidrometroMarca(hidrometroAtualizado
						.getHidrometroMarca());
				hidrometro.setHidrometroCapacidade(hidrometroAtualizado
						.getHidrometroCapacidade());
				hidrometro.setHidrometroDiametro(hidrometroAtualizado
						.getHidrometroDiametro());
				hidrometro.setHidrometroTipo(hidrometroAtualizado
						.getHidrometroTipo());
				hidrometro.setHidrometroRelojoaria(hidrometroAtualizado
						.getHidrometroRelojoaria());
				hidrometro.setDataAquisicao(hidrometroAtualizado
						.getDataAquisicao());
				hidrometro.setAnoFabricacao(hidrometroAtualizado
						.getAnoFabricacao());
				hidrometro.setIndicadorMacromedidor(hidrometroAtualizado
						.getIndicadorMacromedidor());
				hidrometro.setNumeroDigitosLeitura(hidrometroAtualizado
						.getNumeroDigitosLeitura());
				hidrometro.setVazaoTransicao(hidrometroAtualizado
						.getVazaoTransicao());
				hidrometro.setVazaoNominal(hidrometroAtualizado
						.getVazaoNominal());
				hidrometro
						.setVazaoMinima(hidrometroAtualizado.getVazaoMinima());
				hidrometro.setNotaFiscal(hidrometroAtualizado.getNotaFiscal());
				hidrometro.setTempoGarantiaAnos(hidrometroAtualizado
						.getTempoGarantiaAnos());

				this.repositorioUtil.atualizar(hidrometro);

			} catch (Exception e) {
				// Este catch serve para interceptar
				// qualquer exceção que o processo batch
				// venha a lançar e garantir que a unidade
				// de processamento do batch será atualizada
				// com o erro ocorrido
				e.printStackTrace();

				getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
						idUnidadeIniciada, true);
			}
		}
		getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
				idUnidadeIniciada, false);

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param colecaoHidrometro
	 *            Descrição do parâmetro
	 * @param ids
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection obterColecaoObjetosSelecionados(
			Collection colecaoHidrometro, String[] ids)
			throws ControladorException {

		Collection retorno = null;

		Collection colecaoObjetosSelecionados = new ArrayList();

		// Verifica se foram selecionados hidrômetros
		if (ids != null && ids.length != 0) {

			// Criação de objetos
			Hidrometro hidrometro = null;

			for (int i = 0; i < ids.length; i++) {
				// atribui a variável "id" o código do hidrômetro
				int id = Integer.parseInt(ids[i]);

				Iterator iteratorColecaoHidrometro = colecaoHidrometro
						.iterator();

				while (iteratorColecaoHidrometro.hasNext()) {

					// Obtém o hidrômetro da coleção
					hidrometro = (Hidrometro) iteratorColecaoHidrometro.next();

					// Verifica se o código selecionado possui na coleção
					if (id == hidrometro.getId().intValue()) {

						colecaoObjetosSelecionados.add(hidrometro);
					}
				}

			}

		} else {
			// Caso não tenha(m) selecionado(s) hidrômetros gera exceção
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.registros.nao_selecionados", null);
		}

		retorno = colecaoObjetosSelecionados;

		return retorno;
	}

	/**
	 * < <Seleciona os objetos existentes na coleção de acordo com os ids
	 * informados e verifica se o local de armazenagem são os mesmos para os
	 * selecionados, retorna TRUE (vedadeiro) caso o local de armazenagem sejam
	 * os mesmos ou retorna FALSE (falso) caso o local de armazenagem sejam
	 * diferentes>>
	 * 
	 * @param colecaoHidrometro
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 */
	public String verificarLocalArmazenagemSituacao(Collection colecaoHidrometro) {

		String retorno = "valido";

		// Criação de objetos
		Hidrometro hidrometro = null;

		Integer idLocalArmazenagem = null;

		Iterator iteratorColecaoHidrometro = colecaoHidrometro.iterator();

		while (iteratorColecaoHidrometro.hasNext()) {
			// Obtém o hidrômetro da coleção
			hidrometro = (Hidrometro) iteratorColecaoHidrometro.next();

			if (hidrometro.getHidrometroLocalArmazenagem() != null) {

				if (idLocalArmazenagem == null) {

					// Armazena o id do local de armazenagem do 1º hidrômetro
					// encontrado
					idLocalArmazenagem = hidrometro
							.getHidrometroLocalArmazenagem().getId();

					// Caso seja diferentes retorna falso
				} else if (idLocalArmazenagem.intValue() != hidrometro
						.getHidrometroLocalArmazenagem().getId().intValue()) {

					retorno = "localArmazenagemDiferente";
					break;
				}
			}
			// Verifica se o hidrometro selecionado está com a situação de
			// instalado
			if (hidrometro.getHidrometroSituacao().getId()
					.equals(HidrometroSituacao.INSTALADO)) {
				retorno = "hidrometroInstalado";
				break;
			}
		}

		return retorno;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param colecaoHidrometro
	 *            Descrição do parâmetro
	 * @param data
	 *            Descrição do parâmetro
	 * @param hora
	 *            Descrição do parâmetro
	 * @param idLocalArmazenagemDestino
	 *            Descrição do parâmetro
	 * @param idMotivoMovimentacao
	 *            Descrição do parâmetro
	 * @param parecer
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public void inserirAtualizarMovimentacaoHidrometroIds(
			Collection colecaoHidrometro, String data, String hora,
			String idLocalArmazenagemDestino, String idMotivoMovimentacao,
			String parecer, Usuario usuario) throws ControladorException {

		try {
			HidrometroMovimentacao hidrometroMovimentacao = new HidrometroMovimentacao();

			SimpleDateFormat formatoData = new SimpleDateFormat("dd/MM/yyyy");
			SimpleDateFormat formatoHora = new SimpleDateFormat("HH:mm");

			Date dataMovimentacao = null;
			Date horaMovimentacao = null;
			try {
				dataMovimentacao = formatoData.parse(data);
				horaMovimentacao = formatoHora.parse(hora);
			} catch (ParseException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.data.hora.invalido",
						null);
			}

			// Seta a data de movimentação
			hidrometroMovimentacao.setData(dataMovimentacao);
			hidrometroMovimentacao.setHora(horaMovimentacao);
			// Seta o local de armazenagem destino
			FiltroHidrometroLocalArmazenagem filtroHidrometroLocalArmazenagem = new FiltroHidrometroLocalArmazenagem();
			filtroHidrometroLocalArmazenagem
					.adicionarParametro(new ParametroSimples(
							FiltroHidrometroLocalArmazenagem.ID,
							idLocalArmazenagemDestino));

			Collection colecaoHidrometroLocalArmazenagem = getControladorUtil()
					.pesquisar(filtroHidrometroLocalArmazenagem,
							HidrometroLocalArmazenagem.class.getName());

			HidrometroLocalArmazenagem hidrometroLocalArmazenagemDestino = (HidrometroLocalArmazenagem) Util
					.retonarObjetoDeColecao(colecaoHidrometroLocalArmazenagem);

			hidrometroMovimentacao
					.setHidrometroLocalArmazenagemDestino(hidrometroLocalArmazenagemDestino);

			// Seta o motivo da movimentacao
			HidrometroMotivoMovimentacao hidrometroMotivoMovimentacao = new HidrometroMotivoMovimentacao();

			hidrometroMotivoMovimentacao
					.setId(new Integer(idMotivoMovimentacao));
			hidrometroMovimentacao
					.setHidrometroMotivoMovimentacao(hidrometroMotivoMovimentacao);

			// Seta o parecer
			hidrometroMovimentacao.setParecer(parecer);
			// Seta a data e hora de última alteração
			hidrometroMovimentacao.setUltimaAlteracao(new Date());

			// Seta o funcionário
			hidrometroMovimentacao.setUsuario(usuario);

			Hidrometro dadosHidrometroParaMovimentacao = (Hidrometro) ((List) colecaoHidrometro)
					.get(0);

			// Seta o local de armazenagem origem
			hidrometroMovimentacao
					.setHidrometroLocalArmazenagemOrigem(dadosHidrometroParaMovimentacao
							.getHidrometroLocalArmazenagem());

			// Inseri a movimentção do hidrômetro
			Integer idHidrometroMovimentacao = (Integer) repositorioUtil
					.inserir(hidrometroMovimentacao);

			hidrometroMovimentacao.setId(idHidrometroMovimentacao);

			// Criação de objetos
			Hidrometro hidrometro = null;

			Iterator iteratorColecaoHidrometro = colecaoHidrometro.iterator();

			while (iteratorColecaoHidrometro.hasNext()) {

				// Obtém o hidrômetro da coleção
				hidrometro = (Hidrometro) iteratorColecaoHidrometro.next();

				// Verifica se está movimentando o hidrômetro para o mesmo local
				// de armazenagem
				if (hidrometro.getHidrometroLocalArmazenagem().getId()
						.intValue() == new Integer(idLocalArmazenagemDestino)
						.intValue()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.nao.possivel.movimentar.hidrometro.mesmo.local.armazenagem",
							null);
				}

				// Procura hidrometro na base
				FiltroHidrometro filtroHidrometro = new FiltroHidrometro();

				filtroHidrometro.adicionarParametro((new ParametroSimples(
						FiltroHidrometro.ID, hidrometro.getId())));

				Hidrometro hidrometroNaBase = (Hidrometro) ((List) (getControladorUtil()
						.pesquisar(filtroHidrometro, Hidrometro.class.getName())))
						.get(0);

				// Verificar se categoria já foi atualizada por outro usuário
				// durante esta atualização
				if (hidrometroNaBase.getUltimaAlteracao().after(
						hidrometro.getUltimaAlteracao())) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.atualizacao.timestamp");
				}

				HidrometroMovimentado hidrometroMovimentado = new HidrometroMovimentado(
						new HidrometroMovimentadoPK(idHidrometroMovimentacao,
								hidrometro.getId()));

				hidrometroMovimentado
						.setHidrometroMovimentacao(hidrometroMovimentacao);

				repositorioUtil.inserir(hidrometroMovimentado);

				// Seta o hidrometro para o novo local de armazenagem
				hidrometro
						.setHidrometroLocalArmazenagem(hidrometroLocalArmazenagemDestino);

				HidrometroSituacao hidrometroSituacao = new HidrometroSituacao();

				if (hidrometroLocalArmazenagemDestino.getIndicadorOficina()
						.equals(HidrometroLocalArmazenagem.INDICADOR_OFICINA)) {
					hidrometroSituacao.setId(HidrometroSituacao.EM_MANUTENCAO);
				} else {
					hidrometroSituacao.setId(HidrometroSituacao.DISPONIVEL);
				}

				hidrometro.setHidrometroSituacao(hidrometroSituacao);
				hidrometro.setUltimaAlteracao(new Date());

				// Atualiza o hidrômetro
				repositorioUtil.atualizar(hidrometro);
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método utilizado para apoio na realização de testes do caso de uso
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 */
	public void executarImovelTestesMedicaoConsumo(
			FaturamentoGrupo faturamentoGrupo, Imovel imovel)
			throws ControladorException {
		try {

			// Criação das coleções
			ImovelTestesMedicaoConsumo imovelTestesMedicaoConsumoLigacaoAgua = null;
			ImovelTestesMedicaoConsumo imovelTestesMedicaoConsumoPoco = null;
			ImovelTestesMedicaoConsumo imovelTestesMedicaoConsumoLigacaoEsgoto = null;
			ImovelTestesMedicaoConsumo imovelTestesMedicaoConsumo = null;
			Imovel imovelAPesquisar = new Imovel();

			// Criação dos objetos
			Collection colecaoMedicaoConsumoLigacaoAgua = null;
			// Collection colecaoMedicaoConsumoPoco = null;
			Collection colecaoMedicaoConsumoLigacaoEsgoto = null;
			Collection colecaoImovelLigacaoSituacao = null;

			// Filtro para obter os parametros do sistema
			// FiltroSistemaParametro filtroSistemaParametro = new
			// FiltroSistemaParametro();
			// Collection colecaoSistemaParametro = pesquisar(
			// filtroSistemaParametro, SistemaParametro.class.getName());
			// SistemaParametro sistemaParametro = (SistemaParametro) Util
			// .retonarObjetoDeColecao(colecaoSistemaParametro);
			SistemaParametro sistemaParametro = new SistemaParametro();
			sistemaParametro.setAnoMesFaturamento(200408);
			sistemaParametro.setMesesMediaConsumo(new Short("6"));

			// Obtém na coleção todos os ids dos imóveis pertencentes ao grupo
			// de faturamento informado
			/*
			 * Collection colecaoIdsImoveis = repositorioMicromedicao
			 * .pesquisarImovelFaturamentoGrupoObterIds(faturamentoGrupo);
			 */

			Collection colecaoIdsImoveis = new ArrayList();

			colecaoIdsImoveis.add(new Integer("18380544"));
			colecaoIdsImoveis.add(new Integer("18401258"));
			colecaoIdsImoveis.add(new Integer("54260490"));
			colecaoIdsImoveis.add(new Integer("54265735"));

			Iterator colecaoIdsImoveisIterator = colecaoIdsImoveis.iterator();

			int[] consumoMedioHidrometroLigacaoAgua = null;
			int[] consumoMedioImovelLigacaoAgua = null;

			// int[] consumoMedioHidrometroPoco = null;
			// int[] consumoMedioImovelPoco = null;
			// int[] consumoMedioImovelLigacaoEsgoto = null;
			int[] faixaLeituraEsperada = null;
			int quantidadeEconomias = 0;

			MedicaoTipo medicaoTipo = new MedicaoTipo();
			MedicaoHistorico medicaoHistorico = null;
			Hidrometro hidrometro = null;

			// boolean ligacaoEsgoto = false;

			while (colecaoIdsImoveisIterator.hasNext()) {

				// ligacaoEsgoto = false;

				// Obtém o id do imóvel
				Integer imovelId = (Integer) colecaoIdsImoveisIterator.next();

				imovelTestesMedicaoConsumo = new ImovelTestesMedicaoConsumo();
				imovelTestesMedicaoConsumoLigacaoAgua = new ImovelTestesMedicaoConsumo();
				imovelTestesMedicaoConsumoPoco = new ImovelTestesMedicaoConsumo();
				imovelTestesMedicaoConsumoLigacaoEsgoto = new ImovelTestesMedicaoConsumo();

				// Seta o id em um objeto do tipo imóvel
				imovelAPesquisar.setId(imovelId);

				// Pesquisa o imóvel para obter as informações de ligação de
				// água
				colecaoMedicaoConsumoLigacaoAgua = repositorioMicromedicao
						.pesquisarImovelTesteMedicaoConsumoLigacaoAgua(
								faturamentoGrupo, imovelAPesquisar);
				// Pesquisa o imóvel para obter as informações de ligação de
				// poço
				/* colecaoMedicaoConsumoPoco = */repositorioMicromedicao
						.pesquisarImovelTesteMedicaoConsumoPoco(
								faturamentoGrupo, imovelAPesquisar);
				// Pesquisa o imóvel para obter as informações de ligação de
				// esgoto
				colecaoMedicaoConsumoLigacaoEsgoto = repositorioMicromedicao
						.pesquisarImovelTesteMedicaoConsumoLigacaoEsgoto(
								faturamentoGrupo, imovelAPesquisar);

				// Pesquisa a ligação situacao do imóvel
				colecaoImovelLigacaoSituacao = repositorioMicromedicao
						.pesquisarImovelLigacaoSituacao(imovelAPesquisar);

				if (colecaoImovelLigacaoSituacao != null
						&& !colecaoImovelLigacaoSituacao.isEmpty()) {

					Object[] imovelLigacaoSituacaoArray = Util
							.retonarObjetoDeColecaoArray(colecaoImovelLigacaoSituacao);

					// Seta o ligação situação de água e esgoto
					imovelTestesMedicaoConsumo
							.setIdLigacaoAguaSituacao((Integer) imovelLigacaoSituacaoArray[1]);
					imovelTestesMedicaoConsumo
							.setIdLigacaoEsgotoSituacao((Integer) imovelLigacaoSituacaoArray[2]);
				}

				if (colecaoMedicaoConsumoLigacaoAgua != null
						&& !colecaoMedicaoConsumoLigacaoAgua.isEmpty()) {
					// Obtém os dados necessários de ligação de água
					imovelTestesMedicaoConsumoLigacaoAgua = (ImovelTestesMedicaoConsumo) Util
							.retonarObjetoDeColecao(colecaoMedicaoConsumoLigacaoAgua);

					// Seta o tipo de medição
					medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);
					
					/**
					 * 
					 * Alterando o cálculo da média
					 */
					boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(imovel.getId(), medicaoTipo);
					// Obtém o consumo médio do hidrômetro
					consumoMedioHidrometroLigacaoAgua = obterVolumeMedioAguaEsgoto(
							imovelAPesquisar.getId(),
							sistemaParametro.getAnoMesFaturamento(),
							medicaoTipo.getId(), houveIntslacaoHidrometro);

					// Para obter a leitura anterior
					medicaoHistorico = new MedicaoHistorico();
					medicaoHistorico
							.setLeituraAnteriorInformada(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAnteriorInformadaAgua());
					medicaoHistorico
							.setLeituraAtualInformada(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAtualAgua().intValue());
					medicaoHistorico
							.setLeituraAnteriorFaturamento(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAnteriorAgua().intValue());

					hidrometro = new Hidrometro();
					hidrometro
							.setNumeroDigitosLeitura(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroDigitosLeituraAgua());

					// Seta os valores de água
					imovelTestesMedicaoConsumo
							.setNumeroLeituraAnteriorAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAnteriorAgua());
					imovelTestesMedicaoConsumo
							.setNumeroLeituraAnteriorInformadaAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAnteriorInformadaAgua());
					imovelTestesMedicaoConsumo
							.setIdLeituraSituacaoAnteriorAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdLeituraSituacaoAnteriorAgua());
					imovelTestesMedicaoConsumo
							.setNumeroLeituraAtualAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAtualAgua());
					imovelTestesMedicaoConsumo
							.setIdLeituraSituacaoAtualAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdLeituraSituacaoAtualAgua());
					imovelTestesMedicaoConsumo
							.setNumeroLeituraAtualAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAtualAgua());
					imovelTestesMedicaoConsumo
							.setIdLeituraAnormalidadeAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdLeituraAnormalidadeAgua());
					imovelTestesMedicaoConsumo
							.setIdFaturamentoSituacaoTipo(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdFaturamentoSituacaoTipo());
					imovelTestesMedicaoConsumo
							.setNumeroConsumoMinimoAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroConsumoMinimoAgua());
					imovelTestesMedicaoConsumo
							.setNumeroDigitosLeituraAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroDigitosLeituraAgua());
					imovelTestesMedicaoConsumo
							.setIdHidrometroAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdHidrometroAgua());

					imovelTestesMedicaoConsumo
							.setNumeroMedioConsumoHidrometroAgua(new Integer(
									consumoMedioHidrometroLigacaoAgua[0]));

					faixaLeituraEsperada = calcularFaixaLeituraEsperada(
							consumoMedioImovelLigacaoAgua[0], medicaoHistorico,
							hidrometro, null);

					// Inicial
					imovelTestesMedicaoConsumo
							.setNumeroFaixaIncialAgua(new Integer(
									faixaLeituraEsperada[0]));
					// Final
					imovelTestesMedicaoConsumo
							.setNumeroFaixaFinalAgua(new Integer(
									faixaLeituraEsperada[1]));

				}

				/*---POÇO
				 if (colecaoMedicaoConsumoPoco != null
				 && !colecaoMedicaoConsumoPoco.isEmpty()) {
				 //Obtém os dados necessários do poço
				 imovelTestesMedicaoConsumoPoco = (ImovelTestesMedicaoConsumo) Util
				 .retonarObjetoDeColecao(colecaoMedicaoConsumoPoco);

				 //Seta o tipo de medição
				 medicaoTipo.setId(MedicaoTipo.POCO);
				 //Obtém o consumo médio do hidrômetro
				 consumoMedioHidrometroPoco = obterConsumoMedioHidrometro(
				 imovel, sistemaParametro, medicaoTipo);
				 //Obtém o consumo médio do imóvel

				 if (!ligacaoAgua) {
				 consumoMedioImovelPoco = obterConsumoMedioHidrometro(
				 imovel, sistemaParametro, medicaoTipo);
				 imovelTestesMedicaoConsumo
				 .setNumeroMedioConsumoImovel(new Integer(
				 consumoMedioImovelPoco[0]));
				 }
				 //Para obter a leitura anterior
				 medicaoHistorico = new MedicaoHistorico();
				 medicaoHistorico
				 .setLeituraAnteriorInformada(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAnteriorInformadaPoco());
				 medicaoHistorico
				 .setLeituraAtualInformada(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAtualPoco().intValue());
				 medicaoHistorico
				 .setLeituraAnteriorFaturamento(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAnteriorPoco().intValue());

				 hidrometro = new Hidrometro();
				 hidrometro
				 .setNumeroDigitosLeitura(imovelTestesMedicaoConsumoPoco
				 .getNumeroDigitosLeituraPoco());

				 //Seta os valores de poço
				 imovelTestesMedicaoConsumo
				 .setNumeroLeituraAnteriorPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAnteriorPoco());
				 imovelTestesMedicaoConsumo
				 .setNumeroLeituraAnteriorInformadaPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAnteriorInformadaPoco());
				 imovelTestesMedicaoConsumo
				 .setIdLeituraSituacaoAnteriorPoco(imovelTestesMedicaoConsumoPoco
				 .getIdLeituraSituacaoAnteriorPoco());
				 imovelTestesMedicaoConsumo
				 .setNumeroLeituraAtualPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAtualPoco());
				 imovelTestesMedicaoConsumo
				 .setIdLeituraSituacaoAtualPoco(imovelTestesMedicaoConsumoPoco
				 .getIdLeituraSituacaoAtualPoco());
				 imovelTestesMedicaoConsumo
				 .setNumeroLeituraAtualPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAtualPoco());
				 imovelTestesMedicaoConsumo
				 .setIdLeituraAnormalidadePoco(imovelTestesMedicaoConsumoPoco
				 .getIdLeituraAnormalidadePoco());
				 imovelTestesMedicaoConsumo
				 .setIdFaturamentoSituacaoTipo(imovelTestesMedicaoConsumoPoco
				 .getIdFaturamentoSituacaoTipo());
				 imovelTestesMedicaoConsumo
				 .setIdPoco(imovelTestesMedicaoConsumoPoco.getId());
				 imovelTestesMedicaoConsumo
				 .setNumeroDigitosLeituraPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroDigitosLeituraPoco());
				 imovelTestesMedicaoConsumo
				 .setIdHidrometroPoco(imovelTestesMedicaoConsumoPoco
				 .getIdHidrometroPoco());

				 faixaLeituraEsperada = calcularFaixaLeituraEsperada(
				 consumoMedioImovelPoco[0], medicaoHistorico,
				 hidrometro);

				 //Inicial
				 imovelTestesMedicaoConsumo
				 .setNumeroFaixaInicialPoco(new Integer(
				 faixaLeituraEsperada[0]));
				 //Final
				 imovelTestesMedicaoConsumo
				 .setNumeroFaixaFinalPoco(new Integer(
				 faixaLeituraEsperada[1]));

				 imovelTestesMedicaoConsumo
				 .setNumeroMedioConsumoHidrometroPoco(new Integer(
				 consumoMedioHidrometroPoco[0]));

				 poco = true;
				 } */

				if (colecaoMedicaoConsumoLigacaoEsgoto != null
						&& !colecaoMedicaoConsumoLigacaoEsgoto.isEmpty()) {
					// Obtém os dados necessários da ligação de esgoto
					imovelTestesMedicaoConsumoLigacaoEsgoto = (ImovelTestesMedicaoConsumo) Util
							.retonarObjetoDeColecao(colecaoMedicaoConsumoLigacaoEsgoto);

					imovelTestesMedicaoConsumo
							.setNumeroConsumoMinimoEsgoto(imovelTestesMedicaoConsumoLigacaoEsgoto
									.getNumeroConsumoMinimoEsgoto());
					imovelTestesMedicaoConsumo
							.setPercentualColetaLigacaoEsgoto(imovelTestesMedicaoConsumoLigacaoEsgoto
									.getPercentualColetaLigacaoEsgoto());

				}

				if (imovelTestesMedicaoConsumoLigacaoAgua != null
						&& imovelTestesMedicaoConsumoLigacaoAgua
								.getIndicadorHidrometroAgua() != null) {
					imovelTestesMedicaoConsumo
							.setIndicadorHidrometroAgua(new Integer("1"));
				} else {
					imovelTestesMedicaoConsumo
							.setIndicadorHidrometroAgua(new Integer("2"));
				}

				if (imovelTestesMedicaoConsumoPoco != null
						&& imovelTestesMedicaoConsumoPoco
								.getIndicadorHidrometroPoco() != null) {
					imovelTestesMedicaoConsumo
							.setIndicadorHidrometroPoco(new Integer("1"));
				} else {
					imovelTestesMedicaoConsumo
							.setIndicadorHidrometroPoco(new Integer("2"));
				}

				// Obtém a quantidade de economia(s) do imóvel
				quantidadeEconomias = getControladorImovel()
						.obterQuantidadeEconomias(imovelAPesquisar);
				imovelTestesMedicaoConsumo
						.setQuantidadeEconomias(quantidadeEconomias);
				imovelTestesMedicaoConsumo.setId(imovelId);

				imovelTestesMedicaoConsumo.setUltimaAlteracao(new Date());

				repositorioMicromedicao.inserirBat(imovelTestesMedicaoConsumo);

			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0018] - Ajuste do
	 * Consumo para Múltiplo da Quantidade de Economias
	 */
	public void ajusteConsumoMultiploQuantidadeEconomias(Imovel imovel,
			MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistorico, int quantidadeEconomias,
			SistemaParametro sistemaParametro, FaturamentoGrupo faturamentoGrupo)
			throws ControladorException {

		// [UC0105] Obter Consumo Mínimo da Ligação
		int consumoMinimoImovel = this.obterConsumoMinimoLigacao(imovel, null);

		// Cálculo do Excesso do Imóvel = Consumo faturado - Consumo Minimo do
		// imovel
		int calculoExcessoImovel = consumoHistorico
				.getNumeroConsumoFaturadoMes().intValue() - consumoMinimoImovel;

		int resto = 0;

		if (calculoExcessoImovel > 0) {

			// Cálculo do Excesso por economia = Consumo Excedente / quantidade
			// total de economias do imóvel
			int calculoExcessoEconomia = calculoExcessoImovel
					/ quantidadeEconomias;

			// [UC0108] - Obter Quantidade de Economias por Categoria
			boolean isTarifaCategoria = true;
			Collection colecaoCategoriaOUSubcategoria = this
					.getControladorImovel().obterQuantidadeEconomiasCategoria(
							imovel);

			// Verificando se a empresa fatura por CATEGORIA ou SUBCATEGORIA
			if (!sistemaParametro.getIndicadorTarifaCategoria().equals(
					SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {

				isTarifaCategoria = false;

				// [UC0108] - Obter Quantidade de Economias por Subcategoria
				colecaoCategoriaOUSubcategoria = this.getControladorImovel()
						.obterQuantidadeEconomiasSubCategoria(imovel.getId());
			}

			// SELECIONANDO as tarifas vigentes para a tarifa do imóvel
			// -----------------------------------------------------------------------------------------------------------------------------------------
			FiltroConsumoTarifa filtroConsumoTarifa = new FiltroConsumoTarifa();
			filtroConsumoTarifa.adicionarParametro(new ParametroSimples(
					FiltroConsumoTarifa.ID, imovel.getConsumoTarifa().getId()));

			Collection colecaoConsumoTarifa = getControladorUtil().pesquisar(
					filtroConsumoTarifa, ConsumoTarifa.class.getName());

			ConsumoTarifa consumoTarifa = (ConsumoTarifa) Util
					.retonarObjetoDeColecao(colecaoConsumoTarifa);

			Date dataLeituraAnterior = null;
			Date dataLeituraAtual = null;

			// DEFININDO DATA DE LEITURA ANTERIOR E ATUAL
			if (medicaoHistorico != null
					&& medicaoHistorico.getDataLeituraAnteriorFaturamento() != null
					&& medicaoHistorico.getDataLeituraAtualFaturamento() != null) {

				dataLeituraAnterior = medicaoHistorico
						.getDataLeituraAnteriorFaturamento();
				dataLeituraAtual = medicaoHistorico
						.getDataLeituraAtualFaturamento();
			} else {

				/*
				 * [UC0113] - Faturar Grupo de Faturamento Gerar um perído de
				 * leitura para faturamento
				 */
				Integer anoMesFaturamentoAnterior = Util.subtrairMesDoAnoMes(
						sistemaParametro.getAnoMesFaturamento(), 1);

				Date[] periodoLeitura = this.getControladorFaturamento()
						.gerarPeriodoLeituraFaturamento(null, null,
								faturamentoGrupo,
								sistemaParametro.getAnoMesFaturamento(),
								anoMesFaturamentoAnterior);

				dataLeituraAnterior = (Date) periodoLeitura[0];
				dataLeituraAtual = (Date) periodoLeitura[1];
			}

			Collection colecaoConsumoTarifaVigenciaTodasDatas = this
					.getControladorFaturamento().obterConsumoTarifaVigencia(
							consumoTarifa,
							sistemaParametro.getAnoMesFaturamento(),
							dataLeituraAnterior, dataLeituraAtual);

			if (colecaoConsumoTarifaVigenciaTodasDatas == null
					|| colecaoConsumoTarifaVigenciaTodasDatas.isEmpty()) {
				// A lista com as tarifas vigentes está nula ou vazia
				System.out
						.println(" %%% ERRO.ajusteConsumoMultiploQuantidadeEconomiasCAERN.SemTarifaVigencia: "
								+ "Tarifa: "
								+ imovel.getConsumoTarifa().getId()
								+ ", DataAnterior: "
								+ dataLeituraAnterior
								+ ", DataAtual: " + dataLeituraAtual);

				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.nao_cadastrada_data_vigencia");

			}

			ConsumoTarifaVigencia consumoTarifaVigencia = (ConsumoTarifaVigencia) Util
					.retonarObjetoDeColecao(colecaoConsumoTarifaVigenciaTodasDatas);
			// -----------------------------------------------------------------------------------------------------------------------------------------

			// CALCULANDO POR CATEGORIA OU SUBCATEGORIA
			Categoria categoria = null;
			Subcategoria subcategoria = null;
			Integer qtdEconomiasCategoriaOUSubcategoria = null;
			int consumoMinimoCategoriaOuSubcategoria = 0;
			int consumoExcedenteCategoriaOuSubcategoria = 0;
			int consumoCategoriaOuSubcategoria = 0;

			ConsumoTarifaCategoria consumoTarifaCategoria;
			Collection colecaoConsumoTarifaCategoria = null;

			int calculoConsumoTotalAjustado = 0;

			Iterator iterator = colecaoCategoriaOUSubcategoria.iterator();

			while (iterator.hasNext()) {

				if (isTarifaCategoria) {

					categoria = (Categoria) iterator.next();

					// CALCULANDO A QUANTIDADE DE ECONOMIAS DA CATEGORIA
					qtdEconomiasCategoriaOUSubcategoria = getControladorCadastro()
							.obterQuantidadeEconomiasCategoria(categoria);

					try {

						colecaoConsumoTarifaCategoria = repositorioFaturamento
								.pesquisarConsumoTarifaCategoria(
										consumoTarifaVigencia, categoria);

					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
				} else {

					subcategoria = (Subcategoria) iterator.next();

					// CALCULANDO A QUANTIDADE DE ECONOMIAS DA SUBCATEGORIA
					qtdEconomiasCategoriaOUSubcategoria = getControladorCadastro()
							.obterQuantidadeEconomiasSubcategoria(subcategoria);

					try {

						colecaoConsumoTarifaCategoria = repositorioFaturamento
								.pesquisarConsumoTarifaCategoriaPorSubCategoria(
										consumoTarifaVigencia,
										subcategoria.getCategoria(),
										subcategoria);

						// Quando ele não achar a subcategoria procurar mais
						// acima por categoria
						if (colecaoConsumoTarifaCategoria == null
								|| colecaoConsumoTarifaCategoria.isEmpty()) {

							colecaoConsumoTarifaCategoria = repositorioFaturamento
									.pesquisarConsumoTarifaCategoria(
											consumoTarifaVigencia,
											subcategoria.getCategoria());
						}

					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
				}

				if (colecaoConsumoTarifaCategoria == null
						|| colecaoConsumoTarifaCategoria.isEmpty()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.categoria_nao_existe_para_tarifa_vigente");
				}

				consumoTarifaCategoria = (ConsumoTarifaCategoria) Util
						.retonarObjetoDeColecao(colecaoConsumoTarifaCategoria);

				// ConsumoMinimoCategoria (CSTC_NNCONSUMOMINIMO * quantidade de
				// economias da categoria)
				if (consumoTarifaCategoria.getNumeroConsumoMinimo() != null) {

					consumoMinimoCategoriaOuSubcategoria = consumoTarifaCategoria
							.getNumeroConsumoMinimo().intValue()
							* qtdEconomiasCategoriaOUSubcategoria;
				}

				// Consumo excendente da categoria = Cálculo do Excesso por
				// economia * quantidade de economias da categoria
				consumoExcedenteCategoriaOuSubcategoria = calculoExcessoEconomia
						* qtdEconomiasCategoriaOUSubcategoria;

				// Consumo da categoria = Consumo excendente da categoria +
				// ConsumoMinimoCategoria
				consumoCategoriaOuSubcategoria = consumoExcedenteCategoriaOuSubcategoria
						+ consumoMinimoCategoriaOuSubcategoria;

				// TOTALIZANDO O CONSUMO EXCEDENTE
				calculoConsumoTotalAjustado += consumoCategoriaOuSubcategoria;
			}

			resto = consumoHistorico.getNumeroConsumoFaturadoMes()
					- calculoConsumoTotalAjustado;
		} else {

			// Caso contrário o consumo terá que ser multiplo da quantidade de
			// economias
			resto = consumoHistorico.getNumeroConsumoFaturadoMes().intValue()
					% quantidadeEconomias;
		}

		boolean valido = false;

		if ((medicaoHistorico != null && medicaoHistorico.getMedicaoTipo() != null)
				&& medicaoHistorico.getMedicaoTipo().getId() != null) {

			valido = true;
		}

		// Tem hidrômetro
		if (valido) {

			/*
			 * Caso a leitura atual de faturamento seja igual a leitura anterior
			 * de faturamento mais o consumo a ser cobrado.
			 */
			if (medicaoHistorico.getLeituraAtualFaturamento() == (medicaoHistorico
					.getLeituraAnteriorFaturamento() + consumoHistorico
					.getNumeroConsumoFaturadoMes().intValue())) {

				// Seta a leitura atual de faturamento
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico
						.getLeituraAtualFaturamento() - resto);
			}

		}

		// Seta o consumo a ser faturado
		consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
				consumoHistorico.getNumeroConsumoFaturadoMes().intValue()
						- resto));
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0002] - Determinar
	 * Dados para Faturamento de Esgoto
	 * 
	 * Autor: Leonardo Vieira Data: 06/12/2006
	 */

	public void determinarDadosFaturamentoEsgoto(Imovel imovel,
			ConsumoHistorico consumoHistoricoEsgoto,
			ConsumoHistorico consumoHistoricoAgua, int quantidadeEconomias,
			SistemaParametro sistemaParametro, Rota rota,
			Collection colecaoInserirConsumoHistoricoEsgoto,
			FaturamentoGrupo faturamentoGrupo,
			Collection colecaoInserirMedicaoHistoricoEsgoto,
			Collection colecaoAtualizarMedicaoHistoricoEsgoto,
			EsferaPoder esferaPoder) throws ControladorException {

		ConsumoTipo consumoTipo = new ConsumoTipo();
		ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
		MedicaoHistorico medicaoHistoricoPoco = null;
		MedicaoTipo medicaoTipo = new MedicaoTipo(MedicaoTipo.POCO);
		boolean indicadorBolsaAgua = imovel.getImovelPerfil().getId().equals(ImovelPerfil.BOLSA_AGUA);
		
		Integer consumoMinimoBolsaAgua = Integer.valueOf(Fachada.getInstancia().getFaturamentoParametro(FaturamentoParametro.NOME_PARAMETRO_FATURAMENTO.CONSUMO_MINIMO_BOLSA_AGUA.toString()));

		boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(imovel.getId(), medicaoTipo);
		medicaoTipo = null;

		int[] consumoMedioHidrometro = this.obterVolumeMedioAguaEsgoto(
				imovel.getId(), faturamentoGrupo.getAnoMesReferencia(),
				consumoHistoricoEsgoto.getLigacaoTipo().getId(), houveIntslacaoHidrometro);
		
		if (imovel.getHidrometroInstalacaoHistorico() != null) {

			medicaoHistoricoPoco = new MedicaoHistorico();

			medicaoTipo = new MedicaoTipo(MedicaoTipo.POCO);

			medicaoHistoricoPoco = obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo, sistemaParametro);
			medicaoHistoricoPoco.setImovel(imovel);

			medicaoHistoricoPoco.setConsumoMedioHidrometro(new Integer(consumoMedioHidrometro[0]));

			int leituraAnterior = obterLeituraAnterior(medicaoHistoricoPoco);

			if (medicaoHistoricoPoco.getLeituraAtualInformada() != null) {

				if (medicaoHistoricoPoco.getLeituraAtualInformada().intValue() > leituraAnterior) {

					dadosFaturamentoLeituraMaiorAnterior(medicaoHistoricoPoco,
							consumoHistoricoEsgoto, consumoMedioHidrometro[0],
							imovel, rota, sistemaParametro);
				
				} else if (medicaoHistoricoPoco.getLeituraAtualInformada().intValue() == leituraAnterior) {

					dadosFaturamentoLeituraIgualAnterior(medicaoHistoricoPoco,
							consumoHistoricoEsgoto, medicaoTipo, imovel,
							consumoHistoricoAgua, rota, consumoMedioHidrometro,
							sistemaParametro);

				} else if (medicaoHistoricoPoco.getLeituraAtualInformada().intValue() < leituraAnterior) {

					dadosFaturamentoLeituraMenorAnterior(imovel,
							consumoHistoricoEsgoto, medicaoHistoricoPoco,
							sistemaParametro, leituraAnterior, medicaoTipo,
							consumoMedioHidrometro, consumoMedioHidrometro, rota);

				}

			} else if (medicaoHistoricoPoco.getLeituraAtualInformada() == null 	&& medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() == null) {

				dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(
						medicaoHistoricoPoco, consumoHistoricoEsgoto,
						consumoMedioHidrometro, leituraAnterior,
						sistemaParametro, rota);
			}

			if (medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() != null) {

				dadosFaturamentoAnormalidadeLeitura(medicaoHistoricoPoco,
						consumoHistoricoEsgoto, consumoMedioHidrometro,
						leituraAnterior, imovel, rota);
			}

			verificarAnormalidadeDeConsumo(imovel, consumoHistoricoEsgoto,
					faturamentoGrupo, medicaoHistoricoPoco, medicaoTipo,
					consumoMedioHidrometro, leituraAnterior);

			determinarAjusteMensal(medicaoHistoricoPoco,
					consumoHistoricoEsgoto, imovel, rota,
					consumoMedioHidrometro[0], sistemaParametro);

			FaturamentoSituacaoHistorico situacaoEspecialFaturamento = obterSituacaoEspecialFaturamentoImovel(imovel);

			if (situacaoEspecialFaturamento != null
					&& faturamentoGrupo != null
					&& faturamentoGrupo.getAnoMesReferencia() >= situacaoEspecialFaturamento.getAnoMesFaturamentoSituacaoInicio()
					&& faturamentoGrupo.getAnoMesReferencia() <= situacaoEspecialFaturamento.getAnoMesFaturamentoSituacaoFim()
					&& imovel.getFaturamentoSituacaoTipo() != null
					&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto() != null
					&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().intValue() == 1) {

				dadosFaturamentoEspecialMedido(medicaoHistoricoPoco,
						consumoHistoricoEsgoto, imovel, consumoMedioHidrometro,
						leituraAnterior, faturamentoGrupo);
			}

			if (!consumoHistoricoEsgoto.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_HIDROMETRO)
					&& !consumoHistoricoEsgoto.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_IMOVEL)) {

				if (consumoHistoricoAgua != null && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null) {

					Integer consumoFaturadoMes = consumoHistoricoAgua.getNumeroConsumoFaturadoMes()
							+ consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();

					consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoFaturadoMes);
				}
			}

		} else {

			if (imovel.getLigacaoAgua() != null && consumoHistoricoAgua != null && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null) {
				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoHistoricoAgua.getNumeroConsumoFaturadoMes());
				consumoHistoricoEsgoto.setConsumoTipo(consumoHistoricoAgua.getConsumoTipo());
			} else {

				int consumoMinimo = 0;

				if (imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)) {
					consumoMinimo = obterConsumoMinimoLigacao(imovel, null);
					consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);
				} else {
					if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null && sistemaParametro.getCodigoTipoCalculoNaoMedido().equals(new Integer(1))) {

						consumoMinimo = this.obterConsumoNaoMedidoSemTarifa(imovel.getId(),	sistemaParametro.getAnoMesFaturamento());

					} else if (sistemaParametro.getCodigoTipoCalculoNaoMedido() != null
							&& (sistemaParametro.getCodigoTipoCalculoNaoMedido().equals(new Integer(2)) 
									|| sistemaParametro.getCodigoTipoCalculoNaoMedido().equals(new Integer(3)))) {

						consumoMinimo = this.obterConsumoNaoMedidoPorParametro(imovel.getId(), sistemaParametro.getAnoMesFaturamento(), null);
					}
					consumoTipo.setId(ConsumoTipo.NAO_MEDIDO);
				}

				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(new Integer(consumoMinimo));
				consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);

			}

			FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = obterSituacaoEspecialFaturamentoImovel(imovel);

			if (faturamentoSituacaoHistorico != null && faturamentoGrupo != null
					&& faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio()
					&& faturamentoGrupo.getAnoMesReferencia() <= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoFim()
					&& imovel.getFaturamentoSituacaoTipo() != null
					&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto() != null
					&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().intValue() == 1
					&& !indicadorBolsaAgua) {

				dadosFaturamentoEspecialNaoMedido(consumoHistoricoEsgoto, consumoMedioHidrometro, imovel, faturamentoGrupo);
			}

			if ((imovel.getLigacaoEsgoto().getConsumoMinimo() != null) 
					&& (consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue() < imovel.getLigacaoEsgoto().getConsumoMinimo().intValue())) {

				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(imovel.getLigacaoEsgoto().getConsumoMinimo());
				consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_MINIMO_FIXADO);
				consumoHistoricoEsgoto.setConsumoAnormalidade(consumoAnormalidade);
				consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);
				consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);
			}

		}

		if (imovel.getHidrometroInstalacaoHistorico() != null) {
			if (medicaoHistoricoPoco.getNumeroConsumoInformado() != null) {
				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(medicaoHistoricoPoco.getNumeroConsumoInformado());
				consumoTipo.setId(ConsumoTipo.INFORMADO);
				consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);
				consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_INFORMADO);
				consumoHistoricoEsgoto.setConsumoAnormalidade(consumoAnormalidade);
			}
		}
		
		if (indicadorBolsaAgua
				&& (consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() <= consumoMinimoBolsaAgua)
				&& (consumoHistoricoAgua != null && consumoHistoricoAgua.getConsumoTipo().getId().equals(ConsumoTipo.CONSUMO_MINIMO_BOLSA_AGUA))) {
			// Seta o consumo histórico
			consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoMinimoBolsaAgua);
			consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_BOLSA_AGUA);
			consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);
		}

		if (imovel.getHidrometroInstalacaoHistorico() != null) {
			if (!consumoHistoricoEsgoto.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_HIDROMETRO)
					&& !consumoHistoricoEsgoto.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_IMOVEL)) {

				BigDecimal fatorColeta = imovel.getLigacaoEsgoto().getPercentualAguaConsumidaColetada().divide(new BigDecimal("100"));
				fatorColeta = fatorColeta.multiply(new BigDecimal(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue()));
				
				int consumoSerCobradoMes = Util.arredondar(fatorColeta);
				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(new Integer(consumoSerCobradoMes));
			}
		} else {
			BigDecimal fatorColeta = imovel.getLigacaoEsgoto().getPercentualAguaConsumidaColetada().divide(new BigDecimal("100"));
			fatorColeta = fatorColeta.multiply(new BigDecimal(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue()));

			int consumoSerCobradoMes = Util.arredondar(fatorColeta);

			consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(new Integer(consumoSerCobradoMes));
		}

		if (quantidadeEconomias > 1) {
			ajusteConsumoMultiploQuantidadeEconomias(imovel,
					medicaoHistoricoPoco, consumoHistoricoEsgoto,
					quantidadeEconomias, sistemaParametro, faturamentoGrupo);
		}

		if (imovel.getHidrometroInstalacaoHistorico() != null) {

			medicaoHistoricoPoco.setUltimaAlteracao(new Date());

			if (medicaoHistoricoPoco.getId() == null) {

				colecaoInserirMedicaoHistoricoEsgoto.add(medicaoHistoricoPoco);

			} else {
				colecaoAtualizarMedicaoHistoricoEsgoto
						.add(medicaoHistoricoPoco);
			}

			int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());

			if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(
					ConstantesSistema.SIM)) {

				// Verifica se é faturamento antecipado
				if (imovel.getIndicadorDebitoConta().equals(
						Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
						&& (mes == 11)
						&& esferaPoder != null
						&& (esferaPoder.getId().equals(
								new Integer(EsferaPoder.MUNICIPAL))
								|| esferaPoder.getId().equals(
										new Integer(EsferaPoder.ESTADUAL)) || esferaPoder
								.getId().equals(
										new Integer(EsferaPoder.FEDERAL)))) {

					MedicaoHistorico medicaoHistoricoPosteriorPoco = new MedicaoHistorico();

					// Adiciona 1 ao mês/ano de faturamento para gerar o mês de
					// dezembro
					sistemaParametro
							.setAnoMesFaturamento(Util.somaMesAnoMesReferencia(
									sistemaParametro.getAnoMesFaturamento(), 1));

					medicaoHistoricoPosteriorPoco = obterDadosHistoricoMedicao(
							faturamentoGrupo, imovel, medicaoTipo,
							sistemaParametro);

					// // [UC0102] - Obter Consumo Médio do Hidrômetro
					// int[] consumoMedioHidrometroPosterior =
					// obterConsumoMedioHidrometro(imovel,
					// sistemaParametro, medicaoTipo);

					// Retorna ao mês de referência atual
					sistemaParametro
							.setAnoMesFaturamento(Util.subtrairMesDoAnoMes(
									sistemaParametro.getAnoMesFaturamento(), 1));

					medicaoHistoricoPosteriorPoco
							.setLeituraAnormalidadeFaturamento(medicaoHistoricoPoco
									.getLeituraAnormalidadeFaturamento());
					medicaoHistoricoPosteriorPoco
							.setLeituraAnteriorFaturamento(medicaoHistoricoPoco
									.getLeituraAtualFaturamento());
					medicaoHistoricoPosteriorPoco
							.setDataLeituraAnteriorFaturamento(medicaoHistoricoPoco
									.getDataLeituraAtualFaturamento());

					Date dataAtual = new Date();
					
					Integer qtdDias = null;

					qtdDias = (int)getControladorFaturamento().obterDiferencaDiasCronogramas(
							sistemaParametro.getAnoMesFaturamento(), rota, FaturamentoAtividade.EFETUAR_LEITURA);
					
					medicaoHistoricoPosteriorPoco
							.setDataLeituraAtualFaturamento(Util
									.adicionarNumeroDiasDeUmaData(dataAtual, qtdDias));

					Integer leituraAtual = medicaoHistoricoPoco
							.getLeituraAtualFaturamento()
							+ consumoHistoricoEsgoto
									.getNumeroConsumoFaturadoMes();

					medicaoHistoricoPosteriorPoco
							.setLeituraAtualFaturamento(leituraAtual);

					// // Seta o consumo médio do hidrômetro
					// medicaoHistoricoPosterior.setConsumoMedioHidrometro(new
					// Integer(
					// consumoMedioHidrometroPosterior[0]));

					medicaoHistoricoPosteriorPoco
							.setConsumoMedioHidrometro(medicaoHistoricoPoco
									.getConsumoMedioHidrometro());

					medicaoHistoricoPosteriorPoco
							.setUltimaAlteracao(new Date());

					if (medicaoHistoricoPosteriorPoco.getId() == null) {
						colecaoInserirMedicaoHistoricoEsgoto
								.add(medicaoHistoricoPosteriorPoco);

					} else {
						colecaoAtualizarMedicaoHistoricoEsgoto
								.add(medicaoHistoricoPosteriorPoco);
					}

				}

			}
		}

		// Seta o imóvel
		consumoHistoricoEsgoto.setImovel(imovel);

		// Seta o tipo de ligação
		LigacaoTipo ligacaoTipo = new LigacaoTipo();
		
		ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
		consumoHistoricoEsgoto.setLigacaoTipo(ligacaoTipo);
		// Seta a referência de faturamento
		consumoHistoricoEsgoto.setReferenciaFaturamento(sistemaParametro
				.getAnoMesFaturamento());
		// Seta o indicador alteração últimos consumos
		consumoHistoricoEsgoto.setIndicadorAlteracaoUltimosConsumos(new Short(
				"2"));
		// Seta o indicador ajuste
		consumoHistoricoEsgoto.setIndicadorAjuste(rota
				.getIndicadorAjusteConsumo());
		// Seta o consumo rateio
		consumoHistoricoEsgoto.setConsumoRateio(null);
		// Seta o consumo histórico condomínio
		consumoHistoricoEsgoto.setConsumoHistoricoCondominio(null);
		// Seta o indicador imóvel condomínio
		consumoHistoricoEsgoto.setIndicadorImovelCondominio(imovel
				.getIndicadorImovelCondominio());
		// Seta o consumo médio do imóvel
		consumoHistoricoEsgoto.setConsumoMedio(new Integer(
				consumoMedioHidrometro[0]));
		// Seta o consumo mínimo de água
		if (imovel.getLigacaoEsgoto() != null && !imovel.getLigacaoEsgoto().equals("")) {
			
			if (imovel.getImovelPerfil().getId().equals(ImovelPerfil.BOLSA_AGUA)) {
				consumoHistoricoEsgoto.setConsumoMinimo(consumoMinimoBolsaAgua);
			} else {
				consumoHistoricoEsgoto.setConsumoMinimo(imovel.getLigacaoEsgoto().getConsumoMinimo());
			}
			// Seta o percentual de coleta
			consumoHistoricoEsgoto.setPercentualColeta(imovel
					.getLigacaoEsgoto().getPercentualAguaConsumidaColetada());
		}
		// Seta a última alteração
		consumoHistoricoEsgoto.setUltimaAlteracao(new Date());
		// Seta o poco tipo
		consumoHistoricoEsgoto.setPocoTipo(imovel.getPocoTipo());
		/*
		 * Data: 21/05/2009 Autor: Bruno Barros Analista Solicitante: Sávio
		 * 
		 * Alteração Solicitada: Caso FTGR_AMREFERENCIA da tabela
		 * FATURAMENTO_GRUPO, com FTGR_ID = ao grupo que está sendo faturado,
		 * não enteja entre FTSH_AMFATURAMENTOSITUACAO INICIO e
		 * FTSH_AMFATURAMENTOSITUACAOFIM da tabela
		 * FATURAMENTO_SITUACAO_HISTORICO atribuir FTST_ID da tabela imovel.
		 * CASO CONTRARIO, nulo.
		 */

		FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = obterSituacaoEspecialFaturamentoImovel(imovel);

		// Verificamos se anomesreferencia do grupo que esta sendo faturado
		// está entre o os meses inicial e final do
		// FATURAMENTO_SITUACAO_HISTORICO
		if (imovel.getFaturamentoSituacaoTipo() != null
				&& faturamentoSituacaoHistorico != null
				&& faturamentoGrupo != null
				&& faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico
						.getAnoMesFaturamentoSituacaoInicio()
				&& faturamentoGrupo.getAnoMesReferencia() <= faturamentoSituacaoHistorico
						.getAnoMesFaturamentoSituacaoFim()) {
			consumoHistoricoEsgoto.setFaturamentoSituacaoTipo(imovel
					.getFaturamentoSituacaoTipo());
		} else {
			consumoHistoricoEsgoto.setFaturamentoSituacaoTipo(null);
		}
		/*
		 * FIM ALTERAÇÃO BRUNO BARROS
		 * 
		 * CODIGO ANTERIOR: consumoHistoricoEsgoto.setFaturamentoSituacaoTipo(
		 * imovel.getFaturamentoSituacaoTipo() );
		 */

		/*
		 * Colocado por Raphael Rossiter em 02/06/2008 - Analista: Aryed Lins
		 * OBJ: Incluir gravação do consumo a ser cobrado na coluna
		 * CSHI_NNCONSUMOCALCULOMEDIA na tabela CONSUMO_HISTORICO.
		 */
		consumoHistoricoEsgoto
				.setNumeroConsumoCalculoMedia(consumoHistoricoEsgoto
						.getNumeroConsumoFaturadoMes());

		/*
		 * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson
		 * Carvalho Seta o indicador de faturamento paralisação
		 */
		if (imovel.getFaturamentoSituacaoTipo() == null) {
			consumoHistoricoEsgoto.setIndicadorFaturamento(new Short("1"));
			/*
			 * Data: 21/05/2009 Autor: Bruno Barros Analista Solicitante: Sávio
			 * 
			 * Alteração Solicitada: Para atribuir indicador 2 no indicador de
			 * faturamento, adicionar a seguinte validação: Caso
			 * FTGR_AMREFERENCIA da tabela FATURAMENTO_GRUPO, com FTGR_ID = ao
			 * grupo que está sendo faturado, não enteja entre
			 * FTSH_AMFATURAMENTOSITUACAO INICIO e FTSH_AMFATURAMENTOSITUACAOFIM
			 * da tabela FATURAMENTO_SITUACAO_HISTORICO atribuir FTST_ID da
			 * tabela imovel. CASO CONTRARIO, nulo.
			 */
		} else if (
		// Verificamos se anomesreferencia do grupo que esta sendo faturado
		// está entre o os meses inicial e final do
		// FATURAMENTO_SITUACAO_HISTORICO
		(faturamentoSituacaoHistorico != null
				&& faturamentoGrupo != null
				&& faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico
						.getAnoMesFaturamentoSituacaoInicio() && faturamentoGrupo
				.getAnoMesReferencia() <= faturamentoSituacaoHistorico
				.getAnoMesFaturamentoSituacaoFim())
				&&
				/*
				 * FIM ALTERAÇÃO BRUNO BARROS
				 * 
				 * CODIGO ANTERIOR: Não havia essa codificação
				 */imovel.getFaturamentoSituacaoTipo()
						.getIndicadorParalisacaoFaturamento().intValue() == 1
				&& imovel.getFaturamentoSituacaoTipo()
						.getIndicadorValidoEsgoto().intValue() == 1) {
			consumoHistoricoEsgoto.setIndicadorFaturamento(new Short("2"));
		} else {
			consumoHistoricoEsgoto.setIndicadorFaturamento(new Short("1"));
		}

		// Seta o rateio tipo
		if (consumoHistoricoEsgoto.getId() == null) {
			RateioTipo rateioTipo = new RateioTipo();
			rateioTipo.setId(RateioTipo.SEM_RATEIO);
			consumoHistoricoEsgoto.setRateioTipo(rateioTipo);
		}

		// Alteração realizada provisoriamente. Leonardo Vieira 09/03/2007
		/*
		 * if (imovel.getFaturamentoSituacaoTipo() == null) {
		 * consumoHistoricoEsgoto.setIndicadorFaturamento(new Short("1")); }
		 * else if (imovel.getFaturamentoSituacaoTipo().getId().intValue() ==
		 * new Integer( "12").intValue() ||
		 * imovel.getFaturamentoSituacaoTipo().getId().intValue() == new
		 * Integer( "1").intValue()) {
		 * consumoHistoricoEsgoto.setIndicadorFaturamento(new Short("2")); }
		 * else { consumoHistoricoEsgoto.setIndicadorFaturamento(new
		 * Short("1")); }
		 */

		/*
		 * Seta o indicador de faturamento paralisação TRATAMENTO ORIGINAL -
		 * VÁLIDO if (imovel.getFaturamentoSituacaoTipo() == null) {
		 * consumoHistoricoEsgoto.setIndicadorFaturamento(new Short("1")); }
		 * else if
		 * (imovel.getFaturamentoSituacaoTipo().getIndicadorParalisacaoFaturamento
		 * ().intValue() == 1) {
		 * consumoHistoricoEsgoto.setIndicadorFaturamento(new Short("2")); }
		 * else { consumoHistoricoEsgoto.setIndicadorFaturamento(new
		 * Short("1")); }
		 */

		colecaoInserirConsumoHistoricoEsgoto.add(consumoHistoricoEsgoto);

		int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());

		if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(
				ConstantesSistema.SIM)) {

			// Verifica se é faturamento antecipado
			if (imovel.getIndicadorDebitoConta().equals(
					Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
					&& (mes == 11)
					&& esferaPoder != null
					&& (esferaPoder.getId().equals(
							new Integer(EsferaPoder.MUNICIPAL))
							|| esferaPoder.getId().equals(
									new Integer(EsferaPoder.ESTADUAL)) || esferaPoder
							.getId().equals(new Integer(EsferaPoder.FEDERAL)))) {

				ConsumoHistorico consumoHistoricoEsgotoPosterior = new ConsumoHistorico(
						consumoHistoricoEsgoto);

				consumoHistoricoEsgotoPosterior.setReferenciaFaturamento(Util
						.somaMesAnoMesReferencia(consumoHistoricoEsgoto
								.getReferenciaFaturamento(), 1));

				consumoHistoricoEsgotoPosterior.setUltimaAlteracao(new Date());

				consumoAnormalidade
						.setId(ConsumoAnormalidade.FATURAMENTO_ANTECIPADO);

				consumoHistoricoEsgotoPosterior
						.setConsumoAnormalidade(consumoAnormalidade);

				colecaoInserirConsumoHistoricoEsgoto
						.add(consumoHistoricoEsgotoPosterior);

			}

		}
	}

	/**
	 * [UC0083] - Gerar Dados para Leitura [SF0001] - Gerar Arquivo Convencional
	 * ou Relação Autor: Sávio Luiz, Pedro Alexandre Data: 21/12/2005,
	 * 15/10/2007
	 */
	/**
	 * @param colecaoRota
	 * @param anoMesCorrente
	 * @param idGrupoFaturamentoRota
	 * @param idFuncionalidadeIniciada
	 * @return
	 * @throws ControladorException
	 */
	public Collection gerarDadosPorLeituraMicroColetor(Collection colecaoRota,
			Integer anoMesCorrente, Integer idGrupoFaturamentoRota,
			SistemaParametro sistemaParametro, int idFuncionalidadeIniciada)
			throws ControladorException {

		/**
		 * Comentado por Rômulo Aurélio
		 * 
		 * Metodo movido para o controladorMicromedicaoCompesa
		 */

		return null;

	}

	/**
	 * [UC0121] - Filtrar Exceções de Leituras e Consumos
	 * 
	 * @author Flávio Leonardo, Raphael Rossiter
	 * @date 00/00/0000, 06/10/2009
	 * 
	 * @param faturamentoGrupo
	 * @param filtroMedicaoHistoricoSql
	 * @param numeroPagina
	 * @param todosRegistros
	 * @param mesAno
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection filtrarExcecoesLeiturasConsumos(
			FaturamentoGrupo faturamentoGrupo,
			FiltroMedicaoHistoricoSql filtroMedicaoHistoricoSql,
			Integer numeroPagina, boolean todosRegistros, String mesAno,
			String valorAguaEsgotoInicial, String valorAguaEsgotoFinal)
			throws ControladorException {

		Collection colecaoObject = new ArrayList();

		Collection colecaoImovelMedicao = new ArrayList();

		boolean pesquisarPorRotaAlternativa = false;

		try {

			/*
			 * Colocado por Raphael Rossiter em 06/10/2009
			 * 
			 * Verificando se será necessário realizar a consulta dos imóveis
			 * através da rota alternativa.
			 */
			Collection medicaohistoricoParametros = filtroMedicaoHistoricoSql
					.getParametros();

			if (!medicaohistoricoParametros.isEmpty()
					&& medicaohistoricoParametros.size() >= 1) {

				Iterator iteratorImovelSub = medicaohistoricoParametros
						.iterator();

				while (iteratorImovelSub.hasNext()) {

					FiltroParametro filtroParametro = (FiltroParametro) iteratorImovelSub
							.next();

					if (filtroParametro instanceof ParametroSimples) {

						ParametroSimples parametroSimples = ((ParametroSimples) filtroParametro);

						if (parametroSimples
								.getNomeAtributo()
								.trim()
								.equalsIgnoreCase(
										FiltroMedicaoHistoricoSql.GRUPO_FATURAMENTO)
								|| parametroSimples
										.getNomeAtributo()
										.trim()
										.equalsIgnoreCase(
												FiltroMedicaoHistoricoSql.IMOVEL_EMPRESA)) {

							pesquisarPorRotaAlternativa = true;
							break;
						}
					}
				}
			}

			String anoMes = Util.formatarMesAnoParaAnoMesSemBarra(mesAno);

			colecaoObject = repositorioMicromedicao
					.pesquisarImovelExcecoesLeituras(filtroMedicaoHistoricoSql,
							faturamentoGrupo, numeroPagina, todosRegistros,
							anoMes, valorAguaEsgotoInicial,
							valorAguaEsgotoFinal, pesquisarPorRotaAlternativa);

			Iterator iteratorObject = colecaoObject.iterator();
			while (iteratorObject.hasNext()) {
				Object[] arrayObject = (Object[]) iteratorObject.next();
				if (arrayObject != null) {
					// instancia um imovelMedição que é um helper
					ImovelMicromedicao imovelMicromedicao = new ImovelMicromedicao();
					// instancia um imovel
					Imovel imovel = new Imovel();
					// instancia um leiturista
					Leiturista leiturista = new Leiturista();
					// id imovel
					if (arrayObject[0] != null) {
						imovel.setId((Integer) arrayObject[0]);
					}
					// instancia um imovel
					Localidade localidade = new Localidade();
					// id da localidade
					if (arrayObject[1] != null) {
						localidade.setId(((Integer) arrayObject[1]));
						localidade.setDescricao(((String) arrayObject[19]));
						imovel.setLocalidade(localidade);
					}

					// lote

					SetorComercial setorComercial = new SetorComercial();
					// codigo do setor comercial
					if (arrayObject[2] != null) {

						setorComercial.setCodigo(((Integer) arrayObject[2])
								.intValue());
						setorComercial.setId(((Integer) arrayObject[23]));
						imovel.setSetorComercial(setorComercial);
					}
					Quadra quadra = new Quadra();
					if (arrayObject[3] != null) {
						// número da quadra
						quadra.setNumeroQuadra((Integer) arrayObject[3]);
						quadra.setId((Integer) arrayObject[24]);

						// Id Rota
						Rota rota = new Rota();
						rota.setId((Integer) arrayObject[27]);

						// Id Leitura Tipo
						LeituraTipo leituraTipo = new LeituraTipo();
						leituraTipo.setId((Integer) arrayObject[28]);

						rota.setLeituraTipo(leituraTipo);

						quadra.setRota(rota);
					}

					imovel.setQuadra(quadra);

					// lote
					if (arrayObject[4] != null) {
						imovel.setLote(((Short) arrayObject[4]));
					}
					// sublote
					if (arrayObject[5] != null) {

						imovel.setSubLote(((Short) arrayObject[5]));
					}
					ImovelPerfil imovelPerfil = new ImovelPerfil();
					// descrição imovel perfil
					if (arrayObject[6] != null) {
						imovelPerfil.setDescricao((String) arrayObject[6]);

					}
					imovel.setImovelPerfil(imovelPerfil);
					imovelMicromedicao.setImovel(imovel);

					MedicaoHistorico medicaoHistorico = new MedicaoHistorico();

					MedicaoTipo medicaoTipo = new MedicaoTipo();
					// descrição medição tipo
					if (arrayObject[7] != null) {
						medicaoTipo.setDescricao((String) arrayObject[7]);
					}

					ConsumoHistorico consumoHistorico = new ConsumoHistorico();
					// numero consumo faturado mes
					if (arrayObject[8] != null) {
						consumoHistorico
								.setNumeroConsumoFaturadoMes((Integer) arrayObject[8]);
					}
					LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
					if (arrayObject[9] != null) {
						leituraAnormalidade
								.setDescricao((String) arrayObject[9]);
					}
					medicaoHistorico
							.setLeituraAnormalidadeFaturamento(leituraAnormalidade);

					ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
					if (arrayObject[10] != null) {
						consumoAnormalidade
								.setDescricao((String) arrayObject[10]);
					}

					if (arrayObject[11] != null) {
						medicaoTipo.setId((Integer) arrayObject[11]);
					}

					if (arrayObject[12] != null) {
						medicaoHistorico.setId((Integer) arrayObject[12]);
					}

					if (arrayObject[13] != null) {
						medicaoHistorico
								.setIndicadorAnalisado((Short) arrayObject[13]);
					}

					if (arrayObject[14] != null) {
						medicaoHistorico
								.setConsumoMedioHidrometro((Integer) arrayObject[14]);
					}

					if (arrayObject[15] != null) {
						medicaoHistorico
								.setLeituraCampo((Integer) arrayObject[15]);
					}

					if (arrayObject[16] != null) {
						medicaoHistorico
								.setDataLeituraCampo((Date) arrayObject[16]);
					}

					if (arrayObject[17] != null) {
						Cliente cliente = new Cliente();
						cliente.setNome((String) arrayObject[17]);
						leiturista.setCliente(cliente);
					}

					if (arrayObject[18] != null) {
						Funcionario funcionario = new Funcionario();
						funcionario.setNome((String) arrayObject[18]);
						leiturista.setFuncionario(funcionario);
					}

					if (arrayObject[20] != null) {
						PocoTipo pocoTipo = new PocoTipo();
						pocoTipo.setId((Integer) arrayObject[20]);
						imovel.setPocoTipo(pocoTipo);
					}

					if (arrayObject[21] != null) {
						PavimentoRua pavimentoRua = new PavimentoRua();
						pavimentoRua.setId((Integer) arrayObject[21]);
						imovel.setPavimentoRua(pavimentoRua);
					}

					if (arrayObject[22] != null) {
						PavimentoCalcada pavimentoCalcada = new PavimentoCalcada();
						pavimentoCalcada.setId((Integer) arrayObject[22]);
						imovel.setPavimentoCalcada(pavimentoCalcada);
					}

					if (arrayObject[25] != null) {
						Usuario usuario = new Usuario();
						usuario.setLogin((String) arrayObject[25]);
						usuario.setNomeUsuario((String) arrayObject[26]);
						medicaoHistorico.setUsuarioAlteracao(usuario);
					}
					
					if (arrayObject[29] != null) {
						LigacaoAguaSituacao situacaoLigacaoAgua = new LigacaoAguaSituacao((Integer)arrayObject[29]);
						imovel.setLigacaoAguaSituacao(situacaoLigacaoAgua);
						
					}
					
					if (arrayObject[30] != null) {
						LigacaoEsgotoSituacao situacaoLigacaoEsgoto = new LigacaoEsgotoSituacao((Integer)arrayObject[30]);
						imovel.setLigacaoEsgotoSituacao(situacaoLigacaoEsgoto);
					}

					medicaoHistorico.setMedicaoTipo(medicaoTipo);
					medicaoHistorico.setLeiturista(leiturista);

					consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);

					imovelMicromedicao.setConsumoHistorico(consumoHistorico);
					imovelMicromedicao.setMedicaoHistorico(medicaoHistorico);

					colecaoImovelMedicao.add(imovelMicromedicao);
				}
			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoImovelMedicao;
	}

	/**
	 * [UC0121] - Filtrar Exceções de Leituras e Consumos
	 * 
	 * @author Flávio Leonardo, Raphael Rossiter
	 * @date 00/00/0000, 06/10/2009
	 * 
	 * @param faturamentoGrupo
	 * @param filtroMedicaoHistoricoSql
	 * @param mesAnoPesquisa
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer filtrarExcecoesLeiturasConsumosCount(
			FaturamentoGrupo faturamentoGrupo,
			FiltroMedicaoHistoricoSql filtroMedicaoHistoricoSql,
			String mesAnoPesquisa, String valorAguaEsgotoInicial,
			String valorAguaEsgotoFinal) throws ControladorException {

		Integer retorno = 0;
		boolean pesquisarPorRotaAlternativa = false;

		try {

			if (mesAnoPesquisa != null && !mesAnoPesquisa.trim().equals("")
					&& mesAnoPesquisa.contains("/")) {
				mesAnoPesquisa = Util
						.formatarMesAnoParaAnoMesSemBarra(mesAnoPesquisa);
			}

			/*
			 * Colocado por Raphael Rossiter em 06/10/2009
			 * 
			 * Verificando se será necessário realizar a consulta dos imóveis
			 * através da rota alternativa.
			 */
			Collection medicaohistoricoParametros = filtroMedicaoHistoricoSql
					.getParametros();

			if (!medicaohistoricoParametros.isEmpty()
					&& medicaohistoricoParametros.size() >= 1) {

				Iterator iteratorImovelSub = medicaohistoricoParametros
						.iterator();

				while (iteratorImovelSub.hasNext()) {

					FiltroParametro filtroParametro = (FiltroParametro) iteratorImovelSub
							.next();

					if (filtroParametro instanceof ParametroSimples) {

						ParametroSimples parametroSimples = ((ParametroSimples) filtroParametro);

						if (parametroSimples
								.getNomeAtributo()
								.trim()
								.equalsIgnoreCase(
										FiltroMedicaoHistoricoSql.GRUPO_FATURAMENTO)
								|| parametroSimples
										.getNomeAtributo()
										.trim()
										.equalsIgnoreCase(
												FiltroMedicaoHistoricoSql.IMOVEL_EMPRESA)) {

							pesquisarPorRotaAlternativa = true;
							break;
						}
					}
				}
			}

			retorno = repositorioMicromedicao
					.pesquisarImovelExcecoesLeiturasCount(
							filtroMedicaoHistoricoSql, faturamentoGrupo,
							mesAnoPesquisa, valorAguaEsgotoInicial,
							valorAguaEsgotoFinal, pesquisarPorRotaAlternativa);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/*
	 * [UC0121] - Filtrar Exceções de Leituras e Consumos Flávio Leonardo
	 * Cavalcanti Cordeiro
	 */
	public Collection pesquisarLigacoesMedicaoIndividualizada(Integer idImovel,
			String anoMes) throws ControladorException {
		try {

			Collection retorno = new ArrayList();
			Collection colecaoObjetos = repositorioMicromedicao
					.pesqusiarLigacoesMedicaoIndividualizada(idImovel, anoMes);

			if (!colecaoObjetos.isEmpty()) {
				Iterator iterator = colecaoObjetos.iterator();
				LigacaoMedicaoIndividualizadaHelper ligacaoMedicaoIndividualizadaHelper = null;
				while (iterator.hasNext()) {
					Object[] objeto = (Object[]) iterator.next();
					ligacaoMedicaoIndividualizadaHelper = new LigacaoMedicaoIndividualizadaHelper();

					// idimovel
					if (objeto[0] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setIdImovel((Integer) objeto[0]);

						String inscricao = getControladorImovel()
								.pesquisarInscricaoImovel((Integer) objeto[0]);
						ligacaoMedicaoIndividualizadaHelper
								.setInscricaoImovel(inscricao);
					}
					// qtdEconomias
					if (objeto[1] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setQtdEconomias((Integer) objeto[1]);
					}
					// idMedicaoHistorico
					if (objeto[2] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setIdMedicaoHistorico((Integer) objeto[2]);
					}
					// dataLeituraAnterior
					if (objeto[3] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setDataLeituraAnterior(Util
										.formatarData((Date) objeto[3]));
					}
					// leituraAnterior
					if (objeto[4] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setLeituraAnterior((Integer) objeto[4]);
					}
					// dataLeituraAtual
					if (objeto[5] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setDataLeituraAtual(Util
										.formatarData((Date) objeto[5]));
					}
					// leituraAtual
					if (objeto[6] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setLeituraAtual((Integer) objeto[6]);
					}
					// consumoMedido
					if (objeto[7] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setConsumoMedido((Integer) objeto[7]);
					}
					// idAnormalidadeLeitura
					if (objeto[8] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setIdLeituraAnormalidade((Integer) objeto[8]);
					}
					// idConsumoHistorico
					if (objeto[9] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setIdConsumoHistorico((Integer) objeto[9]);
					}
					// consumoMedio
					if (objeto[10] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setConsumoMedia((Integer) objeto[10]);
					}
					// consumoFaturado
					if (objeto[11] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setConsumoFaturado((Integer) objeto[11]);
					}
					// rateio
					if (objeto[12] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setRateio((Integer) objeto[12]);
					}
					// dsAbreviadaAnormalidadeConsumo
					if (objeto[13] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setDsAbreviadaAnormalidadeConsumo((String) objeto[13]);
					}
					// dsAbreviadaAnormalidadeConsumo
					if (objeto[14] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setDsAbreviadaTipoConsumo((String) objeto[14]);
					}

					// tipoMedicao
					if (objeto[15] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setIdTipoMedicao((Integer) objeto[15]);
					}

					// consumoEsgoto
					if (objeto[16] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setConsumoEsgoto((Integer) objeto[16]);
					}

					// consumoInformado
					if (objeto[17] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setConsumoInformado((Integer) objeto[17]);
					}

					// consumosVinculados
					if (objeto[18] != null) {
						ligacaoMedicaoIndividualizadaHelper
								.setConsumosVinculados((Integer) objeto[18]);
					}

					retorno.add(ligacaoMedicaoIndividualizadaHelper);

				}
			}

			return retorno;
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/*
	 * [UC0083] - Gerar dados para Leitura Pesquisa os dados do hidrometro do
	 * tipo ligação agua e rotorna os dados exigidos no caso de uso. Autor:Sávio
	 * Luiz. Data:27/12/2005
	 */

	public Object[] pesquisarDadosHidrometroTipoLigacaoAgua(Imovel imovel)
			throws ControladorException {
		Object[] dadosHidrometroNumeroLeitura = new Object[6];
		StringBuilder dadosHidrometro = new StringBuilder();
		Short numeroDigitosLeitura = null;
		String codigoHidrometroCapacidade = null;
		Integer idHidrometroCapacidade = null;
		Integer idHidrometroMarca = null;
		String descricaoHidrometroMarca = null;
		String numeroHidrometro = null;

		if (imovel.getLigacaoAgua() != null
				&& imovel.getLigacaoAgua().getId() != null
				&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
				&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()
						.getId() != null) {
			Collection hidrometros = null;
			try {
				// recupera todos os hidrometros e seus historicos do tipo
				// ligacao agua
				hidrometros = repositorioMicromedicao
						.pesquisarDadosHidrometroTipoLigacaoAgua(imovel.getId());
			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			Iterator hidrometroIterator = hidrometros.iterator();
			while (hidrometroIterator.hasNext()) {
				// cria um array de objetos para pegar os parametros de
				// retorno da pesquisa
				Object[] arrayhidrometros = (Object[]) hidrometroIterator
						.next();

				// Alterado por Sávio data:21/03/2007 de acordo com o caso de
				// uso
				if (arrayhidrometros[0] != null) {
					String codigoHidrometroMarca = (String) arrayhidrometros[0];
					// marca do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							codigoHidrometroMarca));

				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							""));
				}
				// numero do hidrometro
				if (arrayhidrometros[1] != null) {

					numeroHidrometro = (String) arrayhidrometros[1];

					dadosHidrometro.append(Util.completaString(""
							+ arrayhidrometros[1], 10));
				} else {
					dadosHidrometro.append(Util.completaString("", 10));
				}
				if (arrayhidrometros[2] != null) {
					codigoHidrometroCapacidade = (String) arrayhidrometros[2];
					// marca do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							codigoHidrometroCapacidade));

				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							""));
				}

				if (arrayhidrometros[3] != null) {
					// local de instalação do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							"" + arrayhidrometros[3]));
				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							""));
				}

				// data de instalação do hidrometro
				if (arrayhidrometros[4] != null) {
					String dataInstalacao = "" + arrayhidrometros[4];
					String dataInstalacaoFormatada = dataInstalacao.substring(
							0, 4)
							+ dataInstalacao.substring(5, 7)
							+ dataInstalacao.substring(8, 10);

					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8,
							dataInstalacaoFormatada));

				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8,
							""));
				}

				if (arrayhidrometros[5] != null) {
					// protecao do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							"" + arrayhidrometros[5]));
				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							""));
				}

				if (arrayhidrometros[7] != null) {
					// numero de digitos do hidrometro
					numeroDigitosLeitura = (Short) arrayhidrometros[7];
				}

				if (arrayhidrometros[8] != null) {

					idHidrometroCapacidade = (Integer) arrayhidrometros[8];
				}

				if (arrayhidrometros[9] != null) {

					idHidrometroMarca = (Integer) arrayhidrometros[9];
				}

				if (arrayhidrometros[10] != null) {

					descricaoHidrometroMarca = (String) arrayhidrometros[10];
				}

			}

		} else {
			// marca do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// numero do hidrometro
			dadosHidrometro.append(Util.completaString("", 10));
			// capacidade do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// local de instalação do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// data de instalação do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8, ""));
			// protecao do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
		}
		dadosHidrometroNumeroLeitura[0] = dadosHidrometro;
		dadosHidrometroNumeroLeitura[1] = numeroDigitosLeitura;
		dadosHidrometroNumeroLeitura[2] = idHidrometroCapacidade;
		dadosHidrometroNumeroLeitura[3] = idHidrometroMarca;
		dadosHidrometroNumeroLeitura[4] = numeroHidrometro;
		dadosHidrometroNumeroLeitura[5] = descricaoHidrometroMarca;
		return dadosHidrometroNumeroLeitura;
	} /*
	 * [UC0083] - Gerar dados para Leitura Pesquisa os dados do hidrometro do
	 * tipo poço e rotorna os dados exigidos no caso de uso. Autor:Sávio Luiz.
	 * Data:27/12/2005
	 */

	public Object[] pesquisarDadosHidrometroTipoPoco(Imovel imovel)
			throws ControladorException {
		Object[] dadosHidrometroNumeroLeitura = new Object[6];
		StringBuilder dadosHidrometro = new StringBuilder();
		Short numeroDigitosLeitura = null;
		String codigoHidrometroCapacidade = null;
		Integer idHidrometroCapacidade = null;
		Integer idHidrometroMarca = null;
		String descricaoHidrometroMarca = null;
		String numeroHidrometro = null;

		if (imovel.getHidrometroInstalacaoHistorico() != null
				&& imovel.getHidrometroInstalacaoHistorico().getId() != null) {
			Collection hidrometros = null;
			try {
				// recupera todos os hidrometros e seus historicos do tipo
				// poco
				hidrometros = repositorioMicromedicao
						.pesquisarDadosHidrometroTipoPoco(imovel.getId());
			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			Iterator hidrometroIterator = hidrometros.iterator();
			while (hidrometroIterator.hasNext()) {
				// cria um array de objetos para pegar os parametros de
				// retorno da pesquisa
				Object[] arrayhidrometros = (Object[]) hidrometroIterator
						.next();

				if (arrayhidrometros[0] != null) {
					// Alterado por Sávio data:20/06/2007 de acordo com o caso
					// de uso
					String codigoHidrometroMarca = (String) arrayhidrometros[0];
					// marca do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							codigoHidrometroMarca));

				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							""));
				}
				// numero do hidrometro
				if (arrayhidrometros[1] != null) {
					numeroHidrometro = (String) arrayhidrometros[1];
					dadosHidrometro.append(Util.completaString(""
							+ arrayhidrometros[1], 10));
				} else {
					dadosHidrometro.append(Util.completaString("", 10));
				}
				if (arrayhidrometros[2] != null) {
					codigoHidrometroCapacidade = (String) arrayhidrometros[2];
					// marca do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							codigoHidrometroCapacidade));

				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							""));
				}

				if (arrayhidrometros[3] != null) {
					// local de instalação do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							"" + arrayhidrometros[3]));
				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							""));
				}

				// data de instalação do hidrometro
				if (arrayhidrometros[4] != null) {
					String dataInstalacao = "" + arrayhidrometros[4];
					String dataInstalacaoFormatada = dataInstalacao.substring(
							0, 4)
							+ dataInstalacao.substring(5, 7)
							+ dataInstalacao.substring(8, 10);

					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8,
							dataInstalacaoFormatada));

				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8,
							""));
				}

				if (arrayhidrometros[5] != null) {
					// protecao do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							"" + arrayhidrometros[5]));
				} else {
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1,
							""));
				}

				if (arrayhidrometros[7] != null) {
					// numero de digitos do hidrometro
					numeroDigitosLeitura = (Short) arrayhidrometros[7];
				}

				if (arrayhidrometros[8] != null) {

					idHidrometroCapacidade = (Integer) arrayhidrometros[8];
				}

				if (arrayhidrometros[9] != null) {
					// numero de digitos do hidrometro
					idHidrometroMarca = (Integer) arrayhidrometros[9];
				}

				if (arrayhidrometros[10] != null) {

					descricaoHidrometroMarca = (String) arrayhidrometros[10];
				}

			}

		} else {
			// marca do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// numero do hidrometro
			dadosHidrometro.append(Util.completaString("", 10));
			// capacidade do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// local de instalação do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// data de instalação do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8, ""));
			// protecao do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));

		}
		dadosHidrometroNumeroLeitura[0] = dadosHidrometro;
		dadosHidrometroNumeroLeitura[1] = numeroDigitosLeitura;
		dadosHidrometroNumeroLeitura[2] = idHidrometroCapacidade;
		dadosHidrometroNumeroLeitura[3] = idHidrometroMarca;
		dadosHidrometroNumeroLeitura[4] = numeroHidrometro;
		dadosHidrometroNumeroLeitura[5] = descricaoHidrometroMarca;
		return dadosHidrometroNumeroLeitura;
	}

	// Complementa o tamanho da string com espaços em branco.
	protected String completaString(String str, int tm) {
		char[] temp = new char[tm];
		Arrays.fill(temp, ' ');
		int tamanho = str.length();
		StringBuilder stringBuilder = null;
		// caso o tamanho da string seja maior do que o tamanho especificado
		if (tamanho > tm) {
			// trunca a String
			String strTruncado = str.substring(0, tm);
			stringBuilder = new StringBuilder(strTruncado);
			// coloca o tamanho para o tamanho truncado
			tamanho = strTruncado.length();
		} else {
			stringBuilder = new StringBuilder(str);
		}

		stringBuilder.append(temp, tamanho, tm - tamanho);
		return stringBuilder.toString();
	}

	/**
	 * [UC0087] - Calcular Faixa de Leitura Falsa [FS0002] - Verificar Leitura
	 * Anterior e Média Autor: Sávio Luiz Data: 30/12/2005
	 */
	public boolean verificarLeituraAnteriorMedia(int media,
			MedicaoHistorico medicaoHistorico) {
		boolean hidrometroSelecionado = true;

		if (medicaoHistorico.getLeituraSituacaoAtual().getId()
				.equals(LeituraSituacao.NAO_REALIZADA)
				|| medicaoHistorico.getLeituraAnteriorFaturamento() == 0
				|| media == 0) {
			hidrometroSelecionado = false;
		}

		return hidrometroSelecionado;
	}

	/**
	 * [UC0087] - Calcular Faixa de Leitura Falsa [FS0003] - Verificar Leitura
	 * Anterior Falsa Negativa Autor: Sávio Luiz Data: 30/12/2005
	 */

	public Integer verificarLeituraAnteriorFalsaNegativa(
			Integer leituraAnteriorFalsa, Hidrometro hidrometro) {
		double leituraAnteriorFalsaNegativa = leituraAnteriorFalsa;
		double numeroDigitosLeitura = hidrometro.getNumeroDigitosLeitura();

		double numeroDigitosLeituraElevadoDez = (int) Math.pow(10,
				numeroDigitosLeitura);

		leituraAnteriorFalsa = new Double(leituraAnteriorFalsaNegativa
				+ numeroDigitosLeituraElevadoDez).intValue();

		return leituraAnteriorFalsa;
	}

	/**
	 * Retorna o consumo munimo da tarifa. [UC0087] - Calcular Faixa de Leitura
	 * Falsa Autor: Sávio Luiz Data: 02/01/2006
	 */
	public Integer pesquisarConsumoMinimoTarifa(Integer idImovel)
			throws ControladorException {

		Integer consumoMinimo = null;

		Collection colecaoConsumoTarifaCategoria = null;

		try {
			colecaoConsumoTarifaCategoria = repositorioMicromedicao
					.pesquisarIdConsumoTarifaCategoria(idImovel);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		Iterator colecaoConsumoTarifaCategoriaIterator = colecaoConsumoTarifaCategoria
				.iterator();
		Integer idConsumoTarifa = null;

		Integer idCategoria = null;

		while (colecaoConsumoTarifaCategoriaIterator.hasNext()) {

			// cria um array de objetos para pegar os parametros de
			// retorno da pesquisa
			Object[] arrayConsumoTarifaCategoria = (Object[]) colecaoConsumoTarifaCategoriaIterator
					.next();
			idConsumoTarifa = (Integer) arrayConsumoTarifaCategoria[0];
			idCategoria = (Integer) arrayConsumoTarifaCategoria[1];

		}
		Integer idConsumoTarifaVigencia = null;
		try {
			idConsumoTarifaVigencia = repositorioMicromedicao
					.pesquisarMaiorDataVigencia(idConsumoTarifa);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		try {
			consumoMinimo = repositorioMicromedicao
					.pesquisarConsumoMinimoTarifaCategoria(
							idConsumoTarifaVigencia, idCategoria);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return consumoMinimo;
	}

	/**
	 * [UC0087] - Calcular Faixa de Leitura Falsa Autor: Sávio Luiz Data:
	 * 29/12/2005
	 */
	public Object[] calcularFaixaLeituraFalsa(Imovel imovel, int media,
			Integer leituraAnterior, MedicaoHistorico medicaoHistorico,
			boolean hidrometroSelecionado, Hidrometro hidrometro)
			throws ControladorException {

		Object[] retorno = new Object[3];

		int[] retornoEsperado = new int[2];

		Calendar dataCalendar = new GregorianCalendar();
		// dataCalendar.setTime(data);
		int segundos = dataCalendar.get(Calendar.SECOND);

		Integer somaImovelSegundo = null;

		// soma os segundos com o id do imovel
		somaImovelSegundo = imovel.getId() + segundos;

		BigDecimal multiplicaFaxaFalsa = null;

		// cria uma flag para saber se o hidrometro é para ser selecionado ou
		// não
		boolean hidrometroSelecionar = hidrometroSelecionado;

		// recupera o percentual da geração da faixa falsa
		BigDecimal percentualGeracaoFaixaFalsaRota = imovel.getQuadra()
				.getRota().getPercentualGeracaoFaixaFalsa();
		// recupera o sistema parametro
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		
		// recupera o percentual falsa do sistema parametro
		BigDecimal percentualFaixaFalsaSistemaParametro = sistemaParametro
				.getPercentualFaixaFalsa();
		// verifica se o indicador udo da faixa falsa é igual a 2
		if (sistemaParametro.getIndicadorUsoFaixaFalsa().equals(
				SistemaParametro.INDICADOR_USO_FAIXA_FALSA_ROTA)) {

			// caso percentual geracao faixa falsa rota seja diferente de nulo
			if (percentualGeracaoFaixaFalsaRota != null
					&& !percentualGeracaoFaixaFalsaRota.equals(new BigDecimal(
							0.0))) {
				// multiplica com geracao faixa falsa rota
				multiplicaFaxaFalsa = percentualGeracaoFaixaFalsaRota
						.multiply(new BigDecimal(somaImovelSegundo));

			}
		} else {
			if (sistemaParametro
					.getIndicadorUsoFaixaFalsa()
					.equals(SistemaParametro.INDICADOR_USO_FAIXA_FALSA_SISTEMA_PARAMETRO)) {
				if (!percentualFaixaFalsaSistemaParametro
						.equals(new BigDecimal(0.0))) {
					// multiplica percentual faixa falsa sistema parametro
					multiplicaFaxaFalsa = percentualFaixaFalsaSistemaParametro
							.multiply(new BigDecimal(somaImovelSegundo));

				}
			}
		}

		// cria uma variável da leitura anterior falsa
		Integer leituraAnteriorFalsa = null;

		if (multiplicaFaxaFalsa != null) {

			// chama o método para verificar se o hidrometro será
			// selecionado ou não.
			hidrometroSelecionar = verificarLeituraAnteriorMedia(media,
					medicaoHistorico);

			// se multiplicaFaxaFalsa for divisivel por 100 ou o hidrometro for
			// selecionado
			if ((multiplicaFaxaFalsa.doubleValue() % 100 == 0)
					|| (hidrometroSelecionar)) {

				// recupera o numero de meses do sistema parametro
				Integer numeroMeses = new Integer(
						sistemaParametro.getMesesMediaConsumo());
				// chama o método pesquisar consumo minimo tarifa para recuperar
				// o consumo minimo
				Integer consumoMinimo = null;
				try {
					consumoMinimo = pesquisarConsumoMinimoTarifa(imovel.getId());
				} catch (ControladorException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				if (leituraAnterior != null && numeroMeses != null
						&& media != 0) {

					// calcula a leitura anterior falsa
					leituraAnteriorFalsa = leituraAnterior
							- (numeroMeses * media) - (consumoMinimo + 1);

					// se a leitura anterior falsa for negativo
					if (leituraAnteriorFalsa.intValue() < 0) {
						// chama o método verificarLeituraAnteriorFalsa
						leituraAnteriorFalsa = verificarLeituraAnteriorFalsaNegativa(
								leituraAnteriorFalsa, hidrometro);
					}

					// seta a leitura anterior falsa na medição historico para
					// ser
					// usado calcularFaixaLeituraEsperada
					medicaoHistorico
							.setLeituraAtualInformada(leituraAnteriorFalsa);
					// seta a leitura anterior falsa na medição historico para
					// ser
					// usado calcularFaixaLeituraEsperada
					medicaoHistorico
							.setLeituraAnteriorInformada(leituraAnteriorFalsa);
					retornoEsperado = calcularFaixaLeituraEsperada(media, null,
							hidrometro, leituraAnteriorFalsa);
				}

			}
		}
		// recupera a faixa inicial
		retorno[0] = retornoEsperado[0];
		// recupera a faixa final
		retorno[1] = retornoEsperado[1];
		// manda um boolena para saber se o próximo hidrometro será selecionado
		retorno[2] = hidrometroSelecionar;

		return retorno;
	}

	public Collection pesquisarLeituraAnteriorTipoLigacaoAgua(Integer idImovel,
			Integer anoMesAnterior) throws ControladorException {
		Collection leituraAnterior = null;

		try {
			leituraAnterior = repositorioMicromedicao
					.pesquisarLeituraAnteriorTipoLigacaoAgua(idImovel,
							anoMesAnterior);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return leituraAnterior;
	}

	protected boolean verificarFaixaFalsa(Rota rota,
			SistemaParametro sistemaParametro) {
		boolean seFaixaFalsa = true;
		if (sistemaParametro.getIndicadorFaixaFalsa().equals(
				SistemaParametro.INDICADOR_FAIXA_FALSA_NAO_USO)
				|| sistemaParametro.getIndicadorFaixaFalsa().equals(
						SistemaParametro.INDICADOR_FAIXA_FALSA_ROTA)) {

			if (rota.getIndicadorGerarFalsaFaixa() != null
					&& rota.getIndicadorGerarFalsaFaixa().equals(
							Rota.INDICADOR_NAO_GERAR_FAIXA_FALSA)) {
				seFaixaFalsa = false;
			}

		}

		return seFaixaFalsa;
	}

	/*
	 * Alterado por Thiago Nascimento data 20/06/2008
	 */
	protected Object[] pesquisaLeituraAnterior(boolean ligacaoAgua,
			boolean ligacaoPoco, Integer anoMesAnterior,
			Imovel imovelParaSerGerado) throws ControladorException {

		Object[] retorno = new Object[6];
		Collection leituraAnteriores = null;
		// caso seja tipo ligação agua e poço cria a string primeiro com
		// tipo
		// ligação agua
		if (ligacaoAgua && ligacaoPoco) {

			try {
				leituraAnteriores = repositorioMicromedicao
						.pesquisarLeituraAnteriorTipoLigacaoAgua(
								imovelParaSerGerado.getId(), anoMesAnterior);
			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
			// verifica se a leitura é diferente de nula
			if (leituraAnteriores != null && !leituraAnteriores.isEmpty()) {
				MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
				Iterator iteratorLeituraAnterior = leituraAnteriores.iterator();
				while (iteratorLeituraAnterior.hasNext()) {
					Object[] leituraSituacao = (Object[]) iteratorLeituraAnterior
							.next();
					if (leituraSituacao[0] != null) {
						retorno[0] = "" + leituraSituacao[0];
					}
					if (leituraSituacao[1] != null) {
						LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
						leituraSituacaoAtual
								.setId((Integer) leituraSituacao[1]);
						medicaoHistorico
								.setLeituraSituacaoAtual(leituraSituacaoAtual);
					}
					if (leituraSituacao[2] != null) {
						medicaoHistorico.setId((Integer) leituraSituacao[2]);
					}

					if (leituraSituacao[3] != null) {
						medicaoHistorico
								.setLeituraAnteriorInformada((Integer) leituraSituacao[3]);
					}
					if (leituraSituacao[4] != null) {
						medicaoHistorico
								.setLeituraAtualInformada((Integer) leituraSituacao[4]);
					}
					if (leituraSituacao[5] != null) {

						LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
						leituraAnormalidade.setId((Integer) leituraSituacao[5]);
						leituraAnormalidade
								.setDescricao((String) leituraSituacao[6]);

						medicaoHistorico
								.setLeituraAnormalidadeInformada(leituraAnormalidade);
					}
					if (leituraSituacao[7] != null) {
						medicaoHistorico
								.setDataLeituraAtualFaturamento((Date) leituraSituacao[7]);
					}

				}
				retorno[1] = medicaoHistorico;
				retorno[2] = MedicaoTipo.LIGACAO_AGUA;

			}

			try {
				leituraAnteriores = repositorioMicromedicao
						.pesquisarLeituraAnteriorTipoPoco(
								imovelParaSerGerado.getId(), anoMesAnterior);
			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
			// verifica se a leitura é diferente de nula
			if (leituraAnteriores != null && !leituraAnteriores.isEmpty()) {
				Iterator iteratorLeituraAnterior = leituraAnteriores.iterator();
				MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
				while (iteratorLeituraAnterior.hasNext()) {
					Object[] leituraSituacao = (Object[]) iteratorLeituraAnterior
							.next();
					if (leituraSituacao[0] != null) {
						retorno[3] = "" + leituraSituacao[0];
					}
					if (leituraSituacao[1] != null) {
						LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
						leituraSituacaoAtual
								.setId((Integer) leituraSituacao[1]);
						medicaoHistorico
								.setLeituraSituacaoAtual(leituraSituacaoAtual);
					}
					if (leituraSituacao[2] != null) {
						medicaoHistorico.setId((Integer) leituraSituacao[2]);
					}

					if (leituraSituacao[3] != null) {
						medicaoHistorico
								.setLeituraAnteriorInformada((Integer) leituraSituacao[3]);
					}
					if (leituraSituacao[4] != null) {
						medicaoHistorico
								.setLeituraAtualInformada((Integer) leituraSituacao[4]);
					}
					if (leituraSituacao[5] != null) {

						LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
						leituraAnormalidade.setId((Integer) leituraSituacao[5]);
						leituraAnormalidade
								.setDescricao((String) leituraSituacao[6]);

						medicaoHistorico
								.setLeituraAnormalidadeInformada(leituraAnormalidade);
					}
					if (leituraSituacao[7] != null) {
						medicaoHistorico
								.setDataLeituraAtualFaturamento((Date) leituraSituacao[7]);
					}
				}
				retorno[4] = medicaoHistorico;
				retorno[5] = MedicaoTipo.POCO;

			}

			// caso não seja
		} else {
			// caso seja tipo ligação agua cria a string com tipo
			// ligação agua
			if (ligacaoAgua) {
				retorno[2] = MedicaoTipo.LIGACAO_AGUA;
				try {
					leituraAnteriores = repositorioMicromedicao
							.pesquisarLeituraAnteriorTipoLigacaoAgua(
									imovelParaSerGerado.getId(), anoMesAnterior);
				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
				// verifica se a leitura é diferente de nula
				if (leituraAnteriores != null && !leituraAnteriores.isEmpty()) {
					Iterator iteratorLeituraAnterior = leituraAnteriores
							.iterator();
					MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
					while (iteratorLeituraAnterior.hasNext()) {
						Object[] leituraSituacao = (Object[]) iteratorLeituraAnterior
								.next();
						if (leituraSituacao[0] != null) {
							retorno[0] = "" + leituraSituacao[0];
						}
						if (leituraSituacao[1] != null) {
							LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
							leituraSituacaoAtual
									.setId((Integer) leituraSituacao[1]);
							medicaoHistorico
									.setLeituraSituacaoAtual(leituraSituacaoAtual);
						}
						if (leituraSituacao[2] != null) {
							medicaoHistorico
									.setId((Integer) leituraSituacao[2]);
						}

						if (leituraSituacao[3] != null) {
							medicaoHistorico
									.setLeituraAnteriorInformada((Integer) leituraSituacao[3]);
						}
						if (leituraSituacao[4] != null) {
							medicaoHistorico
									.setLeituraAtualInformada((Integer) leituraSituacao[4]);
						}
						if (leituraSituacao[5] != null) {

							LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
							leituraAnormalidade
									.setId((Integer) leituraSituacao[5]);
							leituraAnormalidade
									.setDescricao((String) leituraSituacao[6]);

							medicaoHistorico
									.setLeituraAnormalidadeInformada(leituraAnormalidade);
						}
						if (leituraSituacao[7] != null) {
							medicaoHistorico
									.setDataLeituraAtualFaturamento((Date) leituraSituacao[7]);
						}
					}
					retorno[1] = medicaoHistorico;

				}
				// caso não seja ,caso seja tipo ligação poço cria a string com
				// tipo
				// ligação poço
			} else {

				retorno[2] = MedicaoTipo.POCO;
				try {
					leituraAnteriores = repositorioMicromedicao
							.pesquisarLeituraAnteriorTipoPoco(
									imovelParaSerGerado.getId(), anoMesAnterior);
				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
				// verifica se a leitura é diferente de nula
				if (leituraAnteriores != null && !leituraAnteriores.isEmpty()) {
					Iterator iteratorLeituraAnterior = leituraAnteriores
							.iterator();
					MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
					while (iteratorLeituraAnterior.hasNext()) {
						Object[] leituraSituacao = (Object[]) iteratorLeituraAnterior
								.next();
						if (leituraSituacao[0] != null) {
							retorno[0] = "" + leituraSituacao[0];
						}
						if (leituraSituacao[1] != null) {
							LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
							leituraSituacaoAtual
									.setId((Integer) leituraSituacao[1]);
							medicaoHistorico
									.setLeituraSituacaoAtual(leituraSituacaoAtual);
						}
						if (leituraSituacao[2] != null) {
							medicaoHistorico
									.setId((Integer) leituraSituacao[2]);
						}

						if (leituraSituacao[3] != null) {
							medicaoHistorico
									.setLeituraAnteriorInformada((Integer) leituraSituacao[3]);
						}
						if (leituraSituacao[4] != null) {
							medicaoHistorico
									.setLeituraAtualInformada((Integer) leituraSituacao[4]);
						}
						if (leituraSituacao[5] != null) {

							LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
							leituraAnormalidade
									.setId((Integer) leituraSituacao[5]);
							leituraAnormalidade
									.setDescricao((String) leituraSituacao[6]);

							medicaoHistorico
									.setLeituraAnormalidadeInformada(leituraAnormalidade);
						}
						if (leituraSituacao[7] != null) {
							medicaoHistorico
									.setDataLeituraAtualFaturamento((Date) leituraSituacao[7]);
						}
					}
					retorno[1] = medicaoHistorico;

				}

			}
		}

		return retorno;
	}

	protected Object[] pesquisarFaixaEsperadaOuFalsaCelular(
			Imovel imovelParaSerGerado, StringBuilder dadosHidrometro,
			String leituraAnterior, MedicaoHistorico medicaoHistorico,
			Integer idMedicaoTipo, SistemaParametro sistemaParametro,
			boolean hidrometroSelecionado, Short numeroDigitosHidrometro)
			throws ControladorException {

		Object[] retorno = new Object[5];

		// Manda a faixa false de leitura para caso precise gerar um arquivo
		// de fiscalizacao então será gerado a faixa esperada.
		boolean faixaFalsaLeitura = false;
		boolean hidrometroParaselecionar = hidrometroSelecionado;
		int faixaInicial = 0;
		int faixaFinal = 0;

		if (dadosHidrometro.toString().trim().equals("")
				|| leituraAnterior == null || leituraAnterior.equals("")) {

			// Faixa de leitura esperada
			// arquivoTxt.append(Util.adicionarZerosEsquedaNumero(12, ""));
		} else {

			// Faixa de leitura esperada
			MedicaoTipo medicaoTipo = new MedicaoTipo();

			medicaoTipo.setId(idMedicaoTipo);
			Hidrometro hidrometro = new Hidrometro();
			hidrometro.setNumeroDigitosLeitura(numeroDigitosHidrometro);

			boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(imovelParaSerGerado.getId(), medicaoTipo);
			
			int[] obterConsumo = obterVolumeMedioAguaEsgoto(
					imovelParaSerGerado.getId(),
					sistemaParametro.getAnoMesFaturamento(),
					medicaoTipo.getId(), houveIntslacaoHidrometro);
			int mediaConsumoHidrometro = obterConsumo[0];

			// Rota rota = imovelParaSerGerado.getQuadra().getRota();
			Integer leituraAnteriorPesquisada = null;
			if (leituraAnterior != null && !leituraAnterior.equals("")) {
				leituraAnteriorPesquisada = Util
						.converterStringParaInteger(leituraAnterior);
			}

			int[] faixas = calcularFaixaLeituraEsperada(mediaConsumoHidrometro,
					null, hidrometro, leituraAnteriorPesquisada);

			faixaInicial = faixas[0];
			faixaFinal = faixas[1];

			/*
			 * boolean seFaixaFalsa = verificarFaixaFalsa(rota,
			 * sistemaParametro); Integer leituraAnteriorInteger = null; if
			 * (leituraAnterior != null) { leituraAnteriorInteger = new
			 * Integer(leituraAnterior); }
			 * 
			 * if (seFaixaFalsa) {
			 * 
			 * Object[] faixasFalsas = calcularFaixaLeituraFalsa(
			 * imovelParaSerGerado, mediaConsumoHidrometro,
			 * leituraAnteriorInteger, medicaoHistorico, hidrometroSelecionado,
			 * hidrometro);
			 * 
			 * int faixaInicialFalsa = Integer.parseInt(faixasFalsas[0]
			 * .toString()); int faixaFinalFalsa =
			 * Integer.parseInt(faixasFalsas[1] .toString());
			 * 
			 * if (faixaInicialFalsa != 0 && faixaFinalFalsa != 0) {
			 * 
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixasFalsas[0]));
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixasFalsas[1])); // Insere o objeto leitura faixa falsa na base
			 * LeituraFaixaFalsa leituraFaixaFalsa = new LeituraFaixaFalsa();
			 * leituraFaixaFalsa.setId(medicaoHistorico.getId());
			 * leituraFaixaFalsa .setNumeroFalsaInferior((Integer)
			 * faixasFalsas[0]); leituraFaixaFalsa
			 * .setNumeroFalsaSuperior((Integer) faixasFalsas[1]);
			 * leituraFaixaFalsa.setNumeroCorretaInferior(faixaInicial);
			 * leituraFaixaFalsa.setNumeroCorretaSuperior(faixaFinal);
			 * leituraFaixaFalsa.setUltimaAlteracao(new Date());
			 * leituraFaixaFalsa.setMedicaoHistorico(medicaoHistorico);
			 * 
			 * try { repositorioUtil.inserir(leituraFaixaFalsa); } catch
			 * (ErroRepositorioException e) { e.printStackTrace(); throw new
			 * ControladorException("erro.sistema", e); }
			 * 
			 * faixaFalsaLeitura = true; } else {
			 * 
			 * if (faixaInicial != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixaInicial)); } else {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "")); } if
			 * (faixaFinal != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixaFinal)); } else {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "")); } }
			 * hidrometroParaselecionar = Boolean.parseBoolean(faixasFalsas[2]
			 * .toString()); } else {
			 * 
			 * if (faixaInicial != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixaInicial)); } else {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "")); } if
			 * (faixaFinal != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixaFinal)); } else {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "")); } }
			 */
		}

		// retorno[0] = arquivoTxt;
		retorno[1] = new Boolean(hidrometroParaselecionar);
		retorno[2] = new Boolean(faixaFalsaLeitura);
		// if (faixaFalsaLeitura) {
		retorno[3] = faixaInicial;
		retorno[4] = faixaFinal;
		// }

		return retorno;
	}

	protected Object[] pesquisarFaixaEsperadaOuFalsa(
			Imovel imovelParaSerGerado, StringBuilder dadosHidrometro,
			String leituraAnterior, MedicaoHistorico medicaoHistorico,
			Integer idMedicaoTipo, SistemaParametro sistemaParametro,
			boolean hidrometroSelecionado, Short numeroDigitosHidrometro)
			throws ControladorException {

		Object[] retorno = new Object[5];
		StringBuilder arquivoTxt = new StringBuilder();

		// Manda a faixa false de leitura para caso precise gerar um arquivo
		// de fiscalizacao então será gerado a faixa esperada.
		boolean faixaFalsaLeitura = false;
		boolean hidrometroParaselecionar = hidrometroSelecionado;
		int faixaInicial = 0;
		int faixaFinal = 0;

		if (dadosHidrometro.toString().trim().equals("")
				|| leituraAnterior == null || leituraAnterior.equals("")) {

			// Faixa de leitura esperada
			arquivoTxt.append(Util.adicionarZerosEsquedaNumero(12, ""));
		} else {

			// Faixa de leitura esperada
			MedicaoTipo medicaoTipo = new MedicaoTipo();

			medicaoTipo.setId(idMedicaoTipo);
			Hidrometro hidrometro = new Hidrometro();
			hidrometro.setNumeroDigitosLeitura(numeroDigitosHidrometro);

			/**
			 *  Alterando o cálculo da média
			 */
			boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(
					imovelParaSerGerado.getId(), medicaoTipo);
			
			int[] obterConsumo = obterVolumeMedioAguaEsgoto(
					imovelParaSerGerado.getId(),
					sistemaParametro.getAnoMesFaturamento(),
					medicaoTipo.getId(), houveIntslacaoHidrometro);
			int mediaConsumoHidrometro = obterConsumo[0];

			Rota rota = imovelParaSerGerado.getQuadra().getRota();
			Integer leituraAnteriorPesquisada = null;
			if (leituraAnterior != null && !leituraAnterior.equals("")) {
				leituraAnteriorPesquisada = Util
						.converterStringParaInteger(leituraAnterior);
			}

			int[] faixas = calcularFaixaLeituraEsperada(mediaConsumoHidrometro,
					null, hidrometro, leituraAnteriorPesquisada);

			faixaInicial = faixas[0];
			faixaFinal = faixas[1];

			boolean seFaixaFalsa = verificarFaixaFalsa(rota, sistemaParametro);
			Integer leituraAnteriorInteger = null;
			if (leituraAnterior != null) {
				leituraAnteriorInteger = new Integer(leituraAnterior);
			}

			if (seFaixaFalsa) {

				Object[] faixasFalsas = calcularFaixaLeituraFalsa(
						imovelParaSerGerado, mediaConsumoHidrometro,
						leituraAnteriorInteger, medicaoHistorico,
						hidrometroSelecionado, hidrometro);

				int faixaInicialFalsa = Integer.parseInt(faixasFalsas[0]
						.toString());
				int faixaFinalFalsa = Integer.parseInt(faixasFalsas[1]
						.toString());

				if (faixaInicialFalsa != 0 && faixaFinalFalsa != 0) {

					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""
							+ faixasFalsas[0]));
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""
							+ faixasFalsas[1]));

					// Insere o objeto leitura faixa falsa na base
					LeituraFaixaFalsa leituraFaixaFalsa = new LeituraFaixaFalsa();
					leituraFaixaFalsa.setId(medicaoHistorico.getId());
					leituraFaixaFalsa
							.setNumeroFalsaInferior((Integer) faixasFalsas[0]);
					leituraFaixaFalsa
							.setNumeroFalsaSuperior((Integer) faixasFalsas[1]);
					leituraFaixaFalsa.setNumeroCorretaInferior(faixaInicial);
					leituraFaixaFalsa.setNumeroCorretaSuperior(faixaFinal);
					leituraFaixaFalsa.setUltimaAlteracao(new Date());
					leituraFaixaFalsa.setMedicaoHistorico(medicaoHistorico);

					try {
						repositorioUtil.inserir(leituraFaixaFalsa);
					} catch (ErroRepositorioException e) {
						e.printStackTrace();
						throw new ControladorException("erro.sistema", e);
					}

					faixaFalsaLeitura = true;
				} else {

					if (faixaInicial != 0) {
						arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6,
								"" + faixaInicial));
					} else {
						arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6,
								""));
					}
					if (faixaFinal != 0) {
						arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6,
								"" + faixaFinal));
					} else {
						arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6,
								""));
					}
				}
				hidrometroParaselecionar = Boolean.parseBoolean(faixasFalsas[2]
						.toString());

			} else {

				if (faixaInicial != 0) {
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""
							+ faixaInicial));
				} else {
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""));
				}
				if (faixaFinal != 0) {
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""
							+ faixaFinal));
				} else {
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""));
				}
			}
		}

		retorno[0] = arquivoTxt;
		retorno[1] = new Boolean(hidrometroParaselecionar);
		retorno[2] = new Boolean(faixaFalsaLeitura);
		if (faixaFalsaLeitura) {
			retorno[3] = faixaInicial;
			retorno[4] = faixaFinal;
		}

		return retorno;
	}

	/**
	 * [UC0099] - Selecionar Fiscalização de Leitura Autor: Sávio Luiz Data:
	 * 04/01/2006
	 */

	public boolean selecionarFiscalizacaoLeitura(Imovel imovel,
			SistemaParametro sistemaParametro) {
		boolean leituraSelecionada = false;
		Rota rota = imovel.getQuadra().getRota();

		Calendar dataCalendar = new GregorianCalendar();
		// obtem a hora corrente
		int segundos = dataCalendar.get(Calendar.SECOND);

		Integer somaImovelSegundo = null;

		// soma os segundos com o id do imovel
		somaImovelSegundo = imovel.getId() + segundos;

		BigDecimal multiplica = null;

		// recupera o percentual de fiscalização de rota
		BigDecimal percentualFiscalizacaoRota = rota
				.getPercentualGeracaoFiscalizacao();
		// recupera o percentual de fiscalização de sistema parametro
		BigDecimal percentualFiscalizacaoSistemaParametro = sistemaParametro
				.getPercentualFiscalizacaoLeitura();

		if ((percentualFiscalizacaoRota != null && !percentualFiscalizacaoRota
				.equals(""))
				&& (percentualFiscalizacaoSistemaParametro != null && !percentualFiscalizacaoSistemaParametro
						.equals(""))) {

			if (percentualFiscalizacaoSistemaParametro
					.equals(SistemaParametro.INDICADOR_PERCENTUAL_FISCALIZACAO_LEITURA_ROTA)) {
				multiplica = percentualFiscalizacaoRota
						.multiply(new BigDecimal(somaImovelSegundo));
			} else {
				multiplica = percentualFiscalizacaoRota
						.multiply(new BigDecimal(somaImovelSegundo));
			}
			if (multiplica != null) {
				if (multiplica.doubleValue() % 100 == 0) {
					leituraSelecionada = true;
				}
			}

		}

		return leituraSelecionada;
	}

	protected void mandaArquivoLeituraEmail(StringBuilder arquivo,
			String emailReceptor, String emailRemetente, String tituloMensagem,
			String corpoMensagem, String nomeArquivo)

	throws ControladorException {
		try {
			nomeArquivo = nomeArquivo
					+ "_"
					+ Util.formatarDataComHora(new Date()).replace("/", "_")
							.replace(":", "_").replace(" ", "_");

			File leitura = new File(nomeArquivo + ".txt");
			File compactado = new File(nomeArquivo + ".zip"); // nomeZip
			ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(
					compactado));
			// Alterado por Ivan Sergio
			// Data: 24/04/2009
			// Por motivo dos arquivos gerados em hexadecimal.
			BufferedOutputStream out = new BufferedOutputStream(
					new FileOutputStream(leitura.getAbsolutePath()));
			out.write(arquivo.toString().getBytes(
					System.getProperty("file.encoding")));
			out.close();

			ZipUtil.adicionarArquivo(zos, leitura);

			// close the stream
			zos.close();

			// Alterado por Ivan Sergio

			// Data: 04/02/2009
			// Por algum motivo não esta encontrando o arquivo .txt para anexar
			// ao email.
			// ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
			// emailRemetente, tituloMensagem, corpoMensagem, leitura);
			System.out.println("@@-> Enviando email Arquivo leitura...");
			ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
					emailRemetente, tituloMensagem, corpoMensagem, compactado);
			System.out.println("@@-> Fim do envio email Arquivo leitura.");

			leitura.delete();

		} catch (IOException e) {
			e.printStackTrace();
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		} catch (Exception e) {
			e.printStackTrace();
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0098] Manter Vínculos de Imóveis para Rateio de Consumo Atualizar Tipo
	 * Rateio com Vinculo com o Imovel Author: Rafael Santos Data: 12/01/2006
	 * 
	 * @imovel Imovel
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public void atualizarTipoRateio(Imovel imovel,
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoAgua,
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoPoco,
			Usuario usuarioLogado, boolean indicadorRateioPorAreaComum,
			Integer imovelAreaComum) throws ControladorException,
			ErroRepositorioException {

		FiltroImovel filtroImovel = new FiltroImovel();

		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID,
				imovel.getId()));

		// Procura Imovel na base
		Imovel imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(
				filtroImovel, Imovel.class.getName()))).get(0);

		Integer anoMesFaturamentoGrupo0 = repositorioFaturamento
				.retornaAnoMesGrupoFaturamento(imovelNaBase.getId());

		Collection<Imovel> colImovel0 = new ArrayList();

		Imovel imovelVinculo0 = new Imovel();

		imovelVinculo0.setId(imovelNaBase.getId());

		colImovel0.add(imovelVinculo0);

		Collection colContas0 = repositorioMicromedicao
				.verificarImoveisCicloFaturamento(colImovel0,
						anoMesFaturamentoGrupo0);

		if (colContas0 != null && !colContas0.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.impossivel.vinculo.desvinculo");
		}

		// [FS0011] -Verifica a existenica de imovel micro em processo de
		// faturamento

		/*
		 * Caso o imóvel condomínio informado esteja vinculado a algum imóvel
		 * (IMOV_IDIMOVELCONDOMINIO na tabela IMOVEL igual ao IMOV_ID do imóvel
		 * condomínio) que já possua conta pre-faturada para o mês/ano do seu
		 * grupo de faturamento (CNTA_AMREFERENCIACONTA da tabela de CONTA igual
		 * ao FTGR_AMREFERENCIA da tabela de FATURAMENTO_GRUPO com FTGR_ID igual
		 * FTGR_ID da tabela de CONTA e DCST_IDATUAL da tabela de CONTA igual a
		 * 9 "PRE FATURADA", exibir a mensagem "Não é possível
		 * vincular/desvincular imóvel ao imóvel condominio informado pois ele
		 * já se encontra em processo de faturamento" e retornar para o passo
		 * correspondente no fluxo principal.
		 */

		// Por Tiago Moreno - 22/02/2011
		Collection imoveisVinculados = repositorioMicromedicao
				.recuperarImoveisVinculadosAoCondominio(imovel.getId());

		if (imoveisVinculados != null && !imoveisVinculados.isEmpty()) {
			Integer anoMesFaturamentoGrupo = repositorioFaturamento
					.retornaAnoMesGrupoFaturamento(imovel.getId());

			Collection colContas = repositorioMicromedicao
					.verificarImoveisCicloFaturamento(imoveisVinculados,
							anoMesFaturamentoGrupo);

			if (colContas != null && !colContas.isEmpty()) {
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.impossivel.vinculo.desvinculo");
			}
		}

		// Verificar se Imovel já foi atualizada por outro usuário durante esta
		// atualização
		// [FS0007] Atualização realizada por outro usuário
		if (imovelNaBase.getUltimaAlteracao()
				.after(imovel.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// [SB0001]Atualizar o Tipo Rateio do Imovel
		// atualizar o tipo rateio de agua
		if (hidrometroInstalacaoHistoricoAgua != null) {
			hidrometroInstalacaoHistoricoAgua.setUltimaAlteracao(new Date());

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.acesso.negado.abrangencia");
			} else {

				// ------------ REGISTRAR TRANSAÇÃO ----------------

				Integer anoMesFaturamentoGrupo = repositorioFaturamento
						.retornaAnoMesGrupoFaturamento(hidrometroInstalacaoHistoricoAgua
								.getLigacaoAgua().getId());

				Imovel imovelVinculo = new Imovel();
				imovelVinculo.setId(hidrometroInstalacaoHistoricoAgua
						.getLigacaoAgua().getId());

				Collection<Imovel> colImovel = new ArrayList();
				colImovel.add(imovelVinculo);

				Collection colContas = repositorioMicromedicao
						.verificarImoveisCicloFaturamento(colImovel,
								anoMesFaturamentoGrupo);

				if (colContas != null && !colContas.isEmpty()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.impossivel.vinculo.desvinculo");
				}

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_ATUALIZAR_TIPO_RATEIO,
						hidrometroInstalacaoHistoricoAgua.getLigacaoAgua()
								.getId(), hidrometroInstalacaoHistoricoAgua
								.getLigacaoAgua().getId(),
						new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao
						.registrarOperacao(hidrometroInstalacaoHistoricoAgua);

				// ------------ REGISTRAR TRANSAÇÃO ----------------

				getControladorUtil().atualizar(
						hidrometroInstalacaoHistoricoAgua);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

		// atualizar tipo poco
		if (hidrometroInstalacaoHistoricoPoco != null) {
			hidrometroInstalacaoHistoricoPoco.setUltimaAlteracao(new Date());

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.acesso.negado.abrangencia");
			} else {

				Integer anoMesFaturamentoGrupo = repositorioFaturamento
						.retornaAnoMesGrupoFaturamento(hidrometroInstalacaoHistoricoPoco
								.getLigacaoAgua().getId());

				Collection<Imovel> colImovel = new ArrayList();

				Imovel imovelVinculo = new Imovel();

				imovelVinculo.setId(hidrometroInstalacaoHistoricoPoco
						.getLigacaoAgua().getId());

				colImovel.add(imovelVinculo);

				Collection colContas = repositorioMicromedicao
						.verificarImoveisCicloFaturamento(colImovel,
								anoMesFaturamentoGrupo);

				if (colContas != null && !colContas.isEmpty()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.impossivel.vinculo.desvinculo");
				}

				// ------------ REGISTRAR TRANSAÇÃO ----------------
				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_ATUALIZAR_TIPO_RATEIO,
						hidrometroInstalacaoHistoricoPoco.getLigacaoAgua()
								.getId(), hidrometroInstalacaoHistoricoPoco
								.getLigacaoAgua().getId(),
						new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao
						.registrarOperacao(hidrometroInstalacaoHistoricoPoco);

				// ------------ REGISTRAR TRANSAÇÃO ----------------

				getControladorUtil().atualizar(
						hidrometroInstalacaoHistoricoPoco);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

		/*
		 * Caso o novo tipo de rateio selecionado corresponda a 'RATEIO POR AREA
		 * COMUM', o sistema atualiza o Imóvel para Área Comum
		 */
		if (indicadorRateioPorAreaComum) {
			if (imovelAreaComum != null) {
				Integer imovelAreaComumAtual = this.getControladorImovel()
						.pesquisarImovelAreaComum(imovel.getId());
				if (imovelAreaComumAtual != null) {
					/*
					 * [SB0005]  Remover Imóvel da Área Comum
					 */
					getControladorImovel()
							.atualizarIndicadorImovelAreaComumDoImovel(
									imovelAreaComumAtual, ConstantesSistema.NAO);
				}

				// Insere o novo Imóvel Área Comum
				getControladorImovel()
						.atualizarIndicadorImovelAreaComumDoImovel(
								imovelAreaComum, ConstantesSistema.SIM);
			}
		} else {
			/*
			 * [SB0005]  Remover Imóvel da Área Comum Caso o tipo do rateio NÃO
			 * seja 'RATEIO POR AREA COMUM' Pesquisa se o
			 * indicadorImovelAreaComum está SIM (1) e
			 */
			Integer imovelAreaComumAtual = this.getControladorImovel()
					.pesquisarImovelAreaComum(imovel.getId());
			// Remove o Imóvel Área Comum atual
			if (imovelAreaComumAtual != null) {
				getControladorImovel()
						.atualizarIndicadorImovelAreaComumDoImovel(
								imovelAreaComumAtual, ConstantesSistema.NAO);
			}
		}
	}

	
	public void estabelecerVinculo(Imovel imovel, Collection imoveisASerVinculados,
			Collection imoveisASerDesvinculados,
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoAgua,
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoPoco,
			Usuario usuarioLogado) throws ControladorException {
		
		try {
			FiltroImovel filtroImovel = new FiltroImovel();
	
			filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
	
			// Procura Imovel na base
			Imovel imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);
	
			Integer anoMesFaturamentoGrupo0 = repositorioFaturamento.retornaAnoMesGrupoFaturamento(imovelNaBase.getId());
	
			Collection<Imovel> colImovel0 = new ArrayList();
	
			Imovel imovelVinculo0 = new Imovel();
	
			imovelVinculo0.setId(imovelNaBase.getId());
	
			colImovel0.add(imovelVinculo0);
	
			Collection colContas0 = repositorioMicromedicao.verificarImoveisCicloFaturamento(colImovel0, anoMesFaturamentoGrupo0);
	
			if (colContas0 != null && !colContas0.isEmpty()) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.impossivel.vinculo.desvinculo");
			}
	
			imovel.setUltimaAlteracao(new Date());
			// Verificar se Imovel já foi atualizada por outro usuário durante esta
			// atualização
			// [FS0007] Atualização realizada por outro usuário
			if (imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}
	
			// Por Tiago Moreno - 22/02/2011
			Collection imoveisVinculados = repositorioMicromedicao.recuperarImoveisVinculadosAoCondominio(imovel.getId());
	
			if (imoveisVinculados != null && !imoveisVinculados.isEmpty()) {
				Integer anoMesFaturamentoGrupo = repositorioFaturamento.retornaAnoMesGrupoFaturamento(imovel.getId());
	
				Collection colContas = repositorioMicromedicao.verificarImoveisCicloFaturamento(imoveisVinculados, anoMesFaturamentoGrupo);
	
				if (colContas != null && !colContas.isEmpty()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.impossivel.vinculo.desvinculo");
				}
			}
	
			// [SB0001]Atualizar o Tipo Rateio do Imovel
			// atualizar o tipo rateio de agua
			if (hidrometroInstalacaoHistoricoAgua != null) {
				hidrometroInstalacaoHistoricoAgua.setUltimaAlteracao(new Date());
	
				/**
				 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
				 * acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);
	
				if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				} else {
	
					Integer anoMesFaturamentoGrupo = repositorioFaturamento.retornaAnoMesGrupoFaturamento(hidrometroInstalacaoHistoricoAgua.getLigacaoAgua().getId());
	
					Collection<Imovel> colImovel = new ArrayList();
	
					Imovel imovelVinculo = new Imovel();
	
					imovelVinculo.setId(hidrometroInstalacaoHistoricoAgua.getLigacaoAgua().getId());
	
					colImovel.add(imovelVinculo);
	
					Collection colContas = repositorioMicromedicao.verificarImoveisCicloFaturamento(colImovel, anoMesFaturamentoGrupo);
	
					if (colContas != null && !colContas.isEmpty()) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.impossivel.vinculo.desvinculo");
					}
	
					getControladorUtil().atualizar(hidrometroInstalacaoHistoricoAgua);
				}
				// ------------ FIM CONTROLE DE ABRANGENCIA -------------
			}
	
			// atualizar tipo poco
			if (hidrometroInstalacaoHistoricoPoco != null) {
				hidrometroInstalacaoHistoricoPoco.setUltimaAlteracao(new Date());
	
				/**
				 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
				 * acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);
	
				if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				} else {
	
					Integer anoMesFaturamentoGrupo = repositorioFaturamento.retornaAnoMesGrupoFaturamento(hidrometroInstalacaoHistoricoPoco.getLigacaoAgua().getId());
	
					Collection<Imovel> colImovel = new ArrayList();
	
					Imovel imovelVinculo = new Imovel();
	
					imovelVinculo.setId(hidrometroInstalacaoHistoricoPoco.getLigacaoAgua().getId());
	
					colImovel.add(imovelVinculo);
	
					Collection colContas = repositorioMicromedicao.verificarImoveisCicloFaturamento(colImovel, anoMesFaturamentoGrupo);
	
					if (colContas != null && !colContas.isEmpty()) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.impossivel.vinculo.desvinculo");
					}
	
					getControladorUtil().atualizar(hidrometroInstalacaoHistoricoPoco);
				}
			}
	
			// atualizar o indicador de imovel condominio
			if (imovel != null) {
				/**
				 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
				 * acoplar o controle de abrangência de usuário
				 */
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);
	
				if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				} else {
					getControladorAtualizacaoCadastro().atualizar(imovel);
				}
			}
	
			// Desvicular imoveis
			if (imoveisASerDesvinculados != null && !imoveisASerDesvinculados.isEmpty()) {
				Iterator iImoveisASerDesvinculados = imoveisASerDesvinculados.iterator();
	
				while (iImoveisASerDesvinculados.hasNext()) {
					Imovel imovelASerDesvinculado = (Imovel) iImoveisASerDesvinculados.next();
	
					filtroImovel = new FiltroImovel();
	
					filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
	
					// Procura Imovel na base
					imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);
					imovelASerDesvinculado.setUltimaAlteracao(new Date());
					// Verificar se Imovel já foi atualizada por outro usuário
					// durante esta
					// atualização
					// [FS0007] Atualização realizada por outro usuário
					if (imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.atualizacao.timestamp");
					}
	
					/**
					 * alterado por pedro alexandre dia 20/11/2006 alteração feita
					 * para acoplar o controle de abrangência de usuário
					 */
					Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);
	
					if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.acesso.negado.abrangencia");
					} else {
						UsuarioAcao usuarioAcao = UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO;
	
						UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado, usuarioAcao);
	
						OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
						Operacao operacao = new Operacao();
						operacao.setId(Operacao.OPERACAO_ESTABELECER_VINCULO);
						operacaoEfetuada.setOperacao(operacao);
	
						ImovelRegistrarTransacaoHelper helper = new ImovelRegistrarTransacaoHelper();
	
						helper.setImovelCondominio(imovel);
	
						operacaoEfetuada.setArgumentoValor(imovelASerDesvinculado.getId());
	
						getControladorTransacao().processaRegistroOperacaoObjetohelper(usuarioAcaoUsuarioHelper,
								AlteracaoTipo.EXCLUSAO, helper, operacaoEfetuada, ImovelRegistrarTransacaoHelper.TABELA_ID);
	
						getControladorAtualizacaoCadastro().atualizar(imovelASerDesvinculado);
					}
				}
	
			}
	
			// estebelcer os imoveis aos condominios
			if (imoveisASerVinculados != null && !imoveisASerVinculados.isEmpty()) {
	
				Integer anoMesFaturamentoGrupo = repositorioFaturamento.retornaAnoMesGrupoFaturamento(imovelNaBase.getId());
	
				Collection colContas = repositorioMicromedicao.verificarImoveisCicloFaturamento(imoveisASerVinculados, anoMesFaturamentoGrupo);
	
				if (colContas != null && !colContas.isEmpty()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.impossivel.vinculo.desvinculo");
				}
	
				Iterator iImoveisASerVinculados = imoveisASerVinculados.iterator();
	
				while (iImoveisASerVinculados.hasNext()) {
					Imovel imovelASerVinculado = (Imovel) iImoveisASerVinculados.next();
	
					filtroImovel = new FiltroImovel();
	
					filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovelASerVinculado.getId()));
	
					// Procura Imovel na base
					imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);
					imovelASerVinculado.setUltimaAlteracao(new Date());
					// Verificar se Imovel já foi atualizada por outro usuário
					// durante esta
					// atualização
					// [FS0007] Atualização realizada por outro usuário
					if (imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.atualizacao.timestamp");
					}
	
					/**
					 * alterado por pedro alexandre dia 20/11/2006 alteração feita
					 * para acoplar o controle de abrangência de usuário
					 */
					Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);
	
					if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.acesso.negado.abrangencia");
					} else {
						UsuarioAcao usuarioAcao = UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO;
	
						UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado,	usuarioAcao);
	
						OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
						Operacao operacao = new Operacao();
						operacao.setId(Operacao.OPERACAO_ESTABELECER_VINCULO);
						operacaoEfetuada.setOperacao(operacao);
	
						ImovelRegistrarTransacaoHelper helper = new ImovelRegistrarTransacaoHelper();
	
						helper.setImovelCondominio(imovel);
	
						operacaoEfetuada.setArgumentoValor(imovelASerVinculado.getId());
	
						getControladorTransacao().processaRegistroOperacaoObjetohelper(usuarioAcaoUsuarioHelper,
								AlteracaoTipo.INCLUSAO, helper, operacaoEfetuada, ImovelRegistrarTransacaoHelper.TABELA_ID);
	
						getControladorAtualizacaoCadastro().atualizar(imovelASerVinculado);
					}
				}
	
			} else {
				filtroImovel = new FiltroImovel();
	
				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
	
				// Procura Imovel na base
				imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);
				imovel.setUltimaAlteracao(new Date());
				// Verificar se Imovel já foi atualizada por outro usuário durante
				// esta
				// atualização
				// [FS0007] Atualização realizada por outro usuário
				if (imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");
				}
				// imovel sem ninguem vinculado a ele
				imovel.setIndicadorImovelCondominio(Imovel.IMOVEL_NAO_CONDOMINIO);
	
				/**
				 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
				 * acoplar o controle de abrangência de usuário
				 */
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);
	
				if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				} else {
					imovel.setUsuarioParaHistorico(usuarioLogado);
					getControladorAtualizacaoCadastro().atualizar(imovel);
				}
			}
		} catch (ControladorException e){
			throw e;
		} catch (Exception e) {
			throw new ControladorException("Erro ao gerenciar vinculo", e);
		}		
	}

	/**
	 * [UC0098] Manter Vínculos de Imóveis para Rateio de Consumo Atualizar Tipo
	 * Rateio com Vinculo com o Imovel Author: Rafael Santos, Pedro Alexandre
	 * Data: 16/01/2006, 20/11/2006 Desfazer Vinculo ao Imovel
	 * 
	 * @param Imovel
	 * @param imoveisASerVinculados
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public void desfazerVinculo(Imovel imovel, String[] ids, boolean desvincular, Usuario usuarioLogado)
			throws ControladorException, ErroRepositorioException {

		Imovel controle = imovel;

		FiltroImovel filtroImovel = new FiltroImovel();

		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));

		// Procura Imovel na base
		Imovel imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);

		Integer anoMesFaturamentoGrupo0 = repositorioFaturamento.retornaAnoMesGrupoFaturamento(imovelNaBase.getId());

		Collection<Imovel> colImovel0 = new ArrayList();

		Imovel imovelVinculo0 = new Imovel();

		imovelVinculo0.setId(imovelNaBase.getId());

		colImovel0.add(imovelVinculo0);

		Collection colContas0 = repositorioMicromedicao.verificarImoveisCicloFaturamento(colImovel0, anoMesFaturamentoGrupo0);

		if (colContas0 != null && !colContas0.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.impossivel.vinculo.desvinculo");
		}

		imovel.setUltimaAlteracao(new Date());

		Collection imoveisVinculados = repositorioMicromedicao.recuperarImoveisVinculadosAoCondominio(imovel.getId());

		if (imoveisVinculados != null && !imoveisVinculados.isEmpty()) {
			Integer anoMesFaturamentoGrupo = repositorioFaturamento.retornaAnoMesGrupoFaturamento(imovel.getId());

			Collection colContas = repositorioMicromedicao.verificarImoveisCicloFaturamento(imoveisVinculados,
					anoMesFaturamentoGrupo);

			if (colContas != null && !colContas.isEmpty()) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.impossivel.vinculo.desvinculo");
			}
		}

		// Verificar se Imovel já foi atualizada por outro usuário durante esta
		// atualização
		// [FS0007] Atualização realizada por outro usuário
		if (imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// desvincular
		if (desvincular) {
			imovel.setIndicadorImovelCondominio(Imovel.IMOVEL_NAO_CONDOMINIO);

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			} else {
				imovel.setUsuarioParaHistorico(usuarioLogado);
				getControladorAtualizacaoCadastro().atualizar(imovel);
			}
		}

		if (ids != null) {
			for (int i = 0; i < ids.length; i++) {
				String id = ids[i];

				filtroImovel = new FiltroImovel();

				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, id.trim()));

				imovel = (Imovel) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()).iterator().next());

				Integer anoMesFaturamentoGrupo = repositorioFaturamento.retornaAnoMesGrupoFaturamento(imovel.getId());

				Collection<Imovel> colImovel = new ArrayList();

				Imovel imovelVinculo = new Imovel();

				imovelVinculo.setId(imovel.getId());

				colImovel.add(imovelVinculo);

				Collection colContas = repositorioMicromedicao.verificarImoveisCicloFaturamento(colImovel, anoMesFaturamentoGrupo);

				if (colContas != null && !colContas.isEmpty()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.impossivel.vinculo.desvinculo");
				}

				imovel.setImovelCondominio(null);
				imovel.setIndicadorImovelAreaComum(ConstantesSistema.NAO);

				filtroImovel = new FiltroImovel();

				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
				imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);
				imovel.setUltimaAlteracao(new Date());
				// Verificar se Imovel já foi atualizada por outro usuário
				// durante esta
				// atualização
				// [FS0007] Atualização realizada por outro usuário
				if (imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");
				}

				/**
				 * alterado por pedro alexandre dia 20/11/2006 alteração feita
				 * para acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

				if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				} else {
					UsuarioAcao usuarioAcao = UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO;

					UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado, usuarioAcao);

					OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
					Operacao operacao = new Operacao();
					operacao.setId(Operacao.OPERACAO_DESFAZER_VINCULO);
					operacaoEfetuada.setOperacao(operacao);

					ImovelRegistrarTransacaoHelper helper = new ImovelRegistrarTransacaoHelper();

					helper.setImovelCondominio(controle);

					operacaoEfetuada.setArgumentoValor(new Integer(id.trim()));

					getControladorTransacao().processaRegistroOperacaoObjetohelper(usuarioAcaoUsuarioHelper,
							AlteracaoTipo.EXCLUSAO, helper, operacaoEfetuada, ImovelRegistrarTransacaoHelper.TABELA_ID);

					getControladorAtualizacaoCadastro().atualizar(imovel);
				}
			}
		}
	}

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades Autor: Sávio Luiz Data:
	 * 04/01/2006
	 */
	public Collection registrarLeiturasAnormalidades(
			Collection colecaoMedicaoHistorico, Integer idFaturamentoGrupo,
			Integer anoMesReferencia, Usuario usuario, String nomeArquivo)
			throws ControladorException {

		try {

			// cria uma coleção das leituras e anormalidades (objetos Medicao
			// Historico) que não serão registradas e sim
			// para gerar um relatório.
			Collection gerarRelatorioObjetosNaoRegistrados = new ArrayList();

			Calendar dataAtualCalendar = Calendar.getInstance();
			dataAtualCalendar.set(Calendar.MILLISECOND, 0);
			dataAtualCalendar.set(Calendar.SECOND, 0);

			Date dataAtual = dataAtualCalendar.getTime();

			Integer idImovelValido = null;

			// cria uma coleção de leituras e anormalidades (objetos Medicao
			// Historico) queserão registradas
			Collection registrarLeiturasAnormalidades = new ArrayList();

			Iterator medicaoHistoricoIterator = colecaoMedicaoHistorico
					.iterator();

			Integer quantidadeMedicoesTipo = null;
			// Integer idImovelPesquisa = null;

			Collection colecaoIdsImoveisAgua = new ArrayList();
			Collection colecaoIdsImoveisPoco = new ArrayList();
			Map<Integer, MedicaoHistorico> mapTxtAgua = new HashMap();
			Map<Integer, MedicaoHistorico> mapTxtPoco = new HashMap();
			Map<Integer, MedicaoHistorico> mapTxtSemMedicao = new HashMap();
			// verifica a quantidade de ano mes que repete mais para ser
			// inserido em cronograma faturamento atividade
			Map<Date, Integer> mapQuantidadeAnoMesRepetidos = new HashMap();
			// passa a data que está como string para data e verifica se é
			// válida
			Date dataLeituraAtualInformada = null;

			while (medicaoHistoricoIterator.hasNext()) {
				StringBuilder dadosRelatorio = new StringBuilder();

				// verifica se a medição historico vai ser gerada no relatório
				// ou se
				// registrado
				// se false será registrado
				// se true será gerado no relatório
				boolean gerarRelatorio = false;

				boolean dataInvalida = false;

				MedicaoHistorico medicaoHistoricoTxt = (MedicaoHistorico) medicaoHistoricoIterator
						.next();
				Integer quantidadeFuncionariosNaBase = null;
				if (medicaoHistoricoTxt.getFuncionario() != null
						&& medicaoHistoricoTxt.getFuncionario().getId() != null) {
					try {
						quantidadeFuncionariosNaBase = repositorioFuncionario
								.verificarExistenciaFuncionario(medicaoHistoricoTxt
										.getFuncionario().getId());

					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}
				// verifica se existe o funcionario na base
				if (quantidadeFuncionariosNaBase != null
						&& quantidadeFuncionariosNaBase <= 0) {
					dadosRelatorio
							.append("Matrícula do Funcionário Inexistente.");
					dadosRelatorio.append(System.getProperty("line.separator"));
				}

				// recupera a data como string do da medicaoHistoricoTxt
				String dataLeituraAtualString = medicaoHistoricoTxt
						.getDataLeituraParaRegistrar();

				SimpleDateFormat dataTxt = new SimpleDateFormat("ddMMyyyy");

				try {

					dataLeituraAtualInformada = dataTxt
							.parse(dataLeituraAtualString);

					if (!Util
							.validarDiaMesAnoSemBarraNovo(dataLeituraAtualString)) {
						dataInvalida = true;
					}

				} catch (ParseException e) {
					dataInvalida = true;
				}

				// Obtém o anoMes da data de leitura atual informada
				Integer anoMes = Util.formataAnoMes(dataLeituraAtualInformada);

				String anoMesString = "" + anoMes;
				String anoMesReferenciaString = "" + anoMesReferencia;
				if ((anoMesString != null && anoMesString.length() >= 6)
						&& (anoMesReferenciaString != null && anoMesReferenciaString
								.length() >= 6)) {

					// Compara o anoMes com o anoMesReferencia
					if (!Util.compararAnoMesReferencia(anoMes,
							anoMesReferencia, "=")) {

						// Adiciona mais um mês
						Integer anoMesReferenciaMaisUmMes = Util
								.somarData(anoMesReferencia);
						Integer anoMesReferenciaMenosUmMes = Util
								.subtrairData(anoMesReferencia);

						if (!Util.compararAnoMesReferencia(anoMes,
								anoMesReferenciaMaisUmMes, "=")) {
							if (!Util.compararAnoMesReferencia(anoMes,
									anoMesReferenciaMenosUmMes, "=")) {
								gerarRelatorio = true;
								dadosRelatorio
										.append("Data de leitura incompatível com o mês/ano de faturamento.");
								dadosRelatorio.append(System
										.getProperty("line.separator"));
							}
						}

					}
				}

				// caso a data seja válida e seja depois a atual cria uma string
				// para criar um relatório
				if (dataInvalida || dataLeituraAtualInformada.after(new Date())) {
					gerarRelatorio = true;
					dadosRelatorio.append("Data de leitura inválida.");
					dadosRelatorio.append(System.getProperty("line.separator"));
				}

				Integer quantidadeImoveisNaBase = null;
				if (medicaoHistoricoTxt.getImovel().getId() != null) {
					try {
						quantidadeImoveisNaBase = repositorioImovel
								.verificarExistenciaImovel(medicaoHistoricoTxt
										.getImovel().getId());
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}

				// verifica a existência do imóvel na base
				if (quantidadeImoveisNaBase == null
						|| quantidadeImoveisNaBase <= 0) {
					gerarRelatorio = true;
					dadosRelatorio.append("Matrícula do Imóvel Inexistente.");
					dadosRelatorio.append(System.getProperty("line.separator"));

				}
				// verifica a existência da leitura anormalidade
				Object[] leituraAnormalidade = null;
				Integer idLeituraAnormalidade = null;
				Short indicadorImovelSemHidrometro = null;
				if (medicaoHistoricoTxt.getLeituraAnormalidadeInformada()
						.getId() != null) {
					try {
						leituraAnormalidade = repositorioMicromedicao
								.pesquisarLeituraAnormalidade(medicaoHistoricoTxt
										.getLeituraAnormalidadeInformada()
										.getId());
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}

				if (leituraAnormalidade != null) {

					if (leituraAnormalidade[0] != null) {
						idLeituraAnormalidade = (Integer) leituraAnormalidade[0];
					}

					if (leituraAnormalidade[1] != null) {
						indicadorImovelSemHidrometro = (Short) leituraAnormalidade[1];
					}
				}

				// verificar tipo de medicao

				// verifica se existe hidrometro instalação histórico para o
				// imóvel
				// da medição histórico
				Integer idHidrometroInstalacaoHistorico = null;
				if (medicaoHistoricoTxt.getImovel().getId() != null) {

					if (medicaoHistoricoTxt.getMedicaoTipo().getId()
							.equals(MedicaoTipo.LIGACAO_AGUA)) {
						try {
							idHidrometroInstalacaoHistorico = repositorioMicromedicao
									.verificarExistenciaHidrometroInstalacaoHistoricoTipoAgua(medicaoHistoricoTxt
											.getImovel().getId());
						} catch (ErroRepositorioException e) {
							throw new ControladorException("erro.sistema", e);
						}
					} else {
						if (medicaoHistoricoTxt.getMedicaoTipo().getId()
								.equals(MedicaoTipo.POCO)) {
							try {
								idHidrometroInstalacaoHistorico = repositorioMicromedicao
										.verificarExistenciaHidrometroInstalacaoHistoricoTipoPoco(medicaoHistoricoTxt
												.getImovel().getId());
							} catch (ErroRepositorioException e) {
								throw new ControladorException("erro.sistema",
										e);
							}
						}
					}
				}

				if (medicaoHistoricoTxt.getMedicaoTipo().getId() != null) {

					try {
						quantidadeMedicoesTipo = repositorioMicromedicao
								.verificarExistenciaMedicaoTipo(medicaoHistoricoTxt
										.getMedicaoTipo().getId());
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}

				// verifica se existe a medição tipo na base
				if (quantidadeMedicoesTipo == null
						|| quantidadeMedicoesTipo <= 0) {
					if (medicaoHistoricoTxt.getMedicaoTipo().getId() != 0) {
						gerarRelatorio = true;
						dadosRelatorio.append("Tipo de Medição Inexistente.");
						dadosRelatorio.append(System
								.getProperty("line.separator"));

					} else {

						// verificar se existe hidrometro instalado e a leitura
						// informada seja maior que 0
						if (medicaoHistoricoTxt.getLeituraAtualInformada() > 0
								&& idHidrometroInstalacaoHistorico == null) {

							gerarRelatorio = true;
							dadosRelatorio
									.append("Movimentação para ligação sem hidrômetro.");
							dadosRelatorio.append(System
									.getProperty("line.separator"));
						} else {
							// caso a anromalidade informada não seja compatível
							// com
							// ligação sem hidrometro e o hidrometro
							// instalação histórico sejá nulo
							if (indicadorImovelSemHidrometro
									.equals(LeituraAnormalidade.INDICADOR_IMOVEL_SEM_HIDROMETRO)) {
								gerarRelatorio = true;
								dadosRelatorio
										.append("Anormalidade não permitida para ligação sem hidrômetro.");
								dadosRelatorio.append(System
										.getProperty("line.separator"));
							}
						}

					}
				} else {

					if (medicaoHistoricoTxt.getMedicaoTipo().getId()
							.equals(MedicaoTipo.LIGACAO_AGUA)) {
						if (idHidrometroInstalacaoHistorico == null) {
							gerarRelatorio = true;
							dadosRelatorio
									.append("Movimento para ligação de agua sem hidrômetro.");
							dadosRelatorio.append(System
									.getProperty("line.separator"));
						}

					} else {
						if (medicaoHistoricoTxt.getMedicaoTipo().getId()
								.equals(MedicaoTipo.POCO)) {
							if (idHidrometroInstalacaoHistorico == null) {
								gerarRelatorio = true;
								dadosRelatorio
										.append("Movimento para poço sem hidrômetro.");
								dadosRelatorio.append(System
										.getProperty("line.separator"));
							}

						}
					}
				}

				Integer idLeituraAnormalidadeInformada = null;
				if (medicaoHistoricoTxt.getLeituraAnormalidadeInformada() != null) {
					idLeituraAnormalidadeInformada = medicaoHistoricoTxt
							.getLeituraAnormalidadeInformada().getId();
				}

				// verificar existencia de código de anormalidade de leitura
				if (idLeituraAnormalidade == null
						&& idLeituraAnormalidadeInformada != null
						&& !idLeituraAnormalidadeInformada.equals(0)) {
					gerarRelatorio = true;
					dadosRelatorio
							.append("Código da Anormalidade de Leitura inexistente.");
					dadosRelatorio.append(System.getProperty("line.separator"));

				}

				// verificar existencia de código de anormalidade de leitura
				if (medicaoHistoricoTxt
						.getIndicadorConfirmacaoLeitura()
						.equals(MedicaoHistorico.INDICADOR_CONFIRMACAO_LEITURA_ZERO)
						|| medicaoHistoricoTxt
								.getIndicadorConfirmacaoLeitura()
								.equals(MedicaoHistorico.INDICADOR_CONFIRMACAO_LEITURA_UM)) {
					gerarRelatorio = true;
					dadosRelatorio
							.append("Indicador de confirmação de Leitura inválido.");
					dadosRelatorio.append(System.getProperty("line.separator"));

				}
				// se a medição histórico passar por algum fluxo secundário
				// então essa medição histórico irá para o relatório
				if (gerarRelatorio) {
					medicaoHistoricoTxt.setGerarRelatorio(dadosRelatorio
							.toString());
					gerarRelatorioObjetosNaoRegistrados
							.add(medicaoHistoricoTxt);
				} else {
					Integer idImovel = medicaoHistoricoTxt.getImovel().getId();
					// idImovelPesquisa = idImovel;
					// Integer idImovelVerificado = idImovel;
					Integer idMedicaoTipo = medicaoHistoricoTxt
							.getMedicaoTipo().getId();
					// caso a map não esteja vazio
					if (mapQuantidadeAnoMesRepetidos != null
							&& !mapQuantidadeAnoMesRepetidos.isEmpty()) {
						// recupe a quantidade de vezes que aquele anoMes foi
						// repetido
						Integer quantidadeRegistros = mapQuantidadeAnoMesRepetidos
								.get(dataLeituraAtualInformada);
						// caso a quantidade de amoMes não tenha sido inserido
						// no map ainda
						// então inseri uma nova tupla no map
						if (quantidadeRegistros == null
								|| quantidadeRegistros.equals("")) {
							mapQuantidadeAnoMesRepetidos.put(
									dataLeituraAtualInformada, 1);
						} else {
							// caso contrário atualiza o valor
							mapQuantidadeAnoMesRepetidos.put(
									dataLeituraAtualInformada,
									quantidadeRegistros + 1);
						}
					} else {
						mapQuantidadeAnoMesRepetidos.put(
								dataLeituraAtualInformada, 1);
					}

					medicaoHistoricoTxt.setGerarRelatorio(dadosRelatorio
							.toString());
					// caso o imóvel não tenha nem ligação agua nem ligação poço
					if (idMedicaoTipo != null && idMedicaoTipo.equals(0)) {
						mapTxtSemMedicao.put(idImovel, medicaoHistoricoTxt);
					} else {
						if (idMedicaoTipo != null
								&& idMedicaoTipo
										.equals(MedicaoTipo.LIGACAO_AGUA)) {
							colecaoIdsImoveisAgua.add(idImovel);
							mapTxtAgua.put(idImovel, medicaoHistoricoTxt);
						} else {
							colecaoIdsImoveisPoco.add(idImovel);
							mapTxtPoco.put(idImovel, medicaoHistoricoTxt);
						}
					}
				}
			}

			Collection colecaoParmsMedicao = null;
			Object[] idsImoveisLimitadoAguaArray = colecaoIdsImoveisAgua
					.toArray();
			Object[] idsImoveisLimitadoPocoArray = colecaoIdsImoveisPoco
					.toArray();
			boolean terminou = false;
			int limiteInferior = 0;
			int limiteSuperior = 0;
			// começa com a medição tipo Agua
			Integer idMedicaoTipo = MedicaoTipo.LIGACAO_AGUA;
			Collection colecaoLimitadaIdsImoveis = null;
			while (!terminou) {
				colecaoLimitadaIdsImoveis = new ArrayList();
				if (idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)) {
					if ((limiteSuperior + 100) <= idsImoveisLimitadoAguaArray.length) {
						limiteSuperior = limiteSuperior + 100;
					} else {
						limiteSuperior = idsImoveisLimitadoAguaArray.length;
					}
				}
				if (idMedicaoTipo.equals(MedicaoTipo.POCO)) {
					if ((limiteSuperior + 100) <= idsImoveisLimitadoPocoArray.length) {
						limiteSuperior = limiteSuperior + 100;
					} else {
						limiteSuperior = idsImoveisLimitadoPocoArray.length;
					}
				}
				for (; limiteInferior < limiteSuperior; limiteInferior++) {
					if (idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)) {
						colecaoLimitadaIdsImoveis
								.add(idsImoveisLimitadoAguaArray[limiteInferior]);
					}
					if (idMedicaoTipo.equals(MedicaoTipo.POCO)) {
						colecaoLimitadaIdsImoveis
								.add(idsImoveisLimitadoPocoArray[limiteInferior]);
					}

				}

				Collection colecaoParmsMedicaoLimitada = null;
				if (colecaoLimitadaIdsImoveis != null
						&& !colecaoLimitadaIdsImoveis.isEmpty()) {
					try {
						colecaoParmsMedicaoLimitada = repositorioMicromedicao
								.pesquisarMedicaoHistorico(
										colecaoLimitadaIdsImoveis,
										anoMesReferencia, idMedicaoTipo);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
					colecaoParmsMedicao = new ArrayList();
					colecaoParmsMedicao.addAll(colecaoParmsMedicaoLimitada);
				}

				Collection colecaoIdsImoveisAtualizar = new ArrayList();

				Collection colecaoMedicaoHistoricoAtualizar = new ArrayList();

				if (colecaoParmsMedicao != null
						&& !colecaoParmsMedicao.isEmpty()) {

					Iterator iteParmsMedicao = colecaoParmsMedicao.iterator();

					// id medição histórico
					Integer idMedicaoHistorico = null;
					Integer idImovel = null;

					while (iteParmsMedicao.hasNext()) {
						Object[] parmsMedicao = (Object[]) iteParmsMedicao
								.next();
						if (parmsMedicao != null) {

							if (parmsMedicao[0] != null) {
								idMedicaoHistorico = (Integer) parmsMedicao[0];
							}
							// id do imóvel
							if (parmsMedicao[1] != null) {
								idImovel = (Integer) parmsMedicao[1];
								if (idImovelValido == null) {
									idImovelValido = idImovel;
								}
							}

						}
						if (idMedicaoHistorico != null) {
							// cria um objeto de medição histórico para ser
							// atualizado
							MedicaoHistorico medicaoHistoricoAtualizar = new MedicaoHistorico();

							MedicaoHistorico medicaoHistoricoTxt = null;

							if (idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)) {
								medicaoHistoricoTxt = mapTxtAgua.get(idImovel);
							}
							if (idMedicaoTipo.equals(MedicaoTipo.POCO)) {
								medicaoHistoricoTxt = mapTxtPoco.get(idImovel);
							}

							// caso a medição não tenha funcionario na base
							// então
							// inseri com nulo o funcionario e manda essa
							// medição
							// para o relatório
							if (medicaoHistoricoTxt.getGerarRelatorio() != null
									&& medicaoHistoricoTxt
											.getGerarRelatorio()
											.trim()
											.equalsIgnoreCase(
													"Matrícula do Funcionário Inexistente.")) {

								/*
								 * gerarRelatorioObjetosNaoRegistrados
								 * .add(medicaoHistoricoTxt);
								 */
								medicaoHistoricoAtualizar.setFuncionario(null);
							} else {
								// atualiza o id funcionario com null caso não
								// exista na
								// base
								// ou com o valor do txt
								if (medicaoHistoricoTxt.getFuncionario() != null) {
									Funcionario funcionario = new Funcionario();
									funcionario.setId(medicaoHistoricoTxt
											.getFuncionario().getId());
									medicaoHistoricoAtualizar
											.setFuncionario(funcionario);
								}
							}

							// codigo da anormalidade de leitura informada
							if (medicaoHistoricoTxt
									.getLeituraAnormalidadeInformada().getId()
									.intValue() == 0) {
								medicaoHistoricoAtualizar
										.setLeituraAnormalidadeInformada(null);

								// id Leitura Anormalidade Faturamento
								medicaoHistoricoAtualizar
										.setLeituraAnormalidadeFaturamento(null);
							} else {
								medicaoHistoricoAtualizar
										.setLeituraAnormalidadeInformada(medicaoHistoricoTxt
												.getLeituraAnormalidadeInformada());

								// id Leitura Anormalidade Faturamento
								medicaoHistoricoAtualizar
										.setLeituraAnormalidadeFaturamento(medicaoHistoricoTxt
												.getLeituraAnormalidadeInformada());
							}

							// data atual da leitura informada
							medicaoHistoricoAtualizar
									.setDataLeituraAtualInformada(dataLeituraAtualInformada);

							// data da leitura do campo
							medicaoHistoricoAtualizar
									.setDataLeituraCampo(dataLeituraAtualInformada);

							// data da leitura atual faturamento
							medicaoHistoricoAtualizar
									.setDataLeituraAtualFaturamento(dataLeituraAtualInformada);

							// com a leitura informada
							if (medicaoHistoricoTxt.getLeituraAtualInformada()
									.intValue() == 0) {
								medicaoHistoricoAtualizar
										.setLeituraAtualInformada(null);
								medicaoHistoricoAtualizar.setLeituraCampo(null);
							} else {
								medicaoHistoricoAtualizar
										.setLeituraAtualInformada(medicaoHistoricoTxt
												.getLeituraAtualInformada());
								medicaoHistoricoAtualizar
										.setLeituraCampo(medicaoHistoricoTxt
												.getLeituraAtualInformada());
							}
							medicaoHistoricoAtualizar.setId(idMedicaoHistorico);
							medicaoHistoricoAtualizar
									.setUltimaAlteracao(dataAtual);

							/*
							 * Atualização da coluna situação da leitura quando
							 * já existe o MEDICAO_HISTORICO. Alteração feita no
							 * [FS0011]- inclusão do item 5 data: 30/07/2007
							 */
							LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();

							if (medicaoHistoricoTxt.getLeituraAtualInformada()
									.intValue() == 0) {
								leituraSituacaoAtual
										.setId(LeituraSituacao.NAO_REALIZADA);
								medicaoHistoricoAtualizar
										.setLeituraSituacaoAtual(leituraSituacaoAtual);
							} else {
								if (Integer.parseInt(medicaoHistoricoTxt
										.getIndicadorConfirmacaoLeitura()) == 0) {
									leituraSituacaoAtual
											.setId(LeituraSituacao.REALIZADA);
									medicaoHistoricoAtualizar
											.setLeituraSituacaoAtual(leituraSituacaoAtual);
								} else {
									leituraSituacaoAtual
											.setId(LeituraSituacao.CONFIRMADA);
									medicaoHistoricoAtualizar
											.setLeituraSituacaoAtual(leituraSituacaoAtual);
								}
							}

							medicaoHistoricoAtualizar
									.setIndicadorAnalisado(MedicaoHistorico.INDICADOR_ANALISADO_NAO);

							// leiturista
							Leiturista leiturista = null;
							Integer idLeiturista = repositorioMicromedicao
									.pesquisarLeituristaImovel(idImovel);

							if (idLeiturista != null) {
								leiturista = new Leiturista();
								leiturista.setId(idLeiturista);
							}

							medicaoHistoricoAtualizar.setLeiturista(leiturista);

							// verifica se não contem a medição historico na
							// coleção
							// que irá inserir
							if (!colecaoMedicaoHistoricoAtualizar
									.contains(medicaoHistoricoAtualizar)) {

								colecaoMedicaoHistoricoAtualizar
										.add(medicaoHistoricoAtualizar);
							}
						}

						colecaoIdsImoveisAtualizar.add(idImovel);
					}
				}
				colecaoParmsMedicao = null;

				// remove todos os ids dos imóveis que foram ser atualizados

				colecaoLimitadaIdsImoveis.removeAll(colecaoIdsImoveisAtualizar);

				Collection colecaoParmsMedicaoAnterior = null;

				// caso não tenha dados do mes anterior,então é guardado os
				// imoveis e pesquisado novamento com 2 meses anteriores
				Collection colecaoIdsImoveisNaoAnterior = new ArrayList();
				colecaoIdsImoveisNaoAnterior.addAll(colecaoLimitadaIdsImoveis);

				int anoMesAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia,
						1);

				if (colecaoLimitadaIdsImoveis != null
						&& !colecaoLimitadaIdsImoveis.isEmpty()) {
					try {
						colecaoParmsMedicaoAnterior = repositorioMicromedicao
								.pesquisarMedicaoHistoricoAnterior(
										colecaoLimitadaIdsImoveis,
										anoMesAnterior, idMedicaoTipo);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}
				Map<Integer, MedicaoHistoricoAnteriorHelper> mapMedicaoHistoricoAnterior = null;

				if (colecaoParmsMedicaoAnterior != null
						&& !colecaoParmsMedicaoAnterior.isEmpty()) {

					Iterator iteParmsMedicaoAnterior = colecaoParmsMedicaoAnterior
							.iterator();

					mapMedicaoHistoricoAnterior = new HashMap();

					while (iteParmsMedicaoAnterior.hasNext()) {
						Object[] dadosAnterioresMedicaoHistorico = (Object[]) iteParmsMedicaoAnterior
								.next();

						if (dadosAnterioresMedicaoHistorico != null) {
							Integer idImovel = null;
							MedicaoHistoricoAnteriorHelper medicaoHistoricoAnteriorHelper = new MedicaoHistoricoAnteriorHelper();

							if (dadosAnterioresMedicaoHistorico[0] != null) {
								medicaoHistoricoAnteriorHelper
										.setDataLeituraAnteriorFaturamento((Date) dadosAnterioresMedicaoHistorico[0]);
							} else {
								medicaoHistoricoAnteriorHelper
										.setDataLeituraAnteriorFaturamento(null);
							}

							if (dadosAnterioresMedicaoHistorico[1] != null) {
								medicaoHistoricoAnteriorHelper
										.setLeituraAtualMesAnteriorFaturamento(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[1]
														.toString()));
							} else {
								medicaoHistoricoAnteriorHelper
										.setLeituraAtualMesAnteriorFaturamento(0);
							}

							if (dadosAnterioresMedicaoHistorico[2] != null) {
								medicaoHistoricoAnteriorHelper
										.setLeituraAtualMesAnteriorInformada(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[2]
														.toString()));
							} else {
								medicaoHistoricoAnteriorHelper
										.setLeituraAtualMesAnteriorInformada(0);
							}

							if (dadosAnterioresMedicaoHistorico[3] != null) {
								medicaoHistoricoAnteriorHelper
										.setIdLeituraSituacaoAnterior((Integer) dadosAnterioresMedicaoHistorico[3]);
							} else {
								medicaoHistoricoAnteriorHelper
										.setIdLeituraSituacaoAnterior(null);
							}
							if (dadosAnterioresMedicaoHistorico[4] != null) {
								medicaoHistoricoAnteriorHelper
										.setIdHidrometroInstalacaoHistorico((Integer) dadosAnterioresMedicaoHistorico[4]);
							}

							if (dadosAnterioresMedicaoHistorico[5] != null) {
								medicaoHistoricoAnteriorHelper
										.setDataInstacao((Date) dadosAnterioresMedicaoHistorico[5]);
							}
							// se for por imovel então 5 senão se for por
							// ligação
							// agua
							// então
							if (dadosAnterioresMedicaoHistorico[6] != null) {
								idImovel = (Integer) dadosAnterioresMedicaoHistorico[6];
							}

							mapMedicaoHistoricoAnterior.put(idImovel,
									medicaoHistoricoAnteriorHelper);
							colecaoIdsImoveisNaoAnterior.remove(idImovel);
						}
					}
				}

				colecaoParmsMedicaoAnterior = null;

				// caso algum imovel não foi retornado no ano mês anterior
				// então faz uma nova pesquisa passando 2 meses anteriores
				if (colecaoIdsImoveisNaoAnterior != null
						&& !colecaoIdsImoveisNaoAnterior.isEmpty()) {

					int doisAnoMesAnterior = Util.subtrairMesDoAnoMes(
							anoMesReferencia, 2);

					if (mapMedicaoHistoricoAnterior == null
							|| mapMedicaoHistoricoAnterior.size() == 0) {
						mapMedicaoHistoricoAnterior = new HashMap();
					}

					try {
						colecaoParmsMedicaoAnterior = repositorioMicromedicao
								.pesquisarMedicaoHistoricoAnterior(
										colecaoIdsImoveisNaoAnterior,
										doisAnoMesAnterior, idMedicaoTipo);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}

					Iterator iteParmsMedicaoDoisMesesAnterior = colecaoParmsMedicaoAnterior
							.iterator();

					while (iteParmsMedicaoDoisMesesAnterior.hasNext()) {
						Object[] dadosAnterioresMedicaoHistorico = (Object[]) iteParmsMedicaoDoisMesesAnterior
								.next();

						if (dadosAnterioresMedicaoHistorico != null) {
							Integer idImovel = null;
							MedicaoHistoricoAnteriorHelper medicaoHistoricoAnteriorHelper = new MedicaoHistoricoAnteriorHelper();

							if (dadosAnterioresMedicaoHistorico[0] != null) {
								medicaoHistoricoAnteriorHelper
										.setDataLeituraAnteriorFaturamento((Date) dadosAnterioresMedicaoHistorico[0]);
							} else {
								medicaoHistoricoAnteriorHelper
										.setDataLeituraAnteriorFaturamento(null);
							}

							if (dadosAnterioresMedicaoHistorico[1] != null) {
								medicaoHistoricoAnteriorHelper
										.setLeituraAtualMesAnteriorFaturamento(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[1]
														.toString()));
							} else {
								medicaoHistoricoAnteriorHelper
										.setLeituraAtualMesAnteriorFaturamento(0);
							}

							if (dadosAnterioresMedicaoHistorico[2] != null) {
								medicaoHistoricoAnteriorHelper
										.setLeituraAtualMesAnteriorInformada(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[2]
														.toString()));
							} else {
								medicaoHistoricoAnteriorHelper
										.setLeituraAtualMesAnteriorInformada(0);
							}

							if (dadosAnterioresMedicaoHistorico[3] != null) {
								medicaoHistoricoAnteriorHelper
										.setIdLeituraSituacaoAnterior((Integer) dadosAnterioresMedicaoHistorico[3]);
							} else {
								medicaoHistoricoAnteriorHelper
										.setIdLeituraSituacaoAnterior(null);
							}
							if (dadosAnterioresMedicaoHistorico[4] != null) {
								medicaoHistoricoAnteriorHelper
										.setIdHidrometroInstalacaoHistorico((Integer) dadosAnterioresMedicaoHistorico[4]);
							}

							if (dadosAnterioresMedicaoHistorico[5] != null) {
								medicaoHistoricoAnteriorHelper
										.setDataInstacao((Date) dadosAnterioresMedicaoHistorico[5]);
							}
							// se for por imovel então 5 senão se for por
							// ligação
							// agua
							// então
							if (dadosAnterioresMedicaoHistorico[6] != null) {
								idImovel = (Integer) dadosAnterioresMedicaoHistorico[6];
							}

							mapMedicaoHistoricoAnterior.put(idImovel,
									medicaoHistoricoAnteriorHelper);
						}
					}
				}

				Date dataLeituraAnteriorFaturamento = null;
				Date dataInstacao = null;
				int leituraAtualMesAnteriorFaturamento = 0;
				int leituraAtualMesAnteriorInformada = 0;
				Integer idLeituraSituacaoAnterior = null;
				Integer idHidrometroInstalacaoHistorico = null;

				if (colecaoLimitadaIdsImoveis != null
						&& !colecaoLimitadaIdsImoveis.isEmpty()) {
					Iterator iteIdsImoveis = colecaoLimitadaIdsImoveis
							.iterator();

					while (iteIdsImoveis.hasNext()) {
						Integer idImovelParaInsercao = (Integer) iteIdsImoveis
								.next();

						MedicaoHistorico medicaoHistoricoRegistrar = new MedicaoHistorico();

						MedicaoHistorico medicaoHistoricoTxt = null;
						if (idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)) {

							medicaoHistoricoTxt = mapTxtAgua
									.get(idImovelParaInsercao);

							/*
							 * Colocado por Raphael Rossiter em 04/03/2009 OBJ:
							 * Solucionar o problema das CRCs 1203, 1088, 1291
							 * 
							 * HIDROMETRO_INSTALACAO_HISTORICO
							 */

							try {

								idHidrometroInstalacaoHistorico = repositorioMicromedicao
										.verificarExistenciaHidrometroInstalacaoHistoricoTipoAgua(idImovelParaInsercao);

							} catch (ErroRepositorioException e) {
								throw new ControladorException("erro.sistema",
										e);
							}
						}

						if (idMedicaoTipo.equals(MedicaoTipo.POCO)) {

							medicaoHistoricoTxt = mapTxtPoco
									.get(idImovelParaInsercao);

							/*
							 * Colocado por Raphael Rossiter em 04/03/2009 OBJ:
							 * Solucionar o problema das CRCs 1203, 1088, 1291
							 * 
							 * HIDROMETRO_INSTALACAO_HISTORICO
							 */

							try {

								idHidrometroInstalacaoHistorico = repositorioMicromedicao
										.verificarExistenciaHidrometroInstalacaoHistoricoTipoPoco(idImovelParaInsercao);

							} catch (ErroRepositorioException e) {
								throw new ControladorException("erro.sistema",
										e);
							}
						}

						if (mapMedicaoHistoricoAnterior != null
								&& !mapMedicaoHistoricoAnterior.isEmpty()) {

							MedicaoHistoricoAnteriorHelper medicaoHistoricoAnteriorHelper = mapMedicaoHistoricoAnterior
									.get(idImovelParaInsercao);

							if (medicaoHistoricoAnteriorHelper != null) {

								dataLeituraAnteriorFaturamento = medicaoHistoricoAnteriorHelper
										.getDataLeituraAnteriorFaturamento();

								dataInstacao = medicaoHistoricoAnteriorHelper
										.getDataInstacao();

								leituraAtualMesAnteriorFaturamento = medicaoHistoricoAnteriorHelper
										.getLeituraAtualMesAnteriorFaturamento();

								leituraAtualMesAnteriorInformada = medicaoHistoricoAnteriorHelper
										.getLeituraAtualMesAnteriorInformada();

								idLeituraSituacaoAnterior = medicaoHistoricoAnteriorHelper
										.getIdLeituraSituacaoAnterior();
							} else {

								/*
								 * Caso o imóvel que está sendo registrada a
								 * leitura não tenha leitura informada para o
								 * mês anterior, atribuir 0 (zero) para leitura
								 * anterior faturamento.
								 */
								leituraAtualMesAnteriorFaturamento = 0;

								/*
								 * Caso o imóvel que está sendo registrada a
								 * leitura não tenha leitura informada para o
								 * mês anterior, atribuir a data de instalação
								 * do hidrômetro para a data de leitura anterior
								 * do faturamento
								 */
								dataLeituraAnteriorFaturamento = null;

								try {

									dataInstacao = repositorioMicromedicao
											.pesquisarDataInstalacaoHidrometro(idHidrometroInstalacaoHistorico);

								} catch (ErroRepositorioException e) {
									throw new ControladorException(
											"erro.sistema", e);
								}

								// Leitura informada será igual a zero
								leituraAtualMesAnteriorInformada = 0;

								// Situacao da leitura anterior será nula
								idLeituraSituacaoAnterior = null;
							}
						}

						if (medicaoHistoricoTxt.getMedicaoTipo().getId()
								.equals(MedicaoTipo.LIGACAO_AGUA)) {
							// seta o id do imovel na ligação agua com null
							// caso não exista
							// na
							// base
							// ou com o valor do txt
							LigacaoAgua ligacaoAgua = new LigacaoAgua();
							ligacaoAgua.setId(medicaoHistoricoTxt.getImovel()
									.getId());
							medicaoHistoricoRegistrar
									.setLigacaoAgua(ligacaoAgua);

						} else {
							if (medicaoHistoricoTxt.getMedicaoTipo().getId()
									.equals(MedicaoTipo.POCO)) {
								// seta o id do imovel com null caso não exista
								// na
								// base
								// ou com o valor do txt
								Imovel imovel = new Imovel();
								imovel.setId(medicaoHistoricoTxt.getImovel()
										.getId());
								medicaoHistoricoRegistrar.setImovel(imovel);

							}

						}

						// ano mes referência do header do arquivo
						medicaoHistoricoRegistrar
								.setAnoMesReferencia(anoMesReferencia);

						// seta o tipo de medição
						medicaoHistoricoRegistrar
								.setMedicaoTipo(medicaoHistoricoTxt
										.getMedicaoTipo());

						// numero de vezes consecutivas anormalidades
						medicaoHistoricoRegistrar
								.setNumeroVezesConsecutivasOcorrenciaAnormalidade(null);

						// verifica se o mes anterior é diferente de nulo
						if (dataLeituraAnteriorFaturamento != null) {
							// seta a data de leitura anterior do faturamento
							medicaoHistoricoRegistrar
									.setDataLeituraAnteriorFaturamento(dataLeituraAnteriorFaturamento);
							// se não seta a data de instalação do historico
							// instalação hidrometro
						} else {

							/*
							 * Caso o imóvel que está sendo registrada a leitura
							 * não tenha leitura informada para o mês anterior,
							 * atribuir a data de instalação do hidrômetro para
							 * a data de leitura anterior do faturamento
							 */
							try {

								dataInstacao = repositorioMicromedicao
										.pesquisarDataInstalacaoHidrometro(idHidrometroInstalacaoHistorico);

							} catch (ErroRepositorioException e) {
								throw new ControladorException("erro.sistema",
										e);
							}

							if (dataInstacao == null) {
								// seta a data de leitura anterior do
								// faturamento
								medicaoHistoricoRegistrar
										.setDataLeituraAnteriorFaturamento(new Date());
							} else {
								// seta a data de leitura anterior do
								// faturamento
								medicaoHistoricoRegistrar
										.setDataLeituraAnteriorFaturamento(dataInstacao);
							}

						}
						// leitura anterior faturamento

						medicaoHistoricoRegistrar
								.setLeituraAnteriorFaturamento(leituraAtualMesAnteriorFaturamento);

						// leitura anterior informada
						medicaoHistoricoRegistrar
								.setLeituraAnteriorInformada(leituraAtualMesAnteriorInformada);

						String dataLeituraAtualString = medicaoHistoricoTxt
								.getDataLeituraParaRegistrar();

						SimpleDateFormat dataTxt = new SimpleDateFormat(
								"ddMMyyyy");

						try {
							dataLeituraAtualInformada = dataTxt
									.parse(dataLeituraAtualString);
						} catch (ParseException e) {
							dataLeituraAtualInformada = null;
						}
						// data leitura atual informada
						medicaoHistoricoRegistrar
								.setDataLeituraAtualInformada(dataLeituraAtualInformada);

						// data leitura atual Faturamento
						// medicaoHistoricoRegistrar
						// .setDataLeituraAtualFaturamento(dataLeituraAtualInformada);
						//
						// //id leitura atual faturamento
						// medicaoHistoricoRegistrar
						// .setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturamento);

						// data leitura campo
						medicaoHistoricoRegistrar
								.setDataLeituraCampo(dataLeituraAtualInformada);

						// numero leitura atual informada e numero leitura campo
						// com a leitura informada
						if (medicaoHistoricoTxt.getLeituraAtualInformada()
								.intValue() == 0) {
							medicaoHistoricoRegistrar
									.setLeituraAtualInformada(null);
							medicaoHistoricoRegistrar.setLeituraCampo(null);
						} else {
							medicaoHistoricoRegistrar
									.setLeituraAtualInformada(medicaoHistoricoTxt
											.getLeituraAtualInformada());
							medicaoHistoricoRegistrar
									.setLeituraCampo(medicaoHistoricoTxt
											.getLeituraAtualInformada());
						}
						// data leitura atual faturamento
						medicaoHistoricoRegistrar
								.setDataLeituraAtualFaturamento(dataLeituraAtualInformada);

						// numero leitura atual faturamento com o mesmo numero
						// de leitura informada
						medicaoHistoricoRegistrar
								.setLeituraAtualFaturamento(medicaoHistoricoTxt
										.getLeituraAtualInformada());

						// consumo medido mes
						medicaoHistoricoRegistrar.setNumeroConsumoMes(null);

						// data leitura processamento motico
						medicaoHistoricoRegistrar
								.setNumeroConsumoInformado(null);

						// caso a medição não tenha funcionario na base então
						// inseri com nulo o funcionario e manda essa medição
						// para o relatório
						if (medicaoHistoricoTxt.getGerarRelatorio() != null
								&& medicaoHistoricoTxt
										.getGerarRelatorio()
										.trim()
										.equalsIgnoreCase(
												"Matrícula do Funcionário Inexistente.")) {
							/*
							 * gerarRelatorioObjetosNaoRegistrados
							 * .add(medicaoHistoricoTxt);
							 */
							medicaoHistoricoRegistrar.setFuncionario(null);

						} else {
							// seta o funcionario na medição historico

							// ******************************************************
							// CRC3419
							// Por: Ivan Sergio
							// Estava verificando apenas a instancia do
							// Funcionario
							// mas nao estava verificando se existia dados.
							// ******************************************************
							if (medicaoHistoricoTxt.getFuncionario() != null
									&& medicaoHistoricoTxt.getFuncionario()
											.getId() != null) {
								Funcionario funcionario = new Funcionario();
								funcionario.setId(medicaoHistoricoTxt
										.getFuncionario().getId());
								medicaoHistoricoRegistrar
										.setFuncionario(funcionario);
							}
							// ******************************************************
						}

						// leitura Anormalidade Informada com a leitura
						// anormalidade informada do txt
						// numero leitura atual informada
						// com a leitura informada
						if (medicaoHistoricoTxt
								.getLeituraAnormalidadeInformada().getId()
								.intValue() == 0) {

							medicaoHistoricoRegistrar
									.setLeituraAnormalidadeInformada(null);
						} else {
							medicaoHistoricoRegistrar
									.setLeituraAnormalidadeInformada(medicaoHistoricoTxt
											.getLeituraAnormalidadeInformada());
						}

						// leitura Anormalidade Faturamento com a leitura
						// anormalidade informada do txt
						if (medicaoHistoricoTxt
								.getLeituraAnormalidadeInformada().getId()
								.intValue() == 0) {

							medicaoHistoricoRegistrar
									.setLeituraAnormalidadeFaturamento(null);
						} else {
							medicaoHistoricoRegistrar
									.setLeituraAnormalidadeFaturamento(medicaoHistoricoTxt
											.getLeituraAnormalidadeInformada());
						}

						// Seta a data corrente
						medicaoHistoricoRegistrar
								.setLeituraProcessamentoMovimento(new Date());

						LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();

						if (medicaoHistoricoTxt.getLeituraAtualInformada()
								.intValue() == 0) {
							leituraSituacaoAtual
									.setId(LeituraSituacao.NAO_REALIZADA);
							medicaoHistoricoRegistrar
									.setLeituraSituacaoAtual(leituraSituacaoAtual);
						} else {
							if (Integer.parseInt(medicaoHistoricoTxt
									.getIndicadorConfirmacaoLeitura()) == 0) {
								leituraSituacaoAtual
										.setId(LeituraSituacao.REALIZADA);
								medicaoHistoricoRegistrar
										.setLeituraSituacaoAtual(leituraSituacaoAtual);
							} else {
								leituraSituacaoAtual
										.setId(LeituraSituacao.CONFIRMADA);
								medicaoHistoricoRegistrar
										.setLeituraSituacaoAtual(leituraSituacaoAtual);
							}
						}

						// leitura situacao anterior
						LeituraSituacao leituraSituacaoAnterior = new LeituraSituacao();
						// caso o id se situação anterior for nula
						// seta o valor da situação anterior como não houve
						if (idLeituraSituacaoAnterior == null) {
							leituraSituacaoAnterior
									.setId(LeituraSituacao.NAO_REALIZADA);
							medicaoHistoricoRegistrar
									.setLeituraSituacaoAnterior(leituraSituacaoAnterior);
						} else {
							// caso contrario seta com o valor de id da leitura
							// situação anterior
							leituraSituacaoAnterior
									.setId(idLeituraSituacaoAnterior);
							medicaoHistoricoRegistrar
									.setLeituraSituacaoAnterior(leituraSituacaoAnterior);
						}
						leituraSituacaoAnterior = null;

						// seta o hidrometro Instalação historico de acordo com
						// o tipo de medição
						if (idHidrometroInstalacaoHistorico != null) {
							HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
							hidrometroInstalacaoHistorico
									.setId(idHidrometroInstalacaoHistorico);
							medicaoHistoricoRegistrar
									.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
						}

						// consumo medio hidrometro
						medicaoHistoricoRegistrar
								.setConsumoMedioHidrometro(null);

						medicaoHistoricoRegistrar
								.setIndicadorAnalisado(MedicaoHistorico.INDICADOR_ANALISADO_NAO);

						// leiturista
						Leiturista leiturista = null;
						Integer idLeiturista = repositorioMicromedicao
								.pesquisarLeituristaImovel(idImovelParaInsercao);

						if (idLeiturista != null) {
							leiturista = new Leiturista();
							leiturista.setId(idLeiturista);
						}

						medicaoHistoricoRegistrar.setLeiturista(leiturista);

						medicaoHistoricoRegistrar.setUltimaAlteracao(dataAtual);

						// verifica se não contem a medição historico na coleção
						// que irá inserir
						if (!registrarLeiturasAnormalidades
								.contains(medicaoHistoricoRegistrar)) {

							registrarLeiturasAnormalidades
									.add(medicaoHistoricoRegistrar);
						}

					}

				}

				// o else do gerar terminava aqui
				// map contendo o id do imovel e a leitura anormalidade que será
				// atualizado

				if (registrarLeiturasAnormalidades != null
						&& !registrarLeiturasAnormalidades.isEmpty()) {
					try {
						repositorioMicromedicao
								.inseriMedicaoHistorico(registrarLeiturasAnormalidades);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}
				if (colecaoMedicaoHistoricoAtualizar != null
						&& !colecaoMedicaoHistoricoAtualizar.isEmpty()) {
					try {
						repositorioMicromedicao
								.atualizarMedicaoHistorico(colecaoMedicaoHistoricoAtualizar);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}
				if (idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)) {
					if (limiteInferior == idsImoveisLimitadoAguaArray.length) {
						idMedicaoTipo = MedicaoTipo.POCO;
						limiteInferior = 0;
						limiteSuperior = 0;
						mapTxtAgua = null;
					}
				} else {
					if (idMedicaoTipo.equals(MedicaoTipo.POCO)) {
						if (limiteInferior == idsImoveisLimitadoPocoArray.length) {
							terminou = true;
						}
					}
				}

				if (registrarLeiturasAnormalidades != null) {
					registrarLeiturasAnormalidades.clear();
				}
				if (colecaoIdsImoveisAtualizar != null) {
					colecaoIdsImoveisAtualizar.clear();
				}

				if (colecaoMedicaoHistoricoAtualizar != null) {
					colecaoMedicaoHistoricoAtualizar.clear();
				}
				if (colecaoParmsMedicaoLimitada != null) {
					colecaoParmsMedicaoLimitada.clear();
				}
				if (colecaoParmsMedicaoAnterior != null) {
					colecaoParmsMedicaoAnterior.clear();
				}

			}
			getControladorImovel().atualizarImovelLeituraAnormalidade(
					mapTxtSemMedicao, dataAtual);

			Date dataComMaiorNumeroRegistroRepetidos = null;

			if (mapQuantidadeAnoMesRepetidos != null
					&& !mapQuantidadeAnoMesRepetidos.isEmpty()) {
				Collection colecaoQuantidadeRegistrosRepetidos = mapQuantidadeAnoMesRepetidos
						.entrySet();
				if (colecaoQuantidadeRegistrosRepetidos != null
						&& !colecaoQuantidadeRegistrosRepetidos.isEmpty()) {
					Iterator iteQuantidadeRegistrosRepetidos = colecaoQuantidadeRegistrosRepetidos
							.iterator();
					Integer qdtRegistrosAtual = 0;

					while (iteQuantidadeRegistrosRepetidos.hasNext()) {
						Entry mapEntry = (Entry) iteQuantidadeRegistrosRepetidos
								.next();
						if (((Integer) mapEntry.getValue()) > qdtRegistrosAtual) {
							qdtRegistrosAtual = (Integer) mapEntry.getValue();
							dataComMaiorNumeroRegistroRepetidos = (Date) mapEntry
									.getKey();
						}
					}

				}
			}
			// atualiza o faturamento atividade cronograma com a data de
			// realização
			// com a
			// data corrente
			Integer idFaturamentoAtividadeCronogramaRegistrarLeiturasAnormalidades = null;
			Integer idFaturamentoAtividadeCronogramaEfetuarLeituras = null;
			Integer idFaturamentoGrupoCronogramaMensal = null;
			try {
				// pesquisa o id do faturamento grupo cronograma mensal
				idFaturamentoGrupoCronogramaMensal = repositorioFaturamento
						.pesquisarFaturamentoGrupoCronogramaMensal(
								idFaturamentoGrupo, anoMesReferencia);

				if (idFaturamentoGrupoCronogramaMensal != null) {
					// pesquisa o id do faturamento atividade cronograma
					idFaturamentoAtividadeCronogramaRegistrarLeiturasAnormalidades = repositorioFaturamento
							.pesquisarFaturamentoAtividadeCronograma(
									idFaturamentoGrupoCronogramaMensal,
									FaturamentoAtividade.REGISTRAR_LEITURA_ANORMALIDADE);

					if (idFaturamentoAtividadeCronogramaRegistrarLeiturasAnormalidades != null) {
						// atualiza o faturamento atividade cronograma para a
						// data
						// de
						// realização com
						// a data corrente

						repositorioFaturamento
								.atualizarFaturamentoAtividadeCronograma(
										idFaturamentoAtividadeCronogramaRegistrarLeiturasAnormalidades,
										new Date());

					}

					// pesquisa o id do faturamento atividade cronograma
					idFaturamentoAtividadeCronogramaEfetuarLeituras = repositorioFaturamento
							.pesquisarFaturamentoAtividadeCronograma(
									idFaturamentoGrupoCronogramaMensal,
									FaturamentoAtividade.EFETUAR_LEITURA);

					if (idFaturamentoAtividadeCronogramaEfetuarLeituras != null) {
						// atualiza o faturamento atividade cronograma para a
						// data
						// de
						// realização com
						// a data corrente
						if (dataComMaiorNumeroRegistroRepetidos != null) {
							repositorioFaturamento
									.atualizarFaturamentoAtividadeCronograma(
											idFaturamentoAtividadeCronogramaEfetuarLeituras,
											dataComMaiorNumeroRegistroRepetidos);
						}

					}
				}

			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			// cria uma instância da classe do relatório
			RelatorioRegistrarLeiturasAnormalidades relatorioRegistrarLeiturasAnormalidades = new RelatorioRegistrarLeiturasAnormalidades(
					usuario);

			relatorioRegistrarLeiturasAnormalidades.addParametro(
					"colecaoMedicaoHistoricoRelatorio",
					gerarRelatorioObjetosNaoRegistrados);
			relatorioRegistrarLeiturasAnormalidades.addParametro(
					"idFaturamento", idFaturamentoGrupo);

			String anoMesReferenciaString = "" + anoMesReferencia;
			relatorioRegistrarLeiturasAnormalidades.addParametro(
					"anoMesLeitura", anoMesReferenciaString);

			relatorioRegistrarLeiturasAnormalidades.addParametro(
					"tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
			relatorioRegistrarLeiturasAnormalidades.addParametro("nomeArquivo",
					nomeArquivo);

			byte[] relatorioGerado = (byte[]) relatorioRegistrarLeiturasAnormalidades
					.executar();

			EnvioEmail envioEmail = getControladorCadastro()
					.pesquisarEnvioEmail(
							EnvioEmail.REGISTRAR_LEITURAS_ANORMALIDADES);

			String emailRemetente = envioEmail.getEmailReceptor();

			String tituloMensagem = envioEmail.getTituloMensagem() + " "
					+ nomeArquivo;

			String corpoMensagem = envioEmail.getCorpoMensagem();
			String emailReceptor = envioEmail.getEmailReceptor();

			try {

				File leitura = new File(nomeArquivo + ".PDF");
				File compactado = new File(nomeArquivo + ".zip"); // nomeZip
				ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(
						compactado));
				FileOutputStream out = new FileOutputStream(
						leitura.getAbsolutePath());
				out.write(relatorioGerado);
				out.close();

				ZipUtil.adicionarArquivo(zos, leitura);

				// close the stream
				zos.close();

				ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
						emailRemetente, tituloMensagem, corpoMensagem, leitura);

				leitura.delete();
			} catch (IOException e) {
				throw new ControladorException("erro.sistema", e);
			}
		} catch (Exception e) {

			e.printStackTrace();
			EnvioEmail envioEmail = getControladorCadastro()
					.pesquisarEnvioEmail(
							EnvioEmail.REGISTRAR_LEITURAS_ANORMALIDADES_COM_ERRO);

			String emailRemetente = envioEmail.getEmailReceptor();

			String tituloMensagem = envioEmail.getTituloMensagem() + " "
					+ idFaturamentoGrupo;

			String emailReceptor = envioEmail.getEmailReceptor();

			String mensagem = e.getMessage();
			e.getStackTrace();
			if (mensagem == null) {
				mensagem = "erro.metodo.nao.econtrado";
			}

			try {
				ServicosEmail.enviarMensagem(emailRemetente, emailReceptor,
						tituloMensagem, ConstantesAplicacao.get(mensagem));
			} catch (ErroEmailException e1) {

			}

		}
		// não tem mais retorno
		return null;

	}

	public Collection pesquisarHidrometroPorHidrometroMovimentacao(Filtro filtro)
			throws ControladorException {
		try {
			return repositorioHidrometro
					.pesquisarHidrometroPorHidrometroMovimentacao(filtro);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Consultar Dados do Cliente Imovel Vinculado Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param imovel
	 *            Imovel
	 * @return Dados do Imovel Vinculado
	 * @throws ControladorException
	 */
	public Cliente consultarDadosClienteImovelUsuario(Imovel imovel)
			throws ControladorException {

		Cliente cliente = null;

		Object[] colecaoClienteArray = null;

		try {
			colecaoClienteArray = repositorioMicromedicao
					.consultarDadosClienteImovelUsuario(imovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoClienteArray != null && !(colecaoClienteArray.length < 0)) {

			cliente = new Cliente();

			// Seta o id do cliente
			if (colecaoClienteArray[0] != null) {
				cliente.setId((Integer) colecaoClienteArray[0]);
			}
			// Seta o nome do cliente
			if (colecaoClienteArray[1] != null) {
				cliente.setNome((String) colecaoClienteArray[1]);
			}
		}

		return cliente;
	}

	/**
	 * Consultar Dados do Cliente Imovel Vinculado Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return Consumo Tipo
	 * @throws ControladorException
	 */
	public ConsumoTipo consultarDadosConsumoTipoConsumoHistorico(
			ConsumoHistorico consumoHistorico) throws ControladorException {

		ConsumoTipo consumoTipo = null;

		Object[] colecaoConsumoTipoArray = null;

		try {
			colecaoConsumoTipoArray = repositorioMicromedicao
					.consultarDadosConsumoTipoConsumoHistorico(consumoHistorico);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoConsumoTipoArray != null
				&& !(colecaoConsumoTipoArray.length < 0)) {

			consumoTipo = new ConsumoTipo();

			// Descricao Abreviada
			if (colecaoConsumoTipoArray[0] != null) {
				consumoTipo
						.setDescricaoAbreviada((String) colecaoConsumoTipoArray[0]);
			}

			// Id
			if (colecaoConsumoTipoArray[1] != null) {
				consumoTipo.setId((Integer) colecaoConsumoTipoArray[1]);
			}

			if (colecaoConsumoTipoArray[2] != null) {
				consumoTipo.setDescricao((String) colecaoConsumoTipoArray[2]);
			}
		}

		return consumoTipo;
	}

	/**
	 * Consultar Histórico Medição Individualizada
	 * 
	 * [UC001779] Consultar Histórico Medição Individualizada
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 23/01/2006, 28/01/2008
	 * 
	 * @param imovelCondominio
	 * @param anoMesFaturamento
	 * @param ligacaoTipoInformado
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarHistoricoMedicaoIndividualizada(
			Imovel imovelCondominio, String anoMesFaturamento,
 LigacaoTipo ligacaoTipoInformado)
            throws ControladorException {

        Collection colecaoHistoricosMedicaoIndividualizada = null;
        MedicaoHistorico medicaoHistorico = null;
        ConsumoHistorico consumoHistorico = null;
        ConsumoHistorico consumoHistoricoAguaEsgoto = null;
        Cliente cliente = null;
        ConsumoTipo consumoTipo = null;

        try {

            /*
             * Matricula Nome do Cliente Tipo de Consumo Consumo de Água Medido
             * Consumo de Água Faturado Consumo Esgoto Faturado Consumo do
             * Rateio
             */
            ConsultarHistoricoMedicaoIndividualizadaHelper consultarHistoricoMedicaoIndividualizadaHelper = null;

            if (imovelCondominio != null) {

                // INICIO IMOVEL
                // CONDOMINIO********************************************
                colecaoHistoricosMedicaoIndividualizada = new ArrayList();

                // imovel condominio
                consultarHistoricoMedicaoIndividualizadaHelper = new ConsultarHistoricoMedicaoIndividualizadaHelper();

                // inscrição do imovel condominio
                consultarHistoricoMedicaoIndividualizadaHelper.setMatriculaImovel(imovelCondominio.getId().toString());

                cliente = this.consultarDadosClienteImovelUsuario(imovelCondominio);

                // nome do cliente do imovel condominio
                if (cliente != null) {
                    consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario(cliente.getNome());
                } else {
                    consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario("");
                }

                // consultar consumo Historico imovel condominio
                consumoHistoricoAguaEsgoto = this.obterConsumoHistoricoMedicaoIndividualizada(imovelCondominio, ligacaoTipoInformado,
                        new Integer(anoMesFaturamento).intValue());

                if (consumoHistoricoAguaEsgoto == null) {
                    sessionContext.setRollbackOnly();
                    throw new ControladorException("atencao.consumo.historico.inexistente.imovel.condominio");
                }

                consumoTipo = consultarDadosConsumoTipoConsumoHistorico(consumoHistoricoAguaEsgoto);
                if (consumoTipo != null) {
                    // tipo de consumo do imovel condominio
                    consultarHistoricoMedicaoIndividualizadaHelper.setTipoConsumo(consumoTipo.getDescricaoAbreviada());

                } else {
                    // tipo de consumo do imovel condominio
                    consultarHistoricoMedicaoIndividualizadaHelper.setTipoConsumo("");
                }

                // PESQUISA MEDICAO HISTORICO
                medicaoHistorico = repositorioMicromedicao.pesquisarMedicaoHistoricoTipoAgua(imovelCondominio.getId(), new Integer(anoMesFaturamento));

                if (medicaoHistorico != null && medicaoHistorico.getNumeroConsumoMes() != null) {
                    // consumo agua medido do imovel condominio
                    consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaMedido(medicaoHistorico.getNumeroConsumoMes().toString());
                } else {
                    consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaMedido("");
                }

                if (consumoHistoricoAguaEsgoto != null) {
                    if (ligacaoTipoInformado.getId().equals(LigacaoTipo.LIGACAO_AGUA)) {

                        if (consumoHistoricoAguaEsgoto.getNumeroConsumoFaturadoMes() != null) {
                            consultarHistoricoMedicaoIndividualizadaHelper
                                    .setConsumoAguaFaturado(consumoHistoricoAguaEsgoto.getNumeroConsumoFaturadoMes().toString());
                        } else {
                            consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaFaturado("");
                        }
                    } else if (ligacaoTipoInformado.getId().equals(LigacaoTipo.LIGACAO_ESGOTO)) {
                        if (consumoHistoricoAguaEsgoto.getNumeroConsumoFaturadoMes() != null) {
                            consultarHistoricoMedicaoIndividualizadaHelper
                                    .setConsumoEsgoto(consumoHistoricoAguaEsgoto.getNumeroConsumoFaturadoMes().toString());
                        } else {
                            consultarHistoricoMedicaoIndividualizadaHelper.setConsumoEsgoto("");
                        }
                    }

                    // consumo rateio do imovel condominio
                    if (consumoHistoricoAguaEsgoto.getConsumoRateio() != null) {
                        consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio(consumoHistoricoAguaEsgoto.getConsumoRateio().toString());
                    } else {
                        consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio("");
                    }

                    // Seta o consumo do imóvel vínculado
                    if (consumoHistoricoAguaEsgoto.getConsumoImovelVinculadosCondominio() != null) {
                        // consumo agua medido do imovel vinculado
                        consultarHistoricoMedicaoIndividualizadaHelper
                                .setConsumoImovel(consumoHistoricoAguaEsgoto.getConsumoImovelVinculadosCondominio().toString());
                    } else {
                        consultarHistoricoMedicaoIndividualizadaHelper.setConsumoImovel("");
                    }

                }

                // adicionando dados do imovel condominio
                colecaoHistoricosMedicaoIndividualizada.add(consultarHistoricoMedicaoIndividualizadaHelper);

                // FIM IMOVEL CONDOMINIO
                // *******************************************************************

                // TODOS OS IMOVEIS VINCULADOS AO IMOVEL CONDOMINIO
                
                ConsumoHistoricoCondominio pesquisa = new ConsumoHistoricoCondominio(imovelCondominio.getId(), new Integer(anoMesFaturamento), ligacaoTipoInformado);
                
                Collection colecaoConsumoHistoricoImoveisVinculados = this.consultarConsumoHistoricoImoveisVinculados(pesquisa);

                // obter os dados para os imoveis vinculados
                // coleção de ids dos imoveis vinculados ao condominio
                if (colecaoConsumoHistoricoImoveisVinculados != null && !colecaoConsumoHistoricoImoveisVinculados.isEmpty()) {

                    Iterator iColecaoConsumoHistoricoImoveisVinculados = colecaoConsumoHistoricoImoveisVinculados.iterator();

                    while (iColecaoConsumoHistoricoImoveisVinculados.hasNext()) {
                        String idImovelVinculados = ((Integer) iColecaoConsumoHistoricoImoveisVinculados.next()).toString();

                        // imovel vinculado
                        consultarHistoricoMedicaoIndividualizadaHelper = new ConsultarHistoricoMedicaoIndividualizadaHelper();

                        Imovel imovelVinculado = new Imovel();
                        imovelVinculado.setId(new Integer(idImovelVinculados));

                        // consultar consumo Historico imovel vinculado Ligacao
                        // Agua
                        // consumoHistorico =
                        // this.obterConsumoHistoricoMedicaoIndividualizada(imovelVinculado,
                        // ligacaoTipo, new
                        // Integer(anoMesFaturamento).intValue());
                        consumoHistorico = this.obterConsumoHistoricoMedicaoIndividualizada(imovelVinculado, ligacaoTipoInformado,
                                new Integer(anoMesFaturamento));

                        // inscrição do imovel vinculado
                        consultarHistoricoMedicaoIndividualizadaHelper.setMatriculaImovel(imovelVinculado.getId().toString());

                        cliente = this.consultarDadosClienteImovelUsuario(imovelVinculado);

                        // nome do cliente do imovel vinculado
                        if (cliente != null) {
                            consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario(cliente.getNome());
                        } else {
                            consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario("");
                        }

                        if (consumoHistorico != null) {
                            consumoTipo = consultarDadosConsumoTipoConsumoHistorico(consumoHistorico);
                        } else {
                            consumoTipo = null;
                        }

                        if (consumoTipo != null) {
                            // tipo de consumo do imovel vinculado
                            consultarHistoricoMedicaoIndividualizadaHelper.setTipoConsumo(consumoTipo.getDescricaoAbreviada());

                        } else {
                            // tipo de consumo do imovel vinculado
                            consultarHistoricoMedicaoIndividualizadaHelper.setTipoConsumo("");
                        }

                        // Seta o consumo do imóvel vínculado
                        if (consumoHistorico != null && consumoHistorico.getConsumoImovelVinculadosCondominio() != null) {
                            // consumo agua medido do imovel vinculado
                            consultarHistoricoMedicaoIndividualizadaHelper.setConsumoImovel(consumoHistorico.getConsumoImovelVinculadosCondominio().toString());
                        } else {
                            consultarHistoricoMedicaoIndividualizadaHelper.setConsumoImovel("");
                        }

                        // consumo agua faturado do imovel vinculado
                        if (consumoHistorico != null) {

                            if (ligacaoTipoInformado.getId().equals(LigacaoTipo.LIGACAO_AGUA)) {

                                if (consumoHistorico.getNumeroConsumoFaturadoMes() != null) {
                                    consultarHistoricoMedicaoIndividualizadaHelper
                                            .setConsumoAguaFaturado(consumoHistorico.getNumeroConsumoFaturadoMes().toString());
                                } else {
                                    consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaFaturado("");
                                }
                            } else if (ligacaoTipoInformado.getId().equals(LigacaoTipo.LIGACAO_ESGOTO)) {
                                if (consumoHistorico.getNumeroConsumoFaturadoMes() != null) {
                                    consultarHistoricoMedicaoIndividualizadaHelper.setConsumoEsgoto(consumoHistorico.getNumeroConsumoFaturadoMes().toString());
                                } else {
                                    consultarHistoricoMedicaoIndividualizadaHelper.setConsumoEsgoto("");
                                }
                            }

                            // consumo rateio do imovel vinculado
                            if (consumoHistorico.getConsumoRateio() != null) {
                                consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio(consumoHistorico.getConsumoRateio().toString());
                            } else {
                                consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio("");
                            }
                        } else {
                            consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaFaturado("");
                            // consumo rateio do imovel vinculado
                            consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio("");
                        }

                        if (consumoHistorico.getImovel() != null && consumoHistorico.getImovel().getIndicadorImovelAreaComum() != null) {
                            consultarHistoricoMedicaoIndividualizadaHelper
                                    .setIndicadorImovelAreaComum(consumoHistorico.getImovel().getIndicadorImovelAreaComum().toString());
                        }

                        // adicionando dados do imovel vinculado
                        colecaoHistoricosMedicaoIndividualizada.add(consultarHistoricoMedicaoIndividualizadaHelper);
                    }
                }
            }

            return colecaoHistoricosMedicaoIndividualizada;

        } catch (ErroRepositorioException e) {
            sessionContext.setRollbackOnly();
            throw new ControladorException("erro.sistema", e);
        }

    }

	/**
	 * Consultar Matriculas dos Imoveis Vinculados do Imovel condominio
	 * 
	 * [UC0179] Consultar Historico Medição Indiviualizada
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 23/01/2006, 24/01/2008
	 * 
	 * @param consumoHistorico
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarConsumoHistoricoImoveisVinculados(ConsumoHistoricoCondominio consumoHistorico) throws ControladorException {

		try {
			return repositorioMicromedicao.consultarConsumoHistoricoImoveisVinculados(consumoHistorico);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Consultar Matriculas dos Imoveis Vinculados do Imovel condominio
	 * 
	 * [UC0179] Consultar Historico Medição Indiviualizada
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 23/01/2006, 24/01/2008
	 * 
	 * @param imovel
	 * @param ligacaoTipo
	 * @param anoMesReferencia
	 * @return
	 * @throws ControladorException
	 */
	public ConsumoHistorico obterConsumoHistoricoMedicaoIndividualizada(Imovel imovel, LigacaoTipo ligacaoTipo, int anoMesReferencia) throws ControladorException {

        ConsumoHistorico consumoHistorico = null;

        try {
            consumoHistorico = repositorioMicromedicao.obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipo, anoMesReferencia);
        } catch (ErroRepositorioException ex) {
            sessionContext.setRollbackOnly();
            throw new ControladorException("erro.sistema", ex);
        }
        return consumoHistorico;
    }

	/**
	 * [UC0113] Faturar Grupo de Faturamento Author: Rafael Santos
	 * Data:03/02/2006 Consultar Medicao Historico do Tipo Agua
	 * 
	 * @param imovel
	 *            Id do Imovel Imovel
	 * @param anoMes
	 *            Ano Mes
	 * @return Medicao Historico
	 * @exception ControladorException
	 */
	public MedicaoHistorico pesquisarMedicaoHistoricoTipoAgua(Integer imovel,
			Integer anoMes) throws ControladorException {

		MedicaoHistorico retorno = null;

		// Pesquisa o histórico de medicao
		try {
			retorno = repositorioMicromedicao
					.pesquisarMedicaoHistoricoTipoAgua(imovel, anoMes);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * método utilizado na impressao via impressora termica
	 */
	public MedicaoHistorico pesquisarMedicaoHistoricoTipoAguaLeituraAnormalidade(
			Integer imovel, Integer anoMes) throws ControladorException {

		MedicaoHistorico retorno = null;

		// Pesquisa o histórico de medicao
		try {
			retorno = repositorioMicromedicao
					.pesquisarMedicaoHistoricoTipoAguaLeituraAnormalidade(
							imovel, anoMes);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento Author: Rafael Santos
	 * Data:03/02/2006 Consultar Medicao Historico do Tipo Poço
	 * 
	 * @param imovel
	 *            Id do Imovel Imovel
	 * @param anoMes
	 *            Ano Mes
	 * @return Medicao Historico
	 * @exception ControladorException
	 */
	public MedicaoHistorico pesquisarMedicaoHistoricoTipoPoco(Integer imovel,
			Integer anoMes) throws ControladorException {

		MedicaoHistorico retorno = null;

		// Pesquisa o histórico de medicao
		try {
			retorno = repositorioMicromedicao
					.pesquisarMedicaoHistoricoTipoPoco(imovel, anoMes);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * Método utilizado na impressao da conta via impressora
	 * Termica
	 */
	public MedicaoHistorico pesquisarMedicaoHistoricoTipoPocoLeituraAnormalidade(
			Integer imovel, Integer anoMes) throws ControladorException {

		MedicaoHistorico retorno = null;

		// Pesquisa o histórico de medicao
		try {
			retorno = repositorioMicromedicao
					.pesquisarMedicaoHistoricoTipoPocoLeituraAnormalidade(
							imovel, anoMes);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * Consultar Consumo Historico da Medicao Individualizada [UC0113] Faturar
	 * Grupo Faturamento Auhtor: Rafael Santos Data: 20/02/2006
	 * 
	 * @param idImovel
	 * @param idAnormalidade
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ConsumoHistorico obterConsumoHistoricoAnormalidade(Integer idImovel,
			Integer idAnormalidade, int anoMes) throws ControladorException {

		ConsumoHistorico consumoHistorico = null;

		Object[] colecaoConsumoHistoricoArray = null;

		try {
			colecaoConsumoHistoricoArray = repositorioMicromedicao
					.obterConsumoHistoricoAnormalidade(idImovel,
							idAnormalidade, anoMes);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoConsumoHistoricoArray != null
				&& !(colecaoConsumoHistoricoArray.length < 0)) {

			consumoHistorico = new ConsumoHistorico();

			// Seta o id do histórico
			if (colecaoConsumoHistoricoArray[0] != null) {
				consumoHistorico
						.setId((Integer) colecaoConsumoHistoricoArray[0]);
			}

		}

		return consumoHistorico;
	}

	public void atualizarMedicaoHistorico(MedicaoHistorico medicaoHistorico,
			Usuario usuarioLogado) throws ControladorException {

		try {

			FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();
			filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
					FiltroMedicaoHistorico.ID, medicaoHistorico.getId()));

			// Procura a medição historico na base
			MedicaoHistorico medicaoHistoricoNaBase = (MedicaoHistorico) ((List) (repositorioUtil
					.pesquisar(filtroMedicaoHistorico,
							MedicaoHistorico.class.getName()))).get(0);

			// Verificar se a medição historico já foi atualizado por outro
			// usuário
			// durante
			// esta atualização
			if (medicaoHistoricoNaBase.getUltimaAlteracao().after(
					medicaoHistorico.getUltimaAlteracao())) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

			// Atualiza a data de última alteração
			medicaoHistorico.setUltimaAlteracao(new Date());

			// REGISTRAR TRANSACAO
			RegistradorOperacao registrador = new RegistradorOperacao(
					Operacao.OPERACAO_ALTERAR_DADOS_DO_FATURAMENTO,
					medicaoHistorico.getId(), medicaoHistorico.getId(),
					new UsuarioAcaoUsuarioHelper(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			registrador.registrarOperacao(medicaoHistorico);

			getControladorTransacao().registrarTransacao(medicaoHistorico);
			// FIM - REGISTRAR TRANSACAO

			// Atualiza a medição histórico
			repositorioUtil.atualizar(medicaoHistorico);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Consultar Imoveis com Medição Indiviualizada Auhtor: Sávio Luiz Data:
	 * 06/02/2006 [UC0180] Consultar Imoveis com Medição Indiviualizada
	 * 
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public String pesquisarDescricaoRateioTipoLigacaoAgua(Integer idImovel)
			throws ControladorException {

		try {
			return repositorioMicromedicao
					.pesquisarDescricaoRateioTipoLigacaoAgua(idImovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Consultar Imoveis com Medição Indiviualizada Auhtor: Sávio Luiz Data:
	 * 06/02/2006 [UC0180] Consultar Imoveis com Medição Indiviualizada
	 * 
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public String pesquisarDescricaoRateioTipoLigacaoEsgoto(Integer idImovel)
			throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquisarDescricaoRateioTipoLigacaoEsgoto(idImovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0038] Inserir Rota e [UC0039]Manter Rota
	 * 
	 * Validar Inserir Rota e Alterar Rota
	 * 
	 * @author Vivianne Sousa
	 * @date 24/03/2006
	 * @param idLocalidade
	 *            ,
	 * @param idSetorComercial
	 *            ,
	 * @param codigoRota
	 *            ,
	 * @param idCobrancaGrupo
	 *            ,
	 * @param idFaturamentoGrupo
	 *            ,
	 * @param idLeituraTipo
	 *            ,
	 * @param idEmpresaLeituristica
	 *            ,
	 * @param dataAjusteLeitura
	 *            ,
	 * @param indicadorAjusteConsumo
	 *            ,
	 * @param indicadorFiscalizarCortado
	 *            ,
	 * @param indicadorFiscalizarSuprimido
	 *            ,
	 * @param indicadorGerarFalsaFaixa
	 *            ,
	 * @param percentualGeracaoFaixaFalsa
	 *            ,
	 * @param indicadorGerarFiscalizacao
	 *            ,
	 * @param percentualGeracaoFiscalizacao
	 *            ,
	 * @param indicadorUso
	 *            ,
	 * @param acao
	 *            ,
	 * @param collectionRotaAcaoCriterio
	 * 
	 *            return void
	 * @throws ControladorException
	 */
	private void validacaoFinalRota(String idLocalidade,
			String idSetorComercial, String codigoRota, String idCobrancaGrupo,
			String idFaturamentoGrupo, String idLeituraTipo,
			String idEmpresaLeituristica, String indicadorFiscalizarCortado,
			String indicadorFiscalizarSuprimido,
			String indicadorGerarFalsaFaixa,
			String percentualGeracaoFaixaFalsa,
			String indicadorGerarFiscalizacao,
			String percentualGeracaoFiscalizacao, String indicadorUso,
			String acao, Collection collectionRotaAcaoCriterio, Integer idRota)
			throws ControladorException {

		// Localidade é obrigatório.
		if ((idLocalidade == null) || (idLocalidade.equals(""))) {
			throw new ControladorException("atencao.localidade_nao_informada");
		}
		// Setor Comercial é obrigatório.
		if ((idSetorComercial == null) || (idSetorComercial.equals(""))) {
			throw new ControladorException(
					"atencao.codigo_setor_comercial_nao_informado");
		}

		// O código da rota é obrigatório.
		if ((codigoRota == null) || (codigoRota.equals(""))) {
			throw new ControladorException("atencao.rota_codigo_nao_informado");
		} else if (acao.equalsIgnoreCase("INSERIR")) {
			FiltroRota filtroRota = new FiltroRota();
			filtroRota
					.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
			filtroRota.adicionarParametro(new ParametroSimples(
					FiltroRota.SETOR_COMERCIAL_ID,
					new Integer(idSetorComercial)));

			filtroRota
					.adicionarParametro(new ParametroSimples(
							FiltroRota.CODIGO_ROTA, new Integer(codigoRota)
									.intValue()));

			// Retorna caso já exista uma rota com o código informado
			Collection colecaoPesquisa = null;

			colecaoPesquisa = getControladorUtil().pesquisar(filtroRota,
					Rota.class.getName());

			if (colecaoPesquisa.size() != 0 || !colecaoPesquisa.isEmpty()) {

				// Rota já cadastrado p setor informado
				throw new ControladorException("atencao.rota_ja_existente",
						null, codigoRota, idLocalidade, idSetorComercial);
			}
		}

		// O grupo de faturamento é obrigatório.
		if ((idFaturamentoGrupo == null)
				|| (idFaturamentoGrupo.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO))) {

			throw new ControladorException(
					"atencao.faturamento_grupo_nao_informado");
		}

		// O grupo de cobrança é obrigatório.
		if ((idCobrancaGrupo == null)
				|| (idCobrancaGrupo.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO))) {

			throw new ControladorException(
					"atencao.cobranca_grupo_nao_informado");
		}

		// O tipo de leitura é obrigatório.
		if ((idLeituraTipo == null)
				|| (idLeituraTipo.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException("atencao.leitura_tipo_nao_informado");
		}

		// A empresa leituristica é obrigatória.
		if ((idEmpresaLeituristica == null)
				|| (idEmpresaLeituristica.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.empresa_leituristica_nao_informado");
		}

		// O identificador de fiscalizar cortado é obrigatório.
		if ((indicadorFiscalizarCortado == null)
				|| (indicadorFiscalizarCortado.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.fiscaliza_cortados_nao_informado");
		}

		// O identificador de fiscalizar suprido é obrigatório.
		if ((indicadorFiscalizarSuprimido == null)
				|| (indicadorFiscalizarSuprimido.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.fiscaliza_suprimidos_nao_informado");
		}

		// Sistema Parametro vai ser utilizado na validação de
		// Percentual de Faixa Falsa e
		// Percentual de Fiscalização de Leitura
		FiltroSistemaParametro filtroSistemaParametro = new FiltroSistemaParametro();

		Collection<SistemaParametro> collectionSistemaParametro = getControladorUtil()
				.pesquisar(filtroSistemaParametro,
						SistemaParametro.class.getName());
		SistemaParametro sistemaParametro = (SistemaParametro) collectionSistemaParametro
				.iterator().next();

		// O identificador de gerar faixa falsa é obrigatório.
		if ((indicadorGerarFalsaFaixa == null)
				|| (indicadorGerarFalsaFaixa.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException("atencao.gera_faixa_nao_informado");
		} else if ((percentualGeracaoFaixaFalsa == null || percentualGeracaoFaixaFalsa
				.equalsIgnoreCase(""))
				&& indicadorGerarFalsaFaixa.equals("" + ConstantesSistema.SIM)
				&& sistemaParametro.getIndicadorUsoFaixaFalsa().equals(
						SistemaParametro.INDICADOR_USO_FAIXA_FALSA_ROTA)) {
			// Percentual de Faixa Falsa é obrigatório
			// caso o indicador de geração de fiscalização de leitura seja SIM e
			// o indicador de uso do percentual para geração de fiscalização de
			// leitura
			// na tabela SISTEMA_PARAMETRO
			// (PARM_ICUSOPERCENTUALFISCALIZACAOLEITURA)
			// corresponda ao valor 2=USA PERCENTUAL DA ROTA

			throw new ControladorException(
					"atencao.percentual_faixa_falsa_nao_informado");
		}

		// O identificador de gerar fiscalização é obrigatório.
		if ((indicadorGerarFiscalizacao == null)
				|| (indicadorGerarFiscalizacao.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO))) {

			throw new ControladorException(
					"atencao.gera_fiscalizacao_leitura_nao_informado");

		} else if ((percentualGeracaoFiscalizacao == null || percentualGeracaoFiscalizacao
				.equalsIgnoreCase(""))
				&& indicadorGerarFiscalizacao
						.equals("" + ConstantesSistema.SIM)
				&& sistemaParametro
						.getIndicadorPercentualFiscalizacaoLeitura()
						.equals(SistemaParametro.INDICADOR_PERCENTUAL_FISCALIZACAO_LEITURA_ROTA)) {

			// Percentual de Fiscalização de Leitura é obrigatório
			// caso o indicador de geração de faixa falsa seja SIM e
			// o indicador de uso do percentual para geração da faixa falsa
			// na tabela SISTEMA_PARAMETRO (PARM_ICUSOPERCENTUALFAIXAFALSA)
			// corresponda ao valor 2=USA PERCENTUAL DA ROTA
			throw new ControladorException(
					"atencao.percentual_fiscalizacao_leitura_nao_informado");
		}

		// [FS0010] Verificar inexistência de alguma ação de cobrança
		if (collectionRotaAcaoCriterio == null) {
			// É necessário informar o critério de cobrança da rota para todas
			// as ações de cobrança
			throw new ControladorException(
					"atencao.criterio_cobranca_rota.informar");

		} else {
			FiltroCobrancaAcao filtroCobrancaAcao = new FiltroCobrancaAcao();

			filtroCobrancaAcao.adicionarParametro(new ParametroSimples(
					FiltroCobrancaAcao.INDICADOR_USO,
					ConstantesSistema.INDICADOR_USO_ATIVO));

			Collection<CobrancaGrupo> collectionCobrancaAcao = this
					.getControladorUtil().pesquisar(filtroCobrancaAcao,
							CobrancaAcao.class.getName());

			if (collectionRotaAcaoCriterio.size() < collectionCobrancaAcao
					.size()) {

				// É necessário informar o critério de cobrança da rota para
				// todas as ações de cobrança
				throw new ControladorException(
						"atencao.criterio_cobranca_rota.informar");
			}
		}

		if (acao.equalsIgnoreCase("ALTERAR")
				&& ((indicadorUso == null) || (indicadorUso.equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)))) {
			throw new ControladorException(
					"atencao.indicador_uso_nao_informado");
		}

		if (acao.equalsIgnoreCase("ALTERAR")) {

			FiltroRota filtroRota = new FiltroRota();
			filtroRota.adicionarParametro(new ParametroSimples(
					FiltroRota.ID_ROTA, idRota));

			filtroRota
					.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupo");
			filtroRota.adicionarCaminhoParaCarregamentoEntidade("leituraTipo");

			// Procura rota na base
			Collection rotaAtualizadas = getControladorUtil().pesquisar(
					filtroRota, Rota.class.getName());

			Rota rotaBase = (Rota) Util.retonarObjetoDeColecao(rotaAtualizadas);

			if (!rotaBase.getFaturamentoGrupo().getId().toString()
					.equals(idFaturamentoGrupo)) {

				this.verificarComandoNaoRealizadoParaRota(idRota, rotaBase
						.getFaturamentoGrupo().getId());
				this.verificarComandoNaoRealizadoParaRota(idRota, new Integer(
						idFaturamentoGrupo));

			} else if (!rotaBase.getLeituraTipo().getId().toString()
					.equals(idLeituraTipo)) {
				this.verificarComandoNaoRealizadoParaRota(idRota, new Integer(
						idFaturamentoGrupo));
			}

		}
	}

	/**
	 * [UC0039] Manter Rota
	 * 
	 * Altera um objeto do tipo rota no BD
	 * 
	 * @author Vivianne Sousa
	 * @date 06/04/2006
	 * @param rota
	 * @param idLocalidade
	 * @param collectionRotaAcaoCriterio
	 * @return void
	 * @throws ControladorException
	 */
	public void atualizarRota(Rota rota, String idLocalidade,
			Collection collectionRotaAcaoCriterio, Usuario usuarioLogado)
			throws ControladorException {

		String idRota = "" + rota.getId();

		validacaoFinalRota(idLocalidade, ""
				+ rota.getSetorComercial().getCodigo(), "" + rota.getCodigo(),
				"" + rota.getCobrancaGrupo().getId(), ""
						+ rota.getFaturamentoGrupo().getId(), ""
						+ rota.getLeituraTipo().getId(), ""
						+ rota.getEmpresa().getId(),
				"" + rota.getIndicadorFiscalizarCortado(),
				"" + rota.getIndicadorFiscalizarSuprimido(),
				"" + rota.getIndicadorGerarFalsaFaixa(),
				"" + rota.getPercentualGeracaoFaixaFalsa(),
				"" + rota.getIndicadorGerarFiscalizacao(),
				"" + rota.getPercentualGeracaoFiscalizacao(),
				"" + rota.getIndicadorUso(), "ALTERAR",
				collectionRotaAcaoCriterio, rota.getId());

		FiltroRota filtroRota = new FiltroRota();
		// Seta o filtro para buscar a rota na base
		filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.ID_ROTA,
				idRota));

		// Procura rota na base
		Collection rotaAtualizadas = getControladorUtil().pesquisar(filtroRota,
				Rota.class.getName());

		Rota rotaAtualizada = (Rota) Util
				.retonarObjetoDeColecao(rotaAtualizadas);

		if (rotaAtualizada == null) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.registro_remocao_nao_existente");
		}

		// Procura a rota na base
		Rota rotaNaBase = null;
		rotaNaBase = (Rota) ((List) (this.getControladorUtil().pesquisar(
				filtroRota, Rota.class.getName()))).get(0);

		// Verificar se a rota já foi atualizado por outro usuário
		// durante esta atualização

		if (rotaNaBase.getUltimaAlteracao().after(rota.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// Atualiza a data de última alteração
		rota.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSAÇÃO ROTA----------------------------
		RegistradorOperacao registradorOperacaoRota = new RegistradorOperacao(
				Operacao.OPERACAO_ROTA_ATUALIZAR, new UsuarioAcaoUsuarioHelper(
						usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacaoRota = new Operacao();
		operacaoRota.setId(Operacao.OPERACAO_ROTA_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuadaRota = new OperacaoEfetuada();
		operacaoEfetuadaRota.setOperacao(operacaoRota);

		rota.setOperacaoEfetuada(operacaoEfetuadaRota);
		rota.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacaoRota.registrarOperacao(rota);
		// ------------ REGISTRAR TRANSAÇÃO ROTA----------------------------
		// Atualiza a rota
		this.getControladorUtil().atualizar(rota);

		// -- codigo para atualizar rotaAcaoCriterio --

		Iterator iterator = collectionRotaAcaoCriterio.iterator();
		FiltroRotaAcaoCriterio filtroRotaAcaoCriterio = new FiltroRotaAcaoCriterio();

		filtroRotaAcaoCriterio.adicionarParametro(new ParametroSimples(
				FiltroRotaAcaoCriterio.ROTA_ID, rota.getId()));
		Collection colecaoRotaAcaoCriterioBase = getControladorUtil()
				.pesquisar(filtroRotaAcaoCriterio,
						RotaAcaoCriterio.class.getName());

		while (iterator.hasNext()) {

			RotaAcaoCriterio rotaAcaoCriterio = (RotaAcaoCriterio) iterator
					.next();
			rotaAcaoCriterio.setRota(rota);

			RotaAcaoCriterioPK rotaAcaoCriterioPK = new RotaAcaoCriterioPK();
			rotaAcaoCriterioPK.setCobrancaAcaoId(rotaAcaoCriterio
					.getCobrancaAcao().getId());
			rotaAcaoCriterioPK.setRotaId(rota.getId());

			rotaAcaoCriterio.setComp_id(rotaAcaoCriterioPK);

			rotaAcaoCriterio.setUltimaAlteracao(new Date());

			Iterator iteratorRotaAcaoCriterio = colecaoRotaAcaoCriterioBase
					.iterator();
			boolean atualizar = false;

			if (colecaoRotaAcaoCriterioBase.isEmpty()) {
				this.getControladorUtil().inserir(rotaAcaoCriterio);
			} else {
				while (iteratorRotaAcaoCriterio.hasNext()) {
					RotaAcaoCriterio rotaAcaoCriterioBase = (RotaAcaoCriterio) iteratorRotaAcaoCriterio
							.next();
					if (rotaAcaoCriterioBase.getComp_id().equals(
							rotaAcaoCriterio.getComp_id())) {
						this.getControladorUtil().atualizar(rotaAcaoCriterio);
						atualizar = true;
						iteratorRotaAcaoCriterio.remove();
						break;
					}
				}
				if (!atualizar) {
					this.getControladorUtil().inserir(rotaAcaoCriterio);
				}
			}
		}

		if (colecaoRotaAcaoCriterioBase != null
				&& !colecaoRotaAcaoCriterioBase.isEmpty()) {
			Iterator iter = colecaoRotaAcaoCriterioBase.iterator();
			while (iter.hasNext()) {
				RotaAcaoCriterio rotaAcaoCriterioBase = (RotaAcaoCriterio) iter
						.next();
				this.getControladorUtil().remover(rotaAcaoCriterioBase);
			}
		}

		// -- fim de codigo para atualizar rotaAcaoCriterio --

	}

	/**
	 * [UC0038] Inserir Rota
	 * 
	 * Insere um objeto do tipo rota no BD
	 * 
	 * @author Vivianne Sousa
	 * @date 17/04/2006
	 * @param rota
	 * @param idLocalidade
	 * @param collectionRotaAcaoCriterio
	 * @return idRota
	 * @throws ControladorException
	 */
	public Integer inserirRota(Rota rota, String idLocalidade,
			Collection collectionRotaAcaoCriterio, Usuario usuarioLogado)
			throws ControladorException {

		validacaoFinalRota(idLocalidade, ""
				+ rota.getSetorComercial().getCodigo(), "" + rota.getCodigo(),
				"" + rota.getCobrancaGrupo().getId(), ""
						+ rota.getFaturamentoGrupo().getId(), ""
						+ rota.getLeituraTipo().getId(), ""
						+ rota.getEmpresa().getId(),
				"" + rota.getIndicadorFiscalizarCortado(),
				"" + rota.getIndicadorFiscalizarSuprimido(),
				"" + rota.getIndicadorGerarFalsaFaixa(),
				"" + rota.getPercentualGeracaoFaixaFalsa(),
				"" + rota.getIndicadorGerarFiscalizacao(),
				"" + rota.getPercentualGeracaoFiscalizacao(), null, "INSERIR",
				collectionRotaAcaoCriterio, null);

		// ------------ REGISTRAR TRANSAÇÃO ROTA----------------------------
		RegistradorOperacao registradorOperacaoRota = new RegistradorOperacao(
				Operacao.OPERACAO_ROTA_INSERIR, new UsuarioAcaoUsuarioHelper(
						usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacaoRota = new Operacao();
		operacaoRota.setId(Operacao.OPERACAO_ROTA_INSERIR);

		OperacaoEfetuada operacaoEfetuadaRota = new OperacaoEfetuada();
		operacaoEfetuadaRota.setOperacao(operacaoRota);

		rota.setOperacaoEfetuada(operacaoEfetuadaRota);
		rota.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacaoRota.registrarOperacao(rota);
		// ------------ REGISTRAR TRANSAÇÃO ROTA----------------------------

		// Inserir a rota
		Integer idRota = (Integer) this.getControladorUtil().inserir(rota);

		// -- codigo para inserir rotaAcaoCriterio --
		rota.setId(idRota);
		Iterator iterator = collectionRotaAcaoCriterio.iterator();

		while (iterator.hasNext()) {

			RotaAcaoCriterio rotaAcaoCriterio = (RotaAcaoCriterio) iterator
					.next();
			rotaAcaoCriterio.setRota(rota);

			RotaAcaoCriterioPK rotaAcaoCriterioPK = new RotaAcaoCriterioPK();
			rotaAcaoCriterioPK.setCobrancaAcaoId(rotaAcaoCriterio
					.getCobrancaAcao().getId());
			rotaAcaoCriterioPK.setRotaId(rota.getId());

			rotaAcaoCriterio.setComp_id(rotaAcaoCriterioPK);
			rotaAcaoCriterio.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ROTAACAOCRITERIO----------------
			rotaAcaoCriterio.setOperacaoEfetuada(operacaoEfetuadaRota);
			rotaAcaoCriterio.adicionarUsuario(usuarioLogado,
					UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacaoRota.registrarOperacao(rotaAcaoCriterio);
			// ------------ REGISTRAR TRANSAÇÃO ROTAACAOCRITERIO----------------

			this.getControladorUtil().inserir(rotaAcaoCriterio);

		}
		// -- fim de codigo para inserir rotaAcaoCriterio --
		return idRota;
	}

	/**
	 * Método que efetua o Rateio do consumo para todos os imóveis de uma rota
	 * que sejam imóvel condominio
	 * 
	 * [UC0103] - Efetuar Rateio de Consumo
	 * 
	 * @author Thiago Toscano, Pedro Alexandre, Pedro Alexandre
	 * @date 07/04/2006, 04/08/2006, 29/05/2007
	 * 
	 * @param rotas
	 * @param anoMesFaturamento
	 * @throws ControladorException
	 */
	public void efetuarRateioDeConsumo(Collection rotas,
			Integer anoMesFaturamento, int idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;
		try {

			// -------------------------
			//
			// Registrar o início do processamento da Unidade de
			// Processamento
			// do Batch
			//
			// -------------------------

			Rota rota = (Rota) Util.retonarObjetoDeColecao(rotas);

			idUnidadeIniciada = getControladorBatch()
					.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.ROTA, rota.getId());

			/*
			 * Pesquisa todos os imóveis condominio que tenham situação de água
			 * igual a ligado ou cortado ou que tenham situação de esgoto igual
			 * a ligado ou que tenha hidrometro.
			 */
			Collection colImoveisCondominio = this
					.pesquisarImovelCondominioParaCalculoDoRateioPorRota(rota);

			// Rateamos
			efetuarRateioDeConsumo(colImoveisCondominio, anoMesFaturamento);

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) {
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			// sessionContext.setRollbackOnly();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);

			throw new EJBException(e);
		}

	}

	/**
	 * [UC0103] - Efetuar Rateio de Consumo
	 * 
	 * Determina o rateio de água entre os imóveis vinculados ao imóvel
	 * condominio.
	 * 
	 * [SF0001] - Determinar Rateio de Agua
	 * 
	 * @author Thiago Toscano, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 07/04/2006, 04/08/2006, 14/12/2006, 17/01/2007
	 * 
	 * @param imoveisVinculados
	 * @param imovelCondominio
	 * @param anoMesFaturamento
	 * @param consumoAguaImoveisVinculados
	 * @param consumoMinimoLigacao
	 * @param sistemaParametro
	 * @param quantidadeEconomiasAguasNaoMedidas
	 * @param quantidadeEconomiasAguasMedidas
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioAgua(Collection<Imovel> imoveisVinculados,
			Imovel imovelCondominio, Integer anoMesFaturamento,
			int consumoAguaImoveisVinculados, int consumoMinimoLigacao,
			SistemaParametro sistemaParametro,
			int quantidadeEconomiasAguasNaoMedidas,
			int quantidadeEconomiasAguasMedidas,
			boolean existeImovelVinculadoRateioAreaComum)
			throws ErroRepositorioException, ControladorException {

		// Recupera os dados do consumo da ligação de água do imóvel condominio
		Object[] dadosConsumoLigacaoAguaImovelCondominio = (Object[]) this.repositorioMicromedicao
				.obterConsumoLigacaoAguaOuEsgotoDoImovel(
						imovelCondominio.getId(), anoMesFaturamento,
						LigacaoTipo.LIGACAO_AGUA);
		Integer idConsumoHistoricoLigacaoAgua = (Integer) dadosConsumoLigacaoAguaImovelCondominio[0];
		Integer consumoLigacaoAguaImovelCondominio = (Integer) dadosConsumoLigacaoAguaImovelCondominio[1];
		Integer idPocoImovelCondominio = (Integer) dadosConsumoLigacaoAguaImovelCondominio[2];

		/*
		 * O consumo de água a ser rateado vai ser igual ao consumo da ligação
		 * de água do imóvel condomínio para o mês de faturamento corrente.
		 */
		int consumoAguaSerRateado = -consumoAguaImoveisVinculados;
		if (consumoLigacaoAguaImovelCondominio != null) {
			consumoAguaSerRateado = consumoAguaSerRateado + consumoLigacaoAguaImovelCondominio;
		}

		if (consumoAguaSerRateado < 0) {
			consumoAguaSerRateado = 0;
		}

		/*
		 * Caso a quantidade de economias de água não medidas seja diferente de
		 * zero, o rateio incidirá apenas entre os não medidos. Caso contrário e
		 * caso a quantidade de economias de água medidas seja diferente de zero
		 * determinar rateio de água para medido.
		 */
		if (quantidadeEconomiasAguasNaoMedidas != 0) {
			// [SF0003] - Determinar Rateio de Água para Não Medido
			determinarRateioAguaNaoMedido(imoveisVinculados, anoMesFaturamento,
					quantidadeEconomiasAguasNaoMedidas,
					idConsumoHistoricoLigacaoAgua, consumoAguaSerRateado,
					consumoAguaImoveisVinculados);

		} else if (quantidadeEconomiasAguasMedidas != 0) {
			// [SF0004] - Determinar Rateio de Água para Medido
			determinarRateioAguaParaMedido(imoveisVinculados,
					anoMesFaturamento, sistemaParametro,
					quantidadeEconomiasAguasMedidas,
					idConsumoHistoricoLigacaoAgua, consumoAguaSerRateado,
					consumoAguaImoveisVinculados, idPocoImovelCondominio,
					consumoMinimoLigacao, consumoLigacaoAguaImovelCondominio,
					existeImovelVinculadoRateioAreaComum);
		}
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo
	 * 
	 * Determina o rateio de do consumo de água para os medidos
	 * 
	 * [SF0004] - Determinar Rateio de Água para Medido
	 * 
	 * @author Pedro Alexandre,Pedro Alexandre
	 * @date 14/12/2006, 17/01/2007
	 * 
	 * @param imoveisVinculados
	 * @param anoMesFaturamento
	 * @param sistemaParametro
	 * @param quantidadeEconomiasAguasMedidas
	 * @param idConsumoHistoricoLigacaoAgua
	 * @param consumoAguaSerRateada
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	private void determinarRateioAguaParaMedido(
			Collection<Imovel> imoveisVinculados, Integer anoMesFaturamento,
			SistemaParametro sistemaParametro,
			int quantidadeEconomiasAguasMedidas,
			Integer idConsumoHistoricoLigacaoAgua, int consumoAguaSerRateada,
			int consumoAguaImoveisVinculados, Integer idPocoImovelCondominio,
			Integer consumoMinimoLigacao,
			Integer consumoLigacaoAguaImovelCondominio, boolean existeImovelVinculadoRateioAreaComum)
			throws ErroRepositorioException, ControladorException {
		/*
		 * Item 4.1 O consumo de água a ser rateado por economia vai ser igual
		 * ao consumo de água a ser rateado dividido pela quantidade de
		 * economias medidas
		 */
		int consumoAguaSerRateadaPorEconomia = (int) (consumoAguaSerRateada / quantidadeEconomiasAguasMedidas);
		if (existeImovelVinculadoRateioAreaComum) {
			consumoAguaSerRateadaPorEconomia = consumoAguaSerRateada;
		}

		/*
		 * Item 4.2 Caso o consumo de água a ser rateado por economia seja
		 * inferior ao negativo do decremento máximo de consumo por economia. O
		 * consumo de água a ser rateado por economia vai ser igual ao negativo
		 * do decremento máximo de consumo por economia.
		 */
		if (consumoAguaSerRateadaPorEconomia < (sistemaParametro.getDecrementoMaximoConsumoRateio() * -1)) {
			consumoAguaSerRateadaPorEconomia = (sistemaParametro.getDecrementoMaximoConsumoRateio() * -1);
		}

		/*
		 * Item 4.3 Caso o consumo de água a ser rateado por economia seja
		 * inferior ao negativo do incremento máximo de consumo por economia. O
		 * consumo de água a ser rateado por economia vai ser igual ao negativo
		 * do incremento máximo de consumo por economia.
		 */
		if (consumoAguaSerRateadaPorEconomia > sistemaParametro.getIncrementoMaximoConsumoRateio()) {
			consumoAguaSerRateadaPorEconomia = sistemaParametro.getIncrementoMaximoConsumoRateio();
		}

		// RM3221 - adicionado por Vivianne Sousa - 16/08/2011 -
		// analista:Claudio Lira
		if (existeImovelVinculadoRateioAreaComum) {
			// [SB0007-Rateio Por Área Comum]
			efetuarRateioPorAreaComum(imoveisVinculados, anoMesFaturamento,
					quantidadeEconomiasAguasMedidas,
					idConsumoHistoricoLigacaoAgua,
					consumoAguaSerRateadaPorEconomia, idPocoImovelCondominio,
					consumoMinimoLigacao, consumoLigacaoAguaImovelCondominio);

		} else {

			// Cria o iterator de imóveis vinculados
			Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados.iterator();

			/*
			 * Item 4.4 Para cada imóvel vinculado ao imóvel condomínio que seja
			 * ligado ou cortado de água atualiza o consumo histórico.
			 */
			while (iteratorImoveisVinculados.hasNext()) {
				// Recupera o imóvel vinculado
				Imovel imovelVinculado = iteratorImoveisVinculados.next();

				/*
				 * Caso a situação da ligação de água seja igual a ligado ou
				 * cortado atualiza os dados do consumo histórico do imóvel
				 * vinculado.
				 */
				if (imovelVinculado.getLigacaoAguaSituacao() != null
						&& (LigacaoAguaSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()))) {

					// Recupera o consumo histórico do imóvel vinculado para ser
					// atualizado
					ConsumoHistorico consumoHistorico = this.repositorioMicromedicao
							.obterConsumoHistoricoImovel(imovelVinculado.getId(), anoMesFaturamento, LigacaoTipo.LIGACAO_AGUA);

					/*
					 * Caso o indicador de faturamento seja 1 atualiza os dados
					 * do consumo histórico do imóvel vinculado.
					 */
					if (consumoHistorico.getIndicadorFaturamento().toString().equals(ConstantesSistema.INDICADOR_USO_ATIVO.toString())) {

						/*
						 * Item 4.4.1 Calcula o consumo rateio, que vai ser
						 * igual ao consumo de água a ser rateado por economia
						 * vezes a quantidade de economias do imóvel.
						 */
						Integer consumoRateio = new Integer((int) consumoAguaSerRateadaPorEconomia * imovelVinculado.getQuantidadeEconomias());
						consumoHistorico.setConsumoRateio(consumoRateio);

						/*
						 * Item 4.4.2 Caso o consumo faturado seja inferior ao
						 * consumo rateio assegura que o consumo a ser cobrado
						 * não vai ser negativo.
						 */
						if (consumoHistorico.getNumeroConsumoFaturadoMes() != null
								&& consumoHistorico.getConsumoRateio() != null
								&& consumoHistorico.getNumeroConsumoFaturadoMes().intValue() < (consumoHistorico.getConsumoRateio().intValue() * -1)) {

							consumoHistorico.setConsumoRateio(new Integer(consumoHistorico.getNumeroConsumoFaturadoMes().intValue()	* -1));
						}

						/*
						 * Item 4.4.3 Caso o número do consumo faturado do mês
						 * seja diferente de nulo o consumo faturado do mês vai
						 * ser igual a ele mais o consumo de rateio.
						 */
						// Atualiza os dados do consumo histórico
						Integer numeroConsumoFaturadoMesAtual = consumoHistorico.getNumeroConsumoFaturadoMes();
						Integer numeroConsumoFaturadoMes = 0;
						if (numeroConsumoFaturadoMesAtual != null) {
							numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual;
						}

						// Obter quantidade de economias do imóvel condominio
						Short quantidadeEconomiasImovel = imovelVinculado.getQuantidadeEconomias();

						/**
						 * caso a quantidade de economias seja nulo atribuir o
						 * valor zero
						 */
						if (quantidadeEconomiasImovel == null) {
							quantidadeEconomiasImovel = 0;
						}

						/*
						 * Caso o imóvel condomínio possua poço e o consumo da
						 * ligação de água do imóvel condomínio para o mês de
						 * faturamento corrente não seja superior a soma dos
						 * consumos mínimos calculados no passo 2.2.5 do fluxo
						 * principal.
						 */
						if ((idPocoImovelCondominio != null && idPocoImovelCondominio.intValue() != 0) && 
							(consumoLigacaoAguaImovelCondominio != null && (consumoLigacaoAguaImovelCondominio.intValue() < consumoMinimoLigacao.intValue()))
						   ) {
							numeroConsumoFaturadoMes = (consumoLigacaoAguaImovelCondominio / quantidadeEconomiasAguasMedidas) * quantidadeEconomiasImovel;
						}

						// Atualiza os dados do consumo histórico
						consumoHistorico.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
						consumoHistorico.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
						// Item 4.4.4
						consumoHistorico.setConsumoImovelCondominio(idConsumoHistoricoLigacaoAgua);
						consumoHistorico.setUltimaAlteracao(new Date());
						this.getControladorBatch().atualizarObjetoParaBatch(consumoHistorico);
					}
				}
			}

		}

		/**
		 * Atualiza o consumo de água a ser rateado e o consumo de água dos
		 * imóveis vínculados do imóvel condomínio.
		 */
		this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(
				idConsumoHistoricoLigacaoAgua, consumoAguaSerRateada,
				consumoAguaImoveisVinculados);
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo
	 * 
	 * Determina o rateio de do consumo de água para os não medidos.
	 * 
	 * [SF0003] - Determinar Rateio de Água para Não Medido
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 14/12/2006, 17/01/2007
	 * 
	 * @param imoveisVinculados
	 * @param anoMesFaturamento
	 * @param quantidadeEconomiasAguasNaoMedidas
	 * @param idConsumoHistoricoLigacaoAgua
	 * @param consumoAguaSerRateada
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioAguaNaoMedido(
			Collection<Imovel> imoveisVinculados, Integer anoMesFaturamento,
			int quantidadeEconomiasAguasNaoMedidas,
			Integer idConsumoHistoricoLigacaoAgua, int consumoAguaSerRateada,
			int consumoAguaImoveisVinculados) throws ErroRepositorioException,
			ControladorException {

		/*
		 * O consumo de água a ser rateado por economia vai ser igual ao consumo
		 * de água a ser rateado dividido pela quantidade de economia não
		 * medida.
		 */
		int consumoAguaSerRateadaPorEconomia = (int) (consumoAguaSerRateada / quantidadeEconomiasAguasNaoMedidas);

		/*
		 * Para cada imóvel vinculado ao imóvel condomínio que seja ligado ou
		 * cortado de água.
		 */
		Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados
				.iterator();

		// Laço para atualizar todos os consumos históricos dos imóveis
		// vinculados ao imóvel condomínio
		while (iteratorImoveisVinculados.hasNext()) {

			// Recupera o imóvel vinculado
			Imovel imovelVinculado = iteratorImoveisVinculados.next();

			/*
			 * Caso o imóvel vinculado tenha a situação de água igual a ligado
			 * ou cortado e o imóvel vinculado não tenha ligação de água.
			 */
			if ((imovelVinculado.getLigacaoAguaSituacao() != null && (LigacaoAguaSituacao.FATURAMENTO_ATIVO
					.equals(imovelVinculado.getLigacaoAguaSituacao()
							.getIndicadorFaturamentoSituacao())))) {

				// Recupera o consumo histórico do imóvel vinculado
				ConsumoHistorico consumoHistorico = this.repositorioMicromedicao
						.obterConsumoHistoricoImovel(imovelVinculado.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_AGUA);

				Integer consumoRateio = null;

				/**
				 * Caso o imóvel não possua hidrômetro na ligação de água o nº
				 * do consumo do rateio é igual a o consumode água a ser rateado
				 * por economia vezes a quantidade de econômias do imóvel. Caso
				 * contrário atribui o valor zero ao nº do consumo do rateio.
				 */
				if (imovelVinculado.getLigacaoAgua()
						.getHidrometroInstalacaoHistorico() != null
						&& imovelVinculado.getLigacaoAgua()
								.getHidrometroInstalacaoHistorico().getId() != null) {
					consumoRateio = 0;
				} else {
					consumoRateio = new Integer(
							(int) consumoAguaSerRateadaPorEconomia
									* imovelVinculado.getQuantidadeEconomias());
				}

				consumoHistorico.setConsumoRateio(consumoRateio);

				/*
				 * Caso o consumo faturado (CSHI_NNCONSUMOFATURADOMES) seja
				 * inferior ao consumo rateio (CSHI_NNCONSUMORATEIO * (-1)), o
				 * consumo rateio vai ser igual ao consumo faturado mês vezes
				 * -1(menos um) assegurando, deste modo, queo consumo a ser
				 * cobrado não será um valor negativo.
				 */
				if (consumoHistorico.getNumeroConsumoFaturadoMes() != null
						&& consumoHistorico.getConsumoRateio() != null
						&& consumoHistorico.getNumeroConsumoFaturadoMes()
								.intValue() < (consumoHistorico
								.getConsumoRateio().intValue() * -1)) {

					consumoHistorico.setConsumoRateio(new Integer(
							consumoHistorico.getNumeroConsumoFaturadoMes()
									.intValue() * -1));
				}

				Integer numeroConsumoFaturadoMesAtual = consumoHistorico
						.getNumeroConsumoFaturadoMes();
				Integer numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual;
				/**
				 *  Pamela gatinho - 28/05/2012 Alteracao para
				 * salvar o valor do rateio junto com o valor faturado de agua.
				 */
				// + consumoHistorico.getConsumoRateio();

				// Atualiza os dados do consumo histórico
				consumoHistorico
						.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
				consumoHistorico
						.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
				consumoHistorico
						.setConsumoImovelCondominio(idConsumoHistoricoLigacaoAgua);
				consumoHistorico.setUltimaAlteracao(new Date());
				this.getControladorBatch().atualizarObjetoParaBatch(
						consumoHistorico);
			}
		}

		/**
		 * Atualiza o consumo de água a ser rateado e o consumo de água dos
		 * imóveis vínculados do imóvel condomínio.
		 */
		this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(
				idConsumoHistoricoLigacaoAgua, consumoAguaSerRateada,
				consumoAguaImoveisVinculados);
	}

	/**
	 * [UC0103] - Efetuar Rateio de Consumo
	 * 
	 * Determina o rateio de esgoto entre os imóveis vinculados ao imóvel
	 * condominio.
	 * 
	 * [SF0002] - Determinar Rateio de Esgoto
	 * 
	 * @author Thiago Toscano, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 07/04/2006, 04/08/2006, 14/12/2006, 17/01/2007
	 * 
	 * @param imoveisVinculados
	 * @param imovelCondominio
	 * @param anoMesFaturamento
	 * @param consumoEsgotoImoveisVinculados
	 * @param consumoMinimoLigacao
	 * @param sistemaParametro
	 * @param quantidadeEconomiasEsgotosNaoMedidas
	 * @param quantidadeEconomiasEsgotosMedidas
	 * @param rateioTipo
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioEsgoto(Collection<Imovel> imoveisVinculados,
			Imovel imovelCondominio, Integer anoMesFaturamento,
			int consumoEsgotoImoveisVinculados, int consumoMinimoLigacao,
			SistemaParametro sistemaParametro,
			int quantidadeEconomiasEsgotosNaoMedidas,
			int quantidadeEconomiasEsgotosMedidas,
			RateioTipo rateioTipoLigacaoAgua) throws ErroRepositorioException,
			ControladorException {

		// Recupera os dados do consumo da ligação de esgoto do imóvel
		// condomínio.
		Object[] dadosConsumoLigacaoEsgotoImovelCondominio = (Object[]) this.repositorioMicromedicao
				.obterConsumoLigacaoAguaOuEsgotoDoImovel(
						imovelCondominio.getId(), anoMesFaturamento,
						LigacaoTipo.LIGACAO_ESGOTO);
		Integer idConsumoHistoricoLigacaoEsgoto = (Integer) dadosConsumoLigacaoEsgotoImovelCondominio[0];
		Integer consumoLigacaoEsgotoImovelCondominio = (Integer) dadosConsumoLigacaoEsgotoImovelCondominio[1];

		/*
		 * Item 2.1 Calcula o consumo de esgoto que vai ser rateado que vai ser
		 * o consumo da ligação de esgoto do imóvel condomínio para o mês de
		 * faturamento corrente menos o consumo de esgoto dos imóveis vinculados
		 */
		int consumoEsgotoSerRateada = -consumoEsgotoImoveisVinculados;
		if (consumoLigacaoEsgotoImovelCondominio != null) {
			consumoEsgotoSerRateada = consumoEsgotoSerRateada
					+ consumoLigacaoEsgotoImovelCondominio;
		}

		/**
		 *  Pamela Gatinho - 23/04/2012
		 * 
		 * Alteração para não definir rateio com valor negativo. Ou seja, se for
		 * negativo, não haverá rateio.
		 */
		if (consumoEsgotoSerRateada < 0) {
			consumoEsgotoSerRateada = 0;
		}

		/*
		 * Item 2.5.1 Caso a quantidade de economias de ESGOTO não medidas seja
		 * diferente de zero , o rateio incidirá apenas entre os não medidos.
		 * Caso contrário e caso a quantidade de economias de ESGOTO medidas
		 * seja diferente de zero determina o rateio de esgoto para medida.
		 */
		if (quantidadeEconomiasEsgotosNaoMedidas != 0) {

			// [SF0005] - Determinar Rateio de Esgoto para Não Medido
			determinarRateioEsgotoNaoMedido(imoveisVinculados,
					anoMesFaturamento, quantidadeEconomiasEsgotosNaoMedidas,
					idConsumoHistoricoLigacaoEsgoto, consumoEsgotoSerRateada,
					consumoEsgotoImoveisVinculados, rateioTipoLigacaoAgua,
					sistemaParametro);

		} else if (quantidadeEconomiasEsgotosMedidas != 0) {

			// [SF0006] - Determinar Rateio de Esgoto para Medido
			determinarRateioEsgotoParaMedido(imoveisVinculados,
					anoMesFaturamento, sistemaParametro,
					quantidadeEconomiasEsgotosMedidas,
					idConsumoHistoricoLigacaoEsgoto, consumoEsgotoSerRateada,
					consumoEsgotoImoveisVinculados);
		}
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo
	 * 
	 * Determina o rateio de esgoto para os imóveis medidos.
	 * 
	 * [SF0006] - Determinar Rateio de Esgoto para Medido
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 14/12/2006, 17/01/2007
	 * 
	 * @param imoveisVinculados
	 * @param anoMesFaturamento
	 * @param sistemaParametro
	 * @param quantidadeEconomiasEsgotosMedidas
	 * @param idConsumoHistoricoLigacaoEsgoto
	 * @param consumoEsgotoSerRateada
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioEsgotoParaMedido(
			Collection<Imovel> imoveisVinculados, Integer anoMesFaturamento,
			SistemaParametro sistemaParametro,
			int quantidadeEconomiasEsgotosMedidas,
			Integer idConsumoHistoricoLigacaoEsgoto,
			int consumoEsgotoSerRateada, int consumoEsgotoImoveisVinculados)
			throws ErroRepositorioException, ControladorException {
		/*
		 * Item 6.1 O consumo de esgoto a ser rateado por economia vai ser igual
		 * aso consumo de esgoto a ser rateado dividido pela quantidade de
		 * economias medidas.
		 */
		int consumoEsgotoSerRateadaPorEconomia = (int) (consumoEsgotoSerRateada / quantidadeEconomiasEsgotosMedidas);

		/*
		 * Item 6.2 Caso o consumo de esgoto a ser rateado por economia não seja
		 * superior a zero passa para o próximo imóvel.
		 */
		if (!(consumoEsgotoSerRateadaPorEconomia > 0)) {
			// return;
			consumoEsgotoSerRateadaPorEconomia = 0;
		}

		/*
		 * Item 4.2 Caso o consumo de água a ser rateado por economia seja
		 * inferior ao negativo do decremento máximo de consumo por economia. O
		 * consumo de água a ser rateado por economia vai ser igual ao negativo
		 * do decremento máximo de consumo por economia.
		 */
		if (consumoEsgotoSerRateadaPorEconomia < (sistemaParametro
				.getDecrementoMaximoConsumoRateio() * -1)) {
			consumoEsgotoSerRateadaPorEconomia = (sistemaParametro
					.getDecrementoMaximoConsumoRateio() * -1);
		}

		/*
		 * Item 6.3 Caso o consumo de esgoto a ser rateado por economia seja
		 * superior ao incremento máximo de consumo por economia o consumo de
		 * esgoto a ser rateado por economia vai ser igual ao incremento máximo
		 * de consumo por economia.
		 */
		if (consumoEsgotoSerRateadaPorEconomia > sistemaParametro
				.getIncrementoMaximoConsumoRateio()) {
			consumoEsgotoSerRateadaPorEconomia = sistemaParametro
					.getIncrementoMaximoConsumoRateio();
		}

		// Cria o iterator dos imóveis vinculados ao imóvel condomínio.
		Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados
				.iterator();

		/*
		 * Item 6.4 Laço para atualizar os dados do consumo históricodos imóveis
		 * vinculados ao imóvel condomínio.
		 */
		while (iteratorImoveisVinculados.hasNext()) {
			// Recupera o imóvel vinculado.
			Imovel imovelVinculado = iteratorImoveisVinculados.next();

			/*
			 * Caso a situação da ligação de esgoto seja igual a ligado ou
			 * cortado atualiza os dados do consumo histórico do imóvel
			 * vinculado.
			 */
			if (imovelVinculado.getLigacaoEsgotoSituacao() != null
					&& LigacaoEsgotoSituacao.FATURAMENTO_ATIVO
							.equals(imovelVinculado.getLigacaoEsgotoSituacao()
									.getIndicadorFaturamentoSituacao())) {

				// Recupera o consumo histórico do imóvel.
				ConsumoHistorico consumoHistorico = this.repositorioMicromedicao
						.obterConsumoHistoricoImovel(imovelVinculado.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_ESGOTO);

				/*
				 * Item 6.4.1 O consumo para rateio vai ser o consumo do esgoto
				 * a ser rateado por economia vezes a quantidade de economias do
				 * imóvel.
				 */
				if (consumoHistorico != null) {
					Integer consumoRateio = new Integer(
							(int) consumoEsgotoSerRateadaPorEconomia
									* imovelVinculado.getQuantidadeEconomias());
					consumoHistorico.setConsumoRateio(consumoRateio);

					/*
					 * Item 6.4.2 Caso o consumo faturado seja inferior ao
					 * consumo rateio assegura que o consumo a ser cobrado não
					 * vai ser negativo.
					 */
					if (consumoHistorico.getNumeroConsumoFaturadoMes() != null
							&& consumoHistorico.getConsumoRateio() != null
							&& consumoHistorico.getNumeroConsumoFaturadoMes()
									.intValue() < (consumoHistorico
									.getConsumoRateio().intValue() * -1)) {

						consumoHistorico.setConsumoRateio(new Integer(
								consumoHistorico.getNumeroConsumoFaturadoMes()
										.intValue() * -1));
					}

					/*
					 * Item 6.4.3 Caso o número do consumo faturado do mês seja
					 * diferente de nulo o consumo faturado do mês vai ser igual
					 * a ele mais o consumo de rateio.
					 */
					int numeroConsumoFaturadoMes = 0;

					Integer numeroConsumoFaturadoMesAtual = consumoHistorico
							.getNumeroConsumoFaturadoMes();

					if (numeroConsumoFaturadoMesAtual != null) {
						numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual;
					}
					// if (consumoHistorico.getConsumoRateio() != null) {
					// numeroConsumoFaturadoMes = numeroConsumoFaturadoMes
					// + consumoHistorico.getConsumoRateio();
					// }

					// Atualiza os dados do consumo histórico
					consumoHistorico
							.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
					consumoHistorico
							.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
					// Item 6.4.6
					consumoHistorico
							.setConsumoImovelCondominio(idConsumoHistoricoLigacaoEsgoto);
					consumoHistorico.setUltimaAlteracao(new Date());
					this.getControladorBatch().atualizarObjetoParaBatch(
							consumoHistorico);
				}
			}
		}

		/**
		 * Atualiza o consumo de esgoto a ser rateado e o consumo de esgoto dos
		 * imóveis vínculados do imóvel condomínio.
		 */
		this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(
				idConsumoHistoricoLigacaoEsgoto, consumoEsgotoSerRateada,
				consumoEsgotoImoveisVinculados);
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo
	 * 
	 * Determina o rateio de esgoto para os imóveis não medidos.
	 * 
	 * [SF0005] - Determinar Rateio de Esgoto para Não Medido
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 14/12/2006, 17/01/2007
	 * 
	 * @param imoveisVinculados
	 * @param anoMesFaturamento
	 * @param quantidadeEconomiasEsgotosNaoMedidas
	 * @param idConsumoHistoricoLigacaoEsgoto
	 * @param consumoEsgotoSerRateada
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioEsgotoNaoMedido(
			Collection<Imovel> imoveisVinculados, Integer anoMesFaturamento,
			int quantidadeEconomiasEsgotosNaoMedidas,
			Integer idConsumoHistoricoLigacaoEsgoto,
			int consumoEsgotoSerRateada, int consumoEsgotoImoveisVinculados,
			RateioTipo rateioTipo, SistemaParametro sistemaParametro)
			throws ErroRepositorioException, ControladorException {
		/*
		 * Item 5.1 Consumo de esgoto a ser rateado por economia vai ser igual
		 * ao consumo de esgoto a ser rateado dividido pela quantidade de
		 * economias não medidas.
		 */
		int consumoEsgotoSerRateadaPorEconomia = (int) (consumoEsgotoSerRateada / quantidadeEconomiasEsgotosNaoMedidas);

		/*
		 * Item 4.2 Caso o consumo de água a ser rateado por economia seja
		 * inferior ao negativo do decremento máximo de consumo por economia. O
		 * consumo de água a ser rateado por economia vai ser igual ao negativo
		 * do decremento máximo de consumo por economia.
		 */
		if (consumoEsgotoSerRateadaPorEconomia < (sistemaParametro
				.getDecrementoMaximoConsumoRateio() * -1)) {
			consumoEsgotoSerRateadaPorEconomia = (sistemaParametro
					.getDecrementoMaximoConsumoRateio() * -1);
		}

		/*
		 * Para cada imóvel vinculado ao imóvel condomínio que seja ligado de
		 * esgoto.
		 */
		// Cria o iterator dos imóveis vínculados ao imóvel condomínio.
		Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados
				.iterator();

		// Laço para atualizar os consumo histórico dos imóveis
		// vínculados
		while (iteratorImoveisVinculados.hasNext()) {
			// Recupera o imóvel vínculado
			Imovel imovelVinculado = iteratorImoveisVinculados.next();

			/*
			 * Caso a situação de esgoto do imóvel seja igual a ligado ou
			 * cortado e o imóvel não tenha hidrometro atualiza os dados do
			 * consumo histórico.
			 */
			if (imovelVinculado.getLigacaoEsgotoSituacao() != null
					&& LigacaoEsgotoSituacao.FATURAMENTO_ATIVO
							.equals(imovelVinculado.getLigacaoEsgotoSituacao()
									.getIndicadorFaturamentoSituacao())) {

				// Recupera o consumo histórico do imóvel.
				ConsumoHistorico consumoHistorico = this.repositorioMicromedicao
						.obterConsumoHistoricoImovel(imovelVinculado.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_ESGOTO);

				Integer consumoRateio = 0;

				if (rateioTipo != null
						&& rateioTipo.getId().equals(
								RateioTipo.RATEIO_NAO_MEDIDO_AGUA)) {

					if (imovelVinculado.getLigacaoAgua() != null
							&& imovelVinculado.getLigacaoAgua()
									.getHidrometroInstalacaoHistorico() != null
							&& imovelVinculado.getLigacaoAgua()
									.getHidrometroInstalacaoHistorico().getId() != null) {
						consumoRateio = 0;
					} else {
						consumoRateio = consumoEsgotoSerRateadaPorEconomia
								* imovelVinculado.getQuantidadeEconomias();
					}
				} else {

					/**
					 * Caso o imóvel não possu hidrômetro no poço o valor do
					 * consumo de rateio vai ser igual ao consumo de esgoto a
					 * ser rateado por economia vezes a quantidade de economias
					 * do imóvel. Caso contrário o valor do rateio de consumo
					 * vai ser igual a zero.
					 */
					if (imovelVinculado.getHidrometroInstalacaoHistorico() != null
							&& imovelVinculado
									.getHidrometroInstalacaoHistorico().getId() != null) {
						consumoRateio = 0;
					} else {
						consumoRateio = consumoEsgotoSerRateadaPorEconomia
								* imovelVinculado.getQuantidadeEconomias();
					}
				}

				consumoHistorico.setConsumoRateio(consumoRateio);

				/**
				 * Caso o consumo faturado (CSHI_NNCONSUMOFATURADOMES) seja
				 * inferior ao consumo rateio (CSHI_NNCONSUMORATEIO * (-1)), o
				 * consumo rateio vai ser igual ao consumo faturado mês vezes
				 * -1(menos um) assegurando, deste modo, queo consumo a ser
				 * cobrado não será um valor negativo.
				 */
				if (consumoHistorico.getNumeroConsumoFaturadoMes() != null
						&& consumoHistorico.getConsumoRateio() != null
						&& consumoHistorico.getNumeroConsumoFaturadoMes()
								.intValue() < (consumoHistorico
								.getConsumoRateio().intValue() * -1)) {

					consumoHistorico.setConsumoRateio(new Integer(
							consumoHistorico.getNumeroConsumoFaturadoMes()
									.intValue() * -1));
				}

				Integer numeroConsumoFaturadoMesAtual = consumoHistorico
						.getNumeroConsumoFaturadoMes();
				// Calcula o nº de consumo calculado no mês.
				Integer numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual;
				// + consumoHistorico.getConsumoRateio();
				// Atualiza os dados do consumo histórico.
				consumoHistorico
						.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
				consumoHistorico
						.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
				consumoHistorico
						.setConsumoImovelCondominio(idConsumoHistoricoLigacaoEsgoto);
				consumoHistorico.setUltimaAlteracao(new Date());
				this.getControladorBatch().atualizarObjetoParaBatch(
						consumoHistorico);
			}
		}

		/**
		 * Atualiza o consumo de esgoto a ser rateado e o consumo de esgoto dos
		 * imóveis vínculados do imóvel condomínio.
		 */
		this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(
				idConsumoHistoricoLigacaoEsgoto, consumoEsgotoSerRateada,
				consumoEsgotoImoveisVinculados);
	}

	/**
	 * [UC0039] Manter Rota
	 * 
	 * Remove um objeto do tipo rota no BD
	 * 
	 * @author Vivianne Sousa
	 * @date 05/05/2006
	 * @param ids
	 * @return void
	 * @throws ControladorException
	 */
	public void removerRota(String[] ids, Usuario usuarioLogado)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ROTA_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(
				usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// remover RotaAcaoCriterio para cada Rota a remover
		int i = 0;

		while (i < ids.length) {
			String idRota = ids[i];

			try {
				repositorioMicromedicao.removerRotaAcaoCriterio(new Integer(
						idRota), operacaoEfetuada, colecaoUsuarios);

				// objeto a ser removido não existe na base
			} catch (RemocaoRegistroNaoExistenteException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.registro_remocao_nao_existente", ex);
				// erro de restrição na base
			} catch (RemocaoInvalidaException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException(
						"atencao.dependencias.existentes", ex);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			i = i + 1;
		}

		// remover rota(s)
		this.getControladorUtil().remover(ids, Rota.class.getName(),
				operacaoEfetuada, colecaoUsuarios);

	}

	/**
	 * 
	 * Filtrar Hidrometro
	 * 
	 * Faz a pesquisa da quantidade que o filtro vai retornar
	 * 
	 * @author Fernanda Paiva
	 * @date
	 * 
	 * @throws ControladorException
	 */
	public Integer pesquisarNumeroHidrometroFaixaCount(String fixo,
			String faixaInicial, String faixaFinal) throws ControladorException {
		try {
			return repositorioMicromedicao.pesquisarNumeroHidrometroFaixaCount(
					fixo, faixaInicial, faixaFinal);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Método que retorna o maior código de Rota de um Setor Comercial
	 * 
	 * @author Vivianne Sousa
	 * @date 12/07/2006
	 * 
	 * @param idSetorComercial
	 * @return
	 * @throws ControladorException
	 */

	public Short pesquisarMaximoCodigoRota(Integer idSetorComercial)
			throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquisarMaximoCodigoRota(idSetorComercial);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * Método que apresenta os dados do imovel
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 * 
	 * @author Sávio Luiz
	 * @date 04/08/2006
	 * 
	 * @param idImovel
	 * @return Collection
	 */
	public Collection pesquiarImovelExcecoesApresentaDados(Integer idImovel,
			boolean ligacaoAgua) throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquiarImovelExcecoesApresentaDados(idImovel, ligacaoAgua);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * Método que apresenta os dados do imovel
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 * 
	 * @author Sávio Luiz
	 * @date 04/08/2006
	 * 
	 * @param idImovel
	 * @return Collection
	 */
	public Collection pesquiarMedicaoConsumoHistoricoExcecoesApresentaDados(
			FaturamentoGrupo faturamentoGrupo, Integer idImovel,
			boolean ligacaoAgua) throws ControladorException {

		try {
			// SistemaParametro sistemaParametro =
			// repositorioUtil.pesquisarParametrosDoSistema();
			return repositorioMicromedicao
					.pesquiarMedicaoConsumoHistoricoExcecoesApresentaDados(
							faturamentoGrupo, idImovel, ligacaoAgua);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * Método que apresenta os dados do imovel
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 * 
	 * @author Sávio Luiz
	 * @date 04/08/2006
	 * 
	 * @param idImovel
	 * @return Collection
	 */
	public Collection pesquisarMedicaoConsumoHistoricoExcecoesApresentaDadosConsultarImovel(
			Integer anoMesReferencia, Integer idImovel, boolean ligacaoAgua)
			throws ControladorException {

		try {
			// SistemaParametro sistemaParametro =
			// repositorioUtil.pesquisarParametrosDoSistema();
			return repositorioMicromedicao
					.pesquisarMedicaoConsumoHistoricoExcecoesApresentaDadosConsultarImovel(
							anoMesReferencia, idImovel, ligacaoAgua);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * Retorna uma coleção com os dados das medicoes para apresentação
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 */
	public Collection carregarDadosMedicao(Integer idImovel, boolean ligacaoAgua)
			throws ControladorException {

		Collection resultadoPesquisa = null;
		Collection retorno = null;

		try {
			resultadoPesquisa = repositorioMicromedicao.carregarDadosMedicao(
					idImovel, ligacaoAgua);

			if (!resultadoPesquisa.isEmpty()) {
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				MedicaoHistorico medicaoHistorico = null;
				Object[] objetoMedicao = null;
				LeituraAnormalidade leituraAnormalidadeInformada = null;
				LeituraAnormalidade leituraAnormalidadeFaturada = null;
				LeituraSituacao leituraSituacao = null;

				while (iterator.hasNext()) {
					objetoMedicao = (Object[]) iterator.next();
					medicaoHistorico = new MedicaoHistorico();

					medicaoHistorico
							.setAnoMesReferencia(((Integer) objetoMedicao[0])
									.intValue());
					medicaoHistorico
							.setDataLeituraAtualInformada((Date) objetoMedicao[1]);
					medicaoHistorico
							.setLeituraAtualInformada((Integer) objetoMedicao[2]);
					medicaoHistorico
							.setDataLeituraAtualFaturamento((Date) objetoMedicao[3]);
					medicaoHistorico
							.setLeituraAtualFaturamento((Integer) objetoMedicao[4]);
					// =============================== Leitura Anormalidade
					// Informada
					leituraAnormalidadeInformada = new LeituraAnormalidade();
					leituraAnormalidadeInformada
							.setId((Integer) objetoMedicao[9]);
					leituraAnormalidadeInformada
							.setDescricao((String) objetoMedicao[5]);
					medicaoHistorico
							.setLeituraAnormalidadeInformada(leituraAnormalidadeInformada);
					// =============================== Leitura Anormalidade
					// Informada
					leituraAnormalidadeFaturada = new LeituraAnormalidade();
					leituraAnormalidadeFaturada
							.setId((Integer) objetoMedicao[10]);
					leituraAnormalidadeFaturada
							.setDescricao((String) objetoMedicao[6]);
					medicaoHistorico
							.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturada);
					// =============================== Leitura Anormalidade
					// Informada
					leituraSituacao = new LeituraSituacao();
					leituraSituacao.setDescricao((String) objetoMedicao[7]);
					medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
					medicaoHistorico
							.setConsumoMedioHidrometro((Integer) objetoMedicao[8]);

					retorno.add(medicaoHistorico);
				}
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * 
	 * Retorna uma coleção com os dados das medicoes para apresentação
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 */
	public Collection carregarDadosMedicaoResumo(Integer idImovel,
			boolean ligacaoAgua) throws ControladorException {

		Collection resultadoPesquisa = null;
		Collection retorno = null;

		try {
			resultadoPesquisa = repositorioMicromedicao
					.carregarDadosMedicaoResumo(idImovel, ligacaoAgua);

			if (!resultadoPesquisa.isEmpty()) {
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				MedicaoHistorico medicaoHistorico = null;
				Object[] objetoMedicao = null;
				LeituraAnormalidade leituraAnormalidadeInformada = null;
				LeituraAnormalidade leituraAnormalidadeFaturada = null;
				LeituraSituacao leituraSituacao = null;

				while (iterator.hasNext()) {
					objetoMedicao = (Object[]) iterator.next();
					medicaoHistorico = new MedicaoHistorico();

					medicaoHistorico
							.setAnoMesReferencia(((Integer) objetoMedicao[0])
									.intValue());
					medicaoHistorico
							.setDataLeituraAtualInformada((Date) objetoMedicao[1]);
					medicaoHistorico
							.setLeituraAtualInformada((Integer) objetoMedicao[2]);
					medicaoHistorico
							.setDataLeituraAtualFaturamento((Date) objetoMedicao[3]);
					medicaoHistorico
							.setLeituraAtualFaturamento((Integer) objetoMedicao[4]);
					// =============================== Leitura Anormalidade
					// Informada
					leituraAnormalidadeInformada = new LeituraAnormalidade();
					leituraAnormalidadeInformada
							.setId((Integer) objetoMedicao[5]);
					medicaoHistorico
							.setLeituraAnormalidadeInformada(leituraAnormalidadeInformada);
					// =============================== Leitura Anormalidade
					// Informada
					leituraAnormalidadeFaturada = new LeituraAnormalidade();
					leituraAnormalidadeFaturada
							.setId((Integer) objetoMedicao[6]);
					leituraAnormalidadeFaturada
							.setDescricao((String) objetoMedicao[7]);
					medicaoHistorico
							.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturada);
					// =============================== Leitura Anormalidade
					// Informada
					leituraSituacao = new LeituraSituacao();
					leituraSituacao.setDescricao((String) objetoMedicao[8]);
					medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);

					retorno.add(medicaoHistorico);
				}
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * 
	 * Retorna uma coleção com os dados das medicoes para apresentação
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 */
	public Collection carregarDadosConsumo(Integer idImovel, int anoMes,
			boolean ligacaoAgua) throws ControladorException {

		Collection resultadoPesquisa = null;
		Collection retorno = null;

		try {
			resultadoPesquisa = repositorioMicromedicao.carregarDadosConsumo(
					idImovel, anoMes, ligacaoAgua);

			if (!resultadoPesquisa.isEmpty()) {
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				ConsumoHistorico consumoHistorico = null;
				ConsumoHistorico consumoHistoricoEsgoto = null;
				Object[] objetoConsumo = null;
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				ConsumoTipo consumoTipo = null;
				MedicaoHistorico medicaoHistorico = null;
				ImovelMicromedicao imovelMicromedicao = null;

				while (iterator.hasNext()) {
					objetoConsumo = (Object[]) iterator.next();
					consumoHistorico = new ConsumoHistorico();
					consumoHistoricoEsgoto = new ConsumoHistorico();

					consumoHistorico
							.setReferenciaFaturamento(((Integer) objetoConsumo[0])
									.intValue());
					// =============================== Consumo Medido
					medicaoHistorico = new MedicaoHistorico();
					medicaoHistorico
							.setNumeroConsumoMes((Integer) objetoConsumo[1]);

					consumoHistorico
							.setNumeroConsumoFaturadoMes((Integer) objetoConsumo[2]);

					consumoHistorico
							.setConsumoRateio((Integer) objetoConsumo[3]);

					// =============================== Anormalidade Consumo
//					consumoAnormalidade = new ConsumoAnormalidade();
//					
//					/**
//					 * 
//					 * Alteracao para enviar o ID da anormalidade de consumo
//					 */
//					if (ligacaoAgua) {
//						consumoAnormalidade.setId((Integer) objetoConsumo[22]);
//					}
//					consumoAnormalidade.setDescricao((String) objetoConsumo[4]);
//					consumoHistorico
//							.setConsumoAnormalidade(consumoAnormalidade);
					
					// =============================== consumoTipo
					consumoTipo = new ConsumoTipo();
					consumoTipo.setDescricao((String) objetoConsumo[5]);
					consumoTipo
							.setDescricaoAbreviada((String) objetoConsumo[6]);
					consumoHistorico.setConsumoTipo(consumoTipo);

					// ==================== Dias de Consumo
					int diasConsumo = 0;
					if (objetoConsumo[7] != null && objetoConsumo[8] != null) {
						diasConsumo = Util.obterQuantidadeDiasEntreDuasDatas(
								(Date) objetoConsumo[7],
								(Date) objetoConsumo[8]);
					}
					if (ligacaoAgua) {
						consumoHistoricoEsgoto
								.setNumeroConsumoFaturadoMes((Integer) objetoConsumo[9]);
					}

					imovelMicromedicao = new ImovelMicromedicao();

					imovelMicromedicao.setConsumoHistorico(consumoHistorico);
					imovelMicromedicao
							.setConsumoHistoricoEsgoto(consumoHistoricoEsgoto);
					imovelMicromedicao.setMedicaoHistorico(medicaoHistorico);
					imovelMicromedicao.setQtdDias("" + diasConsumo);

					if (ligacaoAgua) {
						if (objetoConsumo[10] != null) {
							consumoHistorico
									.setConsumoMedio((Integer) objetoConsumo[10]);
						}
						if (objetoConsumo[11] != null) {
							LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
							leituraAnormalidade
									.setId((Integer) objetoConsumo[11]);

							medicaoHistorico
									.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
						}

						if (objetoConsumo[12] != null) {
							medicaoHistorico
									.setNumeroConsumoInformado((Integer) objetoConsumo[12]);
						}
						if (objetoConsumo[13] != null) {
							consumoAnormalidade
									.setDescricaoAbreviada((String) objetoConsumo[13]);
						}

						if (objetoConsumo[14] != null) {
							consumoHistorico
									.setConsumoRateio((Integer) objetoConsumo[14]);
						}

						if (objetoConsumo[15] != null) {
							consumoHistorico
									.setNumeroConsumoCalculoMedia((Integer) objetoConsumo[15]);
						}
						
						/**
						 * 
						 * Alteracao para enviar o ID da anormalidade de consumo
						 */
						if (objetoConsumo[16] != null) {
							
							consumoAnormalidade.setId((Integer) objetoConsumo[16]);
							consumoAnormalidade.setDescricao((String) objetoConsumo[4]);
							consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);
						}

					} else {
						if (objetoConsumo[10] != null) {
							LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
							leituraAnormalidade
									.setId((Integer) objetoConsumo[10]);

							medicaoHistorico
									.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
						}
						if (objetoConsumo[11] != null) {
							medicaoHistorico
									.setNumeroConsumoInformado((Integer) objetoConsumo[11]);
						}
						if (objetoConsumo[12] != null) {
							consumoAnormalidade
									.setDescricaoAbreviada((String) objetoConsumo[12]);
						}
						if (objetoConsumo[13] != null) {
							consumoHistorico
									.setConsumoRateio((Integer) objetoConsumo[13]);
						}
						if (objetoConsumo[14] != null) {
							consumoHistorico
									.setNumeroConsumoCalculoMedia((Integer) objetoConsumo[14]);
						}
					}

					retorno.add(imovelMicromedicao);
				}
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * 
	 * Método utilizado para pesquisar os consumo historicos a serem
	 * substituidos pelo caso de uso [UC0106] Substituir Consumos Anteriores
	 * 
	 */
	public Collection pesquisaConsumoHistoricoSubstituirConsumo(Integer idImovel)
			throws ControladorException {
		Collection retorno = new ArrayList();
		try {
			FiltroSistemaParametro filtroSistemaParametro = new FiltroSistemaParametro();
			Collection colecaoSistema = getControladorUtil().pesquisar(
					filtroSistemaParametro, SistemaParametro.class.getName());
			SistemaParametro sistemaParametro = (SistemaParametro) Util
					.retonarObjetoDeColecao(colecaoSistema);

			Integer anoMesFaturamento = repositorioFaturamento
					.retornaAnoMesFaturamentoGrupo(idImovel);

			Collection resultado = repositorioMicromedicao
					.pesquisaConsumoHistoricoSubstituirConsumo(idImovel,
							sistemaParametro, anoMesFaturamento);
			if (resultado != null && !resultado.isEmpty()) {
				ConsumoHistorico consumoHistoricoAgua = null;
				ConsumoHistorico consumoHistoricoEsgoto = null;
				ImovelMicromedicao imovelMicromedicao = null;

				Object[] objetoResultado = null;
				Iterator iterator = resultado.iterator();

				while (iterator.hasNext()) {
					consumoHistoricoAgua = new ConsumoHistorico();
					consumoHistoricoEsgoto = new ConsumoHistorico();
					imovelMicromedicao = new ImovelMicromedicao();

					objetoResultado = (Object[]) iterator.next();

					// ligacao tipo
					LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
					ligacaoTipoAgua
							.setId(objetoResultado[0] != null ? ((Integer) objetoResultado[0])
									.intValue() : null);
					consumoHistoricoAgua.setLigacaoTipo(ligacaoTipoAgua);
					LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
					ligacaoTipoAgua
							.setId(objetoResultado[1] != null ? ((Integer) objetoResultado[1])
									.intValue() : null);
					consumoHistoricoEsgoto.setLigacaoTipo(ligacaoTipoEsgoto);

					// consumo Mes
					consumoHistoricoAgua
							.setNumeroConsumoCalculoMedia(objetoResultado[2] != null ? ((Integer) objetoResultado[2])
									.intValue() : 0);
					consumoHistoricoEsgoto
							.setNumeroConsumoCalculoMedia(objetoResultado[3] != null ? ((Integer) objetoResultado[3])
									.intValue() : 0);

					// consumo tipo
					ConsumoTipo consumoTipoAgua = new ConsumoTipo();
					consumoTipoAgua
							.setDescricaoAbreviada(objetoResultado[4] != null ? (String) objetoResultado[4]
									: "");
					consumoHistoricoAgua.setConsumoTipo(consumoTipoAgua);

					ConsumoTipo consumoTipoEsgoto = new ConsumoTipo();
					consumoTipoEsgoto
							.setDescricaoAbreviada(objetoResultado[5] != null ? (String) objetoResultado[5]
									: "");
					consumoHistoricoEsgoto.setConsumoTipo(consumoTipoEsgoto);

					// consumo anormalidade
					ConsumoAnormalidade consumoAnormalidadeAgua = new ConsumoAnormalidade();
					consumoAnormalidadeAgua
							.setDescricaoAbreviada(objetoResultado[6] != null ? (String) objetoResultado[6]
									: "");
					consumoHistoricoAgua
							.setConsumoAnormalidade(consumoAnormalidadeAgua);

					ConsumoAnormalidade consumoAnormalidadeEsgoto = new ConsumoAnormalidade();
					consumoAnormalidadeEsgoto
							.setDescricaoAbreviada(objetoResultado[7] != null ? (String) objetoResultado[7]
									: "");
					consumoHistoricoEsgoto
							.setConsumoAnormalidade(consumoAnormalidadeEsgoto);

					// id consumo historico
					consumoHistoricoAgua
							.setId(objetoResultado[8] != null ? ((Integer) objetoResultado[8])
									.intValue() : null);
					consumoHistoricoEsgoto
							.setId(objetoResultado[9] != null ? ((Integer) objetoResultado[9])
									.intValue() : null);

					// consumo ano Mes referencia
					consumoHistoricoAgua
							.setReferenciaFaturamento(objetoResultado[10] != null ? ((Integer) objetoResultado[10])
									.intValue() : 0);
					consumoHistoricoEsgoto
							.setReferenciaFaturamento(objetoResultado[11] != null ? ((Integer) objetoResultado[11])
									.intValue() : 0);

					if (consumoHistoricoAgua.getId() != null) {
						imovelMicromedicao
								.setConsumoHistorico(consumoHistoricoAgua);
					}
					if (consumoHistoricoEsgoto.getId() != null) {
						imovelMicromedicao
								.setConsumoHistoricoEsgoto(consumoHistoricoEsgoto);
					}

					if (objetoResultado[12] != null) {
						imovelMicromedicao
								.setAnoMesGrupoFaturamento((Integer) objetoResultado[12]);
					}

					retorno.add(imovelMicromedicao);
				}
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Atualiza o valor de cshi_nnconsumoFaturadomes consumo historico [UC0106]
	 * - Substituir Consumos Anteriores
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarConsumosAnteriores(ConsumoHistorico consumoHistorico)
			throws ControladorException {

		try {
			repositorioMicromedicao
					.atualizarConsumosAnteriores(consumoHistorico);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * Método que apresenta os dados do imovel
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 * 
	 * @author Flávio Cordeiro, Ivan Sérgio
	 * @date 04/08/2006, 06/03/2008
	 * @alteracao: Trocar idHidrometroHistorico por idPoco, pois alguns imoveis
	 *             nao possuem registro na tabela de
	 *             HidrometroInstalacaoHistorico mas possuem poco.
	 * 
	 * @param idImovel
	 * @return Collection
	 */
	public ImovelMicromedicao pesquiarImovelExcecoesApresentaDadosResumido(
			Integer idImovel, boolean ligacaoAgua) throws ControladorException {

		ImovelMicromedicao imovelMicromedicao = new ImovelMicromedicao();

		try {
			Collection resultado = repositorioMicromedicao
					.pesquiarImovelExcecoesApresentaDadosResumido(idImovel,
							ligacaoAgua);

			if (!resultado.isEmpty()) {
				HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();

				Object[] objetoResultado = (Object[]) resultado.iterator()
						.next();

				// faturamento grupo(id 0 , anomes 1)
				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				if (objetoResultado[0] != null) {
					faturamentoGrupo.setId((Integer) objetoResultado[0]);
				}
				if (objetoResultado[1] != null) {
					faturamentoGrupo
							.setAnoMesReferencia((Integer) objetoResultado[1]);
				}
				// Imovel (icCondominio 2)
				Imovel imovel = new Imovel();
				if (objetoResultado[2] != null) {
					imovel.setIndicadorImovelCondominio((Short) objetoResultado[2]);
				}
				// Ligacao Agua Situacao (descricao 3)
				LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
				if (objetoResultado[3] != null) {
					ligacaoAguaSituacao.setId((Integer) objetoResultado[14]);
					ligacaoAguaSituacao
							.setDescricao((String) objetoResultado[3]);
					ligacaoAguaSituacao
							.setIndicadorFaturamentoSituacao((Short) objetoResultado[17]);
					imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
				}
				// Ligacao Esgoto Situacao (descricao 4)
				LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
				if (objetoResultado[4] != null) {
					ligacaoEsgotoSituacao.setId((Integer) objetoResultado[15]);
					ligacaoEsgotoSituacao
							.setIndicadorFaturamentoSituacao((Short) objetoResultado[18]);
					ligacaoEsgotoSituacao
							.setDescricao((String) objetoResultado[4]);
					imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
				}
				// Hidrometro (numero 5)
				Hidrometro hidrometro = new Hidrometro();
				if (objetoResultado[5] != null) {
					hidrometro.setNumero((String) objetoResultado[5]);
					hidrometroInstalacaoHistorico.setHidrometro(hidrometro);
					imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
				}
				// Hidrometro Instalacao Historico (data Instalcao 6)
				if (objetoResultado[6] != null) {
					hidrometroInstalacaoHistorico
							.setDataInstalacao((Date) objetoResultado[6]);
				}
				// hidrometro (capacidade 7)
				HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
				if (objetoResultado[7] != null) {
					hidrometroCapacidade
							.setDescricao((String) objetoResultado[7]);
					hidrometro.setHidrometroCapacidade(hidrometroCapacidade);
				}
				// Imovel Perfil (descricao 8)
				ImovelPerfil imovelPerfil = new ImovelPerfil();
				if (objetoResultado[8] != null) {
					imovelPerfil.setId((Integer) objetoResultado[16]);
					imovelPerfil.setDescricao((String) objetoResultado[8]);
					imovel.setImovelPerfil(imovelPerfil);
				}
				// Imovel Condominio (id 9)
				Imovel imovelCondominio = new Imovel();
				if (objetoResultado[9] != null) {
					imovelCondominio.setId((Integer) objetoResultado[9]);
					imovel.setImovelCondominio(imovelCondominio);
				}
				// Imovel (qtdEconomias 10)
				if (objetoResultado[10] != null) {
					imovel.setQuantidadeEconomias((Short) objetoResultado[10]);
				}

				// Imovel (idHidrometroHistorico 11)
				// if (objetoResultado[11] != null) {
				// hidrometroInstalacaoHistorico
				// .setId((Integer) objetoResultado[11]);
				// }
				// Imovel (idPoco 11)
				if (objetoResultado[11] != null) {
					PocoTipo pocoTipo = new PocoTipo();
					pocoTipo.setId((Integer) objetoResultado[11]);

					imovel.setPocoTipo(pocoTipo);
				}
				// numeroDigitosLeitura Hidrometro(12)
				if (objetoResultado[12] != null) {
					hidrometro
							.setNumeroDigitosLeitura((Short) objetoResultado[12]);
				}

				// Imovel (área construída 13)
				if (objetoResultado[13] != null) {
					imovel.setAreaConstruida((BigDecimal) objetoResultado[13]);
				}

				// montagem do objeto imovelMicromedicao
				imovelMicromedicao.setImovel(imovel);
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return imovelMicromedicao;
	}

	/**
	 * 
	 * Retorna um objeto com os dados das medicoes para apresentação
	 * 
	 * Flávio
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 */
	public ImovelMicromedicao carregarDadosMedicaoResumido(Integer idImovel,
			boolean ligacaoAgua, String anoMes) throws ControladorException {

		ImovelMicromedicao imovelMicromedicao = new ImovelMicromedicao();

		try {
			Object[] resultado = repositorioMicromedicao
					.carregarDadosMedicaoResumido(idImovel, ligacaoAgua, anoMes);

			MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
			if (resultado != null) {
				// (anoMes 0)
				if (resultado[0] != null) {
					medicaoHistorico
							.setAnoMesReferencia((Integer) resultado[0]);
				}
				// medicao hitorico (dataLeitura atual informada 1)
				if (resultado[1] != null) {
					medicaoHistorico
							.setDataLeituraAtualInformada((Date) resultado[1]);
				}
				// medicao historico (numero leitura atual informada 2)
				if (resultado[2] != null) {
					medicaoHistorico
							.setLeituraAtualInformada((Integer) resultado[2]);
				}
				// medicao historico (numero leitura anterior faturada 3)
				if (resultado[3] != null) {
					medicaoHistorico
							.setDataLeituraAnteriorFaturamento((Date) resultado[3]);
				}
				// medicao historico (numeroLeituraAnteriorFaturada 4)
				if (resultado[4] != null) {
					medicaoHistorico
							.setLeituraAnteriorFaturamento((Integer) resultado[4]);
				}
				// Anormalidade Leitura (descricaoAnormalidadeLeituraInformada
				// 5)
				LeituraAnormalidade leituraAnormalidadeInformada = new LeituraAnormalidade();
				if (resultado[5] != null) {
					leituraAnormalidadeInformada
							.setDescricao((String) resultado[5]);
				}
				// Anormalidade Leitura (descricaoAnormalidadeLeituraInformada
				// 6)
				LeituraAnormalidade leituraAnormalidadeFaturada = new LeituraAnormalidade();
				if (resultado[6] != null) {
					leituraAnormalidadeFaturada
							.setDescricao((String) resultado[6]);
				}
				// medicao historico (numeroVezesConsecutivosAnormalidade 7)
				if (resultado[7] != null) {
					medicaoHistorico
							.setNumeroVezesConsecutivasOcorrenciaAnormalidade((Short) resultado[7]);
				}
				// medicao historico (idFuncionario 8)
				Funcionario funcionario = new Funcionario();
				if (resultado[8] != null) {
					funcionario.setId((Integer) resultado[8]);
					medicaoHistorico.setFuncionario(funcionario);
				}
				// medicao historico (leituraSituacao 9)
				LeituraSituacao leituraSituacao = new LeituraSituacao();
				if (resultado[9] != null) {
					leituraSituacao.setDescricao((String) resultado[9]);
					medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
				}
				// Data Leitura Anterior Faturada
				if (resultado[10] != null) {
					medicaoHistorico
							.setDataLeituraAtualFaturamento((Date) resultado[10]);
				}
				// numero Leitura Anterior Faturada
				if (resultado[11] != null) {
					medicaoHistorico
							.setLeituraAtualFaturamento((Integer) resultado[11]);
				}
				// numero Leitura Anterior Faturada
				if (resultado[12] != null) {
					LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
					leituraAnormalidade.setId((Integer) resultado[12]);
					medicaoHistorico
							.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
				}
				// consumo informado
				if (resultado[13] != null) {
					medicaoHistorico
							.setNumeroConsumoInformado((Integer) resultado[13]);
				}
				// consumo informado
				if (resultado[14] != null) {
					medicaoHistorico
							.setConsumoMedioHidrometro((Integer) resultado[14]);
				}
				// motivo da interferencia
				if (resultado[15] != null) {
					MotivoInterferenciaTipo motivoInterferenciaTipo = new MotivoInterferenciaTipo();
					motivoInterferenciaTipo.setId((Integer) resultado[15]);
					medicaoHistorico
							.setMotivoInterferenciaTipo(motivoInterferenciaTipo);
				}
				imovelMicromedicao.setMedicaoHistorico(medicaoHistorico);
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return imovelMicromedicao;
	}

	/**
	 * Atualizar Analise excecoes consumo resumido
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarLeituraConsumoResumido(Integer idImovel,
			String mesAno, String dataLeituraAnteriorFaturamento,
			String leituraAnteriorFaturamento,
			String dataLeituraAtualInformada, String leituraAtualInformada,
			String consumo, boolean ligacaoAgua, Integer idAnormalidade,
			Integer idleituraSituacaoAtual, FaturamentoGrupo faturamentoGrupo,
			Usuario usuarioLogado, boolean alterouAnormalidade,
			MotivoInterferenciaTipo motivoInterferenciaTipo,
			Integer idMedicaoTipo) throws ControladorException {

		try {
			// ----------INICIO REGISTRAR TRANSAÇÃO-----------------
			/**
			 * @author Arthur Carvalho
			 * @date 26/03/2010
			 */
			selecionarAtualizaConsumoHistoricoREGISTRATRANSACAO(idImovel,
					mesAno, usuarioLogado);

			selecionaAtualizaMedicaoHistoricoREGISTRATRANSACAO(idImovel,
					mesAno, dataLeituraAnteriorFaturamento,
					leituraAnteriorFaturamento, dataLeituraAtualInformada,
					leituraAtualInformada, consumo, ligacaoAgua,
					idAnormalidade, idleituraSituacaoAtual, usuarioLogado,
					alterouAnormalidade, motivoInterferenciaTipo);

			// -----------FIM REGISTRAR TRANSAÇÃO ------------------

			repositorioMicromedicao.atualizarLeituraConsumoResumido(idImovel,
					mesAno, dataLeituraAnteriorFaturamento,
					leituraAnteriorFaturamento, dataLeituraAtualInformada,
					leituraAtualInformada, consumo, ligacaoAgua,
					idAnormalidade, idleituraSituacaoAtual, usuarioLogado,
					alterouAnormalidade, motivoInterferenciaTipo);

			Collection colecaoIdImovel = new ArrayList();
			colecaoIdImovel.add(idImovel);

			this.consistirLeiturasCalcularConsumosImoveis(faturamentoGrupo,
					colecaoIdImovel);

			this.atualizarMovimentoContaPreFaturada(idImovel, mesAno,
					idMedicaoTipo, dataLeituraAtualInformada,
					leituraAtualInformada, alterouAnormalidade, idAnormalidade);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Atualizar Analise excecoes consumo resumido
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorAnalisadoMedicaoHistorico(
			Integer idMedicaoHistorico, Usuario usuarioLogado)
			throws ControladorException {

		try {
			repositorioMicromedicao
					.atualizarIndicadorAnalisadoMedicaoHistorico(
							idMedicaoHistorico, usuarioLogado);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Método que retorna um arrey de Object com informações do histórico de
	 * consumo com tipo de medição poco
	 * 
	 * [UC0348] Emitir Contas
	 * 
	 * [SB0006] Obter Dados de consumo da conta
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * 
	 * 
	 * @param idImovel
	 * @param anoMes
	 * @param idTipoLigacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterDadosConsumoConta(Integer idImovel,
			int anoMesReferencia, Integer idTipoLigacao)
			throws ControladorException {

		try {
			return repositorioMicromedicao.obterDadosConsumoConta(idImovel,
					anoMesReferencia, idTipoLigacao);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Método que retorna o número da leitura de retirada do hidrômetro
	 * 
	 * @author Ana Maria
	 * @date 25/09/2006
	 * 
	 * @param idLigacaoAgua
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarNumeroLeituraRetiradaLigacaoAgua(
			Integer idLigacaoAgua) throws ControladorException {

		try {
			return repositorioMicromedicao
					.pesquisarNumeroLeituraRetiradaLigacaoAgua(idLigacaoAgua);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Método que retorna o número da leitura de retirada do hidrômetro
	 * 
	 * @author Ana Maria
	 * @date 25/09/2006
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarNumeroLeituraRetiradaImovel(Integer idImovel)
			throws ControladorException {

		try {
			return repositorioMicromedicao
					.pesquisarNumeroLeituraRetiradaImovel(idImovel);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0000] - Efetuar Retirada de Hidrômetro
	 * 
	 * Pesquisa todos os campos do Hidrometro e seus relacionamentos
	 * obrigatórios.
	 * 
	 * @author Thiago Tenório
	 * @date 28/09/2006
	 * 
	 * @param idHidrometro
	 * @throws ControladorException
	 */
	public Hidrometro pesquisarHidrometroPeloId(Integer idHidrometro)
			throws ControladorException {
		Hidrometro hidrometro = new Hidrometro();

		try {
			Object[] resultado = repositorioHidrometro
					.pesquisarHidrometroPeloId(idHidrometro);

			if (resultado != null) {
				// Id do Hidrômetro
				if (resultado[0] != null) { // 0
					hidrometro.setId((Integer) resultado[0]);
				}
				// Número do Hidrômetro
				if (resultado[1] != null) { // 1
					hidrometro.setNumero((String) resultado[1]);
				}
				// Data de Aquisição do Hidrômetro
				if (resultado[2] != null) { // 2
					hidrometro.setDataAquisicao((Date) resultado[2]);
				}
				// Ano de Fabricação do Hidrômetro
				if (resultado[3] != null) { // 3
					hidrometro.setAnoFabricacao((Short) resultado[3]);
				}
				// Indicado Macromedidor do Hidrômetro
				if (resultado[4] != null) { // 4
					hidrometro.setIndicadorMacromedidor((Short) resultado[4]);
				}
				// Data da Última Revisão do Hidrômetro
				if (resultado[5] != null) { // 5
					hidrometro.setDataUltimaRevisao((Date) resultado[5]);
				}
				// Data da Baixa do Hidrômetro
				if (resultado[6] != null) { // 6
					hidrometro.setDataBaixa((Date) resultado[6]);
				}
				// Número da Leitura Acumulada do Hidrômetro
				if (resultado[7] != null) { // 7
					hidrometro
							.setNumeroLeituraAcumulada((Integer) resultado[7]);
				}
				// Número de Dígitos de Leitura do Hidrômetro
				if (resultado[8] != null) { // 8
					hidrometro.setNumeroDigitosLeitura((Short) resultado[8]);
				}
				// Tipo do Hidrômetro
				if (resultado[9] != null) { // 9
					HidrometroTipo hidrometroTipo = new HidrometroTipo();
					hidrometroTipo.setId((Integer) resultado[9]);
					hidrometro.setHidrometroTipo(hidrometroTipo);
				}
				// Situação do Hidrômetro
				if (resultado[10] != null) { // 10
					HidrometroSituacao hidrometroSituacao = new HidrometroSituacao();
					hidrometroSituacao.setId((Integer) resultado[10]);
					hidrometro.setHidrometroSituacao(hidrometroSituacao);
				}
				// Marca do Hidrômetro
				if (resultado[11] != null) { // 11
					HidrometroMarca hidrometroMarca = new HidrometroMarca();
					hidrometroMarca.setId((Integer) resultado[11]);
					hidrometro.setHidrometroMarca(hidrometroMarca);
				}
				// Capacidade do Hidrômetro
				if (resultado[12] != null) { // 12
					HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
					hidrometroCapacidade.setId((Integer) resultado[12]);
					hidrometro.setHidrometroCapacidade(hidrometroCapacidade);
				}
				// Classe Metrológica do Hidrômetro
				if (resultado[13] != null) { // 13
					HidrometroClasseMetrologica hidrometroClasseMetrologica = new HidrometroClasseMetrologica();
					hidrometroClasseMetrologica.setId((Integer) resultado[13]);
					hidrometro
							.setHidrometroClasseMetrologica(hidrometroClasseMetrologica);
				}
				// Diâmetro do Hidrômetro
				if (resultado[14] != null) { // 14
					HidrometroDiametro hidrometroDiametro = new HidrometroDiametro();
					hidrometroDiametro.setId((Integer) resultado[14]);
					hidrometro.setHidrometroDiametro(hidrometroDiametro);
				}
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return hidrometro;
	}

	/**
	 * Método que retorna o consumo médio do imóvel
	 * 
	 * @author Ana Maria
	 * @date 17/10/2006
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarConsumoMedioImovel(Integer idImovel)
			throws ControladorException {

		try {
			return repositorioMicromedicao
					.pesquisarConsumoMedioImovel(idImovel);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 15/11/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Integer pesquisarConsumoMedio(Integer idImovel, Integer tipoMedicao)
			throws ControladorException {

		try {
			return repositorioMicromedicao.pesquisarConsumoMedio(idImovel,
					tipoMedicao);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2007
	 * 
	 * @param Integer
	 *            idImovel, Integer tipoMedicao
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarUltimoAnoMesConsumoFaturado(Integer idImovel,
			Integer tipoMedicao) throws ControladorException {

		try {

			return repositorioMicromedicao
					.pesquisarUltimoAnoMesConsumoFaturado(idImovel, tipoMedicao);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 15/11/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Integer pesquisarMaiorConsumoFaturadoQuantidadeMeses(
			Integer idImovel, Integer tipoMedicao, short qtdMeses)
			throws ControladorException {

		Collection colecaoConsumoFaturaMes = null;
		Integer retorno = null;

		try {
			colecaoConsumoFaturaMes = repositorioMicromedicao
					.pesquisarConsumoFaturadoQuantidadeMeses(idImovel,
							tipoMedicao, qtdMeses);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		if (colecaoConsumoFaturaMes != null
				&& !colecaoConsumoFaturaMes.isEmpty()) {

			Iterator iteratorConsumoFaturaMes = colecaoConsumoFaturaMes
					.iterator();

			Integer maiorValor = 0;
			Integer valorMomento = 0;

			while (iteratorConsumoFaturaMes.hasNext()) {
				Object[] dados = (Object[]) iteratorConsumoFaturaMes.next();

				valorMomento = (Integer) dados[0];

				if (valorMomento != null && valorMomento > maiorValor) {
					maiorValor = valorMomento;
				}
			}

			retorno = maiorValor;
		}

		return retorno;
	}

	/**
	 * Atualizar Hidrômetro
	 * 
	 * Pesquisa o imóvel no qual o hidrômetro está instalado
	 * 
	 * @author Rafael Corrêa
	 * @date 23/11/2006
	 * 
	 * @param idHidrometro
	 * @return String
	 * @throws ControladorException
	 */
	public String pesquisarImovelHidrometroInstalado(Integer idHidrometro)
			throws ControladorException {

		String idImovel = "";
		Object[] dadosHidrometro = null;

		try {

			dadosHidrometro = repositorioMicromedicao
					.pesquisarImovelHidrometroInstalado(idHidrometro);

			if (dadosHidrometro != null) {

				// Id do Imóvel
				if (dadosHidrometro[0] != null) { // 0
					idImovel = ((Integer) dadosHidrometro[0]).toString();
				}
				// Id da Ligação de Água
				if (dadosHidrometro[1] != null) { // 1
					idImovel = ((Integer) dadosHidrometro[1]).toString();
				}
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return idImovel;
	}

	/**
	 * [UC0498] - Efetuar Ligação de Água com Instalaação de Hidrômetro
	 * 
	 * Pesquisa o id do hidrômetro e a sua situação pelo número
	 * 
	 * @author Rafael Corrêa
	 * @date 29/11/2006
	 * 
	 * @param numeroHidrometro
	 * @return Hidrometro
	 * @throws ControladorException
	 */
	public Hidrometro pesquisarHidrometroPeloNumero(String numeroHidrometro)
			throws ControladorException {

		Hidrometro hidrometro = null;
		Object[] dadosHidrometro = null;

		try {

			dadosHidrometro = repositorioMicromedicao
					.pesquisarHidrometroPeloNumero(numeroHidrometro);

			if (dadosHidrometro != null) {

				hidrometro = new Hidrometro();

				// Id do Hidrômetro
				if (dadosHidrometro[0] != null) { // 0
					hidrometro.setId((Integer) dadosHidrometro[0]);
				}

				// Número do Hidrômetro
				if (dadosHidrometro[1] != null) { // 1
					hidrometro.setNumero((String) dadosHidrometro[1]);
				}

				// Situação do Hidrômetro
				if (dadosHidrometro[2] != null) { // 2

					HidrometroSituacao hidrometroSituacao = new HidrometroSituacao();
					hidrometroSituacao.setId((Integer) dadosHidrometro[2]);
					hidrometroSituacao
							.setDescricao((String) dadosHidrometro[3]);

					hidrometro.setHidrometroSituacao(hidrometroSituacao);

				}

				// Hidrômetro Capacidade
				if (dadosHidrometro[4] != null) { // 4

					HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
					hidrometroCapacidade.setId((Integer) dadosHidrometro[4]);
					hidrometroCapacidade
							.setDescricao((String) dadosHidrometro[5]);

					hidrometro.setHidrometroCapacidade(hidrometroCapacidade);

				}

				// Hidrômetro Local Armazenagem
				if (dadosHidrometro[6] != null) { // 4

					HidrometroLocalArmazenagem hidrometroLocalArmazenagem = new HidrometroLocalArmazenagem();
					hidrometroLocalArmazenagem
							.setId((Integer) dadosHidrometro[6]);

					hidrometro
							.setHidrometroLocalArmazenagem(hidrometroLocalArmazenagem);

				}

			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return hidrometro;
	}

	/**
	 * [UC0498] - Efetuar Ligação de Água com Instalaação de Hidrômetro
	 * 
	 * Pesquisa o id do hidrômetro e a sua situação pelo número
	 * 
	 * @author Rafael Corrêa
	 * @date 29/11/2006
	 * 
	 * @param numeroHidrometro
	 * @return Hidrometro
	 * @throws ControladorException
	 */
	public Hidrometro pesquisarHidrometroNumeroSituacao(String numeroHidrometro, Integer idSituacao)
			throws ControladorException {

		Hidrometro hidrometro = null;

		try {

			hidrometro = repositorioMicromedicao
					.pesquisarHidrometroNumeroSituacao(numeroHidrometro, idSituacao);


		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return hidrometro;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 06/12/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Date pesquisarDataInstalacaoHidrometroAgua(Integer idImovel)
			throws ControladorException {

		Date dataInstalacao = null;

		try {

			dataInstalacao = repositorioMicromedicao
					.pesquisarDataInstalacaoHidrometroAgua(idImovel);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return dataInstalacao;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 06/12/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Date pesquisarDataInstalacaoHidrometroPoco(Integer idImovel)
			throws ControladorException {

		Date dataInstalacao = null;

		try {

			dataInstalacao = repositorioMicromedicao
					.pesquisarDataInstalacaoHidrometroPoco(idImovel);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return dataInstalacao;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 14/11/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */
	public Integer pesquisarConsumoFaturaMes(Integer amReferencia,
			Integer idLigacao, Integer idImovel) throws ControladorException {

		Integer consumoHistoricoMes = null;

		try {

			consumoHistoricoMes = repositorioMicromedicao
					.pesquisarConsumoFaturaMes(amReferencia, idLigacao,
							idImovel);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return consumoHistoricoMes;
	}

	/**
	 * [] Ligacoes Medicao Individualizada
	 * 
	 * 
	 * @author Flávio Cordeiro
	 * @date 17/12/2006
	 * 
	 * @param colecaoLigacoesMedicao
	 * @throws ControladorException
	 */
	public void atualizarLigacoesMedicaoIndividualizada(
			Collection colecaoLigacoesMedicao, Usuario usuarioLogado,
			Integer anoMes) throws ControladorException {
		try {

			// itera a colecao para validar se existem as
			// anormalidades(Leitura,Consumo) digitadas.
			Iterator iterator = colecaoLigacoesMedicao.iterator();
			LigacaoMedicaoIndividualizadaHelper ligacaoMedicaoIndividualizadaHelper = null;
			Collection colecaoLeituraAnormalidade = null;

			while (iterator.hasNext()) {
				ligacaoMedicaoIndividualizadaHelper = (LigacaoMedicaoIndividualizadaHelper) iterator
						.next();

				// testa se existe a anormalidade de leitura
				if (ligacaoMedicaoIndividualizadaHelper
						.getIdLeituraAnormalidade() != null) {
					FiltroLeituraAnormalidade filtroLeituraAnormalidade = new FiltroLeituraAnormalidade();
					filtroLeituraAnormalidade
							.adicionarParametro(new ParametroSimples(
									FiltroLeituraAnormalidade.ID,
									ligacaoMedicaoIndividualizadaHelper
											.getIdLeituraAnormalidade()));
					colecaoLeituraAnormalidade = getControladorUtil()
							.pesquisar(filtroLeituraAnormalidade,
									LeituraAnormalidade.class.getName());
					if (colecaoLeituraAnormalidade.isEmpty()) {
						sessionContext.setRollbackOnly();
						throw new ControladorException(
								"atencao.anormalidade_ligacoes_invalida", null,
								ligacaoMedicaoIndividualizadaHelper
										.getIdImovel().toString());

					}
				}
				repositorioMicromedicao
						.atualizarLigacoesMedicaoIndividualizada(
								ligacaoMedicaoIndividualizadaHelper, anoMes);
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Obtém os ids de todas as rotas cadastradas menos as rotas que tiverem o
	 * emp_cobranca = 1
	 * 
	 * [UC0251] - Gerar Atividade de Ação de Cobrança
	 * 
	 * [SB0002] - Gerar Atividade de Ação de Cobrança para os Imóveis da Lista
	 * de Rotas
	 * 
	 * @author Sávio Luiz
	 * @date 05/03/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarListaRotas() throws ControladorException {

		Collection retorno = null;

		try {

			retorno = repositorioMicromedicao.pesquisarListaRotas();

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	public Collection pesquisarListaRotasEspecificas()
			throws ControladorException {

		Collection retorno = null;

		try {

			retorno = repositorioMicromedicao.pesquisarListaRotasEspecificas();

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar o arquivo em TXT
	 * 
	 * @author Rafael Francisco Pinto
	 * @date 19/01/2007
	 * 
	 * @param ano
	 *            e mes corrente
	 * @param id
	 *            grupo faturamento
	 * 
	 * @throws ControladorException
	 */

	protected void gerarArquivoConvencional(Integer anoMesCorrente,
			Integer idGrupoFaturamentoRota, StringBuilder arquivoTxtLinha,
			Integer idRota, boolean ehSistemaLegado)
			throws ControladorException {

		try {

			String nomeZipRol = null;

			if (ehSistemaLegado) {
				nomeZipRol = "ROL_SISTEMA_LEGADO_";
			} else {
				nomeZipRol = "ROL_";
			}

			/*
			 * Alterado por Raphael Rossiter em 30/03/2007 OBJ: Gerar apenas um
			 * arquivo para todas as rotas
			 */
			if (idRota != null) {
				nomeZipRol = nomeZipRol + idGrupoFaturamentoRota + "_" + idRota
						+ "_" + anoMesCorrente + "-";
			} else {
				nomeZipRol = nomeZipRol + idGrupoFaturamentoRota + "_"
						+ anoMesCorrente + "-";
			}

			File compactadoTipoRol = new File(nomeZipRol + ".zip");
			File leituraTipoRol = File.createTempFile(nomeZipRol, ".txt");

			ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(
					compactadoTipoRol));

			BufferedWriter out = new BufferedWriter(new OutputStreamWriter(
					new FileOutputStream(leituraTipoRol.getAbsolutePath())));

			out.write(arquivoTxtLinha.toString());
			out.flush();

			ZipUtil.adicionarArquivo(zos, leituraTipoRol);
			zos.close();

			leituraTipoRol.delete();
			out.close();
		} catch (IOException e) {
			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");

			if (inicioMensagem != null
					&& (inicioMensagem[0].equals("erro") || inicioMensagem[0]
							.equals("atencao"))) {
				throw new ControladorException(mensagem);
			} else {
				throw new ControladorException("erro.sistema", e);
			}
		} catch (Exception e) {
			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");
			if (inicioMensagem != null
					&& (inicioMensagem[0].equals("erro") || inicioMensagem[0]
							.equals("atencao"))) {

				throw new ControladorException(mensagem);
			} else {
				throw new ControladorException("erro.sistema", e);
			}
		}
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT - Registro 0
	 * 
	 * @author Rafael Francisco Pinto, Raphael Rossiter
	 * @date 22/01/2007, 28/03/2007
	 * 
	 * @param imovel
	 *            , pagina, anoMesFaturamento
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroZERO(
			Imovel imovel, int pagina, String anoMesFaturamento)
			throws ControladorException {

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.1.1 - Tipo de Registro 0 (ZERO)
		arquivoTxtLinha.append("0");

		// 1.1.2 - Distrito (Gerencia Regional)
		arquivoTxtLinha.append(completaString(imovel.getLocalidade()
				.getGerenciaRegional().getNome(), 13));

		// 1.1.3 - Cidade (Localidade)
		arquivoTxtLinha.append(completaString(imovel.getLocalidade()
				.getDescricao(), 20));

		// 1.1.4 - Mês de Referência
		String ano = anoMesFaturamento.substring(0, 4);
		String mes = anoMesFaturamento.substring(4, 6);

		arquivoTxtLinha
				.append(completaString(
						Util.retornaDescricaoMes(Integer.parseInt(mes)) + "/"
								+ ano, 14));

		// 1.1.5 - Cidade (Código da Localidade)
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ imovel.getLocalidade().getId()));

		// 1.1.6 - Setor (Setor Comercial)
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, ""
				+ imovel.getSetorComercial().getCodigo()));

		// 1.1.7 - Rota
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, ""
				+ imovel.getQuadra().getRota().getCodigo()));

		// 1.1.8 - Página
		arquivoTxtLinha
				.append(Util.adicionarZerosEsquedaNumero(4, "" + pagina));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT - Registro 1
	 * 
	 * @author Rafael Francisco Pinto, Raphael Rossiter
	 * @date 22/01/2007, 28/03/2007
	 * 
	 * @param imovel
	 *            , anoMesFaturamento
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroUM(
			Imovel imovel, int anoMesFaturamento) throws ControladorException {

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.2.1 - Tipo de Registro 1 (UM)
		arquivoTxtLinha.append("1");

		// 1.2.1.1 - Nome
		String nomeClienteUsuario = null;
		try {
			// Pesquisa o nome do cliente que tem o tipo de relação usuário.
			nomeClienteUsuario = repositorioClienteImovel
					.pesquisarNomeClientePorImovel(imovel.getId());
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		arquivoTxtLinha.append(completaString(nomeClienteUsuario, 40));

		// 1.2.1.2 - Situação (RETIRAR - DEIXAR ESPAÇOS - COM TAMANHO = 06)
		arquivoTxtLinha.append(completaString("", 6));

		// 1.2.1.3
		Collection colecaoSubCategoria = this.getControladorImovel()
				.obterQuantidadeEconomiasSubCategoria(imovel.getId());

		// 1.2.1.3.1 - SubCategoria 01
		// 1.2.1.3.2 - Quantidade 01
		// 1.2.1.3.3 - SubCategoria 02
		// 1.2.1.3.4 - Quantidade 02
		if (colecaoSubCategoria != null && !colecaoSubCategoria.isEmpty()) {

			Iterator itera = colecaoSubCategoria.iterator();
			int tam = 0;
			while (itera.hasNext()) {
				tam++;
				if (tam < 3) {

					Subcategoria subcategoria = (Subcategoria) itera.next();

					// tipoEconomia = categoria_id(1 posição) +
					// subcategoria_codigo(3 posições)
					arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(1,
							subcategoria.getCategoria().getId() + ""));
					arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2,
							subcategoria.getCodigo() + ""));

					// qtdeEconomia
					arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3,
							"" + subcategoria.getQuantidadeEconomias()));

				} else {
					break;
				}
			}

			if (tam < 2) {
				arquivoTxtLinha.append(completaString("", 6));
			}
		} else {
			arquivoTxtLinha.append(completaString("", 12));
		}

		// 1.2.1.4 - Consumo
		Integer numeroConsumoFaturadoMes = null;

		try {

			// 1.2.1.4.1 - Consumo 01
			int anoMesSubtraido = Util
					.subtrairMesDoAnoMes(anoMesFaturamento, 1);

			numeroConsumoFaturadoMes = repositorioMicromedicao
					.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(
							imovel.getId(), anoMesSubtraido,
							LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if (numeroConsumoFaturadoMes != null) {
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, ""
						+ numeroConsumoFaturadoMes));
			} else {
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(
						"", 4));
			}

			// 1.2.1.4.2 - Consumo 02
			anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 2);
			numeroConsumoFaturadoMes = repositorioMicromedicao
					.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(
							imovel.getId(), anoMesSubtraido,
							LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if (numeroConsumoFaturadoMes != null) {
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, ""
						+ numeroConsumoFaturadoMes));
			} else {
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(
						"", 4));
			}

			// 1.2.1.4.3 - Consumo 03
			anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 3);
			numeroConsumoFaturadoMes = repositorioMicromedicao
					.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(
							imovel.getId(), anoMesSubtraido,
							LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if (numeroConsumoFaturadoMes != null) {
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, ""
						+ numeroConsumoFaturadoMes));
			} else {
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(
						"", 4));
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		// 1.2.1.5 - Condição
		String condicao = null;
		try {
			condicao = this.repositorioMicromedicao.obterDescricaoConsumoTipo(
					imovel.getId(), LigacaoTipo.LIGACAO_AGUA);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		if (condicao != null) {
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(""
					+ condicao, 8));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 8));
		}

		// 1.2.1.6 - Número do Lacre
		if (imovel.getLigacaoAgua().getNumeroLacre() != null) {
			arquivoTxtLinha.append(completaString(imovel.getLigacaoAgua()
					.getNumeroLacre(), 6));
		} else {
			arquivoTxtLinha.append(completaString("", 6));
		}

		// 1.2.1.7 - Matrícula do Imóvel
		arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(imovel
				.getId().toString(), 9));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT - Registro 2
	 * 
	 * @author Rafael Francisco Pinto, Raphael Rossiter
	 * @date 22/01/2007, 28/03/2007
	 * 
	 * @param imovel
	 *            , anoMesCorrente, sistemaParametro
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroDOIS(
			Imovel imovel, Integer anoMesCorrente,
			SistemaParametro sistemaParametro) throws ControladorException {

		StringBuilder arquivoTxtLinha = new StringBuilder();

		boolean ligacaoAgua = false;
		boolean ligacaoPoco = false;

		if (imovel.getLigacaoAgua() != null
				&& imovel.getLigacaoAgua().getId() != null
				&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
				&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()
						.getId() != null) {

			ligacaoAgua = true;
		}

		if (imovel.getHidrometroInstalacaoHistorico() != null
				&& imovel.getHidrometroInstalacaoHistorico().getId() != null) {

			ligacaoPoco = true;
		}

		// Dados do Hidrometro

		Short numeroDigitosHidrometro = null;
		StringBuilder dadosHidrometro = null;

		if (ligacaoAgua && ligacaoPoco) {

			Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

			dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
			numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

		} else {
			if (ligacaoAgua) {

				Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

				dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
				numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

			} else {

				if (ligacaoPoco) {

					Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

					dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
					numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

				} else {
					Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

					dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
					numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

				}
			}
		}

		// 1.2.2 - Tipo de Registro 2 (DOIS)
		arquivoTxtLinha.append("2");

		// 1.2.2.1 - Endereço
		// Pesquisa o endereço do imovel passando o id
		String enderecoImovel = getControladorEndereco()
				.pesquisarEnderecoFormatado(imovel.getId());
		if (enderecoImovel != null && !enderecoImovel.equals("")) {
			// endereço do imóvel
			arquivoTxtLinha.append(completaString(enderecoImovel, 45));
		} else {
			arquivoTxtLinha.append(completaString("", 45));
		}

		// 1.2.2.2 - Hidrômetro
		if (ligacaoPoco && !ligacaoAgua) {

			String numeroHidrometroFinal = imovel
					.getHidrometroInstalacaoHistorico().getHidrometro()
					.getNumero().trim();

			if (numeroHidrometroFinal.length() > 8) {

				numeroHidrometroFinal = numeroHidrometroFinal.substring(
						numeroHidrometroFinal.length() - 8,
						numeroHidrometroFinal.length());

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
						numeroHidrometroFinal));
			} else {

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
						numeroHidrometroFinal));
			}

		} else {

			String numeroHidrometroFinal = imovel.getLigacaoAgua()
					.getHidrometroInstalacaoHistorico().getHidrometro()
					.getNumero().trim();

			if (numeroHidrometroFinal.length() > 8) {

				numeroHidrometroFinal = numeroHidrometroFinal.substring(
						numeroHidrometroFinal.length() - 8,
						numeroHidrometroFinal.length());

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
						numeroHidrometroFinal));
			} else {

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
						numeroHidrometroFinal));
			}
		}

		// 1.2.2.3 - Inscrição do Imovel
		// 1.2.2.3.1 - Quadra
		// 1.2.2.3.2 - Lote
		// 1.2.2.3.3 - SubLote
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ imovel.getQuadra().getNumeroQuadra()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4,
				"" + imovel.getLote()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3,
				"" + imovel.getSubLote()));

		// 1.2.2.4 - Sequencial da Rota
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4,
				"" + imovel.getNumeroSequencialRota()));

		// 1.2.2.5 - Leitura Atual (Leitura anterior)
		/*
		 * Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);
		 * 
		 * String leituraAnterior = null; Integer idMedicaoTipo = null;
		 * 
		 * MedicaoHistorico medicaoHistorico = null;
		 * 
		 * Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco,
		 * anoMesAnterior, imovel); // verifica se a leitura anterior é
		 * diferente de nula if (retorno[0] != null) { leituraAnterior =
		 * retorno[0].toString(); } // verifica se a leitura situação atual é
		 * diferente de // nula if (retorno[1] != null) { medicaoHistorico =
		 * (MedicaoHistorico) retorno[1]; } // verifica se o id da medição tipo
		 * é diferente de nula if (retorno[2] != null) { idMedicaoTipo =
		 * (Integer) retorno[2]; }
		 * 
		 * if (leituraAnterior != null) {
		 * arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, "" +
		 * leituraAnterior)); } else {
		 * arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, "")); }
		 */

		// 1.2.2.6 - Leitura Esperada
		// 1.2.2.7
		// 1.2.2.8
		/*
		 * Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovel,
		 * dadosHidrometro, leituraAnterior, medicaoHistorico, idMedicaoTipo,
		 * sistemaParametro, false, numeroDigitosHidrometro);
		 * 
		 * StringBuilder faixaInicialFinalString = (StringBuilder)
		 * faixaInicialFinal[0];
		 * 
		 * arquivoTxtLinha.append(faixaInicialFinalString);
		 */

		/*
		 * Colocado por Raphael Rossiter em 30/03/2007 (Analista: Rosana) Obter
		 * a leitura atual e a leitura esperada da mesma forma que é feito para
		 * o sistema legado.
		 * 
		 * 1.2.2.5 Leitura atual
		 * 
		 * 1.2.2.6 Leitura esperada
		 */
		Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);

		String leituraAnterior = null;
		Integer idMedicaoTipo = null;

		MedicaoHistorico medicaoHistorico = null;

		Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco,
				anoMesAnterior, imovel);

		// verifica se a leitura anterior é diferente de nula
		if (retorno[0] != null) {
			leituraAnterior = retorno[0].toString();
		}
		// verifica se a leitura situação atual é diferente de
		// nula
		if (retorno[1] != null) {
			medicaoHistorico = (MedicaoHistorico) retorno[1];
		}
		// verifica se o id da medição tipo é diferente de nula
		if (retorno[2] != null) {
			idMedicaoTipo = (Integer) retorno[2];
		}

		Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovel,
				dadosHidrometro, leituraAnterior, medicaoHistorico,
				idMedicaoTipo, sistemaParametro, false, numeroDigitosHidrometro);

		StringBuilder faixaInicialFinalString = (StringBuilder) faixaInicialFinal[0];

		arquivoTxtLinha.append(faixaInicialFinalString);

		Integer numeroConsumoFaturadoMes = null;

		try {

			// 1.2.2.9 - Consumo 04
			int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesCorrente, 4);

			numeroConsumoFaturadoMes = repositorioMicromedicao
					.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(
							imovel.getId(), anoMesSubtraido,
							LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if (numeroConsumoFaturadoMes != null) {
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, ""
						+ numeroConsumoFaturadoMes));
			} else {
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(
						"", 4));
			}

			// 1.2.2.10 - Consumo 05
			anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesCorrente, 5);
			numeroConsumoFaturadoMes = repositorioMicromedicao
					.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(
							imovel.getId(), anoMesSubtraido,
							LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if (numeroConsumoFaturadoMes != null) {
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, ""
						+ numeroConsumoFaturadoMes));
			} else {
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(
						"", 4));
			}

			// 1.2.2.11 - Consumo 06
			anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesCorrente, 6);
			numeroConsumoFaturadoMes = repositorioMicromedicao
					.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(
							imovel.getId(), anoMesSubtraido,
							LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if (numeroConsumoFaturadoMes != null) {
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, ""
						+ numeroConsumoFaturadoMes));
			} else {
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(
						"", 4));
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		// 1.2.2.12 - Consumo Médio
		Integer numeroConsumoMedio = null;
		try {
			numeroConsumoMedio = this.repositorioMicromedicao
					.pesquisarNumeroConsumoMedioImovel(imovel.getId(),
							anoMesCorrente, LigacaoTipo.LIGACAO_AGUA);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		if (numeroConsumoMedio != null) {
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(""
					+ numeroConsumoMedio, 4));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 4));
		}

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0003] Gerar Arquivo Entrada Sistema Legado
	 * 
	 * @author Rafael Francisco Pinto
	 * @date 09/02/2007
	 * 
	 * @param Imovel
	 * 
	 * @throws ErroRepositorioException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalSistemaLegado(
			Imovel imovel, int pagina, Integer anoMesCorrente,
			SistemaParametro sistemaParametro) throws ControladorException {

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.1 - Matricula do imovel Tam. 09
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(9,
				"" + imovel.getId()));

		// 1.2 - Cidade (codigo da localidade) Tam. 03
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ imovel.getLocalidade().getId()));

		// 1.3 - Setor (Setor Comercial) Tam. 03
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ imovel.getSetorComercial().getCodigo()));

		// 1.4 - Rota Tam. 02
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, ""
				+ imovel.getQuadra().getRota().getCodigo()));

		/*
		 * Colocado por Raphael Rossiter em 19/05/2007 (Analista: Eduardo
		 * Borges)
		 */
		// Sequencial da Rota Tam. 04
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4,
				"" + imovel.getNumeroSequencialRota()));

		// 1.5 - Página
		arquivoTxtLinha
				.append(Util.adicionarZerosEsquedaNumero(4, "" + pagina));

		// 1.6 - Inscrição do Imovel
		// 1.6.1 - Quadra
		// 1.6.2 - Lote
		// 1.6.3 - SubLote
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ imovel.getQuadra().getNumeroQuadra()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4,
				"" + imovel.getLote()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3,
				"" + imovel.getSubLote()));

		boolean ligacaoAgua = false;
		boolean ligacaoPoco = false;

		if (imovel.getLigacaoAgua() != null
				&& imovel.getLigacaoAgua().getId() != null
				&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
				&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()
						.getId() != null) {

			ligacaoAgua = true;
		}

		if (imovel.getHidrometroInstalacaoHistorico() != null
				&& imovel.getHidrometroInstalacaoHistorico().getId() != null) {

			ligacaoPoco = true;
		}

		// Dados do Hidrometro
		Short numeroDigitosHidrometro = null;
		StringBuilder dadosHidrometro = null;

		if (ligacaoAgua && ligacaoPoco) {

			Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

			dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
			numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

		} else {
			if (ligacaoAgua) {

				Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

				dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
				numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

			} else {

				if (ligacaoPoco) {

					Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

					dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
					numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

				} else {
					Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

					dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
					numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

				}
			}
		}

		Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);

		String leituraAnterior = null;
		Integer idMedicaoTipo = null;

		MedicaoHistorico medicaoHistorico = null;

		Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco,
				anoMesAnterior, imovel);

		// verifica se a leitura anterior é diferente de nula
		if (retorno[0] != null) {
			leituraAnterior = retorno[0].toString();
		}
		// verifica se a leitura situação atual é diferente de
		// nula
		if (retorno[1] != null) {
			medicaoHistorico = (MedicaoHistorico) retorno[1];
		}
		// verifica se o id da medição tipo é diferente de nula
		if (retorno[2] != null) {
			idMedicaoTipo = (Integer) retorno[2];
		}

		// 1.7 - Leitura Esperada Inicial e Esperada
		Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovel,
				dadosHidrometro, leituraAnterior, medicaoHistorico,
				idMedicaoTipo, sistemaParametro, false, numeroDigitosHidrometro);

		StringBuilder faixaInicialFinalString = (StringBuilder) faixaInicialFinal[0];

		arquivoTxtLinha.append(faixaInicialFinalString);

		// Numero do Hidrometro
		if (ligacaoPoco && !ligacaoAgua) {

			String numeroHidrometroFinal = imovel
					.getHidrometroInstalacaoHistorico().getHidrometro()
					.getNumero().trim();

			if (numeroHidrometroFinal.length() > 8) {

				numeroHidrometroFinal = numeroHidrometroFinal.substring(
						numeroHidrometroFinal.length() - 8,
						numeroHidrometroFinal.length());

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
						numeroHidrometroFinal));
			} else {

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
						numeroHidrometroFinal));
			}

		} else {

			String numeroHidrometroFinal = imovel.getLigacaoAgua()
					.getHidrometroInstalacaoHistorico().getHidrometro()
					.getNumero().trim();

			if (numeroHidrometroFinal.length() > 8) {

				numeroHidrometroFinal = numeroHidrometroFinal.substring(
						numeroHidrometroFinal.length() - 8,
						numeroHidrometroFinal.length());

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
						numeroHidrometroFinal));
			} else {

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
						numeroHidrometroFinal));
			}
		}

		// Tipo de Medição
		arquivoTxtLinha.append(idMedicaoTipo);

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT
	 * 
	 * Cria o objeto Imovel apartir da pesquisa
	 * 
	 * @param Object
	 *            [] arrayImoveis
	 * 
	 * @return Imovel
	 * 
	 * @author Rafael Francisco Pinto
	 * @date 19/01/2007
	 * 
	 * @throws ControladorException
	 */
	protected Imovel criarImovelApartirDadosPorLeituraConvencional(
			Object[] arrayImoveis) {

		// instancia um imóvel
		Imovel imovel = new Imovel();

		if (arrayImoveis[0] != null) {
			// seta o id no imovel
			imovel.setId((Integer) arrayImoveis[0]);
		}

		if (arrayImoveis[1] != null) {
			// instancia uma localidade para ser setado no imóvel
			Localidade localidade = new Localidade();
			localidade.setId((Integer) arrayImoveis[1]);
			localidade.setDescricao((String) arrayImoveis[30]);
			imovel.setLocalidade(localidade);
		}

		if (arrayImoveis[2] != null) {
			// instancia um setor comercial para ser setado no
			// imóvel
			SetorComercial setorComercial = new SetorComercial();
			setorComercial.setCodigo(Integer.parseInt(arrayImoveis[2]
					.toString()));
			imovel.setSetorComercial(setorComercial);
		}
		Quadra quadra = new Quadra();
		if (arrayImoveis[3] != null) {
			// instancia uma quadra para ser setado no imóvel

			Integer numeroQuadra = (Integer) arrayImoveis[3];
			quadra.setNumeroQuadra(numeroQuadra);
			imovel.setQuadra(quadra);
		}

		if (arrayImoveis[4] != null) {
			// seta o lote no imóvel
			imovel.setLote(Short.parseShort(arrayImoveis[4].toString()));
		}

		if (arrayImoveis[5] != null) {
			// seta o lote no imóvel
			imovel.setSubLote(Short.parseShort(arrayImoveis[5].toString()));
		}

		if (arrayImoveis[34] != null) {
			// seta numero sequencial rota
			imovel.setNumeroSequencialRota((Integer) arrayImoveis[34]);
		}

		if (arrayImoveis[6] != null) {
			// instancia uma imovel perfil para ser setado no
			// imóvel
			ImovelPerfil imovelPerfil = new ImovelPerfil();
			imovelPerfil.setId((Integer) arrayImoveis[6]);
			imovel.setImovelPerfil(imovelPerfil);
		}

		LigacaoAgua ligacaoAgua = new LigacaoAgua();
		if (arrayImoveis[7] != null) {
			// instancia uma ligação agua para ser setado no
			// imóvel

			ligacaoAgua.setId((Integer) arrayImoveis[7]);
			ligacaoAgua.setNumeroLacre((String) arrayImoveis[32]);
		}
		// instancia um hidrometro instalação historico para ser
		// colocado na ligacao agua
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoLigacaoAgua = new HidrometroInstalacaoHistorico();
		if (arrayImoveis[8] != null) {

			hidrometroInstalacaoHistoricoLigacaoAgua
					.setId((Integer) arrayImoveis[8]);
			MedicaoTipo medicaoTipo = new MedicaoTipo();
			medicaoTipo.setId((Integer) arrayImoveis[26]);
			hidrometroInstalacaoHistoricoLigacaoAgua
					.setMedicaoTipo(medicaoTipo);

			if (arrayImoveis[33] != null) {
				Hidrometro hidrometro = new Hidrometro();
				hidrometro.setNumero((String) arrayImoveis[33]);
				hidrometroInstalacaoHistoricoLigacaoAgua
						.setHidrometro(hidrometro);
			}

			ligacaoAgua
					.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoLigacaoAgua);

		}
		imovel.setLigacaoAgua(ligacaoAgua);

		// //instancia um hidrometro instalação historico para
		// ser colocado no imovel
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel = new HidrometroInstalacaoHistorico();
		if (arrayImoveis[9] != null) {

			hidrometroInstalacaoHistoricoImovel
					.setId((Integer) arrayImoveis[9]);

			MedicaoTipo medicaoTipo = new MedicaoTipo();
			medicaoTipo.setId((Integer) arrayImoveis[27]);

			hidrometroInstalacaoHistoricoImovel.setMedicaoTipo(medicaoTipo);

			if (arrayImoveis[36] != null) {
				Hidrometro hidrometro = new Hidrometro();
				hidrometro.setNumero((String) arrayImoveis[36]);
				hidrometroInstalacaoHistoricoImovel.setHidrometro(hidrometro);
			}

			imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoImovel);

		}
		// instancia a rota
		Rota rotaImovel = new Rota();

		if (arrayImoveis[10] != null) {
			// seta o id da rota
			rotaImovel.setId((Integer) arrayImoveis[10]);
		}

		if (arrayImoveis[11] != null) {
			// seta o indicador fiscalizador suprimido na rota
			rotaImovel.setIndicadorFiscalizarSuprimido(Short
					.parseShort(arrayImoveis[11].toString()));
		}

		if (arrayImoveis[12] != null) {
			// seta o indicador fiscalizador cortado na rota
			rotaImovel.setIndicadorFiscalizarCortado(Short
					.parseShort(arrayImoveis[12].toString()));
		}

		if (arrayImoveis[13] != null) {
			// seta o indicador gerar fiscalizacao na rota
			rotaImovel.setIndicadorGerarFiscalizacao(Short
					.parseShort(arrayImoveis[13].toString()));
		}

		if (arrayImoveis[14] != null) {
			// seta o indicador fgerar falsa faixa na rota
			rotaImovel.setIndicadorGerarFalsaFaixa(Short
					.parseShort(arrayImoveis[14].toString()));
		}

		if (arrayImoveis[15] != null) {
			// seta o percentual geracao fiscalizacao na rota
			rotaImovel
					.setPercentualGeracaoFiscalizacao((BigDecimal) (arrayImoveis[15]));
		}

		if (arrayImoveis[16] != null) {
			// seta o percentual geracao faixa falsa na rota
			rotaImovel
					.setPercentualGeracaoFaixaFalsa((BigDecimal) (arrayImoveis[16]));
		}

		if (arrayImoveis[35] != null) {
			// seta o codigo da rota
			rotaImovel.setCodigo((Short) (arrayImoveis[35]));
		}

		// instancia a empresa
		Empresa empresa = new Empresa();
		if (arrayImoveis[17] != null) {
			// seta o id na empresa
			empresa.setId((Integer) arrayImoveis[17]);
		}

		if (arrayImoveis[18] != null) {
			// seta a descrição abreviada na empresa
			empresa.setDescricaoAbreviada(arrayImoveis[18].toString());
		}

		if (arrayImoveis[19] != null) {
			// seta email da empresa
			empresa.setEmail(arrayImoveis[19].toString());
		}

		// seta a empresa na rota
		rotaImovel.setEmpresa(empresa);
		// instancia o faturamento
		FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
		if (arrayImoveis[20] != null) {
			// seta o id no faturamentGrupo
			faturamentoGrupo.setId((Integer) arrayImoveis[20]);

		}
		if (arrayImoveis[21] != null) {
			// seta o descrição no faturamentGrupo
			faturamentoGrupo.setDescricao((String) arrayImoveis[21]);
		}
		// seta o faturamento na rota
		rotaImovel.setFaturamentoGrupo(faturamentoGrupo);
		if (arrayImoveis[22] != null) {
			// instancia a ligação esgoto situação
			LeituraTipo leituraTipo = new LeituraTipo();
			// seta o id na ligação esgoto situação
			leituraTipo.setId((Integer) arrayImoveis[22]);
			// seta a ligação esgoto situação no imovel
			rotaImovel.setLeituraTipo(leituraTipo);
		}

		// seta a rota na quadra
		quadra.setRota(rotaImovel);
		// seta a quadra no imovel
		imovel.setQuadra(quadra);
		if (arrayImoveis[23] != null) {
			// instancia a ligação agua situação
			LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
			// seta o id na ligação agua situação
			ligacaoAguaSituacao.setId((Integer) arrayImoveis[23]);
			ligacaoAguaSituacao.setDescricao((String) arrayImoveis[31]);
			ligacaoAguaSituacao
					.setIndicadorFaturamentoSituacao((Short) arrayImoveis[37]);

			// seta a ligação agua situação no imovel
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		}
		if (arrayImoveis[24] != null) {
			// instancia a ligação esgoto situação
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
			// seta o id na ligação esgoto situação
			ligacaoEsgotoSituacao.setId((Integer) arrayImoveis[24]);
			ligacaoEsgotoSituacao
					.setIndicadorFaturamentoSituacao((Short) arrayImoveis[38]);
			// seta a ligação esgoto situação no imovel
			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
		}

		if (arrayImoveis[25] != null) {
			// instancia o faturamento situacao tipo
			FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
			// seta o id no faturamento situacao tipo
			faturamentoSituacaoTipo
					.setIndicadorParalisacaoLeitura((Short) arrayImoveis[25]);
			// seta a ligação esgoto situação no imovel
			imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
		}

		if (arrayImoveis[28] != null) {
			// instancia o gerencia regional
			GerenciaRegional gerenciaRegional = new GerenciaRegional();

			// seta o id no faturamento situacao tipo
			gerenciaRegional.setId((Integer) arrayImoveis[28]);
			gerenciaRegional.setNome((String) arrayImoveis[29]);

			// seta a ligação esgoto situação no imovel
			imovel.getLocalidade().setGerenciaRegional(gerenciaRegional);
		}

		return imovel;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT
	 * 
	 * Valida o imovel para geração do TXT
	 * 
	 * @param Imovel
	 * 
	 * @return true se eh valido,false se não for
	 * 
	 * @author Rafael Francisco Pinto
	 * @date 19/01/2007
	 * 
	 * @throws ControladorException
	 */
	protected boolean validarImovelGerarDadosLeituraConvencional(Imovel imovel,
			Integer anoMesMovimento) throws ControladorException {

		// variavel responsável para entrar em uma das 4 condicões abaixo
		boolean achouImovel = false;

		if (!achouImovel) {

			/*
			 * modificado por Flávio Leonardo a pedido de Rosana,Aryed e Eduardo
			 * é pra sair no rol todos os imoveis que tiverem hidrometro
			 * independente do indicador de situacao do faturamento
			 */

			// Verifica se a situação da ligação agua é diferente de nulo
			// Se for verifica se está ligado ou cortado
			/*
			 * Se for ligado ou cortado então Verifica se a ligação agua é
			 * diferente de nulo se for verifica se o id da ligação agua é igual
			 * ao id do imovel e se o id do histórico da instalação do
			 * hidrometro é diferente de null
			 */
			if (imovel.getLigacaoAgua() != null
					&& imovel.getLigacaoAgua().getId() != null
					&& (imovel.getLigacaoAgua().getId().equals(imovel.getId())
							&& imovel.getLigacaoAgua()
									.getHidrometroInstalacaoHistorico() != null && imovel
							.getLigacaoAgua()
							.getHidrometroInstalacaoHistorico().getId() != null)) {

				if (imovel.getFaturamentoSituacaoTipo() == null) {

					achouImovel = true;
				}

				/*
				 * e caso o imóvel esteja em situação especial de
				 * faturamento(FTST_ID diferente de nulo) o imóvel será
				 * selecionado quando a referida situação não indicar
				 * paralisação de leitura (ftst_icleituraparalisacao = 2 ou
				 * ftst_icvalidoagua = 2 da
				 * tabelafaturamento.fatur_situacao_tipo com FTST_ID = FTST_ID
				 * do imóvel)
				 */
				else if (imovel.getFaturamentoSituacaoTipo() != null
						&& imovel.getFaturamentoSituacaoTipo().getId() != null
						&& (imovel.getFaturamentoSituacaoTipo()
								.getIndicadorParalisacaoLeitura()
								.equals(ConstantesSistema.NAO) || imovel
								.getFaturamentoSituacaoTipo()
								.getIndicadorValidoAgua()
								.equals(ConstantesSistema.NAO))) {

					achouImovel = true;

					/*
					 * ou quando o ano/mês início da referida situação seja
					 * superior ao ano mês de movimento(FTSH_AMFATMSITINICIO da
					 * tabela faturamento.fatur_situacao_hist com imov_id =
					 * imov_id da tabela movimento_roteiro_empresa e
					 * ftsh_amfaturamentoretirada = nulo e FTST_ID = FTST_ID da
					 * tabela imovel MAIOR QUE O MREM_AMMOVIMENTO da tabela
					 * movimento roteiro_empresa
					 */
				} else if (imovel.getFaturamentoSituacaoTipo() != null
						&& imovel.getFaturamentoSituacaoTipo().getId() != null
						&& this.anoMesInicioSuperiorAnoMesMovimento(imovel
								.getId(), imovel.getFaturamentoSituacaoTipo()
								.getId(), anoMesMovimento)) {

					achouImovel = true;
				}
			}
		}

		if (!achouImovel) {

			/*
			 * Verifica se a situação da ligação esgoto é diferente de nulo Se
			 * for verifica se está ligado
			 */
			if (imovel.getLigacaoEsgotoSituacao() != null
					&& imovel.getLigacaoEsgotoSituacao()
							.getIndicadorFaturamentoSituacao() != null
					&& (imovel.getLigacaoEsgotoSituacao()
							.getIndicadorFaturamentoSituacao()
							.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO))) {

				/*
				 * Verifica se o id do hidrometro historico é diferente de nulo
				 * na tabela imovel
				 */
				if (imovel.getHidrometroInstalacaoHistorico() != null
						&& imovel.getHidrometroInstalacaoHistorico().getId() != null) {

					if (imovel.getFaturamentoSituacaoTipo() == null) {

						achouImovel = true;
					}

					/*
					 * e Caso o imóvel esteja em situação especial de
					 * faturamento(FTST_ID diferente de nulo) o imóvel será
					 * selecionado quando a referida situação não indicar
					 * paralisação de leitura ( ftst_icleituraparalisacao = 2 ou
					 * ftst_icvalidoesgoto = 2 da tabela
					 * faturamento.fatur_situacao_tipo com FTST_ID = FTST_ID do
					 * imóvel)
					 */
					else if (imovel.getFaturamentoSituacaoTipo() != null
							&& imovel.getFaturamentoSituacaoTipo().getId() != null
							&& (imovel.getFaturamentoSituacaoTipo()
									.getIndicadorParalisacaoLeitura()
									.equals(ConstantesSistema.NAO) || imovel
									.getFaturamentoSituacaoTipo()
									.getIndicadorValidoEsgoto()
									.equals(ConstantesSistema.NAO))) {

						achouImovel = true;

						/*
						 * ou quando o ano/mês início da referida situação seja
						 * superior ao ano mês de movimento(FTSH_AMFATMSITINICIO
						 * da tabela faturamento.fatur_situacao_hist com imov_id
						 * = imov_id da tabela movimento_roteiro_empresa e
						 * ftsh_amfaturamentoretirada = nulo e FTST_ID = FTST_ID
						 * da tabela imovel MAIOR QUE O MREM_AMMOVIMENTO da
						 * tabela movimento roteiro_empresa)
						 */
					} else if (imovel.getFaturamentoSituacaoTipo() != null
							&& imovel.getFaturamentoSituacaoTipo().getId() != null
							&& this.anoMesInicioSuperiorAnoMesMovimento(imovel
									.getId(), imovel
									.getFaturamentoSituacaoTipo().getId(),
									anoMesMovimento)) {

						achouImovel = true;
					}
				}
			}
		}

		if (!achouImovel) {

			/*
			 * Verifica se a situação da ligação agua é diferente de nulo Se for
			 * verifica se está suprimido
			 */
			if (imovel.getLigacaoAguaSituacao() != null
					&& imovel.getLigacaoAguaSituacao().getId() != null
					&& imovel.getLigacaoAguaSituacao().getId()
							.equals(LigacaoAguaSituacao.SUPRIMIDO)) {

				/*
				 * verifica se o indicador de fiscalização suprimido é diferente
				 * de nulo se for verifica se está ativo
				 */
				if (imovel.getQuadra().getRota()
						.getIndicadorFiscalizarSuprimido() != null
						&& imovel.getQuadra().getRota()
								.getIndicadorFiscalizarSuprimido().intValue() == Rota.INDICADOR_SUPRIMIDO_ATIVO) {

					achouImovel = true;
				}
			}
		}

		if (!achouImovel) {

			/*
			 * Verifica se a situação da ligação agua é diferente de nulo Se for
			 * verifica se está cortado
			 */
			if ((imovel.getLigacaoAguaSituacao() != null && imovel
					.getLigacaoAguaSituacao().getId() != null)
					&& (imovel.getLigacaoAguaSituacao().getId()
							.equals(LigacaoAguaSituacao.CORTADO))) {

				/*
				 * Se for cortado então verifica se a ligação agua é diferente
				 * de nulo se for verifica se o id da ligação agua é igual ao id
				 * do imovel e se o id do histórico da instalação do hidrometro
				 * é null
				 */
				if (imovel.getLigacaoAgua() != null
						&& imovel.getLigacaoAgua().getId() != null
						&& (imovel.getLigacaoAgua().getId()
								.equals(imovel.getId()) && (imovel
								.getLigacaoAgua()
								.getHidrometroInstalacaoHistorico() == null || imovel
								.getLigacaoAgua()
								.getHidrometroInstalacaoHistorico().getId() == null))) {

					/*
					 * verifica se o indicador de fiscalização cortado é
					 * diferente de nulo se for verifica se está ativo
					 */
					if (imovel.getQuadra().getRota()
							.getIndicadorFiscalizarCortado() != null
							&& imovel.getQuadra().getRota()
									.getIndicadorFiscalizarCortado().intValue() == Rota.INDICADOR_CORTADO_ATIVO) {

						achouImovel = true;
					}
				}
			}
		}

		return achouImovel;
	}

	/**
	 * 
	 * Método que retorna o consumo de ligacao da agua ou esgoto (tipo passado)
	 * de um imovel em um determinado anoMes do faturamento. Método utilizado
	 * pra saber a ligacao de
	 * 
	 * 2.2.2.2 e 2.2.3.2 do [UC0103] Efetuar Rateio de Consumo
	 * 
	 * @author Sávio Luiz
	 * @date 07/04/2006
	 * 
	 * @param idImovel
	 * @param anoMes
	 * @param idLigacaoTipo
	 *            podendo ser agua ou esgoto
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterConsumoAnteriorAnormalidadeDoImovel(Integer idImovel,
			Integer anoMes, Integer idLigacaoTipo) throws ControladorException {

		Object[] parmsConsumoHistorico = null;

		try {

			parmsConsumoHistorico = repositorioMicromedicao
					.obterConsumoAnteriorAnormalidadeDoImovel(idImovel, anoMes,
							idLigacaoTipo);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return parmsConsumoHistorico;
	}

	/*
	 * Utilizado pelo caso de uso Substituir COnsumos anteriores
	 */
	public void atualizarConsumosMedio(Integer idImovel,
			Integer anoMesConsumoHistorico, int consumoMedioHidrometroAgua,
			int consumoMedioHidrometroEsgoto) {
		try {

			repositorioMicromedicao.atualizarConsumosMedio(idImovel,
					anoMesConsumoHistorico, consumoMedioHidrometroAgua,
					consumoMedioHidrometroEsgoto);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Pesquisa todas as rotas do sistema. Metódo usado no [UC0302] Gerar Débito
	 * a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 20/03/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarListaRotasCarregadas()
			throws ControladorException {

		Collection retorno = null;

		try {

			retorno = repositorioMicromedicao.pesquisarListaRotasCarregadas();

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC0105] Obter Consumo Mínimo da Ligação por Subcategoria
	 * 
	 * @author Raphael Rossiter
	 * @date 11/04/2007
	 * 
	 * @return imovel, colecaoSubcategoria
	 * @throws ControladorException
	 */
	/*
	 * public int obterConsumoMinimoLigacaoPorSubcategoria(Imovel imovel,
	 * Collection colecaoSubcategoria) throws ControladorException {
	 * 
	 * int consumoMinimoLigacao = 0;
	 * 
	 * Collection colecaoDataVigencia = null; Integer consumoMinimo = null;
	 * 
	 * // Obtém o id do consumo tarifa vigência da maior data de vigência da //
	 * tarifa do imóvel try { colecaoDataVigencia = repositorioMicromedicao
	 * .pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(), imovel); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * new ControladorException("erro.sistema", ex); }
	 * 
	 * // Obtém o id do array e atribui na variável Object[]
	 * consumoTarifaVigenciaIdArray = (Object[]) Util
	 * .retonarObjetoDeColecaoArray(colecaoDataVigencia); Integer
	 * consumoTarifaVigenciaId = null;
	 * 
	 * if (consumoTarifaVigenciaIdArray == null) { throw new
	 * ControladorException( "erro.nao_cadastrada_consumo_tarifa_vigencia",
	 * null, String .valueOf(imovel.getId())); }
	 * 
	 * if (consumoTarifaVigenciaIdArray[0] != null) { consumoTarifaVigenciaId =
	 * (Integer) consumoTarifaVigenciaIdArray[0]; }
	 * 
	 * // Cria o objeto consumo tarifa vigência e seta o id
	 * ConsumoTarifaVigencia consumoTarifaVigencia = new
	 * ConsumoTarifaVigencia();
	 * consumoTarifaVigencia.setId(consumoTarifaVigenciaId);
	 * 
	 * // Obter Quantidade de Economias por Subcategoria if (colecaoSubcategoria
	 * == null) { colecaoSubcategoria = getControladorImovel()
	 * .obterQuantidadeEconomiasSubCategoria(imovel.getId()); }
	 * 
	 * Iterator colecaoSubcategoriaIterator = colecaoSubcategoria.iterator();
	 * 
	 * while (colecaoSubcategoriaIterator.hasNext()) {
	 * 
	 * Subcategoria subcategoria = (Subcategoria) colecaoSubcategoriaIterator
	 * .next();
	 * 
	 * try { // Obtém o consumo mínimo da tarifa da categoria do imóvel Object
	 * consumoMinimoObjeto = repositorioMicromedicao
	 * .pesquisarConsumoMinimoTarifaSubcategoriaVigencia( subcategoria,
	 * consumoTarifaVigencia); consumoMinimo = (Integer) consumoMinimoObjeto; }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * new ControladorException("erro.sistema", ex); }
	 * 
	 * /* Caso não exista tarifa cadastrada para a subcategoria em questao,
	 * utilizar a tarifa da categoria
	 */
	/*
	 * if (consumoMinimo == null) {
	 * 
	 * Categoria categoria = subcategoria.getCategoria();
	 * categoria.setQuantidadeEconomiasCategoria(subcategoria
	 * .getQuantidadeEconomias());
	 * 
	 * Collection colecaoCategoria = new ArrayList();
	 * colecaoCategoria.add(categoria);
	 * 
	 * consumoMinimo = this.obterConsumoMinimoLigacao(imovel, colecaoCategoria);
	 * 
	 * /* throw new ControladorException(
	 * "erro.nao_cadastrada_consumo_tarifa_categoria", null,
	 * subcategoria.getDescricao());
	 */

	/*
	 * }
	 * 
	 * // Multiplica a quantidade de economias da categoria pelo consumo //
	 * mínimo e acumula consumoMinimoLigacao = consumoMinimoLigacao +
	 * (subcategoria.getQuantidadeEconomias().intValue() * consumoMinimo
	 * .intValue());
	 * 
	 * }
	 * 
	 * // Retorna o consumo mínimo da ligação return consumoMinimoLigacao;
	 * 
	 * }
	 */

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades
	 * 
	 * [SB0001] - Gerar Relatório Resumo das Leituras e Anormalidades
	 * 
	 * Pesquisa as Anormalidades de Leitura e suas quantidades
	 * 
	 * @author Rafael Corrêa
	 * @date 13/04/2007
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarAnormalidadesRelatorioComparativoLeiturasEAnormalidades(
			Integer idGrupoFaturamento, Integer idEmpresa, Integer anoMes,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorInicial, Integer idSetorFinal, Integer idGerencia,
			Integer idUnidadeNegocio, Integer idLeiturista,
			Integer idRotaInicial, Integer idRotaFinal, Integer idPerfilImovel,
			Integer numOcorrenciasConsecutivas,
			Collection colecaoAnormalidadesLeituras)
			throws ControladorException {

		Collection retorno = new ArrayList();

		try {
			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			Collection colecaoObjetos = repositorioMicromedicao
					.pesquisarAnormalidadesRelatorioComparativoLeiturasEAnormalidades(
							idGrupoFaturamento, idEmpresa, anoMes,
							idLocalidadeInicial, idLocalidadeFinal,
							idSetorInicial, idSetorFinal, idGerencia,
							idUnidadeNegocio, idLeiturista, idRotaInicial,
							idRotaFinal, idPerfilImovel,
							numOcorrenciasConsecutivas,
							colecaoAnormalidadesLeituras, sistemaParametro);

			if (!colecaoObjetos.isEmpty()) {

				Iterator iterator = colecaoObjetos.iterator();
				while (iterator.hasNext()) {
					Object[] objeto = (Object[]) iterator.next();

					AnormalidadeLeituraHelper anormalidadeLeituraHelper = new AnormalidadeLeituraHelper();

					// id
					if (objeto[0] != null) {
						anormalidadeLeituraHelper
								.setIdAnormalidadeLeitura((Integer) objeto[0]);
					}

					// descricao
					if (objeto[1] != null) {
						anormalidadeLeituraHelper
								.setDescricaoAnormalidadeLeitura((String) objeto[1]);
					}

					// qtd
					if (objeto[2] != null) {
						anormalidadeLeituraHelper
								.setQuantidade((Integer) objeto[2]);
					}

					if (idEmpresa != null) {
						// Id da Empresa
						if (objeto[3] != null) {
							anormalidadeLeituraHelper
									.setIdEmpresa((Integer) objeto[3]);
						}

						// Descrição da Empresa
						if (objeto[4] != null) {
							anormalidadeLeituraHelper
									.setNomeEmpresa((String) objeto[4]);
						}
					}
					if (idGrupoFaturamento != null) {
						if (idEmpresa != null) {
							// Id do Grupo de Faturamento
							if (objeto[5] != null) {
								anormalidadeLeituraHelper
										.setIdGrupoFaturamento((Integer) objeto[5]);
							}
						} else {
							// Id do Grupo de Faturamento
							if (objeto[3] != null) {
								anormalidadeLeituraHelper
										.setIdGrupoFaturamento((Integer) objeto[3]);
							}
						}
					}
					retorno.add(anormalidadeLeituraHelper);
				}
			}

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades
	 * 
	 * [SB0001] - Gerar Relatório Resumo das Leituras e Anormalidades
	 * 
	 * Pesquisa os dados do relatório do comparativo de leituras e anormalidades
	 * 
	 * @author Rafael Corrêa - Hugo Leonardo - Rodrigo Cabral - Magno Gouveia
	 * @date 13/04/2007 - 18/03/2010 - 19/08/2010 - 21/06/2011
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarDadosRelatorioComparativoLeiturasEAnormalidades(
			Integer idGrupoFaturamento, Integer idEmpresa, Integer anoMes,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorInicial, Integer idSetorFinal, Integer idGerencia,
			Integer idUnidadeNegocio, Integer idLeiturista,
			Integer idRotaInicial, Integer idRotaFinal, Integer idPerfilImovel,
			Integer numOcorrenciasConsecutivas,
			Collection colecaoAnormalidadesLeituras)
			throws ControladorException {

		Collection retorno = new ArrayList();

		try {
			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			Collection colecaoObjetos = repositorioMicromedicao
					.pesquisarDadosRelatorioComparativoLeiturasEAnormalidades(
							idGrupoFaturamento, idEmpresa, anoMes,
							idLocalidadeInicial, idLocalidadeFinal,
							idSetorInicial, idSetorFinal, idGerencia,
							idUnidadeNegocio, idLeiturista, idRotaInicial,
							idRotaFinal, idPerfilImovel,
							numOcorrenciasConsecutivas,
							colecaoAnormalidadesLeituras, sistemaParametro);
			if (!colecaoObjetos.isEmpty()) {

				Iterator iterator = colecaoObjetos.iterator();
				while (iterator.hasNext()) {
					Object[] objeto = (Object[]) iterator.next();

					ComparativoLeiturasEAnormalidadesRelatorioHelper comparativoLeiturasEAnormalidadesRelatorioHelper = new ComparativoLeiturasEAnormalidadesRelatorioHelper();

					// id localidade
					if (objeto[0] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setIdLocalidade((Integer) objeto[0]);
					}

					// id setor comercial
					if (objeto[1] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setIdSetorComercial((Integer) objeto[1]);
					}

					// código setor comercial
					if (objeto[2] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setCodigoSetorComercial((Integer) objeto[2]);
					}

					// registros c/ leitura
					if (objeto[3] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setRegistrosComLeitura((Integer) objeto[3]);
					}

					// registros c/ anormalidade
					if (objeto[4] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setRegistrosComAnormalidade((Integer) objeto[4]);
					}

					// registros c/ leitura e anormalidade
					if (objeto[5] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setRegistrosComLeituraEAnormalidade((Integer) objeto[5]);
					}

					// registros recebidos
					if (objeto[6] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setRegistrosRecebidos((Integer) objeto[6]);
					}

					// registros Enviados
					if (objeto[7] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setRegistrosEnviados((Integer) objeto[7]);
					}

					// Codigo da Rota
					if (objeto[8] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setCodigoRota((Short) objeto[8]);
					}

					// Registros Recebidos Convencional
					if (objeto[9] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setRegistrosRecebidosConvencional((Integer) objeto[9]);
					}

					// Registros Recebidos Simultaneo
					if (objeto[10] != null) {
						comparativoLeiturasEAnormalidadesRelatorioHelper
								.setRegistrosRecebidosSimultaneo((Integer) objeto[10]);
					}

					retorno.add(comparativoLeiturasEAnormalidadesRelatorioHelper);
				}
			}

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [UC0613] - Registrar Leituras e Anormalidades
	 * 
	 * Pesquisa os imóveis com faixa falsa
	 * 
	 * @author Rafael Corrêa
	 * @date 18/06/2007
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarImovelFaixaFalsa(Integer anoMesReferencia)
			throws ControladorException {

		Collection retorno = new ArrayList();

		try {
			Collection colecaoDados = repositorioMicromedicao
					.pesquisarImovelFaixaFalsa(anoMesReferencia);

			if (!colecaoDados.isEmpty()) {

				Iterator colecaoDadosIterator = colecaoDados.iterator();
				while (colecaoDadosIterator.hasNext()) {
					Object[] dados = (Object[]) colecaoDadosIterator.next();

					FaixasFalsasLeituraRelatorioHelper faixasFalsasLeituraRelatorioHelper = new FaixasFalsasLeituraRelatorioHelper();

					// Id Grupo de Faturamento
					if (dados[0] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setIdGrupoFaturamento((Integer) dados[0]);
					}

					// Descrição Grupo de Faturamento
					if (dados[1] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setDescricaoGrupoFaturamento((String) dados[1]);
					}

					// Id da Empresa
					if (dados[2] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setIdEmpresa((Integer) dados[2]);
					}

					// Nome da Empresa
					if (dados[3] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setNomeEmpresa((String) dados[3]);
					}

					// Id da Localidade
					if (dados[4] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setIdLocalidade((Integer) dados[4]);
					}

					// Nome da Localidade
					if (dados[5] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setNomeLocalidade((String) dados[5]);
					}

					// Id do Setor Comercial
					if (dados[6] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setIdSetorComercial((Integer) dados[6]);
					}

					// Código do Setor Comercial
					if (dados[7] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setCodigoSetorComercial((Integer) dados[7]);
					}

					// Nome do Setor Comercial
					if (dados[8] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setNomeSetorComercial((String) dados[8]);
					}

					// Faixa Falsa Inferior
					if (dados[9] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setFaixaFalsaInferior((Integer) dados[9]);
					}

					// Leitura Atual
					if (dados[10] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setLeituraAtual((Integer) dados[10]);
					}

					// Faixa Falsa Superior
					if (dados[11] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setFaixaFalsaSuperior((Integer) dados[11]);
					}

					// Número da Quadra
					if (dados[12] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setNumeroQuadra((Integer) dados[12]);
					}

					// Lote
					if (dados[13] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setLote((Short) dados[13]);
					}

					// Sublote
					if (dados[14] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setSublote((Short) dados[14]);
					}

					// Id do Imóvel
					if (dados[15] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setIdImovel((Integer) dados[15]);
					}

					// Id do Leiturista
					if (dados[16] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setIdLeiturista((Integer) dados[16]);
					}

					// Faixa Correta Inferior
					if (dados[17] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setFaixaCorretaInferior((Integer) dados[17]);
					}

					// Faixa Correta Superior
					if (dados[18] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setFaixaCorretaSuperior((Integer) dados[18]);
					}

					// Data da Leitura
					if (dados[19] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setDataLeitura((Date) dados[19]);
					}

					// Descrição da Anormalidade de Leitura
					if (dados[20] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setDescricaoLeituraAnormalidade((String) dados[20]);
					} else {
						faixasFalsasLeituraRelatorioHelper
								.setDescricaoLeituraAnormalidade("");
					}

					// Descrição da Situação da Leitura
					if (dados[21] != null) {
						faixasFalsasLeituraRelatorioHelper
								.setDescricaoSituacaoLeitura((String) dados[21]);
					} else {
						faixasFalsasLeituraRelatorioHelper
								.setDescricaoSituacaoLeitura("");
					}

					retorno.add(faixasFalsasLeituraRelatorioHelper);
				}
			}

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [UC0613] - Registrar Leituras e Anormalidades
	 * 
	 * Retorna a quantidade de imóveis com faixa falsa
	 * 
	 * @author Rafael Corrêa
	 * @date 18/06/2007
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Integer pesquisarImovelFaixaFalsaCount(Integer anoMesReferencia)
			throws ControladorException {

		try {
			return repositorioMicromedicao
					.pesquisarImovelFaixaFalsaCount(anoMesReferencia);
		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0100] Informar Leitura de Fiscalização
	 * 
	 * 
	 * @author Rômulo Aurélio
	 * @date 19/05/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */

	public void informarLeituraFiscalizacao(Usuario usuarioLogado,
			LeituraFiscalizacao leituraFiscalizacao)
			throws ControladorException {

		/**
		 * Registrar Transacao
		 */

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		/*
		 * RegistradorOperacao registradorOperacao = new RegistradorOperacao(
		 * Operacao.OPERACAO_LEITURA_FISCALIZACAO_INFORMAR, new
		 * UsuarioAcaoUsuarioHelper(usuarioLogado,
		 * UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		 * 
		 * Operacao operacao = new Operacao();
		 * operacao.setId(Operacao.OPERACAO_LEITURA_FISCALIZACAO_INFORMAR);
		 * 
		 * OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		 * operacaoEfetuada.setOperacao(operacao);
		 * 
		 * leituraFiscalizacao.setOperacaoEfetuada(operacaoEfetuada);
		 * leituraFiscalizacao.adicionarUsuario(usuarioLogado,
		 * UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		 * registradorOperacao.registrarOperacao(leituraFiscalizacao);
		 */
		// ------------ REGISTRAR TRANSAÇÃO ----------------
		leituraFiscalizacao.setUltimaAlteracao(new Date());

		FiltroLeituraFiscalizacao filtroLeituraFiscalizacao = new FiltroLeituraFiscalizacao();

		filtroLeituraFiscalizacao.adicionarParametro(new ParametroSimples(
				FiltroLeituraFiscalizacao.ID, leituraFiscalizacao
						.getMedicaoHistorico().getId()));

		Collection colecaoLeituraFiscalizacaoBase = getControladorUtil()
				.pesquisar(filtroLeituraFiscalizacao,
						LeituraFiscalizacao.class.getName());

		if (colecaoLeituraFiscalizacaoBase != null
				&& !colecaoLeituraFiscalizacaoBase.isEmpty()) {

			LeituraFiscalizacao leituraFiscalizacaoBase = (LeituraFiscalizacao) colecaoLeituraFiscalizacaoBase

			.iterator().next();

			if (leituraFiscalizacaoBase.getUltimaAlteracao() != null
					&& leituraFiscalizacao.getUltimaAlteracao() != null
					&& leituraFiscalizacaoBase.getUltimaAlteracao().after(
							leituraFiscalizacao.getUltimaAlteracao())) {
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

			// leituraFiscalizacao.setId(leituraFiscalizacaoBase.getId());

			getControladorUtil().atualizar(leituraFiscalizacao);

		} else {

			getControladorUtil().inserir(leituraFiscalizacao);

		}

	}

	/**
	 * Permite inserir uma Anormalidade de Leitura
	 * 
	 * [UC0217] Inserir Anormalidade Leitura
	 * 
	 * @author Thiago Tenório
	 * @date 30/03/2006
	 * 
	 */
	public Integer inserirAnormalidadeLeitura(
			LeituraAnormalidade leituraAnormalidade, Usuario usuarioLogado)
			throws ControladorException {

		// FiltroLeituraAnormalidade filtroLeituraAnormalidade = new
		// FiltroLeituraAnormalidade();

		/*
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.DESCRICAO, leituraAnormalidade
		 * .getDescricao()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.DESCRICAO_ABREVIADA,
		 * leituraAnormalidade.getDescricaoAbreviada()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_RELATIVO_HIDROMETRO,
		 * leituraAnormalidade.getIndicadorRelativoHidrometro()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_IMOVEL_SEM_HIDROMETRO,
		 * leituraAnormalidade.getIndicadorImovelSemHidrometro()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_USO_SISTEMA,
		 * leituraAnormalidade.getIndicadorSistema()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_EMISSAO_ORDEM_SERVICO,
		 * leituraAnormalidade.getIndicadorEmissaoOrdemServico()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_TIPO_SERVICO, leituraAnormalidade
		 * .getServicoTipo()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_CONSUMO_A_COBRAR_SEM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_CONSUMO_A_COBRAR_COM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_LEITURA_A_FATURAR_SEM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_LEITURA_A_FATURAR_COM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeLeituraComleitura()));
		 */
		// Collection colecaoAnormalidadeLeitura =
		// getControladorUtil().pesquisar(
		// filtroLeituraAnormalidade, LeituraAnormalidade.class.getName());
		// if (colecaoAnormalidadeLeitura != null
		// && !colecaoAnormalidadeLeitura.isEmpty()) {
		// throw new ControladorException(
		// "atencao.endereco_localidade_nao_informado");
		// }
		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ANORMALIDADE_LEITURA_INSERIR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ANORMALIDADE_LEITURA_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		leituraAnormalidade.setOperacaoEfetuada(operacaoEfetuada);
		leituraAnormalidade.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(leituraAnormalidade);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Integer id = (Integer) getControladorUtil()
				.inserir(leituraAnormalidade);

		return id;

	}

	/**
	 * [UC0298] Manter Tipo de Retorno da OS_Referida [] Atualizar Tipo de
	 * Retorno da OS_Referida Metodo que atualiza a Situação Usuario
	 * 
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * 
	 * @param Tipo
	 *            de Retorno da OS_Referida Usuário
	 * @throws ControladorException
	 */

	public void atualizarAnormalidadeLeitura(
			LeituraAnormalidade leituraAnormalidade)
			throws ControladorException {

		// Verifica se todos os campos obrigatorios foram preenchidos

		if ((leituraAnormalidade.getDescricao() == null || leituraAnormalidade
				.getDescricao().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leituraAnormalidade.getDescricaoAbreviada() == null || leituraAnormalidade
						.getDescricaoAbreviada().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leituraAnormalidade.getIndicadorRelativoHidrometro() == 0)
				&& (leituraAnormalidade.getIndicadorImovelSemHidrometro() == null || leituraAnormalidade
						.getIndicadorImovelSemHidrometro().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leituraAnormalidade.getIndicadorSistema() == null || leituraAnormalidade
						.getIndicadorSistema().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leituraAnormalidade.getIndicadorEmissaoOrdemServico() == 0)
				&& (leituraAnormalidade
						.getLeituraAnormalidadeConsumoSemleitura() == null || leituraAnormalidade
						.getLeituraAnormalidadeConsumoSemleitura().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leituraAnormalidade
						.getLeituraAnormalidadeConsumoComleitura() == null || leituraAnormalidade
						.getLeituraAnormalidadeConsumoComleitura().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leituraAnormalidade
						.getLeituraAnormalidadeLeituraSemleitura() == null || leituraAnormalidade
						.getLeituraAnormalidadeLeituraSemleitura().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))

				&& (leituraAnormalidade
						.getLeituraAnormalidadeLeituraComleitura() == null || leituraAnormalidade
						.getLeituraAnormalidadeLeituraComleitura().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Descrição foi preenchido

		if (leituraAnormalidade.getDescricao() == null
				|| leituraAnormalidade.getDescricao().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Descrição");
		}

		// Verifica se o campo Descrição foi preenchido

		if (leituraAnormalidade.getDescricaoAbreviada() == null
				|| leituraAnormalidade.getDescricaoAbreviada().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Abreviatura");
		}

		// Verifica se o campo Descrição foi preenchido

		if (leituraAnormalidade.getIndicadorRelativoHidrometro() == 0
				|| leituraAnormalidade.getDescricaoAbreviada().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Anormalidade Relativa a Hidrômetro");
		}

		// Verifica se o campo Referência do Tipo de Serviço foi preenchido
		if (leituraAnormalidade.getIndicadorImovelSemHidrometro() == null
				|| leituraAnormalidade.getIndicadorImovelSemHidrometro()
						.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Anormalidade Aceita para Ligação sem Hidrômetro");
		}

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if (leituraAnormalidade.getIndicadorSistema() == null
				|| leituraAnormalidade.getIndicadorSistema().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Anormalidade de Uso Restrito do Sistema");
		}

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if (leituraAnormalidade.getIndicadorPerdaTarifaSocial() == null
				|| leituraAnormalidade.getIndicadorPerdaTarifaSocial().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Anormalidade Acarreta Perda Tarifa Socia");
		}

		// // Verifica se o campo Indicador de Troca de Serviço foi preenchido
		//
		// if (leituraAnormalidade.getIndicadorEmissaoOrdemServico() == 0
		// leituraAnormalidade.getIndicadorEmissaoOrdemServico() {
		// throw new ControladorException("atencao.Informe_entidade", null,
		// " Anormalidade Acarreta Perda Tarifa Socia");
		// }

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if (leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura() == null
				|| leituraAnormalidade
						.getLeituraAnormalidadeConsumoSemleitura().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Consumo a Ser Cobrado (anormalidade informada e leitura não informada)");
		}

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if (leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura() == null
				|| leituraAnormalidade
						.getLeituraAnormalidadeConsumoComleitura().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Consumo a Ser Cobrado (anormalidade informada e leitura informada)");
		}

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if (leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura() == null
				|| leituraAnormalidade
						.getLeituraAnormalidadeLeituraSemleitura().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Leitura para faturamento (anormalidade informada e leitura não informada)");
		}

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if (leituraAnormalidade.getLeituraAnormalidadeLeituraComleitura() == null
				|| leituraAnormalidade
						.getLeituraAnormalidadeLeituraSemleitura().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Leitura para faturamento (anormalidade informada e leitura não informada)");
		}

		// Verifica se o campo Código da Situação foi preenchido

		// if (osReferidaRetornoTipo.getSituacaoOsReferencia() == null
		// || osReferidaRetornoTipo.getSituacaoOsReferencia().equals(
		// "" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
		// throw new ControladorException("atencao.Informe_entidade", null,
		// " Código da Situação");
		// }

		// [FS0003] - Atualização realizada por outro usuário
		FiltroLeituraAnormalidade filtroLeituraAnormalidade = new FiltroLeituraAnormalidade();
		filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
				FiltroLeituraAnormalidade.ID, leituraAnormalidade.getId()));

		LeituraAnormalidade leituraBase = null;

		try {
			leituraBase = (LeituraAnormalidade) ((List) (repositorioUtil
					.pesquisar(filtroLeituraAnormalidade,
							LeituraAnormalidade.class.getName()))).get(0);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		// Verificar se o hidrometro já foi atualizado por outro usuário
		// durante
		// esta atualização
		if (leituraBase.getUltimaAlteracao().after(
				leituraAnormalidade.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		leituraAnormalidade.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(leituraAnormalidade);

	}

	// valida anoMes para caso de uso anlise excecoes leituras
	public boolean validaDataFaturamentoIncompativel(String anoMesReferencia,
			String anoMesAtual) {
		boolean retorno = true;

		String anoMesReferenciaMaisUmMes = ""
				+ Util.somarData(new Integer(anoMesReferencia));

		if (!((Util.compararAnoMesReferencia(new Integer(anoMesReferencia),
				new Integer(anoMesAtual), "=")) || (Util
				.compararAnoMesReferencia(
						new Integer(anoMesReferenciaMaisUmMes), new Integer(
								anoMesAtual), "=")))) {
			retorno = false;
		}

		return retorno;
	}

	// valida anoMes para caso de uso anlise excecoes leituras
	public boolean validaDataFaturamentoIncompativelInferior(
			String anoMesReferencia, String anoMesAnterior) {
		boolean retorno = true;

		String anoMesReferenciaMenosUmMes = ""
				+ Util.subtrairMesDoAnoMes(new Integer(anoMesReferencia), 1);

		// Comparando a data anterior faturada no form com o ano
		// mês
		// referência e com o ano mês anterior
		if (!((Util.compararAnoMesReferencia(new Integer(anoMesReferencia),
				new Integer(anoMesAnterior), "=")) || (Util
				.compararAnoMesReferencia(new Integer(
						anoMesReferenciaMenosUmMes),
						new Integer(anoMesAnterior), "=")))) {

			retorno = false;
		}

		return retorno;
	}

	/**
	 * relatório de regitro atendimento
	 * 
	 * @author Vivianne Sousa
	 * @date 07/06/2007
	 * 
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public AnaliseConsumoRelatorioOSHelper obterDadosAnaliseConsumo(
			Integer idImovel) throws ControladorException {

		AnaliseConsumoRelatorioOSHelper analiseConsumoRelatorioOSHelper = new AnaliseConsumoRelatorioOSHelper();
		Integer anoMes = null;
		try {
			anoMes = repositorioMicromedicao
					.obterMaxAMFaturamentoConsumoHistoricoDoImovel(idImovel);
		} catch (ErroRepositorioException e1) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e1);
		}

		if (anoMes != null) {

			for (int qtdMeses = 0; qtdMeses <= 5; qtdMeses++) {

				int anoMesSubtraido = Util
						.subtrairMesDoAnoMes(anoMes, qtdMeses);
				Object[] dadosConsumoHistoricoDoImovel = null;
				Object[] dadosMedicaoHistoricoDoImovel = null;

				try {
					dadosConsumoHistoricoDoImovel = repositorioMicromedicao
							.obterDadosConsumoHistoricoDoImovel(idImovel,
									anoMesSubtraido);
				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				try {
					dadosMedicaoHistoricoDoImovel = repositorioMicromedicao
							.obterDadosMedicaoHistoricoDoImovel(idImovel,
									anoMesSubtraido);
				} catch (ErroRepositorioException e2) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e2);
				}

				switch (qtdMeses) {

				case 0:
					analiseConsumoRelatorioOSHelper
							.setAnoMesHistoricoConsumo1(Util
									.formatarAnoMesParaMesAno(anoMesSubtraido));
					if (dadosConsumoHistoricoDoImovel != null) {
						if (dadosConsumoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setConsumoFaturado1(""
											+ (Integer) dadosConsumoHistoricoDoImovel[0]);
						}
						if (dadosConsumoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeConsumo1((String) dadosConsumoHistoricoDoImovel[1]);
						}
					}
					if (dadosMedicaoHistoricoDoImovel != null) {
						if (dadosMedicaoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setDtLeituraAtualInformada1(Util
											.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
						}
						if (dadosMedicaoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setLeituraAtualInformada1(""
											+ (Integer) dadosMedicaoHistoricoDoImovel[1]);
						}
						if (dadosMedicaoHistoricoDoImovel[2] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeLeitura1((String) dadosMedicaoHistoricoDoImovel[2]);
						}
					}
					break;

				case 1:
					analiseConsumoRelatorioOSHelper
							.setAnoMesHistoricoConsumo2(Util
									.formatarAnoMesParaMesAno(anoMesSubtraido));
					if (dadosConsumoHistoricoDoImovel != null) {
						if (dadosConsumoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setConsumoFaturado2(""
											+ (Integer) dadosConsumoHistoricoDoImovel[0]);
						}
						if (dadosConsumoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeConsumo2((String) dadosConsumoHistoricoDoImovel[1]);
						}
					}
					if (dadosMedicaoHistoricoDoImovel != null) {
						if (dadosMedicaoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setDtLeituraAtualInformada2(Util
											.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
						}
						if (dadosMedicaoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setLeituraAtualInformada2(""
											+ (Integer) dadosMedicaoHistoricoDoImovel[1]);
						}
						if (dadosMedicaoHistoricoDoImovel[2] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeLeitura2((String) dadosMedicaoHistoricoDoImovel[2]);
						}
					}
					break;

				case 2:
					analiseConsumoRelatorioOSHelper
							.setAnoMesHistoricoConsumo3(Util
									.formatarAnoMesParaMesAno(anoMesSubtraido));
					if (dadosConsumoHistoricoDoImovel != null) {
						if (dadosConsumoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setConsumoFaturado3(""
											+ (Integer) dadosConsumoHistoricoDoImovel[0]);
						}
						if (dadosConsumoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeConsumo3((String) dadosConsumoHistoricoDoImovel[1]);
						}
					}
					if (dadosMedicaoHistoricoDoImovel != null) {
						if (dadosMedicaoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setDtLeituraAtualInformada3(Util
											.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
						}
						if (dadosMedicaoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setLeituraAtualInformada3(""
											+ (Integer) dadosMedicaoHistoricoDoImovel[1]);
						}
						if (dadosMedicaoHistoricoDoImovel[2] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeLeitura3((String) dadosMedicaoHistoricoDoImovel[2]);
						}
					}
					break;

				case 3:
					analiseConsumoRelatorioOSHelper
							.setAnoMesHistoricoConsumo4(Util
									.formatarAnoMesParaMesAno(anoMesSubtraido));
					if (dadosConsumoHistoricoDoImovel != null) {
						if (dadosConsumoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setConsumoFaturado4(""
											+ (Integer) dadosConsumoHistoricoDoImovel[0]);
						}
						if (dadosConsumoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeConsumo4((String) dadosConsumoHistoricoDoImovel[1]);
						}
					}
					if (dadosMedicaoHistoricoDoImovel != null) {
						if (dadosMedicaoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setDtLeituraAtualInformada4(Util
											.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
						}
						if (dadosMedicaoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setLeituraAtualInformada4(""
											+ (Integer) dadosMedicaoHistoricoDoImovel[1]);
						}
						if (dadosMedicaoHistoricoDoImovel[2] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeLeitura4((String) dadosMedicaoHistoricoDoImovel[2]);
						}
					}
					break;

				case 4:
					analiseConsumoRelatorioOSHelper
							.setAnoMesHistoricoConsumo5(Util
									.formatarAnoMesParaMesAno(anoMesSubtraido));
					if (dadosConsumoHistoricoDoImovel != null) {
						if (dadosConsumoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setConsumoFaturado5(""
											+ (Integer) dadosConsumoHistoricoDoImovel[0]);
						}
						if (dadosConsumoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeConsumo5((String) dadosConsumoHistoricoDoImovel[1]);
						}
					}
					if (dadosMedicaoHistoricoDoImovel != null) {
						if (dadosMedicaoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setDtLeituraAtualInformada5(Util
											.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
						}
						if (dadosMedicaoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setLeituraAtualInformada5(""
											+ (Integer) dadosMedicaoHistoricoDoImovel[1]);
						}
						if (dadosMedicaoHistoricoDoImovel[2] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeLeitura5((String) dadosMedicaoHistoricoDoImovel[2]);
						}
					}
					break;

				case 5:
					analiseConsumoRelatorioOSHelper
							.setAnoMesHistoricoConsumo6(Util
									.formatarAnoMesParaMesAno(anoMesSubtraido));
					if (dadosConsumoHistoricoDoImovel != null) {
						if (dadosConsumoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setConsumoFaturado6(""
											+ (Integer) dadosConsumoHistoricoDoImovel[0]);
						}
						if (dadosConsumoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeConsumo6((String) dadosConsumoHistoricoDoImovel[1]);
						}
					}
					if (dadosMedicaoHistoricoDoImovel != null) {
						if (dadosMedicaoHistoricoDoImovel[0] != null) {
							analiseConsumoRelatorioOSHelper
									.setDtLeituraAtualInformada6(Util
											.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
						}
						if (dadosMedicaoHistoricoDoImovel[1] != null) {
							analiseConsumoRelatorioOSHelper
									.setLeituraAtualInformada6(""
											+ (Integer) dadosMedicaoHistoricoDoImovel[1]);
						}
						if (dadosMedicaoHistoricoDoImovel[2] != null) {
							analiseConsumoRelatorioOSHelper
									.setDescAbrevAnormalidadeLeitura6((String) dadosMedicaoHistoricoDoImovel[2]);
						}
					}
					break;

				}
			}
		}

		return analiseConsumoRelatorioOSHelper;
	}

	/**
	 * relatório de regitro atendimento
	 * 
	 * @author Vivianne Sousa
	 * @date 08/06/2007
	 * 
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public HidrometroRelatorioOSHelper obterDadosHidrometro(Integer idImovel)
			throws ControladorException {

		HidrometroRelatorioOSHelper hidrometroRelatorioOSHelper = new HidrometroRelatorioOSHelper();
		Object[] dadosHidrometro = null;

		try {
			dadosHidrometro = repositorioMicromedicao
					.obterDadosHidrometro(idImovel);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (dadosHidrometro != null) {

			if (dadosHidrometro[0] != null) {
				if (!dadosHidrometro[0].equals("")) {
					String numeroHidrometro = (String) dadosHidrometro[0];
					hidrometroRelatorioOSHelper
							.setHidrometroFixo(numeroHidrometro.substring(0, 4));
					numeroHidrometro = Util.adicionarZerosEsquedaNumero(
							10,
							numeroHidrometro.substring(4,
									numeroHidrometro.length()));
					hidrometroRelatorioOSHelper
							.setHidrometroNumero(numeroHidrometro.substring(4,
									10));
				}
			}

			if (dadosHidrometro[1] != null) {
				hidrometroRelatorioOSHelper
						.setHidrometroMarca((String) dadosHidrometro[1]);
			}

			if (dadosHidrometro[2] != null) {
				hidrometroRelatorioOSHelper
						.setHidrometroCapacidade((String) dadosHidrometro[2]);
			}

			if (dadosHidrometro[3] != null) {
				hidrometroRelatorioOSHelper
						.setHidrometroDiametro((String) dadosHidrometro[3]);
			}

			if (dadosHidrometro[4] != null) {
				hidrometroRelatorioOSHelper
						.setHidrometroLocal((String) dadosHidrometro[4]);
			}

			if (dadosHidrometro[5] != null) {
				hidrometroRelatorioOSHelper.setHidrometroLeitura(Util
						.formatarData((Date) dadosHidrometro[5]));
			}

			if (dadosHidrometro[6] != null) {
				hidrometroRelatorioOSHelper.setHidrometroNumeroDigitos(""
						+ (Short) dadosHidrometro[6]);
			}

		}

		return hidrometroRelatorioOSHelper;
	}

	/**
	 * Permite inserir uma Capacidade de Hidrometro
	 * 
	 * [UC0217] Inserir Capacidade hidrometro
	 * 
	 * @author Thiago Tenório
	 * @date 26/06/2007
	 * 
	 */
	public Integer inserirCapacidadeHidrometro(
			HidrometroCapacidade hidrometroCapacidade, Usuario usuarioLogado)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_CAPACIDADE_HIDROMETRO_INSERIR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CAPACIDADE_HIDROMETRO_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		hidrometroCapacidade.setOperacaoEfetuada(operacaoEfetuada);
		hidrometroCapacidade.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(hidrometroCapacidade);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Integer id = (Integer) getControladorUtil().inserir(
				hidrometroCapacidade);

		return id;

	}

	/**
	 * [UC0298] Manter Agência bancária [] Atualizar Agência Bancária Metodo que
	 * atualiza a Agência Bancária
	 * 
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * 
	 * 
	 * @throws ControladorException
	 */

	public void atualizarCapacidadeHidrometro(
			HidrometroCapacidade hidrometroCapacidade)
			throws ControladorException {

		// Verifica se todos os campos obrigatorios foram preenchidos

		if ((hidrometroCapacidade.getId() == null || hidrometroCapacidade
				.getId().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (hidrometroCapacidade.getDescricao() == null || hidrometroCapacidade
						.getDescricao().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (hidrometroCapacidade.getDescricaoAbreviada() == null || hidrometroCapacidade
						.getDescricaoAbreviada().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (hidrometroCapacidade.getLeituraMinimo() == null || hidrometroCapacidade
						.getLeituraMinimo().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (hidrometroCapacidade.getLeituraMaximo() == null || hidrometroCapacidade
						.getLeituraMaximo().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (hidrometroCapacidade.getIndicadorUso() == null || hidrometroCapacidade
						.getIndicadorUso().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (hidrometroCapacidade.getNumeroOrdem() == null || hidrometroCapacidade
						.getNumeroOrdem().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Identicador da capacidade de Hidrômetro foi
		// preenchido

		if (hidrometroCapacidade.getId() == null
				|| hidrometroCapacidade.getId().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Identicador da capacidade de Hidrômetro");
		}

		// Verifica se o campo Descrição foi preenchido
		if (hidrometroCapacidade.getDescricao() == null
				|| hidrometroCapacidade.getDescricao().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Descrição");
		}

		// Verifica se o campo Número mínimo de dígitos de leitura do hidrômetro
		// foi preenchido
		if (hidrometroCapacidade.getLeituraMinimo() == null
				|| hidrometroCapacidade.getLeituraMinimo().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Número mínimo de dígitos de leitura do hidrômetro");
		}

		// Verifica se o campo Número máximo de dígitos de leitura do hidrômetro
		// foi preenchido
		if (hidrometroCapacidade.getLeituraMaximo() == null
				|| hidrometroCapacidade.getLeituraMaximo().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Número máximo de dígitos de leitura do hidrômetro");
		}

		// Verifica se o campo Número de ordem da capacidade do hidrômetro foi
		// preenchido
		if (hidrometroCapacidade.getNumeroOrdem() == null
				|| hidrometroCapacidade.getNumeroOrdem().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Número de ordem da capacidade do hidrômetro");
		}

		// Verifica se o campo Código da Capacidade do hidrômetro foi preenchido
		if (hidrometroCapacidade.getCodigoHidrometroCapacidade() == null
				|| hidrometroCapacidade.getCodigoHidrometroCapacidade().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Código da Capacidade do hidrômetro");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroHidrometroCapacidade filtroHidrometroCapacidade = new FiltroHidrometroCapacidade();
		filtroHidrometroCapacidade.adicionarParametro(new ParametroSimples(
				FiltroHidrometroCapacidade.ID, hidrometroCapacidade.getId()));

		Collection colecaoHidrometroCapacidadeBase = getControladorUtil()
				.pesquisar(filtroHidrometroCapacidade,
						HidrometroCapacidade.class.getName());

		if (colecaoHidrometroCapacidadeBase == null
				|| colecaoHidrometroCapacidadeBase.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		HidrometroCapacidade hidrometroCapacidadeBase = (HidrometroCapacidade) colecaoHidrometroCapacidadeBase
				.iterator().next();

		if (hidrometroCapacidadeBase.getUltimaAlteracao().after(
				hidrometroCapacidade.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		hidrometroCapacidade.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(hidrometroCapacidade);

	}

	/**
	 * [UC0595] Gerar Histórico de Medicao
	 * 
	 * @param medicaoTipo
	 *            Tipo de medição
	 * @param imovel
	 *            Imovel a ter a medicao gerada
	 * @param faturamentoGrupo
	 *            Grupo de faturamento
	 * @return
	 * @throws ControladorException
	 */
	public MedicaoHistorico gerarHistoricoMedicao(MedicaoTipo medicaoTipo, Imovel imovel, FaturamentoGrupo faturamentoGrupo,
			SistemaParametro sistemaParametro) throws ControladorException {

		Collection colecaoMedicaoHistoricoMesAnterior = null;

		MedicaoHistorico medicaoHistorico = new MedicaoHistorico();

		if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()) {
			medicaoHistorico.setLigacaoAgua(imovel.getLigacaoAgua());
			medicaoHistorico.setHidrometroInstalacaoHistorico(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico());

		} else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()) {
			medicaoHistorico.setImovel(imovel);
			medicaoHistorico.setHidrometroInstalacaoHistorico(imovel.getHidrometroInstalacaoHistorico());

		}

		medicaoHistorico.setNumeroVezesConsecutivasOcorrenciaAnormalidade(new Short("0"));
		medicaoHistorico.setMedicaoTipo(medicaoTipo);
		medicaoHistorico.setAnoMesReferencia(sistemaParametro.getAnoMesFaturamento());

		String anoMes = "" + faturamentoGrupo.getAnoMesReferencia();

		int anoMesAnterior = Util.subtrairMesDoAnoMes(new Integer(anoMes).intValue(), 1);

		FaturamentoGrupo faturamentoGrupoAuxiliar = new FaturamentoGrupo();
		faturamentoGrupoAuxiliar.setAnoMesReferencia(new Integer(anoMesAnterior).intValue());

		try {
			colecaoMedicaoHistoricoMesAnterior = repositorioMicromedicao.pesquisarObterDadosHistoricoMedicao(imovel, medicaoTipo,faturamentoGrupoAuxiliar);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoMedicaoHistoricoMesAnterior == null || colecaoMedicaoHistoricoMesAnterior.isEmpty()) {

			int anoMesDoisMesesAnteriores =  Util.subtrairMesDoAnoMes(new Integer(anoMes).intValue(), 2);
			
			faturamentoGrupoAuxiliar.setAnoMesReferencia(anoMesDoisMesesAnteriores);

			try {
				colecaoMedicaoHistoricoMesAnterior = repositorioMicromedicao.pesquisarObterDadosHistoricoMedicao(imovel, medicaoTipo, faturamentoGrupoAuxiliar);
			} catch (ErroRepositorioException ex) {
				throw new ControladorException("erro.sistema", ex);
			}
		}

		LeituraSituacao leituraSituacao = new LeituraSituacao();

		FiltroLeituraSituacao filtro = new FiltroLeituraSituacao();
		filtro.adicionarParametro(new ParametroSimples(FiltroLeituraSituacao.ID, LeituraSituacao.NAO_REALIZADA));

		Collection colFiltros = getControladorUtil().pesquisar(filtro, leituraSituacao.getClass().getName());

		leituraSituacao = (LeituraSituacao) colFiltros.toArray()[0];

		// Com o valor da Data Prevista para a atividade de efetuar leitura no cronograma do
		// grupo de faturamento do mês corrente (FTAC_DTPREVISTA), limitada à data corrente
		Object[] datas = obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(faturamentoGrupo, sistemaParametro.getAnoMesFaturamento());

		Date dataPrevista = null;

		if (datas != null) {
			dataPrevista = (Date) datas[0];
		}

		if (colecaoMedicaoHistoricoMesAnterior != null && !colecaoMedicaoHistoricoMesAnterior.isEmpty()) {

			MedicaoHistorico medicaoHistoricoMesAnterior = obterHistoricoMedicao(colecaoMedicaoHistoricoMesAnterior);

			medicaoHistorico.setDataLeituraAnteriorFaturamento(medicaoHistoricoMesAnterior.getDataLeituraAtualFaturamento());
			medicaoHistorico.setLeituraAnteriorFaturamento(medicaoHistoricoMesAnterior.getLeituraAtualFaturamento());
			medicaoHistorico.setLeituraAnteriorInformada(medicaoHistoricoMesAnterior.getLeituraAtualInformada());
			medicaoHistorico.setLeituraSituacaoAnterior(medicaoHistoricoMesAnterior.getLeituraSituacaoAtual());

		} else {

			Object[] maiorMedicaoHistorico = null;

			try {
				maiorMedicaoHistorico = (Object[]) repositorioMicromedicao.pesquisarObterDadosMaiorHistoricoMedicao(imovel,medicaoTipo, sistemaParametro);
			} catch (ErroRepositorioException ex) {
				throw new ControladorException("erro.sistema", ex);
			}

			if (maiorMedicaoHistorico != null) {

				medicaoHistorico.setDataLeituraAnteriorFaturamento((Date) maiorMedicaoHistorico[0]);
				medicaoHistorico.setLeituraAnteriorFaturamento(((Integer) maiorMedicaoHistorico[1]).intValue());
				medicaoHistorico.setLeituraAnteriorInformada((Integer) maiorMedicaoHistorico[2]);
			}
			
			else {

				// e a data de Realização para a atividade de efetuar leitura no cronograma do grupo de faturamento do mês anterior (FTAC_TMREALIZACAO).
				Integer anoMesFaturamentoAnterior = Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(), 1);

				Object[] datasAnterior = obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(faturamentoGrupo, anoMesFaturamentoAnterior);

				Date dataRealizada = null;

				if (datasAnterior == null) {
					dataRealizada = this.gerarDataRealizacaoLeituraAnterior(faturamentoGrupo, sistemaParametro);

				} else if (datasAnterior.length == 1 && datasAnterior[0] != null && datasAnterior[1] == null) {
					dataRealizada = (Date) datasAnterior[0];
				
				} else if(datasAnterior.length > 1 && datasAnterior[1] != null) {
					dataRealizada = (Date) datasAnterior[1];
				
				}else if(datasAnterior.length > 1 && datasAnterior[0] != null && datasAnterior[1] == null) {
					dataRealizada = (Date) datasAnterior[0];
				
				}else{
					dataRealizada = this.gerarDataRealizacaoLeituraAnterior(faturamentoGrupo, sistemaParametro);
				}

				
				Date dataLeituraAnteriorFaturamento = null;

				if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()) {

					if (Util.compararData(dataRealizada, imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao()) == 1) {
						dataLeituraAnteriorFaturamento = dataRealizada;
					
					} else {
						dataLeituraAnteriorFaturamento = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();
					}

					if (imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) {
						medicaoHistorico.setLeituraAnteriorFaturamento(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getNumeroLeituraInstalacao());
					}

				} else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()) {

					if (Util.compararData(dataRealizada, imovel.getHidrometroInstalacaoHistorico().getDataInstalacao()) == 1) {
						dataLeituraAnteriorFaturamento = dataRealizada;
					
					} else {
						dataLeituraAnteriorFaturamento =imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();
					}

					if(imovel.getHidrometroInstalacaoHistorico() != null) {
						medicaoHistorico.setLeituraAnteriorFaturamento(imovel.getHidrometroInstalacaoHistorico().getNumeroLeituraInstalacao());
					}
				}
				medicaoHistorico.setDataLeituraAnteriorFaturamento(dataLeituraAnteriorFaturamento);
			}

			medicaoHistorico.setLeituraSituacaoAnterior(leituraSituacao);
		}

		if (dataPrevista != null) {
			medicaoHistorico.setDataLeituraAtualFaturamento(dataPrevista);
		} else {
			medicaoHistorico.setDataLeituraAtualFaturamento(Util.adicionarNumeroDiasDeUmaData(medicaoHistorico.getDataLeituraAnteriorFaturamento(), 30));
		}

		medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
		medicaoHistorico.setIndicadorAnalisado(MedicaoHistorico.INDICADOR_ANALISADO_NAO);
		medicaoHistorico.setUltimaAlteracao(new Date());

		return medicaoHistorico;
	}

	/**
	 * relatório de extrato de debito
	 * 
	 * @author Vivianne Sousa
	 * @date 17/07/2007
	 * 
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public String obterRotaESequencialRotaDoImovel(Integer idImovel)
			throws ControladorException {

		String codigoRotaESequencialRota = "";
		Object[] dados = null;

		try {
			dados = repositorioMicromedicao
					.obterRotaESequencialRotaDoImovel(idImovel);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if (dados != null) {
			if (dados[0] != null) {
				codigoRotaESequencialRota = "" + (Short) dados[0];
			}
			if (dados[1] != null) {
				codigoRotaESequencialRota = codigoRotaESequencialRota + "."
						+ (Integer) dados[1];
			}
		}

		return codigoRotaESequencialRota;
	}

	/**
	 * Emitir Contas Caema
	 * 
	 * @author Tiago Moreno
	 * @date 06/11/2008
	 * 
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */

	public Object[] obterRotaESequencialRotaDoImovelSeparados(Integer idImovel)
			throws ControladorException {

		Object[] dados = null;

		try {
			dados = repositorioMicromedicao
					.obterRotaESequencialRotaDoImovel(idImovel);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return dados;
	}

	/**
	 * [UC0623] Gerar Resumo de Metas CAERN
	 * 
	 * @author Sávio Luiz
	 * @date 15/11/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Integer pesquisarConsumoFaturado(Integer idImovel,
			Integer tipoLigacao, Integer idConsumoTipoMediaImovel,
			Integer idConsumoTipoMediaHidrometro, Integer amArrecadacao)
			throws ControladorException {
		try {
			return repositorioMicromedicao.pesquisarConsumoFaturado(idImovel,
					tipoLigacao, idConsumoTipoMediaImovel,
					idConsumoTipoMediaHidrometro, amArrecadacao);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Permite inserir um Leiturista
	 * 
	 * [UC0588] Inserir Leiturista
	 * 
	 * @author Thiago Tenório
	 * @date 22/07/2007
	 * 
	 */
	public Integer inserirLeiturista(Leiturista leiturista,
			Usuario usuarioLogado) throws ControladorException {

		// FiltroLeituraAnormalidade filtroLeituraAnormalidade = new
		// FiltroLeituraAnormalidade();

		/*
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.DESCRICAO, leituraAnormalidade
		 * .getDescricao()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.DESCRICAO_ABREVIADA,
		 * leituraAnormalidade.getDescricaoAbreviada()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_RELATIVO_HIDROMETRO,
		 * leituraAnormalidade.getIndicadorRelativoHidrometro()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_IMOVEL_SEM_HIDROMETRO,
		 * leituraAnormalidade.getIndicadorImovelSemHidrometro()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_USO_SISTEMA,
		 * leituraAnormalidade.getIndicadorSistema()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_EMISSAO_ORDEM_SERVICO,
		 * leituraAnormalidade.getIndicadorEmissaoOrdemServico()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_TIPO_SERVICO, leituraAnormalidade
		 * .getServicoTipo()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_CONSUMO_A_COBRAR_SEM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_CONSUMO_A_COBRAR_COM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_LEITURA_A_FATURAR_SEM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura()));
		 * 
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_LEITURA_A_FATURAR_COM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeLeituraComleitura()));
		 */
		// Collection colecaoAnormalidadeLeitura =
		// getControladorUtil().pesquisar(
		// filtroLeituraAnormalidade, LeituraAnormalidade.class.getName());
		// if (colecaoAnormalidadeLeitura != null
		// && !colecaoAnormalidadeLeitura.isEmpty()) {
		// throw new ControladorException(
		// "atencao.endereco_localidade_nao_informado");
		// }
		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_LEITURISTA_INSERIR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_LEITURISTA_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		leiturista.setOperacaoEfetuada(operacaoEfetuada);
		leiturista.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(leiturista);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Integer id = (Integer) getControladorUtil().inserir(leiturista);

		return id;

	}

	/**
	 * [UC0583] Inserir Roteiro Empresa
	 * 
	 * Insere um objeto do tipo roteiro empresa no BD
	 * 
	 * @author Francisco Nascimento
	 * @date 24/07/2007
	 * @param roteiro
	 *            empresa
	 * @param idLocalidade
	 * @param quadras
	 * @return idRota
	 * @throws ControladorException
	 */
	public Integer inserirRoteiroEmpresa(RoteiroEmpresa roteiroEmpresa,
			String[] idQuadrasAdicionar, Usuario usuarioLogado)
			throws ControladorException {

		validacaoFinalRoteiroEmpresa("" + roteiroEmpresa.getEmpresa().getId(),
				roteiroEmpresa.getLeiturista(),
				"" + roteiroEmpresa.getIndicadorUso(), "INSERIR",
				idQuadrasAdicionar);

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ROTEIRO_EMPRESA_INSERIR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		roteiroEmpresa.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

		registradorOperacao.registrarOperacao(roteiroEmpresa);

		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// Inserir o roteiro empresa
		Integer idRoteiroEmpresa = (Integer) this.getControladorUtil().inserir(
				roteiroEmpresa);
		roteiroEmpresa.setId(idRoteiroEmpresa);

		// -- codigo para atualizar quadras do roteiro empresa
		roteiroEmpresa.setId(idRoteiroEmpresa);
		String quadrasJaPertencentes = "";
		for (int i = 0; i < idQuadrasAdicionar.length; i++) {

			// Cria o filtro
			FiltroQuadra filtroQuadra = new FiltroQuadra();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = Quadra.class.getName();

			// Seta os parametros do filtro
			filtroQuadra.adicionarParametro(new ParametroSimples(
					FiltroQuadra.ID, idQuadrasAdicionar[i]));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection quadras = getControladorUtil().pesquisar(filtroQuadra,
					nomePacoteObjeto);

			Quadra quadraNaBase = (Quadra) Util.retonarObjetoDeColecao(quadras);

			// [FS0007] - Verificar duplicidade de roteiro empresa para a quadra
			if (quadraNaBase.getRoteiroEmpresa() != null
					&& !quadraNaBase
							.getRoteiroEmpresa()
							.getId()
							.equals(new Integer(
									ConstantesSistema.NUMERO_NAO_INFORMADO))) {
				quadrasJaPertencentes += quadraNaBase.getNumeroQuadra() + ", ";
			} else {
				quadraNaBase.setRoteiroEmpresa(roteiroEmpresa);
				// quadraNaBase.setOperacaoEfetuada(operacaoEfetuada);
				quadraNaBase.adicionarUsuario(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(quadraNaBase);
				getControladorLocalidade().atualizarQuadra(quadraNaBase,
						usuarioLogado, null);
			}
		}
		if (!quadrasJaPertencentes.equals("")) {
			ControladorException ce = new ControladorException(
					"atencao.quadra_ja_pertence_roteiro_empresa");
			String parametros[] = { quadrasJaPertencentes.substring(0,
					quadrasJaPertencentes.length() - 2) };
			ce.setParametroMensagem(parametros);
			throw ce;
		}
		return idRoteiroEmpresa;
	}

	private void validacaoFinalRoteiroEmpresa(String empresa,
			Leiturista leiturista, String indicadorUso, String acao,
			String[] quadras) throws ControladorException {

		// Empresa é obrigatório.
		if ((empresa == null) || (empresa.equals(""))) {
			throw new ControladorException("atencao.empresa_nao_informada");
		}

		// Leiturista é obrigatório.
		if (leiturista == null
				|| leiturista.getId() == null
				|| leiturista.getId().intValue() == ConstantesSistema.NUMERO_NAO_INFORMADO) {
			throw new ControladorException("atencao.leiturista_nao_informado");
		}

		if (quadras == null || quadras.length == 0) {
			throw new ControladorException("atencao.quadras_nao_informadas");
		}

	}

	/**
	 * Permite gerar o arquivo texto do roteiro empresa para o leiturista.
	 * 
	 * [UC0627] Gerar Arquivo Texto para Leitura
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 02/08/2007, 15/10/2007
	 * 
	 * @param colecaoRoteirosEmpresa
	 * @param colecaoRotas
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void gerarArquivoTextoParaLeiturista(
			Collection colecaoRoteirosEmpresa, Collection colecaoRotas,
			Integer anoMesFaturamento, FaturamentoGrupo faturamentoGrupo,
			int idFuncionalidadeIniciada) throws ControladorException {

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		int idUnidadeIniciada = 0;

		/*
		 * idUnidadeIniciada = getControladorBatch()
		 * .iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
		 * UnidadeProcessamento.FUNCIONALIDADE, 0);
		 */

		try {
			/*
			 * recupera o indicador de roteiro empresa da tabela de parametros
			 * do sistema
			 */
			SistemaParametro sistemaParametro = getControladorUtil()
					.pesquisarParametrosDoSistema();
			Short indicadorRoteiroEmpresa = sistemaParametro
					.getIndicadorRoteiroEmpresa();

			/*
			 * Caso o indicador de roteiro empresa esteja com valor igual a 1
			 * (SIM) processar todos que estão na lista de roteiro empresa Caso
			 * contrario, processar todas as rotas que estão na lista de rotas.
			 */
			if (indicadorRoteiroEmpresa.equals(ConstantesSistema.SIM)) {
				// [SB0001 - Processar Movimento Roteiro Empresa por Roteiro
				// Empresa]
				processarMovimentoRoteiroEmpresaPorRoteiroEmpresa(
						colecaoRoteirosEmpresa, anoMesFaturamento,
						faturamentoGrupo, sistemaParametro, idUnidadeIniciada,
						idFuncionalidadeIniciada);
			} else {
				// [SB0002 - Processar Movimento Roteiro Empresa por Rota]
				processarMovimentoRoteiroEmpresaPorRota(colecaoRotas,
						anoMesFaturamento, faturamentoGrupo, sistemaParametro,
						idUnidadeIniciada, idFuncionalidadeIniciada);
			}

			/* fecha a unidade de processamento com sucesso */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception ex) {

			ex.printStackTrace();

			/* fecha a unidade de processamento com erro */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(ex,
					idUnidadeIniciada, true);

			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0627] Gerar Arquivo Texto para Leitura
	 * 
	 * [SB0001] Processar Movimento Roteiro Empresa por Roteiro Empresa
	 * 
	 * @author Pedro Alexandre
	 * @date 15/10/2007
	 * 
	 * @param colecaoRoteirosEmpresa
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	private void processarMovimentoRoteiroEmpresaPorRoteiroEmpresa(
			Collection colecaoRoteirosEmpresa, Integer anoMesFaturamento,
			FaturamentoGrupo faturamentoGrupo,
			SistemaParametro sistemaParametro, int idUnidadeIniciada,
			int idFuncionalidadeIniciada) throws ControladorException {
		// Caso a coleção de roteiros empresa não esteja vazia
		if (colecaoRoteirosEmpresa != null && !colecaoRoteirosEmpresa.isEmpty()) {

			Integer idLocalidadeTemp = null;
			Integer sequencial = 1;
			boolean flagPrimeiraVez = true;

			try {
				// o sistema classifica a lista de roteiros empresas recebidas
				// por empresa
				Collections.sort((List) colecaoRoteirosEmpresa,
						new Comparator() {
							public int compare(Object a, Object b) {
								Integer codigo1 = ((RoteiroEmpresa) a)
										.getEmpresa().getId();
								Integer codigo2 = ((RoteiroEmpresa) b)
										.getEmpresa().getId();
								if (codigo1 == null || codigo1.equals("")) {
									return -1;
								} else {
									return codigo1.compareTo(codigo2);
								}
							}
						});

				Iterator iteratorRoteirosEmpresa = colecaoRoteirosEmpresa
						.iterator();

				// Para cada roteiro empresa gera o arquivo texto para leitura.
				while (iteratorRoteirosEmpresa.hasNext()) {

					RoteiroEmpresa roteiroEmpresa = (RoteiroEmpresa) iteratorRoteirosEmpresa
							.next();

					// -------------------------
					//
					// Registrar o início do processamento da Unidade de
					// Processamento
					// do Batch
					//
					// -------------------------
					idUnidadeIniciada = getControladorBatch()
							.iniciarUnidadeProcessamentoBatch(
									idFuncionalidadeIniciada,
									UnidadeProcessamento.FUNCIONALIDADE, 0);
					// --------------------------

					// [FS005] Verificar existência do arquivo texto roteiro
					// empresa
					boolean gerarArquivoTexto = true;

					ArquivoTextoRoteiroEmpresa arquivo;

					try {

						arquivo = this.repositorioMicromedicao
								.pesquisaArquivoTextoParaLeituristaPorRoteiroEmpresa(
										anoMesFaturamento,
										roteiroEmpresa.getId(),
										faturamentoGrupo.getId());

					} catch (ErroRepositorioException e1) {
						throw new ControladorException("erro.sistema", e1);
					}

					if (arquivo != null) {
						if (arquivo
								.getSituacaoTransmissaoLeitura()
								.getId()
								.compareTo(
										SituacaoTransmissaoLeitura.DISPONIVEL) == 0) {

							this.getControladorUtil().remover(arquivo);

						} else {

							gerarArquivoTexto = false;

						}
					}

					if (gerarArquivoTexto) {

						// [FS0004] Verificar quantidade de setores comerciais
						int qtdSetorComercial = this.repositorioMicromedicao
								.pesquisarQuantidadeSetorComercialPorRoteiroEmpresa(
										roteiroEmpresa.getId(),
										anoMesFaturamento,
										faturamentoGrupo.getId(),
										LeituraTipo.CELULAR_MOBILE);

						// caso a quantidade de setor comercial não exceda 3,
						// processa a coleção de movimento roteiro empresa.
						if (qtdSetorComercial <= 3) {
							// pesquisa os dados do movimento roteiro empresa
							Collection<Object[]> colecaoDadosMovimentoRoteiroEmpresa = this.repositorioMicromedicao
									.pesquisarMovimentoRoteiroEmpresa(
											roteiroEmpresa.getId(),
											anoMesFaturamento,
											faturamentoGrupo.getId());

							// [FS0001 - Verificar Seleção de imóvel]
							if (colecaoDadosMovimentoRoteiroEmpresa != null
									&& !colecaoDadosMovimentoRoteiroEmpresa
											.isEmpty()) {

								// gera o arquivo txt para o roteiro empresa
								// e retorna as informações necessárias para
								// inserir
								// o ArquivoTextoParaRoteiroEmpresa
								Object[] dadosRoteiroEmpresa = this
										.gerarArquivoTextoParaRoteiroEmpresa(
												colecaoDadosMovimentoRoteiroEmpresa,
												faturamentoGrupo,
												sistemaParametro);

								byte[] arquivoRoteiroEmpresaByte = null;
								StringBuilder arquivoRoteiroEmpresa = null;

								// recupera o arquivo txt gerado
								arquivoRoteiroEmpresa = (StringBuilder) dadosRoteiroEmpresa[0];
								arquivoRoteiroEmpresaByte = IoUtil
										.transformarObjetoParaBytes(arquivoRoteiroEmpresa);

								// dados necessários para inserir o
								// ArquivoTextoParaRoteiroEmpresa
								Integer codigoSetorComercial1 = (Integer) dadosRoteiroEmpresa[1];
								Integer numeroQuadraInicial1 = (Integer) dadosRoteiroEmpresa[2];
								Integer numeroQuadraFinal1 = (Integer) dadosRoteiroEmpresa[3];
								Integer codigoSetorComercial2 = (Integer) dadosRoteiroEmpresa[4];
								Integer numeroQuadraInicial2 = (Integer) dadosRoteiroEmpresa[5];
								Integer numeroQuadraFinal2 = (Integer) dadosRoteiroEmpresa[6];
								Integer codigoSetorComercial3 = (Integer) dadosRoteiroEmpresa[7];
								Integer numeroQuadraInicial3 = (Integer) dadosRoteiroEmpresa[8];
								Integer numeroQuadraFinal3 = (Integer) dadosRoteiroEmpresa[9];
								Integer qtdImoveis = (Integer) dadosRoteiroEmpresa[10];

								Integer idLocalidadePrimeiroImovel = (Integer) dadosRoteiroEmpresa[11];
								Localidade localidadePrimeiroImovel = new Localidade();
								localidadePrimeiroImovel
										.setId(idLocalidadePrimeiroImovel);

								// define se o vai incrementar o sequencia
								// dependendo se a localidade permanece a mesma
								// para o roteiro empresa diferente, cso
								// contrario
								// inicia o sequencial com 1.
								if (flagPrimeiraVez) {
									flagPrimeiraVez = false;
									idLocalidadeTemp = idLocalidadePrimeiroImovel;
								} else {
									if (idLocalidadeTemp
											.equals(idLocalidadePrimeiroImovel)) {
										sequencial++;
									} else {
										sequencial = 1;
										idLocalidadeTemp = idLocalidadePrimeiroImovel;
									}
								}

								/*
								 * instância a situação da transmissão de
								 * leitura para "LIBERADO"
								 */
								SituacaoTransmissaoLeitura situacaoTransmissaoLeitura = new SituacaoTransmissaoLeitura();

								/*
								 * Alteração feita para os arquivos serem
								 * gerados com situação Disponível = 1 * Thiago
								 * Nascimento 01/01/2008
								 */
								situacaoTransmissaoLeitura
										.setId(SituacaoTransmissaoLeitura.DISPONIVEL);

								// [FS0003] - Nome do Arquivo Texto
								String nomeArquivo = this
										.gerarNomeArquivoTextoParaRoteiroEmpresa(
												idLocalidadePrimeiroImovel,
												codigoSetorComercial1, null,
												faturamentoGrupo.getId(),
												faturamentoGrupo
														.getAnoMesReferencia());

								// cria o ArquivoTextoRoteiroEmpresa para ser
								// inserido.
								ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = new ArquivoTextoRoteiroEmpresa();
								arquivoTextoRoteiroEmpresa
										.setAnoMesReferencia(anoMesFaturamento);
								arquivoTextoRoteiroEmpresa
										.setRoteiroEmpresa(roteiroEmpresa);
								arquivoTextoRoteiroEmpresa
										.setFaturamentoGrupo(faturamentoGrupo);
								arquivoTextoRoteiroEmpresa
										.setEmpresa(roteiroEmpresa.getEmpresa());
								arquivoTextoRoteiroEmpresa
										.setLocalidade(localidadePrimeiroImovel);
								arquivoTextoRoteiroEmpresa
										.setCodigoSetorComercial1(codigoSetorComercial1);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraInicial1(numeroQuadraInicial1);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraFinal1(numeroQuadraFinal1);
								arquivoTextoRoteiroEmpresa
										.setCodigoSetorComercial2(codigoSetorComercial2);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraInicial2(numeroQuadraInicial2);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraFinal2(numeroQuadraFinal2);
								arquivoTextoRoteiroEmpresa
										.setCodigoSetorComercial3(codigoSetorComercial3);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraInicial3(numeroQuadraInicial3);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraFinal3(numeroQuadraFinal3);
								arquivoTextoRoteiroEmpresa
										.setQuantidadeImovel(qtdImoveis);
								arquivoTextoRoteiroEmpresa
										.setNomeArquivo(nomeArquivo);
								arquivoTextoRoteiroEmpresa
										.setLeiturista(roteiroEmpresa
												.getLeiturista());
								arquivoTextoRoteiroEmpresa
										.setCodigoLeiturista(roteiroEmpresa
												.getLeiturista().getCodigoDDD());
								arquivoTextoRoteiroEmpresa
										.setNumeroFoneLeiturista(roteiroEmpresa
												.getLeiturista()
												.getNumeroFone());
								arquivoTextoRoteiroEmpresa
										.setArquivoTexto(arquivoRoteiroEmpresaByte);
								arquivoTextoRoteiroEmpresa
										.setUltimaAlteracao(new Date());
								arquivoTextoRoteiroEmpresa
										.setTempoEnvioEmpresa(null);
								arquivoTextoRoteiroEmpresa
										.setSituacaoTransmissaoLeitura(situacaoTransmissaoLeitura);
								arquivoTextoRoteiroEmpresa
										.setNumeroImei(roteiroEmpresa
												.getLeiturista()
												.getNumeroImei());
								arquivoTextoRoteiroEmpresa.setRota(null);

								ServicoTipoCelular servicoTipoCelular = new ServicoTipoCelular();
								servicoTipoCelular
										.setId(ServicoTipoCelular.LEITURA);
								arquivoTextoRoteiroEmpresa
										.setServicoTipoCelular(servicoTipoCelular);

								getControladorUtil().inserir(
										arquivoTextoRoteiroEmpresa);
							}
						} else {
							throw new ControladorException(
									"atencao.limite.excedente.setorcomercial");
						}
					}
				}

				// Erro no repositório
			} catch (Exception ex) {
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}
		}
	}

	/**
	 * [UC0627] Gerar Arquivo Texto para Leitura
	 * 
	 * [SB0002] Processar Movimento Roteiro Empresa por Rota
	 * 
	 * @author Pedro Alexandre
	 * @date 15/10/2007
	 * 
	 * @param colecaoRotas
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	private void processarMovimentoRoteiroEmpresaPorRota(
			Collection colecaoRotas, Integer anoMesFaturamento,
			FaturamentoGrupo faturamentoGrupo,
			SistemaParametro sistemaParametro, int idUnidadeIniciada,
			int idFuncionalidadeIniciada) throws ControladorException {
		// Caso a coleção de rotas não esteja vazia
		if (colecaoRotas != null && !colecaoRotas.isEmpty()) {

			Integer idLocalidadeTemp = null;
			Integer sequencial = 1;
			boolean flagPrimeiraVez = true;

			try {
				// o sistema classifica a lista de rotas recebidas
				// por empresa
				Collections.sort((List) colecaoRotas, new Comparator() {
					public int compare(Object a, Object b) {
						Integer codigo1 = ((Rota) a).getEmpresa().getId();

						Integer codigo2 = ((Rota) b).getEmpresa().getId();

						if (codigo1 == null || codigo1.equals("")) {
							return -1;
						} else {
							return codigo1.compareTo(codigo2);
						}
					}
				});

				Iterator iteratorRotas = colecaoRotas.iterator();

				// Para cada rota gera o arquivo texto para leitura.
				while (iteratorRotas.hasNext()) {
					// recupera a rota
					Rota rota = (Rota) iteratorRotas.next();

					// -------------------------
					//
					// Registrar o início do processamento da Unidade de
					// Processamento
					// do Batch
					//
					// -------------------------
					idUnidadeIniciada = getControladorBatch()
							.iniciarUnidadeProcessamentoBatch(
									idFuncionalidadeIniciada,
									UnidadeProcessamento.ROTA, rota.getId());
					// --------------------------

					// [FS005] Verificar existência do arquivo texto roteiro
					// empresa por rota
					boolean gerarArquivoTexto = true;

					ArquivoTextoRoteiroEmpresa arquivo = this.repositorioMicromedicao
							.pesquisaArquivoTextoParaLeituristaPorRota(
									anoMesFaturamento, rota.getId(),
									faturamentoGrupo.getId());

					if (arquivo != null) {
						if (arquivo
								.getSituacaoTransmissaoLeitura()
								.getId()
								.compareTo(
										SituacaoTransmissaoLeitura.DISPONIVEL) == 0) {

							this.getControladorUtil().remover(arquivo);

						} else {

							gerarArquivoTexto = false;

						}
					}

					if (gerarArquivoTexto) {
						// [FS0004] Verificar quantidade de setores comerciais
						// por
						// rota
						int qtdSetorComercial = this.repositorioMicromedicao
								.pesquisarQuantidadeSetorComercialPorRota(
										rota.getId(), anoMesFaturamento,
										faturamentoGrupo.getId());

						// caso a quantidade de setor comercial não exceda 3,
						// processa a coleção de movimento roteiro empresa.
						if (qtdSetorComercial <= 3) {

							// pesquisa os dados do movimento roteiro empresa
							// por
							// rota
							Collection<Object[]> colecaoDadosMovimentoRoteiroEmpresa = this.repositorioMicromedicao
									.pesquisarMovimentoRoteiroEmpresaPorRota(
											rota.getId(), anoMesFaturamento,
											faturamentoGrupo.getId(),
											sistemaParametro
													.getNomeAbreviadoEmpresa(),
											LeituraTipo.CELULAR_MOBILE);

							// [FS0001 - Verificar Seleção de imóvel]
							if (colecaoDadosMovimentoRoteiroEmpresa != null
									&& !colecaoDadosMovimentoRoteiroEmpresa
											.isEmpty()) {

								// gera o arquivo txt para o rota
								// e retorna as informações necessárias para
								// inserir
								// o ArquivoTextoParaRoteiroEmpresa
								Object[] dadosRoteiroEmpresa = this
										.gerarArquivoTextoParaRoteiroEmpresa(
												colecaoDadosMovimentoRoteiroEmpresa,
												faturamentoGrupo,
												sistemaParametro);

								byte[] arquivoRoteiroEmpresaByte = null;
								StringBuilder arquivoRoteiroEmpresa = null;

								// recupera o arquivo txt gerado
								arquivoRoteiroEmpresa = (StringBuilder) dadosRoteiroEmpresa[0];
								arquivoRoteiroEmpresaByte = IoUtil
										.transformarObjetoParaBytes(arquivoRoteiroEmpresa);

								// dados necessários para inserir o
								// ArquivoTextoParaRoteiroEmpresa
								Integer codigoSetorComercial1 = (Integer) dadosRoteiroEmpresa[1];
								Integer numeroQuadraInicial1 = (Integer) dadosRoteiroEmpresa[2];
								Integer numeroQuadraFinal1 = (Integer) dadosRoteiroEmpresa[3];
								Integer codigoSetorComercial2 = (Integer) dadosRoteiroEmpresa[4];
								Integer numeroQuadraInicial2 = (Integer) dadosRoteiroEmpresa[5];
								Integer numeroQuadraFinal2 = (Integer) dadosRoteiroEmpresa[6];
								Integer codigoSetorComercial3 = (Integer) dadosRoteiroEmpresa[7];
								Integer numeroQuadraInicial3 = (Integer) dadosRoteiroEmpresa[8];
								Integer numeroQuadraFinal3 = (Integer) dadosRoteiroEmpresa[9];
								Integer qtdImoveis = (Integer) dadosRoteiroEmpresa[10];

								Integer idLocalidadePrimeiroImovel = (Integer) dadosRoteiroEmpresa[11];
								Localidade localidadePrimeiroImovel = new Localidade();
								localidadePrimeiroImovel
										.setId(idLocalidadePrimeiroImovel);

								// define se o vai incrementar o sequencia
								// dependendo se a localidade permanece a mesma
								// para o roteiro empresa diferente, cso
								// contrario
								// inicia o sequencial com 1.
								if (flagPrimeiraVez) {
									flagPrimeiraVez = false;
									idLocalidadeTemp = idLocalidadePrimeiroImovel;
								} else {
									if (idLocalidadeTemp
											.equals(idLocalidadePrimeiroImovel)) {
										sequencial++;
									} else {
										sequencial = 1;
										idLocalidadeTemp = idLocalidadePrimeiroImovel;
									}
								}

								/*
								 * instância a situação da transmissão de
								 * leitura para "LIBERADO"
								 */
								SituacaoTransmissaoLeitura situacaoTransmissaoLeitura = new SituacaoTransmissaoLeitura();

								/*
								 * Alteração feita para os arquivos serem
								 * gerados com situação Disponível = 1 * Thiago
								 * Nascimento 01/01/2008
								 */
								situacaoTransmissaoLeitura
										.setId(SituacaoTransmissaoLeitura.DISPONIVEL);

								// [FS0003] - Nome do Arquivo Texto
								String nomeArquivo = this
										.gerarNomeArquivoTextoParaRoteiroEmpresa(
												idLocalidadePrimeiroImovel,
												codigoSetorComercial1, rota
														.getCodigo(),
												faturamentoGrupo.getId(),
												faturamentoGrupo
														.getAnoMesReferencia());

								// cria o ArquivoTextoRoteiroEmpresa para ser
								// inserido.
								ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = new ArquivoTextoRoteiroEmpresa();
								arquivoTextoRoteiroEmpresa
										.setAnoMesReferencia(anoMesFaturamento);
								arquivoTextoRoteiroEmpresa
										.setRoteiroEmpresa(null);
								arquivoTextoRoteiroEmpresa
										.setFaturamentoGrupo(faturamentoGrupo);
								arquivoTextoRoteiroEmpresa.setEmpresa(rota
										.getEmpresa());
								arquivoTextoRoteiroEmpresa
										.setLocalidade(localidadePrimeiroImovel);
								arquivoTextoRoteiroEmpresa
										.setCodigoSetorComercial1(codigoSetorComercial1);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraInicial1(numeroQuadraInicial1);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraFinal1(numeroQuadraFinal1);
								arquivoTextoRoteiroEmpresa
										.setCodigoSetorComercial2(codigoSetorComercial2);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraInicial2(numeroQuadraInicial2);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraFinal2(numeroQuadraFinal2);
								arquivoTextoRoteiroEmpresa
										.setCodigoSetorComercial3(codigoSetorComercial3);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraInicial3(numeroQuadraInicial3);
								arquivoTextoRoteiroEmpresa
										.setNumeroQuadraFinal3(numeroQuadraFinal3);
								arquivoTextoRoteiroEmpresa
										.setQuantidadeImovel(qtdImoveis);
								arquivoTextoRoteiroEmpresa
										.setNomeArquivo(nomeArquivo);
								arquivoTextoRoteiroEmpresa.setLeiturista(rota
										.getLeiturista());
								arquivoTextoRoteiroEmpresa
										.setCodigoLeiturista(rota
												.getLeiturista().getCodigoDDD());
								arquivoTextoRoteiroEmpresa
										.setNumeroFoneLeiturista(rota
												.getLeiturista()
												.getNumeroFone());
								arquivoTextoRoteiroEmpresa
										.setArquivoTexto(arquivoRoteiroEmpresaByte);
								arquivoTextoRoteiroEmpresa
										.setUltimaAlteracao(new Date());
								arquivoTextoRoteiroEmpresa
										.setTempoEnvioEmpresa(null);
								arquivoTextoRoteiroEmpresa
										.setSituacaoTransmissaoLeitura(situacaoTransmissaoLeitura);
								arquivoTextoRoteiroEmpresa.setNumeroImei(rota
										.getLeiturista().getNumeroImei());
								arquivoTextoRoteiroEmpresa.setRota(rota);

								ServicoTipoCelular servicoTipoCelular = new ServicoTipoCelular();
								servicoTipoCelular
										.setId(ServicoTipoCelular.LEITURA);
								arquivoTextoRoteiroEmpresa
										.setServicoTipoCelular(servicoTipoCelular);

								/*
								 * Alteração feita para definir a sequencia do
								 * arquivo que deve ser liberado para o
								 * leiturista 11/04/2008
								 * 
								 * @autor Thiago Nascimento
								 */
								arquivoTextoRoteiroEmpresa
										.setNumeroSequenciaLeitura(rota
												.getNumeroSequenciaLeitura());

								getControladorUtil().inserir(
										arquivoTextoRoteiroEmpresa);
							}
						} else {
							throw new ControladorException(
									"atencao.limite.excedente.setorcomercial");
						}

					}
					/* fecha a unidade de processamento com sucesso */
					getControladorBatch().encerrarUnidadeProcessamentoBatch(
							null, idUnidadeIniciada, false);
				}

				// Erro no repositório
			} catch (Exception ex) {
				ex.printStackTrace();

				/* fecha a unidade de processamento com erro */
				getControladorBatch().encerrarUnidadeProcessamentoBatch(ex,
						idUnidadeIniciada, true);
				throw new ControladorException("erro.sistema", ex);
			}
		}
	}

	/**
	 * [UC0627] Gerar Arquivo Texto para Leiturista
	 * 
	 * Gera o arquivo texto para o roteiro empresa.
	 * 
	 * [SB0001] - Gerar Arquivo Texto
	 * 
	 * @author Pedro Alexandre
	 * @date 03/08/2007
	 * 
	 * @param colecaoDadosMovimentoRoteiroEmpresa
	 * @param faturamentoGrupo
	 * @return
	 * @throws ControladorException
	 */
	private Object[] gerarArquivoTextoParaRoteiroEmpresa(
			Collection<Object[]> colecaoDadosMovimentoRoteiroEmpresa,
			FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro)
			throws ControladorException {

		Object[] dadosRoteiroEmpresa = new Object[12];
		StringBuilder arquivoRoteiroEmpresa = new StringBuilder();

		// declara os maps que ira armazenar os setores comerciais e as quadras
		Map<Integer, Integer> mapSetorComercial = new HashMap();
		Map<Integer, Integer> mapQuadraInicial = new HashMap();
		Map<Integer, Integer> mapQuadraFinal = new HashMap();

		Integer cont = 1;

		Integer menorQuadra[] = new Integer[3];
		Integer maiorQuadra[] = new Integer[3];

		Integer codigoSetorComercial1 = null;
		Integer numeroQuadraInicial1 = null;
		Integer numeroQuadraFinal1 = null;

		Integer codigoSetorComercial2 = null;
		Integer numeroQuadraInicial2 = null;
		Integer numeroQuadraFinal2 = null;

		Integer codigoSetorComercial3 = null;
		Integer numeroQuadraInicial3 = null;
		Integer numeroQuadraFinal3 = null;

		// contador da quantidade de imóveis
		Integer qtdImoveis = 0;

		Integer idLocalidadePrimeiroImovel = null;
		boolean primeiraVez = true;

		Integer setorComercialTemp = null;
		// Integer idQuadraAnterior = null;

		/*
		 * 0 - id da localidade 1 - código do setor comercial 2 - número da
		 * quadra 3 - número do lote do imóvel 4 - número do sublote do imóvel 5
		 * - id do tipo de medição 6 - inscrição do imóvel 7 - id do perfil do
		 * imóvel 8 - nome do cliente usuário 9 - endereço do imóvel 10 - id da
		 * marca do hidrômetro 11 - número do hidrometro 12 - id da capacidade
		 * do hidrômetro 13 - id do local da instalação de hidrômetro 14 - data
		 * da instalação de hidrômetro 15 - id da proteção do hidrômetro 16 - id
		 * da situação da ligação de água 17 - id da situação da ligação de
		 * esgoto 18 - descrição abreviada da categoria do imóvel 19 -
		 * quantidades de economias 20 - leitura anterior 21 - faixa de leitura
		 * esperada inicial 22 - faixa de leitura esperada final 23 - Codigo da
		 * Rota 24 - Sequencial de Rota 25 - Matrícula do Funcionário
		 */
		for (Object[] dadosMovimentoRoteiroEmpresa : colecaoDadosMovimentoRoteiroEmpresa) {

			// recupera as informações do movimento roteiro empresa
			Integer idLocalidade = (Integer) dadosMovimentoRoteiroEmpresa[0];
			Integer codigoSetorComercial = (Integer) dadosMovimentoRoteiroEmpresa[1];
			Integer numeroQuadra = (Integer) dadosMovimentoRoteiroEmpresa[2];
			String numeroLote = (String) dadosMovimentoRoteiroEmpresa[3];
			String numeroSubLote = (String) dadosMovimentoRoteiroEmpresa[4];
			Integer idTipoMedicao = (Integer) dadosMovimentoRoteiroEmpresa[5];
			Integer matriculaImovel = (Integer) dadosMovimentoRoteiroEmpresa[6];
			Integer idPerfilImovel = (Integer) dadosMovimentoRoteiroEmpresa[7];
			String nomeCliente = (String) dadosMovimentoRoteiroEmpresa[8];
			String enderecoImovel = (String) dadosMovimentoRoteiroEmpresa[9];
			Integer idMarcaHidrometro = (Integer) dadosMovimentoRoteiroEmpresa[10];
			String numeroHidrometro = (String) dadosMovimentoRoteiroEmpresa[11];
			Integer idCapacidadeHidrometro = (Integer) dadosMovimentoRoteiroEmpresa[12];
			Integer idLocalInstalacaoHidrometro = (Integer) dadosMovimentoRoteiroEmpresa[13];
			Date dataInstalacaoHidrometro = (Date) dadosMovimentoRoteiroEmpresa[14];
			Integer idProtecaoHidrometro = (Integer) dadosMovimentoRoteiroEmpresa[15];
			Integer idSituacaoLigacaoAgua = (Integer) dadosMovimentoRoteiroEmpresa[16];
			Integer idSituacaoLigacaoEsgoto = (Integer) dadosMovimentoRoteiroEmpresa[17];
			String descricaoAbreviadaCategoriaImovel = (String) dadosMovimentoRoteiroEmpresa[18];
			Short quantidadeEconomia = (Short) dadosMovimentoRoteiroEmpresa[19];
			Integer numeroLeituraAnterior = (Integer) dadosMovimentoRoteiroEmpresa[20];
			Integer numeroFaixaLeituraEsperadaInicial = (Integer) dadosMovimentoRoteiroEmpresa[21];
			Integer numeroFaixaLeituraEsperadaFinal = (Integer) dadosMovimentoRoteiroEmpresa[22];
			Integer idFaturamentoGrupo = faturamentoGrupo.getId();

			/*
			 * Alteração feita para incluir o código da rota, sequencial de rota
			 * e a matrícula do funcionario no arquivo gerado para a leitura.
			 * Thiago Nascimento 01/04/2008
			 */
			Integer matriculaFuncionario = null;
			Short codigoRota = null;
			Integer sequencialRota = null;
			if (sistemaParametro.getIndicadorRoteiroEmpresa().equals(
					ConstantesSistema.SIM)) {
				matriculaFuncionario = (Integer) dadosMovimentoRoteiroEmpresa[23];
			} else {
				codigoRota = (Short) dadosMovimentoRoteiroEmpresa[23];
				sequencialRota = (Integer) dadosMovimentoRoteiroEmpresa[24];
				matriculaFuncionario = (Integer) dadosMovimentoRoteiroEmpresa[25];
			}

			// caso a datade instalação do hidrômetro estiver nula
			// adiciona zeros no lugar
			String dataInstalacaoHidrometroFormatada = "";
			if (dataInstalacaoHidrometro == null) {
				dataInstalacaoHidrometroFormatada = "000000";
			} else {
				dataInstalacaoHidrometroFormatada = Util.formatarDataSemBarra(
						dataInstalacaoHidrometro).substring(2);
			}

			// caso o tipo de medição não tenha sido informada atribui 0(zero)
			if (idTipoMedicao == null) {
				idTipoMedicao = 0;
			}

			// caso o nome do cliente não for informado adicionar espaços em
			// branco
			if (nomeCliente == null) {
				nomeCliente = "";
			}

			// caso o endereço do imóvel não for informado adicionar espaços em
			// branco
			if (enderecoImovel == null) {
				enderecoImovel = "";
			}

			// caso a marca do hidrômetro não for informada
			// adicionar espaço em braco , caso contrário
			// informar o id da marca do hidrômetro
			String marcaHidrometro = null;
			// Obs: Vai ficar com 1 digito por enquanto
			// depois ira mudar para dois digitos
			if (idMarcaHidrometro == null) {
				marcaHidrometro = "  ";
			} else {
				marcaHidrometro = (Util.adicionarZerosEsquedaNumeroTruncando(2,
						idMarcaHidrometro + ""));

			}

			/*
			 * if (idMarcaHidrometro == null) { marcaHidrometro = " "; } else {
			 * marcaHidrometro = Util.adicionarZerosEsquedaNumero(2,
			 * idMarcaHidrometro+ ""); }
			 */
			// caso o número do hidrômetro não for informado
			// adicionar espaço em braco , caso contrário
			// informar o id o número do hidrômetro
			String numeroHidrometroFormatado = null;
			if (numeroHidrometro == null || numeroHidrometro.trim().equals("")) {
				numeroHidrometroFormatado = "          ";
			} else {
				numeroHidrometroFormatado = Util
						.adicionarZerosEsquedaNumeroTruncando(10,
								numeroHidrometro);
				/*
				 * Alterado para o numero de hidrometro não passar de 10 dígitos
				 * Thiago Nascimento
				 */
				numeroHidrometroFormatado = numeroHidrometroFormatado
						.substring(0, 10);

			}

			// caso a capacidade do hidrômetro não for informada
			// adicionar espaço em braco , caso contrário
			// informar o id da capacidade do hidrômetro
			String capacidadeHidrometro = null;
			if (idCapacidadeHidrometro == null) {
				capacidadeHidrometro = "  ";
			} else {
				capacidadeHidrometro = Util
						.adicionarZerosEsquedaNumeroTruncando(2,
								idCapacidadeHidrometro.toString());
			}

			// caso local de instalação do hidrômetro não for informado
			// adicionar espaço em braco , caso contrário
			// informar o id do local da instalação do hidrômetro
			String localInstalacaoHidrometro = null;
			if (idLocalInstalacaoHidrometro == null) {
				localInstalacaoHidrometro = "  ";
			} else {
				localInstalacaoHidrometro = Util
						.adicionarZerosEsquedaNumeroTruncando(2,
								idLocalInstalacaoHidrometro.toString());
			}

			// caso a proteção do hidrômetro não for informada
			// adicionar espaço em braco , caso contrário
			// informar o id da proteção do hidrômetro
			String protecaoInstalacaoHidrometro = null;
			if (idProtecaoHidrometro == null) {
				protecaoInstalacaoHidrometro = "  ";
			} else {
				protecaoInstalacaoHidrometro = Util
						.adicionarZerosEsquedaNumeroTruncando(2,
								idProtecaoHidrometro.toString());
			}

			/*
			 * Alterado por Thiago Nascimento data: 17/06/2008
			 */
			String situacaoLigAgua = "  ";
			if (idSituacaoLigacaoAgua != null) {
				situacaoLigAgua = Util.adicionarZerosEsquedaNumeroTruncando(2,
						idSituacaoLigacaoAgua.toString());
			}

			String situacaoLigEsgoto = "  ";
			if (idSituacaoLigacaoEsgoto != null) {
				situacaoLigEsgoto = Util.adicionarZerosEsquedaNumeroTruncando(
						2, idSituacaoLigacaoEsgoto.toString());
			}

			// caso a descrição abreviada da categoria do imóvel não for
			// informada
			// adicionar espaço em braco
			if (descricaoAbreviadaCategoriaImovel == null) {
				descricaoAbreviadaCategoriaImovel = "";
			}

			// caso a quantidade de economias não for informada
			// informar zero
			if (quantidadeEconomia == null) {
				quantidadeEconomia = 0;
			}

			// caso o nº da leitura anterior não for informada
			// informar zero
			// caso contrario criptografar a leitura anterior
			String leituraAnteriorCriptografada = null;
			if (numeroLeituraAnterior == null) {
				leituraAnteriorCriptografada = Criptografia.encrypt("000000");
			} else {
				leituraAnteriorCriptografada = Criptografia.encrypt(Util
						.adicionarZerosEsquedaNumeroTruncando(6,
								numeroLeituraAnterior + ""));
			}

			// caso o nº de faixa leitura esperada inicial
			// não for informada, informar zero
			String numeroFaixaLeituraEsperadaInicialCriptografada = null;
			if (numeroFaixaLeituraEsperadaInicial == null) {
				numeroFaixaLeituraEsperadaInicialCriptografada = Criptografia
						.encrypt("000000");
			} else {
				numeroFaixaLeituraEsperadaInicialCriptografada = Criptografia
						.encrypt(Util.adicionarZerosEsquedaNumeroTruncando(6,
								numeroFaixaLeituraEsperadaInicial + ""));
			}

			// caso o nº de faixa leitura esperada final
			// não for informada, informar zero
			String numeroFaixaLeituraEsperadaFinalCriptografada = null;

			if (numeroFaixaLeituraEsperadaFinal == null) {
				numeroFaixaLeituraEsperadaFinalCriptografada = Criptografia
						.encrypt("000000");
			} else {
				numeroFaixaLeituraEsperadaFinalCriptografada = Criptografia
						.encrypt(Util.adicionarZerosEsquedaNumeroTruncando(6,
								numeroFaixaLeituraEsperadaFinal + ""));
			}

			// adiciona as informações no txt
			arquivoRoteiroEmpresa
					.append(Util.adicionarZerosEsquedaNumeroTruncando(3,
							idLocalidade + ""));
			arquivoRoteiroEmpresa.append(Util
					.adicionarZerosEsquedaNumeroTruncando(3,
							codigoSetorComercial + ""));
			arquivoRoteiroEmpresa
					.append(Util.adicionarZerosEsquedaNumeroTruncando(3,
							numeroQuadra + ""));
			arquivoRoteiroEmpresa.append(Util
					.adicionarZerosEsquedaNumeroTruncando(4, numeroLote));
			arquivoRoteiroEmpresa.append(Util
					.adicionarZerosEsquedaNumeroTruncando(3, numeroSubLote));
			arquivoRoteiroEmpresa.append(idTipoMedicao);
			arquivoRoteiroEmpresa.append(Util
					.adicionarZerosEsquedaNumeroTruncando(2, idFaturamentoGrupo
							+ ""));
			arquivoRoteiroEmpresa.append(Util
					.adicionarZerosEsquedaNumeroTruncando(8, matriculaImovel
							+ ""));
			arquivoRoteiroEmpresa.append(idPerfilImovel);
			arquivoRoteiroEmpresa.append(Util.completaString(nomeCliente, 25));
			arquivoRoteiroEmpresa.append(Util
					.completaString(enderecoImovel, 50));
			arquivoRoteiroEmpresa.append(marcaHidrometro);
			arquivoRoteiroEmpresa.append(numeroHidrometroFormatado);
			arquivoRoteiroEmpresa.append(capacidadeHidrometro);
			arquivoRoteiroEmpresa.append(localInstalacaoHidrometro);
			arquivoRoteiroEmpresa.append(dataInstalacaoHidrometroFormatada);
			arquivoRoteiroEmpresa.append(protecaoInstalacaoHidrometro);
			arquivoRoteiroEmpresa.append(situacaoLigAgua);
			arquivoRoteiroEmpresa.append(situacaoLigEsgoto);
			arquivoRoteiroEmpresa.append(Util.completaString(
					descricaoAbreviadaCategoriaImovel, 3));
			arquivoRoteiroEmpresa.append(Util
					.adicionarZerosEsquedaNumeroTruncando(3, quantidadeEconomia
							+ ""));
			arquivoRoteiroEmpresa.append(leituraAnteriorCriptografada);
			arquivoRoteiroEmpresa
					.append(numeroFaixaLeituraEsperadaInicialCriptografada);
			arquivoRoteiroEmpresa
					.append(numeroFaixaLeituraEsperadaFinalCriptografada);
			/*
			 * Alteração feita para incluir o código da rota, sequencial de rota
			 * e a matrícula do funcionario no arquivo gerado para a leitura.
			 * Thiago Nascimento 01/04/2008
			 */
			if (!sistemaParametro.getIndicadorRoteiroEmpresa().equals(
					ConstantesSistema.SIM)) {
				if (codigoRota != null) {
					arquivoRoteiroEmpresa.append(Util
							.adicionarZerosEsquedaNumeroTruncando(6,
									codigoRota.toString()));
				} else {
					arquivoRoteiroEmpresa.append("000000");
				}
				if (sequencialRota != null) {
					arquivoRoteiroEmpresa.append(Util
							.adicionarZerosEsquedaNumeroTruncando(4,
									sequencialRota.toString()));
				} else {
					arquivoRoteiroEmpresa.append("0000");
				}
			}
			if (matriculaFuncionario != null) {
				arquivoRoteiroEmpresa.append(Util
						.adicionarZerosEsquedaNumeroTruncando(8,
								matriculaFuncionario.toString()));
			} else {
				arquivoRoteiroEmpresa.append("00000000");
			}

			arquivoRoteiroEmpresa.append(System.getProperty("line.separator"));

			// incrementa a quantidade de imoveis
			qtdImoveis++;

			// caso seja a primeira vez
			if (primeiraVez) {
				primeiraVez = false;
				menorQuadra[cont - 1] = numeroQuadra;
				maiorQuadra[cont - 1] = numeroQuadra;

				mapSetorComercial.put(cont, codigoSetorComercial);
				// mapQuadraInicial.put(cont, numeroQuadra);

				idLocalidadePrimeiroImovel = idLocalidade;
				setorComercialTemp = codigoSetorComercial;

				// caso só exista um único registro a quadra final
				// sera a mesma que a inicial.
				if (colecaoDadosMovimentoRoteiroEmpresa.size() == 1) {
					mapQuadraInicial.put(cont, numeroQuadra);
					mapQuadraFinal.put(cont, numeroQuadra);
				}

			} else {

				// caso o setor comercial tenha mudado
				if (!setorComercialTemp.equals(codigoSetorComercial)) {
					mapSetorComercial.put(cont + 1, codigoSetorComercial);
					mapQuadraInicial.put(cont, menorQuadra[cont - 1]);
					mapQuadraFinal.put(cont, maiorQuadra[cont - 1]);
					// mapQuadraInicial.put(cont + 1, numeroQuadra);
					cont++;
					menorQuadra[cont - 1] = numeroQuadra;
					maiorQuadra[cont - 1] = numeroQuadra;
					setorComercialTemp = codigoSetorComercial;
				} else {

					if (menorQuadra[cont - 1] > numeroQuadra) {
						menorQuadra[cont - 1] = numeroQuadra;
					} else if (maiorQuadra[cont - 1] < numeroQuadra) {
						maiorQuadra[cont - 1] = numeroQuadra;
					}

				}
			}

			// armazena a quadra anterior para utilizar como a quadra final do
			// setor comercial
			// idQuadraAnterior = numeroQuadra;
		}

		// caso o o ultimo setor comercial ainda não estiver com a quadra final
		if (mapSetorComercial.get(cont) != null) {
			mapQuadraInicial.put(cont, menorQuadra[cont - 1]);
			mapQuadraFinal.put(cont, maiorQuadra[cont - 1]);
		}

		/*
		 * Recupera os setores comerciais e as quadras inicial e final
		 * dependendo da quantidade inserida no map.
		 */
		if (mapSetorComercial.size() == 1) {
			codigoSetorComercial1 = mapSetorComercial.get(1);
			numeroQuadraInicial1 = mapQuadraInicial.get(1);
			numeroQuadraFinal1 = mapQuadraFinal.get(1);

			codigoSetorComercial2 = null;
			numeroQuadraInicial2 = null;
			numeroQuadraFinal2 = null;

			codigoSetorComercial3 = null;
			numeroQuadraInicial3 = null;
			numeroQuadraFinal3 = null;

		} else if (mapSetorComercial.size() == 2) {
			codigoSetorComercial1 = mapSetorComercial.get(1);
			numeroQuadraInicial1 = mapQuadraInicial.get(1);
			numeroQuadraFinal1 = mapQuadraFinal.get(1);

			codigoSetorComercial2 = mapSetorComercial.get(2);
			numeroQuadraInicial2 = mapQuadraInicial.get(2);
			numeroQuadraFinal2 = mapQuadraFinal.get(2);

			codigoSetorComercial3 = null;
			numeroQuadraInicial3 = null;
			numeroQuadraFinal3 = null;

		} else if (mapSetorComercial.size() == 3) {
			codigoSetorComercial1 = mapSetorComercial.get(1);
			numeroQuadraInicial1 = mapQuadraInicial.get(1);
			numeroQuadraFinal1 = mapQuadraFinal.get(1);

			codigoSetorComercial2 = mapSetorComercial.get(2);
			numeroQuadraInicial2 = mapQuadraInicial.get(2);
			numeroQuadraFinal2 = mapQuadraFinal.get(2);

			codigoSetorComercial3 = mapSetorComercial.get(3);
			numeroQuadraInicial3 = mapQuadraInicial.get(3);
			numeroQuadraFinal3 = mapQuadraFinal.get(3);
		}

		// armazena os dados necessarios para inserir o
		// ArquivoTextoParaRoteiroEmpresa
		// no array de retorno.
		dadosRoteiroEmpresa[0] = arquivoRoteiroEmpresa;
		dadosRoteiroEmpresa[1] = codigoSetorComercial1;
		dadosRoteiroEmpresa[2] = numeroQuadraInicial1;
		dadosRoteiroEmpresa[3] = numeroQuadraFinal1;
		dadosRoteiroEmpresa[4] = codigoSetorComercial2;
		dadosRoteiroEmpresa[5] = numeroQuadraInicial2;
		dadosRoteiroEmpresa[6] = numeroQuadraFinal2;
		dadosRoteiroEmpresa[7] = codigoSetorComercial3;
		dadosRoteiroEmpresa[8] = numeroQuadraInicial3;
		dadosRoteiroEmpresa[9] = numeroQuadraFinal3;
		dadosRoteiroEmpresa[10] = qtdImoveis;
		dadosRoteiroEmpresa[11] = idLocalidadePrimeiroImovel;

		return dadosRoteiroEmpresa;
	}

	/**
	 * [UC0627] Gerar Arquivo Texto para Leituristas
	 * 
	 * Gera o nome do arquivo texto para o roteiro empresa.
	 * 
	 * [FS0003] Nome do arquivo texto
	 * 
	 * @author Pedro Alexandre
	 * @date 06/08/2007
	 * 
	 * @param idLocalidade
	 * @param idFaturamentoGrupo
	 * @param sequencial
	 * @return
	 * @throws ControladorException
	 */
	private String gerarNomeArquivoTextoParaRoteiroEmpresa(
			Integer idLocalidade, Integer codigoSetorComercial,
			Short codigoRota, Integer idFaturamentoGrupo, Integer anoMes)
			throws ControladorException {

		// variável que vai armazenar o nome do arquivo gerado.
		String nomeArquivo = null;

		/*
		 * concatena o nome do arquivo com : G - letra "G" fixo FF - ftgr_id id
		 * do grupo de faturamento LLL - loca_id do 1º imóvel SSS - stcm_id dp
		 * 1º imóvel RRRR - rota_cdrota AAAAMM - ano/mês referencia do
		 * faturamento
		 */

		nomeArquivo =

		"G"
				+ Util.adicionarZerosEsquedaNumero(3, idFaturamentoGrupo + "")
				+ Util.adicionarZerosEsquedaNumero(3, idLocalidade + "")
				+ Util.adicionarZerosEsquedaNumero(3, codigoSetorComercial + "");

		if (codigoRota != null) {
			nomeArquivo = nomeArquivo
					+ Util.adicionarZerosEsquedaNumero(4, codigoRota + "");
		}

		nomeArquivo = nomeArquivo + anoMes + "" + ".txt";

		return nomeArquivo;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0005] Gerar Relação(ROL) em TXT - CAER
	 * 
	 * @author Sávio Luiz
	 * @date 13/08/2007
	 * 
	 * @param idRota
	 * @param idLeituraTipo
	 * 
	 * @throws ErroRepositorioException
	 */
	protected boolean gerarRelacaoTxt(StringBuilder arquivoTxtLinha,
			Object[] arrayImoveisPorRota, Integer anoMesCorrente,
			boolean hidrometroSelecionado, SistemaParametro sistemaParametro) {

		boolean ligacaoAgua = false;
		boolean ligacaoPoco = false;
		Imovel imovelParaSerGerado = new Imovel();
		Short numeroDigitosHidrometro = null;
		StringBuilder dadosHidrometro = new StringBuilder();
		StringBuilder arquivoTxtLinhaAux = new StringBuilder();
		// parte que coloca alguma dado para não entrar eu uma situação não
		// desejada do metodo pesquisarFaixaEsperadaOuFalsa
		dadosHidrometro.append("Qualquer dado");

		Object[] dadosLinhaTxtHidSelecionaldo = new Object[2];

		try {

			if (arrayImoveisPorRota != null) {
				arquivoTxtLinhaAux.append(System.getProperty("line.separator"));
				// id do imovel
				if (arrayImoveisPorRota[0] != null) {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							7, "" + (Integer) arrayImoveisPorRota[0]));
					imovelParaSerGerado.setId((Integer) arrayImoveisPorRota[0]);

				} else {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							7, ""));
				}

				// id da rota
				if (arrayImoveisPorRota[1] != null) {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							4, "" + arrayImoveisPorRota[1]));
					Rota rota = new Rota();
					rota.setId((Integer) arrayImoveisPorRota[1]);
					rota.setCodigo((Short) arrayImoveisPorRota[18]);
					if (arrayImoveisPorRota[15] != null) {
						rota.setPercentualGeracaoFaixaFalsa((BigDecimal) arrayImoveisPorRota[15]);
					}
					Quadra quadra = new Quadra();
					quadra.setRota(rota);
					imovelParaSerGerado.setQuadra(quadra);
				} else {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							4, ""));
				}

				// numero quadra
				if (arrayImoveisPorRota[2] != null) {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							4, "" + arrayImoveisPorRota[2]));
				} else {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							4, ""));
				}

				// lote do imovel
				if (arrayImoveisPorRota[3] != null) {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							3, "" + arrayImoveisPorRota[3]));
				} else {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							3, ""));
				}

				// situação de ligação de agua
				if (arrayImoveisPorRota[4] != null) {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							3, "" + arrayImoveisPorRota[4]));
				} else {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							3, ""));
				}

				// id logradouro
				if (arrayImoveisPorRota[5] != null) {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							4, "" + arrayImoveisPorRota[5]));
				} else {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							4, ""));
				}

				// nome logradouro
				if (arrayImoveisPorRota[6] != null) {
					String logradouroCompleto = "";

					// descrição abreviado tipo
					if (arrayImoveisPorRota[17] != null) {
						logradouroCompleto += "" + arrayImoveisPorRota[17];
					}
					// descrição abreviado titulo
					if (arrayImoveisPorRota[16] != null) {
						logradouroCompleto += "" + arrayImoveisPorRota[16];
					}

					logradouroCompleto += "" + arrayImoveisPorRota[6];

					arquivoTxtLinhaAux.append(Util.completaString(
							logradouroCompleto, 25));

				} else {
					arquivoTxtLinhaAux.append(Util.completaString("", 25));
				}

				// numero do imovel
				if (arrayImoveisPorRota[7] != null) {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							5, "" + arrayImoveisPorRota[7]));
				} else {
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(
							5, ""));
				}

				// complemento do imovel
				if (arrayImoveisPorRota[8] != null) {
					arquivoTxtLinhaAux.append(Util.completaString(""
							+ arrayImoveisPorRota[8], 3));
				} else {
					arquivoTxtLinhaAux.append(Util.completaString("", 3));
				}

				String numeroHidrometroAgua = null;
				String numeroHidrometroPoco = null;

				// medição tipo Agua
				if (arrayImoveisPorRota[9] != null) {
					ligacaoAgua = true;
					if (arrayImoveisPorRota[10] != null) {
						numeroHidrometroAgua = "" + arrayImoveisPorRota[10];
						numeroDigitosHidrometro = (Short) arrayImoveisPorRota[11];
					}
				}

				// medição tipo Poco
				if (arrayImoveisPorRota[12] != null) {
					ligacaoPoco = true;
					if (arrayImoveisPorRota[13] != null) {
						numeroHidrometroPoco = "" + arrayImoveisPorRota[13];
						numeroDigitosHidrometro = (Short) arrayImoveisPorRota[14];
					}
				}

				// caso sela ligacao de agua e ligação de esgoto então é gerado
				// 2 linhas
				Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);
				if (ligacaoAgua && ligacaoPoco) {
					Object[] dadosAuxSegundaParte = retornaDadosFaixa(
							anoMesAnterior, imovelParaSerGerado, ligacaoAgua,
							ligacaoPoco, hidrometroSelecionado,
							dadosHidrometro, sistemaParametro,
							numeroDigitosHidrometro);
					StringBuilder arquivoTxtAuxSegundaParte = (StringBuilder) dadosAuxSegundaParte[0];
					hidrometroSelecionado = (Boolean) dadosAuxSegundaParte[1];
					arquivoTxtLinha.append(arquivoTxtLinhaAux);
					if (numeroHidrometroAgua != null) {
						arquivoTxtLinha.append(Util.completaString(""
								+ numeroHidrometroAgua, 10));
					} else {
						arquivoTxtLinha.append(Util.completaString("", 10));
					}
					arquivoTxtLinha.append(arquivoTxtAuxSegundaParte);
					// faz a segunda parte com ligação agua igual a false, pois
					// quando os 2 são true ele pega os dados de ligação agua.
					ligacaoAgua = false;

					// cria outra linha com os dados de ligação esgoto
					dadosAuxSegundaParte = retornaDadosFaixa(anoMesAnterior,
							imovelParaSerGerado, ligacaoAgua, ligacaoPoco,
							hidrometroSelecionado, dadosHidrometro,
							sistemaParametro, numeroDigitosHidrometro);
					arquivoTxtAuxSegundaParte = (StringBuilder) dadosAuxSegundaParte[0];
					hidrometroSelecionado = (Boolean) dadosAuxSegundaParte[1];
					arquivoTxtLinha.append(arquivoTxtLinhaAux);
					if (numeroHidrometroPoco != null) {
						arquivoTxtLinha.append(Util.completaString(""
								+ numeroHidrometroPoco, 10));
					} else {
						arquivoTxtLinha.append(Util.completaString("", 10));
					}

					arquivoTxtLinha.append(arquivoTxtAuxSegundaParte);

				} else {
					Object[] dadosAuxSegundaParte = retornaDadosFaixa(
							anoMesAnterior, imovelParaSerGerado, ligacaoAgua,
							ligacaoPoco, hidrometroSelecionado,
							dadosHidrometro, sistemaParametro,
							numeroDigitosHidrometro);
					StringBuilder arquivoTxtAuxSegundaParte = (StringBuilder) dadosAuxSegundaParte[0];
					hidrometroSelecionado = (Boolean) dadosAuxSegundaParte[1];
					arquivoTxtLinha.append(arquivoTxtLinhaAux);
					if (ligacaoAgua) {
						if (numeroHidrometroAgua != null) {
							arquivoTxtLinha.append(Util.completaString(""
									+ numeroHidrometroAgua, 10));
						} else {
							arquivoTxtLinha.append(Util.completaString("", 10));
						}
					} else {
						if (numeroHidrometroPoco != null) {
							arquivoTxtLinha.append(Util.completaString(""
									+ numeroHidrometroPoco, 10));
						} else {
							arquivoTxtLinha.append(Util.completaString("", 10));
						}
					}
					arquivoTxtLinha.append(arquivoTxtAuxSegundaParte);

				}

			}

		} catch (Exception e) { // Este catch serve para interceptar
			e.printStackTrace();

			throw new EJBException(e);
		}
		dadosLinhaTxtHidSelecionaldo[0] = arquivoTxtLinha;
		dadosLinhaTxtHidSelecionaldo[1] = hidrometroSelecionado;

		return hidrometroSelecionado;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0005] Gerar Relação(ROL) em TXT - CAER
	 * 
	 * @author Sávio Luiz
	 * @date 13/08/2007
	 * 
	 * @param idRota
	 * @param idLeituraTipo
	 * 
	 * @throws ErroRepositorioException
	 */
	protected Object[] retornaDadosFaixa(Integer anoMesAnterior,
			Imovel imovelParaSerGerado, boolean ligacaoAgua,
			boolean ligacaoPoco, boolean hidrometroSelecionado,
			StringBuilder dadosHidrometro, SistemaParametro sistemaParametro,
			Short numeroDigitosHidrometro) {

		StringBuilder dadosFaixaTxt = new StringBuilder();
		Object[] dadosLinhaTxtHidSelecionaldo = new Object[2];

		try {

			// Leitura anterior

			String leituraAnterior = null;
			Integer idMedicaoTipo = null;
			MedicaoHistorico medicaoHistorico = null;
			Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua,
					ligacaoPoco, anoMesAnterior, imovelParaSerGerado);
			// verifica se a leitura anterior é diferente de nula
			if (retorno[0] != null) {
				leituraAnterior = retorno[0].toString();
			}
			// verifica se a leitura situação atual é diferente de
			// nula
			if (retorno[1] != null) {
				medicaoHistorico = (MedicaoHistorico) retorno[1];
			}
			// verifica se o id da medição tipo é diferente de nula
			if (retorno[2] != null) {
				idMedicaoTipo = (Integer) retorno[2];
			}

			// leitura minima
			// Faixa de leitura esperada

			Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(
					imovelParaSerGerado, dadosHidrometro, leituraAnterior,
					medicaoHistorico, idMedicaoTipo, sistemaParametro,
					hidrometroSelecionado, numeroDigitosHidrometro);

			StringBuilder faixaInicialFinalString = (StringBuilder) faixaInicialFinal[0];
			hidrometroSelecionado = Boolean.parseBoolean(faixaInicialFinal[1]
					.toString());

			boolean faixaFalsaLeitura = Boolean
					.parseBoolean(faixaInicialFinal[2].toString());

			int faixaInicialEsperada = 0;
			int faixaFinalEsperada = 0;
			if (faixaFalsaLeitura) {
				faixaInicialEsperada = Integer.parseInt(faixaInicialFinal[3]
						.toString());

				faixaFinalEsperada = Integer.parseInt(faixaInicialFinal[4]
						.toString());

				dadosFaixaTxt.append(Util.adicionarZerosEsquedaNumero(7, ""
						+ faixaInicialEsperada));
				// leitura maxima
				dadosFaixaTxt.append(Util.adicionarZerosEsquedaNumero(7, ""
						+ faixaFinalEsperada));
			} else {
				dadosFaixaTxt.append(Util.adicionarZerosEsquedaNumero(14, ""
						+ faixaInicialFinalString));
			}

			// zeros
			dadosFaixaTxt.append(Util.adicionarZerosEsquedaNumero(30, ""));
		} catch (Exception e) { // Este catch serve para interceptar
			e.printStackTrace();

			throw new EJBException(e);
		}
		dadosLinhaTxtHidSelecionaldo[0] = dadosFaixaTxt;
		dadosLinhaTxtHidSelecionaldo[1] = hidrometroSelecionado;
		return dadosLinhaTxtHidSelecionaldo;
	}

	/**
	 * Pesquisa os roteiros empresa de acordo com os parâmetros informado pelo
	 * usuário
	 * 
	 * [UC0370] - Filtrar Roteiro Empresa
	 * 
	 * @author Thiago Tenório
	 * @date 29/08/2007
	 * 
	 * @param empresa
	 * @param idLocalidade
	 * @param idLeiturista
	 * @param idSetorComercial
	 * @param indicadorUso
	 * @param numeroPagina
	 * @return Collection
	 */
	public Collection pesquisarRoteiroEmpresa(String idEmpresa,
			String idLocalidade, String codigoSetorComercial,
			String idLeiturista, String indicadorUso, Integer numeroPagina)
			throws ControladorException {

		Collection roteiros = new ArrayList();

		try {

			Collection retorno = repositorioMicromedicao
					.pesquisarRoteiroEmpresa(idEmpresa, idLocalidade,
							codigoSetorComercial, idLeiturista, indicadorUso,
							numeroPagina);

			// verifica se a houve algum elemento de retorno
			/*
			 * consulta = "select distinct(re.roem_id) as id, " + //[0] id
			 * roteiro empresa "re.empr_id as empresa, " + // [1] id da empresa
			 * "emp.empr_nmempresa, " + // [2] nome da empresa "loc.loca_id, " +
			 * // [3] id da localidade "loc.loca_nmlocalidade, " + // [4] nome
			 * da localidade "re.leit_id as leit, " + // [5] id leiturista
			 * "cli.clie_nmcliente, " + // [6] nome do cliente
			 * "func.func_nmfuncionario, " + // [7] nome do funcionario
			 * "sc.stcm_cdsetorcomercial " + // [8] Código setor comercial
			 */
			if (retorno != null && !retorno.isEmpty()) {
				Iterator iteratorRetorno = retorno.iterator();
				while (iteratorRetorno.hasNext()) {
					Object[] dadosRetorno = (Object[]) iteratorRetorno.next();
					RoteiroEmpresaHelper roteiroEmpresaHelper = new RoteiroEmpresaHelper();
					roteiroEmpresaHelper
							.setIdRoteiroEmpresa((Integer) dadosRetorno[0]);
					roteiroEmpresaHelper
							.setIdEmpresa((Integer) dadosRetorno[1]);
					roteiroEmpresaHelper
							.setNomeEmpresa((String) dadosRetorno[2]);
					roteiroEmpresaHelper
							.setIdLocalidade((Integer) dadosRetorno[3]);
					roteiroEmpresaHelper
							.setNomeLocalidade((String) dadosRetorno[4]);
					if (dadosRetorno[7] != null) {
						roteiroEmpresaHelper
								.setNomeLeiturista((String) dadosRetorno[7]);
					} else {
						roteiroEmpresaHelper
								.setNomeLeiturista((String) dadosRetorno[6]);
					}
					roteiroEmpresaHelper
							.setCodigoSetorComercial((Integer) dadosRetorno[8]);
					roteiros.add(roteiroEmpresaHelper);
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return roteiros;

	}

	/**
	 * Verifica a quantidade de registros retornados da pesquisa de equipe
	 * 
	 * [UC0370] - Filtrar Equipe
	 * 
	 * @author Rafael Corrêa
	 * @date 09/11/06
	 * 
	 * @param idEquipe
	 * @param nome
	 * @param placa
	 * @param cargaTrabalho
	 * @param idUnidade
	 * @param idFuncionario
	 * @param idPerfilServico
	 * @param indicadorUso
	 * @return int
	 */
	public int pesquisarRoteiroEmpresaCount(String idEmpresa,
			String idLocalidade, String codigoSetorComercial,
			String idLeiturista, String indicadorUso)
			throws ControladorException {

		int retorno = 0;

		try {

			retorno = repositorioMicromedicao.pesquisarRoteiroEmpresaCount(
					idEmpresa, idLocalidade, codigoSetorComercial,
					idLeiturista, indicadorUso);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0005] Gerar Relação(ROL) em TXT - CAER
	 * 
	 * @author Sávio Luiz
	 * @date 24/08/2007
	 * 
	 * @param idRota
	 * @param idLeituraTipo
	 * 
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosLocalProtecaoTipoLigacaoAgua(Integer idImovel)
			throws ControladorException {

		Object[] dados = null;
		try {
			dados = repositorioMicromedicao
					.pesquisarDadosLocalProtecaoTipoLigacaoAgua(idImovel);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return dados;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0005] Gerar Relação(ROL) em TXT - CAER
	 * 
	 * @author Sávio Luiz
	 * @date 24/08/2007
	 * 
	 * @param idRota
	 * @param idLeituraTipo
	 * 
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosLocalProtecaoTipoTipoPoco(Integer idImovel)
			throws ControladorException {
		Object[] dados = null;
		try {
			dados = repositorioMicromedicao
					.pesquisarDadosLocalProtecaoTipoTipoPoco(idImovel);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return dados;
	}

	/**
	 * [UC0631] Processar Requisições do Dispositivo Móvel.
	 * 
	 * [SB0001] Baixar Arquivo Texto para o Leiturista.
	 * 
	 * 
	 * @author Bruno Barros
	 * @date 14/08/2007
	 * 
	 * @param imei
	 * @return
	 * @throws ControladorException
	 */
	public byte[] baixarArquivoTextoParaLeitura(long imei,
			Integer idServicoTipoCelular) throws ControladorException {
		try {
			Object[] retorno = this.repositorioMicromedicao
					.baixarArquivoTextoParaLeitura(imei, idServicoTipoCelular);

			// Atualizamos os registro, informando que o arquivo está em campo
			// if ( retorno[1] != null ){
			// ArquivoTextoRoteiroEmpresa are = ( ArquivoTextoRoteiroEmpresa
			// )retorno[1];
			//
			// SituacaoTransmissaoLeitura stl = new
			// SituacaoTransmissaoLeitura();
			// stl.setId( SituacaoTransmissaoLeitura.EM_CAMPO );
			// are.setSituacaoTransmissaoLeitura( stl );
			// are.setUltimaAlteracao( new Date() );
			// repositorioUtil.atualizar( are );
			// }

			return (byte[]) retorno[0];
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0631] Processar Requisições do Dispositivo Móvel.
	 * 
	 * Atualizar Situação do Arquivo Texto.
	 * 
	 * 
	 * @author Thiago Nascimento
	 * @date 14/08/2007
	 * 
	 * @param imei
	 * @param situacaoAnterior
	 * @param situacaoNova
	 * @throws ControladorException
	 */
	@Deprecated
	public void atualizarArquivoTextoEnviado(long imei, int situacaoAnterior,
			int situacaoNova) throws ControladorException {
		try {
			this.repositorioMicromedicao.atualizarArquivoTextoEnviado(imei,
					situacaoAnterior, situacaoNova);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0631] Processar Requisições do Dispositivo Móvel.
	 * 
	 * Atualizar Situação do Arquivo Texto.
	 * 
	 * 
	 * @author Thiago Nascimento
	 * @date 14/08/2007
	 * 
	 * @param idRota
	 * @param situacaoAnterior
	 * @param situacaoNova
	 * @throws ControladorException
	 */
	public void atualizarArquivoTextoEnviadoPorRota(Integer idRota,
			int situacaoAnterior, int situacaoNova) throws ControladorException {
		try {
			this.repositorioMicromedicao.atualizarArquivoTextoEnviadoPorRota(
					idRota, situacaoAnterior, situacaoNova);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0631] Processar Requisições do Dispositivo Móvel.
	 * 
	 * Atualizar Situação do Arquivo Texto.
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 05/04/2010
	 * 
	 * @param imei
	 * @param situacaoAnterior
	 * @param situacaoNova
	 * @throws ErroRepositorioException
	 */
	public void atualizarArquivoTextoMenorSequencialLeitura(long imei,
			int situacaoAnterior, int situacaoNova, int idServicoTipoCelular)
			throws ControladorException {
		try {
			this.repositorioMicromedicao
					.atualizarArquivoTextoMenorSequencialLeitura(imei,
							situacaoAnterior, situacaoNova,
							idServicoTipoCelular);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0631] Processar Requisições do Dispositivo Móvel.
	 * 
	 * [SB0002] Atualizar o movimento roteiro empresa.
	 * 
	 * 
	 * @author Thiago Nascimento
	 * @date 14/08/2007
	 * 
	 * @param dados
	 * 
	 * @throws ControladorException
	 */
	public void atualizarRoteiro(Collection<DadosMovimentacao> dados, boolean isCelular) throws ControladorException {
		try {
			FaturamentoGrupo faturamentoGrupo = null;
			Iterator<DadosMovimentacao> it = dados.iterator();
			if (it.hasNext()) {
				
				faturamentoGrupo = this.repositorioMicromedicao.buscarAnoMesReferenciaCasoSistema(it.next().getMatriculaImovel());
			}
			if (faturamentoGrupo != null) {
				this.repositorioMicromedicao.atualizarRoteiro(dados,faturamentoGrupo.getAnoMesReferencia(), isCelular);
			} else {
				throw new ControladorException("erro.sistema");
			}

		} catch (ErroRepositorioException e) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * 
	 * Gerar uma data de realização da atividade efetuar leitura para os imóveis
	 * que não tenha sido efetuado leitura no mês anterior.
	 * 
	 * @author Raphael Rossiter
	 * @data 05/09/2007
	 */
	public Date gerarDataRealizacaoLeituraAnterior(
			FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro)
			throws ControladorException {

		Date dataRealizada = null;

		Object[] cronogramaAtual = obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
				faturamentoGrupo, sistemaParametro.getAnoMesFaturamento());

		Date dataPrevistaLeituraAtual = (Date) cronogramaAtual[0];
		Date dataRealizacaoLeituraAtual = (Date) cronogramaAtual[1];

		/*
		 * Caso exista data de realização da atividade efetuar leitura para o
		 * ano/mês de faturamento da tabela SistemaParametro com o grupo de
		 * faturamento informado:
		 * 
		 * A data de realização será gerada a partir da data de realização atual
		 * menos 30 dias.
		 */
		if (dataRealizacaoLeituraAtual != null) {
			dataRealizada = Util.subtrairNumeroDiasDeUmaData(
					dataRealizacaoLeituraAtual, 30);
		}

		/*
		 * Caso contrário:
		 * 
		 * A data de realização será a data prevista do cronograma atual menos
		 * 30 dias
		 */
		else {

			dataRealizada = Util.subtrairNumeroDiasDeUmaData(
					dataPrevistaLeituraAtual, 30);
		}

		return dataRealizada;
	}

	/**
	 * [UC00082] Registrar Leituras e Anormalidades
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 29/08/2007
	 * 
	 * @param idRota
	 * @param idLeituraTipo
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection<MedicaoHistorico> recuperarMedicoesHistorico(
			Integer idGrupoFaturamento) throws ControladorException {

		Collection<MedicaoHistorico> colecaoMedicaoHistorico = null;
		try {

			Collection<MovimentoRoteiroEmpresa> colecaoMovimentoRoteiroEmpresa = repositorioMicromedicao
					.pesquisarColecaoMovimentoRoteiroEmpresa(idGrupoFaturamento);

			if (colecaoMovimentoRoteiroEmpresa != null
					&& !colecaoMovimentoRoteiroEmpresa.isEmpty()) {

				colecaoMedicaoHistorico = new ArrayList();

				Iterator<MovimentoRoteiroEmpresa> iteMovimentoRoteiroEmpresa = colecaoMovimentoRoteiroEmpresa
						.iterator();

				while (iteMovimentoRoteiroEmpresa.hasNext()) {

					MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
					MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = iteMovimentoRoteiroEmpresa
							.next();

					Imovel imovel = new Imovel();
					LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
					Localidade localidade = new Localidade();
					SetorComercial setorComercial = new SetorComercial();
					Quadra quadra = new Quadra();

					// imovel
					if (movimentoRoteiroEmpresa.getImovel() != null) {

						imovel.setId(movimentoRoteiroEmpresa.getImovel()
								.getId());

						// localidade
						if (movimentoRoteiroEmpresa.getLocalidade() != null) {
							localidade.setId(movimentoRoteiroEmpresa
									.getLocalidade().getId());
						}
						imovel.setLocalidade(localidade);

						// setor comercial
						if (movimentoRoteiroEmpresa.getCodigoSetorComercial() != null) {
							setorComercial.setCodigo(movimentoRoteiroEmpresa
									.getCodigoSetorComercial());
						}
						imovel.setSetorComercial(setorComercial);

						// Quadra
						if (movimentoRoteiroEmpresa.getNumeroQuadra() != null) {
							quadra.setNumeroQuadra(movimentoRoteiroEmpresa
									.getNumeroQuadra());
						}
						imovel.setQuadra(quadra);

						// lote
						if (movimentoRoteiroEmpresa.getNumeroLoteImovel() != null) {
							imovel.setLote(new Short(movimentoRoteiroEmpresa
									.getNumeroLoteImovel().trim()));
						}

						// sublote
						if (movimentoRoteiroEmpresa.getNumeroSubloteImovel() != null) {
							imovel.setSubLote(new Short(movimentoRoteiroEmpresa
									.getNumeroSubloteImovel().trim()));
						}

					}
					medicaoHistorico.setImovel(imovel);

					// medição tipo
					MedicaoTipo medicaoTipo = new MedicaoTipo();
					if (movimentoRoteiroEmpresa.getMedicaoTipo() != null) {
						medicaoTipo.setId(movimentoRoteiroEmpresa
								.getMedicaoTipo().getId());

					}
					medicaoHistorico.setMedicaoTipo(medicaoTipo);

					// leitura do hidrometro
					if (movimentoRoteiroEmpresa.getNumeroLeituraHidrometro() != null) {
						medicaoHistorico
								.setLeituraAtualInformada(movimentoRoteiroEmpresa
										.getNumeroLeituraHidrometro());
					}

					// leitura anormalidade informada
					if (movimentoRoteiroEmpresa.getLeituraAnormalidade() != null) {
						leituraAnormalidade.setId(movimentoRoteiroEmpresa
								.getLeituraAnormalidade().getId());

					}
					medicaoHistorico
							.setLeituraAnormalidadeInformada(leituraAnormalidade);

					// data de leitura
					if (movimentoRoteiroEmpresa.getTempoLeitura() != null) {
						medicaoHistorico.setDataLeituraParaRegistrar(Util
								.formatarDataSemBarra(movimentoRoteiroEmpresa
										.getTempoLeitura()));
					}

					// indicador de leitura
					if (movimentoRoteiroEmpresa
							.getIndicadorConfirmacaoLeitura() != null) {

						medicaoHistorico.setIndicadorConfirmacaoLeitura(""
								+ movimentoRoteiroEmpresa
										.getIndicadorConfirmacaoLeitura());
					}

					colecaoMedicaoHistorico.add(medicaoHistorico);
					medicaoHistorico = null;
				}
			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return colecaoMedicaoHistorico;
	}

	/**
	 * 
	 * @author Vivianne Sousa
	 * @date 06/09/2007
	 * 
	 * @param idImovel
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer obterConsumoMedioEmConsumoHistorico(Integer idImovel,
			Integer idLigacaoTipo) throws ControladorException {
		try {
			return this.repositorioMicromedicao
					.obterConsumoMedioEmConsumoHistorico(idImovel,
							idLigacaoTipo);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Pesquisa os roteiros empresas pelo grupo de faturamento
	 * 
	 * [UC0627] Gerar Arquivo Texto para Leitura
	 * 
	 * @author Pedro Alexandre
	 * @date 13/09/2007
	 * 
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarRoteiroEmpresaPorGrupoFaturamento(
			Integer idFaturamentoGrupo) throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquisarRoteiroEmpresaPorGrupoFaturamento(idFaturamentoGrupo);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0629] Liberar Arquivo Texto para Leitura
	 * 
	 * 
	 * 
	 * @author Thiago Tenório
	 * @date 18/09/2007
	 * 
	 * 
	 * @throws ControladorException
	 */

	public void liberarArquivoTextoLeitura(
			ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa)
			throws ControladorException {

		// Verifica se todos os campos obrigatorios foram preenchidos

		if ((arquivoTextoRoteiroEmpresa.getSituacaoTransmissaoLeitura() == null || arquivoTextoRoteiroEmpresa
				.getSituacaoTransmissaoLeitura().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Situação Texto para Leitura foi preenchido
		if (arquivoTextoRoteiroEmpresa.getSituacaoTransmissaoLeitura() == null
				|| arquivoTextoRoteiroEmpresa.getSituacaoTransmissaoLeitura()
						.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Situação Texto para Leitura");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroArquivoTextoRoteiroEmpresa filtroArquivoTextoRoteiroEmpresa = new FiltroArquivoTextoRoteiroEmpresa();
		filtroArquivoTextoRoteiroEmpresa
				.adicionarParametro(new ParametroSimples(
						FiltroArquivoTextoRoteiroEmpresa.ID,
						arquivoTextoRoteiroEmpresa.getId()));

		Collection colecaoArquivoTextoRoteiroEmpresaBase = getControladorUtil()
				.pesquisar(filtroArquivoTextoRoteiroEmpresa,
						ArquivoTextoRoteiroEmpresa.class.getName());

		if (colecaoArquivoTextoRoteiroEmpresaBase == null
				|| colecaoArquivoTextoRoteiroEmpresaBase.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresaBase = (ArquivoTextoRoteiroEmpresa) colecaoArquivoTextoRoteiroEmpresaBase
				.iterator().next();

		if (arquivoTextoRoteiroEmpresaBase.getUltimaAlteracao().after(
				arquivoTextoRoteiroEmpresa.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		arquivoTextoRoteiroEmpresa.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(arquivoTextoRoteiroEmpresa);

	}

	/**
	 * [UC0298] Manter Leiturista [] Atualizar Leiturista Metodo que atualiza o
	 * Leiturista
	 * 
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * 
	 * 
	 * @throws ControladorException
	 */

	public void atualizarLeiturista(Leiturista leiturista)
			throws ControladorException {

		// Verifica se todos os campos obrigatorios foram preenchidos

		if ((leiturista.getId() == null || leiturista.getId().equals(
				"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leiturista.getFuncionario() == null || leiturista
						.getFuncionario().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leiturista.getEmpresa() == null || leiturista.getEmpresa()
						.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leiturista.getCodigoDDD() == null || leiturista
						.getCodigoDDD().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leiturista.getNumeroFone() == null || leiturista
						.getNumeroFone().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leiturista.getNumeroImei() == null || leiturista
						.getNumeroImei().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Identicador do Funcionario foi
		// preenchido

		if ((leiturista.getFuncionario() == null || leiturista.getFuncionario()
				.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (leiturista.getCliente() == null || leiturista.getCliente()
						.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Funcionario ou Cliente");
		}

		// Verifica se o campo Empresa foi preenchido
		if (leiturista.getEmpresa() == null
				|| leiturista.getEmpresa().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Empresa");
		}

		// Verifica se o campo Código do DDD do Município
		// foi preenchido
		if (leiturista.getCodigoDDD() == null
				|| leiturista.getCodigoDDD().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Código do DDD do Município");
		}

		// Verifica se o campo Numero Telefone
		// foi preenchido
		if (leiturista.getNumeroFone() == null
				|| leiturista.getNumeroFone().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Numero Telefone");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroLeiturista filtroLeiturista = new FiltroLeiturista();
		filtroLeiturista.adicionarParametro(new ParametroSimples(
				FiltroLeiturista.ID, leiturista.getId()));

		Collection colecaoLeituristaBase = getControladorUtil().pesquisar(
				filtroLeiturista, Leiturista.class.getName());

		if (colecaoLeituristaBase == null || colecaoLeituristaBase.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		Leiturista leituristaBase = (Leiturista) colecaoLeituristaBase
				.iterator().next();

		if (leituristaBase.getUltimaAlteracao().after(
				leiturista.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		leiturista.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(leiturista);

	}

	public void atualizarRoteiroEmpresa(RoteiroEmpresa roteiroEmpresa,
			String[] idQuadras, Usuario usuarioLogado)
			throws ControladorException {

		String idRoteiro = "" + roteiroEmpresa.getId();

		validacaoFinalRoteiroEmpresa("" + roteiroEmpresa.getEmpresa().getId(),
				roteiroEmpresa.getLeiturista(),
				"" + roteiroEmpresa.getIndicadorUso(), "ALTERAR", idQuadras);

		FiltroRoteiroEmpresa filtro = (FiltroRoteiroEmpresa) roteiroEmpresa
				.retornaFiltro();

		// Procura roteiro na base
		Collection roteirosNaBase = getControladorUtil().pesquisar(filtro,
				RoteiroEmpresa.class.getName());

		RoteiroEmpresa roteiroNaBase = (RoteiroEmpresa) Util
				.retonarObjetoDeColecao(roteirosNaBase);

		if (roteiroNaBase == null) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.registro_remocao_nao_existente");
		}

		// Verificar se a roteiro já foi atualizado por outro usuário
		// durante esta atualização

		if (roteiroNaBase.getUltimaAlteracao().after(
				roteiroEmpresa.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// Atualiza a data de última alteração
		roteiroEmpresa.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ROTEIRO_EMPRESA_ATUALIZAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		roteiroEmpresa.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

		registradorOperacao.registrarOperacao(roteiroEmpresa);

		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// Atualiza o roteiro empresa
		this.getControladorUtil().atualizar(roteiroEmpresa);

		// Atualizar as quadras
		// 1o. retirar o roteiro empresa das quadras que estavam com este
		// roteiro
		// 2o. atualizar as novas quadras com este roteiro empresa
		Collection quadrasRoteiro = getControladorLocalidade()
				.pesquisarQuadrasPorRoteiroEmpresa(Integer.parseInt(idRoteiro));
		for (Iterator iter = quadrasRoteiro.iterator(); iter.hasNext();) {
			Quadra quadra = (Quadra) iter.next();

			// Cria o filtro
			FiltroQuadra filtroQuadra = new FiltroQuadra();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = Quadra.class.getName();

			// Seta os parametros do filtro
			filtroQuadra.adicionarParametro(new ParametroSimples(
					FiltroQuadra.ID, quadra.getId()));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection quadrasNaBase = getControladorUtil().pesquisar(
					filtroQuadra, nomePacoteObjeto);

			Quadra quadraNaBase = (Quadra) Util
					.retonarObjetoDeColecao(quadrasNaBase);

			quadraNaBase.setRoteiroEmpresa(null);

			quadraNaBase.adicionarUsuario(usuarioLogado,
					UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(quadraNaBase);
			getControladorLocalidade().atualizarQuadra(quadraNaBase,
					usuarioLogado, null);
		}

		for (int i = 0; i < idQuadras.length; i++) {

			// Cria o filtro
			FiltroQuadra filtroQuadra = new FiltroQuadra();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = Quadra.class.getName();

			// Seta os parametros do filtro
			filtroQuadra.adicionarParametro(new ParametroSimples(
					FiltroQuadra.ID, idQuadras[i]));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection quadras = getControladorUtil().pesquisar(filtroQuadra,
					nomePacoteObjeto);

			Quadra quadraNaBase = (Quadra) Util.retonarObjetoDeColecao(quadras);

			// [FS0007] - Verificar duplicidade de roteiro empresa para a quadra
			if (quadraNaBase.getRoteiroEmpresa() == null) {
				quadraNaBase.setRoteiroEmpresa(roteiroEmpresa);
				quadraNaBase.adicionarUsuario(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(quadraNaBase);
				getControladorLocalidade().atualizarQuadra(quadraNaBase,
						usuarioLogado, null);
			}
		}

	}

	/**
	 * Remover roteiros empresa
	 * 
	 * @author Francisco do Nascimento
	 * @date 20/09/07
	 * @param ids
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void removerRoteiroEmpresa(String[] ids, Usuario usuarioLogado)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ROTEIRO_EMPRESA_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(
				usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// retirar a associação do roteiro empresa às quadras antes de remover
		for (int i = 0; i < ids.length; i++) {
			int idRoteiro = Integer.parseInt(ids[i]);
			Collection quadras = getControladorLocalidade()
					.pesquisarQuadrasPorRoteiroEmpresa(idRoteiro);
			for (Iterator iter = quadras.iterator(); iter.hasNext();) {
				Quadra quadra = (Quadra) iter.next();

				// Cria o filtro
				FiltroQuadra filtroQuadra = new FiltroQuadra();
				// Pega o nome do pacote do objeto
				String nomePacoteObjeto = Quadra.class.getName();

				// Seta os parametros do filtro
				filtroQuadra.adicionarParametro(new ParametroSimples(
						FiltroQuadra.ID, quadra.getId()));

				// Pesquisa a coleção de acordo com o filtro passado
				Collection quadrasNaBase = getControladorUtil().pesquisar(
						filtroQuadra, nomePacoteObjeto);

				Quadra quadraNaBase = (Quadra) Util
						.retonarObjetoDeColecao(quadrasNaBase);

				quadraNaBase.setRoteiroEmpresa(null);

				quadraNaBase.adicionarUsuario(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				quadraNaBase.setOperacaoEfetuada(operacaoEfetuada);

				getControladorUtil().atualizar(quadraNaBase);
			}
		}

		// remover roteiro(s) empresa
		this.getControladorUtil().remover(ids, RoteiroEmpresa.class.getName(),
				operacaoEfetuada, colecaoUsuarios);

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloRota(
			String codigoSetorComercial, String rotaInicial, String rotaFinal,
			String idLocalidade, String idCobrancaAcao, Integer idCriterio)
			throws ControladorException {
		String[] retorno = null;

		try {
			retorno = repositorioMicromedicao.pesquisarQuantidadeRotas(
					codigoSetorComercial, rotaInicial, rotaFinal, idLocalidade,
					idCobrancaAcao, idCriterio);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloSetor(
			String codigoSetorComercialInicial,
			String codigoSetorComercialFinal, String idLocalidade,
			String idCobrancaAcao, Integer idCriterio)
			throws ControladorException {
		String[] retorno = null;

		try {
			retorno = repositorioMicromedicao
					.pesquisarQuantidadeRotasIntervaloSetor(
							codigoSetorComercialInicial,
							codigoSetorComercialFinal, idLocalidade,
							idCobrancaAcao, idCriterio);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloLocalidade(
			String idLocalidadeInicial, String idLocalidadeFinal,
			String idCobrancaAcao, Integer idCriterio)
			throws ControladorException {
		String[] retorno = null;

		try {
			retorno = repositorioMicromedicao
					.pesquisarQuantidadeRotasIntervaloLocalidade(
							idLocalidadeInicial, idLocalidadeFinal,
							idCobrancaAcao, idCriterio);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloGerencia(
			String idGerenciaRegional, String idCobrancaAcao, Integer idCriterio)
			throws ControladorException {
		String[] retorno = null;

		try {
			retorno = repositorioMicromedicao
					.pesquisarQuantidadeRotasIntervaloGerencia(
							idGerenciaRegional, idCobrancaAcao, idCriterio);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloGrupo(
			String idGrupoCobranca, String idCobrancaAcao, Integer idCriterio)
			throws ControladorException {
		String[] retorno = null;

		try {
			retorno = repositorioMicromedicao
					.pesquisarQuantidadeRotasIntervaloGrupo(idGrupoCobranca,
							idCobrancaAcao, idCriterio);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloUnidadeNegocio(
			String idUnidadeNegocio, String idCobrancaAcao, Integer idCriterio)
			throws ControladorException {
		String[] retorno = null;

		try {
			retorno = repositorioMicromedicao
					.pesquisarQuantidadeRotasIntervaloUnidadeNegocio(
							idUnidadeNegocio, idCobrancaAcao, idCriterio);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	public String[] pesquisarQuantidadeRotasPorCobrancaAcao(
			String idCobrancaAcao, Integer idCriterio)
			throws ControladorException {
		String[] retorno = null;

		try {
			retorno = repositorioMicromedicao
					.pesquisarQuantidadeRotasPorCobrancaAcao(idCobrancaAcao,
							idCriterio);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	/**
	 * Pesquisa as rotas pelo grupo de faturamento
	 * 
	 * [UC0627] Gerar Arquivo Texto para Leitura
	 * 
	 * @author Pedro Alexandre
	 * @date 15/10/2007
	 * 
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarRotaPorGrupoFaturamento(
			Integer idFaturamentoGrupo) throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquisarRotasPorGrupoFaturamento(idFaturamentoGrupo);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloRotas(String codigoSetorComercial,
			String rotaInicial, String rotaFinal, String idLocalidade,
			String idCobrancaAcao) throws ControladorException {

		try {
			repositorioMicromedicao.desassociarRotasIntervaloRotas(
					codigoSetorComercial, rotaInicial, rotaFinal, idLocalidade,
					idCobrancaAcao);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloSetor(
			String codigoSetorComercialInicial,
			String codigoSetorComercialFinal, String idLocalidade,
			String idCobrancaAcao) throws ControladorException {

		try {
			repositorioMicromedicao.desassociarRotasIntervaloSetor(
					codigoSetorComercialInicial, codigoSetorComercialFinal,
					idLocalidade, idCobrancaAcao);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloLocalidade(String idLocalidadeInicial,
			String idLocalidadeFinal, String idCobrancaAcao)
			throws ControladorException {

		try {
			repositorioMicromedicao.desassociarRotasIntervaloLocalidade(
					idLocalidadeInicial, idLocalidadeFinal, idCobrancaAcao);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloGerencia(String idGerenciaRegional,
			String idCobrancaAcao) throws ControladorException {

		try {
			repositorioMicromedicao.desassociarRotasIntervaloGerencia(
					idGerenciaRegional, idCobrancaAcao);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloGrupo(String idGrupoCobranca,
			String idCobrancaAcao) throws ControladorException {

		try {
			repositorioMicromedicao.desassociarRotasIntervaloGrupo(
					idGrupoCobranca, idCobrancaAcao);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloUnidadeNegocio(
			String idUnidadeNegocio, String idCobrancaAcao)
			throws ControladorException {

		try {
			repositorioMicromedicao.desassociarRotasIntervaloUnidadeNegocio(
					idUnidadeNegocio, idCobrancaAcao);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

	}

	/**
	 * [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	 */
	public void desassociarRotasPorCobrancaAcao(String idCobrancaAcao)
			throws ControladorException {

		try {
			repositorioMicromedicao
					.desassociarRotasPorCobrancaAcao(idCobrancaAcao);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

	}

	/**
	 * pesquisa o consumo historico passando o imovel e o anomes referencia e o
	 * consumo anormalidade correspondente ao faturameto antecipado.
	 * 
	 * [UC0113] Faturar Grupo de Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 08/11/2007
	 * 
	 * @param idRota
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarConsumoHistoricoAntecipado(Integer idImovel,
			Integer anoMes) throws ControladorException {
		try {
			return repositorioMicromedicao.pesquisarConsumoHistoricoAntecipado(
					idImovel, anoMes);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * Relatório Analise de Consumo Flávio Leonardo 26/12/2007
	 * 
	 * @param idImovel
	 * @param anomes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarLeiturasImovel(String idImovel, String anoMes)
			throws ControladorException {
		try {
			return repositorioMicromedicao.pesquisarLeiturasImovel(idImovel,
					anoMes);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Relatório Manter Hidrometro
	 * 
	 * Flávio Leonardo
	 * 
	 * pesquisa o id do imovel do hidrometro instalado
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarImovelPeloHidrometro(Integer hidrometroId)
			throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquisarImovelPeloHidrometro(hidrometroId);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método que atualiza as leituras e Anormalidades do Celular caso não tenha
	 * sido iniciado pelo operador do Computador.
	 * 
	 * [UC0712] Atualizar Leituras e Anormalidades do Celular
	 * 
	 * @author Thiago Nascimento
	 * @date 05/12/2007
	 * 
	 * @param dados
	 * @throws ControladorException
	 */
	public byte[] atualizarLeituraAnormalidadeCelularCasoOperador(
			Vector<DadosMovimentacao> dados, Usuario usuario,
			String nomeArquivo, Leiturista l) throws ControladorException {

		Vector<DadosMovimentacao> invalidos = new Vector<DadosMovimentacao>();
		Vector<DadosMovimentacao> validos = new Vector<DadosMovimentacao>();
		Iterator<DadosMovimentacao> it = dados.iterator();

		byte[] retorno = null;
		Empresa empresa = null;

		StringBuffer log = new StringBuffer();
		Integer setorComercial = null;

		Collection colecaoHelper = new ArrayList();

		// Ano mes de Referencia;
		FaturamentoGrupo faturamentoGrupo = null;
		Integer anoMesReferencia = null;
		Integer grupo = null;
		try {

			if (dados.size() > 0) {

				grupo = dados.get(0).getGrupoFaturamento();

				if (grupo != null) {
					faturamentoGrupo = repositorioMicromedicao
							.buscarAnoMesReferenciaCasoOperador(grupo);

					if (faturamentoGrupo != null) {
						anoMesReferencia = faturamentoGrupo
								.getAnoMesReferencia();
					}
				}
			}

			if (anoMesReferencia != null) {
				Date dataRealizacao = null;

				while (it.hasNext()) {

					DadosMovimentacao dado = it.next();
					Date dataLeitura = dado.getDataLeituraCampo();

					if (dataRealizacao == null) {
						dataRealizacao = dataLeitura;
					}

					boolean invalido = false;

					setorComercial = dado.getSetorComercial();

					// Verificar a Existencia de Imovel
					Integer quantidadeImoveisNaBase = null;

					if (dado.getMatriculaImovel() != null) {
						quantidadeImoveisNaBase = repositorioImovel
								.verificarExistenciaImovel(dado
										.getMatriculaImovel());

					}

					// verifica a existência do imóvel na base
					if (quantidadeImoveisNaBase == null
							|| quantidadeImoveisNaBase <= 0) {

						invalido = true;

						String mensagem = "Matrícula do imóvel inexistente: "
								+ dado.getMatriculaImovel();

						colecaoHelper.add(mensagem);

					}

					// Obtém o anoMes da data de leitura atual informada
					if (dataLeitura == null) {

						invalido = true;

						String mensagem = "Imóvel:" + dado.getMatriculaImovel()
								+ " com Data de leitura inválida "
								+ dado.getStringDataLeitura();
						colecaoHelper.add(mensagem);

					} else {

						Integer anoMes = Util.formataAnoMes(dataLeitura);

						String anoMesString = "" + anoMes;
						String anoMesReferenciaString = "" + anoMesReferencia;
						if ((anoMesString != null && anoMesString.length() >= 6)
								&& (anoMesReferenciaString != null && anoMesReferenciaString
										.length() >= 6)) {

							// Compara se data de leitura está dentro do
							// intervalo anoMesFaturamentoAnterior e
							// anoMesFaturamentoPosterior
							// Caso contrário, dataLeitura recebe a data
							// corrente.
							// ----------------------------------------------------------------
							// CRC 826
							// Alterado por: Yara T. Souza
							// Date = 17/02/2008
							// ----------------------------------------------------------------
							Integer anoMesDataLeitura = Util
									.formataAnoMes(dataLeitura);
							Integer anoMesFaturamentoAnterior = Util
									.subtrairMesDoAnoMes(anoMesReferencia, 1);
							Integer anoMesFaturamentoPosterior = Util
									.somaUmMesAnoMesReferencia(anoMesReferencia);

							if (anoMesDataLeitura != null
									&& anoMesFaturamentoAnterior != null
									&& anoMesFaturamentoPosterior != null) {

								if (!anoMesReferencia.equals(anoMesDataLeitura)
										&& !Util.compararAnoMesReferencia(
												anoMesDataLeitura,
												anoMesFaturamentoAnterior, "=")
										&& !Util.compararAnoMesReferencia(
												anoMesDataLeitura,
												anoMesFaturamentoPosterior, "=")) {

									dataLeitura = new Date();
								}
							}
						}
					}

					// verifica a existência da leitura anormalidade
					Object[] leituraAnormalidade = null;
					Short indicadorImovelSemHidrometro = null;

					if (dado.getCodigoAnormalidade() != null) {
						leituraAnormalidade = repositorioMicromedicao
								.pesquisarLeituraAnormalidade(dado
										.getCodigoAnormalidade());
					}

					if (leituraAnormalidade != null) {

						if (leituraAnormalidade[1] != null) {
							indicadorImovelSemHidrometro = (Short) leituraAnormalidade[1];
						}
					} else {
						if (dado.getCodigoAnormalidade() != null
								&& dado.getCodigoAnormalidade() != 0) {
							// Anormalidade Inexistente

							invalido = true;

							String mensagem = "Imóvel:"
									+ dado.getMatriculaImovel()
									+ " com Código da Anormalidade de Leitura inexistente "
									+ dado.getCodigoAnormalidade();

							colecaoHelper.add(mensagem);
						}
					}

					// Verificar tipo de medicao

					// verifica se existe hidrometro instalação histórico para o
					// imóvel da medição histórico
					Integer idHidrometroInstalacaoHistorico = null;
					Integer quantidadeMedicoesTipo = null;

					if (dado.getMatriculaImovel() != null) {

						if (dado.getTipoMedicao().equals(
								MedicaoTipo.LIGACAO_AGUA)) {

							idHidrometroInstalacaoHistorico = repositorioMicromedicao
									.verificarExistenciaHidrometroInstalacaoHistoricoTipoAgua(dado
											.getMatriculaImovel());

						} else {
							if (dado.getTipoMedicao().equals(MedicaoTipo.POCO)) {

								idHidrometroInstalacaoHistorico = repositorioMicromedicao
										.verificarExistenciaHidrometroInstalacaoHistoricoTipoPoco(dado
												.getMatriculaImovel());

							}
						}
					}

					if (dado.getTipoMedicao() != null) {

						quantidadeMedicoesTipo = repositorioMicromedicao
								.verificarExistenciaMedicaoTipo(dado
										.getTipoMedicao());

					}

					// verifica se existe a medição tipo na base
					if (quantidadeMedicoesTipo == null
							|| quantidadeMedicoesTipo <= 0) {

						if (dado.getTipoMedicao() != 0) {

							invalido = true;

							String mensagem = "Imóvel:"
									+ dado.getMatriculaImovel()
									+ " com Tipo de Medição Inexistente "
									+ dado.getTipoMedicao();

							colecaoHelper.add(mensagem);

						} else {

							// verificar se existe hidrometro instalado e a
							// leitura
							// informada seja maior que 0
							if (dado.getLeituraHidrometro() > 0
									&& idHidrometroInstalacaoHistorico == null) {

								invalido = true;

								String mensagem = "Imóvel:"
										+ dado.getMatriculaImovel()
										+ " com Movimentação para ligação sem hidrômetro";

								colecaoHelper.add(mensagem);

							} else {
								// caso a anromalidade informada não seja
								// compatível
								// com ligação sem hidrometro e o hidrometro
								// instalação histórico sejá nulo
								if (indicadorImovelSemHidrometro
										.equals(LeituraAnormalidade.INDICADOR_IMOVEL_SEM_HIDROMETRO)) {

									invalido = true;

									String mensagem = "Imóvel:"
											+ dado.getMatriculaImovel()
											+ " com Anormalidade não permitida para ligação sem hidrômetro";

									colecaoHelper.add(mensagem);
								}
							}
						}
					} else {

						if (dado.getTipoMedicao().equals(
								MedicaoTipo.LIGACAO_AGUA)) {

							if (idHidrometroInstalacaoHistorico == null) {

								invalido = true;

								String mensagem = "Imóvel:"
										+ dado.getMatriculaImovel()
										+ " com Movimento para ligação de água sem hidrômetro "
										+ dado.getTipoMedicao();

								colecaoHelper.add(mensagem);
							}

						} else {
							if (dado.getTipoMedicao().equals(MedicaoTipo.POCO)) {

								if (idHidrometroInstalacaoHistorico == null) {

									invalido = true;

									String mensagem = "Imóvel:"
											+ dado.getMatriculaImovel()
											+ " com Movimento para poço sem hidrômetro "
											+ dado.getTipoMedicao();

									colecaoHelper.add(mensagem);
								}
							}
						}
					}

					// Verificar o indicador de confirmação de leitura
					if (dado.getIndicadorConfirmacaoLeitura() != 0
							&& dado.getIndicadorConfirmacaoLeitura() != 1) {

						invalido = true;
						String mesagem = "Imóvel:"
								+ dado.getMatriculaImovel()
								+ " com Indicador de Confirmação de Leitura inválido "
								+ dado.getIndicadorConfirmacaoLeitura();

						colecaoHelper.add(mesagem);
					}

					// Inserir no Vetor de Imóveis com dados Inválidos
					if (invalido) {
						invalidos.add(dado);
					} else {

						/*
						 * CRC5256
						 * 
						 * Colocado por Raphael Rossiter em 18/10/2010 Analista:
						 * Eduardo Borges
						 * 
						 * OBJ: Não atualizar a data de realização da atividade
						 * efetuar leitura com uma data que não esteja dentro do
						 * cronograma do grupo.
						 */
						Date dataLeituraCronograma = this
								.obterDataRealizacaoDaAtividadeEfetuarLeitura(
										dado.getDataLeituraCampo(),
										faturamentoGrupo, anoMesReferencia);

						dado.setDataLeituraCronograma(dataLeituraCronograma);

						// Registrar
						this.repositorioMicromedicao
								.atualizarLeituraAnormailidadeCelular(dado,
										anoMesReferencia, l);

						// 1.3.6
						if (dado.getTipoMedicao() != null
								&& !dado.getTipoMedicao().equals(0)) {

							// Consistir
							Collection<Integer> imoveis = new ArrayList<Integer>();
							imoveis.add(dado.getMatriculaImovel());

							this.consistirLeiturasCalcularConsumosImoveis(
									faturamentoGrupo, imoveis);

							// Inserir no Movimento Roteiro Empresa
							if (this.repositorioMicromedicao
									.atualizarMovimentoRoteiroEmpresa(dado,
											anoMesReferencia, true) == null) {

								invalidos.add(dado);
								invalido = true;

								String mensagem = "";

								mensagem = "Imóvel:"
										+ dado.getMatriculaImovel()
										+ " com Movimento Roteiro Empresa sem dados para processar o imóvel informado.";
								colecaoHelper.add(mensagem);
							} else {
								validos.add(dado);

								if (!it.hasNext()) {
									FiltroRota filtroRota = new FiltroRota();
									filtroRota
											.adicionarParametro(new ParametroSimples(
													FiltroRota.LOCALIDADE_ID,
													dado.getLocalidade()));
									filtroRota
											.adicionarParametro(new ParametroSimples(
													FiltroRota.SETOR_COMERCIAL_CODIGO,
													dado.getSetorComercial()));
									filtroRota
											.adicionarParametro(new ParametroSimples(
													FiltroRota.CODIGO_ROTA,
													dado.getCodigoRota()));
									Collection colecaoRota = getControladorUtil()
											.pesquisar(filtroRota,
													Rota.class.getName());
									Rota rota = (Rota) Util
											.retonarObjetoDeColecao(colecaoRota);
									if (rota != null) {
										this.repositorioMicromedicao
												.atualizarArquivoRoteiroEmpresaParaFinalizado(
														faturamentoGrupo, dado,
														rota.getId());
									}
								}
							}
						}
					}

					if (empresa == null) {
						empresa = this.repositorioImovel
								.buscarEmpresaPorMatriculaImovel(dado
										.getMatriculaImovel());
					}

				}
				// Verificar se é o processamento do ultimo arquivo texto
				if (dataRealizacao == null) {
					dataRealizacao = new Date();
				}

				/*
				 * CRC5256
				 * 
				 * Colocado por Raphael Rossiter em 18/10/2010 Analista: Eduardo
				 * Borges
				 * 
				 * OBJ: Não atualizar a data de realização da atividade efetuar
				 * leitura com uma data que não esteja dentro do cronograma do
				 * grupo.
				 */
				FaturamentoGrupo faturamentoGrupoAtualizarAtividade = new FaturamentoGrupo();
				faturamentoGrupoAtualizarAtividade.setId(grupo);

				dataRealizacao = this
						.obterDataRealizacaoDaAtividadeEfetuarLeitura(
								dataRealizacao,
								faturamentoGrupoAtualizarAtividade,
								anoMesReferencia);

				this.repositorioMicromedicao
						.verificarProcessamentoUltimoArquivoTexto(grupo,
								anoMesReferencia, dataRealizacao);

				retorno = this
						.gerarRelatorioAtualizarLeituraAnormalidadeCelular(
								validos, invalidos, grupo, empresa, usuario,
								colecaoHelper);
			} else {
				// Não existe grupo de faturamento.
				log.append("Grupo de Faturamento Inexistente");

				throw new ControladorException(
						"atencao.grupo_faturamento_inexistente");
			}

		} catch (ControladorException e) {

			e.printStackTrace();

			ControladorException e2 = new ControladorException(log.toString(),
					e);

			String[] parametros = new String[1];
			if (setorComercial != null) {
				parametros[0] = setorComercial.toString();
			} else {
				parametros[0] = "";
			}
			e2.setParametroMensagem(parametros);

			throw e2;
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * 
	 * Buscar Empresa pela Matrícula do Imóvel.
	 * 
	 * @param imovel
	 * @return
	 * @throws ControladorException
	 */
	public Empresa buscarEmpresaPorMatriculaImovel(Integer imovel)
			throws ControladorException {
		try {
			return this.repositorioImovel
					.buscarEmpresaPorMatriculaImovel(imovel);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * 
	 * Enviar Email em Caso de Problemas no Registrar ou Consistir.
	 * 
	 * @param nomeArquivo
	 * @param arquivo
	 * @throws ControladorException
	 */
	public void enviarEmailProblemasRegistrarConsistir(String nomeArquivo,
			byte[] arquivo) throws SendFailedException, ControladorException {

		EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(
				EnvioEmail.REGISTRAR_LEITURAS_ANORMALIDADES);

		String emailRemetente = envioEmail.getEmailReceptor();

		String tituloMensagem = "ERRO - " + envioEmail.getTituloMensagem()
				+ " - " + nomeArquivo;

		String corpoMensagem = envioEmail.getCorpoMensagem();
		String emailReceptor = envioEmail.getEmailReceptor();

		try {
			File leitura = File.createTempFile(
					nomeArquivo.substring(0, nomeArquivo.length() - 4) + "-",
					".txt");
			FileOutputStream out = new FileOutputStream(leitura);
			out.write(arquivo);
			out.close();

			ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
					emailRemetente, tituloMensagem, corpoMensagem, leitura);

			leitura.delete();

		} catch (SendFailedException e) {
			throw e;
		} catch (IOException e) {
			throw new ControladorException("erro.sistema", e);
		} catch (Exception e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	private void logPerformance(String mens, long tempo1, long tempo2) {
		if (tempo2 - tempo1 > 7000) {
			System.out
					.println("%$% " + mens + ": " + (tempo2 - tempo1) + " ms");
		}
	}

	/**
	 * 
	 * Método que atualiza as leituras e Anormalidades do Celular caso não tenha
	 * sido iniciado pelo Sistema.
	 * 
	 * [UC0712] Atualizar Leituras e Anormalidades do Celular
	 * 
	 * @author Thiago Nascimento
	 * @date 05/12/2007
	 * 
	 * @param dados
	 * @throws ControladorException
	 */
	public void atualizarLeituraAnormalidadeCelularCasoSistema(
			Vector<DadosMovimentacao> dados) throws SendFailedException,
			ControladorException {

		Iterator<DadosMovimentacao> it = dados.iterator();
		StringBuffer log = new StringBuffer("");
		FaturamentoGrupo faturamentoGrupo = null;
		Integer anoMesReferencia = null;
		Integer grupo = null;
		Leiturista leit = null;

		if (dados.size() > 0) {

			try {

				DadosMovimentacao d = dados.get(0);

				faturamentoGrupo = repositorioMicromedicao
						.buscarAnoMesReferenciaCasoSistema(d
								.getMatriculaImovel());

				if (faturamentoGrupo != null) {

					anoMesReferencia = faturamentoGrupo.getAnoMesReferencia();
					grupo = faturamentoGrupo.getId();

					// Buscar Leiturista
					FiltroMovimentoRoteiroEmpresa filtro = new FiltroMovimentoRoteiroEmpresa();
					filtro.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.ROTA);
					filtro.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.LEITURISTA);
					filtro.adicionarParametro(new ParametroSimples(
							FiltroMovimentoRoteiroEmpresa.IMOVEL_ID, d
									.getMatriculaImovel()));
					filtro.adicionarParametro(new ParametroSimples(
							FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO,
							anoMesReferencia));
					filtro.adicionarParametro(new ParametroSimples(
							FiltroMovimentoRoteiroEmpresa.MEDICAO_TIPO_ID, d
									.getTipoMedicao()));

					Collection colecao = getControladorUtil().pesquisar(filtro,
							MovimentoRoteiroEmpresa.class.getName());

					if (colecao != null && !colecao.isEmpty()) {
						MovimentoRoteiroEmpresa m = (MovimentoRoteiroEmpresa) colecao
								.iterator().next();
						leit = m.getRota().getLeiturista();
					}
				}

				Date dataRealizacao = null;
				while (it.hasNext()) {
					DadosMovimentacao dado = it.next();

					if (dataRealizacao == null) {
						dataRealizacao = dado.getDataLeituraCampo();
					}

					/*
					 * CRC5256
					 * 
					 * Colocado por Raphael Rossiter em 18/10/2010 Analista:
					 * Eduardo Borges
					 * 
					 * OBJ: Não atualizar a data de realização da atividade
					 * efetuar leitura com uma data que não esteja dentro do
					 * cronograma do grupo.
					 */
					Date dataLeituraCronograma = this
							.obterDataRealizacaoDaAtividadeEfetuarLeitura(
									dado.getDataLeituraCampo(),
									faturamentoGrupo, anoMesReferencia);

					dado.setDataLeituraCronograma(dataLeituraCronograma);

					this.repositorioMicromedicao
							.atualizarLeituraAnormailidadeCelular(dado,
									anoMesReferencia, leit);

					// Consistir
					Collection<Integer> imoveis = new ArrayList<Integer>();
					imoveis.add(dado.getMatriculaImovel());

					this.consistirLeiturasCalcularConsumosImoveis(
							faturamentoGrupo, imoveis);

					// Atualizar Movimento roteiro empresa para nenhum problema
					// com
					// Registar e Consistir

					if (this.repositorioMicromedicao
							.atualizarMovimentoRoteiroEmpresa(dado,
									anoMesReferencia, true) == null) {

						log.append("Imóvel:");
						log.append(dado.getMatriculaImovel());
						log.append(" com Movimento Roteiro Empresa sem dados para processar o imóvel informado");
						log.append(System.getProperty("line.separator"));
					}

				}
				if (dataRealizacao == null) {
					dataRealizacao = new Date();
				}

				/*
				 * CRC5256
				 * 
				 * Colocado por Raphael Rossiter em 18/10/2010 Analista: Eduardo
				 * Borges
				 * 
				 * OBJ: Não atualizar a data de realização da atividade efetuar
				 * leitura com uma data que não esteja dentro do cronograma do
				 * grupo.
				 */
				FaturamentoGrupo faturamentoGrupoAtualizarAtividade = new FaturamentoGrupo();
				faturamentoGrupoAtualizarAtividade.setId(grupo);

				dataRealizacao = this
						.obterDataRealizacaoDaAtividadeEfetuarLeitura(
								dataRealizacao,
								faturamentoGrupoAtualizarAtividade,
								anoMesReferencia);

				this.repositorioMicromedicao
						.verificarProcessamentoUltimoArquivoTexto(grupo,
								anoMesReferencia, dataRealizacao);

				// Enviar Email com o log de erros cometidos
				// Caso tenha algum erro
				if (log.length() != 0) {
					this.enviarEmailProblemasRegistrarConsistir(
							"LOG de ERRO.txt", log.toString().getBytes());
				}

			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

		} else {
			// Lista Vazia para Atualizar
			// throw new ControladorException("atencao.lista_vazia");
		}
	}

	/**
	 * Gerar relatório de Leituras e Anormalidades
	 * 
	 * @param validos
	 * @param invalidos
	 * @param grupo
	 * @param empresa
	 * @param usuario
	 * @return
	 * @throws ControladorException
	 */
	public byte[] gerarRelatorioAtualizarLeituraAnormalidadeCelular(
			Vector<DadosMovimentacao> validos,
			Vector<DadosMovimentacao> invalidos, Integer grupo,
			Empresa empresa, Usuario usuario, Collection colecaoHelper)
			throws ControladorException {

		Integer localidade = null;
		int totalComLeitura = 0;
		int totalComAnormalidade = 0;
		int totalLeituraAnormalidade = 0;
		int totalAnormalidade = 0;

		Iterator<DadosMovimentacao> it = validos.iterator();

		// Parte para resumo de Leituras e Anormalidades por setor e localidade
		Collection<RelatorioAtualizarLeiturasAnormalidadesCelularBean> leituras = new ArrayList<RelatorioAtualizarLeiturasAnormalidadesCelularBean>();

		// Parte de Resumo de Anormalidade
		Collection<RelatorioAtualizarLeiturasAnormalidadesCelularBean> anormalidades = new ArrayList<RelatorioAtualizarLeiturasAnormalidadesCelularBean>();

		// Parte de Resumo de Anormalidade
		Collection<RelatorioAtualizarLeiturasAnormalidadesCelularBean> mensagem = new ArrayList<RelatorioAtualizarLeiturasAnormalidadesCelularBean>();

		RelatorioAtualizarLeiturasAnormalidadesCelularBean m = null;

		for (Iterator iter = colecaoHelper.iterator(); iter.hasNext();) {

			String mensagemErro = (String) iter.next();

			m = new RelatorioAtualizarLeiturasAnormalidadesCelularBean();

			mensagemErro = "ATENÇÃO: " + mensagemErro;

			m.setMensagemInvalida(mensagemErro);
			mensagem.add(m);
		}

		if (validos.size() > 0) {
			localidade = validos.get(0).getLocalidade();
		} else if (invalidos.size() > 0) {
			localidade = invalidos.get(0).getLocalidade();
		}

		int count = 0;
		// Para os dados válidos
		while (it.hasNext()) {
			DadosMovimentacao dado = it.next();
			boolean tem = false;
			Iterator<RelatorioAtualizarLeiturasAnormalidadesCelularBean> it2 = leituras
					.iterator();
			while (it2.hasNext()) {
				RelatorioAtualizarLeiturasAnormalidadesCelularBean r = it2
						.next();
				if (r.getSetor().equals(dado.getSetorComercial().toString())) {
					tem = true;
					// Que só tenha Leitura
					if ((dado.getCodigoAnormalidade() == null || dado
							.getCodigoAnormalidade() == 0)
							&& dado.getLeituraHidrometro() != null
							&& dado.getLeituraHidrometro() != 0) {
						r.setComLeitura(""
								+ (Integer.parseInt(r.getComLeitura()) + 1));
						totalComLeitura++;
						// Que tenha só anormalidade
					} else if (dado.getCodigoAnormalidade() != null
							&& dado.getCodigoAnormalidade() != 0
							&& (dado.getLeituraHidrometro() == null || dado
									.getLeituraHidrometro() == 0)) {
						r.setComAnormalidade(""
								+ (Integer.parseInt(r.getComAnormalidade()) + 1));
						totalComAnormalidade++;
					} else {
						// Que tenha os dois leitura e anormalidade
						r.setLeituraAnormalidade(""
								+ (Integer.parseInt(r.getLeituraAnormalidade()) + 1));
						totalLeituraAnormalidade++;
					}
					r.setRecebido("" + (Integer.parseInt(r.getRecebido()) + 1));
					break;
				}
			}
			if (!tem) {
				RelatorioAtualizarLeiturasAnormalidadesCelularBean r = new RelatorioAtualizarLeiturasAnormalidadesCelularBean(
						dado.getSetorComercial().toString(), "1", "0", "0",
						"0", "0");
				if ((dado.getCodigoAnormalidade() == null || dado
						.getCodigoAnormalidade() == 0)
						&& dado.getLeituraHidrometro() != null
						&& dado.getLeituraHidrometro() != 0) {
					r.setComLeitura("1");
					totalComLeitura++;
				} else if (dado.getCodigoAnormalidade() != null
						&& dado.getCodigoAnormalidade() != 0
						&& (dado.getLeituraHidrometro() == null || dado
								.getLeituraHidrometro() == 0)) {
					r.setComAnormalidade("1");
					totalComAnormalidade++;
				} else {
					r.setLeituraAnormalidade("1");
					totalLeituraAnormalidade++;
				}
				r.setIdSetor("" + count);
				count++;
				leituras.add(r);
			}

			// Para Resumo de Anormalidades

			if (dado.getCodigoAnormalidade() != null
					&& dado.getCodigoAnormalidade() != 0) {
				boolean temAnormalidade = false;
				it2 = anormalidades.iterator();
				while (it2.hasNext()) {
					RelatorioAtualizarLeiturasAnormalidadesCelularBean r = it2
							.next();
					if (dado.getCodigoAnormalidade().toString()
							.equals(r.getCodigoAnormalidade())) {
						temAnormalidade = true;
						r.setQuantidade(""
								+ (Integer.parseInt(r.getQuantidade()) + 1));
						totalAnormalidade++;
						break;
					}
				}
				if (!temAnormalidade) {
					RelatorioAtualizarLeiturasAnormalidadesCelularBean r = new RelatorioAtualizarLeiturasAnormalidadesCelularBean(
							dado.getCodigoAnormalidade().toString(), "", "1");
					anormalidades.add(r);
					totalAnormalidade++;
				}
			}

		}
		// Para os invalidos
		it = invalidos.iterator();
		while (it.hasNext()) {
			DadosMovimentacao dado = it.next();
			boolean tem = false;
			Iterator<RelatorioAtualizarLeiturasAnormalidadesCelularBean> it2 = leituras
					.iterator();
			while (it2.hasNext()) {
				RelatorioAtualizarLeiturasAnormalidadesCelularBean r = it2
						.next();
				if (r.getSetor().equals(dado.getSetorComercial().toString())) {
					tem = true;
					r.setRecebido("" + (Integer.parseInt(r.getRecebido()) + 1));
					r.calcularInvalidos();
					break;
				}
			}
			if (!tem) {
				RelatorioAtualizarLeiturasAnormalidadesCelularBean r = new RelatorioAtualizarLeiturasAnormalidadesCelularBean(
						dado.getSetorComercial().toString(), "1", "0", "0",
						"0", "1");
				leituras.add(r);
			}
		}
		String recebido = "" + (validos.size() + invalidos.size());
		leituras.add(new RelatorioAtualizarLeiturasAnormalidadesCelularBean(
				recebido, "" + totalComLeitura, "" + totalComAnormalidade, ""
						+ totalLeituraAnormalidade, "" + invalidos.size()));

		Iterator<RelatorioAtualizarLeiturasAnormalidadesCelularBean> it2 = anormalidades
				.iterator();
		while (it2.hasNext()) {
			RelatorioAtualizarLeiturasAnormalidadesCelularBean r = it2.next();
			String descricao = null;
			try {
				descricao = this.repositorioMicromedicao
						.buscarDescricaoLeituraAnormalidade(new Integer(r
								.getCodigoAnormalidade()));
			} catch (NumberFormatException e) {
				throw new ControladorException("erro.sistema", e);
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}
			r.setDescricaoAnormalidade(descricao);

		}

		anormalidades
				.add(new RelatorioAtualizarLeiturasAnormalidadesCelularBean(""
						+ totalAnormalidade));

		RelatorioAtualizarLeiturasAnormalidadesCelular relatorio = new RelatorioAtualizarLeiturasAnormalidadesCelular(
				usuario, leituras, anormalidades, mensagem);

		relatorio.addParametro("grupo", grupo);
		relatorio.addParametro("codigoEmpresa", empresa.getId());
		relatorio.addParametro("empresa", empresa.getDescricao());
		relatorio.addParametro("localidade", localidade);

		return (byte[]) relatorio.executar();

	}

	public void consistirLeiturasCalcularConsumosImoveis(FaturamentoGrupo faturamentoGrupo, Collection<Integer> imoveis) throws ControladorException {

		Integer matricula = null;

		try {

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			sistemaParametro.setAnoMesFaturamento(faturamentoGrupo.getAnoMesReferencia());

			Collection colecaoInserirMedicaoHistoricoAgua = new ArrayList();
			Collection colecaoAtualizarMedicaoHistoricoAgua = new ArrayList();
			Collection colecaoInserirConsumoHistoricoAgua = new ArrayList();

			Collection colecaoInserirMedicaoHistoricoEsgoto = new ArrayList();
			Collection colecaoAtualizarMedicaoHistoricoEsgoto = new ArrayList();
			Collection colecaoInserirConsumoHistoricoEsgoto = new ArrayList();

			Rota rota = null;

			Object[] arrayImovel = null;
			Imovel imovel = null;

			int quantidadeEconomias = 0;

			colecaoInserirMedicaoHistoricoAgua.clear();
			colecaoAtualizarMedicaoHistoricoAgua.clear();
			colecaoInserirConsumoHistoricoAgua.clear();
			colecaoInserirConsumoHistoricoEsgoto.clear();

			Integer idConta = null;

			if (imoveis != null && !imoveis.isEmpty()) {

				Iterator<Integer> iteratorColecaoImoveis = imoveis.iterator();

				while (iteratorColecaoImoveis.hasNext()) {

					matricula = iteratorColecaoImoveis.next();

					arrayImovel = this.repositorioMicromedicao.pesquisarImovelPelaMatricula(matricula);
					rota = this.repositorioMicromedicao.buscarRotaDoImovel(matricula);

					imovel = obterImovelLigadoCortadoAguaLigadoEsgoto(arrayImovel);

					EsferaPoder esferaPoder = null;

					if (arrayImovel[26] != null) {
						esferaPoder = new EsferaPoder();
						esferaPoder.setId((Integer) arrayImovel[26]);
					}

					idConta = (Integer) getControladorImovel().pesquisarImovelIdComConta(imovel.getId(),sistemaParametro.getAnoMesFaturamento());

					Integer idDebitoCreditoSituacaoAtual = this.getControladorFaturamento().pesquisarDebitoCreditoSituacaoAtualConta(imovel.getId(), sistemaParametro.getAnoMesFaturamento());

					if (idConta == null || idConta.equals("") || idDebitoCreditoSituacaoAtual.intValue() == DebitoCreditoSituacao.PRE_FATURADA.intValue()) {

						repositorioMicromedicao.deletarConsumoHistoricoCondominioRETIRAR(imovel.getId(), sistemaParametro.getAnoMesFaturamento().intValue());
						repositorioMicromedicao.deletarConsumoHistoricoRETIRAR(imovel.getId(), sistemaParametro.getAnoMesFaturamento().intValue());

						if (Util.obterMes(sistemaParametro.getAnoMesFaturamento()) == 11) {
							if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)) {
								Integer anoMesReferenciaFaturamentoAntecipado = Util.somarData(sistemaParametro.getAnoMesFaturamento());

								repositorioMicromedicao.deletarConsumoHistoricoCondominioRETIRAR(imovel.getId(), anoMesReferenciaFaturamentoAntecipado);
								repositorioMicromedicao.deletarConsumoHistoricoRETIRAR(imovel.getId(),	anoMesReferenciaFaturamentoAntecipado);
							}
						}

						quantidadeEconomias = this.getControladorImovel().obterQuantidadeEconomiasVirtuais(imovel.getId());

						MedicaoHistorico medicaoHistorico = null;
						ConsumoHistorico consumoHistoricoAgua = null;
						ConsumoHistorico consumoHistoricoEsgoto = null;

						LigacaoTipo ligacaoTipo = new LigacaoTipo();

						Short indicadorFaturamentoLigacaoAgua = imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao();
						Short indicadorFaturamentoLigacaoEsgoto = imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao();

						// CASO O IMÓVEL SEJA LIGADO OU CORTADO DE ÁGUA
						if (indicadorFaturamentoLigacaoAgua.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
								|| (imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null)) {

							ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

							rota.setFaturamentoGrupo(faturamentoGrupo);
							consumoHistoricoAgua = new ConsumoHistorico();
							consumoHistoricoAgua.setRota(rota);
							consumoHistoricoAgua.setLigacaoTipo(ligacaoTipo);
							consumoHistoricoAgua.setImovel(imovel);
							
							long t1 = System.currentTimeMillis();
							
							determinarDadosFaturamentoAgua(medicaoHistorico, consumoHistoricoAgua, sistemaParametro,
									quantidadeEconomias, colecaoInserirMedicaoHistoricoAgua, colecaoAtualizarMedicaoHistoricoAgua,
									colecaoInserirConsumoHistoricoAgua, esferaPoder);

						}

						// CASO O IMÓVEL SEJA LIGADO DE ESGOTO
						if (indicadorFaturamentoLigacaoEsgoto.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)
								|| (imovel.getHidrometroInstalacaoHistorico() != null)) {

							ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

							consumoHistoricoEsgoto = new ConsumoHistorico();
							consumoHistoricoEsgoto.setRota(rota);
							consumoHistoricoEsgoto.setLigacaoTipo(ligacaoTipo);

							determinarDadosFaturamentoEsgoto(imovel, consumoHistoricoEsgoto, consumoHistoricoAgua, quantidadeEconomias,
									sistemaParametro, rota, colecaoInserirConsumoHistoricoEsgoto, faturamentoGrupo, colecaoInserirMedicaoHistoricoEsgoto,
									colecaoAtualizarMedicaoHistoricoEsgoto, esferaPoder);
						}
					}

				}

				getControladorBatch().inserirColecaoObjetoParaBatchSemTransacao(colecaoInserirMedicaoHistoricoAgua);
				getControladorBatch().atualizarColecaoObjetoParaBatchSemTransacao(colecaoAtualizarMedicaoHistoricoAgua);
				getControladorBatch().inserirColecaoObjetoParaBatchSemTransacao(colecaoInserirConsumoHistoricoAgua);
				getControladorBatch().inserirColecaoObjetoParaBatchSemTransacao(colecaoInserirMedicaoHistoricoEsgoto);
				getControladorBatch().atualizarColecaoObjetoParaBatchSemTransacao(colecaoAtualizarMedicaoHistoricoEsgoto);
				getControladorBatch().inserirColecaoObjetoParaBatchSemTransacao(colecaoInserirConsumoHistoricoEsgoto);
			}
		} catch (Exception e) {
			System.out.println("ERRO NO IMÓVEL:" + matricula);
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);

		}
	}

	/**
	 * [UC0629] Consultar Arquivo Texto Leitura.
	 * 
	 * Atualizar Situação do Arquivo Texto.
	 * 
	 * 
	 * @author Thiago Nascimento
	 * @date 29/01/2008
	 * 
	 * @param id
	 * @param situacaoNova
	 * @throws ControladorException
	 */
	public void atualizarArquivoTextoEnviado(Integer id, Integer situacaoNova)
			throws ControladorException {
		try {
			this.repositorioMicromedicao.atualizarArquivoTexto(id,
					situacaoNova, null);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0629] Consultar Arquivo Texto Leitura.
	 * 
	 * Atualizar Situação do Arquivo Texto.
	 * 
	 * 
	 * @author Thiago Nascimento
	 * @date 29/01/2008
	 * 
	 * @param ids
	 * @param situacaoNova
	 * @throws ControladorException
	 */
	public void atualizarListaArquivoTexto(Vector<Integer> ids,
			Integer situacaoNova, Integer idServicoTipoCelular,
			boolean temPermissaoFinalizarArquivo, String motivoFinalizacao)
			throws ControladorException {
		try {
			Iterator<Integer> it = ids.iterator();
			while (it.hasNext()) {
				Integer id = it.next();
				if (situacaoNova.equals(SituacaoTransmissaoLeitura.LIBERADO)) {
					Object[] dadosArquivoLiberado = verificarExistenciaArquivoLiberado(
							id, false);
					if (dadosArquivoLiberado == null
							|| dadosArquivoLiberado.length == 0) {
						this.repositorioMicromedicao.atualizarArquivoTexto(id,
								situacaoNova, motivoFinalizacao);
					} else {
						sessionContext.setRollbackOnly();
						throw new ControladorException(
								"atencao.arquivo_nao_pode_liberar",
								null,
								Util.formatarAnoMesParaMesAno((Integer) dadosArquivoLiberado[0]),
								"" + dadosArquivoLiberado[1]);
					}

				} else if (situacaoNova
						.equals(SituacaoTransmissaoLeitura.FINALIZADO_USUARIO)) {

					Object[] obj = repositorioMicromedicao
							.pesquisarQuantidadeImoveisPorArquivo(id);

					Integer idRota = (Integer) obj[0];
					Integer quantidadeImoveis = (Integer) obj[1];
					Integer anoMesReferencia = (Integer) obj[2];
					Integer situacaoleitura = (Integer) obj[3];

					if (situacaoleitura
							.compareTo(SituacaoTransmissaoLeitura.DISPONIVEL) == 0
							|| situacaoleitura
									.compareTo(SituacaoTransmissaoLeitura.EM_CAMPO) == 0
							|| situacaoleitura
									.compareTo(SituacaoTransmissaoLeitura.LIBERADO) == 0) {

						if (anoMesReferencia == null
								|| anoMesReferencia.equals("")) {
							SistemaParametro sistemaParametro = getControladorUtil()
									.pesquisarParametrosDoSistema();
							anoMesReferencia = sistemaParametro
									.getAnoMesFaturamento();
						}

						Integer quantidadeLeiturasRealizadas = repositorioMicromedicao
								.quantidadeLeiturasRealizada(idRota,
										anoMesReferencia, idServicoTipoCelular);

						if (quantidadeLeiturasRealizadas != null
								&& quantidadeImoveis != null
								&& quantidadeLeiturasRealizadas
										.equals(quantidadeImoveis)) {
							this.repositorioMicromedicao.atualizarArquivoTexto(
									id, situacaoNova, motivoFinalizacao);
						} // Alteracao solitcitada por Leo para deixar finalizar
							// aquivos que sejam de impressao simultanea
						else if (quantidadeLeiturasRealizadas != null
								&& quantidadeImoveis != null
								&& !quantidadeLeiturasRealizadas
										.equals(quantidadeImoveis)
								&& idServicoTipoCelular == 2
								&& temPermissaoFinalizarArquivo) {

							this.repositorioMicromedicao.atualizarArquivoTexto(
									id, situacaoNova, motivoFinalizacao);
						} else {
							sessionContext.setRollbackOnly();
							throw new ControladorException(
									"atencao.leituras.nao.recebidas");
						}
					} else {
						sessionContext.setRollbackOnly();
						throw new ControladorException(
								"atencao.arquivo.ja.finalizado");
					}
				} else if (situacaoNova
						.equals(SituacaoTransmissaoLeitura.INFORMAR_MOTIVO_FINALIZACAO)) {
					Object[] obj = repositorioMicromedicao
							.pesquisarQuantidadeImoveisPorArquivo(id);

					Integer situacaoleitura = (Integer) obj[3];

					this.repositorioMicromedicao.atualizarArquivoTexto(id,
							situacaoleitura, motivoFinalizacao);
				} else {
					this.repositorioMicromedicao.atualizarArquivoTexto(id,
							situacaoNova, motivoFinalizacao);
				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0629] Consultar Arquivo Texto Leitura.
	 * 
	 * Verifica se todas leituras foram relizadas.
	 * 
	 * 
	 * @author Hugo Amorim
	 * @date 25/08/2010
	 * 
	 * @param ids
	 * @throws ControladorException
	 */
	public boolean verificarLeiturasRealizadas(Vector<Integer> ids,
			Integer idServicoTipoCelular) throws ControladorException {

		boolean retorno = true;

		try {
			Iterator<Integer> it = ids.iterator();

			while (it.hasNext()) {

				Integer id = it.next();

				Object[] obj = repositorioMicromedicao
						.pesquisarQuantidadeImoveisPorArquivo(id);

				Integer idRota = (Integer) obj[0];
				Integer quantidadeImoveis = (Integer) obj[1];
				Integer anoMesReferencia = (Integer) obj[2];

				if (anoMesReferencia == null || anoMesReferencia.equals("")) {
					SistemaParametro sistemaParametro = getControladorUtil()
							.pesquisarParametrosDoSistema();
					anoMesReferencia = sistemaParametro.getAnoMesFaturamento();
				}

				Integer quantidadeLeiturasRealizadas = repositorioMicromedicao
						.quantidadeLeiturasRealizada(idRota, anoMesReferencia,
								idServicoTipoCelular);

				if (quantidadeLeiturasRealizadas != null
						&& quantidadeImoveis != null
						&& !quantidadeLeiturasRealizadas
								.equals(quantidadeImoveis)) {
					retorno = false;
					break;
				}

			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * [UC0543] Associar Conjunto de Rotas a Critério de Cobrança
	 * 
	 * [FS0003] - Verificar existência da localidade [FS0004] - Verificar
	 * existência do setor
	 * 
	 * Verifica se a localidade inicial é maior que a localidade final Verifica
	 * se o setor inicial é maior que o setor final
	 * 
	 * @author Raphael Rossiter
	 * @date 24/01/2008
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public void validarParametrosParaSelecaoDeRotas(
			AssociarConjuntoRotasCriterioCobrancaHelper parametros)
			throws ControladorException {

		if (parametros.getIdCobrancaAcao() == null) {
			throw new ControladorException("atencao.campo.informada", null,
					"Ação de Cobrança");
		}

		// Ana Breda pediu pra retirar a critica, pois o unico campo obrigatorio
		// eh a acao de cobranca
		// e quando nao for preenchido o grupo de cobranca deve pegar todos os
		// grupos.
		// if (parametros.getIdGrupoCobranca() == null &&
		// parametros.getIdGerencialRegional() == null &&
		// parametros.getIdUnidadeNegocio() == null &&
		// parametros.getIdLocalidadeInicial() == null){
		//
		// throw new
		// ControladorException("atencao.informar_grupo_ou_localizacao_geografica");
		// }

		// LOCALIDADE
		boolean localidadesIguais = true;

		if (parametros.getIdLocalidadeInicial() != null) {

			FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
			filtroLocalidade.adicionarParametro(new ParametroSimples(
					FiltroLocalidade.ID, parametros.getIdLocalidadeInicial()));
			Collection colecaoLocalidade = this.getControladorUtil().pesquisar(
					filtroLocalidade, Localidade.class.getName());

			if (colecaoLocalidade.isEmpty()) {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Localidade Inicial");
			}

			if (parametros.getIdLocalidadeFinal() != null) {

				if (!parametros.getIdLocalidadeFinal().equals(
						parametros.getIdLocalidadeInicial())) {

					filtroLocalidade.limparListaParametros();
					filtroLocalidade.adicionarParametro(new ParametroSimples(
							FiltroLocalidade.ID, parametros
									.getIdLocalidadeFinal()));
					colecaoLocalidade = this.getControladorUtil().pesquisar(
							filtroLocalidade, Localidade.class.getName());

					if (colecaoLocalidade.isEmpty()) {
						throw new ControladorException(
								"atencao.pesquisa_inexistente", null,
								"Localidade Final");
					}

					if (parametros.getIdLocalidadeFinal().intValue() < parametros
							.getIdLocalidadeInicial().intValue()) {
						throw new ControladorException(
								"atencao.localidade_inicial_maior_localidade_final");
					}

					localidadesIguais = false;
				}
			} else {
				throw new ControladorException("atencao.campo.informada", null,
						"Localidade Final");
			}
		}

		/*
		 * Os setores só poderão ser informados caso as localidades sejam iguais
		 */
		if (!localidadesIguais
				&& parametros.getCdSetorComercialInicial() != null) {
			throw new ControladorException("atencao.localidade_diferente");
		}

		// SETOR COMERCIAL
		boolean setoresIguais = true;
		SetorComercial setorComercialInicial = null;

		if (parametros.getIdLocalidadeInicial() != null
				&& parametros.getCdSetorComercialInicial() != null) {

			FiltroSetorComercial filtroSetorComercial = new FiltroSetorComercial();
			filtroSetorComercial.adicionarParametro(new ParametroSimples(
					FiltroSetorComercial.CODIGO_SETOR_COMERCIAL, parametros
							.getCdSetorComercialInicial()));
			filtroSetorComercial.adicionarParametro(new ParametroSimples(
					FiltroSetorComercial.ID_LOCALIDADE, parametros
							.getIdLocalidadeInicial()));
			Collection colecaoSetor = this.getControladorUtil().pesquisar(
					filtroSetorComercial, SetorComercial.class.getName());

			if (colecaoSetor.isEmpty()) {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Setor Comercial Inicial");
			}

			setorComercialInicial = (SetorComercial) Util
					.retonarObjetoDeColecao(colecaoSetor);

			if (parametros.getCdSetorComercialFinal() != null) {

				if (!parametros.getCdSetorComercialFinal().equals(
						parametros.getCdSetorComercialInicial())) {

					filtroSetorComercial.limparListaParametros();
					filtroSetorComercial
							.adicionarParametro(new ParametroSimples(
									FiltroSetorComercial.CODIGO_SETOR_COMERCIAL,
									parametros.getCdSetorComercialFinal()));
					filtroSetorComercial
							.adicionarParametro(new ParametroSimples(
									FiltroSetorComercial.ID_LOCALIDADE,
									parametros.getIdLocalidadeFinal()));
					colecaoSetor = this.getControladorUtil().pesquisar(
							filtroSetorComercial,
							SetorComercial.class.getName());

					if (colecaoSetor.isEmpty()) {
						throw new ControladorException(
								"atencao.pesquisa_inexistente", null,
								"Setor Comercial Final");
					}

					if (parametros.getCdSetorComercialFinal().intValue() < parametros
							.getCdSetorComercialInicial().intValue()) {
						throw new ControladorException(
								"atencao.setor_inicial_maior_setor_final");
					}

					setoresIguais = false;
				}
			} else {
				throw new ControladorException("atencao.campo.informada", null,
						"Setor Comercial Final");
			}
		}

		/*
		 * As rotas só poderão ser informados caso os setores sejam iguais
		 */
		if (!setoresIguais && parametros.getNnRotaInicial() != null) {
			throw new ControladorException("atencao.setor_diferente");
		}

		// ROTA
		if (setorComercialInicial != null
				&& parametros.getNnRotaInicial() != null) {

			FiltroRota filtroRota = new FiltroRota();
			filtroRota.adicionarParametro(new ParametroSimples(
					FiltroRota.SETOR_COMERCIAL_ID, setorComercialInicial
							.getId()));
			filtroRota.adicionarParametro(new ParametroSimples(
					FiltroRota.CODIGO_ROTA, parametros.getNnRotaInicial()));
			Collection colecaoRota = this.getControladorUtil().pesquisar(
					filtroRota, Rota.class.getName());

			if (colecaoRota.isEmpty()) {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Rota Inicial");
			}

			if (parametros.getNnRotaFinal() != null) {

				if (!parametros.getNnRotaFinal().equals(
						parametros.getNnRotaInicial())) {

					filtroRota.limparListaParametros();
					filtroRota.adicionarParametro(new ParametroSimples(
							FiltroRota.SETOR_COMERCIAL_ID,
							setorComercialInicial.getId()));
					filtroRota
							.adicionarParametro(new ParametroSimples(
									FiltroRota.CODIGO_ROTA, parametros
											.getNnRotaFinal()));
					colecaoRota = this.getControladorUtil().pesquisar(
							filtroRota, Rota.class.getName());

					if (colecaoRota.isEmpty()) {
						throw new ControladorException(
								"atencao.pesquisa_inexistente", null,
								"Rota Final");
					}

					if (parametros.getNnRotaFinal().intValue() < parametros
							.getNnRotaInicial().intValue()) {
						throw new ControladorException(
								"atencao.rota_inicial_maior_rota_final");
					}

				}
			} else {
				throw new ControladorException("atencao.campo.informada", null,
						"Rota Final");
			}
		}
	}

	/**
	 * [UC0543] Associar Conjunto de Rotas a Critério de Cobrança
	 * 
	 * @author Raphael Rossiter
	 * @date 24/01/2008
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public void validarAssociarConjuntoRotasCriterioCobranca(
			AssociarConjuntoRotasCriterioCobrancaHelper parametros)
			throws ControladorException {

		if (parametros.getIdCriterioCobranca() == null) {
			throw new ControladorException("atencao.campo.informada", null,
					"Critério de Cobrança");
		}

		this.validarParametrosParaSelecaoDeRotas(parametros);
	}

	/**
	 * [UC0543] Associar Conjunto de Rotas a Critério de Cobrança
	 * 
	 * @author Raphael Rossiter
	 * @date 24/01/2008
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public String[] pesquisarQuantidadeRotas(
			AssociarConjuntoRotasCriterioCobrancaHelper parametros)
			throws ControladorException {

		String[] qtdRotasArray = null;

		this.validarParametrosParaSelecaoDeRotas(parametros);

		if (parametros.getIdGrupoCobranca() != null) {

			qtdRotasArray = this.pesquisarQuantidadeRotasIntervaloGrupo(
					parametros.getIdGrupoCobranca().toString(), parametros
							.getIdCobrancaAcao().toString(), parametros
							.getIdCriterioCobranca());

		} else if (parametros.getNnRotaInicial() != null) {

			qtdRotasArray = this.pesquisarQuantidadeRotasIntervaloRota(
					parametros.getCdSetorComercialInicial().toString(),
					parametros.getNnRotaInicial().toString(), parametros
							.getNnRotaFinal().toString(), parametros
							.getIdLocalidadeInicial().toString(), parametros
							.getIdCobrancaAcao().toString(), parametros
							.getIdCriterioCobranca());

		} else if (parametros.getCdSetorComercialInicial() != null) {

			qtdRotasArray = this.pesquisarQuantidadeRotasIntervaloSetor(
					parametros.getCdSetorComercialInicial().toString(),
					parametros.getCdSetorComercialFinal().toString(),
					parametros.getIdLocalidadeInicial().toString(), parametros
							.getIdCobrancaAcao().toString(), parametros
							.getIdCriterioCobranca());

		} else if (parametros.getIdLocalidadeInicial() != null) {

			qtdRotasArray = this.pesquisarQuantidadeRotasIntervaloLocalidade(
					parametros.getIdLocalidadeInicial().toString(), parametros
							.getIdLocalidadeFinal().toString(), parametros
							.getIdCobrancaAcao().toString(), parametros
							.getIdCriterioCobranca());

		} else if (parametros.getIdUnidadeNegocio() != null) {

			qtdRotasArray = this
					.pesquisarQuantidadeRotasIntervaloUnidadeNegocio(parametros
							.getIdUnidadeNegocio().toString(), parametros
							.getIdCobrancaAcao().toString(), parametros
							.getIdCriterioCobranca());

		} else if (parametros.getIdGerencialRegional() != null) {

			qtdRotasArray = this.pesquisarQuantidadeRotasIntervaloGerencia(
					parametros.getIdGerencialRegional().toString(), parametros
							.getIdCobrancaAcao().toString(), parametros
							.getIdCriterioCobranca());

		} else { // nenhum parametro foi escolhido, entao buscar as rotas em
					// todo o estado
			qtdRotasArray = this.pesquisarQuantidadeRotasPorCobrancaAcao(
					parametros.getIdCobrancaAcao().toString(),
					parametros.getIdCriterioCobranca());

		}

		return qtdRotasArray;
	}

	/**
	 * [UC0543] Associar Conjunto de Rotas a Critério de Cobrança
	 * 
	 * @author Raphael Rossiter
	 * @date 24/01/2008
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public Collection pesquisarRotasParaAssociacaoCriterioCobranca(
			AssociarConjuntoRotasCriterioCobrancaHelper parametros)
			throws ControladorException {

		Collection rotas = null;

		if (parametros.isValidarCriterioCobranca()) {
			this.validarAssociarConjuntoRotasCriterioCobranca(parametros);
		} else {
			this.validarParametrosParaSelecaoDeRotas(parametros);
		}

		if (parametros.getIdGrupoCobranca() != null) {

			rotas = this.getControladorCobranca().pesquisarRotasIntervaloGrupo(
					parametros.getIdGrupoCobranca().toString(),
					parametros.getIdCobrancaAcao().toString());

		} else if (parametros.getNnRotaInicial() != null) {

			rotas = this.getControladorCobranca().pesquisarRotas(
					parametros.getCdSetorComercialInicial().toString(),
					parametros.getNnRotaInicial().toString(),
					parametros.getNnRotaFinal().toString(),
					parametros.getIdLocalidadeInicial().toString(),
					parametros.getIdCobrancaAcao().toString());

		} else if (parametros.getCdSetorComercialInicial() != null) {

			rotas = this.getControladorCobranca().pesquisarRotasIntervaloSetor(
					parametros.getCdSetorComercialInicial().toString(),
					parametros.getCdSetorComercialFinal().toString(),
					parametros.getIdLocalidadeInicial().toString(),
					parametros.getIdCobrancaAcao().toString());

		} else if (parametros.getIdLocalidadeInicial() != null) {

			rotas = this.getControladorCobranca()
					.pesquisarRotasIntervaloLocalidade(
							parametros.getIdLocalidadeInicial().toString(),
							parametros.getIdLocalidadeFinal().toString(),
							parametros.getIdCobrancaAcao().toString());

		} else if (parametros.getIdUnidadeNegocio() != null) {

			rotas = this.getControladorCobranca()
					.pesquisarRotasIntervaloUnidadeNegocio(
							parametros.getIdUnidadeNegocio().toString(),
							parametros.getIdCobrancaAcao().toString());

		} else if (parametros.getIdGerencialRegional() != null) {

			rotas = this.getControladorCobranca()
					.pesquisarRotasIntervaloGerencia(
							parametros.getIdGerencialRegional().toString(),
							parametros.getIdCobrancaAcao().toString());

		} else { // caso nenhum parametro seja setado, deve-se pesquisar todas
					// as rotas do estado by Ana Breda
			rotas = this.getControladorCobranca()
					.pesquisarRotasPorCobrancaAcao(
							parametros.getIdCobrancaAcao().toString());
		}

		return rotas;
	}

	/**
	 * [UC0543] Associar Conjunto de Rotas a Critério de Cobrança
	 * 
	 * @author Raphael Rossiter, Anderson Italo
	 * @date 24/01/2008, 02/06/2009 Adicionado registro de transacao CRC1946
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public void desassociarConjuntoRotasCriterioCobranca(
			AssociarConjuntoRotasCriterioCobrancaHelper parametros,
			Usuario usuarioLogado, RotaAcaoCriterioHelper rotaAcaoCriterioHelper)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		UsuarioAcao usuarioAcao = UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO;

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(
				usuarioLogado, usuarioAcao);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_DESASSOCIAR_CONJUNTO_ROTAS_CRITERIO_COBRANCA);
		operacaoEfetuada.setOperacao(operacao);

		CobrancaAcao cobrancaAcao = new CobrancaAcao();
		cobrancaAcao.setId(new Integer(rotaAcaoCriterioHelper.getCobrancaAcao()
				.getId()));
		cobrancaAcao.setDescricaoCobrancaAcao(Interceptador
				.consultarDescricao(cobrancaAcao));
		rotaAcaoCriterioHelper.setCobrancaAcao(cobrancaAcao);

		operacaoEfetuada.preencherDadosAdicionais(rotaAcaoCriterioHelper);
		operacaoEfetuada.setArgumentoValor(new Integer(rotaAcaoCriterioHelper
				.getCobrancaAcao().getId()));

		getControladorTransacao().processaRegistroOperacaoObjetohelper(
				usuarioAcaoUsuarioHelper, AlteracaoTipo.EXCLUSAO,
				rotaAcaoCriterioHelper, operacaoEfetuada,
				RotaAcaoCriterioHelper.TABELA_ID);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		if (parametros.isValidarCriterioCobranca()) {
			this.validarAssociarConjuntoRotasCriterioCobranca(parametros);
		} else {
			this.validarParametrosParaSelecaoDeRotas(parametros);
		}

		if (parametros.getIdGrupoCobranca() != null) {

			this.desassociarRotasIntervaloGrupo(parametros.getIdGrupoCobranca()
					.toString(), parametros.getIdCobrancaAcao().toString());

		} else if (parametros.getNnRotaInicial() != null) {

			this.desassociarRotasIntervaloRotas(parametros
					.getCdSetorComercialInicial().toString(), parametros
					.getNnRotaInicial().toString(), parametros.getNnRotaFinal()
					.toString(),
					parametros.getIdLocalidadeInicial().toString(), parametros
							.getIdCobrancaAcao().toString());

		} else if (parametros.getCdSetorComercialInicial() != null) {

			this.desassociarRotasIntervaloSetor(parametros
					.getCdSetorComercialInicial().toString(), parametros
					.getCdSetorComercialFinal().toString(), parametros
					.getIdLocalidadeInicial().toString(), parametros
					.getIdCobrancaAcao().toString());

		} else if (parametros.getIdLocalidadeInicial() != null) {

			this.desassociarRotasIntervaloLocalidade(parametros
					.getIdLocalidadeInicial().toString(), parametros
					.getIdLocalidadeFinal().toString(), parametros
					.getIdCobrancaAcao().toString());

		} else if (parametros.getIdUnidadeNegocio() != null) {

			this.desassociarRotasIntervaloUnidadeNegocio(parametros
					.getIdUnidadeNegocio().toString(), parametros
					.getIdCobrancaAcao().toString());

		} else if (parametros.getIdGerencialRegional() != null) {

			this.desassociarRotasIntervaloGerencia(parametros
					.getIdGerencialRegional().toString(), parametros
					.getIdCobrancaAcao().toString());

		} else { // caso em q nenhum parametro foi setado, usar todas as rotas
			this.desassociarRotasPorCobrancaAcao(parametros.getIdCobrancaAcao()
					.toString());
		}

	}

	/**
	 * 
	 * Retorna uma coleção com os dados das medicoes para apresentação sem
	 * informar o ano/mes para o caso em que o Imovel nao possui Hidrometro (Sem
	 * Medicao).
	 * 
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 */
	public Collection carregarDadosConsumo(Integer idImovel, boolean ligacaoAgua)
			throws ControladorException {

		Collection resultadoPesquisa = null;
		Collection retorno = null;

		try {
			resultadoPesquisa = repositorioMicromedicao.carregarDadosConsumo(
					idImovel, ligacaoAgua);

			if (!resultadoPesquisa.isEmpty()) {
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				ConsumoHistorico consumoHistorico = null;
				ConsumoHistorico consumoHistoricoEsgoto = null;
				Object[] objetoConsumo = null;
				ConsumoAnormalidade consumoAnormalidade = null;
				ConsumoTipo consumoTipo = null;
				MedicaoHistorico medicaoHistorico = null;
				ImovelMicromedicao imovelMicromedicao = null;

				while (iterator.hasNext()) {
					objetoConsumo = (Object[]) iterator.next();
					consumoHistorico = new ConsumoHistorico();
					consumoHistoricoEsgoto = new ConsumoHistorico();

					consumoHistorico
							.setReferenciaFaturamento(((Integer) objetoConsumo[0])
									.intValue());
					// =============================== Consumo Medido
					medicaoHistorico = new MedicaoHistorico();
					medicaoHistorico
							.setNumeroConsumoMes((Integer) objetoConsumo[1]);

					consumoHistorico
							.setNumeroConsumoFaturadoMes((Integer) objetoConsumo[2]);

					consumoHistorico
							.setConsumoRateio((Integer) objetoConsumo[3]);

					// =============================== Anormalidade Consumo
					consumoAnormalidade = new ConsumoAnormalidade();
					consumoAnormalidade.setDescricao((String) objetoConsumo[4]);
					consumoHistorico
							.setConsumoAnormalidade(consumoAnormalidade);

					// =============================== consumoTipo
					consumoTipo = new ConsumoTipo();
					consumoTipo.setDescricao((String) objetoConsumo[5]);
					consumoTipo
							.setDescricaoAbreviada((String) objetoConsumo[6]);
					consumoHistorico.setConsumoTipo(consumoTipo);

					if (objetoConsumo[8] != null) {
						medicaoHistorico
								.setDataLeituraAtualFaturamento((Date) objetoConsumo[8]);
					}

					// ==================== Dias de Consumo
					int diasConsumo = 0;
					if (objetoConsumo[7] != null && objetoConsumo[8] != null) {
						diasConsumo = Util.obterQuantidadeDiasEntreDuasDatas(
								(Date) objetoConsumo[7],
								(Date) objetoConsumo[8]);
					}
					if (ligacaoAgua) {
						consumoHistoricoEsgoto
								.setNumeroConsumoFaturadoMes((Integer) objetoConsumo[9]);
					}

					imovelMicromedicao = new ImovelMicromedicao();

					imovelMicromedicao
							.setConsumoHistoricoEsgoto(consumoHistoricoEsgoto);
					imovelMicromedicao.setQtdDias("" + diasConsumo);

					if (ligacaoAgua) {
						if (objetoConsumo[10] != null) {
							consumoHistorico
									.setConsumoMedio((Integer) objetoConsumo[10]);
						}
						if (objetoConsumo[11] != null) {
							LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
							leituraAnormalidade
									.setId((Integer) objetoConsumo[11]);
							leituraAnormalidade
									.setId((Integer) objetoConsumo[11]);
							leituraAnormalidade
									.setDescricao((String) objetoConsumo[20]);

							medicaoHistorico
									.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
						}

						if (objetoConsumo[12] != null) {
							medicaoHistorico
									.setNumeroConsumoInformado((Integer) objetoConsumo[12]);
						}
						if (objetoConsumo[13] != null) {
							consumoAnormalidade
									.setDescricaoAbreviada((String) objetoConsumo[13]);
						}

						if (objetoConsumo[14] != null) {
							consumoHistorico
									.setConsumoRateio((Integer) objetoConsumo[14]);
						}
						if (objetoConsumo[15] != null) {
							consumoHistorico
									.setNumeroConsumoCalculoMedia((Integer) objetoConsumo[15]);
						}

						if (objetoConsumo[16] != null) {
							medicaoHistorico
									.setDataLeituraAtualInformada((Date) objetoConsumo[16]);
						}

						if (objetoConsumo[17] != null) {
							medicaoHistorico
									.setLeituraAtualInformada((Integer) objetoConsumo[17]);
						}

						if (objetoConsumo[18] != null) {
							medicaoHistorico
									.setLeituraAtualFaturamento((Integer) objetoConsumo[18]);
						}

						if (objetoConsumo[19] != null) {
							LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
							leituraAnormalidade
									.setId((Integer) objetoConsumo[19]);
							medicaoHistorico
									.setLeituraAnormalidadeInformada(leituraAnormalidade);
						}

						if (objetoConsumo[21] != null) {
							LeituraSituacao leituraSituacao = new LeituraSituacao();
							leituraSituacao
									.setDescricao((String) objetoConsumo[21]);
							medicaoHistorico
									.setLeituraSituacaoAtual(leituraSituacao);
						}
					} else {
						if (objetoConsumo[9] != null) {
							consumoHistorico
									.setConsumoMedio((Integer) objetoConsumo[9]);
						}

						if (objetoConsumo[10] != null) {
							LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
							leituraAnormalidade
									.setId((Integer) objetoConsumo[10]);

							medicaoHistorico
									.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
						}
						if (objetoConsumo[11] != null) {
							medicaoHistorico
									.setNumeroConsumoInformado((Integer) objetoConsumo[11]);
						}
						if (objetoConsumo[12] != null) {
							consumoAnormalidade
									.setDescricaoAbreviada((String) objetoConsumo[12]);
						}
						if (objetoConsumo[13] != null) {
							consumoHistorico
									.setConsumoRateio((Integer) objetoConsumo[13]);
						}
						if (objetoConsumo[14] != null) {
							consumoHistorico
									.setNumeroConsumoCalculoMedia((Integer) objetoConsumo[14]);
						}

						// dataLeituraInformada
						if (objetoConsumo[15] != null) {
							medicaoHistorico
									.setDataLeituraAtualInformada((Date) objetoConsumo[15]);
						}

						// leituraAtualInformada
						if (objetoConsumo[16] != null) {
							medicaoHistorico
									.setLeituraAtualInformada((Integer) objetoConsumo[16]);
						}

						// leituraAtualFaturamento
						if (objetoConsumo[17] != null) {
							medicaoHistorico
									.setLeituraAtualFaturamento((Integer) objetoConsumo[17]);
						}
					}

					imovelMicromedicao.setConsumoHistorico(consumoHistorico);
					imovelMicromedicao.setMedicaoHistorico(medicaoHistorico);

					retorno.add(imovelMicromedicao);
				}
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	public Collection<DadosMovimentacao> buscarImoveisPorRota(Rota rota, boolean manter) throws ControladorException, ErroRepositorioException {
		Collection<DadosMovimentacao> colecao = new ArrayList<DadosMovimentacao>();

		Integer anoMesReferencia = rota.getFaturamentoGrupo().getAnoMesReferencia();
		
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		sistemaParametro.setAnoMesFaturamento(anoMesReferencia);

		Collection<ImovelPorRotaHelper> colecaoImoveisPorRotaHelper = buscarImoveisPorRotaHelper(rota, sistemaParametro);

		Iterator<ImovelPorRotaHelper> iteratorImovelPorRotaHelper = colecaoImoveisPorRotaHelper.iterator();
		while (iteratorImovelPorRotaHelper.hasNext()) {
			
			DadosMovimentacao dado = obterDadosMedicaoImovelPorRota(rota, anoMesReferencia, manter, sistemaParametro, iteratorImovelPorRotaHelper);
			
			if (dado != null) {
				colecao.add(dado);
			}
		}

		return colecao;
	}
	
	private DadosMovimentacao obterDadosMedicaoImovelPorRota(Rota rota,
			Integer anoMesReferencia, boolean manter,
			SistemaParametro sistemaParametro,
			Iterator<ImovelPorRotaHelper> iteratorImovelPorRotaHelper)
			throws ControladorException, ErroRepositorioException {
		ImovelPorRotaHelper imovelPorRotaHelper = iteratorImovelPorRotaHelper.next();

		Imovel imovel = imovelPorRotaHelper.getImovel();
		MedicaoTipo medicaoTipo = null;
		
		MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = imovelPorRotaHelper.getMovimentoRoteiroEmpresa();

		boolean achouImovel = this.validarImovelGerarDadosLeituraConvencional(imovel, movimentoRoteiroEmpresa.getAnoMesMovimento());

		if (achouImovel) {
			Integer idMedicaoTipo = null;
			idMedicaoTipo = repositorioMicromedicao.pesquisarMedicaoTipo(imovel.getId(), anoMesReferencia);
			medicaoTipo = new MedicaoTipo(idMedicaoTipo);
			
			DadosMovimentacao dado = new DadosMovimentacao();
			dado.setMatriculaImovel(imovel.getId());
			dado.setLocalidade(imovel.getLocalidade().getId());
			dado.setSetorComercial(imovel.getSetorComercial().getCodigo());
			dado.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
			dado.setNumeroLote(new Integer(imovel.getLote()));
			dado.setNumeroSubLote(new Integer(imovel.getSubLote()));
			dado.setEndereco(imovel.getNumeroImovel());
			dado.setNumeroSequencialRota(imovel.getNumeroSequencialRota());
			dado.setGrupoFaturamento(rota.getFaturamentoGrupo().getId());

			boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(imovel.getId(), medicaoTipo);

			int idLigacaoTipo = verificarTipoLigacao(imovel);
			int[] media = obterVolumeMedioAguaEsgoto(imovel.getId(),movimentoRoteiroEmpresa.getAnoMesMovimento(),idLigacaoTipo, houveIntslacaoHidrometro);
			Integer anoMesAnterior = Util.subtrairData(sistemaParametro.getAnoMesFaturamento());
			Integer leituraAnterior = new Integer(0);

			boolean ligacaoAgua = false;
			boolean ligacaoPoco = false;

			if (imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getId() != null && imovel.getLigacaoAgua() .getHidrometroInstalacaoHistorico() != null
					&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null) {
				ligacaoAgua = true;
			}
			if (imovel.getHidrometroInstalacaoHistorico() != null && imovel.getHidrometroInstalacaoHistorico().getId() != null) {
				ligacaoPoco = true;
			}

			Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior, imovel);
			
			if (retorno[0] != null) {
				leituraAnterior = new Integer(retorno[0].toString());
			}

			if (media[0] <= 10) {
				dado.setFaixaLeituraEsperadaInferior(leituraAnterior);
				dado.setFaixaLeituraEsperadaSuperior(leituraAnterior.intValue() + media[0] + 10);
			} else if (media[0] > 10 && media[0] <= 20) {
				dado.setFaixaLeituraEsperadaInferior(leituraAnterior + (int) (0.4 * media[0]));
				dado.setFaixaLeituraEsperadaSuperior(leituraAnterior + (int) (1.6 * media[0]));
			} else if (media[0] > 20 && media[0] <= 45) {
				dado.setFaixaLeituraEsperadaInferior(leituraAnterior + (int) (0.5 * media[0]));
				dado.setFaixaLeituraEsperadaSuperior(leituraAnterior + (int) (1.5 * media[0]));
			} else if (media[0] > 45 && media[0] <= 100) {
				dado.setFaixaLeituraEsperadaInferior(leituraAnterior + (int) (0.6 * media[0]));
				dado.setFaixaLeituraEsperadaSuperior(leituraAnterior + (int) (1.4 * media[0]));
			} else if (media[0] > 100) {
				dado.setFaixaLeituraEsperadaInferior(leituraAnterior + (int) (0.7 * media[0]));
				dado.setFaixaLeituraEsperadaSuperior(leituraAnterior + (int) (1.3 * media[0]));
			}

			try {
				if (imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() == null && idMedicaoTipo != null && idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)) {

					dado.setTipoMedicao(idMedicaoTipo);

					medicaoTipo.setId(idMedicaoTipo);
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = repositorioMicromedicao.verificaExistenciaDeHidrometroInstalado(imovel.getId(), medicaoTipo);

					 // Caso o Imovel seja suprimido, exibir a mensagem informando com a data.
					if (imovel.getLigacaoAguaSituacao() != null && imovel.getLigacaoAguaSituacao().getId() != null 
							&& imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.SUPRIMIDO)) {

						dado.setMsgImovelSuprimidoOuHidrometroRetirado("Imóvel suprimido no dia "+ Util.formatarData(imovel.getLigacaoAgua().getDataSupressao()));

					} else if (hidrometroInstalacaoHistorico != null && hidrometroInstalacaoHistorico.getDataRetirada() != null) {
						dado.setMsgImovelSuprimidoOuHidrometroRetirado("Hidrômetro retirado no dia " + Util.formatarData(hidrometroInstalacaoHistorico.getDataRetirada()));
					}
				} else if (imovel.getHidrometroInstalacaoHistorico() == null && idMedicaoTipo != null && idMedicaoTipo == MedicaoTipo.POCO) {

					dado.setTipoMedicao(idMedicaoTipo);

					medicaoTipo.setId(idMedicaoTipo);
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = repositorioMicromedicao.verificaExistenciaDeHidrometroInstalado(imovel.getId(), medicaoTipo);

					if (hidrometroInstalacaoHistorico != null && hidrometroInstalacaoHistorico .getDataRetirada() != null) {
						dado.setMsgImovelSuprimidoOuHidrometroRetirado("Hidrômetro retirado no dia "
								+ Util.formatarData(hidrometroInstalacaoHistorico.getDataRetirada()));
					}
				} else if (idMedicaoTipo != null) {
					dado.setTipoMedicao(idMedicaoTipo);
					medicaoTipo.setId(idMedicaoTipo);
				}

				if (movimentoRoteiroEmpresa != null) {

					dado.setLeituraHidrometro(movimentoRoteiroEmpresa.getNumeroLeituraHidrometro());
					dado.setDataLeituraCampo(movimentoRoteiroEmpresa.getTempoLeitura());

					if (movimentoRoteiroEmpresa.getLeituraAnormalidade() != null) {
						dado.setCodigoAnormalidade(movimentoRoteiroEmpresa.getLeituraAnormalidade().getId());
					}

					if (movimentoRoteiroEmpresa.getDataHoraProcessamento() != null) {
						//dado.setNaoPermitirAlterar(true);
					}

					ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = this.repositorioMicromedicao
							.pesquisarArquivosTextoRoteiroEmpresa(movimentoRoteiroEmpresa.getLocalidade().getId(),
									movimentoRoteiroEmpresa.getRota().getId(),
									movimentoRoteiroEmpresa.getFaturamentoGrupo().getId(),
									movimentoRoteiroEmpresa.getAnoMesMovimento());

					if (arquivoTextoRoteiroEmpresa != null) {

						dado.setArquivoTextoRoteiroEmpresa(arquivoTextoRoteiroEmpresa);

						if (arquivoTextoRoteiroEmpresa.getSituacaoTransmissaoLeitura() != null
								&& arquivoTextoRoteiroEmpresa.getSituacaoTransmissaoLeitura().getId().compareTo(SituacaoTransmissaoLeitura.TRANSMITIDO) == 0) {
							//dado.setNaoPermitirAlterar(true);
						}

					}
				}

				if (medicaoTipo != null && medicaoTipo.getId() != null) {

					Collection colecaoMedicaoHistorico = null;

					try {
						colecaoMedicaoHistorico = repositorioMicromedicao.pesquisarObterDadosHistoricoMedicao(imovel, medicaoTipo,rota.getFaturamentoGrupo());
					} catch (ErroRepositorioException ex) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}

					MedicaoHistorico medicaoHistorico = obterHistoricoMedicao(colecaoMedicaoHistorico);

					if (medicaoHistorico != null && !medicaoHistorico.getLeituraSituacaoAtual().getId().equals(LeituraSituacao.NAO_REALIZADA)) {
						if (manter) {
							return dado;
						}
					} else {
						return dado;
					}
				}

			} catch (ErroRepositorioException e) {
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}
		}
		return null;
	}

	private Collection<ImovelPorRotaHelper> buscarImoveisPorRotaHelper(Rota rota, SistemaParametro sistemaParametro) throws ControladorException {
		Collection imoveisPorRota = null;
		Collection<ImovelPorRotaHelper> objetosImoveis = new ArrayList<ImovelPorRotaHelper>();
		try {
			imoveisPorRota = repositorioMicromedicao.buscarImoveisPorRota(rota.getId(), sistemaParametro.getNomeAbreviadoEmpresa(), rota.getFaturamentoGrupo().getAnoMesReferencia());

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		if (imoveisPorRota != null && !imoveisPorRota.isEmpty()) {

			Iterator imovelporRotaIterator = imoveisPorRota.iterator();
			
			while (imovelporRotaIterator.hasNext()) {
				ImovelPorRotaHelper helper = buildImovelPorRotaHelper(rota, (Object[]) imovelporRotaIterator.next());
				
				if (helper.getImovel().isLigadoAgua() || helper.getImovel().isLigadoEsgoto())
					objetosImoveis.add(helper);
			}
		}
		
		return objetosImoveis;
	}

	private ImovelPorRotaHelper buildImovelPorRotaHelper(Rota rota, Object[] arrayImoveisPorRota) {

		Imovel imovel = new Imovel();
		MedicaoTipo medicaoTipo = new MedicaoTipo();
		MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = new MovimentoRoteiroEmpresa();

		if (arrayImoveisPorRota[0] != null) {
			imovel.setId((Integer) arrayImoveisPorRota[0]);
		}

		if (arrayImoveisPorRota[1] != null) {
			Localidade localidade = new Localidade((Integer) arrayImoveisPorRota[1]);
			imovel.setLocalidade(localidade);
		}

		if (arrayImoveisPorRota[2] != null) {
			SetorComercial setorComercial = new SetorComercial();
			setorComercial.setCodigo(Integer.parseInt(arrayImoveisPorRota[2].toString()));
			imovel.setSetorComercial(setorComercial);
		}
		Quadra quadra = new Quadra();
		if (arrayImoveisPorRota[3] != null) {
			Integer numeroQuadra = (Integer) arrayImoveisPorRota[3];
			quadra.setNumeroQuadra(numeroQuadra);
			imovel.setQuadra(quadra);
		}

		if (arrayImoveisPorRota[4] != null) {
			imovel.setLote(Short.parseShort(arrayImoveisPorRota[4].toString()));
		}

		if (arrayImoveisPorRota[5] != null) {
			imovel.setSubLote(Short.parseShort(arrayImoveisPorRota[5].toString()));
		}

		LigacaoAgua ligacaoAgua = new LigacaoAgua();
		if (arrayImoveisPorRota[6] != null) {
			ligacaoAgua.setId((Integer) arrayImoveisPorRota[6]);
		}

		if (arrayImoveisPorRota[16] != null) {
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoLigacaoAgua = (HidrometroInstalacaoHistorico) arrayImoveisPorRota[16];
			medicaoTipo.setId((Integer) arrayImoveisPorRota[14]);
			hidrometroInstalacaoHistoricoLigacaoAgua.setMedicaoTipo(medicaoTipo);
			ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoLigacaoAgua);
		}

		if (arrayImoveisPorRota[22] != null) {
			ligacaoAgua.setDataSupressao((Date) arrayImoveisPorRota[22]);
		}

		imovel.setLigacaoAgua(ligacaoAgua);

		if (arrayImoveisPorRota[17] != null) {
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel = (HidrometroInstalacaoHistorico) arrayImoveisPorRota[17];
			medicaoTipo.setId((Integer) arrayImoveisPorRota[15]);
			hidrometroInstalacaoHistoricoImovel.setMedicaoTipo(medicaoTipo);
			imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoImovel);
		}
		
		Rota rotaImovel = new Rota(rota.getId());

		if (arrayImoveisPorRota[9] != null) {
			rotaImovel.setIndicadorFiscalizarSuprimido(Short.parseShort(arrayImoveisPorRota[9].toString()));
		}
		if (arrayImoveisPorRota[10] != null) {
			rotaImovel.setIndicadorFiscalizarCortado(Short.parseShort(arrayImoveisPorRota[10].toString()));
		}

		quadra.setRota(rotaImovel);
		imovel.setQuadra(quadra);

		if (arrayImoveisPorRota[11] != null) {
			LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao((Integer) arrayImoveisPorRota[11]);
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		}
		if (arrayImoveisPorRota[12] != null) {
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao((Integer) arrayImoveisPorRota[12]);
			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
		}

		if (arrayImoveisPorRota[33] != null) {
			FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
			faturamentoSituacaoTipo.setId((Integer) arrayImoveisPorRota[33]);
			faturamentoSituacaoTipo.setIndicadorParalisacaoLeitura((Short) arrayImoveisPorRota[13]);
			faturamentoSituacaoTipo.setIndicadorValidoAgua((Short) arrayImoveisPorRota[31]);
			faturamentoSituacaoTipo.setIndicadorValidoEsgoto((Short) arrayImoveisPorRota[32]);
			imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
		}

		if (arrayImoveisPorRota[18] != null) {
			imovel.getLigacaoAguaSituacao().setIndicadorFaturamentoSituacao((Short) arrayImoveisPorRota[18]);
		}

		if (arrayImoveisPorRota[19] != null) {
			imovel.getLigacaoEsgotoSituacao().setIndicadorFaturamentoSituacao((Short) arrayImoveisPorRota[19]);
		}

		if (arrayImoveisPorRota[20] != null) {
			imovel.setNumeroImovel(arrayImoveisPorRota[20].toString());
		}

		if (arrayImoveisPorRota[21] != null) {
			imovel.setNumeroSequencialRota((Integer) arrayImoveisPorRota[21]);
		}
		if (arrayImoveisPorRota[21] != null) {
			imovel.setNumeroSequencialRota((Integer) arrayImoveisPorRota[21]);
		}
		if (arrayImoveisPorRota[23] != null) {
			movimentoRoteiroEmpresa.setNumeroLeituraHidrometro((Integer) arrayImoveisPorRota[23]);
		}
		if (arrayImoveisPorRota[24] != null) {
			movimentoRoteiroEmpresa.setTempoLeitura((Date) arrayImoveisPorRota[24]);
		}
		if (arrayImoveisPorRota[25] != null) {
			movimentoRoteiroEmpresa.setLeituraAnormalidade((LeituraAnormalidade) arrayImoveisPorRota[25]);
		}
		if (arrayImoveisPorRota[26] != null) {
			movimentoRoteiroEmpresa.setDataHoraProcessamento((Date) arrayImoveisPorRota[26]);
		}
		if (arrayImoveisPorRota[27] != null) {
			movimentoRoteiroEmpresa.setLocalidade((Localidade) arrayImoveisPorRota[27]);
		}
		if (arrayImoveisPorRota[28] != null) {
			movimentoRoteiroEmpresa.setFaturamentoGrupo((FaturamentoGrupo) arrayImoveisPorRota[28]);
		}
		if (arrayImoveisPorRota[29] != null) {
			movimentoRoteiroEmpresa.setRota((Rota) arrayImoveisPorRota[29]);
		}
		if (arrayImoveisPorRota[30] != null) {
			movimentoRoteiroEmpresa.setAnoMesMovimento((Integer) arrayImoveisPorRota[30]);
		}

		ImovelPorRotaHelper helper = new ImovelPorRotaHelper();

		helper.setImovel(imovel);
		helper.setMovimentoRoteiroEmpresa(movimentoRoteiroEmpresa);
		
		arrayImoveisPorRota = null;
		
		return helper;
	}

	public void atualizarLeituraAnormalidadeSemCelular(Vector<DadosMovimentacao> dados) throws ControladorException {
		Iterator<DadosMovimentacao> it = dados.iterator();
		FaturamentoGrupo faturamentoGrupo = null;
		Integer anoMesReferencia = null;
		if (dados.size() > 0) {
			try {
				faturamentoGrupo = repositorioMicromedicao.buscarAnoMesReferenciaCasoSistema(dados.get(0).getMatriculaImovel());
				if (faturamentoGrupo != null) {
					anoMesReferencia = faturamentoGrupo.getAnoMesReferencia();

				}

				while (it.hasNext()) {

					DadosMovimentacao dado = it.next();

					Integer leitura = dado.getLeituraHidrometro();
					Integer codAnormalidade = dado.getCodigoAnormalidade();
					Integer idImovel = dado.getMatriculaImovel();

					if (codAnormalidade != null && !codAnormalidade.equals("") && codAnormalidade != 0) {

						FiltroLeituraAnormalidade filtro = new FiltroLeituraAnormalidade(FiltroLeituraAnormalidade.ID);
						filtro.adicionarParametro(new ParametroSimples(FiltroLeituraAnormalidade.INDICADOR_USO,	ConstantesSistema.SIM));
						filtro.adicionarParametro(new ParametroSimples(FiltroLeituraAnormalidade.INDICADOR_USO_SISTEMA, ConstantesSistema.NAO));
						filtro.adicionarParametro(new ParametroSimples(FiltroLeituraAnormalidade.ID, codAnormalidade));

						Collection colecaoLeituraAnormalidade = Fachada.getInstancia().pesquisar(filtro, LeituraAnormalidade.class.getName());

						LeituraAnormalidade leituraAnormalidade = (LeituraAnormalidade) Util.retonarObjetoDeColecao(colecaoLeituraAnormalidade);

						if (leituraAnormalidade != null && !leituraAnormalidade.equals("")) {

							short indicadorLeitura = leituraAnormalidade.getIndicadorLeitura();

							if (leitura == null || leitura == 0) {
								if (indicadorLeitura == 1) {
									throw new ControladorException("atencao.anormalidade_conter_leitura", null, idImovel + "");
								}
							} else {
								if (indicadorLeitura == 2) {
									throw new ControladorException("atencao.anormalidade_nao_leitura", null, idImovel + "");
								}
							}
						} else {
							throw new ControladorException("atencao.anormalidade_inexistente", null, idImovel + "");
						}

					}

					Collection<DadosMovimentacao> colecaoDadosMovimentacao = new ArrayList();
					colecaoDadosMovimentacao.add(dado);

					this.atualizarRoteiro(colecaoDadosMovimentacao, false);

					Date dataLeituraCronograma = this.obterDataRealizacaoDaAtividadeEfetuarLeitura(dado.getDataLeituraCampo(), faturamentoGrupo, anoMesReferencia);
					dado.setDataLeituraCronograma(dataLeituraCronograma);

					this.repositorioMicromedicao.atualizarLeituraAnormailidadeCelular(dado, anoMesReferencia, null);

					Collection<Integer> imoveis = new ArrayList<Integer>();
					imoveis.add(dado.getMatriculaImovel());
					this.consistirLeiturasCalcularConsumosImoveis(faturamentoGrupo, imoveis);

				}

			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

		} else {
			// Lista Vazia para Atualizar
			throw new ControladorException("atencao.lista_vazia");
		}

	}

	/**
	 * Atualiza a Relação de Rota X Leiturista
	 * 
	 * @author Thiago Nascimento
	 * @param leiturista
	 * @param rotas
	 * @throws ControladorException
	 */
	public void atualizarRelacaoRotaLeiturista(Integer leiturista,
			Integer[] rotas) throws ControladorException {

		/*
		 * FiltroRota filtroRota= new FiltroRota();
		 * filtroRota.adicionarParametro(new
		 * ParametroSimples(FiltroRota.LEITURISTA_ID, leiturista));
		 * filtroRota.adicionarCaminhoParaCarregamentoEntidade
		 * (FiltroRota.LEITURISTA);
		 * 
		 * Collection colecao =
		 * getControladorUtil().pesquisar(filtroRota,Rota.class.getName());
		 * 
		 * if(colecao!=null && !colecao.isEmpty()){ try {
		 * this.repositorioMicromedicao.removerRelacaoRotaLeiturista(colecao);
		 * 
		 * } catch (ErroRepositorioException e) {
		 * sessionContext.setRollbackOnly(); new
		 * ControladorException("erro.sistema",e); } }
		 */

		// Criar o leitirista
		Leiturista leit = new Leiturista();
		leit.setId(leiturista);

		for (int i = 0; i < rotas.length; i++) {
			FiltroRota filtroRota = new FiltroRota();
			filtroRota.adicionarParametro(new ParametroSimples(
					FiltroRota.ID_ROTA, rotas[i]));
			filtroRota
					.adicionarCaminhoParaCarregamentoEntidade(FiltroRota.LEITURA_TIPO);
			Collection colecao = getControladorUtil().pesquisar(filtroRota,
					Rota.class.getName());

			if (colecao != null && !colecao.isEmpty()) {
				// Atualizando a Relação Rota Leiturista
				Rota rota = (Rota) colecao.iterator().next();
				rota.setLeiturista(leit);
				rota.setNumeroSequenciaLeitura(new Integer(i + 1));
				rota.setUltimaAlteracao(new Date());

				getControladorUtil().atualizar(rota);

			}

		}

	}

	/**
	 * [UC0763] Gerar Arquivo Texto de Ligacoes com Hidrometro - CAERN
	 * 
	 * @author Tiago Moreno
	 * @date 10/04/2008
	 * 
	 * @param ArquivoTextoLigacoesHidrometroHelper
	 * 
	 * @return
	 * @throws ControladorException
	 */

	public void gerarArquivoTextoLigacoesHidrometro(
			ArquivoTextoLigacoesHidrometroHelper arquivoTextoLigacoesHidrometroHelper)
			throws ControladorException {

		// Recupera os imoveis a serem submetidos ao processo
		Collection<HidrometroInstalacaoHistorico> colecaoHidrometroInstalacaoHistorico = (Collection) this
				.recuperaImoveisArquivoTextoLigacoesHidrometro(arquivoTextoLigacoesHidrometroHelper);

		// verifica se há imoveis para os parametros informados
		if (colecaoHidrometroInstalacaoHistorico == null
				|| colecaoHidrometroInstalacaoHistorico.isEmpty()) {
			throw new ControladorException(
					"atencao.sem_registros_arquivo_texto");
		}

		// joga numa colecao de helper todas as informacoes necessarias
		Collection<StringArquivoTextoLigacoesHidrometroHelper> collectionHelper = this
				.formatarStringArquivoTextoLigacoesHidrometro(colecaoHidrometroInstalacaoHistorico);

		// Arquivo texto final
		StringBuilder arquivoTxFinal = new StringBuilder();

		try {

			int i = 1;

			// itera a colecao do helper montando as linhas
			for (Iterator iter = collectionHelper.iterator(); iter.hasNext();) {
				StringArquivoTextoLigacoesHidrometroHelper helper = (StringArquivoTextoLigacoesHidrometroHelper) iter
						.next();

				// variavel que cria linha por linha
				StringBuilder arquivoTx = new StringBuilder();

				// Matricula Imovel Imovel - 8
				if (helper.getMatriculaImovel() != null
						&& !helper.getMatriculaImovel().equalsIgnoreCase("")) {
					arquivoTx.append(Util.completaString(
							helper.getMatriculaImovel(), 8));
					arquivoTx.append(";");
				} else {
					arquivoTx.append(Util.completaString(" ", 8));
					arquivoTx.append(";");
				}

				// Numero Hidrometro- 1=
				if (helper.getNumeroHidrometro() != null
						&& !helper.getNumeroHidrometro().equalsIgnoreCase("")) {
					arquivoTx.append(Util.completaString(
							helper.getNumeroHidrometro(), 10));
					arquivoTx.append(";");
				} else {
					arquivoTx.append(Util.completaString(" ", 10));
					arquivoTx.append(";");
				}

				// Localizacao hidrometro - 1
				if (helper.getLocalidazacaoHidrometro() != null
						&& !helper.getLocalidazacaoHidrometro()
								.equalsIgnoreCase("")) {
					arquivoTx.append(Util.completaString(
							helper.getLocalidazacaoHidrometro(), 1));
					arquivoTx.append(";");
				} else {
					arquivoTx.append(Util.completaString(" ", 1));
					arquivoTx.append(";");
				}

				// Capacidade Hidrometro - 1
				if (helper.getCapacidadeHidrometro() != null
						&& !helper.getCapacidadeHidrometro().equalsIgnoreCase(
								"")) {
					arquivoTx.append(Util.completaString(
							helper.getCapacidadeHidrometro(), 1));
					arquivoTx.append(";");
				} else {
					arquivoTx.append(Util.completaString(" ", 1));
					arquivoTx.append(";");
				}

				// adicionando a linha no TXT
				arquivoTxFinal.append(arquivoTx.toString());

				// zerando a variavel da linha
				arquivoTx = null;

				// adicionando quebra da linha
				arquivoTxFinal.append(System.getProperty("line.separator"));

				i++;

			}

			System.out.println("CRIANDO O ARQUIVO TEXTO...");

			// criando nome do arquivo
			String nomeZip = null;

			String data = Util.formatarDataSemBarraDDMMAAAA(new Date());

			String hora = Util.formatarHoraSemDataSemDoisPontos(new Date());

			nomeZip = "ARQUIVO_LIGACOES_HIDROMETRO_" + data + "_" + hora;

			BufferedWriter out = null;
			ZipOutputStream zos = null;

			File compactadoTipo = new File(nomeZip + ".zip");
			File leituraTipo = new File(nomeZip + ".txt");

			if (arquivoTxFinal != null && arquivoTxFinal.length() != 0) {
				zos = new ZipOutputStream(new FileOutputStream(compactadoTipo));
				out = new BufferedWriter(new OutputStreamWriter(
						new FileOutputStream(leituraTipo.getAbsolutePath())));
				out.write(arquivoTxFinal.toString());
				out.flush();
				ZipUtil.adicionarArquivo(zos, leituraTipo);
				zos.close();
				leituraTipo.delete();
				out.close();
			}

			// limpa todos os campos
			nomeZip = null;
			out = null;
			zos = null;
			compactadoTipo = null;
			leituraTipo = null;
			arquivoTxFinal = null;

			System.out.println("ARQUIVO TEXTO CRIADO COM SUCESSO!");

		} catch (IOException e) {
			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");
			if (inicioMensagem != null
					&& (inicioMensagem[0].equals("erro") || inicioMensagem[0]
							.equals("atencao"))) {
				throw new ControladorException(mensagem);
			} else {
				throw new ControladorException("erro.sistema", e);
			}
		} catch (Exception e) {
			e.printStackTrace();
			String mensagem = e.getMessage();
			if (mensagem != null) {
				String[] inicioMensagem = mensagem.split("\\.");
				if (inicioMensagem != null
						&& (inicioMensagem[0].equals("erro") || inicioMensagem[0]
								.equals("atencao"))) {
					throw new ControladorException(mensagem);
				} else {
					throw new ControladorException("erro.sistema", e);
				}
			} else {
				throw new ControladorException("erro.sistema", e);
			}
		}
	}

	/**
	 * [UC0763] Gerar Arquivo Texto de Ligacoes com Hidrometro - CAERN
	 * 
	 * @author Tiago Moreno
	 * @date 10/04/2008
	 * 
	 * @param ArquivoTextoLigacoesHidrometroHelper
	 * 
	 * @return
	 * @throws ControladorException
	 */

	public Collection<StringArquivoTextoLigacoesHidrometroHelper> formatarStringArquivoTextoLigacoesHidrometro(
			Collection<HidrometroInstalacaoHistorico> hih)
			throws ControladorException {

		Collection<StringArquivoTextoLigacoesHidrometroHelper> retorno = new ArrayList();

		int i = 1;

		for (Iterator iter = hih.iterator(); iter.hasNext();) {

			HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = (HidrometroInstalacaoHistorico) iter
					.next();

			StringArquivoTextoLigacoesHidrometroHelper objeto = new StringArquivoTextoLigacoesHidrometroHelper();

			// Matricula do Imovel - 8

			if (hidrometroInstalacaoHistorico.getLigacaoAgua() != null) {
				objeto.setMatriculaImovel(Util.adicionarZerosEsquedaNumero(8,
						hidrometroInstalacaoHistorico.getLigacaoAgua().getId()
								.toString()));
			}

			if (hidrometroInstalacaoHistorico != null) {

				// Numero Hidometro - 10
				if (hidrometroInstalacaoHistorico.getHidrometro() != null) {
					objeto.setNumeroHidrometro(Util.completaString(
							hidrometroInstalacaoHistorico.getHidrometro()
									.getNumero(), 10));

					// hidrometro capacidade - 1
					if (hidrometroInstalacaoHistorico.getHidrometro()
							.getHidrometroCapacidade() != null) {
						int hidrCap = hidrometroInstalacaoHistorico
								.getHidrometro().getHidrometroCapacidade()
								.getId();
						int hidrCapFormatado = 0;

						if (hidrCap == 0) {
							hidrCapFormatado = 9;
						} else if (hidrCap > 0 && hidrCap < 9) {
							hidrCapFormatado = hidrCap;
						} else if (hidrCap > 8) {
							hidrCapFormatado = 7;
						}

						objeto.setCapacidadeHidrometro(Util.completaString(
								hidrCapFormatado + "", 1));

					}

				}

				// Localizacao Hidrometro - 1
				if (hidrometroInstalacaoHistorico
						.getHidrometroLocalInstalacao() != null) {
					int localInstalacao = 0;
					int idlocalInstalacao = hidrometroInstalacaoHistorico
							.getHidrometroLocalInstalacao().getId();

					if (idlocalInstalacao < 6) {
						localInstalacao = idlocalInstalacao;
					} else {
						localInstalacao = 5;
					}

					objeto.setLocalidazacaoHidrometro(Util.completaString(
							localInstalacao + "", 1));
				}

			}

			retorno.add(objeto);

			i++;
		}

		return retorno;

	}

	/**
	 * [UC0763] Gerar Arquivo Texto de Ligacoes com Hidrometro - CAERN
	 * 
	 * @author Tiago Moreno
	 * @date 10/04/2008
	 * 
	 * @param ArquivoTextoLigacoesHidrometroHelper
	 * 
	 * @return
	 * @throws ControladorException
	 */

	public Collection<HidrometroInstalacaoHistorico> recuperaImoveisArquivoTextoLigacoesHidrometro(
			ArquivoTextoLigacoesHidrometroHelper arquivoTextoLigacoesHidrometroHelper)
			throws ControladorException {

		return getControladorCadastro()
				.recuperaImoveisArquivoTextoLigacoesHidrometro(
						arquivoTextoLigacoesHidrometroHelper);

	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 24/04/2008
	 * 
	 * @param imovel
	 * @param anoMesReferenciaInicio
	 * @param anoMesReferenciaFim
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection obterUltimosConsumosImovel(Imovel imovel)
			throws ControladorException {

		Collection colecaoArrayConsumoHistorico = null;
		Collection colecaoConsumoHistorico = null;
		try {

			colecaoArrayConsumoHistorico = this.repositorioMicromedicao
					.obterUltimosConsumosImovel(imovel.getId(),
							LigacaoTipo.LIGACAO_AGUA);

			if (colecaoArrayConsumoHistorico != null && !colecaoArrayConsumoHistorico.isEmpty()) {

				colecaoConsumoHistorico = new ArrayList();
				Iterator iterator = colecaoArrayConsumoHistorico.iterator();

				while (iterator.hasNext()) {

					Object[] arrayConsumoHistorico = (Object[]) iterator.next();
					ConsumoHistorico consumoHistorico = this.montarConsumoHistorico(imovel, arrayConsumoHistorico);
					colecaoConsumoHistorico.add(consumoHistorico);
				}
			} else {

				colecaoArrayConsumoHistorico = null;
				if (imovel.getHidrometroInstalacaoHistorico() != null
						&& imovel.getHidrometroInstalacaoHistorico().getId() != null) {
					colecaoArrayConsumoHistorico = this.repositorioMicromedicao
							.obterUltimosConsumosImovel(imovel.getId(),
									LigacaoTipo.LIGACAO_ESGOTO);
				}

				if (colecaoArrayConsumoHistorico != null
						&& !colecaoArrayConsumoHistorico.isEmpty()) {

					colecaoConsumoHistorico = new ArrayList();
					Iterator iterator = colecaoArrayConsumoHistorico.iterator();

					while (iterator.hasNext()) {

						Object[] arrayConsumoHistorico = (Object[]) iterator.next();
						ConsumoHistorico consumoHistorico = this.montarConsumoHistorico(imovel, arrayConsumoHistorico);
						colecaoConsumoHistorico.add(consumoHistorico);
					}
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoConsumoHistorico;
	}

	public ConsumoHistorico obterUltimoConsumoImovel(Imovel imovel, Integer idLigacaoTipo) throws ControladorException {
		ConsumoHistorico consumo = null;
		
		Collection colecaoArrayConsumoHistorico = null;
		Collection colecaoConsumoHistorico = null;
		try {

			if (idLigacaoTipo.equals(LigacaoTipo.LIGACAO_AGUA)) {
			
				colecaoArrayConsumoHistorico = this.repositorioMicromedicao
						.obterUltimosConsumosImovel(imovel.getId(),
								LigacaoTipo.LIGACAO_AGUA);

			} else if (idLigacaoTipo.equals(LigacaoTipo.LIGACAO_ESGOTO)) {
				colecaoArrayConsumoHistorico = this.repositorioMicromedicao
						.obterUltimosConsumosImovel(imovel.getId(),
								LigacaoTipo.LIGACAO_ESGOTO);
			}
				
			if (colecaoArrayConsumoHistorico != null && !colecaoArrayConsumoHistorico.isEmpty()) {
					
				colecaoConsumoHistorico = new ArrayList();
				Iterator iterator = colecaoArrayConsumoHistorico.iterator();
				
				Object[] arrayConsumoHistorico = (Object[]) iterator.next();
				consumo = this.montarConsumoHistorico(imovel, arrayConsumoHistorico);
			} 
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return consumo;
	}
	
	private ConsumoHistorico montarConsumoHistorico(Imovel imovel, Object[] arrayConsumo) {
		
		ConsumoHistorico consumo = new ConsumoHistorico();

		consumo.setImovel(imovel);
		consumo.setId((Integer) arrayConsumo[0]);
		consumo.setReferenciaFaturamento((Integer) arrayConsumo[1]);
		consumo.setNumeroConsumoFaturadoMes((Integer) arrayConsumo[2]);

		if (arrayConsumo[3] != null) {
			ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade((Integer) arrayConsumo[3]);
			consumo.setConsumoAnormalidade(consumoAnormalidade);
		}

		consumo.setLigacaoTipo(new LigacaoTipo((Integer) arrayConsumo[4]));
		
		return consumo;
	}

	
	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT - Registro 2 (DOIS)
	 * 
	 * @author Rafael Francisco Pinto
	 * @date 22/01/2007
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarNumeroConsumoMedioImovel(Integer idImovel,
			Integer anoMesReferencia) throws ControladorException {

		Integer consumoMedio = null;
		try {

			consumoMedio = this.repositorioMicromedicao
					.pesquisarNumeroConsumoMedioImovel(idImovel,
							anoMesReferencia, LigacaoTipo.LIGACAO_AGUA);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return consumoMedio;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Raphael Rossiter
	 * 
	 * @date 24/04/2008
	 * 
	 * @param consumoHistorico
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer obterLeituraAnormalidadeFaturamentoMedicaoHistorico(
			ConsumoHistorico consumoHistorico) throws ControladorException {

		Integer idLeituraAnormalidadeFaturamento = null;
		try {

			idLeituraAnormalidadeFaturamento = this.repositorioMicromedicao
					.obterLeituraAnormalidadeFaturamentoMedicaoHistorico(consumoHistorico);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return idLeituraAnormalidadeFaturamento;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * [SB0006] - Obter dados dos tipos de medição
	 * 
	 * @author Raphael Rossiter
	 * @date 30/04/2008
	 * 
	 * @param imovel
	 * @param anoMesReferencia
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection obterDadosTiposMedicao(Imovel imovel, Integer anoMesReferencia) throws ControladorException {

		Collection colecaoDadosMedicaoHistorico = null;
		try {

			Collection colecaoDadosInstalacaoHidrometro = this.repositorioMicromedicao.obterDadosTiposMedicaoHidrometro(imovel);

			if (colecaoDadosInstalacaoHidrometro != null && !colecaoDadosInstalacaoHidrometro.isEmpty()) {
				Iterator ite = colecaoDadosInstalacaoHidrometro.iterator();
				Object[] dadosHidrometro = null;
				colecaoDadosMedicaoHistorico = new ArrayList();
				
				while (ite.hasNext()) {
					Object[] dadosInstalacao = (Object[]) ite.next();
					if (dadosInstalacao != null) {
				
						dadosHidrometro = new Object[15];
						// numero hidrometro
						dadosHidrometro[0] = dadosInstalacao[0];
						// numero digitos leitura
						dadosHidrometro[1] = dadosInstalacao[1];
						// data instalação hidrometro
						dadosHidrometro[2] = dadosInstalacao[2];
						// leitura instalação hidrometro
						dadosHidrometro[3] = dadosInstalacao[3];
						// data instalação hidrometro
						dadosHidrometro[4] = dadosInstalacao[4];
						// leitura situação
						dadosHidrometro[5] = LeituraSituacao.NAO_REALIZADA;
						// Consumo médio do Hidrômetro
						dadosHidrometro[6] = 0;
						// Data leitura atual informada
						dadosHidrometro[10] = null;
						//Leitura Atual Informada
						dadosHidrometro[12] = null;
						//Leitura Instalação hidrometro
						 dadosHidrometro[13] = dadosInstalacao[3];
						
						// id da ligação de água
						if (dadosInstalacao[5] != null
								&& !((Integer) dadosInstalacao[5]).equals(0)) {
							Integer idLigacaoAgua = (Integer) dadosInstalacao[5];
							Object[] dadosMedicaoHistorico = this.repositorioMicromedicao
									.obterDadosTiposMedicao(null,
											idLigacaoAgua, anoMesReferencia);
							if (dadosMedicaoHistorico != null) {
								// leitura atual faturamento
								dadosHidrometro[3] = dadosMedicaoHistorico[0];
								// data leitura atual faturamento
								dadosHidrometro[4] = dadosMedicaoHistorico[1];
								// leitura situação
								dadosHidrometro[5] = dadosMedicaoHistorico[2];
								// Consumo médio do Hidrômetro
								dadosHidrometro[6] = dadosMedicaoHistorico[3];
								/* Alteração para enviar na rota a data da Leitura 
								  * Anterior Faturada*/
								// Data leitura atual informada
								if(dadosMedicaoHistorico[5] != null){
								 	dadosHidrometro[10] = dadosMedicaoHistorico[5];
								 }
								//Leitura Atual Informada
								 /* Alteração para enviar na rota a Leitura 
								  * Anterior Faturada*/
								 if(dadosMedicaoHistorico[4] != null){
									 	dadosHidrometro[12] = dadosMedicaoHistorico[4];
								 }
							} else {
								Integer anoMesReferenciaMenos2 = Util
										.subtrairMesDoAnoMes(anoMesReferencia,
												1);
								dadosMedicaoHistorico = this.repositorioMicromedicao
										.obterDadosTiposMedicao(null,
												idLigacaoAgua,
												anoMesReferenciaMenos2);
								if (dadosMedicaoHistorico != null) {
									// leitura atual faturamento
									dadosHidrometro[3] = dadosMedicaoHistorico[0];
									// data leitura atual faturamento
									dadosHidrometro[4] = dadosMedicaoHistorico[1];
									// leitura situação
									dadosHidrometro[5] = dadosMedicaoHistorico[2];
									// Consumo médio do Hidrômetro
									dadosHidrometro[6] = dadosMedicaoHistorico[3];
									// Data leitura atual informada
									/* Alteração para enviar na rota a data da Leitura 
									  * Anterior Faturada*/
									 if(dadosMedicaoHistorico[5] != null){
									 	dadosHidrometro[10] = dadosMedicaoHistorico[5];
									 }
									//Leitura Atual Informada
									 /* Alteração para enviar na rota a Leitura 
									  * Anterior Faturada*/
									 if(dadosMedicaoHistorico[4] != null){
										 	dadosHidrometro[12] = dadosMedicaoHistorico[4];
									 }
								}
							}
						}
						// id do Imóvel
						if (dadosInstalacao[6] != null
								&& !((Integer) dadosInstalacao[6]).equals(0)) {
							Integer idImovel = (Integer) dadosInstalacao[6];
							Object[] dadosMedicaoHistorico = this.repositorioMicromedicao
									.obterDadosTiposMedicao(idImovel, null,
											anoMesReferencia);
							if (dadosMedicaoHistorico != null) {
								// leitura atual faturamento
								dadosHidrometro[3] = dadosMedicaoHistorico[0];
								// data leitura atual faturamento
								dadosHidrometro[4] = dadosMedicaoHistorico[1];
								// leitura situação
								dadosHidrometro[5] = dadosMedicaoHistorico[2];
								// Consumo médio do Hidrômetro
								dadosHidrometro[6] = dadosMedicaoHistorico[3];
								// Data leitura atual informada
								/* Alteração para enviar na rota a data da Leitura 
								  * Anterior Faturada*/
								if(dadosMedicaoHistorico[5] != null){
									dadosHidrometro[10] = dadosMedicaoHistorico[5];
								}
								//Leitura Atual Informada
								 /* Alteração para enviar na rota a Leitura 
								  * Anterior Faturada*/
								 if(dadosMedicaoHistorico[4] != null){
									 	dadosHidrometro[12] = dadosMedicaoHistorico[4];
									 }

							} else {
								Integer anoMesReferenciaMenos2 = Util
										.subtrairMesDoAnoMes(anoMesReferencia,
												1);

								dadosMedicaoHistorico = this.repositorioMicromedicao
										.obterDadosTiposMedicao(idImovel, null,
												anoMesReferenciaMenos2);
								if (dadosMedicaoHistorico != null) {
									// leitura atual faturamento
									dadosHidrometro[3] = dadosMedicaoHistorico[0];
									// data leitura atual faturamento
									dadosHidrometro[4] = dadosMedicaoHistorico[1];
									// leitura situação
									dadosHidrometro[5] = dadosMedicaoHistorico[2];
									// Consumo médio do Hidrômetro
									dadosHidrometro[6] = dadosMedicaoHistorico[3];
									// Data leitura atual informada
									/* Alteração para enviar na rota a data da Leitura 
									  * Anterior Faturada*/
									 if(dadosMedicaoHistorico[5] != null){
									 	dadosHidrometro[10] = dadosMedicaoHistorico[5];
									 }
									//Leitura Atual Informada
									 /* Alteração para enviar na rota a Leitura 
									  * Anterior Faturada*/
									 if(dadosMedicaoHistorico[4] != null){
										 	dadosHidrometro[12] = dadosMedicaoHistorico[4];
										 }
								}
							}
						}
						// Ligação Água
						dadosHidrometro[7] = dadosInstalacao[5];
						// Imóvel
						dadosHidrometro[8] = dadosInstalacao[6];
						// Descrição da Local de Instalação do Hidrômetro
						dadosHidrometro[9] = dadosInstalacao[7];

						// TIPO DE RATEIO
						dadosHidrometro[11] = dadosInstalacao[8];

						// adiciona os dados do hidrômetro na coleção
						colecaoDadosMedicaoHistorico.add(dadosHidrometro);
					}
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoDadosMedicaoHistorico;
	}

	/**
	 * 
	 * O ultimo sequencia para o id do leiturista passado como parametro
	 * 
	 * @author Thiago Nascimento
	 * @param leit
	 * @return
	 * @throws ControladorException
	 */
	public Integer numeroSequenciaUltimaRota(Integer leit)
			throws ControladorException {
		Integer ultimo = null;

		try {
			ultimo = this.repositorioMicromedicao
					.numeroSequenciaUltimaRota(leit);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		if (ultimo == null) {
			ultimo = new Integer(-1);
		}

		return ultimo;
	}

	/**
	 * 
	 * Retorno o valor máximo do Id do Leiturista.
	 * 
	 * @author Thiago Nascimento
	 * @return
	 * @throws ControladorException
	 */
	public Integer maximoIdLeiturista() throws ControladorException {
		try {
			return this.repositorioMicromedicao.maximoIdLeiturista();
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * 
	 * Retorna a quantidade de Leitura feitas na Rota para o AnoMes de
	 * referencia.
	 * 
	 * @author Thiago Nascimento
	 * @return
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public Integer quantidadeLeiturasRealizada(Integer rota, Integer anoMes,
			Integer idServicoTipoCelular) throws ControladorException {
		try {
			return this.repositorioMicromedicao.quantidadeLeiturasRealizada(
					rota, anoMes, idServicoTipoCelular);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0800] - Obter Consumo Não Medido
	 * 
	 * @author Raphael Rossiter
	 * @date 22/05/2008
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer obterConsumoNaoMedidoSemTarifa(Integer idImovel,
 Integer anoMesReferencia) throws ControladorException {

		Integer consumoNaoMedido = 0;

		// [UC0801] - Obter Quantidade de Economias por Subcategoria
		Collection<Subcategoria> colecaoSubcategoria = this.getControladorImovel().obterQuantidadeEconomiasSubCategoria(idImovel);

		// [UC0810] Obter Quantidade de Economias Virtuais
		Integer qtdEconomiasVirtuais = this.getControladorImovel().obterQuantidadeEconomiasVirtuais(idImovel);

		// [FS0001] - Verificar Área Não Informada
		BigDecimal areaConstruida = this.verificarAreaNaoInformada(idImovel);

		// Área Virtual = área construída do imóvel / quantidade de economias
		// virtuais
		BigDecimal areaConstruidaVirtual = areaConstruida.divide(new BigDecimal(qtdEconomiasVirtuais), 2, BigDecimal.ROUND_HALF_UP);

		if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {

			Iterator iterator = colecaoSubcategoria.iterator();

			while (iterator.hasNext()) {

				Subcategoria subcategoria = (Subcategoria) iterator.next();
				
				Integer consumoMinimo = this.pesquisarConsumoMinimoArea(areaConstruidaVirtual, anoMesReferencia, subcategoria, null);

				// Caso a categoria associada à subcategoria tenha fator de economias diferente de NULO
				if (subcategoria.getCategoria().getFatorEconomias() != null) {

					// Multiplica o consumo mínimo pelo fator obtido.
					consumoNaoMedido = consumoNaoMedido + (consumoMinimo * subcategoria.getCategoria().getFatorEconomias().intValue());
				} else {
					// Multiplica o consumo mínimo pela quantidade de economias
					// da subcategoria.
					consumoNaoMedido = consumoNaoMedido + (consumoMinimo * subcategoria.getQuantidadeEconomias());
				}
			}
		}

		return consumoNaoMedido;
	}

	/**
	 * [UC0800] - Obter Consumo Não Medido
	 * 
	 * [FS0001] - Verificar Área Não Informada
	 * 
	 * @author Raphael Rossiter
	 * @date 22/05/2008
	 * 
	 * @param idImovel
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	protected BigDecimal verificarAreaNaoInformada(Integer idImovel)
			throws ControladorException {

		BigDecimal areaConstruida = null;

		Object[] dadosAreaConstruida = null;
		try {

			dadosAreaConstruida = this.repositorioImovel
					.pesquisarAreaConstruida(idImovel);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		areaConstruida = (BigDecimal) dadosAreaConstruida[0];
		Integer menorFaixa = (Integer) dadosAreaConstruida[1];

		/*
		 * Caso não exista área construída para o imóvel e exista faixa de área
		 * para o mesmo: O sistema deverá obter a menor área da faixa informada.
		 */
		if (areaConstruida == null) {

			if (menorFaixa != null) {
				areaConstruida = new BigDecimal(menorFaixa);
			} else {
				areaConstruida = BigDecimal.ONE;
			}

		}

		return areaConstruida;
	}

	/**
	 * [UC0800] - Obter Consumo Não Medido
	 * 
	 * Obter o consumo mínimo associado à faixa de área do imóvel e a categoria
	 * ou subcategoria informada
	 * 
	 * @author Raphael Rossiter
	 * @date 22/05/2008
	 * 
	 * @param areaConstruida
	 * @param anoMesReferencia
	 * @param subcategoria
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarConsumoMinimoArea(BigDecimal areaConstruida,
			Integer anoMesReferencia, Subcategoria subcategoria,
			Categoria categoria) throws ControladorException {

		Integer consumoMinimoArea = null;

		Integer idCategoria = null;

		if (subcategoria != null) {

			idCategoria = subcategoria.getCategoria().getId();

			try {

				consumoMinimoArea = this.repositorioMicromedicao
						.pesquisarConsumoMinimoArea(areaConstruida,
								anoMesReferencia, subcategoria.getId(), null);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

		} else {
			idCategoria = categoria.getId();
		}

		// Caso não seja encontrado o consumo para subcategoria, será utilizado
		// o consumo da categoria.
		if (subcategoria == null || consumoMinimoArea == null) {

			try {

				consumoMinimoArea = this.repositorioMicromedicao
						.pesquisarConsumoMinimoArea(areaConstruida,
								anoMesReferencia, null, idCategoria);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

		return consumoMinimoArea;
	}

	/**
	 * Atualiza o FaturamentoAtividadeCronograma do grupo no anoMes especificado
	 * para o Registrar, Consistir e Efetuar Leitura.
	 * 
	 * [UC0712] Atualizar Leituras e Anormalidades do Celular
	 * 
	 * @author Thiago Nascimento
	 * @date 23/05/2008
	 * 
	 * 
	 * @param grupo
	 * @param anoMesReferencia
	 * @throws ControladorException
	 */
	public void atualizarFaturamentoAtividadeCronogramaRegistrarConsistirEfetuarLeitura(
			Integer grupo, Date dataRealizacao) throws ControladorException {
		try {
			FaturamentoGrupo faturamentoGrupo = repositorioMicromedicao
					.buscarAnoMesReferenciaCasoOperador(grupo);
			this.repositorioMicromedicao
					.atualizarFaturamentoAtividadeCronogramaRegistrarConsistirEfetuarLeitura(
							grupo, faturamentoGrupo.getAnoMesReferencia(),
							dataRealizacao);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Adaptação do batch que efetua o Rateio do consumo para todos os imóveis
	 * de uma rota que sejam imóvel condominio
	 * 
	 * [UC0103] - Efetuar Rateio de Consumo
	 * 
	 * @author Thiago Nascimento
	 * @date 27/03/2008
	 * 
	 * @param rota
	 * @param anoMesFaturamento
	 * @throws ControladorException
	 */
	// public void efetuarRateioDeConsumoPorRota(Rota rota,
	// Integer anoMesFaturamento)throws ControladorException {
	//
	//
	// try {
	//
	// /*
	// * Pesquisa todos os imóveis condominio que tenham situação de água
	// * igual a ligado ou cortado ou que tenham situação de esgoto igual
	// * a ligado ou que tenha hidrometro.
	// */
	// Collection colImoveisCondominio =
	// this.pesquisarImovelCondominioParaCalculoDoRateioPorRota(rota);
	//
	// // Efetuamos o rateio
	// efetuarRateioDeConsumo( colImoveisCondominio, anoMesFaturamento );
	//
	// } catch (Exception e) {
	// sessionContext.setRollbackOnly();
	// throw new EJBException(e);
	// }
	//
	// }

	/**
	 * [UC0805] - Gerar Aviso de Anormalidade
	 * 
	 * Pesquisa os dados necessérios para a geração do relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 03/06/2008
	 * 
	 * @param colecaoImoveis
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<AvisoAnormalidadeRelatorioHelper> pesquisarAvisoAnormalidadeRelatorio(
			Collection colecaoImoveis, Integer anoMes)
			throws ControladorException {

		Collection<AvisoAnormalidadeRelatorioHelper> retorno = new ArrayList<AvisoAnormalidadeRelatorioHelper>();

		try {
			Collection<Object[]> colecaoDadosRelatorio = repositorioMicromedicao
					.pesquisarAvisoAnormalidadeRelatorio(colecaoImoveis, anoMes);

			if (colecaoDadosRelatorio != null
					&& !colecaoDadosRelatorio.isEmpty()) {
				for (Object[] dadosRelatorio : colecaoDadosRelatorio) {
					montarAvisoAnormalidadeRelatorioHelper(anoMes, retorno,
							dadosRelatorio);
				}

			}

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return retorno;
	}

	/**
	 * [UC0805] - Gerar Aviso de Anormalidade
	 * 
	 * Pesquisa os dados necessérios para a geração do relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 03/06/2008
	 * 
	 * @param colecaoImoveis
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<AvisoAnormalidadeRelatorioHelper> pesquisarAvisoAnormalidadeRelatorio(
			FiltrarAnaliseExcecoesLeiturasHelper filtrarAnaliseExcecoesLeiturasHelper,
			Integer anoMes) throws ControladorException {

		Collection<AvisoAnormalidadeRelatorioHelper> retorno = new ArrayList<AvisoAnormalidadeRelatorioHelper>();

		try {
			Collection<Object[]> colecaoDadosRelatorio = repositorioMicromedicao
					.pesquisarAvisoAnormalidadeRelatorio(
							filtrarAnaliseExcecoesLeiturasHelper, anoMes);

			if (colecaoDadosRelatorio != null
					&& !colecaoDadosRelatorio.isEmpty()) {
				for (Object[] dadosRelatorio : colecaoDadosRelatorio) {
					montarAvisoAnormalidadeRelatorioHelper(anoMes, retorno,
							dadosRelatorio);
				}

			}

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return retorno;
	}

	private void montarAvisoAnormalidadeRelatorioHelper(Integer anoMes,
			Collection<AvisoAnormalidadeRelatorioHelper> retorno,
			Object[] dadosRelatorio) throws ControladorException {
		AvisoAnormalidadeRelatorioHelper avisoAnormalidadeRelatorioHelper = new AvisoAnormalidadeRelatorioHelper();

		// Nome do Cliente
		if (dadosRelatorio[0] != null) {
			avisoAnormalidadeRelatorioHelper
					.setNomeCliente((String) dadosRelatorio[0]);
		}

		// Id do Imóvel
		if (dadosRelatorio[1] != null) {
			avisoAnormalidadeRelatorioHelper
					.setIdImovel((Integer) dadosRelatorio[1]);
		}

		// Código da Rota
		if (dadosRelatorio[2] != null) {
			avisoAnormalidadeRelatorioHelper
					.setCodigoRota((Short) dadosRelatorio[2]);
		}

		// Sequencial da Rota
		if (dadosRelatorio[3] != null) {
			avisoAnormalidadeRelatorioHelper
					.setSequencialRota((Integer) dadosRelatorio[3]);
		}

		// Nome do Município
		if (dadosRelatorio[4] != null) {
			avisoAnormalidadeRelatorioHelper
					.setNomeMunicipio((String) dadosRelatorio[4]);
		}

		// Endereço
		String endereco = getControladorEndereco().pesquisarEnderecoFormatado(
				avisoAnormalidadeRelatorioHelper.getIdImovel());
		avisoAnormalidadeRelatorioHelper.setEndereco(endereco);

		// Inscrição
		String inscricao = getControladorImovel().pesquisarInscricaoImovel(
				avisoAnormalidadeRelatorioHelper.getIdImovel());
		avisoAnormalidadeRelatorioHelper.setInscricao(inscricao);

		// Mês/Ano de Referência
		avisoAnormalidadeRelatorioHelper.setAnoMes(anoMes);

		// Verifica se o imóvel tem alguma anormalidade
		if (dadosRelatorio[5] != null || dadosRelatorio[6] != null) {

			Integer consumoFaturado = null;
			Integer consumoMedio = null;

			// Descrição da Anormalidade de Consumo Água
			if (dadosRelatorio[5] != null) {
				avisoAnormalidadeRelatorioHelper
						.setDescricaoAnormalidadeConsumo((String) dadosRelatorio[5]);

				// Consumo Faturado Água
				if (dadosRelatorio[7] != null) {
					consumoFaturado = (Integer) dadosRelatorio[7];
					avisoAnormalidadeRelatorioHelper
							.setConsumoFaturado(consumoFaturado);
				}

				// Consumo Médio Água
				if (dadosRelatorio[8] != null) {
					consumoMedio = (Integer) dadosRelatorio[8];
					avisoAnormalidadeRelatorioHelper
							.setConsumoMedio(consumoMedio);
				}

				// Consumo Medido Água
				if (dadosRelatorio[9] != null) {
					avisoAnormalidadeRelatorioHelper
							.setConsumoMedido((Integer) dadosRelatorio[9]);
				}

			}
			// Descrição da Anormalidade de Consumo Esgoto
			else {
				avisoAnormalidadeRelatorioHelper
						.setDescricaoAnormalidadeConsumo((String) dadosRelatorio[6]);

				// Consumo Faturado Esgoto
				if (dadosRelatorio[10] != null) {
					consumoFaturado = (Integer) dadosRelatorio[9];
					avisoAnormalidadeRelatorioHelper
							.setConsumoFaturado(consumoFaturado);
				}

				// Consumo Médio Esgoto
				if (dadosRelatorio[11] != null) {
					consumoMedio = (Integer) dadosRelatorio[10];
					avisoAnormalidadeRelatorioHelper
							.setConsumoMedio(consumoMedio);
				}

				// Consumo Medido Esgoto
				if (dadosRelatorio[12] != null) {
					avisoAnormalidadeRelatorioHelper
							.setConsumoMedido((Integer) dadosRelatorio[12]);
				}
			}

			BigDecimal variacaoConsumo = this.calcularVariacaoConsumo(
					consumoFaturado, consumoMedio);

			if (variacaoConsumo != null) {
				avisoAnormalidadeRelatorioHelper
						.setVariacaoConsumo(variacaoConsumo
								.divide(new BigDecimal(100)));
			}

			retorno.add(avisoAnormalidadeRelatorioHelper);
		}
	}

	private BigDecimal calcularVariacaoConsumo(Integer consumoFaturado,
			Integer consumoMedio) {

		BigDecimal retorno = null;

		if (consumoFaturado != null && consumoFaturado.intValue() != 0
				&& consumoMedio != null && consumoMedio.intValue() != 0) {

			retorno = new BigDecimal(0);

			retorno = retorno.add(new BigDecimal(consumoFaturado)).subtract(
					new BigDecimal(consumoMedio));
			retorno = retorno.multiply(new BigDecimal(100));
			retorno = retorno.divide(new BigDecimal(consumoMedio), 2,
					BigDecimal.ROUND_HALF_UP);

		}

		return retorno;
	}

	/**
	 * [UC0805] - Gerar Aviso de Anormalidade
	 * 
	 * Pesquisa a quantidade de registros do relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 28/06/2008
	 * 
	 * @param gerarDadosLeituraHelper
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDadosParaLeituraRelatorioCount(
			GerarDadosLeituraHelper gerarDadosLeituraHelper)
			throws ControladorException {
		try {
			return this.repositorioMicromedicao
					.pesquisarDadosParaLeituraRelatorioCount(gerarDadosLeituraHelper);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0805] - Gerar Aviso de Anormalidade
	 * 
	 * Pesquisa os dados necessérios para a geração do relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 28/06/2008
	 * 
	 * @param gerarDadosLeituraHelper
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<RelatorioGerarDadosLeituraBean> pesquisarDadosParaLeituraRelatorio(
			GerarDadosLeituraHelper gerarDadosLeituraHelper)
			throws ControladorException {

		Collection<RelatorioGerarDadosLeituraBean> retorno = new ArrayList<RelatorioGerarDadosLeituraBean>();

		SistemaParametro sistemaParametro = getControladorUtil()
				.pesquisarParametrosDoSistema();

		try {
			Collection<Object[]> colecaoDadosRelatorio = repositorioMicromedicao
					.pesquisarDadosParaLeituraRelatorio(
							gerarDadosLeituraHelper,
							sistemaParametro.getNomeAbreviadoEmpresa());

			if (colecaoDadosRelatorio != null
					&& !colecaoDadosRelatorio.isEmpty()) {
				for (Object[] dadosRelatorio : colecaoDadosRelatorio) {
					montarRelatorioGerarDadosLeituraBean(retorno,
							dadosRelatorio);
				}
			}

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return retorno;
	}

	private void montarRelatorioGerarDadosLeituraBean(
			Collection<RelatorioGerarDadosLeituraBean> retorno,
			Object[] dadosRelatorio) throws ControladorException {

		RelatorioGerarDadosLeituraBean gerarDadosLeituraBean = new RelatorioGerarDadosLeituraBean();

		// Mês/Ano
		if (dadosRelatorio[0] != null) {
			Integer anoMes = (Integer) dadosRelatorio[0];
			gerarDadosLeituraBean.setAnoMes(Util
					.formatarAnoMesParaMesAno(anoMes));
		}

		// Grupo de Faturamento
		if (dadosRelatorio[1] != null) {
			gerarDadosLeituraBean.setGrupo((String) dadosRelatorio[1]);
		}

		// Localidade
		if (dadosRelatorio[2] != null) {
			String localidadeFormatada = dadosRelatorio[2] + " - "
					+ dadosRelatorio[3];
			gerarDadosLeituraBean.setLocalidade(localidadeFormatada);
		}

		// Data Prevista
		if (dadosRelatorio[4] != null) {
			Date dataPrevista = (Date) dadosRelatorio[4];
			gerarDadosLeituraBean.setDataPrevista(Util
					.formatarData(dataPrevista));
		}

		// Rota
		if (dadosRelatorio[5] != null) {
			Short codigoRota = (Short) dadosRelatorio[5];
			gerarDadosLeituraBean.setRota(codigoRota.toString());
		}

		// Leiturista
		if (dadosRelatorio[6] != null) {
			gerarDadosLeituraBean.setLeiturista((String) dadosRelatorio[6]);
		} else {
			gerarDadosLeituraBean.setLeiturista("");
		}

		// Endereço
		if (dadosRelatorio[7] != null) {
			gerarDadosLeituraBean.setEndereco((String) dadosRelatorio[7]);
		} else {
			gerarDadosLeituraBean.setEndereco("");
		}

		// Inscrição
		if (dadosRelatorio[8] != null) {
			gerarDadosLeituraBean.setInscricao((String) dadosRelatorio[8]);
		} else {
			gerarDadosLeituraBean.setInscricao("");
		}

		// Nome Cliente
		if (dadosRelatorio[9] != null) {
			gerarDadosLeituraBean.setNomeCliente((String) dadosRelatorio[9]);
		} else {
			gerarDadosLeituraBean.setNomeCliente("");
		}

		String economias = "";

		// Categoria 1
		if (dadosRelatorio[10] != null) {
			economias = economias
					+ dadosRelatorio[10]
					+ Util.adicionarZerosEsquedaNumero(3,
							((Short) dadosRelatorio[11]).toString());
			gerarDadosLeituraBean.setCategoria((String) dadosRelatorio[10]);
		} else {
			gerarDadosLeituraBean.setCategoria("");
		}

		// Categoria 2
		if (dadosRelatorio[12] != null) {
			economias = economias
					+ ", "
					+ dadosRelatorio[12]
					+ Util.adicionarZerosEsquedaNumero(3,
							((Short) dadosRelatorio[13]).toString());
		}

		gerarDadosLeituraBean.setEconomias(economias);

		// Situação da Ligação de Água
		if (dadosRelatorio[14] != null) {
			gerarDadosLeituraBean
					.setSituacaoLigacaoAgua((String) dadosRelatorio[14]);
		} else {
			gerarDadosLeituraBean.setSituacaoLigacaoAgua("");
		}

		// Situação da Ligação de Esgoto
		if (dadosRelatorio[15] != null) {
			gerarDadosLeituraBean
					.setSituacaoLigacaoEsgoto((String) dadosRelatorio[15]);
		} else {
			gerarDadosLeituraBean.setSituacaoLigacaoEsgoto("");
		}

		// Imóvel Perfil
		if (dadosRelatorio[16] != null) {
			Integer idImovelPerfil = (Integer) dadosRelatorio[16];

			// Verifica se é um grande consumidor
			if (idImovelPerfil.equals(ImovelPerfil.GRANDE)) {
				gerarDadosLeituraBean.setGrandeConsumidor("*");
			} else {
				gerarDadosLeituraBean.setGrandeConsumidor("");
			}
		} else {
			gerarDadosLeituraBean.setGrandeConsumidor("");
		}

		// Número do Hidrômetro
		if (dadosRelatorio[17] != null) {
			gerarDadosLeituraBean
					.setNumeroHidrometro((String) dadosRelatorio[17]);
		} else {
			gerarDadosLeituraBean.setNumeroHidrometro("");
		}

		// Consumo Médio
		if (dadosRelatorio[18] != null) {
			gerarDadosLeituraBean.setMedia(((Integer) dadosRelatorio[18])
					.toString());
		} else {
			gerarDadosLeituraBean.setMedia("");
		}

		// Sequencial da Rota
		if (dadosRelatorio[19] != null) {
			gerarDadosLeituraBean.setSequencia(((Integer) dadosRelatorio[19])
					.toString());
		} else {
			gerarDadosLeituraBean.setSequencia("");
		}

		// Sublote
		if (dadosRelatorio[20] != null) {
			gerarDadosLeituraBean
					.setComplementoSequenciaLeitura((String) dadosRelatorio[20]);
		} else {
			gerarDadosLeituraBean.setComplementoSequenciaLeitura("");
		}

		// Id imovel
		if (dadosRelatorio[21] != null) {
			gerarDadosLeituraBean
					.setMatriculaImovel((String) dadosRelatorio[21]);
		} else {
			gerarDadosLeituraBean.setMatriculaImovel("");
		}

		retorno.add(gerarDadosLeituraBean);
	}

	/**
	 * 
	 * [UC0781] - Informar Consumo por Área
	 * 
	 * @author Rômulo Aurélio
	 * @date 21/05/2008
	 * 
	 * @param anoMesReferenciaInformado
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarAnoMesReferenciaMenorAnoMesReferenciaFaturamentoGrupo(
			int anoMesReferenciaInformado) throws ControladorException {

		Integer qtde = 0;

		try {
			qtde = repositorioMicromedicao
					.pesquisarAnoMesReferenciaMenorAnoMesReferenciaFaturamentoGrupo(anoMesReferenciaInformado);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return qtde;
	}

	/**
	 * 
	 * [UC0781] - Informar Consumo por Área
	 * 
	 * Inserir/Atualizar consumoMinimoArea
	 * 
	 * @author Rômulo Aurélio
	 * @date 26/05/2008
	 * 
	 * @param anoMesReferenciaInformado
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Integer informarConsumoMinimoArea(
			Collection colecaoConsumoMinimoArea,
			Collection colecaoConsumoMinimoAreaBase, Usuario usuarioLogado)
			throws ControladorException {

		Integer qtd = 0;

		Iterator colecaoConsumoMinimoAreaIterator = colecaoConsumoMinimoArea
				.iterator();

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_CONSUMO_AREA_INFORMAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CONSUMO_AREA_INFORMAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		if (!colecaoConsumoMinimoAreaBase.isEmpty()) {
			Iterator colecaoConsumoMinimoAreaBaseIterator = colecaoConsumoMinimoAreaBase
					.iterator();

			/**
			 * Remove todos os consumos Minimos da base
			 */

			while (colecaoConsumoMinimoAreaBaseIterator.hasNext()) {

				ConsumoMinimoArea consumoMinimoArea = (ConsumoMinimoArea) colecaoConsumoMinimoAreaBaseIterator
						.next();

				consumoMinimoArea.setOperacaoEfetuada(operacaoEfetuada);
				consumoMinimoArea.adicionarUsuario(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(consumoMinimoArea);

				getControladorUtil().remover(consumoMinimoArea);

			}
		}

		while (colecaoConsumoMinimoAreaIterator.hasNext()) {

			ConsumoMinimoArea consumoMinimoArea = (ConsumoMinimoArea) colecaoConsumoMinimoAreaIterator
					.next();

			consumoMinimoArea.setOperacaoEfetuada(operacaoEfetuada);
			consumoMinimoArea.adicionarUsuario(usuarioLogado,
					UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(consumoMinimoArea);

			getControladorUtil().inserir(consumoMinimoArea);

			qtd++;

		}

		return qtd;
	}

	/**
	 * [UC0105] Obter Consumo Mínimo da Ligação
	 * 
	 * @author Raphael Rossiter
	 * @date 11/04/2007
	 * 
	 * @return imovel, colecaoSubcategoria
	 * @throws ControladorException
	 */
	public int obterConsumoMinimoLigacao(Imovel imovel,
			Collection colecaoCategoriaOUSubcategoria)
			throws ControladorException {

		int consumoMinimoLigacao = 0;

		// Verificando se a empresa fatura por CATEGORIA ou SUBCATEGORIA
		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (sistemaParametro.getIndicadorTarifaCategoria().equals(
				SistemaParametro.INDICADOR_TARIFA_CATEGORIA)) {

			if (colecaoCategoriaOUSubcategoria == null
					|| colecaoCategoriaOUSubcategoria.isEmpty()) {

				// [UC0801] - Obter Quantidade de Economias por Categoria
				colecaoCategoriaOUSubcategoria = this.getControladorImovel()
						.obterQuantidadeEconomiasCategoria(imovel);
			}

			consumoMinimoLigacao = this.obterConsumoMinimoLigacaoPorCategoria(
					imovel, colecaoCategoriaOUSubcategoria);
		} else {

			if (colecaoCategoriaOUSubcategoria == null
					|| colecaoCategoriaOUSubcategoria.isEmpty()) {

				// [UC0801] - Obter Quantidade de Economias por Subcategoria
				colecaoCategoriaOUSubcategoria = this.getControladorImovel()
						.obterQuantidadeEconomiasSubCategoria(imovel.getId());
			}

			consumoMinimoLigacao = this
					.obterConsumoMinimoLigacaoPorSubcategoria(imovel,
							colecaoCategoriaOUSubcategoria);
		}

		return consumoMinimoLigacao;
	}

	/**
	 * [UC0105] Obter Consumo Mínimo da Ligação
	 * 
	 * @author Raphael Rossiter
	 * @date 11/04/2007
	 * 
	 * @return imovel, colecaoSubcategoria
	 * @throws ControladorException
	 */
	public int obterConsumoMinimoLigacaoPorSubcategoria(Imovel imovel,
			Collection colecaoCategoriaOUSubcategoria)
			throws ControladorException {

		int consumoMinimoLigacao = 0;

		if (colecaoCategoriaOUSubcategoria != null
				&& !colecaoCategoriaOUSubcategoria.isEmpty()) {

			// Pesquisando a vigência da tarifa do imóvel.
			ConsumoTarifaVigencia consumoTarifaVigencia = this
					.pesquisarConsumoTarifaVigencia(imovel);

			Iterator iterator = colecaoCategoriaOUSubcategoria.iterator();

			while (iterator.hasNext()) {

				Subcategoria subcategoria = (Subcategoria) iterator.next();

				Integer consumoMinimoTarifa = this
						.pesquisarConsumoMinimoTarifaCategoriaPorSubcategoria(
								consumoTarifaVigencia, subcategoria);

				// Caso a categoria associada à subcategoria tenha fator de
				// economias diferente de NULO
				if (subcategoria.getCategoria().getFatorEconomias() != null) {

					// Multiplica o consumo mínimo da tarifa pelo fator obtido.
					consumoMinimoLigacao = consumoMinimoLigacao
							+ (consumoMinimoTarifa * subcategoria
									.getCategoria().getFatorEconomias()
									.intValue());
				} else {

					// Multiplica o consumo mínimo da tarifa pela quantidade de
					// economias da subcategoria.
					consumoMinimoLigacao = consumoMinimoLigacao
							+ (consumoMinimoTarifa * subcategoria
									.getQuantidadeEconomias());
				}
			}
		}

		// Retorna o consumo mínimo da ligação
		return consumoMinimoLigacao;

	}

	/**
	 * [UC0105] Obter Consumo Mínimo da Ligação
	 * 
	 * @author Raphael Rossiter
	 * @date 11/04/2007
	 * 
	 * @return imovel, colecaoSubcategoria
	 * @throws ControladorException
	 */
	public int obterConsumoMinimoLigacaoPorCategoria(Imovel imovel,
			Collection colecaoCategoriaOUSubcategoria)
			throws ControladorException {

		int consumoMinimoLigacao = 0;

		if (colecaoCategoriaOUSubcategoria != null
				&& !colecaoCategoriaOUSubcategoria.isEmpty()) {

			// Pesquisando a vigência da tarifa do imóvel.
			ConsumoTarifaVigencia consumoTarifaVigencia = this
					.pesquisarConsumoTarifaVigencia(imovel);

			Iterator iterator = colecaoCategoriaOUSubcategoria.iterator();

			while (iterator.hasNext()) {

				Categoria categoria = (Categoria) iterator.next();

				Integer consumoMinimoTarifa = this
						.pesquisarConsumoMinimoTarifaCategoriaPorCategoria(
								consumoTarifaVigencia, categoria);

				// Caso a categoria associada à subcategoria tenha fator de
				// economias diferente de NULO
				if (categoria.getFatorEconomias() != null) {

					// Multiplica o consumo mínimo da tarifa pelo fator obtido.
					consumoMinimoLigacao = consumoMinimoLigacao
							+ (consumoMinimoTarifa * categoria
									.getFatorEconomias().intValue());
				} else {

					// Multiplica o consumo mínimo da tarifa pela quantidade de
					// economias da subcategoria.
					consumoMinimoLigacao = consumoMinimoLigacao
							+ (consumoMinimoTarifa * categoria
									.getQuantidadeEconomiasCategoria());
				}
			}
		}

		// Retorna o consumo mínimo da ligação
		return consumoMinimoLigacao;

	}

	/**
	 * [UC0105] Obter Consumo Mínimo da Ligação
	 * 
	 * @author Raphael Rossiter
	 * @date 26/05/2008
	 * 
	 * @param imovel
	 * @return ConsumoTarifaVigencia
	 * @throws ControladorException
	 */
	protected ConsumoTarifaVigencia pesquisarConsumoTarifaVigencia(Imovel imovel)
			throws ControladorException {

		ConsumoTarifaVigencia consumoTarifaVigencia = null;
		Collection colecaoDataVigencia = null;

		// Obtém o consumo tarifa vigência da maior data de vigência da tarifa
		// do imóvel
		try {

			colecaoDataVigencia = repositorioMicromedicao
					.pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(),
							imovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		// Recupera os dados do CONSUMO_TARIFA_VIGENCIA para o imóvel
		Object[] consumoTarifaVigenciaIdArray = null;

		if (colecaoDataVigencia == null || colecaoDataVigencia.isEmpty()) {

			throw new ControladorException(
					"erro.nao_cadastrada_consumo_tarifa_vigencia", null,
					String.valueOf(imovel.getId()));
		} else {

			consumoTarifaVigenciaIdArray = (Object[]) Util
					.retonarObjetoDeColecaoArray(colecaoDataVigencia);

			consumoTarifaVigencia = new ConsumoTarifaVigencia();
			consumoTarifaVigencia
					.setId((Integer) consumoTarifaVigenciaIdArray[0]);

			if (consumoTarifaVigenciaIdArray[1] != null) {
				consumoTarifaVigencia
						.setDataVigencia((Date) consumoTarifaVigenciaIdArray[1]);
			}
		}

		return consumoTarifaVigencia;
	}

	/**
	 * [UC0105] Obter Consumo Mínimo da Ligação
	 * 
	 * @author Raphael Rossiter
	 * @date 26/05/2008
	 * 
	 * @param consumoTarifaVigencia
	 * @param subcategoria
	 * @return Integer
	 * @throws ControladorException
	 */
	protected Integer pesquisarConsumoMinimoTarifaCategoriaPorSubcategoria(
			ConsumoTarifaVigencia consumoTarifaVigencia,
			Subcategoria subcategoria) throws ControladorException {

		Integer consumoMinimoTarifa = null;

		try {

			// Obtém o consumo mínimo da tarifa da subcategoria do imóvel
			Object consumoMinimoObjeto = repositorioMicromedicao
					.pesquisarConsumoMinimoTarifaSubcategoriaVigencia(
							subcategoria, consumoTarifaVigencia);

			consumoMinimoTarifa = (Integer) consumoMinimoObjeto;
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		/*
		 * Caso não exista tarifa cadastrada para a subcategoria em questao,
		 * utilizar a tarifa da categoria
		 */
		if (consumoMinimoTarifa == null) {

			consumoMinimoTarifa = this
					.pesquisarConsumoMinimoTarifaCategoriaPorCategoria(
							consumoTarifaVigencia, subcategoria.getCategoria());

		}

		return consumoMinimoTarifa;
	}

	/**
	 * [UC0105] Obter Consumo Mínimo da Ligação
	 * 
	 * @author Raphael Rossiter
	 * @date 26/05/2008
	 * 
	 * @param consumoTarifaVigencia
	 * @param subcategoria
	 * @return Integer
	 * @throws ControladorException
	 */
	protected Integer pesquisarConsumoMinimoTarifaCategoriaPorCategoria(
			ConsumoTarifaVigencia consumoTarifaVigencia, Categoria categoria)
			throws ControladorException {

		Integer consumoMinimoTarifa = null;

		try {

			// Obtém o consumo mínimo da tarifa da categoria do imóvel
			Object consumoMinimoObjeto = repositorioMicromedicao
					.pesquisarConsumoMinimoTarifaCategoriaVigencia(categoria,
							consumoTarifaVigencia);

			consumoMinimoTarifa = (Integer) consumoMinimoObjeto;
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		return consumoMinimoTarifa;
	}

	/**
	 * Gerar o vetor para registrar as leituras e anormalidades
	 * 
	 * @data 28/07/2008
	 * @return
	 * @throws ControladorException
	 */
	public Vector<DadosMovimentacao> gerarVetorDadosParaLeitura(
			BufferedReader buffer) throws ControladorException {
		Vector<DadosMovimentacao> dados = new Vector<DadosMovimentacao>();

		try {

			while (buffer.ready()) {
				String linha = buffer.readLine();
				dados.add(gerarDadosMovimentacao(linha));
			}

		} catch (Exception e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema");
		}

		return dados;
	}

	public DadosMovimentacao gerarDadosMovimentacao(String linha)
			throws ControladorException, ErroRepositorioException {

		DadosMovimentacao retorno = new DadosMovimentacao();

		retorno.setLocalidade(new Integer(linha.substring(0, 3)
				.replace(" ", "")));
		retorno.setSetorComercial(new Integer(linha.substring(3, 6).replace(
				" ", "")));
		retorno.setNumeroQuadra(new Integer(linha.substring(6, 9).replace(" ",
				"")));
		retorno.setNumeroLote(new Integer(linha.substring(9, 13).replace(" ",
				"")));
		retorno.setNumeroSubLote(new Integer(linha.substring(13, 16).replace(
				" ", "")));
		retorno.setTipoMedicao(new Integer(linha.substring(16, 17).replace(" ",
				"")));

		retorno.setMatriculaImovel(new Integer(linha.substring(19, 27).replace(
				" ", "")));
		retorno.setPerfilImovel(new Integer(linha.substring(27, 28).replace(
				" ", "")));
		retorno.setNomeCliente(linha.substring(28, 53));
		retorno.setEndereco(linha.substring(53, 103));
		String marcaHidrometro = linha.substring(103, 105).replace(" ", "");

		Integer grupo = repositorioMicromedicao
				.pesquisarMovimentoRoteiroEmpresa(retorno.getMatriculaImovel());
		retorno.setGrupoFaturamento(grupo);

		if (marcaHidrometro != null && !marcaHidrometro.equals("")) {
			retorno.setMarcaHidrometro(marcaHidrometro);
		} else {
			retorno.setMarcaHidrometro("  ");
		}
		String numeroHidrometro = linha.substring(105, 115);
		if (numeroHidrometro != null && !numeroHidrometro.equals("")) {
			retorno.setNumeroHidrometro(numeroHidrometro);
		} else {
			retorno.setNumeroHidrometro("          ");
		}
		String capacidadeHidrometro = linha.substring(115, 117)
				.replace(" ", "");
		if (capacidadeHidrometro != null && !capacidadeHidrometro.equals("")) {
			retorno.setCapacidadeHidrometro(capacidadeHidrometro);
		} else {
			retorno.setCapacidadeHidrometro("  ");
		}
		String localInstalacao = linha.substring(117, 119).replace(" ", "");
		if (localInstalacao != null && !localInstalacao.equals("")) {
			retorno.setLocalInstalacao(localInstalacao);
		} else {
			retorno.setLocalInstalacao("  ");
		}

		StringBuffer dataInstalacao = new StringBuffer(
				linha.substring(119, 125));
		retorno.setDataInstalacao(retorno.stringParaData(dataInstalacao
				.reverse().toString()));

		String protecaoHidrometro = linha.substring(125, 127).replace(" ", "");
		if (protecaoHidrometro != null && !protecaoHidrometro.equals("")) {
			retorno.setProtecaoHidrometro(protecaoHidrometro);
		} else {
			retorno.setProtecaoHidrometro("  ");
		}
		retorno.setSituacaoLigacaoAgua(new Integer(linha.substring(127, 129)
				.replace(" ", "")));
		retorno.setSituacaoLigacaoEsgoto(new Integer(linha.substring(129, 131)
				.replace(" ", "")));
		retorno.setDecricaoAbreviadaImovel(linha.substring(131, 134));
		retorno.setQuantidadeEconomias(new Integer(linha.substring(134, 137)
				.replace(" ", "")));
		retorno.setLeituraAnterior(new Integer(retorno.decrypt(linha.substring(
				137, 143))));
		retorno.setFaixaLeituraEsperadaInferior(new Integer(retorno
				.decrypt(linha.substring(143, 149).replace(" ", ""))));
		retorno.setFaixaLeituraEsperadaSuperior(new Integer(retorno
				.decrypt(linha.substring(149, 155).replace(" ", ""))));
		retorno.setCodigoRota(new Integer(linha.substring(155, 161).replace(
				" ", "")));
		retorno.setNumeroSequencialRota(new Integer(linha.substring(161, 165)
				.replace(" ", "")));
		retorno.setMatriculaOperador(new Integer(linha.substring(165, 173)
				.replace(" ", "")));
		retorno.setLeituraHidrometro(new Integer(linha.substring(173, 179)
				.replace(" ", "")));
		retorno.setCodigoAnormalidade(new Integer(linha.substring(179, 181)
				.replace(" ", "")));
		retorno.setStringDataLeitura(retorno.decrypt(linha.substring(181, 187)));
		retorno.setHoraLeituraCampo(retorno.decrypt(linha.substring(187, 193)));
		retorno.setIndicadorConfirmacaoLeitura(new Byte(linha.substring(193,
				194)));
		retorno.setDataLeituraCampo(retorno.stringParaDataHora(retorno
				.getStringDataLeitura() + retorno.getHoraLeituraCampo()));

		return retorno;
	}

	/**
	 * Retorno a quantidade leituras que ainda não foram registradas
	 * 
	 * @data 03/06/2008
	 * @param grupo
	 * @return
	 * @throws ControladorException
	 */
	public Integer consultarQuantidadeLeiturasNaoResgistradas(
			FaturamentoGrupo grupo) throws ControladorException {
		try {
			return this.repositorioMicromedicao
					.consultarQuantidadeLeiturasNaoResgistradas(
							grupo.getAnoMesReferencia(), grupo.getId());
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Processa as leituras que ainda não foram registradas
	 * 
	 * @data 03/06/2008
	 * @param anoMes
	 * @param grupo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void processarLeiturasNaoResgistradas(FaturamentoGrupo grupo)
			throws ControladorException {
		try {
			// Lista de Movimento Roteiro Empresa ainda n processado
			List movimentos = this.repositorioMicromedicao
					.consultarLeiturasNaoResgistradas(
							grupo.getAnoMesReferencia(), grupo.getId());

			Iterator it = movimentos.iterator();

			while (it.hasNext()) {
				MovimentoRoteiroEmpresa movimento = (MovimentoRoteiroEmpresa) it
						.next();
				DadosMovimentacao dado = new DadosMovimentacao();
				dado.setMatriculaImovel(movimento.getImovel().getId());
				if (movimento.getLeituraAnormalidade() != null) {
					dado.setCodigoAnormalidade(movimento
							.getLeituraAnormalidade().getId());
				} else {
					dado.setCodigoAnormalidade(0);
				}
				dado.setDataInstalacao(movimento.getDataInstalacaoHidrometro());
				dado.setDataLeituraCampo(movimento.getTempoLeitura());
				dado.setIndicadorConfirmacaoLeitura(new Byte(movimento
						.getIndicadorConfirmacaoLeitura().byteValue()));
				dado.setLeituraHidrometro(movimento
						.getNumeroLeituraHidrometro());
				dado.setTipoMedicao(movimento.getMedicaoTipo().getId());

				FiltroRota filtro = new FiltroRota();
				filtro.adicionarCaminhoParaCarregamentoEntidade(FiltroRota.LEITURISTA);
				filtro.adicionarParametro(new ParametroSimples(
						FiltroRota.ID_ROTA, movimento.getRota().getId()));

				Collection colecao = getControladorUtil().pesquisar(filtro,
						Rota.class.getName());

				if (colecao != null && !colecao.isEmpty()) {
					movimento.setRota((Rota) colecao.iterator().next());
				}

				/*
				 * CRC5256
				 * 
				 * Colocado por Raphael Rossiter em 18/10/2010 Analista: Eduardo
				 * Borges
				 * 
				 * OBJ: Não atualizar a data de realização da atividade efetuar
				 * leitura com uma data que não esteja dentro do cronograma do
				 * grupo.
				 */
				Date dataLeituraCronograma = this
						.obterDataRealizacaoDaAtividadeEfetuarLeitura(
								dado.getDataLeituraCampo(), grupo,
								grupo.getAnoMesReferencia());

				dado.setDataLeituraCronograma(dataLeituraCronograma);

				// Registrar
				this.repositorioMicromedicao
						.atualizarLeituraAnormailidadeCelular(dado, grupo
								.getAnoMesReferencia(), movimento.getRota()
								.getLeiturista());

				// Consistir
				Collection<Integer> ids = new ArrayList<Integer>();
				ids.add(dado.getMatriculaImovel());
				this.consistirLeiturasCalcularConsumosImoveis(grupo, ids);

				movimento.setIndicadorAtualizacaoLeitura(new Integer(1));

				this.repositorioUtil.atualizar(movimento);

			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Retorno a quantidade leituras enviada.
	 * 
	 * @autor Yara T. Souza
	 * 
	 * @data 26/08/2008
	 * @param grupo
	 * @return
	 * @throws ControladorException
	 */
	public Integer pesquisarLeiturasEnviadasRelatorioCount(
			Integer anoMesReferencia, Integer idEmpresa, Integer idLocalidade,
			Integer codigoSetorComercial, Integer idGrupoFaturamento,
			Integer idGerencia, Integer idUnidadeNegocio, Integer idLeiturista)
			throws ControladorException {
		try {
			return this.repositorioMicromedicao
					.pesquisarLeiturasEnviadasRelatorioCount(anoMesReferencia,
							idEmpresa, idLocalidade, codigoSetorComercial,
							idGrupoFaturamento, idGerencia, idUnidadeNegocio,
							idLeiturista);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT
	 * 
	 * @author Rômulo Aurélio
	 * @date 08/07/2008
	 * 
	 * @param Rota
	 * @param ano
	 *            e mes corrente
	 * @param id
	 *            grupo faturamento
	 * @param id
	 *            funcionalidade iniciada
	 * 
	 * @throws ControladorException
	 */
	public void gerarDadosPorLeituraConvencional(Collection<Rota> colecaoRota,
			Integer anoMesCorrente, Integer idGrupoFaturamentoRota,
			SistemaParametro sistemaParametro, int idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		Integer idLeituraTipo = LeituraTipo.CONVENCIONAL;

		StringBuilder arquivoTxtLinha = new StringBuilder();
		StringBuilder arquivoTxtLinhaSistemaLegado = new StringBuilder();

		// Registrar o início do processamento da Unidade de Processamento
		// do Batch
		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, 0);

		// cria uma coleção de imóvel por rota
		Collection objetosMovimentoRoteiroEmpresa = new ArrayList();

		MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = new MovimentoRoteiroEmpresa();

		try {

			final int quantidade = 500;
			boolean flagTerminou = false;
			int numeroIndice = 0;

			while (!flagTerminou) {

				try {

					// recupera todos os imóveis da coleção de rotas do tipo
					// ROL
					Collection arrayMovimentoRoteiroEmpresa = repositorioMicromedicao
							.pesquisarMovimentoRoteiroEmpresaParaLeituraPorColecaoRotaCAERN(
									colecaoRota, idLeituraTipo, numeroIndice,
									anoMesCorrente);

					objetosMovimentoRoteiroEmpresa
							.addAll(arrayMovimentoRoteiroEmpresa);

					numeroIndice = numeroIndice + 500;

					if (arrayMovimentoRoteiroEmpresa.size() < quantidade) {
						flagTerminou = true;
					}

				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}

			}

			if (objetosMovimentoRoteiroEmpresa != null
					&& !objetosMovimentoRoteiroEmpresa.isEmpty()) {

				/*
				 * Integer qtdMovimentoRoteiroEmpresa =
				 * objetosMovimentoRoteiroEmpresa .size();
				 */

				Iterator dadosMovimentoRoteiroEmpresaIterator = objetosMovimentoRoteiroEmpresa
						.iterator();

				/*
				 * Totalizador
				 */
				int quantidadeRegistrospPorRota = 0;

				int quantidadeRegistros = 0;
				int pagina = 0;

				Integer idGerenciaRegionalAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
				Integer idLocalidadeAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
				Integer codigoSetorComercialAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
				Integer idRotaAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

				while (dadosMovimentoRoteiroEmpresaIterator.hasNext()) {

					Object[] dadosMovimentoRoteiroEmpresa = (Object[]) dadosMovimentoRoteiroEmpresaIterator
							.next();

					movimentoRoteiroEmpresa = (MovimentoRoteiroEmpresa) dadosMovimentoRoteiroEmpresa[0];

					Integer idQuadra = (Integer) dadosMovimentoRoteiroEmpresa[1];
					String descricaoFaturamentoGrupo = (String) dadosMovimentoRoteiroEmpresa[2];
					String descricaoEmpresa = (String) dadosMovimentoRoteiroEmpresa[3];
					String emailEmpresa = (String) dadosMovimentoRoteiroEmpresa[4];
					String nomeLocalidade = (String) dadosMovimentoRoteiroEmpresa[5];
					Integer idGerenciaRegional = (Integer) dadosMovimentoRoteiroEmpresa[6];
					String nomeGerenciaRegional = (String) dadosMovimentoRoteiroEmpresa[7];
					String codigoHidrometroMarca = (String) dadosMovimentoRoteiroEmpresa[8];

					Quadra quadra = new Quadra();
					quadra.setId(idQuadra);

					Imovel imovel = new Imovel();
					imovel.setId(movimentoRoteiroEmpresa.getImovel().getId());
					imovel.setQuadra(quadra);

					movimentoRoteiroEmpresa.setImovel(imovel);

					FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
					faturamentoGrupo.setId(movimentoRoteiroEmpresa
							.getFaturamentoGrupo().getId());
					faturamentoGrupo.setDescricao(descricaoFaturamentoGrupo);

					movimentoRoteiroEmpresa
							.setFaturamentoGrupo(faturamentoGrupo);

					Empresa empresa = new Empresa();
					empresa.setId(movimentoRoteiroEmpresa.getEmpresa().getId());
					empresa.setDescricao(descricaoEmpresa);
					empresa.setEmail(emailEmpresa);

					movimentoRoteiroEmpresa.setEmpresa(empresa);

					GerenciaRegional gerenciaRegional = new GerenciaRegional();
					gerenciaRegional.setId(idGerenciaRegional);
					gerenciaRegional.setNome(nomeGerenciaRegional);

					Localidade localidade = new Localidade();
					localidade.setId(movimentoRoteiroEmpresa.getLocalidade()
							.getId());
					localidade.setDescricao(nomeLocalidade);
					localidade.setGerenciaRegional(gerenciaRegional);

					movimentoRoteiroEmpresa.setLocalidade(localidade);

					HidrometroMarca hidrometroMarca = new HidrometroMarca();
					hidrometroMarca.setId(movimentoRoteiroEmpresa
							.getHidrometroMarca().getId());
					hidrometroMarca
							.setCodigoHidrometroMarca(codigoHidrometroMarca);

					movimentoRoteiroEmpresa.setHidrometroMarca(hidrometroMarca);

					quantidadeRegistros++;

					boolean geraRegistroZERO = false;

					Integer idGerenciaRegionalAtual = movimentoRoteiroEmpresa
							.getGerenciaRegional().getId();
					Integer idLocalidadeAtual = movimentoRoteiroEmpresa
							.getLocalidade().getId();
					Integer codigoSetorComercialAtual = movimentoRoteiroEmpresa
							.getCodigoSetorComercial();
					Integer idRotaAtual = movimentoRoteiroEmpresa.getRota()
							.getId();

					/*
					 * Quebra por ROTA
					 */
					if ((idRotaAnterior.intValue() != ConstantesSistema.NUMERO_NAO_INFORMADO)
							&& (idRotaAnterior.intValue() != idRotaAtual
									.intValue())) {

						/*
						 * Gerar um totalizador para os imóveis de uma ROTA
						 */
						arquivoTxtLinha.append("TOTAL DE IMOVEIS POR ROTA = "
								+ quantidadeRegistrospPorRota);

						arquivoTxtLinha.append(System
								.getProperty("line.separator"));

						/*
						 * Gerar um totalizador para os imóveis de uma ROTA
						 */
						quantidadeRegistrospPorRota = 0;
						geraRegistroZERO = true;
					}

					if ((codigoSetorComercialAtual.intValue() != codigoSetorComercialAnterior
							.intValue())
							|| (idLocalidadeAtual.intValue() != idLocalidadeAnterior
									.intValue())
							|| (idGerenciaRegionalAtual.intValue() != idGerenciaRegionalAnterior
									.intValue())) {

						geraRegistroZERO = true;
					}

					idGerenciaRegionalAnterior = idGerenciaRegionalAtual;
					idLocalidadeAnterior = idLocalidadeAtual;
					codigoSetorComercialAnterior = codigoSetorComercialAtual;
					idRotaAnterior = idRotaAtual;

					// Na primeira execução, a cada 25 imóveis da lista
					// e
					// cada
					// quebra da ordenação
					// definida acima,o sistema deve gerar uma linha de
					// registro
					// do tipo 0(zero)
					if (geraRegistroZERO || quantidadeRegistros == 25) {

						pagina++;
						arquivoTxtLinha.append(this
								.gerarDadosLeituraConvencionalRegistroZERO(
										movimentoRoteiroEmpresa, pagina, ""
												+ anoMesCorrente));

						quantidadeRegistros = 0;
					}

					arquivoTxtLinha.append(this
							.gerarDadosLeituraConvencionalRegistroUM(
									movimentoRoteiroEmpresa, anoMesCorrente));

					arquivoTxtLinha.append(this
							.gerarDadosLeituraConvencionalRegistroDOIS(
									movimentoRoteiroEmpresa, anoMesCorrente,
									sistemaParametro));

					/*
					 * Colocado por Raphael Rossiter em 28/03/2007 OBJ: Gerar um
					 * totalizador para os imóveis de uma ROTA
					 */
					quantidadeRegistrospPorRota++;

					// Para todos os imoveis gerar o TXT para o Sistema
					// Legado
					// [SB0003] - Gerar Arquivo Entrada Sistema Legado
					arquivoTxtLinhaSistemaLegado.append(this
							.gerarDadosLeituraConvencionalSistemaLegado(
									movimentoRoteiroEmpresa, pagina,
									anoMesCorrente, sistemaParametro));

				}

				// Gera o arquivo

				this.gerarArquivoConvencional(anoMesCorrente,
						idGrupoFaturamentoRota, arquivoTxtLinha, null, false);

				// Gera o arquivo para o sistema legado

				this.gerarArquivoConvencional(anoMesCorrente,
						idGrupoFaturamentoRota, arquivoTxtLinhaSistemaLegado,
						null, true);

			}

			repositorioMicromedicao.atualizarFaturamentoAtividadeCronograma(
					idGrupoFaturamentoRota, anoMesCorrente);

			// Encerra a unidade de Faturamento
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

			// atualiza a data e a hora da realização da atividade com a
			// data e
			// a hora correntes

		} catch (Exception e) { // Este catch serve para interceptar

			// qualquer exceção que o processo batch
			// venha a lançar e garantir que a unidade
			// de processamento do batch será atualizada
			// com o erro ocorrido

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT - Registro 0
	 * 
	 * @author Rômulo Aurélio
	 * @date 09/08/2008
	 * 
	 * @param imovel
	 *            , pagina, anoMesFaturamento
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroZERO(
			MovimentoRoteiroEmpresa movimentoRoteiroEmpresa, int pagina,
			String anoMesFaturamento) throws ControladorException {

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.1.1 - Tipo de Registro 0 (ZERO)
		arquivoTxtLinha.append("0");

		// 1.1.2 - Distrito (Gerencia Regional)
		arquivoTxtLinha.append(completaString(movimentoRoteiroEmpresa
				.getLocalidade().getGerenciaRegional().getNome(), 13));

		// 1.1.3 - Cidade (Localidade)
		arquivoTxtLinha.append(completaString(movimentoRoteiroEmpresa
				.getLocalidade().getDescricao(), 20));

		// 1.1.4 - Mês de Referência
		String ano = anoMesFaturamento.substring(0, 4);
		String mes = anoMesFaturamento.substring(4, 6);

		arquivoTxtLinha
				.append(completaString(
						Util.retornaDescricaoMes(Integer.parseInt(mes)) + "/"
								+ ano, 14));

		// 1.1.5 - Cidade (Código da Localidade)
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(3, ""
				+ movimentoRoteiroEmpresa.getLocalidade().getId()));

		// 1.1.6 - Setor (Setor Comercial)
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(2, ""
				+ movimentoRoteiroEmpresa.getCodigoSetorComercial()));

		// 1.1.7 - Rota
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(2, ""
				+ movimentoRoteiroEmpresa.getCodigoRota()));

		// 1.1.8 - Página
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(4, ""
				+ pagina));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT - Registro 1
	 * 
	 * @author Rafael Francisco Pinto, Raphael Rossiter
	 * @date 22/01/2007, 28/03/2007
	 * 
	 * @param imovel
	 *            , anoMesFaturamento
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroUM(
			MovimentoRoteiroEmpresa movimentoRoteiroEmpresa,
			int anoMesFaturamento) throws ControladorException {

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.2.1 - Tipo de Registro 1 (UM)
		arquivoTxtLinha.append("1");

		// 1.2.1.1 - Nome
		arquivoTxtLinha.append(completaString(
				movimentoRoteiroEmpresa.getNomeCliente(), 40));

		// 1.2.1.2 - Situação (RETIRAR - DEIXAR ESPAÇOS - COM TAMANHO = 06)
		arquivoTxtLinha.append(completaString("", 6));

		// 1.2.1.3
		// Categoria
		if (movimentoRoteiroEmpresa.getCategoriaPrincipal() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(1,
					movimentoRoteiroEmpresa.getCategoriaPrincipal().getId()
							+ ""));
		} else {
			arquivoTxtLinha.append(Util.completaString("", 1));
		}

		// Subcategoria1

		if (movimentoRoteiroEmpresa.getCodigoSubcategoria1() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2,
					movimentoRoteiroEmpresa.getCodigoSubcategoria1() + ""));
		} else {
			arquivoTxtLinha.append(Util.completaString("", 2));
		}

		// qtdeEconomia
		if (movimentoRoteiroEmpresa.getQuantidadeEconomias() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3,
					movimentoRoteiroEmpresa.getQuantidadeEconomias() + ""));
		} else {
			arquivoTxtLinha.append(Util.completaString("", 3));
		}

		// Categoria
		if (movimentoRoteiroEmpresa.getCategoria2() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(1,
					movimentoRoteiroEmpresa.getCategoria2().getId() + ""));
		} else {
			arquivoTxtLinha.append(Util.completaString("", 1));
		}

		// Subcategoria2

		if (movimentoRoteiroEmpresa.getCodigoSubcategoria2() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2,
					movimentoRoteiroEmpresa.getCodigoSubcategoria2() + ""));
		} else {
			arquivoTxtLinha.append(Util.completaString("", 2));
		}

		// qtdeEconomia2
		if (movimentoRoteiroEmpresa.getQuantidadeEconomias2() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3,
					movimentoRoteiroEmpresa.getQuantidadeEconomias2() + ""));
		} else {
			arquivoTxtLinha.append(Util.completaString("", 3));
		}

		if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos1Mes() != null) {
			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					4,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroConsumoFaturadoMenos1Mes()));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 4));
		}

		if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos2Meses() != null) {
			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					4,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroConsumoFaturadoMenos2Meses()));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 4));
		}
		if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos3Meses() != null) {
			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					4,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroConsumoFaturadoMenos3Meses()));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 4));
		}
		// 1.2.1.5 - Condição

		if (movimentoRoteiroEmpresa.getDescricaoConsumoTipo() != null) {
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(""
					+ movimentoRoteiroEmpresa.getDescricaoConsumoTipo(), 8));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 8));
		}

		// 1.2.1.6 - Número do Lacre
		if (movimentoRoteiroEmpresa.getNumeroLacreLigacaoAgua() != null) {
			arquivoTxtLinha.append(completaString(movimentoRoteiroEmpresa
					.getNumeroLacreLigacaoAgua().toString(), 6));
		} else {
			arquivoTxtLinha.append(completaString("", 6));
		}

		// 1.2.1.7 - Matrícula do Imóvel
		arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(
				movimentoRoteiroEmpresa.getImovel().getId().toString(), 9));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0002] Gerar Relação(ROL) em TXT - Registro 2
	 * 
	 * @author Rômulo Aurélio
	 * @date 15/07/2008
	 * 
	 * @param movimentoRoteiroEmpresa
	 *            , anoMesCorrente, sistemaParametro
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroDOIS(
			MovimentoRoteiroEmpresa movimentoRoteiroEmpresa,
			Integer anoMesCorrente, SistemaParametro sistemaParametro)
			throws ControladorException {

		StringBuilder arquivoTxtLinha = new StringBuilder();

		StringBuilder dadosHidrometro = new StringBuilder();

		// DadosHidrometro

		String dataInstalacaohidrometro = Util
				.formatarDataAAAAMMDD(movimentoRoteiroEmpresa
						.getDataInstalacaoHidrometro());

		dadosHidrometro.append(Util.adicionarZerosEsquedaNumeroTruncando(1, ""
				+ movimentoRoteiroEmpresa.getHidrometroMarca()
						.getCodigoHidrometroMarca().toString())
				+ completaString(
						"" + movimentoRoteiroEmpresa.getNumeroHidrometro(), 10)
				+ Util.adicionarZerosEsquedaNumeroTruncando(1,
						movimentoRoteiroEmpresa.getHidrometroCapacidade()
								.getId().toString())
				+ Util.adicionarZerosEsquedaNumeroTruncando(1,
						movimentoRoteiroEmpresa.getHidrometroLocalInstalacao()
								.getId().toString())
				+ dataInstalacaohidrometro
				+ Util.adicionarZerosEsquedaNumeroTruncando(1,
						movimentoRoteiroEmpresa.getHidrometroProtecao().getId()
								.toString()));

		// 1.2.2 - Tipo de Registro 2 (DOIS)
		arquivoTxtLinha.append("2");

		// 1.2.2.1 - Endereço
		// Pesquisa o endereço do imovel passando o id
		String enderecoImovel = movimentoRoteiroEmpresa.getEnderecoImovel();

		if (enderecoImovel != null && !enderecoImovel.equals("")) {
			// endereço do imóvel
			arquivoTxtLinha.append(completaString(enderecoImovel, 45));
		} else {
			arquivoTxtLinha.append(completaString("", 45));
		}

		// 1.2.2.2 - Hidrômetro

		if (movimentoRoteiroEmpresa.getNumeroHidrometro() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(8,
					movimentoRoteiroEmpresa.getNumeroHidrometro()));
		} else {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(8,
					""));
		}

		// 1.2.2.3 - Inscrição do Imovel
		// 1.2.2.3.1 - Quadra
		// 1.2.2.3.2 - Lote
		// 1.2.2.3.3 - SubLote
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(3, ""
				+ movimentoRoteiroEmpresa.getNumeroQuadra()));

		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(4, ""
				+ movimentoRoteiroEmpresa.getNumeroLoteImovel()));

		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(3, ""
				+ movimentoRoteiroEmpresa.getNumeroSubloteImovel()));

		// 1.2.2.4 - Sequencial da Rota
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(4, ""
				+ movimentoRoteiroEmpresa.getNumeroSequencialRota()));

		// 1.2.2.5 - Leitura Atual (Leitura anterior)

		if (movimentoRoteiroEmpresa.getNumeroLeituraAnterior() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(6,
					"" + movimentoRoteiroEmpresa.getNumeroLeituraAnterior()));

		} else {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, ""));

		}
		// 1.2.2.6 - Faixa de Leitura esperada Inicial

		if (movimentoRoteiroEmpresa.getNumeroFaixaLeituraEsperadaInicial() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					6,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroFaixaLeituraEsperadaInicial()));

		} else {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, ""));

		}

		// 1.2.2.7 - Faixa de Leitura esperada Final

		if (movimentoRoteiroEmpresa.getNumeroFaixaLeituraEsperadaFinal() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					6,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroFaixaLeituraEsperadaFinal()));

		} else {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, ""));

		}

		// 1.2.2.9 - Consumo 04

		if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos4Meses() != null) {
			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(
					4,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroConsumoFaturadoMenos4Meses()));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 4));
		}

		// 1.2.2.10 - Consumo 05
		if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos5Meses() != null) {
			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					4,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroConsumoFaturadoMenos5Meses()));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 4));
		}

		// caso o numero consumo faturado do mes for diferente de nulo
		if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos6Meses() != null) {
			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					4,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroConsumoFaturadoMenos6Meses()));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 4));
		}

		if (movimentoRoteiroEmpresa.getNumeroConsumoMedio() != null) {
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(""
					+ movimentoRoteiroEmpresa.getNumeroConsumoMedio(), 4));
		} else {
			arquivoTxtLinha
					.append(Util.completaStringComEspacoAEsquerda("", 4));
		}

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * [SB0003] Gerar Arquivo Entrada Sistema Legado
	 * 
	 * @author Rômulo Aurélio
	 * @date 09/07/2008
	 * 
	 * @param movimentoRoteiroEmpresa
	 * 
	 * @throws ErroRepositorioException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalSistemaLegado(
			MovimentoRoteiroEmpresa movimentoRoteiroEmpresa, int pagina,
			Integer anoMesCorrente, SistemaParametro sistemaParametro)
			throws ControladorException {

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.1 - Matricula do imovel Tam. 09
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(9, ""
				+ movimentoRoteiroEmpresa.getImovel().getId()));

		// 1.2 - Cidade (codigo da localidade) Tam. 03
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ movimentoRoteiroEmpresa.getLocalidade().getId()));

		// 1.3 - Setor (Setor Comercial) Tam. 03
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ movimentoRoteiroEmpresa.getCodigoSetorComercial()));

		// 1.4 - Rota Tam. 02
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, ""
				+ movimentoRoteiroEmpresa.getCodigoRota()));

		/*
		 * Colocado por Raphael Rossiter em 19/05/2007 (Analista: Eduardo
		 * Borges)
		 */
		// Sequencial da Rota Tam. 04
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, ""
				+ movimentoRoteiroEmpresa.getNumeroSequencialRota()));

		// 1.5 - Página
		arquivoTxtLinha
				.append(Util.adicionarZerosEsquedaNumero(4, "" + pagina));

		// 1.6 - Inscrição do Imovel
		// 1.6.1 - Quadra
		// 1.6.2 - Lote
		// 1.6.3 - SubLote
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ movimentoRoteiroEmpresa.getNumeroQuadra()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, ""
				+ movimentoRoteiroEmpresa.getNumeroLoteImovel()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, ""
				+ movimentoRoteiroEmpresa.getNumeroSubloteImovel()));

		if (movimentoRoteiroEmpresa.getNumeroFaixaLeituraEsperadaInicial() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					6,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroFaixaLeituraEsperadaInicial()));
		} else {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(6,
					""));
		}

		if (movimentoRoteiroEmpresa.getNumeroFaixaLeituraEsperadaFinal() != null) {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(
					6,
					""
							+ movimentoRoteiroEmpresa
									.getNumeroFaixaLeituraEsperadaFinal()));
		} else {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumeroTruncando(6,
					""));
		}

		String numeroHidrometroFinal = movimentoRoteiroEmpresa
				.getNumeroHidrometro().trim();

		if (numeroHidrometroFinal.length() > 8) {

			numeroHidrometroFinal = numeroHidrometroFinal.substring(
					numeroHidrometroFinal.length() - 8,
					numeroHidrometroFinal.length());

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
					numeroHidrometroFinal));
		} else {

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8,
					numeroHidrometroFinal));
		}
		/*
		 * if (movimentoRoteiroEmpresa.getNumeroHidrometro() != null) {
		 * arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(16,
		 * movimentoRoteiroEmpresa.getNumeroHidrometro().toString())); } else {
		 * 
		 * arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(16, "")); }
		 */
		// Tipo de Medição
		arquivoTxtLinha.append(movimentoRoteiroEmpresa.getMedicaoTipo().getId()
				.toString());

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC0083] - Gerar Dados para Leitura Empresa
	 * 
	 * @author Rômulo Aurélio
	 * @date 09/07/2008
	 * 
	 * @param anoMesFaturamento
	 * @param movimentoRoteiroEmpresa
	 * @param qtdImoveis
	 * @param arquivoTexto
	 *            param nomeArquivo
	 * 
	 */
	public void inserirArquivoTextoRoteiroEmpresa(Integer anoMesFaturamento,
			MovimentoRoteiroEmpresa movimentoRoteiroEmpresa,
			Integer qtdImoveis, StringBuilder arquivoTexto, String nomeArquivo)
			throws ControladorException {

		if (movimentoRoteiroEmpresa != null) {

			boolean gerarArquivoTexto = true;

			ArquivoTextoRoteiroEmpresa arquivo;

			try {

				arquivo = this.repositorioMicromedicao
						.pesquisaArquivoTextoParaLeituristaPorRota(
								anoMesFaturamento, movimentoRoteiroEmpresa
										.getRota().getId(),
								movimentoRoteiroEmpresa.getFaturamentoGrupo()
										.getId());

			} catch (ErroRepositorioException e1) {
				throw new ControladorException("erro.sistema", e1);
			}

			if (arquivo != null) {
				if (arquivo.getSituacaoTransmissaoLeitura().getId()
						.compareTo(SituacaoTransmissaoLeitura.LIBERADO) == 0) {

					this.getControladorUtil().remover(arquivo);

				} else {

					gerarArquivoTexto = false;

				}
			}

			if (gerarArquivoTexto) {

				ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = new ArquivoTextoRoteiroEmpresa();

				// ANO_MES_REFERENCIA
				arquivoTextoRoteiroEmpresa
						.setAnoMesReferencia(anoMesFaturamento);

				// FATURAMENTO_GRUPO
				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				faturamentoGrupo.setId(movimentoRoteiroEmpresa
						.getFaturamentoGrupo().getId());

				arquivoTextoRoteiroEmpresa
						.setFaturamentoGrupo(faturamentoGrupo);

				// EMPRESA
				arquivoTextoRoteiroEmpresa.setEmpresa(movimentoRoteiroEmpresa
						.getEmpresa());

				// LOCALIDADE
				Localidade localidade = new Localidade();
				localidade.setId(movimentoRoteiroEmpresa.getLocalidade()
						.getId());

				arquivoTextoRoteiroEmpresa.setLocalidade(localidade);

				// CÓDIGO DO SETOR COMERCIAL
				arquivoTextoRoteiroEmpresa
						.setCodigoSetorComercial1(movimentoRoteiroEmpresa
								.getCodigoSetorComercial());

				// MENOR E MAIOR NÚMERO DA QUADRA PARA ROTA
				Object[] intervalorNumeroQuadra = null;
				try {

					intervalorNumeroQuadra = this.repositorioFaturamento
							.pesquisarIntervaloNumeroQuadraPorRota(movimentoRoteiroEmpresa
									.getRota().getId());

				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				arquivoTextoRoteiroEmpresa
						.setNumeroQuadraInicial1((Integer) intervalorNumeroQuadra[0]);
				arquivoTextoRoteiroEmpresa
						.setNumeroQuadraFinal1((Integer) intervalorNumeroQuadra[1]);

				// QUANTIDADE DE IMÓVEIS
				arquivoTextoRoteiroEmpresa.setQuantidadeImovel(qtdImoveis);

				// NOME DO ARQUIVO
				arquivoTextoRoteiroEmpresa.setNomeArquivo(nomeArquivo);

				// INFORMAÇÕES LEITURISTA
				if (movimentoRoteiroEmpresa.getRota().getLeiturista() != null) {
					arquivoTextoRoteiroEmpresa
							.setLeiturista(movimentoRoteiroEmpresa.getRota()
									.getLeiturista());
					arquivoTextoRoteiroEmpresa
							.setCodigoLeiturista(movimentoRoteiroEmpresa
									.getRota().getLeiturista().getCodigoDDD());
					arquivoTextoRoteiroEmpresa
							.setNumeroFoneLeiturista(movimentoRoteiroEmpresa
									.getRota().getLeiturista().getNumeroFone());
					arquivoTextoRoteiroEmpresa
							.setNumeroImei(movimentoRoteiroEmpresa.getRota()
									.getLeiturista().getNumeroImei());
				}
				// ARQUIVO TEMPORÁRIO GERADO PARA ROTA
				byte[] arquivoTextoByte = null;

				try {

					arquivoTextoByte = IoUtil
							.transformarObjetoParaBytes(arquivoTexto);

				} catch (IOException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				arquivoTextoRoteiroEmpresa.setArquivoTexto(arquivoTextoByte);

				// SITUACAO_TRANSMISSAO_LEITURA
				SituacaoTransmissaoLeitura situacaoTransmissaoLeitura = new SituacaoTransmissaoLeitura();
				situacaoTransmissaoLeitura
						.setId(SituacaoTransmissaoLeitura.LIBERADO);

				arquivoTextoRoteiroEmpresa
						.setSituacaoTransmissaoLeitura(situacaoTransmissaoLeitura);

				// ROTA
				arquivoTextoRoteiroEmpresa.setRota(movimentoRoteiroEmpresa
						.getRota());

				if (movimentoRoteiroEmpresa.getRota() != null
						&& movimentoRoteiroEmpresa.getRota()
								.getNumeroSequenciaLeitura() != null) {
					arquivoTextoRoteiroEmpresa
							.setNumeroSequenciaLeitura(movimentoRoteiroEmpresa
									.getRota().getNumeroSequenciaLeitura());
				}

				// SITUACAO_TRANSMISSAO_LEITURA
				ServicoTipoCelular servicoTipoCelular = new ServicoTipoCelular();
				servicoTipoCelular.setId(ServicoTipoCelular.LEITURA);
				arquivoTextoRoteiroEmpresa
						.setServicoTipoCelular(servicoTipoCelular);

				// ULTIMA ALTERACAO
				arquivoTextoRoteiroEmpresa.setUltimaAlteracao(new Date());

				// INSERINDO NA BASE
				this.getControladorUtil().inserir(arquivoTextoRoteiroEmpresa);

			}

		}

	}

	public void removerMovimentoRoteiroEmpresa(Integer anoMesCorrente,
			Integer idGrupoFaturamentoRota) throws ControladorException {

		try {
			repositorioMicromedicao.removerMovimentoRoteiroEmpresa(
					anoMesCorrente, idGrupoFaturamentoRota);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
	}

	public void removerMovimentoRoteiroEmpresa(Integer anoMesCorrente,
			Integer idGrupoFaturamentoRota, Rota rota)
			throws ControladorException {

		try {
			repositorioMicromedicao.removerMovimentoRoteiroEmpresa(
					anoMesCorrente, idGrupoFaturamentoRota, rota);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
	}

	/**
	 * [UC0083]-Gerar Dados para Leitura
	 * 
	 * Author: Rômulo Aurélio
	 * 
	 * @date: 17/06/2008
	 * 
	 * 
	 * 
	 * @param colecaoRota
	 * @param anoMesCorrente
	 * @param idGrupoFaturamentoRota
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */

	public void gerarDadosPorLeituraParaInserir(Rota rota,
			Integer anoMesCorrente, Integer idGrupoFaturamentoRota,
			SistemaParametro sistemaParametro, Integer idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		try {

			Integer idLeituraTipo = rota.getLeituraTipo().getId();

			repositorioMicromedicao.removerMovimentoRoteiroEmpresa(
					anoMesCorrente, idGrupoFaturamentoRota, rota);

			// -------------------------
			//
			// Registrar o início do processamento da Unidade de
			// Processamento
			// do Batch
			//
			// -------------------------

			idUnidadeIniciada = getControladorBatch()
					.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.ROTA, rota.getId());

			// inicializa uma coleção de imoveis
			Collection objetosImoveis = new ArrayList();

			objetosImoveis = this.retornaImoveisPorRota(rota, sistemaParametro);

			Collection<Imovel> imoveisParaSerGerados = new ArrayList();
			/**
			 * Valida os imoveis para ser gerados
			 */
			imoveisParaSerGerados = this
					.verificarImoveisParaSerGerados(objetosImoveis);

			objetosImoveis.clear();
			objetosImoveis = null;
			/**
			 * [FS0006]- Veriricar imóveis processados na competência
			 */

			Collection<Imovel> colecaoimoveisAGerar = this
					.verificarImoveisProcessadosEmMovimentoRoteiroEmpresa(
							imoveisParaSerGerados, idGrupoFaturamentoRota,
							anoMesCorrente);

			/**
			 * [SB0004]-Recuperar Dados para inclusao na Tabela
			 */
			inserirDadosImoveisMovimentoRoteiroEmpresa(colecaoimoveisAGerar,
					anoMesCorrente, sistemaParametro, idLeituraTipo);

			// Encerra a unidade de Faturamento

			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) { // Este catch serve para interceptar
			// qualquer exceção que o processo batch
			// venha a lançar e garantir que a unidade
			// de processamento do batch será atualizada
			// com o erro ocorrido

			System.out.println("@@ ERRO NO GERAR DADOS PARA LEITURA");
			System.out.println("@@ ROTA ----> " + rota.getId());

			e.printStackTrace();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	/**
	 * Author: Rômulo Aurélio [UC0083] - Gerar Dados para Leitura
	 * 
	 * @param objetosImoveis
	 * @return
	 */

	public Collection verificarImoveisParaSerGerados(Collection objetosImoveis)
			throws ControladorException {
		try {
			// Instancia uma coleção que será usada para gerar o arquivo
			// txt.
			Collection<Imovel> imoveisParaSerGerados = new ArrayList();

			Iterator imovelIterator = objetosImoveis.iterator();
			while (imovelIterator.hasNext()) {
				// Recupera o imovel da coleção
				Imovel imovel = (Imovel) imovelIterator.next();
				// variavel responsável para entrar em uma das 4 condicões
				// abaixo

				boolean achouImovel = false;

				/**
				 * [SF0002] - Verificar situação especial de faturamento Autor:
				 * Sávio Luiz Data: 21/12/2005
				 */
				// caso no imovel o faturamento situação grupo seja
				// diferente de
				// nulo e igual a leitura
				// não realizada então não seleciona o imovel caso contrario
				// seleciona.
				if (imovel.getFaturamentoSituacaoTipo() == null
						|| !imovel
								.getFaturamentoSituacaoTipo()
								.equals(FaturamentoSituacaoTipo.INDICADOR_PARALIZACAO_LEITURA_NAO_REALIZADA)) {

					if (!achouImovel) {
						// Verifica se a situação da ligação agua é
						// diferente de
						// nulo
						// Se for verifica se está ligado ou cortado
						if (imovel.getLigacaoAguaSituacao() != null
								&& imovel.getLigacaoAguaSituacao()
										.getIndicadorFaturamentoSituacao() != null
								&& (imovel.getLigacaoAguaSituacao()
										.getIndicadorFaturamentoSituacao()
										.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO))) {
							// Se for ligado ou cortado então
							// Verifica se a ligação agua é diferente de
							// nulo
							// se for verifica se o id da ligação agua é
							// igual
							// ao id
							// do
							// imovel e
							// se o id do histórico da instalação do
							// hidrometro
							// é
							// diferente de
							// null

							if (imovel.getLigacaoAgua() != null
									&& imovel.getLigacaoAgua().getId() != null
									&& (imovel.getLigacaoAgua().getId()
											.equals(imovel.getId())
											&& imovel
													.getLigacaoAgua()
													.getHidrometroInstalacaoHistorico() != null && imovel
											.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico()
											.getId() != null)) {

								imoveisParaSerGerados.add(imovel);
								achouImovel = true;

							}
						}
					}
					if (!achouImovel) {
						// Verifica se a situação da ligação esgoto é
						// diferente
						// de nulo
						// Se for verifica se está ligado
						if (imovel.getLigacaoEsgotoSituacao() != null
								&& imovel.getLigacaoEsgotoSituacao()
										.getIndicadorFaturamentoSituacao() != null
								&& (imovel.getLigacaoEsgotoSituacao()
										.getIndicadorFaturamentoSituacao()
										.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO))) {
							// Verifica se o id do hidrometro historico é
							// diferente de
							// nulo na tabela imovel
							if (imovel.getHidrometroInstalacaoHistorico() != null
									&& imovel
											.getHidrometroInstalacaoHistorico()
											.getId() != null) {
								imoveisParaSerGerados.add(imovel);
								achouImovel = true;
							}
						}
					}
					if (!achouImovel) {
						// Verifica se a situação da ligação agua é
						// diferente de
						// nulo
						// Se for verifica se está suprimido
						if (imovel.getLigacaoAguaSituacao() != null
								&& imovel.getLigacaoAguaSituacao().getId() != null
								&& imovel.getLigacaoAguaSituacao().getId()
										.equals(LigacaoAguaSituacao.SUPRIMIDO)) {
							// verifica se o indicador de fiscalização
							// suprimido
							// é
							// diferente de nulo
							// se for verifica se está ativo
							if (imovel.getQuadra().getRota()
									.getIndicadorFiscalizarSuprimido() != null
									&& imovel
											.getQuadra()
											.getRota()
											.getIndicadorFiscalizarSuprimido()
											.equals(Rota.INDICADOR_SUPRIMIDO_ATIVO)) {
								imoveisParaSerGerados.add(imovel);
								achouImovel = true;
							}

						}
					}
					if (!achouImovel) {
						// Verifica se a situação da ligação agua é
						// diferente de
						// nulo
						// Se for verifica se está cortado
						if ((imovel.getLigacaoAguaSituacao() != null && imovel
								.getLigacaoAguaSituacao().getId() != null)
								&& (imovel.getLigacaoAguaSituacao().getId()
										.equals(LigacaoAguaSituacao.CORTADO))) {

							// Se for cortado então
							// Verifica se a ligação agua é diferente de
							// nulo
							// se for verifica se o id da ligação agua é
							// igual
							// ao id do
							// imovel e
							// se o id do histórico da instalação do
							// hidrometro
							// é null
							if (imovel.getLigacaoAgua() != null
									&& imovel.getLigacaoAgua().getId() != null
									&& (imovel.getLigacaoAgua().getId()
											.equals(imovel.getId()) && (imovel
											.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico() == null || imovel
											.getLigacaoAgua()
											.getHidrometroInstalacaoHistorico()
											.getId() == null))) {

								// verifica se o indicador de fiscalização
								// cortado é
								// diferente de nulo se for verifica se está
								// ativo
								if (imovel.getQuadra().getRota()
										.getIndicadorFiscalizarCortado() != null
										&& imovel
												.getQuadra()
												.getRota()
												.getIndicadorFiscalizarCortado()
												.intValue() == Rota.INDICADOR_CORTADO_ATIVO) {
									imoveisParaSerGerados.add(imovel);
									achouImovel = true;
								}
							}

						}
					}

				}

			}

			return imoveisParaSerGerados;

		} catch (Exception e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Author: Rômulo Aurélio Date:08/07/2008
	 * 
	 * @param idMedicaoTipo
	 * @param imovel
	 * @param anoMes
	 * @return
	 */

	public String pesquisarFaixaLeituraemLeituraFaixaFalsa(
			Integer idMedicaoTipo, Imovel imovel, Integer anoMes) {

		String retorno = null;
		String leituraFalsaInferior = null;
		String leituraFalsaSuperior = null;
		LeituraFaixaFalsa leituraFaixaFalsa = null;

		try {
			leituraFaixaFalsa = repositorioMicromedicao
					.pesquisarDadosLeituraFaixaFalsa(idMedicaoTipo, imovel,
							anoMes);
			if (leituraFaixaFalsa != null) {

				leituraFalsaInferior = leituraFaixaFalsa
						.getNumeroCorretaInferior().toString();

				leituraFalsaSuperior = leituraFaixaFalsa
						.getNumeroCorretaInferior().toString();

				retorno = leituraFalsaInferior + leituraFalsaSuperior;
			}

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * @author Rômulo Aurélio, Raphael Rossiter
	 * @throws ControladorException
	 * @date 07/07/2008, 27/08/2009
	 */

	public Collection pesquisarImoveisPorRota(Rota rota,
			SistemaParametro sistemaParametro) throws ControladorException {

		Collection colecaoImoveis = new ArrayList();

		/*
		 * Caso a rota não esteja com o indicador de rota alternativa ativo; a
		 * pesquisa dos imóveis será feita a partir de sua quadra.
		 */
		if (!rota.getIndicadorRotaAlternativa().equals(ConstantesSistema.SIM)) {

			try {

				colecaoImoveis = repositorioMicromedicao
						.pesquisarImoveisPorRotaCompesa(rota,
								sistemaParametro.getNomeAbreviadoEmpresa());

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}
		/*
		 * Caso contrário; a pesquisa dos imóveis será feita a partir da rota
		 * alternativa que estará associada ao mesmo.
		 */
		else {

			try {

				colecaoImoveis = repositorioMicromedicao
						.pesquisarImoveisPorRotaAlternativa(rota,
								sistemaParametro.getNomeAbreviadoEmpresa());

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}

		return colecaoImoveis;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * @author Rômulo Aurélio
	 * @date 07/07/2008
	 */
	public Collection retornaImoveisPorRota(Rota rota,
			SistemaParametro sistemaParametro) throws ControladorException {

		/**
		 * [SB0004]-Recuperar Dados para inclusao na Tabela
		 */

		// inicializa uma coleção de imoveis
		Collection objetosImoveis = new ArrayList();
		// cria uma coleção de imóvel por rota
		Collection imoveisPorRota = null;

		imoveisPorRota = this.pesquisarImoveisPorRota(rota, sistemaParametro);

		if (imoveisPorRota != null && !imoveisPorRota.isEmpty()) {

			Iterator imovelporRotaIterator = imoveisPorRota.iterator();
			while (imovelporRotaIterator.hasNext()) {
				// cria um array de objetos para pegar os parametros
				// de
				// retorno da pesquisa
				Object[] arrayImoveisPorRota = (Object[]) imovelporRotaIterator
						.next();

				// instancia um imóvel
				Imovel imovel = new Imovel();
				if (arrayImoveisPorRota[0] != null) {
					// seta o id no imovel
					imovel.setId((Integer) arrayImoveisPorRota[0]);
				}

				if (arrayImoveisPorRota[1] != null) {
					// instancia uma localidade para ser setado no
					// imóvel
					Localidade localidade = new Localidade();
					localidade.setId((Integer) arrayImoveisPorRota[1]);

					// DESCRIÇÃO
					localidade.setDescricao((String) arrayImoveisPorRota[49]);
					imovel.setLocalidade(localidade);
				}

				if (arrayImoveisPorRota[2] != null) {
					// instancia um setor comercial para ser setado
					// no
					// imóvel
					SetorComercial setorComercial = new SetorComercial();
					setorComercial.setCodigo(Integer
							.parseInt(arrayImoveisPorRota[2].toString()));
					imovel.setSetorComercial(setorComercial);
				}
				Quadra quadra = new Quadra();
				if (arrayImoveisPorRota[3] != null) {
					// instancia uma quadra para ser setado no
					// imóvel

					Integer numeroQuadra = (Integer) arrayImoveisPorRota[3];
					quadra.setNumeroQuadra(numeroQuadra);

					imovel.setQuadra(quadra);
				}

				if (arrayImoveisPorRota[4] != null) {
					// seta o lote no imóvel
					imovel.setLote(Short.parseShort(arrayImoveisPorRota[4]
							.toString()));
				}

				if (arrayImoveisPorRota[5] != null) {
					// seta o lote no imóvel
					imovel.setSubLote(Short.parseShort(arrayImoveisPorRota[5]
							.toString()));
				}
				if (arrayImoveisPorRota[6] != null) {
					// instancia uma imovel perfil para ser setado
					// no
					// imóvel
					ImovelPerfil imovelPerfil = new ImovelPerfil();
					imovelPerfil.setId((Integer) arrayImoveisPorRota[6]);
					imovel.setImovelPerfil(imovelPerfil);
				}

				LigacaoAgua ligacaoAgua = new LigacaoAgua();
				if (arrayImoveisPorRota[7] != null) {
					// instancia uma ligação agua para ser setado no
					// imóvel

					ligacaoAgua.setId((Integer) arrayImoveisPorRota[7]);
				}
				// instancia um hidrometro instalação historico para
				// ser
				// colocado na ligacao agua

				if (arrayImoveisPorRota[30] != null) {

					HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoLigacaoAgua = (HidrometroInstalacaoHistorico) arrayImoveisPorRota[30];
					MedicaoTipo medicaoTipo = new MedicaoTipo();
					medicaoTipo.setId((Integer) arrayImoveisPorRota[26]);
					hidrometroInstalacaoHistoricoLigacaoAgua
							.setMedicaoTipo(medicaoTipo);
					ligacaoAgua
							.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoLigacaoAgua);

				}
				imovel.setLigacaoAgua(ligacaoAgua);

				// //instancia um hidrometro instalação historico
				// para
				// ser colocado no imovel

				if (arrayImoveisPorRota[31] != null) {

					HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel = (HidrometroInstalacaoHistorico) arrayImoveisPorRota[31];
					MedicaoTipo medicaoTipo = new MedicaoTipo();
					medicaoTipo.setId((Integer) arrayImoveisPorRota[27]);
					hidrometroInstalacaoHistoricoImovel
							.setMedicaoTipo(medicaoTipo);
					imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoImovel);

				}
				// instancia a rota
				Rota rotaImovel = new Rota();

				rotaImovel.setLeiturista(rota.getLeiturista());

				if (arrayImoveisPorRota[10] != null) {
					// seta o id da rota
					rotaImovel.setId((Integer) arrayImoveisPorRota[10]);
				}
				if (arrayImoveisPorRota[11] != null) {
					// seta o indicador fiscalizador suprimido na
					// rota
					rotaImovel.setIndicadorFiscalizarSuprimido(Short
							.parseShort(arrayImoveisPorRota[11].toString()));
				}
				if (arrayImoveisPorRota[12] != null) {
					// seta o indicador fiscalizador cortado na rota
					rotaImovel.setIndicadorFiscalizarCortado(Short
							.parseShort(arrayImoveisPorRota[12].toString()));
				}
				if (arrayImoveisPorRota[13] != null) {
					// seta o indicador gerar fiscalizacao na rota
					rotaImovel.setIndicadorGerarFiscalizacao(Short
							.parseShort(arrayImoveisPorRota[13].toString()));
				}
				if (arrayImoveisPorRota[14] != null) {
					// seta o indicador fgerar falsa faixa na rota
					rotaImovel.setIndicadorGerarFalsaFaixa(Short
							.parseShort(arrayImoveisPorRota[14].toString()));
				}
				if (arrayImoveisPorRota[15] != null) {
					// seta o percentual geracao fiscalizacao na
					// rota
					rotaImovel
							.setPercentualGeracaoFiscalizacao((BigDecimal) (arrayImoveisPorRota[15]));
				}
				if (arrayImoveisPorRota[16] != null) {
					// seta o percentual geracao faixa falsa na rota
					rotaImovel
							.setPercentualGeracaoFaixaFalsa((BigDecimal) (arrayImoveisPorRota[16]));
				}

				if (arrayImoveisPorRota[50] != null) {
					// seta o leiturista
					Leiturista leiturista = new Leiturista();
					leiturista.setId((Integer) arrayImoveisPorRota[50]);

					rotaImovel.setLeiturista(leiturista);
				}

				// instancia a empresa
				Empresa empresa = new Empresa();
				if (arrayImoveisPorRota[17] != null) {

					// seta o id na empresa
					empresa.setId((Integer) arrayImoveisPorRota[17]);

				}
				if (arrayImoveisPorRota[18] != null) {

					// seta a descrição abreviada na empresa
					empresa.setDescricaoAbreviada(arrayImoveisPorRota[18]
							.toString());

				}
				if (arrayImoveisPorRota[19] != null) {

					// seta email da empresa
					empresa.setEmail(arrayImoveisPorRota[19].toString());

				}
				if (arrayImoveisPorRota[28] != null) {

					// seta email da empresa
					empresa.setDescricao(arrayImoveisPorRota[28].toString());

				}
				// seta a empresa na rota
				rotaImovel.setEmpresa(empresa);
				// instancia o faturamento
				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				if (arrayImoveisPorRota[20] != null) {
					// seta o id no faturamentGrupo
					faturamentoGrupo.setId((Integer) arrayImoveisPorRota[20]);

				}
				if (arrayImoveisPorRota[21] != null) {
					// seta o descrição no faturamentGrupo
					faturamentoGrupo
							.setDescricao((String) arrayImoveisPorRota[21]);
				}
				// seta o faturamento na rota
				rotaImovel.setFaturamentoGrupo(faturamentoGrupo);
				if (arrayImoveisPorRota[22] != null) {
					// instancia a ligação esgoto situação
					LeituraTipo leituraTipo = new LeituraTipo();
					// seta o id na ligação esgoto situação
					leituraTipo.setId((Integer) arrayImoveisPorRota[22]);
					// seta a ligação esgoto situação no imovel
					rotaImovel.setLeituraTipo(leituraTipo);
				}

				// seta a rota na quadra
				quadra.setRota(rotaImovel);

				// seta o roteiro empresa na quadra
				quadra.setRoteiroEmpresa((RoteiroEmpresa) arrayImoveisPorRota[29]);

				// seta a quadra no imovel
				imovel.setQuadra(quadra);
				if (arrayImoveisPorRota[23] != null) {
					// instancia a ligação agua situação
					LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
					// seta o id na ligação agua situação
					ligacaoAguaSituacao
							.setId((Integer) arrayImoveisPorRota[23]);

					// DESCRIÇÃO
					ligacaoAguaSituacao
							.setDescricao((String) arrayImoveisPorRota[47]);

					// seta a ligação agua situação no imovel
					imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
				}
				if (arrayImoveisPorRota[24] != null) {
					// instancia a ligação esgoto situação
					LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
					// seta o id na ligação esgoto situação
					ligacaoEsgotoSituacao
							.setId((Integer) arrayImoveisPorRota[24]);
					// seta a ligação esgoto situação no imovel
					imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
				}

				if (arrayImoveisPorRota[25] != null) {
					// instancia o faturamento situacao tipo
					FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
					// seta o id no faturamento situacao tipo
					faturamentoSituacaoTipo
							.setIndicadorParalisacaoLeitura((Short) arrayImoveisPorRota[25]);
					// seta a ligação esgoto situação no imovel
					imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
				}

				if (arrayImoveisPorRota[32] != null) {
					imovel.getQuadra().getRota().getEmpresa()
							.setId((Integer) arrayImoveisPorRota[32]);
				}

				if (arrayImoveisPorRota[33] != null) {
					imovel.getLigacaoAguaSituacao()
							.setIndicadorFaturamentoSituacao(
									(Short) arrayImoveisPorRota[33]);
				}

				if (arrayImoveisPorRota[34] != null) {
					imovel.getLigacaoEsgotoSituacao()
							.setIndicadorFaturamentoSituacao(
									(Short) arrayImoveisPorRota[34]);
				}

				if (arrayImoveisPorRota[35] != null) {

					LogradouroBairro logradouroBairro = new LogradouroBairro();

					logradouroBairro.setId((Integer) arrayImoveisPorRota[35]);

					imovel.setLogradouroBairro(logradouroBairro);
				}

				if (arrayImoveisPorRota[36] != null) {

					Logradouro logradouro = new Logradouro();

					logradouro.setId((Integer) arrayImoveisPorRota[36]);

					imovel.getLogradouroBairro().setLogradouro(logradouro);
				}

				if (arrayImoveisPorRota[37] != null) {

					imovel.getLogradouroBairro().getLogradouro()
							.setNome((String) arrayImoveisPorRota[37]);
				}

				if (arrayImoveisPorRota[38] != null) {
					Bairro bairro = new Bairro();
					bairro.setNome((String) arrayImoveisPorRota[38]);

					imovel.getLogradouroBairro().setBairro(bairro);
				}
				if (arrayImoveisPorRota[39] != null) {
					imovel.setNumeroImovel(completaString(
							(String) arrayImoveisPorRota[39], 5));
				}

				if (arrayImoveisPorRota[40] != null) {
					imovel.setNumeroSequencialRota((Integer) arrayImoveisPorRota[40]);
				}
				if (arrayImoveisPorRota[41] != null) {
					ligacaoAgua.setNumeroLacre(completaString(
							(String) arrayImoveisPorRota[41], 6));
				}
				if (arrayImoveisPorRota[42] != null) {
					imovel.setComplementoEndereco((String) arrayImoveisPorRota[42]);
				}
				if (arrayImoveisPorRota[43] != null) {
					GerenciaRegional gerenciaRegional = new GerenciaRegional();
					gerenciaRegional.setId((Integer) arrayImoveisPorRota[43]);
					imovel.getLocalidade()
							.setGerenciaRegional(gerenciaRegional);
				}
				if (arrayImoveisPorRota[44] != null) {

					rotaImovel.setCodigo((Short) arrayImoveisPorRota[44]);
				}

				// QUADRA_FACE
				if (arrayImoveisPorRota[45] != null) {

					QuadraFace quadraFace = new QuadraFace();
					quadraFace.setId((Integer) arrayImoveisPorRota[45]);
					quadraFace
							.setNumeroQuadraFace((Integer) arrayImoveisPorRota[46]);

					imovel.setQuadraFace(quadraFace);
				}

				// NÚMERO DE MORADORES
				if (arrayImoveisPorRota[48] != null) {

					imovel.setNumeroMorador((Short) arrayImoveisPorRota[48]);
				}

				// adiciona na coleção de imoveis
				objetosImoveis.add(imovel);
				arrayImoveisPorRota = null;

			}

		}

		imoveisPorRota.clear();
		imoveisPorRota = null;
		return objetosImoveis;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * @date 07/07/2008
	 * @author Rômulo Aurélio
	 * @param imoveisParaSerGerados
	 * @param anoMesCorrente
	 * @param sistemaParametro
	 * @param idLeituraTipo
	 * @throws ControladorException
	 */

	public void inserirDadosImoveisMovimentoRoteiroEmpresa(
			Collection imoveisParaSerGerados, int anoMesCorrente,
			SistemaParametro sistemaParametro, Integer idLeituraTipo)
 throws ControladorException {

		/**
		 * [SB0004]-Recuperar Dados para inclusao na Tabela
		 */

		Collection colecaoMovimentoRoteiroEmpresa = new ArrayList();

		if (imoveisParaSerGerados != null && !imoveisParaSerGerados.isEmpty()) {

			// Ã© usado para na faixa falsa saber se o hidrometro foi
			// selecionado
			// ou
			// nÃ£o
			boolean hidrometroSelecionado = false;

			Integer quantidadeRegistros = 0;

			Integer quantidadeImoveis = 0;

			ListIterator imovelParaSerGeradoIterator = ((List) imoveisParaSerGerados).listIterator(0);

			Imovel imovelParaSerGerado = null;

			try {

				while (imovelParaSerGeradoIterator.hasNext()) {
					boolean ligacaoAgua = false;
					boolean ligacaoPoco = false;

					imovelParaSerGerado = (Imovel) imovelParaSerGeradoIterator.next();					

					// incrementa a quantidade de registros
					quantidadeRegistros = quantidadeRegistros + 1;

					quantidadeImoveis = quantidadeImoveis + 1;

					if (imovelParaSerGerado.getLigacaoAgua() != null && imovelParaSerGerado.getLigacaoAgua().getId() != null
							&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
							&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null) {
						ligacaoAgua = true;
					}
					if (imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null
							&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId() != null) {
						ligacaoPoco = true;
					}

					MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = new MovimentoRoteiroEmpresa();

					LeituraTipo leituraTipo = new LeituraTipo();
					leituraTipo.setId(idLeituraTipo);

					movimentoRoteiroEmpresa.setLeituraTipo(leituraTipo);

					movimentoRoteiroEmpresa.setAnoMesMovimento(anoMesCorrente);

					if (imovelParaSerGerado.getQuadra() != null) {

						movimentoRoteiroEmpresa.setRoteiroEmpresa(imovelParaSerGerado.getQuadra().getRoteiroEmpresa());
						movimentoRoteiroEmpresa.setNumeroQuadra(imovelParaSerGerado.getQuadra().getNumeroQuadra());

						if (imovelParaSerGerado.getQuadra().getRota() != null) {
							// id do grupo de faturamento
							movimentoRoteiroEmpresa.setFaturamentoGrupo(imovelParaSerGerado.getQuadra().getRota().getFaturamentoGrupo());
						}

						if (imovelParaSerGerado.getQuadra().getRoteiroEmpresa() != null) {
							movimentoRoteiroEmpresa.setEmpresa(imovelParaSerGerado.getQuadra().getRoteiroEmpresa().getEmpresa());
						} else {
							movimentoRoteiroEmpresa.setEmpresa(imovelParaSerGerado.getQuadra().getRota().getEmpresa());
						}

						// LEITURISTA
						movimentoRoteiroEmpresa.setLeiturista(imovelParaSerGerado.getQuadra().getRota().getLeiturista());
					}

					// QUADRA_FACE
					if (imovelParaSerGerado.getQuadraFace() != null) {

						movimentoRoteiroEmpresa.setCodigoQuadraFace(imovelParaSerGerado.getQuadraFace().getNumeroQuadraFace());
					}

					movimentoRoteiroEmpresa.setLocalidade(imovelParaSerGerado.getLocalidade());

					// DESCRIÇÃO DA LOCALIDADE
					movimentoRoteiroEmpresa.setNomeLocalidade(imovelParaSerGerado.getLocalidade().getDescricao());

					FiltroImovel filtroDadosImovelRotaAlternativa = new FiltroImovel();
					filtroDadosImovelRotaAlternativa.adicionarCaminhoParaCarregamentoEntidade("rotaAlternativa.setorComercial");
					filtroDadosImovelRotaAlternativa.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovelParaSerGerado.getId()));
					Collection<Imovel> colDadosImovelRotaAlternativa = this.getControladorUtil().pesquisar(filtroDadosImovelRotaAlternativa,
							Imovel.class.getName());
					Imovel dadosImovelRotaAlternativa = (Imovel) Util.retonarObjetoDeColecao(colDadosImovelRotaAlternativa);

					if (dadosImovelRotaAlternativa.getRotaAlternativa() != null) {
						imovelParaSerGerado.setRotaAlternativa(dadosImovelRotaAlternativa.getRotaAlternativa());
					}

					if (imovelParaSerGerado.getRotaAlternativa() != null) {
						movimentoRoteiroEmpresa.setCodigoSetorComercial(imovelParaSerGerado.getRotaAlternativa().getSetorComercial().getCodigo());
					} else {
						movimentoRoteiroEmpresa.setCodigoSetorComercial(imovelParaSerGerado.getSetorComercial().getCodigo());
					}

					movimentoRoteiroEmpresa.setNumeroLoteImovel(Util.adicionarZerosEsquedaNumero(4, "" + imovelParaSerGerado.getLote()));
					movimentoRoteiroEmpresa.setNumeroSubloteImovel(Util.adicionarZerosEsquedaNumero(3, "" + imovelParaSerGerado.getSubLote()));

					movimentoRoteiroEmpresa.setImovelPerfil(imovelParaSerGerado.getImovelPerfil());

					// NÚMERO DE MORADORES
					if (imovelParaSerGerado.getNumeroMorador() != null) {

						movimentoRoteiroEmpresa.setNumeroMoradores(imovelParaSerGerado.getNumeroMorador().intValue());
					}

					// caso seja tipo ligaÃ§Ã£o agua e poÃ§o cria a string
					// primeiro
					// com
					// tipo
					// ligaÃ§Ã£o agua
					if (ligacaoAgua && ligacaoPoco) {

						if (imovelParaSerGerado.getLigacaoAgua() != null && imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
								&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null
								&& !imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId().equals("")) {

							movimentoRoteiroEmpresa.setMedicaoTipo(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getMedicaoTipo());
						}
						// caso nÃ£o seja
					} else {
						// caso seja tipo ligaÃ§Ã£o agua cria a string com
						// tipo
						// ligaÃ§Ã£o agua
						if (ligacaoAgua) {
							if (imovelParaSerGerado.getLigacaoAgua() != null && imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
									&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null
									&& !imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId().equals("")) {
								movimentoRoteiroEmpresa
										.setMedicaoTipo(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getMedicaoTipo());
							}
						} else {
							// caso seja tipo ligaÃ§Ã£o poÃ§o cria a string
							// com
							// tipo
							// ligaÃ§Ã£o poÃ§o
							if (ligacaoPoco) {
								if (imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null
										&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId() != null
										&& !imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId().equals("")) {
									movimentoRoteiroEmpresa.setMedicaoTipo(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getMedicaoTipo());
								}
							}
						}
					}

					// Matricula do imÃ³vel
					movimentoRoteiroEmpresa.setImovel(imovelParaSerGerado);

					// Perfil do imovel
					movimentoRoteiroEmpresa.setImovelPerfil(imovelParaSerGerado.getImovelPerfil());

					String nomeClienteUsuario = null;
					// Pesquisa o nome do cliente que tem o tipo de
					// relaÃ§Ã£o
					// usuÃ¡rio.
					try {
						nomeClienteUsuario = repositorioClienteImovel.pesquisarNomeClientePorImovel(imovelParaSerGerado.getId());
					} catch (ErroRepositorioException e) {

						throw new ControladorException("erro.sistema", e);

					}

					// nome do cliente usuario
					movimentoRoteiroEmpresa.setNomeCliente(Util.completaString(nomeClienteUsuario, 30));

					// Pesquisa o endereÃ§o do imovel passando o id
					String enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(imovelParaSerGerado.getId());

					movimentoRoteiroEmpresa.setEnderecoImovel(Util.completaString(enderecoImovel, 100));

					// Dados do Hidrometro
					// caso seja tipo ligação agua e poçoo cria a string
					// primeiro
					// com
					// tipo
					// ligaÃ§Ã£o agua
					Short numeroDigitosHidrometro = null;
					StringBuilder dadosHidrometro = null;
					Integer capacidadeHidrometro = null;
					Integer marcaHidrometro = null;

					if (ligacaoAgua && ligacaoPoco) {

						Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);

						dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
						numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
						capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
						marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

						HidrometroCapacidade capacidade = new HidrometroCapacidade();
						capacidade.setId(capacidadeHidrometro);
						movimentoRoteiroEmpresa.setHidrometroCapacidade(capacidade);

						HidrometroMarca hidrometroMarca = new HidrometroMarca();
						hidrometroMarca.setId(marcaHidrometro);
						movimentoRoteiroEmpresa.setHidrometroMarca(hidrometroMarca);

						movimentoRoteiroEmpresa.setNumeroHidrometro(Util.completaString((String) dadosHidrometroNumeroLeitura[4], 10));

						movimentoRoteiroEmpresa.setDescricaoHidrometroMarca((String) dadosHidrometroNumeroLeitura[5]);

						// caso nÃ£o seja
					} else {
						// caso seja tipo ligaÃ§Ã£o agua cria a string com
						// tipo
						// ligaÃ§Ã£o agua
						if (ligacaoAgua) {

							Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);

							dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
							numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
							capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
							marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

							HidrometroCapacidade capacidade = new HidrometroCapacidade();
							capacidade.setId(capacidadeHidrometro);
							movimentoRoteiroEmpresa.setHidrometroCapacidade(capacidade);

							HidrometroMarca hidrometroMarca = new HidrometroMarca();
							hidrometroMarca.setId(marcaHidrometro);
							movimentoRoteiroEmpresa.setHidrometroMarca(hidrometroMarca);

							movimentoRoteiroEmpresa.setNumeroHidrometro(Util.completaString((String) dadosHidrometroNumeroLeitura[4], 10));

							movimentoRoteiroEmpresa.setDescricaoHidrometroMarca((String) dadosHidrometroNumeroLeitura[5]);

							// caso nÃ£o seja
						} else {
							// caso seja tipo ligaÃ§Ã£o poÃ§o cria a string
							// com
							// tipo
							// ligaÃ§Ã£o poÃ§o
							if (ligacaoPoco) {

								Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);

								dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
								numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
								capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
								marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

								HidrometroCapacidade capacidade = new HidrometroCapacidade();
								capacidade.setId(capacidadeHidrometro);
								movimentoRoteiroEmpresa.setHidrometroCapacidade(capacidade);

								HidrometroMarca hidrometroMarca = new HidrometroMarca();
								hidrometroMarca.setId(marcaHidrometro);
								movimentoRoteiroEmpresa.setHidrometroMarca(hidrometroMarca);

								movimentoRoteiroEmpresa.setNumeroHidrometro(Util.completaString((String) dadosHidrometroNumeroLeitura[4], 10));

								movimentoRoteiroEmpresa.setDescricaoHidrometroMarca((String) dadosHidrometroNumeroLeitura[5]);

								// caso nÃ£o seja nem um nem outro entÃ£o
								// pode
								// chamar
								// qualquer um dos mÃ©todos
								// pois os dois fazem a verificaÃ§Ã£o e
								// retorna
								// strings
								// vazia e
								// a data cpm zeros
							} else {
								Object[] dadosHidrometroNumeroLeitura = this.pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);

								dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
								numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
								capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
								marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

								HidrometroCapacidade capacidade = new HidrometroCapacidade();
								capacidade.setId(capacidadeHidrometro);
								movimentoRoteiroEmpresa.setHidrometroCapacidade(capacidade);

								HidrometroMarca hidrometroMarca = new HidrometroMarca();
								hidrometroMarca.setId(marcaHidrometro);
								movimentoRoteiroEmpresa.setHidrometroMarca(hidrometroMarca);

								movimentoRoteiroEmpresa.setNumeroHidrometro(Util.completaString((String) dadosHidrometroNumeroLeitura[4], 10));

								movimentoRoteiroEmpresa.setDescricaoHidrometroMarca((String) dadosHidrometroNumeroLeitura[5]);
							}
						}
					}

					if (imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null) {

						movimentoRoteiroEmpresa.setHidrometroLocalInstalacao(imovelParaSerGerado.getHidrometroInstalacaoHistorico()
								.getHidrometroLocalInstalacao());

						movimentoRoteiroEmpresa.setDataInstalacaoHidrometro(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getDataInstalacao());

						movimentoRoteiroEmpresa.setHidrometroProtecao(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getHidrometroProtecao());

					}

					if (imovelParaSerGerado.getLigacaoAgua() != null && imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) {

						movimentoRoteiroEmpresa.setHidrometroLocalInstalacao(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico()
								.getHidrometroLocalInstalacao());

						movimentoRoteiroEmpresa.setDataInstalacaoHidrometro(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico()
								.getDataInstalacao());

						movimentoRoteiroEmpresa.setHidrometroProtecao(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico()
								.getHidrometroProtecao());

					}

					// id da ligacao agua situaÃ§Ã£o
					if (imovelParaSerGerado.getLigacaoAguaSituacao() != null && imovelParaSerGerado.getLigacaoAguaSituacao().getId() != null) {
						// SituaÃ§Ã£o da ligaÃ§Ã£o de agua
						movimentoRoteiroEmpresa.setLigacaoAguaSituacao(imovelParaSerGerado.getLigacaoAguaSituacao());

						// DESCRIÇÃO
						movimentoRoteiroEmpresa.setDescricaoLigacaoAguaSituacao(imovelParaSerGerado.getLigacaoAguaSituacao().getDescricao());
					}

					// id da ligacao esgoto situaÃ§Ã£o
					if (imovelParaSerGerado.getLigacaoEsgotoSituacao() != null && imovelParaSerGerado.getLigacaoEsgotoSituacao().getId() != null) {
						// SituaÃ§Ã£o de ligaÃ§Ã£o esgoto
						movimentoRoteiroEmpresa.setLigacaoEsgotoSituacao(imovelParaSerGerado.getLigacaoEsgotoSituacao());
					}

					// pega as descriÃ§Ãµes das categorias do imovel

					Categoria categoria = getControladorImovel().obterDescricoesCategoriaImovel(imovelParaSerGerado);

					// quantidade de economias
					movimentoRoteiroEmpresa.setDescricaoAbreviadaCategoriaImovel(categoria.getDescricaoAbreviada());

					// [UC0086 - Obter quantidade de economias]
					int quantidadeEconomias = getControladorImovel().obterQuantidadeEconomias(imovelParaSerGerado);
					// quantidade de economias
					movimentoRoteiroEmpresa.setQuantidadeEconomias(new Integer(quantidadeEconomias).shortValue());

					// Leitura anterior
					Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);
					String leituraAnterior = null;
					Integer idMedicaoTipo = null;
					MedicaoHistorico medicaoHistorico = null;

					Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior, imovelParaSerGerado);

					// verifica se a leitura anterior Ã© diferente de
					// nula
					if (retorno[0] != null) {
						leituraAnterior = retorno[0].toString();
					}
					// verifica se a leitura situaÃ§Ã£o atual Ã© diferente
					// de
					// nula
					if (retorno[1] != null) {
						medicaoHistorico = (MedicaoHistorico) retorno[1];
					}
					// verifica se o id da mediÃ§Ã£o tipo Ã© diferente de
					// nula
					if (retorno[2] != null) {
						idMedicaoTipo = (Integer) retorno[2];
					}

					// verifica se a leitura anterior Ã© diferente de
					// nula
					// para
					// ser
					// jogado no arquivo
					// txt
					if (leituraAnterior != null) {
						movimentoRoteiroEmpresa.setNumeroLeituraAnterior(new Integer(leituraAnterior));
						// caso contrario coloca a string com zeros
					} else {
						movimentoRoteiroEmpresa.setNumeroLeituraAnterior(new Integer(0));
					}

					// ANORMALIDADE DE LEITURA ANTERIOR
					if (medicaoHistorico != null && medicaoHistorico.getLeituraAnormalidadeInformada() != null) {

						movimentoRoteiroEmpresa.setCodigoAnormalidadeAnterior(medicaoHistorico.getLeituraAnormalidadeInformada().getId());

						movimentoRoteiroEmpresa.setDescricaoAnormalidadeAnterior(medicaoHistorico.getLeituraAnormalidadeInformada().getDescricao());
					}

					// DATA DA LEITURA ANTERIOR
					if (medicaoHistorico != null && medicaoHistorico.getDataLeituraAtualFaturamento() != null) {

						movimentoRoteiroEmpresa.setDataLeituraAnterior(medicaoHistorico.getDataLeituraAtualFaturamento());
					}

					// Faixa de leitura esperada

					Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsaCelular(imovelParaSerGerado, dadosHidrometro, leituraAnterior, medicaoHistorico,
							idMedicaoTipo, sistemaParametro, hidrometroSelecionado, numeroDigitosHidrometro);

					hidrometroSelecionado = Boolean.parseBoolean(faixaInicialFinal[1].toString());

					boolean faixaFalsaLeitura = Boolean.parseBoolean(faixaInicialFinal[2].toString());

					int faixaInicialEsperada = 0;
					int faixaFinalEsperada = 0;

					if (!faixaFalsaLeitura) {
						faixaInicialEsperada = Integer.parseInt(faixaInicialFinal[3].toString());

						faixaFinalEsperada = Integer.parseInt(faixaInicialFinal[4].toString());
					}

					movimentoRoteiroEmpresa.setNumeroFaixaLeituraEsperadaInicial(faixaInicialEsperada);
					movimentoRoteiroEmpresa.setNumeroFaixaLeituraEsperadaFinal(faixaFinalEsperada);

					movimentoRoteiroEmpresa.setUltimaAlteracao(new Date());

					if (imovelParaSerGerado.getRotaAlternativa() != null) {
						movimentoRoteiroEmpresa.setRota(imovelParaSerGerado.getRotaAlternativa());
					} else {
						movimentoRoteiroEmpresa.setRota(imovelParaSerGerado.getQuadra().getRota());
					}

					/**
					 * Obtem a colecao economias por categoria
					 * 
					 */

					Collection colecaoSubCategoria = this.getControladorImovel().obterQuantidadeEconomiasSubCategoria(imovelParaSerGerado.getId());

					// 1.10.1 - SubCategoria 01
					// 1.10.2 - Quantidade 01
					// 1.10.3 - SubCategoria 02
					// 1.10.4 - Quantidade 02
					if (colecaoSubCategoria != null && !colecaoSubCategoria.isEmpty()) {

						Iterator itera = colecaoSubCategoria.iterator();

						for (int i = 0; i < 2; i++) {

							while (itera.hasNext()) {

								Subcategoria subcategoria = (Subcategoria) itera.next();

								// tipoEconomia = categoria_id(1
								// posiÃ§Ã£o) +
								// subcategoria_codigo(3 posiÃ§Ãµes)

								if (i == 0) {
									// CÃ³digo da subcategoria do imovel
									movimentoRoteiroEmpresa.setCodigoSubcategoria1(subcategoria.getCodigo());
									// qtdeEconomia
									movimentoRoteiroEmpresa.setQuantidadeEconomias(subcategoria.getQuantidadeEconomias().shortValue());
								} else {

									// CÃ³digo da 2 subcategoria do
									// imovel
									movimentoRoteiroEmpresa.setCodigoSubcategoria2(subcategoria.getCodigo());
									// qtdeEconomia
									movimentoRoteiroEmpresa.setQuantidadeEconomias2(subcategoria.getQuantidadeEconomias().shortValue());
								}

							}
						}
					}
					// 1.11 - Consumo
					Integer numeroConsumoFaturadoMes = null;

					Integer anoMesFaturamento = sistemaParametro.getAnoMesFaturamento();

					try {

						// 1.11.1 - Consumo 01
						int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 6);

						numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovelParaSerGerado.getId(),
								anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

						// caso o numero consumo faturado do mes for
						// diferente de nulo
						if (numeroConsumoFaturadoMes != null) {

							movimentoRoteiroEmpresa.setNumeroConsumoFaturadoMenos6Meses(numeroConsumoFaturadoMes);

						}

						// 1.11.2 - Consumo 02
						anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 5);

						numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovelParaSerGerado.getId(),
								anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

						// caso o numero consumo faturado do mes for
						// diferente de nulo
						if (numeroConsumoFaturadoMes != null) {

							movimentoRoteiroEmpresa.setNumeroConsumoFaturadoMenos5Meses(numeroConsumoFaturadoMes);

						}

						// 1.11.3 - Consumo 03
						anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 4);

						numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovelParaSerGerado.getId(),
								anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

						// caso o numero consumo faturado do mes for
						// diferente de nulo
						if (numeroConsumoFaturadoMes != null) {

							movimentoRoteiroEmpresa.setNumeroConsumoFaturadoMenos4Meses(numeroConsumoFaturadoMes);

						}

						// 1.12 - CondiÃ§Ã£o
						String condicao = null;

						condicao = this.repositorioMicromedicao.obterDescricaoConsumoTipo(imovelParaSerGerado.getId(), LigacaoTipo.LIGACAO_AGUA);

						if (condicao != null) {
							movimentoRoteiroEmpresa.setDescricaoConsumoTipo(Util.completaStringComEspacoAEsquerda("" + condicao, 15));
						}

						// 1.13 - NÃºmero do Lacre
						if (imovelParaSerGerado.getLigacaoAgua() != null && imovelParaSerGerado.getLigacaoAgua().getNumeroLacre() != null) {
							movimentoRoteiroEmpresa.setNumeroLacreLigacaoAgua(Util.completaStringComEspacoAEsquerda(""
									+ imovelParaSerGerado.getLigacaoAgua().getNumeroLacre(), 6));
						}

						// 1.14 - Sequencial da Rota

						movimentoRoteiroEmpresa.setNumeroSequencialRota(imovelParaSerGerado.getNumeroSequencialRota());

						// 1.15 - Consumo 04

						anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 3);

						try {
							numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(
									imovelParaSerGerado.getId(), anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);
						} catch (ErroRepositorioException e) {
							throw new ControladorException("erro.sistema", e);
						}

						// caso o numero consumo faturado do mes for
						// diferente
						// de nulo
						if (numeroConsumoFaturadoMes != null) {

							movimentoRoteiroEmpresa.setNumeroConsumoFaturadoMenos3Meses(numeroConsumoFaturadoMes);

						}

						// 1.16 - Consumo 05
						anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 2);
						try {
							numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(
									imovelParaSerGerado.getId(), anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

						} catch (ErroRepositorioException e) {
							throw new ControladorException("erro.sistema", e);
						}

						// caso o numero consumo faturado do mes for
						// diferente
						// de nulo
						if (numeroConsumoFaturadoMes != null) {

							movimentoRoteiroEmpresa.setNumeroConsumoFaturadoMenos2Meses(numeroConsumoFaturadoMes);

						}

						// 1.17 - Consumo 06
						anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 1);

						numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovelParaSerGerado.getId(),
								anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}

					// caso o numero consumo faturado do mes for
					// diferente
					// de nulo
					if (numeroConsumoFaturadoMes != null) {

						movimentoRoteiroEmpresa.setNumeroConsumoFaturadoMenos1Mes(numeroConsumoFaturadoMes);

					}

					// 1.18 - Consumo Medio

					Integer numeroConsumoMedio = null;
					try {

						numeroConsumoMedio = this.repositorioMicromedicao.pesquisarNumeroConsumoMedioImovel(imovelParaSerGerado.getId(), anoMesAnterior,
								LigacaoTipo.LIGACAO_AGUA);

					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}

					if (numeroConsumoMedio != null) {
						movimentoRoteiroEmpresa.setNumeroConsumoMedio(numeroConsumoMedio);
					}

					// 1.19 -Rota
					if (imovelParaSerGerado.getRotaAlternativa() != null) {
						movimentoRoteiroEmpresa.setCodigoRota(imovelParaSerGerado.getRotaAlternativa().getCodigo());
					} else {
						movimentoRoteiroEmpresa.setCodigoRota(imovelParaSerGerado.getQuadra().getRota().getCodigo());
					}

					// 1.20 - Codigo Logradouro

					Logradouro logradouro = new Logradouro();
					logradouro.setId(imovelParaSerGerado.getLogradouroBairro().getLogradouro().getId());

					movimentoRoteiroEmpresa.setLogradouro(logradouro);

					// 1.21 - Nome do Logradouro

					movimentoRoteiroEmpresa.setNomeLogradouro(imovelParaSerGerado.getLogradouroBairro().getLogradouro().getNome());

					// 1.22 - Numero do Imovel

					movimentoRoteiroEmpresa.setNumeroImovel(imovelParaSerGerado.getNumeroImovel());

					// 1.23 - Complemento

					movimentoRoteiroEmpresa.setComplementoEndereco(imovelParaSerGerado.getComplementoEndereco());

					// 1.24 - Nome do Bairro

					movimentoRoteiroEmpresa.setNomeBairro(imovelParaSerGerado.getLogradouroBairro().getBairro().getNome());

					// 1.25 - Id da Categoria

					Categoria categoria1 = (Categoria) getControladorImovel().obterPrincipalCategoriaImovel(imovelParaSerGerado.getId());

					movimentoRoteiroEmpresa.setCategoriaPrincipal(categoria1);
					// 1.1 Incricao do Imovel
					movimentoRoteiroEmpresa.setInscricaoImovel(imovelParaSerGerado.getInscricaoFormatada());

					// Id gerencia Regional

					GerenciaRegional gerenciaRegional = new GerenciaRegional();

					gerenciaRegional.setId(imovelParaSerGerado.getLocalidade().getGerenciaRegional().getId());

					movimentoRoteiroEmpresa.setGerenciaRegional(gerenciaRegional);

					// Caso Imovel tenha Ligacao de Agua e de PoÃ§o
					if (ligacaoAgua && ligacaoPoco) {

						MovimentoRoteiroEmpresa movimentoRoteiroEmpresaPoco = new MovimentoRoteiroEmpresa();

						movimentoRoteiroEmpresaPoco.setAnoMesMovimento(movimentoRoteiroEmpresa.getAnoMesMovimento());

						if (movimentoRoteiroEmpresa.getCategoria2() != null) {
							movimentoRoteiroEmpresaPoco.setCategoria2(movimentoRoteiroEmpresa.getCategoria2());
						}

						if (movimentoRoteiroEmpresa.getCategoriaPrincipal() != null) {
							movimentoRoteiroEmpresaPoco.setCategoriaPrincipal(movimentoRoteiroEmpresa.getCategoriaPrincipal());
						}

						movimentoRoteiroEmpresaPoco.setCodigoRota(movimentoRoteiroEmpresa.getCodigoRota());

						movimentoRoteiroEmpresaPoco.setCodigoSetorComercial(movimentoRoteiroEmpresa.getCodigoSetorComercial());

						if (movimentoRoteiroEmpresa.getCodigoSubcategoria1() != null) {

							movimentoRoteiroEmpresaPoco.setCodigoSubcategoria1(movimentoRoteiroEmpresa.getCodigoSubcategoria1());

						}
						if (movimentoRoteiroEmpresa.getCodigoSubcategoria2() != null) {
							movimentoRoteiroEmpresaPoco.setCodigoSubcategoria2(movimentoRoteiroEmpresa.getCodigoSubcategoria2());
						}

						if (movimentoRoteiroEmpresa.getComplementoEndereco() != null) {
							movimentoRoteiroEmpresaPoco.setComplementoEndereco(movimentoRoteiroEmpresa.getComplementoEndereco());
						}

						if (movimentoRoteiroEmpresa.getDataHoraProcessamento() != null) {
							movimentoRoteiroEmpresaPoco.setDataHoraProcessamento(movimentoRoteiroEmpresa.getDataHoraProcessamento());
						}

						if (movimentoRoteiroEmpresa.getDataInstalacaoHidrometro() != null) {
							movimentoRoteiroEmpresaPoco.setDataInstalacaoHidrometro(movimentoRoteiroEmpresa.getDataInstalacaoHidrometro());
						}

						if (movimentoRoteiroEmpresa.getDescricaoAbreviadaCategoriaImovel() != null) {
							movimentoRoteiroEmpresaPoco.setDescricaoAbreviadaCategoriaImovel(movimentoRoteiroEmpresa.getDescricaoAbreviadaCategoriaImovel());
						}

						if (movimentoRoteiroEmpresa.getDescricaoAbreviadaLogradouroTipo() != null) {
							movimentoRoteiroEmpresaPoco.setDescricaoAbreviadaLogradouroTipo(movimentoRoteiroEmpresa.getDescricaoAbreviadaLogradouroTipo());
						}

						if (movimentoRoteiroEmpresa.getDescricaoAbreviadaLogradouroTitulo() != null) {
							movimentoRoteiroEmpresaPoco.setDescricaoAbreviadaLogradouroTitulo(movimentoRoteiroEmpresa.getDescricaoAbreviadaLogradouroTitulo());
						}

						if (movimentoRoteiroEmpresa.getDescricaoConsumoTipo() != null) {
							movimentoRoteiroEmpresaPoco.setDescricaoConsumoTipo(movimentoRoteiroEmpresa.getDescricaoConsumoTipo());
						}

						if (movimentoRoteiroEmpresa.getEmpresa() != null) {
							movimentoRoteiroEmpresaPoco.setEmpresa(movimentoRoteiroEmpresa.getEmpresa());
						}

						if (movimentoRoteiroEmpresa.getEnderecoImovel() != null) {
							movimentoRoteiroEmpresaPoco.setEnderecoImovel(movimentoRoteiroEmpresa.getEnderecoImovel());
						}

						if (movimentoRoteiroEmpresa.getFaturamentoGrupo() != null) {
							movimentoRoteiroEmpresaPoco.setFaturamentoGrupo(movimentoRoteiroEmpresa.getFaturamentoGrupo());
						}

						if (movimentoRoteiroEmpresa.getGerenciaRegional() != null) {
							movimentoRoteiroEmpresaPoco.setGerenciaRegional(movimentoRoteiroEmpresa.getGerenciaRegional());
						}

						if (movimentoRoteiroEmpresa.getHidrometroProtecao() != null) {
							movimentoRoteiroEmpresaPoco.setHidrometroProtecao(movimentoRoteiroEmpresa.getHidrometroProtecao());
						}

						if (movimentoRoteiroEmpresa.getImovel() != null) {
							movimentoRoteiroEmpresaPoco.setImovel(movimentoRoteiroEmpresa.getImovel());
						}

						if (movimentoRoteiroEmpresa.getImovelPerfil() != null) {
							movimentoRoteiroEmpresaPoco.setImovelPerfil(movimentoRoteiroEmpresa.getImovelPerfil());
						}

						if (movimentoRoteiroEmpresa.getIndicadorAtualizacaoLeitura() != null) {
							movimentoRoteiroEmpresaPoco.setIndicadorAtualizacaoLeitura(movimentoRoteiroEmpresa.getIndicadorAtualizacaoLeitura());
						}
						if (movimentoRoteiroEmpresa.getIndicadorConfirmacaoLeitura() != null) {
							movimentoRoteiroEmpresaPoco.setIndicadorConfirmacaoLeitura(movimentoRoteiroEmpresa.getIndicadorConfirmacaoLeitura());
						}

						if (movimentoRoteiroEmpresa.getInscricaoImovel() != null) {
							movimentoRoteiroEmpresaPoco.setInscricaoImovel(movimentoRoteiroEmpresa.getInscricaoImovel());
						}

						if (movimentoRoteiroEmpresa.getLeituraAnormalidade() != null) {
							movimentoRoteiroEmpresaPoco.setLeituraAnormalidade(movimentoRoteiroEmpresa.getLeituraAnormalidade());
						}

						if (movimentoRoteiroEmpresa.getLeituraTipo() != null) {
							movimentoRoteiroEmpresaPoco.setLeituraTipo(movimentoRoteiroEmpresa.getLeituraTipo());
						}

						if (movimentoRoteiroEmpresa.getLigacaoAguaSituacao() != null) {
							movimentoRoteiroEmpresaPoco.setLigacaoAguaSituacao(movimentoRoteiroEmpresa.getLigacaoAguaSituacao());
						}

						if (movimentoRoteiroEmpresa.getLigacaoEsgotoSituacao() != null) {
							movimentoRoteiroEmpresaPoco.setLigacaoEsgotoSituacao(movimentoRoteiroEmpresa.getLigacaoEsgotoSituacao());
						}

						if (movimentoRoteiroEmpresa.getLocalidade() != null) {
							movimentoRoteiroEmpresaPoco.setLocalidade(movimentoRoteiroEmpresa.getLocalidade());
						}

						if (movimentoRoteiroEmpresa.getLogradouro() != null) {
							movimentoRoteiroEmpresaPoco.setLogradouro(movimentoRoteiroEmpresa.getLogradouro());
						}

						if (movimentoRoteiroEmpresa.getNomeBairro() != null) {
							movimentoRoteiroEmpresaPoco.setNomeBairro(movimentoRoteiroEmpresa.getNomeBairro());
						}

						if (movimentoRoteiroEmpresa.getNomeCliente() != null) {
							movimentoRoteiroEmpresaPoco.setNomeCliente(movimentoRoteiroEmpresa.getNomeCliente());
						}

						if (movimentoRoteiroEmpresa.getNomeLeiturista() != null) {
							movimentoRoteiroEmpresaPoco.setNomeLeiturista(movimentoRoteiroEmpresa.getNomeLeiturista());
						}

						if (movimentoRoteiroEmpresa.getNomeLogradouro() != null) {
							movimentoRoteiroEmpresaPoco.setNomeLogradouro(movimentoRoteiroEmpresa.getNomeLogradouro());
						}

						if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos1Mes() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroConsumoFaturadoMenos1Mes(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos1Mes());
						}

						if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos2Meses() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroConsumoFaturadoMenos2Meses(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos2Meses());
						}
						if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos3Meses() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroConsumoFaturadoMenos3Meses(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos3Meses());
						}

						if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos4Meses() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroConsumoFaturadoMenos4Meses(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos4Meses());
						}

						if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos5Meses() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroConsumoFaturadoMenos5Meses(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos5Meses());
						}

						if (movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos6Meses() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroConsumoFaturadoMenos6Meses(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoMenos6Meses());
						}

						if (movimentoRoteiroEmpresa.getNumeroImovel() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroImovel(movimentoRoteiroEmpresa.getNumeroImovel());
						}

						if (movimentoRoteiroEmpresa.getNumeroLacreLigacaoAgua() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroLacreLigacaoAgua(movimentoRoteiroEmpresa.getNumeroLacreLigacaoAgua());
						}

						if (movimentoRoteiroEmpresa.getNumeroLeituraAnterior() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroLeituraAnterior(movimentoRoteiroEmpresa.getNumeroLeituraAnterior());
						}

						if (movimentoRoteiroEmpresa.getNumeroLoteImovel() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroLoteImovel(movimentoRoteiroEmpresa.getNumeroLoteImovel());
						}

						if (movimentoRoteiroEmpresa.getNumeroQuadra() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroQuadra(movimentoRoteiroEmpresa.getNumeroQuadra());
						}

						if (movimentoRoteiroEmpresa.getNumeroSequencialRota() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroSequencialRota(movimentoRoteiroEmpresa.getNumeroSequencialRota());

						}

						if (movimentoRoteiroEmpresa.getNumeroSubloteImovel() != null) {
							movimentoRoteiroEmpresaPoco.setNumeroSubloteImovel(movimentoRoteiroEmpresa.getNumeroSubloteImovel());

						}

						if (movimentoRoteiroEmpresa.getQuantidadeEconomias() != null) {
							movimentoRoteiroEmpresaPoco.setQuantidadeEconomias(movimentoRoteiroEmpresa.getQuantidadeEconomias());

						}

						if (movimentoRoteiroEmpresa.getQuantidadeEconomias2() != null) {
							movimentoRoteiroEmpresaPoco.setQuantidadeEconomias2(movimentoRoteiroEmpresa.getQuantidadeEconomias2());

						}

						if (movimentoRoteiroEmpresa.getRota() != null) {
							movimentoRoteiroEmpresaPoco.setRota(movimentoRoteiroEmpresa.getRota());

						}

						if (movimentoRoteiroEmpresa.getRoteiroEmpresa() != null) {
							movimentoRoteiroEmpresaPoco.setRoteiroEmpresa(movimentoRoteiroEmpresa.getRoteiroEmpresa());

						}

						if (movimentoRoteiroEmpresa.getTempoLeitura() != null) {
							movimentoRoteiroEmpresaPoco.setTempoLeitura(movimentoRoteiroEmpresa.getTempoLeitura());

						}

						if (movimentoRoteiroEmpresa.getUltimaAlteracao() != null) {
							movimentoRoteiroEmpresaPoco.setUltimaAlteracao(movimentoRoteiroEmpresa.getUltimaAlteracao());

						}

						// Medicao Tipo
						MedicaoTipo medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId(MedicaoTipo.POCO);

						movimentoRoteiroEmpresaPoco.setMedicaoTipo(medicaoTipo);

						Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);

						dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
						numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
						capacidadeHidrometro = (Integer) dadosHidrometroNumeroLeitura[2];
						marcaHidrometro = (Integer) dadosHidrometroNumeroLeitura[3];

						// Capacidade Hidrometro
						HidrometroCapacidade capacidade = new HidrometroCapacidade();
						capacidade.setId(capacidadeHidrometro);
						movimentoRoteiroEmpresaPoco.setHidrometroCapacidade(capacidade);

						// Marca do Hidrometro
						HidrometroMarca hidrometroMarca = new HidrometroMarca();
						hidrometroMarca.setId(marcaHidrometro);
						movimentoRoteiroEmpresaPoco.setHidrometroMarca(hidrometroMarca);

						// Numero Hidrometro
						movimentoRoteiroEmpresaPoco.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);

						movimentoRoteiroEmpresaPoco.setDescricaoHidrometroMarca((String) dadosHidrometroNumeroLeitura[5]);

						if (imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null) {

							// Local de InstalaÃ§Ã£o
							movimentoRoteiroEmpresaPoco.setHidrometroLocalInstalacao(imovelParaSerGerado.getHidrometroInstalacaoHistorico()
									.getHidrometroLocalInstalacao());

							// Data de InstalaÃ§Ã£o
							movimentoRoteiroEmpresaPoco.setDataInstalacaoHidrometro(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getDataInstalacao());

							// ProteÃ§Ã£o do Hidrometro
							movimentoRoteiroEmpresaPoco.setHidrometroProtecao(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getHidrometroProtecao());

						}

						// verifica se a leitura anterior Ã© diferente de
						// nula
						if (retorno[3] != null) {
							leituraAnterior = retorno[3].toString();
						} else {
							leituraAnterior = "0";
						}
						// verifica se a leitura situaÃ§Ã£o atual Ã© diferente
						// de
						// nula
						if (retorno[4] != null) {
							medicaoHistorico = (MedicaoHistorico) retorno[4];
						} else {
							medicaoHistorico = new MedicaoHistorico();
						}
						// verifica se o id da mediÃ§Ã£o tipo Ã© diferente de
						// nula
						if (retorno[5] != null) {
							idMedicaoTipo = (Integer) retorno[5];
						} else {
							idMedicaoTipo = MedicaoTipo.POCO;
						}

						// verifica se a leitura anterior Ã© diferente de
						// nula
						// para
						// ser
						// jogado no arquivo
						// txt
						if (leituraAnterior != null) {
							movimentoRoteiroEmpresaPoco.setNumeroLeituraAnterior(new Integer(leituraAnterior));
							// caso contrario coloca a string com zeros
						} else {
							movimentoRoteiroEmpresaPoco.setNumeroLeituraAnterior(new Integer(0));
						}

						// Faixa de leitura esperada
						faixaInicialFinal = pesquisarFaixaEsperadaOuFalsaCelular(imovelParaSerGerado, dadosHidrometro, leituraAnterior, medicaoHistorico,
								idMedicaoTipo, sistemaParametro, hidrometroSelecionado, numeroDigitosHidrometro);

						faixaInicialEsperada = 0;
						faixaFinalEsperada = 0;

						faixaInicialEsperada = Integer.parseInt(faixaInicialFinal[3].toString());

						faixaFinalEsperada = Integer.parseInt(faixaInicialFinal[4].toString());

						movimentoRoteiroEmpresaPoco.setNumeroFaixaLeituraEsperadaInicial(faixaInicialEsperada);
						movimentoRoteiroEmpresaPoco.setNumeroFaixaLeituraEsperadaFinal(faixaFinalEsperada);

						movimentoRoteiroEmpresaPoco.setUltimaAlteracao(new Date());

						colecaoMovimentoRoteiroEmpresa.add(movimentoRoteiroEmpresaPoco);
						// getControladorBatch().inserirObjetoParaBatch(
						// movimentoRoteiroEmpresaPoco);

						// LIMPA CAMPOS
						movimentoRoteiroEmpresaPoco = null;
						medicaoTipo = null;
						dadosHidrometroNumeroLeitura = null;
						capacidade = null;
						hidrometroMarca = null;

					}

					colecaoMovimentoRoteiroEmpresa.add(movimentoRoteiroEmpresa);
					// getControladorBatch().inserirObjetoParaBatch(
					// movimentoRoteiroEmpresa);

					// LIMPA CAMPOS
					imovelParaSerGerado = null;
					movimentoRoteiroEmpresa = null;
					leituraTipo = null;
					nomeClienteUsuario = null;
					enderecoImovel = null;
					numeroDigitosHidrometro = null;
					dadosHidrometro = null;
					capacidadeHidrometro = null;
					marcaHidrometro = null;
					categoria = null;
					anoMesAnterior = null;
					leituraAnterior = null;
					idMedicaoTipo = null;
					retorno = null;
					faixaInicialFinal = null;
					colecaoSubCategoria = null;
					numeroConsumoFaturadoMes = null;
					anoMesFaturamento = null;
					logradouro = null;
					categoria1 = null;
					gerenciaRegional = null;

				}

				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoMovimentoRoteiroEmpresa);

			} catch (ControladorException e) {
				// sessionContext.setRollbackOnly();
				e.printStackTrace();
			}

			colecaoMovimentoRoteiroEmpresa.clear();
			colecaoMovimentoRoteiroEmpresa = null;

		}

	}

	/**
	 * 
	 * Método que atualiza as leituras da telemetria
	 * 
	 * 
	 * @author Thiago Nascimento
	 * @date 20/08/2008
	 * 
	 * @param dados
	 * @throws ControladorException
	 */
	public void atualizarLeituraTelemetria(Vector<DadosMovimentacao> dados)
			throws ControladorException {
		Iterator<DadosMovimentacao> it = dados.iterator();
		FaturamentoGrupo faturamentoGrupo = null;
		Integer anoMesReferencia = null;

		if (dados.size() > 0) {
			try {
				DadosMovimentacao d = dados.get(0);

				faturamentoGrupo = repositorioMicromedicao
						.buscarAnoMesReferenciaCasoSistema(d
								.getMatriculaImovel());

				if (faturamentoGrupo != null) {
					anoMesReferencia = faturamentoGrupo.getAnoMesReferencia();
				}

				while (it.hasNext()) {
					DadosMovimentacao dado = it.next();

					/*
					 * CRC5256
					 * 
					 * Colocado por Raphael Rossiter em 18/10/2010 Analista:
					 * Eduardo Borges
					 * 
					 * OBJ: Não atualizar a data de realização da atividade
					 * efetuar leitura com uma data que não esteja dentro do
					 * cronograma do grupo.
					 */
					Date dataLeituraCronograma = this
							.obterDataRealizacaoDaAtividadeEfetuarLeitura(
									dado.getDataLeituraCampo(),
									faturamentoGrupo, anoMesReferencia);

					dado.setDataLeituraCronograma(dataLeituraCronograma);

					// Registrar
					this.repositorioMicromedicao
							.atualizarLeituraAnormailidadeCelular(dado,
									anoMesReferencia, null);

					// Consistir
					Collection<Integer> imoveis = new ArrayList<Integer>();
					imoveis.add(dado.getMatriculaImovel());

					this.consistirLeiturasCalcularConsumosImoveis(
							faturamentoGrupo, imoveis);

				}

			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

		} else {
			// Lista Vazia para Atualizar
			throw new ControladorException("atencao.lista_vazia");
		}
	}

	/**
	 * [UC0831] Gerar Tabelas para Atualização Cadastral via celular
	 * 
	 * @author Vinicius Medeiros
	 * @date 25/08/2008
	 * 
	 * @return Object[]
	 * @throws Controlador
	 *             Exception
	 */

	public Object[] obterDadosHidrometroAtualizacaoCadastral(Integer idImovel)
			throws ControladorException {

		try {

			return this.repositorioMicromedicao
					.obterDadosHidrometroAtualizacaoCadastral(idImovel);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Informar Subdivisões de Rota
	 * 
	 * @author: Victor Cisneiros
	 * @date: 30/09/2008
	 */
	public void informarSubdivisoesDeRota(Integer idRotaOriginal,
			InformarSubdivisoesDeRotaHelper subdivisaoRotaOriginal,
			Collection<InformarSubdivisoesDeRotaHelper> subdivisoes)
			throws ControladorException {
		try {
			FiltroRota filtroRota = new FiltroRota();
			filtroRota.adicionarParametro(new ParametroSimples(
					FiltroRota.ID_ROTA, idRotaOriginal));
			filtroRota.adicionarCaminhoParaCarregamentoEntidade("leituraTipo");
			Collection pesquisa = getControladorUtil().pesquisar(filtroRota,
					Rota.class.getName());
			if (pesquisa == null || pesquisa.isEmpty()) {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Rota");
			}

			Rota rota = (Rota) Util.retonarObjetoDeColecao(pesquisa);

			Leiturista leiturista = new Leiturista();
			leiturista.setId(subdivisaoRotaOriginal.getIdLeiturista());
			rota.setLeiturista(leiturista);
			rota.setUltimaAlteracao(new Date());

			getControladorUtil().atualizar(rota);

			FiltroRotaAcaoCriterio filtroRotaAcaoCriterio = new FiltroRotaAcaoCriterio();
			filtroRotaAcaoCriterio.adicionarParametro(new ParametroSimples(
					FiltroRotaAcaoCriterio.ROTA_ID, idRotaOriginal));
			Collection<RotaAcaoCriterio> rotaAcoesCriterio = (Collection<RotaAcaoCriterio>) getControladorUtil()
					.pesquisar(filtroRotaAcaoCriterio,
							RotaAcaoCriterio.class.getName());
			if (rotaAcoesCriterio == null || rotaAcoesCriterio.isEmpty()) {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Rota Ações Critério da Rota original");
			}

			for (InformarSubdivisoesDeRotaHelper subdivisao : subdivisoes) {
				Rota rotaSubdividida = new Rota();

				rotaSubdividida.setIndicadorAjusteConsumo(rota
						.getIndicadorAjusteConsumo());
				rotaSubdividida.setDataAjusteLeitura(rota
						.getDataAjusteLeitura());
				rotaSubdividida.setIndicadorFiscalizarCortado(rota
						.getIndicadorFiscalizarCortado());
				rotaSubdividida.setIndicadorFiscalizarSuprimido(rota
						.getIndicadorFiscalizarCortado());
				rotaSubdividida.setIndicadorFiscalizarSuprimido(rota
						.getIndicadorFiscalizarSuprimido());
				rotaSubdividida.setPercentualGeracaoFaixaFalsa(rota
						.getPercentualGeracaoFaixaFalsa());
				rotaSubdividida.setIndicadorGerarFiscalizacao(rota
						.getIndicadorGerarFiscalizacao());
				rotaSubdividida.setPercentualGeracaoFiscalizacao(rota
						.getPercentualGeracaoFiscalizacao());
				rotaSubdividida.setIndicadorUso(rota.getIndicadorUso());

				rotaSubdividida.setEmpresa(rota.getEmpresa());
				rotaSubdividida.setFaturamentoGrupo(rota.getFaturamentoGrupo());
				rotaSubdividida.setLeituraTipo(rota.getLeituraTipo());
				rotaSubdividida.setSetorComercial(rota.getSetorComercial());
				rotaSubdividida.setCobrancaGrupo(rota.getCobrancaGrupo());
				rotaSubdividida.setEmpresaCobranca(rota.getEmpresaCobranca());
				rotaSubdividida.setNumeroSequenciaLeitura(rota
						.getNumeroSequenciaLeitura());
				rotaSubdividida.setIndicadorTransmissaoOffline(rota
						.getIndicadorTransmissaoOffline());
				rotaSubdividida.setIndicadorSequencialLeitura(rota
						.getIndicadorSequencialLeitura());

				Leiturista leituristaSubdivisao = new Leiturista();
				leituristaSubdivisao.setId(subdivisao.getIdLeiturista());

				rotaSubdividida.setId(null);
				rotaSubdividida.setCodigo(subdivisao.getCodigoRota());
				rotaSubdividida.setLeiturista(leituristaSubdivisao);
				rotaSubdividida.setUltimaAlteracao(new Date());

				Integer idInserido = (Integer) getControladorUtil().inserir(
						rotaSubdividida);
				rotaSubdividida.setId(idInserido);

				getControladorLocalidade()
						.atualizarRotaDasQuadrasNoIntervaloNumero(idInserido,
								rota.getSetorComercial().getId(),
								subdivisao.getQuadraInicial(),
								subdivisao.getQuadraFinal());

				for (RotaAcaoCriterio rotaAcaoCriterio : rotaAcoesCriterio) {
					RotaAcaoCriterio novaRotaAcaoCriterio = new RotaAcaoCriterio();
					novaRotaAcaoCriterio.setRota(rotaSubdividida);
					novaRotaAcaoCriterio.setCobrancaAcao(rotaAcaoCriterio
							.getCobrancaAcao());
					novaRotaAcaoCriterio.setCobrancaCriterio(rotaAcaoCriterio
							.getCobrancaCriterio());
					novaRotaAcaoCriterio.setUltimaAlteracao(new Date());

					RotaAcaoCriterioPK pk = new RotaAcaoCriterioPK(
							rotaSubdividida.getId(), rotaAcaoCriterio
									.getCobrancaAcao().getId());
					novaRotaAcaoCriterio.setComp_id(pk);

					getControladorUtil().inserir(novaRotaAcaoCriterio);
				}
			}
		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(e.getMessage(), e);
		}
	}

	/**
	 * [UC0629] Retornar Arquivo Txt Leitura
	 * 
	 * 
	 * @author Rômulo Aurélio
	 * @date 06/10/2008
	 * 
	 */
	public Collection pesquisarArquivosTextoRoteiroEmpresaParaArquivoZip(
			String[] ids) throws ControladorException {

		Collection colecaoArquivoTextoRoteiroEmpresa = new ArrayList();

		try {
			colecaoArquivoTextoRoteiroEmpresa = repositorioMicromedicao
					.pesquisarArquivosTextoRoteiroEmpresaParaArquivoZip(ids);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return colecaoArquivoTextoRoteiroEmpresa;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura [FS0006]-Verificar imóveis processados
	 * na competência
	 * 
	 * @date 13/10/2008
	 * @author Rômulo Aurélio
	 * 
	 */

	public Collection verificarImoveisProcessadosEmMovimentoRoteiroEmpresa(
			Collection colecaoImoveisAGerar, Integer idFaturamentoGrupo,
			Integer anoMes) throws ControladorException {

		if (colecaoImoveisAGerar != null && !colecaoImoveisAGerar.isEmpty()) {

			try {
				Collection colecaoImoveisGeradosEmOutroGrupo = repositorioMicromedicao
						.pesquisarImoveisMovimentoRoteiroEmpresaParaExistenteGeradoParaOutroGrupo(
								colecaoImoveisAGerar, idFaturamentoGrupo,
								anoMes);

				Map<Integer, Imovel> imoveis = new HashMap<Integer, Imovel>();

				Iterator colecaoImoveisAGerarIterator = colecaoImoveisAGerar
						.iterator();

				while (colecaoImoveisAGerarIterator.hasNext()) {
					Imovel imovelAGerar = (Imovel) colecaoImoveisAGerarIterator
							.next();

					imoveis.put(imovelAGerar.getId(), imovelAGerar);
				}

				if (colecaoImoveisGeradosEmOutroGrupo != null
						&& !colecaoImoveisGeradosEmOutroGrupo.isEmpty()) {

					Iterator colecaoImoveisGeradosEmOutroGrupoIterator = colecaoImoveisGeradosEmOutroGrupo
							.iterator();

					while (colecaoImoveisGeradosEmOutroGrupoIterator.hasNext()) {

						Imovel imovel = (Imovel) colecaoImoveisGeradosEmOutroGrupoIterator
								.next();

						if (imoveis.containsKey(imovel.getId())) {
							colecaoImoveisAGerar.remove(imoveis.get(imovel
									.getId()));
						}

					}

				}

			} catch (ErroRepositorioException e) {
				e.printStackTrace();
			}
		}
		return colecaoImoveisAGerar;

	}

	/**
	 * [UC0???] Gerar Relatorio Rotas Online por Empresa
	 * 
	 * @author Victor Cisneiros
	 * @date 28/10/2008
	 */
	public Collection<RelatorioRotasOnlinePorEmpresaBean> pesquisarRelatorioRotasOnlinePorEmpresa(
			PesquisarRelatorioRotasOnlinePorEmpresaHelper helper)
			throws ControladorException {
		try {
			return this.repositorioMicromedicao
					.pesquisarRelatorioRotasOnlinePorEmpresa(helper);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(ex.getMessage(), ex);
		}
	}

	// /**
	// * Processar Requisições da Atualizacao Cadastral.
	// *
	// * @author Victor Cisneiros
	// * @date 10/11/2008
	// */
	// public byte[] baixarArquivoTextoAtualizacaoCadastral(long imei) throws
	// ControladorException {
	// try {
	// return
	// this.repositorioMicromedicao.baixarArquivoTextoAtualizacaoCadastral(imei);
	// } catch (ErroRepositorioException e) {
	// sessionContext.setRollbackOnly();
	// throw new ControladorException("erro.sistema", e);
	// }
	// }

	/**
	 * [UC0???] Gerar Relatorio Rotas Online por Empresa
	 * 
	 * @author Victor Cisneiros
	 * @date 28/10/2008
	 */
	public Integer pesquisarRelatorioRotasOnlinePorEmpresaCount(
			PesquisarRelatorioRotasOnlinePorEmpresaHelper helper)
			throws ControladorException {
		try {
			return this.repositorioMicromedicao
					.pesquisarRelatorioRotasOnlinePorEmpresaCount(helper);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(ex.getMessage(), ex);
		}
	}

	/**
	 * Verifica se o processo de dados diários da arrecadação está sendo
	 * executado
	 * 
	 * @author bruno
	 * @date 12/12/2008
	 * 
	 * @throws ControladorException
	 */
	public void verificarBatchDadosDiariosArracadacaoRodando()
			throws ControladorException {

		/**
		 * filtro para verificar se a funcionalidade de gerar dados diários de
		 * arrecadação esta executando
		 */
		FiltroFuncionalidadeIniciada filtroFuncionalidadeIniciada = new FiltroFuncionalidadeIniciada();

		filtroFuncionalidadeIniciada.adicionarParametro(new ParametroSimples(
				FiltroFuncionalidadeIniciada.FUNCIONALIDADE_ID,
				Funcionalidade.GERAR_DADOS_DIARIOS_ARRECADACAO));
		filtroFuncionalidadeIniciada.adicionarParametro(new ParametroSimples(
				FiltroFuncionalidadeIniciada.FUNCIONALIDADE_SITUACAO,
				FuncionalidadeSituacao.EM_PROCESSAMENTO));

		Collection colecaoFuncionalidadeEmProcessamento = getControladorUtil()
				.pesquisar(filtroFuncionalidadeIniciada,
						FuncionalidadeIniciada.class.getName());

		/*
		 * Caso a funcionalidade esteja em processamento envia uma mensagem ao
		 * usuário negando o acesso a consulta.
		 */
		if (colecaoFuncionalidadeEmProcessamento != null
				&& !colecaoFuncionalidadeEmProcessamento.isEmpty()) {
			throw new ControladorException("atencao.funcionalidade.processando");
		}
	}

	public Collection pesquisarDadosRelatorioAnaliseImovelCorporativoGrande(
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorComercialInicial, Integer idSetorComercialFinal,
			Integer referencia, Integer idImovelPerfil, Integer selecionar)
			throws ControladorException {

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosAnaliseImovelCorporativoGrande = null;

		try {
			colecaoDadosAnaliseImovelCorporativoGrande = repositorioMicromedicao
					.pesquisarDadosRelatorioAnaliseImovelCorporativoGrande(
							idGerenciaRegional, idUnidadeNegocio,
							idLocalidadeInicial, idLocalidadeFinal,
							idSetorComercialInicial, idSetorComercialFinal,
							referencia, idImovelPerfil, selecionar);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		if (colecaoDadosAnaliseImovelCorporativoGrande != null
				&& !colecaoDadosAnaliseImovelCorporativoGrande.isEmpty()) {

			Iterator colecaoDadosAnaliseImovelCorporativoGrandeIterator = colecaoDadosAnaliseImovelCorporativoGrande
					.iterator();

			while (colecaoDadosAnaliseImovelCorporativoGrandeIterator.hasNext()) {

				// Obtém os dados do débito cobrado
				Object[] dadosAnaliseImovelCorporativoGrande = (Object[]) colecaoDadosAnaliseImovelCorporativoGrandeIterator
						.next();

				GerarRelatorioAnaliseImovelCorporativoGrandeHelper helper = new GerarRelatorioAnaliseImovelCorporativoGrandeHelper();

				// Id da Gerência Regional
				if (dadosAnaliseImovelCorporativoGrande[0] != null) {
					helper.setIdGerenciaRegional((Integer) dadosAnaliseImovelCorporativoGrande[0]);
				}

				// Id da Unidade de Negócio
				if (dadosAnaliseImovelCorporativoGrande[1] != null) {
					helper.setIdUnidadeNegocio((Integer) dadosAnaliseImovelCorporativoGrande[1]);
				}

				// Id da Localidade
				if (dadosAnaliseImovelCorporativoGrande[2] != null) {
					helper.setIdLocalidade((Integer) dadosAnaliseImovelCorporativoGrande[2]);
				}

				// Código do Setor Comercial
				if (dadosAnaliseImovelCorporativoGrande[3] != null) {
					helper.setCodigoSetorComercial((Integer) dadosAnaliseImovelCorporativoGrande[3]);
				}

				// Id do Imóvel
				if (dadosAnaliseImovelCorporativoGrande[4] != null) {
					helper.setIdImovel((Integer) dadosAnaliseImovelCorporativoGrande[4]);
				}

				// Descrição Abreviada da Capacidade do Hidrômetro da
				// Ligação de Água
				if (dadosAnaliseImovelCorporativoGrande[5] != null) {
					helper.setCapacidadeHidrometro((String) dadosAnaliseImovelCorporativoGrande[5]);
				}

				// Consumo Médio
				if (dadosAnaliseImovelCorporativoGrande[6] != null) {
					helper.setConsumoMedio((Integer) dadosAnaliseImovelCorporativoGrande[6]);
				}

				// Consumo Faturado
				if (dadosAnaliseImovelCorporativoGrande[7] != null) {
					helper.setConsumoFaturado((Integer) dadosAnaliseImovelCorporativoGrande[7]);
				}

				// Tipo de Ligação
				if (dadosAnaliseImovelCorporativoGrande[8] != null) {
					helper.setIdTipoLigacao((Integer) dadosAnaliseImovelCorporativoGrande[8]);
				}

				retorno.add(helper);
			}
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0889] - Alterar datas das leituras
	 * 
	 * Pesquisamos todos os dados necessários para a alteração das datas
	 * 
	 * @author bruno
	 * @date 26/02/2009
	 * 
	 * @param idGrupoFaturamento
	 * @return
	 */
	public Collection<AlterarDatasLeiturasHelper> pesquisarDadosAlterarGruposFaturamento(
			Integer idGrupoFaturamento) throws ControladorException {

		Collection<AlterarDatasLeiturasHelper> colRetorno = new ArrayList();

		try {
			Collection<Object[]> colResultSet = this.repositorioMicromedicao
					.pesquisarDadosAlterarGruposFaturamento(idGrupoFaturamento);

			if (colResultSet != null && colResultSet.size() > 0) {
				Iterator iteResultSet = colResultSet.iterator();

				while (iteResultSet.hasNext()) {
					Object[] linha = (Object[]) iteResultSet.next();

					AlterarDatasLeiturasHelper helper = new AlterarDatasLeiturasHelper(
							(Date) linha[0], (Date) linha[1],
							(Integer) linha[2]);

					colRetorno.add(helper);
				}
			}

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return colRetorno;
	}

	/**
	 * 
	 * [UC0889] - Alterar datas das leituras
	 * 
	 * Alteramos todos as datas informadas
	 * 
	 * @author bruno
	 * @date 26/02/2009
	 * 
	 * @param idGrupoFaturamento
	 * @return
	 */
	public void alterarDatasLeituras(
			Collection<AlterarDatasLeiturasHelper> colHelper, Integer idGrupo)
			throws ControladorException {
		for (AlterarDatasLeiturasHelper helper : colHelper) {
			try {
				this.repositorioMicromedicao.alterarDatasLeituras(helper,
						idGrupo);
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}
		}
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @author Rômulo Aurélio Data: 28/04/2009
	 * @throws ControladorException
	 */
	public Integer pesquisarNumeroHidrometroSituacaoInstaladoPaginacaoCount(
			FiltrarHidrometroHelper helper) throws ControladorException {
		try {

			return repositorioMicromedicao
					.pesquisarNumeroHidrometroSituacaoInstaladoPaginacaoCount(helper);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @author Rômulo Aurélio Data: 28/04/2009
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroSituacaoInstaladoPaginacao(
			FiltrarHidrometroHelper helper, Integer numeroPagina)
			throws ControladorException {
		try {

			return repositorioMicromedicao
					.pesquisarNumeroHidrometroSituacaoInstaladoPaginacao(
							helper, numeroPagina);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @author Rômulo Aurélio Data: 28/04/2009
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroSituacaoInstaladoRelatorio(
			FiltrarHidrometroHelper helper) throws ControladorException {
		try {

			return repositorioMicromedicao
					.pesquisarNumeroHidrometroSituacaoInstaladoRelatorio(helper);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 15/11/2006
	 * 
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Collection pesquisarConsumoFaturadoQuantidadeMesesPorReferencia(
			Integer idImovel, Integer tipoMedicao, short qtdMeses)
			throws ControladorException {

		Collection colecaoConsumoFaturaMesEReferencia = null;

		try {
			colecaoConsumoFaturaMesEReferencia = repositorioMicromedicao
					.pesquisarConsumoFaturadoQuantidadeMeses(idImovel,
							tipoMedicao, qtdMeses);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoConsumoFaturaMesEReferencia;
	}

	/**
	 * Obter consumo mínimo da ligação de agua via conta
	 * 
	 * @author Bruno Barros
	 * @date 15/05/2009
	 * 
	 * @param idConta
	 * @return valorMinimoContaAgua
	 * @throws ErroRepositorioException
	 */
	public Integer obterConsumoMininoAgua(Integer idConta)
			throws ControladorException {
		FiltroContaCategoria filtro = new FiltroContaCategoria();
		filtro.adicionarParametro(new ParametroSimples(
				FiltroContaCategoria.CONTA_ID, idConta));
		Collection<ContaCategoria> colContaCategoria = getControladorUtil()
				.pesquisar(filtro, ContaCategoria.class.getName());

		Integer retorno = new Integer(0);

		for (ContaCategoria contaCategoria : colContaCategoria) {
			retorno += (contaCategoria.getConsumoMinimoAgua() == null ? 0
					: contaCategoria.getConsumoMinimoAgua());
		}

		return retorno;
	}

	/**
	 * Obter consumo mínimo da ligação de esgoto via conta
	 * 
	 * @author Bruno Barros
	 * @date 15/05/2009
	 * 
	 * @param idConta
	 * @return valorMinimoConsumoEsgoto
	 * @throws ErroRepositorioException
	 */
	public Integer obterConsumoMininoEsgoto(Integer idConta)
			throws ControladorException {
		FiltroContaCategoria filtro = new FiltroContaCategoria();
		filtro.adicionarParametro(new ParametroSimples(
				FiltroContaCategoria.CONTA_ID, idConta));
		Collection<ContaCategoria> colContaCategoria = getControladorUtil()
				.pesquisar(filtro, ContaCategoria.class.getName());

		Integer retorno = new Integer(0);

		for (ContaCategoria contaCategoria : colContaCategoria) {
			retorno += (contaCategoria.getConsumoMinimoEsgoto() == null ? 0
					: contaCategoria.getConsumoMinimoEsgoto());
		}

		return retorno;
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 01/07/2009
	 * 
	 * @param imovel
	 * @param anoMesReferencia
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMaiorDataLeituraImoveis(Integer idImovel,
			Integer anoMesReferencia) throws ControladorException {
		try {
			return repositorioMicromedicao.pesquisarMaiorDataLeituraImoveis(
					idImovel, anoMesReferencia);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * 
	 * Método que retorna os consumos de ligacao da agua ou esgoto (tipo
	 * passado) de um imovel em um determinado período do faturamento.
	 * 
	 * @author Rafael Corrêa
	 * @date 27/07/2009
	 * 
	 * @param idImovel
	 * @param anoMesInicial
	 * @param anoMesFinal
	 * @param idLigacaoTipo
	 *            podendo ser agua ou esgoto
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Object[]> obterConsumosAnterioresAnormalidadeDoImovel(
			Integer idImovel, Integer anoMesInicial, Integer anoMesFinal,
			Integer idLigacaoTipo) throws ControladorException {

		try {
			return repositorioMicromedicao
					.obterConsumosAnterioresAnormalidadeDoImovel(idImovel,
							anoMesInicial, anoMesFinal, idLigacaoTipo);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * 
	 * Métido retorna o consumo tipo - descricao abreviada
	 * 
	 * @author Tiago Moreno
	 * @date 25/02/2010
	 * 
	 * @param idImovel
	 * @param anoMes
	 * @param idLigacaoTipo
	 *            podendo ser agua ou esgoto
	 * @return String consumoTipo - descricaoAbreviada
	 * @throws ControladorException
	 */
	public String obterConsumoTipoImovel(Integer idImovel, Integer anoMes,
			Integer idLigacaoTipo) throws ControladorException {

		try {
			String consumoTipo = repositorioMicromedicao
					.obterConsumoTipoImovel(idImovel, anoMes, idLigacaoTipo);

			if (consumoTipo == null) {
				consumoTipo = "NM"; // Se for null passar como não medido.
			}

			return consumoTipo;
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Inserir e Atualizar Movimentações de Hidrometros
	 * 
	 * @author Arthur Carvalho
	 * @date 17/06/2009
	 * 
	 */
	public void inserirAtualizarMovimentacaoHidrometroIdsBatch(
			Collection colecaoHidrometro, String data, String hora,
			String idLocalArmazenagemDestino, String idMotivoMovimentacao,
			String parecer, Usuario usuario, int idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		try {
			HidrometroMovimentacao hidrometroMovimentacao = new HidrometroMovimentacao();

			SimpleDateFormat formatoData = new SimpleDateFormat("dd/MM/yyyy");
			SimpleDateFormat formatoHora = new SimpleDateFormat("HH:mm");

			Date dataMovimentacao = null;
			Date horaMovimentacao = null;
			try {
				dataMovimentacao = formatoData.parse(data);
				horaMovimentacao = formatoHora.parse(hora);
			} catch (ParseException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.data.hora.invalido",
						null);
			}

			// Seta a data de movimentação
			hidrometroMovimentacao.setData(dataMovimentacao);
			hidrometroMovimentacao.setHora(horaMovimentacao);
			// Seta o local de armazenagem destino
			FiltroHidrometroLocalArmazenagem filtroHidrometroLocalArmazenagem = new FiltroHidrometroLocalArmazenagem();
			filtroHidrometroLocalArmazenagem
					.adicionarParametro(new ParametroSimples(
							FiltroHidrometroLocalArmazenagem.ID,
							idLocalArmazenagemDestino));

			Collection colecaoHidrometroLocalArmazenagem = getControladorUtil()
					.pesquisar(filtroHidrometroLocalArmazenagem,
							HidrometroLocalArmazenagem.class.getName());

			HidrometroLocalArmazenagem hidrometroLocalArmazenagemDestino = (HidrometroLocalArmazenagem) Util
					.retonarObjetoDeColecao(colecaoHidrometroLocalArmazenagem);

			hidrometroMovimentacao
					.setHidrometroLocalArmazenagemDestino(hidrometroLocalArmazenagemDestino);

			// Seta o motivo da movimentacao
			HidrometroMotivoMovimentacao hidrometroMotivoMovimentacao = new HidrometroMotivoMovimentacao();

			hidrometroMotivoMovimentacao
					.setId(new Integer(idMotivoMovimentacao));
			hidrometroMovimentacao
					.setHidrometroMotivoMovimentacao(hidrometroMotivoMovimentacao);

			// Seta o parecer
			hidrometroMovimentacao.setParecer(parecer);
			// Seta a data e hora de última alteração
			hidrometroMovimentacao.setUltimaAlteracao(new Date());

			// Seta o funcionário
			hidrometroMovimentacao.setUsuario(usuario);

			Hidrometro dadosHidrometroParaMovimentacao = (Hidrometro) ((List) colecaoHidrometro)
					.get(0);

			// Seta o local de armazenagem origem
			hidrometroMovimentacao
					.setHidrometroLocalArmazenagemOrigem(dadosHidrometroParaMovimentacao
							.getHidrometroLocalArmazenagem());

			// Inseri a movimentção do hidrômetro
			Integer idHidrometroMovimentacao = (Integer) repositorioUtil
					.inserir(hidrometroMovimentacao);

			hidrometroMovimentacao.setId(idHidrometroMovimentacao);

			// Criação de objetos
			Hidrometro hidrometro = null;

			Iterator iteratorColecaoHidrometro = colecaoHidrometro.iterator();

			while (iteratorColecaoHidrometro.hasNext()) {

				// Obtém o hidrômetro da coleção
				hidrometro = (Hidrometro) iteratorColecaoHidrometro.next();

				idUnidadeIniciada = getControladorBatch()
						.iniciarUnidadeProcessamentoBatch(
								idFuncionalidadeIniciada,
								UnidadeProcessamento.HIDROMETRO,
								hidrometro.getId());

				// Verifica se está movimentando o hidrômetro para o mesmo local
				// de armazenagem
				if (hidrometro.getHidrometroLocalArmazenagem().getId()
						.intValue() == new Integer(idLocalArmazenagemDestino)
						.intValue()) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.nao.possivel.movimentar.hidrometro.mesmo.local.armazenagem",
							null);
				}

				// Procura hidrometro na base
				FiltroHidrometro filtroHidrometro = new FiltroHidrometro();

				filtroHidrometro.adicionarParametro((new ParametroSimples(
						FiltroHidrometro.ID, hidrometro.getId())));

				Hidrometro hidrometroNaBase = (Hidrometro) ((List) (getControladorUtil()
						.pesquisar(filtroHidrometro, Hidrometro.class.getName())))
						.get(0);

				// Verificar se categoria já foi atualizada por outro usuário
				// durante esta atualização
				if (hidrometroNaBase.getUltimaAlteracao().after(
						hidrometro.getUltimaAlteracao())) {
					sessionContext.setRollbackOnly();
					throw new ControladorException(
							"atencao.atualizacao.timestamp");
				}

				HidrometroMovimentado hidrometroMovimentado = new HidrometroMovimentado(
						new HidrometroMovimentadoPK(idHidrometroMovimentacao,
								hidrometro.getId()));

				hidrometroMovimentado
						.setHidrometroMovimentacao(hidrometroMovimentacao);

				repositorioUtil.inserir(hidrometroMovimentado);

				// Seta o hidrometro para o novo local de armazenagem
				hidrometro
						.setHidrometroLocalArmazenagem(hidrometroLocalArmazenagemDestino);

				HidrometroSituacao hidrometroSituacao = new HidrometroSituacao();

				if (hidrometroLocalArmazenagemDestino.getIndicadorOficina()
						.equals(HidrometroLocalArmazenagem.INDICADOR_OFICINA)) {
					hidrometroSituacao.setId(HidrometroSituacao.EM_MANUTENCAO);
				} else {
					hidrometroSituacao.setId(HidrometroSituacao.DISPONIVEL);
				}

				hidrometro.setHidrometroSituacao(hidrometroSituacao);
				hidrometro.setUltimaAlteracao(new Date());

				// Atualiza o hidrômetro
				repositorioUtil.atualizar(hidrometro);

				getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
						idUnidadeIniciada, false);
			}
		} catch (Exception e) {
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a
			// lançar e garantir que a unidade de processamento do batch será
			// atualizada com o erro ocorrido
			e.printStackTrace();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);
		}

	}

	/**
	 * [UC0038] Inserir Rota [UC0039]Manter Rota
	 * 
	 * @author Rafael Pinto
	 * @date 31/08/2009
	 * 
	 * @param idRota
	 * @param idFaturamentoGrupo
	 * @param codigoRota
	 * @param idLocalidade
	 * @param idSetorComercial
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	private void verificarComandoNaoRealizadoParaRota(Integer idRota,
			Integer idFaturamentoGrupo) throws ControladorException {

		Collection comandoRealizadoParaRota = null;
		try {
			comandoRealizadoParaRota = this.repositorioMicromedicao
					.pesquisarComandoNaoRealizadoParaRota(idRota,
							idFaturamentoGrupo);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", e);
		}

		if (comandoRealizadoParaRota != null
				&& !comandoRealizadoParaRota.isEmpty()) {

			Iterator itera = comandoRealizadoParaRota.iterator();
			String atividades = "";

			while (itera.hasNext()) {

				String descricao = (String) itera.next();

				if (atividades.equals("")) {
					atividades = descricao;
				} else {
					atividades = atividades + "," + descricao;
				}

			}

			String[] mensagem = new String[2];

			mensagem[0] = atividades;
			mensagem[1] = "" + idFaturamentoGrupo;

			throw new ControladorException(
					"atencao.rota_comando_nao_realizado", null, mensagem);
		}

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * 
	 * @author Raphael Rossiter
	 * @date 25/08/2009
	 * 
	 * @return Collection
	 * @exception ControladorException
	 */
	public Collection pesquisarImovelParaConsistirLeitura(Rota rota)
			throws ControladorException {

		Collection colecaoImoveis = null;

		/*
		 * Caso a rota não esteja com o indicador de rota alternativa ativo; a
		 * pesquisa dos imóveis será feita a partir de sua quadra.
		 */
		if (!rota.getIndicadorRotaAlternativa().equals(ConstantesSistema.SIM)) {

			try {

				colecaoImoveis = this.repositorioMicromedicao
						.pesquisarImovelConsistirLeituraPorRota(rota);
			} catch (ErroRepositorioException e) {
				e.printStackTrace();
			}
		}
		/*
		 * Caso contrário; a pesquisa dos imóveis será feita a partir da rota
		 * alternativa que estará associada ao mesmo.
		 */
		else {

			try {

				colecaoImoveis = this.repositorioMicromedicao
						.pesquisarImovelConsistirLeituraPorRotaAlternativa(rota);
			} catch (ErroRepositorioException e) {
				e.printStackTrace();
			}
		}

		return colecaoImoveis;
	}

	/**
	 * Método que retorna os imoveis condominiais e esteja com ligados ou
	 * cortados a agua e ou ligados com esgoto que possuam hidrometro no poço
	 * das rotas passadas
	 * 
	 * [UC0103] Efetuar Rateio de Consumo
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2009
	 * 
	 * @param rota
	 * @return Imoveis
	 */
	public Collection pesquisarImovelCondominioParaCalculoDoRateioPorRota(
			Rota rota) throws ControladorException {

		Collection colecaoImoveis = null;

		/*
		 * Caso a rota não esteja com o indicador de rota alternativa ativo; a
		 * pesquisa dos imóveis será feita a partir de sua quadra.
		 */
		if (!rota.getIndicadorRotaAlternativa().equals(ConstantesSistema.SIM)) {

			try {

				colecaoImoveis = repositorioMicromedicao
						.pesquisarImovelCondominioParaCalculoDoRateioPorRota(rota
								.getId());

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}
		/*
		 * Caso contrário; a pesquisa dos imóveis será feita a partir da rota
		 * alternativa que estará associada ao mesmo.
		 */
		else {

			try {

				colecaoImoveis = repositorioMicromedicao
						.pesquisarImovelCondominioParaCalculoDoRateioPorRotaAlternativa(rota
								.getId());

			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}

		return colecaoImoveis;
	}

	/**
	 * [UC0082] Registrar Leituras e Anormalidades
	 * 
	 * @author Raphael Rossiter
	 * @date 03/09/2009
	 * 
	 * @param idFaturamentoGrupo
	 * @param fileItem
	 * @return Collection<MedicaoHistorico>
	 * @throws ControladorException
	 */
	public Collection<MedicaoHistorico> processarArquivoTextoParaRegistrarLeiturasAnormalidades(
			Integer idFaturamentoGrupo, FileItem fileItem)
			throws ControladorException {

		Collection<MedicaoHistorico> colecaoMedicaoHistorico = new ArrayList();

		// ABRINDO O ARQUIVO
		InputStreamReader reader;
		try {
			reader = new InputStreamReader(fileItem.getInputStream());
		} catch (IOException e) {
			e.printStackTrace();
			throw new ControladorException("erro.importacao.nao_concluida");
		}

		// PREPARANDO OBJETO PARA LER O ARQUIVO
		BufferedReader buffer = new BufferedReader(reader);

		// VARIÁVEIS PARA LER O ARQUIVO LINHA A LINHA
		boolean eof = false;
		boolean primeiraLinha = true;

		// CARREGANDO OS DADOS DO GRUPO DE FATURAMENTO ONDE SERÃO REGISTRADAS AS
		// LEITURAS
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();

		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
				FiltroFaturamentoGrupo.ID, idFaturamentoGrupo));

		Collection colecaoFaturamentoGrupo = this.getControladorUtil()
				.pesquisar(filtroFaturamentoGrupo,
						FaturamentoGrupo.class.getName());

		FaturamentoGrupo faturamentoGrupo = null;

		if (colecaoFaturamentoGrupo != null
				&& !colecaoFaturamentoGrupo.isEmpty()) {

			faturamentoGrupo = (FaturamentoGrupo) Util
					.retonarObjetoDeColecao(colecaoFaturamentoGrupo);
		} else {

			throw new ControladorException("atencao.entidade.inexistente",
					null, "Faturamento Grupo");
		}

		while (!eof) {

			// PEGANDO A LINHA DO ARQUIVO
			String linhaLida;
			try {
				linhaLida = buffer.readLine();
			} catch (IOException e) {
				e.printStackTrace();
				throw new ControladorException("erro.importacao.nao_concluida");
			}

			if (linhaLida == null) {

				// ÚLTIMA LINHA DO ARQUIVO
				eof = true;
			} else {

				// VARIÁVEIS QUE SERÃO UTILIZADAS PARA GERAÇÃO DA MEDIÇÃO
				// HISTÓRICO
				MedicaoHistorico medicaoHistorico = new MedicaoHistorico();

				MedicaoTipo medicaoTipo = new MedicaoTipo();
				Funcionario funcionario = new Funcionario();
				LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
				Imovel imovel = new Imovel();
				Localidade localidade = new Localidade();
				SetorComercial setorComercial = new SetorComercial();
				Quadra quadra = new Quadra();

				String anoMesLeitura = null;

				// INICIANDO O PROCESSO DE LEITURA DO ARQUIVO
				if (primeiraLinha) {

					// ANO E MÊS DA LEITURA
					anoMesLeitura = linhaLida.substring(4, 10);

					// VALIDANDO O ANO E MÊS DA LEITURA
					boolean anoMesInvalido = Util
							.validarAnoMesSemBarra(anoMesLeitura);

					if (anoMesInvalido) {

						throw new ControladorException(
								"atencao.anomes.faturamento.invalido");
					}

					if (faturamentoGrupo.getAnoMesReferencia() != Integer
							.parseInt(anoMesLeitura)) {

						throw new ControladorException(
								"atencao.anomes.faturamento.nao.corresponde");
					}

					// IDENTIFICADOR DE TRANSMISSÃO OU RECEPÇÃO
					String identificador = linhaLida.substring(1, 2);

					if (!identificador.equals("R")) {

						throw new ControladorException(
								"atencao.indicador.invalido");

					}

					// ID DO GRUPO DE FATURAMENTO INFORMADO NO ARQUIVO
					String idFaturamentoHeaderString = linhaLida
							.substring(2, 4).trim();
					Integer idFaturamentoHeader = null;

					if (!idFaturamentoHeaderString.equals("")) {

						idFaturamentoHeader = new Integer(linhaLida.substring(
								2, 4));
					}

					if (idFaturamentoHeader != null
							&& !idFaturamentoGrupo.equals(idFaturamentoHeader)) {

						throw new ControladorException(
								"atencao.nao.grupo.faturamento");
					}

					primeiraLinha = false;

				} else {

					if (linhaLida.trim().length() != 24) {

						if (primeiraLinha) {

							new ControladorException(
									"atencao.arquivo.sem.header");
						}

						if (linhaLida.trim().length() >= 50) {

							// ID DO FUNCIONARIO
							String idFuncionario = linhaLida.substring(2, 8)
									.trim();

							if (!idFuncionario.equals("")) {

								funcionario.setId(new Integer(idFuncionario));
							} else {

								funcionario.setId(null);
							}

							medicaoHistorico.setFuncionario(funcionario);

							// DATA DE LEITURA
							medicaoHistorico
									.setDataLeituraParaRegistrar(linhaLida
											.substring(8, 16).trim());

							// IMÓVEL
							String idImovel = linhaLida.substring(16, 24)
									.trim();

							if (!idImovel.equals("")) {

								imovel.setId(new Integer(idImovel));
							} else {

								imovel.setId(null);
							}

							// LOCALIDADE
							String idLocalidade = linhaLida.substring(24, 27)
									.trim();

							if (!idLocalidade.equals("")) {

								localidade.setId(new Integer(linhaLida
										.substring(24, 27)));
							} else {

								localidade.setId(null);
							}

							imovel.setLocalidade(localidade);

							// CÓDIGO DO SETOR COMERCIAL
							String codigoSetorComercial = linhaLida.substring(
									27, 30).trim();

							if (!codigoSetorComercial.equals("")) {

								setorComercial.setCodigo(new Integer(linhaLida
										.substring(27, 30)));
							} else {

								setorComercial.setCodigo(0);
							}

							imovel.setSetorComercial(setorComercial);

							// NÚMERO DA QUADRA
							String numeroQuadra = linhaLida.substring(30, 33)
									.trim();

							if (!numeroQuadra.equals("")) {

								quadra.setNumeroQuadra(new Integer(linhaLida
										.substring(30, 33)));
							} else {

								quadra.setNumeroQuadra(0);
							}

							imovel.setQuadra(quadra);

							// LOTE
							String lote = linhaLida.substring(33, 37).trim();

							if (!lote.equals("")) {

								imovel.setLote(new Short(lote));
							} else {

								imovel.setLote(new Short("0"));
							}

							// SUBLOTE
							String subLote = linhaLida.substring(37, 40).trim();

							if (!subLote.equals("")) {

								imovel.setSubLote(new Short(subLote));
							} else {

								imovel.setSubLote(new Short("0"));
							}

							medicaoHistorico.setImovel(imovel);

							// TIPO DE MEDIÇÃO
							String idMedicaoTipo = linhaLida.substring(40, 41)
									.trim();

							if (!idMedicaoTipo.equals("")) {

								medicaoTipo.setId(new Integer(idMedicaoTipo));
							} else {

								medicaoTipo.setId(null);
							}

							medicaoHistorico.setMedicaoTipo(medicaoTipo);

							// LEITURA DO HIDRÔMETRO
							String leituraHidrometro = null;

							leituraHidrometro = linhaLida.substring(41, 47)
									.trim();

							if (!leituraHidrometro.equals("")) {

								medicaoHistorico
										.setLeituraAtualInformada(new Integer(
												leituraHidrometro));

								try {

									medicaoHistorico
											.setLeituraAtualInformada(new Integer(
													leituraHidrometro));
								} catch (NumberFormatException ex) {

									medicaoHistorico
											.setLeituraAtualInformada(0);
								}
							} else {

								medicaoHistorico.setLeituraAtualInformada(null);
							}

							// ANORMALIDADE
							String idLeituraAnormalidade = linhaLida.substring(
									47, 49).trim();

							if (!idLeituraAnormalidade.equals("")) {

								try {

									leituraAnormalidade.setId(new Integer(
											idLeituraAnormalidade));
								} catch (NumberFormatException ex) {

									leituraAnormalidade.setId(0);
								}
							} else {

								leituraAnormalidade.setId(null);
							}

							medicaoHistorico
									.setLeituraAnormalidadeInformada(leituraAnormalidade);

							// INDICADOR DE CONFIRMAÇÃO DA LEITURA
							medicaoHistorico
									.setIndicadorConfirmacaoLeitura(linhaLida
											.substring(49, 50).trim());

							// INSERINDO A MEDIÇÃO HISTORICO QUE FOI GERADA A
							// PARTIR DO ARQUIVO TXT
							colecaoMedicaoHistorico.add(medicaoHistorico);
						}
					} else {

						// ÚLTIMA LINHA DO ARQUIVO
						eof = true;
					}
				}
			}
		}

		// FECHANDO O ARQUIVO
		try {

			buffer.close();
			reader.close();
			fileItem.getInputStream().close();
		} catch (IOException e) {
			e.printStackTrace();
			throw new ControladorException("erro.importacao.nao_concluida");
		}

		return colecaoMedicaoHistorico;
	}

	/**
	 * [UC0811] Requisições do Dispositivo Móvel da Conta Pré-faturada.
	 * 
	 * SB0001 ? Baixar Arquivo Texto para o Leiturista
	 * 
	 * @author Bruno Barros
	 * @date 24/09/2009
	 * 
	 * @param imei
	 * @return
	 * @throws ControladorException
	 */

	public Object[] baixarArquivoTextoParaLeituristaImpressaoSimulanea(
			long imei, Integer idServicoTipoCelular)
			throws ControladorException {
		Object[] retorno = null;
		try {
			// verifica se existe uma rota dividida para o imei do leiturista
			retorno = this.repositorioMicromedicao
					.baixarArquivoTextoDivididoParaLeituristaImpressaoSimultanea(imei);

			byte[] arq = (byte[]) retorno[0];
			// caso não exista rota dividida para o leiturista, então pesquisa a
			// rota sem ser dividida
			if (arq == null) {
				retorno = this.repositorioMicromedicao
						.baixarArquivoTextoParaLeituristaImpressaoSimultanea(
								imei, idServicoTipoCelular);

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC0957]Gerar Relatório de Acompanhamento de Leiturista
	 * 
	 * Pesquisa as rotas que possuem validos para geração do relatorio de
	 * acompanhamento de leiturista.
	 * 
	 * @author Hugo Amorim
	 * @data 16/10/2009
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection selecionarRotasRelatorioAcompanhamentoLeiturista(
			Integer anoMesReferencia, Integer rotas[], String idEmpresa,
			String idLeiturista) throws ControladorException {
		try {

			return this.repositorioMicromedicao
					.selecionarRotasRelatorioAcompanhamentoLeiturista(
							anoMesReferencia, rotas, idEmpresa, idLeiturista);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0957]Gerar Relatório de Acompanhamento de Leiturista
	 * 
	 * @author Hugo Amorim
	 * @data 21/10/2009
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarLeituristasDasRotas(
			RelatorioAcompanhamentoLeituristaHelper helper)
			throws ControladorException {
		try {

			return repositorioMicromedicao.pesquisarLeituristasDasRotas(helper);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0957]Gerar Relatório de Acompanhamento de Leiturista
	 * 
	 * @author Hugo Amorim
	 * @data 19/10/2009
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	@SuppressWarnings("unused")
	public Collection<RelatorioAcompanhamentoLeituristaHelper> pesquisarRelatorioAcompanhamentoLeiturista(
			RelatorioAcompanhamentoLeituristaHelper helper)
			throws ControladorException {
		Collection<RelatorioAcompanhamentoLeituristaHelper> retorno = new ArrayList();
		SimpleDateFormat ds = new SimpleDateFormat("HH:mm:ss");
		SimpleDateFormat dsDiaHoraMinSeg = new SimpleDateFormat(
				"dd/MM/yyyy HH:mm:ss");
		try {

			Collection rotasLeituristas = repositorioMicromedicao
					.pesquisarLeituristasDasRotas(helper);

			Iterator rotasLeituristasIterator = rotasLeituristas.iterator();

			while (rotasLeituristasIterator.hasNext()) {

				RelatorioAcompanhamentoLeituristaHelper helperRelatorio = new RelatorioAcompanhamentoLeituristaHelper();

				Object[] rotaLeiturista = (Object[]) rotasLeituristasIterator
						.next();

				Integer rota = (Integer) rotaLeiturista[0];
				Integer leiturista = (Integer) rotaLeiturista[1];
				Integer idGrupo = (Integer) rotaLeiturista[2];

				if (helper.getIdGrupoFaturamento() == null
						|| helper.getIdGrupoFaturamento().equals("-1")) {
					helper.setIdGrupoFaturamento(idGrupo.toString());
				}

				helper.setIdRotaFluxo(rota);
				helper.setIdLeiturista(leiturista.toString());

				// Dados do Resumo da Leitura
				Collection dadosResumoleituraAgua = repositorioMicromedicao
						.pesquisarDadosResumoLeituraAgua(helper);
				Collection dadosResumoleituraPoco = repositorioMicromedicao
						.pesquisarDadosResumoLeituraPoco(helper);
				// Agua
				Iterator dadosAgua = dadosResumoleituraAgua.iterator();
				BigDecimal totalLeiturasAguaExecutadas = new BigDecimal(
						dadosAgua.next().toString());
				BigDecimal totalLeiturasAgua = new BigDecimal(dadosAgua.next()
						.toString());
				BigDecimal percentualAgua = Util.calcularPercentualBigDecimal(
						totalLeiturasAguaExecutadas, totalLeiturasAgua);
				// Esgoto
				Iterator dadosPoco = dadosResumoleituraPoco.iterator();
				BigDecimal totalLeiturasPocoExecutadas = new BigDecimal(
						dadosPoco.next().toString());
				BigDecimal totalLeiturasPoco = new BigDecimal(dadosPoco.next()
						.toString());
				BigDecimal percentualPoco = Util.calcularPercentualBigDecimal(
						totalLeiturasPocoExecutadas, totalLeiturasPoco);

				// Dados do Resumo do Faturamento
				FiltroFaturamentoGrupo filtro = new FiltroFaturamentoGrupo();

				filtro.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupo.ID, new Integer(helper
								.getIdGrupoFaturamento())));

				Collection faturamentoGrupos = getControladorUtil().pesquisar(
						filtro, FaturamentoGrupo.class.getName());

				FaturamentoGrupo fatGrupo = (FaturamentoGrupo) Util
						.retonarObjetoDeColecao(faturamentoGrupos);

				Collection dadosFaturadosPelaMedia;
				Collection dadosFaturadosPeloMinimo;
				Collection dadosConsumoTotalMedido;
				Collection dadosConsumoTotalFaturado;
				if (fatGrupo.getAnoMesReferencia()
						.compareTo(helper.getMesAno()) < 0) {
					helperRelatorio
							.setFaturadoMediaAbsoluto(new BigDecimal("0"));
					helperRelatorio.setFaturadoMediaPercentual(new BigDecimal(
							"0"));
					helperRelatorio.setFaturadoMinimoAbsoluto(new BigDecimal(
							"0"));
					helperRelatorio.setFaturadoMinimoPercentual(new BigDecimal(
							"0"));
					helperRelatorio.setConsumoTotalMedido(new BigDecimal("0"));
					helperRelatorio
							.setConsumoTotalFaturado(new BigDecimal("0"));
					helperRelatorio.setConsumoMedioMedido(new BigDecimal("0"));
					helperRelatorio
							.setConsumoMedioFaturado(new BigDecimal("0"));
				} else {
					// Faturado pela Média
					dadosFaturadosPelaMedia = repositorioMicromedicao
							.pesquisarDadosFaturadosPelaMedia(helper);
					BigDecimal valorFaturadoMedia = (BigDecimal) dadosFaturadosPelaMedia
							.iterator().next();
					helperRelatorio
							.setFaturadoMediaAbsoluto(valorFaturadoMedia);
					BigDecimal percentualFaturadoMedia = Util
							.calcularPercentualBigDecimal(valorFaturadoMedia,
									totalLeiturasAgua);
					helperRelatorio
							.setFaturadoMediaPercentual(percentualFaturadoMedia);

					// Faturado pelo Mínimo
					dadosFaturadosPeloMinimo = repositorioMicromedicao
							.pesquisarDadosFaturadosPeloMinimo(helper);
					BigDecimal valorFaturadoMinimo = (BigDecimal) dadosFaturadosPeloMinimo
							.iterator().next();
					helperRelatorio
							.setFaturadoMinimoAbsoluto(valorFaturadoMinimo);
					BigDecimal percentualFaturadoMinimo = Util
							.calcularPercentualBigDecimal(valorFaturadoMinimo,
									totalLeiturasAgua);
					helperRelatorio
							.setFaturadoMinimoPercentual(percentualFaturadoMinimo);

					// Consumo Total Medido
					dadosConsumoTotalMedido = repositorioMicromedicao
							.pesquisarDadosConsumoTotalMedido(helper);
					BigDecimal consumoTotalMedido = (BigDecimal) dadosConsumoTotalMedido
							.iterator().next();
					if (consumoTotalMedido == null) {
						consumoTotalMedido = new BigDecimal("0");
					}
					helperRelatorio.setConsumoTotalMedido(consumoTotalMedido);

					// Consumo Total Faturado
					dadosConsumoTotalFaturado = repositorioMicromedicao
							.pesquisarDadosConsumoTotalFaturado(helper);
					BigDecimal consumoTotalFaturado = (BigDecimal) dadosConsumoTotalFaturado
							.iterator().next();

					if (consumoTotalFaturado == null) {
						consumoTotalFaturado = new BigDecimal("0");
					}

					helperRelatorio
							.setConsumoTotalFaturado(consumoTotalFaturado);
					BigDecimal percentualConsumoTotalFaturado = Util
							.calcularPercentualBigDecimal(consumoTotalFaturado,
									consumoTotalMedido);
					helperRelatorio
							.setConsumoTotalFaturadoPercentual(percentualConsumoTotalFaturado);

					// Consumo Medio Medido
					if (totalLeiturasAguaExecutadas.compareTo(new BigDecimal(
							"0")) != 0) {
						BigDecimal consumoMedioMedido = consumoTotalMedido
								.divide(totalLeiturasAguaExecutadas,
										RoundingMode.HALF_UP);
						helperRelatorio
								.setConsumoMedioMedido(consumoMedioMedido);
					} else {
						helperRelatorio.setConsumoMedioMedido(new BigDecimal(
								"0"));
					}

					// Consumo Medio Faturado
					if (totalLeiturasAguaExecutadas.compareTo(new BigDecimal(
							"0")) != 0) {
						BigDecimal consumoMedioFaturado = consumoTotalFaturado
								.divide(totalLeiturasAguaExecutadas,
										RoundingMode.HALF_UP);
						helperRelatorio
								.setConsumoMedioFaturado(consumoMedioFaturado);
					} else {
						helperRelatorio.setConsumoMedioFaturado(new BigDecimal(
								"0"));
					}

				}

				// Dados Gerais
				Collection dadosCabecalho = this.repositorioMicromedicao
						.pesquisarRelatorioAcompanhamentoLeiturista(helper,
								rota, leiturista);

				Iterator iteraDados = dadosCabecalho.iterator();

				Object[] dados = null;
				String horarioPrimeiraLeitura = "";
				String horarioUltimaLeitura = "";
				String horarioControle = "";
				String horarioPresumidoIntervalo = "";
				String horaLeituraFormatadaAnterior = "";
				String horaString = null;
				Date horaAnterior = null;
				Date horaAtual;
				int count = 0;
				int contadorTotal = 0;
				long intervaloTotal = 0;
				List<RelatorioAcompanhamentoLeituristaAnormalidadesHelper> anormalidadesCollection = new ArrayList();
				Collection<RelatorioAcompanhamentoLeituristaHorariosHelper> horariosCollection = new ArrayList();
				// Dados Anormalidades
				// Dados dos Horários Individuais
				boolean primeiraVez = true;
				while (iteraDados.hasNext()) {
					contadorTotal++;
					dados = (Object[]) iteraDados.next();

					if (dados[8] != null
							&& !dados[8].equals("")
							&& !dados[8].toString().equalsIgnoreCase(
									"sem anormalidade")) {
						RelatorioAcompanhamentoLeituristaAnormalidadesHelper anormalidade = new RelatorioAcompanhamentoLeituristaAnormalidadesHelper();
						anormalidade.setAnormalidade((String) dados[8]);

						if (!anormalidadesCollection.contains(anormalidade)) {
							anormalidade.setQuantidade(new Integer(1));
							anormalidadesCollection.add(anormalidade);
						} else {

							RelatorioAcompanhamentoLeituristaAnormalidadesHelper anormalidadeFluxo = anormalidadesCollection
									.get(anormalidadesCollection
											.indexOf(anormalidade));
							anormalidadeFluxo.setQuantidade(anormalidadeFluxo
									.getQuantidade() + 1);

						}
					}
					if (dados[9] != null && !dados[9].equals("")) {

						Timestamp horarioLeitura = (Timestamp) dados[9];

						horaString = Util
								.getHoraMinutoSegundoTimestamp(horarioLeitura);

						String horaLeituraFormatada = dsDiaHoraMinSeg
								.format(horarioLeitura);

						if (primeiraVez) {
							horarioPrimeiraLeitura = horaLeituraFormatada;
							horaLeituraFormatadaAnterior = horaLeituraFormatada;
							horaAnterior = ds.parse(horaString);
							primeiraVez = false;
						} else {
							horaAtual = ds.parse(horaString);
							long intervalo = horaAtual.getTime()
									- horaAnterior.getTime(); // em milisegundos
							horaAnterior = horaAtual;
							if (intervalo > 1800000) {
								horarioPresumidoIntervalo = horaLeituraFormatadaAnterior
										+ " às " + horaLeituraFormatada;
								continue;

							}
							if (intervalo > 0) {
								intervaloTotal = intervaloTotal + intervalo;
							}
						}
						count++;
						if (!iteraDados.hasNext()) {
							horarioUltimaLeitura = horaLeituraFormatada;
							count = 4;
						}
						horaLeituraFormatadaAnterior = horaLeituraFormatada;
						horarioControle = horarioControle + " "
								+ horaLeituraFormatada + "     ";

						if (count == 4) {
							RelatorioAcompanhamentoLeituristaHorariosHelper horario = new RelatorioAcompanhamentoLeituristaHorariosHelper();
							horario.setHorario(horarioControle);
							horariosCollection.add(horario);
							horarioControle = "";
							count = 0;
						}
					}
				}

				// Calculo do Tempo Medio de Leitura da Rota
				long intervaloMedio = intervaloTotal / contadorTotal;

				if (dados != null) {
					helperRelatorio.setMesAno((Integer) dados[0]);
					helperRelatorio.setIdLocalidade(((Integer) dados[1])
							.toString());
					helperRelatorio.setNomeLocalidade((String) dados[2]);
					helperRelatorio.setIdGrupoFaturamento(((Integer) dados[3])
							.toString());
					helperRelatorio
							.setCodigoRota(((Short) dados[4]).toString());
					helperRelatorio.setTipoLeitura((String) dados[5]);
					helperRelatorio.setNomeLeiturista((String) dados[6]);
					helperRelatorio.setTotalLeiturasAgua(totalLeiturasAgua);
					helperRelatorio
							.setTotalLeiturasAguaExecutadaAbsoluto(totalLeiturasAguaExecutadas);
					helperRelatorio
							.setTotalLeiturasAguaExecutadaPercentual(percentualAgua);
					helperRelatorio.setTotalLeiturasPoco(totalLeiturasPoco);
					helperRelatorio
							.setTotalLeiturasPocoExecutadaAbsoluto(totalLeiturasPocoExecutadas);
					helperRelatorio
							.setTotalLeiturasPocoExecutadaPercentual(percentualPoco);
					helperRelatorio
							.setCollectionAnormalidades(anormalidadesCollection);
					helperRelatorio
							.setDataHoraPrimeiraLeitura(horarioPrimeiraLeitura);
					helperRelatorio
							.setDataHoraUltimaLeitura(horarioUltimaLeitura);
					String tempoMedioLeitura = "";
					if (intervaloMedio > 0) {
						tempoMedioLeitura = Util
								.milisegundosParaHoraMinuto(intervaloMedio);

						if (intervaloMedio < 60000) {
							tempoMedioLeitura = "00h 01min";
						}
					}
					helperRelatorio.setTempoMedioLeitura(tempoMedioLeitura);
					helperRelatorio.setIdRota(rota);
					helperRelatorio
							.setHorarioPresumidoIntervalo(horarioPresumidoIntervalo);

					if (helper.getIndicadorHorario() != null
							&& helper.getIndicadorHorario().equalsIgnoreCase(
									"S")) {
						helperRelatorio
								.setHorariosIndividuais(horariosCollection);
					}

					if (horariosCollection == null
							|| horariosCollection.isEmpty()) {
						helperRelatorio.setImprimirCabecalhoHorario("N");
					} else {
						helperRelatorio.setImprimirCabecalhoHorario("S");
					}
					if (anormalidadesCollection == null
							|| anormalidadesCollection.isEmpty()) {
						helperRelatorio.setImprimirCabecalhoAnormalidades("N");
					} else {
						helperRelatorio.setImprimirCabecalhoAnormalidades("S");
					}

				}
				retorno.add(helperRelatorio);
			}
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		} catch (ParseException e) {
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * [UC0965] - Relatorio de Anormalidade de Leitura por Periodo
	 * 
	 * @since 03/11/2009
	 * @author Marlon Patrick
	 */
	public Collection<RelatorioAnormalidadeLeituraPeriodoBean> pesquisarRelatorioAnormalidadeLeituraPeriodo(
			FiltrarRelatorioAnormalidadeLeituraPeriodoHelper filtro)
			throws ControladorException {
		Collection<RelatorioAnormalidadeLeituraPeriodoBean> colecaoBeans = null;

		try {
			Collection<Object[]> dadosRelatorio = this.repositorioMicromedicao
					.pesquisarRelatorioAnormalidadeLeituraPeriodo(filtro);

			if (!Util.isVazioOrNulo(dadosRelatorio)) {
				colecaoBeans = new ArrayList<RelatorioAnormalidadeLeituraPeriodoBean>();

				for (Object[] dadosAtuais : dadosRelatorio) {
					RelatorioAnormalidadeLeituraPeriodoBean relatorioBean = new RelatorioAnormalidadeLeituraPeriodoBean();

					Imovel imovel = new Imovel();
					imovel.setLocalidade(new Localidade(
							(Integer) dadosAtuais[2]));
					imovel.setSetorComercial(new SetorComercial());
					imovel.getSetorComercial().setCodigo(
							(Integer) dadosAtuais[4]);
					imovel.setQuadra(new Quadra());
					imovel.getQuadra()
							.setNumeroQuadra((Integer) dadosAtuais[5]);
					imovel.setLote((Short) dadosAtuais[6]);
					imovel.setSubLote((Short) dadosAtuais[7]);
					imovel.setId((Integer) dadosAtuais[8]);

					relatorioBean.setUnidadeNegocio((Integer) dadosAtuais[0]
							+ " - " + (String) dadosAtuais[1]);
					relatorioBean.setLocalidade((Integer) dadosAtuais[2]
							+ " - " + (String) dadosAtuais[3]);

					relatorioBean.setInscricao(imovel.getInscricaoFormatada());
					relatorioBean.setMatricula(imovel.getMatriculaFormatada());

					relatorioBean.setCliente((String) dadosAtuais[9]);

					relatorioBean.setEndereco(this.getControladorEndereco()
							.obterEnderecoAbreviadoImovel(imovel.getId()));

					relatorioBean
							.setGrupoFaturamento((Integer) dadosAtuais[10]);

					Integer rota = (Integer) dadosAtuais[11];
					Integer sequencialRota = (Integer) dadosAtuais[12];

					if (sequencialRota != null) {

						relatorioBean.setRota(Util.adicionarZerosEsquedaNumero(
								3, rota.toString())
								+ "."
								+ Util.adicionarZerosEsquedaNumero(3,
										sequencialRota.toString()));
					} else if (rota != null) {
						relatorioBean.setRota(Util.adicionarZerosEsquedaNumero(
								3, rota.toString()));
					}

					colecaoBeans.add(relatorioBean);
				}
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return colecaoBeans;
	}

	/**
	 * [UC0965] - Relatorio de Anormalidade de Leitura por Periodo
	 * 
	 * @since 03/11/2009
	 * @author Marlon Patrick
	 */
	public Collection<Object[]> pesquisarTotalRegistrosRelatorioAnormalidadeLeituraPeriodo(
			FiltrarRelatorioAnormalidadeLeituraPeriodoHelper filtro)
			throws ControladorException {
		try {
			return this.repositorioMicromedicao
					.pesquisarTotalRegistrosRelatorioAnormalidadeLeituraPeriodo(filtro);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0745] - Gerar Arquivo Texto Faturamento
	 * 
	 * @since 25/11/2009
	 * @author Sávio Luiz
	 */
	public Collection pesquisarFaturamentoSituacaoTipo(
			FaturamentoSituacaoTipo faturamentoSituacaoTipo)
			throws ControladorException {
		try {
			// Pesquisa a anormalidade de leitura de faturamento
			return repositorioMicromedicao
					.pesquisarFaturamentoSituacaoTipo(faturamentoSituacaoTipo);

		} catch (ErroRepositorioException ex) {
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0613] - Registrar Leituras e Anormalidades
	 * 
	 * Retorna a quantidade de imóveis com faixa falsa
	 * 
	 * @author Arthur Carvalho - Hugo Leonardo - Magno Gouveia
	 * @date 16/11/2009 - 18/03/2010 - 21/06/2011
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Integer pesquisarDadosRelatorioComparativoLeiturasEAnormalidadesCount(
			Integer idGrupoFaturamento, Integer idEmpresa, Integer anoMes,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal,
			Integer idSetorInicial, Integer idSetorFinal, Integer idGerencia,
			Integer idUnidadeNegocio, Integer idLeiturista,
			Integer idRotaInicial, Integer idRotaFinal, Integer idPerfilImovel,
			Integer numOcorrenciasConsecutivas,
			Collection colecaoAnormalidadesLeituras)
			throws ControladorException {
		try {
			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			return repositorioMicromedicao
					.pesquisarDadosRelatorioComparativoLeiturasEAnormalidadesCount(
							idGrupoFaturamento, idEmpresa, anoMes,
							idLocalidadeInicial, idLocalidadeFinal,
							idSetorInicial, idSetorFinal, idGerencia,
							idUnidadeNegocio, idLeiturista, idRotaInicial,
							idRotaFinal, idPerfilImovel,
							numOcorrenciasConsecutivas,
							colecaoAnormalidadesLeituras, sistemaParametro);
		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * Verifica se houve todos os processamentos do um determinado grupo e
	 * ano-Mês de Referencia e inserir no cronograma de atividades.
	 * 
	 * [UC0840] - Atualizar Faturamento do Movimento Celular
	 * 
	 * @author Sávio Luiz
	 * @date 01/12/2009
	 * 
	 * @param grupo
	 * @param anoMesReferencia
	 * @throws ErroRepositorioException
	 */
	public void atualizarDataRealizacaoGronogramaPreFaturamento(Integer grupo,
			Integer anoMesReferencia, Date dataRealizacao)
			throws ControladorException {
		try {
			repositorioMicromedicao
					.atualizarDataRealizacaoGronogramaPreFaturamento(grupo,
							anoMesReferencia, dataRealizacao);
		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0101] Consistir Leituras e Calcular Consumos
	 * 
	 * 3.1 do [SB0014] - Verificar Estouro de Consumo 2.1 do [SB0015] -
	 * Verificar Alto Consumo 2.1 do [SB0016] - Verificar Baixo Consumo
	 * 
	 * @author Vivianne Sousa
	 * @date 17/12/2009
	 * 
	 * @param grupo
	 * @param anoMesReferencia
	 * @throws ErroRepositorioException
	 */
	public ConsumoAnormalidadeAcao verificaAcaoASerTomada(
			Integer idConsumoAnormalidade, Integer idCategoria,
			Integer idPerfilImovel) throws ControladorException {

		ConsumoAnormalidadeAcao retorno = null;

		try {

			// O sistema verifica a ação a ser tomada acessando a tabela
			// CONSUMO_ANORMALIDADE_ACAO,
			// passando o código da anormalidade
			// a categoria do imóvel que tenha o maior número de economias e o
			// perfil do imóvel
			retorno = repositorioMicromedicao.pesquisarConsumoAnormalidadeAcao(
					idConsumoAnormalidade, idCategoria, idPerfilImovel);

			// Caso não retornou nenhum registro dado da tabela
			// CONSUMO_ANORMALIDADE_ACAO,
			// então verifica a ação a ser tomada acessando a tabela
			// CONSUMO_ANORMALIDADE_ACAO,
			// passando o código da anormalidade
			// a categoria do imóvel que tenha o maior número de economias
			if (retorno == null) {
				retorno = repositorioMicromedicao
						.pesquisarConsumoAnormalidadeAcao(
								idConsumoAnormalidade, idCategoria, null);
			}

			// Caso não retornou nenhum registro dado da tabela
			// CONSUMO_ANORMALIDADE_ACAO,
			// então verifica a ação a ser tomada acessando a tabela
			// CONSUMO_ANORMALIDADE_ACAO,
			// passando o código da anormalidade
			if (retorno == null) {
				retorno = repositorioMicromedicao
						.pesquisarConsumoAnormalidadeAcao(
								idConsumoAnormalidade, null, null);
			}

		} catch (ErroRepositorioException ex) {

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	public void efetuarRateioDeConsumo(Integer idImovelCondominio, Integer anoMesFaturamento) throws ControladorException {
		Collection colImoveisCondominio = this.pesquisarImovelCondominio(idImovelCondominio);

		try {
			efetuarRateioDeConsumo(colImoveisCondominio, anoMesFaturamento);
		} catch (Exception e) {
			throw new EJBException(e);
		}
	}


	private void efetuarRateioDeConsumo(Collection colImoveisCondominio, Integer anoMesFaturamento) throws ControladorException, ErroRepositorioException {
		if (colImoveisCondominio != null && !colImoveisCondominio.isEmpty()) {
			SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
			boolean existeImovelVinculadoRateioAreaComum = false;

			Iterator iteratorImoveisCondominio = colImoveisCondominio.iterator();

			while (iteratorImoveisCondominio.hasNext()) {
				Object[] imovelCondominioDados = (Object[]) iteratorImoveisCondominio.next();

				// Seta os dados no imóvel condominio
				Integer idImovelCondominio      = (Integer) imovelCondominioDados[0];
				Integer idSituacaoLigacaoAgua   = (Integer) imovelCondominioDados[1];
				Integer idSituacaoLigacaoEsgoto = (Integer) imovelCondominioDados[2];
				Short indFatSitLigacaoAgua      = (Short) imovelCondominioDados[3];
				Short indFatSitLigacaoEsgoto    = (Short) imovelCondominioDados[4];
				
				LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
				ligacaoAguaSituacao.setId(idSituacaoLigacaoAgua);
				ligacaoAguaSituacao.setIndicadorFaturamentoSituacao(indFatSitLigacaoAgua);
				
				LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
				ligacaoEsgotoSituacao.setId(idSituacaoLigacaoEsgoto);
				ligacaoEsgotoSituacao.setIndicadorFaturamentoSituacao(indFatSitLigacaoEsgoto);
				
				Imovel imovelCondominio = new Imovel();
				imovelCondominio.setId(idImovelCondominio);
				imovelCondominio.setLigacaoAguaSituacao(ligacaoAguaSituacao);
				imovelCondominio.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

				// Cria as variáveis que vai armazenas as quantidades de
				// economia e consumo
				int quantidadeEconomiasAguasMedidas = 0;
				int quantidadeEconomiasAguasNaoMedidas = 0;
				int quantidadeEconomiasEsgotoMedidas = 0;
				int quantidadeEconomiasEsgotoNaoMedidas = 0;
				int consumoMinimoLigacao = 0;
				int consumoAguaImoveisVinculados = 0;
				int consumoEsgotoImoveisVinculados = 0;

				/*
				 * Item 2.1 Pesquisa os imóveis que estão vinculados ao imóvel
				 * condominio e que tenham a situação de água igual a ligada ou
				 * cortada ou ligação de esgoto igual a ligado e tenha
				 * hidrometro
				 */

				Collection imoveisVinculados = new ArrayList();
				Collection imoveisVinculadosArrayObject = this.obterImoveisVinculadosDoCondominio(idImovelCondominio);

				/*
				 * Item 2.4 Caso o tipo de rateio corresponda a rateio não
				 * medido água (RTTP_ID=4 da tabela
				 * HIDROMETRO_INSTALACAO_HISTORICO com LAGU_ID=IMOV_ID do imóvel
				 * condominio e com HIDI_DTRETIRADAHIDROMETRO igual a nulo):
				 */
				RateioTipo rateioTipoLigacaoAgua = null;
				try {
					rateioTipoLigacaoAgua = this.repositorioMicromedicao.obterDadosRateioTipoParaLigacaoAgua(imovelCondominio);
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
					throw new ControladorException("erro.sistema", e);
				}

				// RM3221 - adicionado por Vivianne Sousa - 17/08/2011 -
				// analista:Claudio Lira
				if (rateioTipoLigacaoAgua != null && rateioTipoLigacaoAgua.getId().equals(RateioTipo.RATEIO_AREA_COMUM)) {
					existeImovelVinculadoRateioAreaComum = true;
				}

				if (imoveisVinculadosArrayObject != null && !imoveisVinculadosArrayObject.isEmpty()) {
					Iterator iteratorImoveisVinculados = imoveisVinculadosArrayObject.iterator();

					while (iteratorImoveisVinculados.hasNext()) {

						// Recupera os dados do imóvel vinculado
						Object[] dadosImovelVinculado = (Object[]) iteratorImoveisVinculados.next();
						Integer idImovelVinculado = (Integer) dadosImovelVinculado[0];

						// Obtem quantidade de economias
						Short quantidadeEconomia = (Short) dadosImovelVinculado[1];
						Integer idSituacaoLigacaoAguaImovelVinculado = (Integer) dadosImovelVinculado[2];
						Short indFatSitLigacaoAguaImovelVinculado = (Short) dadosImovelVinculado[8];
						Integer idSituacaoLigacaoEsgotoImovelVinculado = (Integer) dadosImovelVinculado[3];
						Short indFatSitLigacaoEsgotoImovelVinculado = (Short) dadosImovelVinculado[9];
						Integer idMedicaoPoco = (Integer) dadosImovelVinculado[4];
						Integer idConsumoTarifa = (Integer) dadosImovelVinculado[5];

						Integer idHidrometroInstalacaoHistorico;
						HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = null;

						if (dadosImovelVinculado[7] != null) {
							idHidrometroInstalacaoHistorico = (Integer) dadosImovelVinculado[7];
							hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
							hidrometroInstalacaoHistorico.setId(idHidrometroInstalacaoHistorico);
						}

						Integer idLigacaoAgua = (Integer) dadosImovelVinculado[6];
						LigacaoAgua ligacaoAgua = new LigacaoAgua();
						ligacaoAgua.setId(idLigacaoAgua);
						ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);

						// Monta imóvel vinculado e seta os dados no objeto
						ConsumoTarifa consumoTarifa = new ConsumoTarifa();
						consumoTarifa.setId(idConsumoTarifa);

						LigacaoAguaSituacao ligacaoAguaSituacaoImovelVinculado = new LigacaoAguaSituacao();
						ligacaoAguaSituacaoImovelVinculado.setId(idSituacaoLigacaoAguaImovelVinculado);
						ligacaoAguaSituacaoImovelVinculado.setIndicadorFaturamentoSituacao(indFatSitLigacaoAguaImovelVinculado);

						LigacaoEsgotoSituacao ligacaoEsgotoSituacaoImovelVinculado = new LigacaoEsgotoSituacao();
						ligacaoEsgotoSituacaoImovelVinculado.setId(idSituacaoLigacaoEsgotoImovelVinculado);
						ligacaoEsgotoSituacaoImovelVinculado.setIndicadorFaturamentoSituacao(indFatSitLigacaoEsgotoImovelVinculado);
						HidrometroInstalacaoHistorico medicaoPoco = new HidrometroInstalacaoHistorico();
						medicaoPoco.setId(idMedicaoPoco);

						Imovel imovelVinculado = new Imovel();
						imovelVinculado.setId(idImovelVinculado);
						imovelVinculado.setLigacaoAgua(ligacaoAgua);
						imovelVinculado.setLigacaoAguaSituacao(ligacaoAguaSituacaoImovelVinculado);
						imovelVinculado.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacaoImovelVinculado);
						imovelVinculado.setHidrometroInstalacaoHistorico(medicaoPoco);
						imovelVinculado.setConsumoTarifa(consumoTarifa);
						imovelVinculado.setQuantidadeEconomias(quantidadeEconomia);

						if (dadosImovelVinculado[10] != null) {
							imovelVinculado.setIndicadorImovelAreaComum((Short) dadosImovelVinculado[10]);
						}

						// Caso a quantidade de economia seja nula seta o
						// valor para zero
						if (quantidadeEconomia == null) {
							quantidadeEconomia = 0;
						}

						// Recupera os dados do consumo da ligação de água do
						// imóvel
						Object[] dadosConsumoLigacaoAguaImovel = (Object[]) this.repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovel(
										imovelVinculado.getId(), anoMesFaturamento, LigacaoTipo.LIGACAO_AGUA);

						// Recupera os dados do consumo da ligação de esgoto do
						// imóvel
						Object[] dadosConsumoLigacaoEsgotoImovel = (Object[]) this.repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovel(
										imovelVinculado.getId(), anoMesFaturamento, LigacaoTipo.LIGACAO_ESGOTO);

						// VERIFICANDO SE EXISTE CONSUMO GERADO PARA O IMOVEL
						// VINCULADO
						if (dadosConsumoLigacaoAguaImovel != null || dadosConsumoLigacaoEsgotoImovel != null) {

							if (imovelVinculado.getLigacaoAguaSituacao() != null
									&& (LigacaoAguaSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()))) {
								/*
								 * Item 2.2.2.1 Caso o imóvel seja medido na
								 * ligação de água (hidi_id preenchido na tabela
								 * ligacao_agua com lagu_id=imov_id) acumula a
								 * quantidade de economias do imóvelna
								 * quantidade de economias da água medida. Caso
								 * contrário acumula na quantidade de economias
								 * de água não medidas.
								 */
								if (imovelVinculado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
										&& imovelVinculado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null) {
									quantidadeEconomiasAguasMedidas    += quantidadeEconomia.intValue();
								} else {
									quantidadeEconomiasAguasNaoMedidas += quantidadeEconomia.intValue();
								}

								// Alterado por Leonardo Vieira 03/12
								Integer consumoLigacaoAguaImovel = null;

								if (dadosConsumoLigacaoAguaImovel != null && dadosConsumoLigacaoAguaImovel[1] != null) {
									consumoLigacaoAguaImovel = (Integer) dadosConsumoLigacaoAguaImovel[1];
								}

								/*
								 * Item 2.2.2.2 Acumula o consumo da ligação de
								 * água do imóvel para o mês de faturamento
								 * corrente no consumo de água dos imóveis
								 * vinculados caso exista.
								 */
								if (consumoLigacaoAguaImovel != null) {
									consumoAguaImoveisVinculados += consumoLigacaoAguaImovel.intValue();
								}
							}

							// 2.2.3 - Caso o imóvel seja ligado de esgoto
							if (imovelVinculado.getLigacaoEsgotoSituacao() != null
									&& LigacaoEsgotoSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao())) {

								/*
								 * Caso o tipo de rateio corresponda a rateio
								 * não medido água (RTTP_ID=4 da tabela
								 * HIDROMETRO_INSTALACAO_HISTORICO com
								 * LAGU_ID=IMOV_ID do imóvel condominio e com
								 * HIDI_DTRETIRADAHIDROMETRO igual a nulo):
								 */
								if (rateioTipoLigacaoAgua != null && rateioTipoLigacaoAgua.getId().equals(RateioTipo.RATEIO_NAO_MEDIDO_AGUA)) {

									if (imovelVinculado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
											&& imovelVinculado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null) {

										quantidadeEconomiasEsgotoMedidas += quantidadeEconomia.intValue();
									} else {
										quantidadeEconomiasEsgotoNaoMedidas += quantidadeEconomia.intValue();
									}
								} else {
									if (imovelVinculado.getHidrometroInstalacaoHistorico() != null
											&& imovelVinculado.getHidrometroInstalacaoHistorico().getId() != null) {

										quantidadeEconomiasEsgotoMedidas += quantidadeEconomia.intValue();
									} else {
										quantidadeEconomiasEsgotoNaoMedidas += quantidadeEconomia.intValue();
									}
								}

								Integer consumoLigacaoEsgotoImovel = null;

								if (dadosConsumoLigacaoEsgotoImovel != null	&& dadosConsumoLigacaoEsgotoImovel[1] != null) {
									consumoLigacaoEsgotoImovel = (Integer) dadosConsumoLigacaoEsgotoImovel[1];
								}

								if (consumoLigacaoEsgotoImovel != null) {
									consumoEsgotoImoveisVinculados += consumoLigacaoEsgotoImovel.intValue();
								}
							}

							int consumoMinimoLigacaoImovelVinculado = this.obterConsumoMinimoLigacao(imovelVinculado, null);

							consumoMinimoLigacao += consumoMinimoLigacaoImovelVinculado;

							imoveisVinculados.add(imovelVinculado);

						}

					}// while dos imóveis vinculados

					/*
					 * Item 2.3.1 Caso o imóvel condominio seja ligado de água
					 * (last_id da tabela imóvel, com o valor correspondente a
					 * ligado de água).
					 */
					if (imovelCondominio.getLigacaoAguaSituacao() != null
							&& LigacaoAguaSituacao.FATURAMENTO_ATIVO
									.equals(imovelCondominio
											.getLigacaoAguaSituacao()
											.getIndicadorFaturamentoSituacao())) {

						// [SF0001] - Determinar Rateio de Agua
						determinarRateioAgua(imoveisVinculados,
								imovelCondominio, anoMesFaturamento,
								consumoAguaImoveisVinculados,
								consumoMinimoLigacao, sistemaParametro,
								quantidadeEconomiasAguasNaoMedidas,
								quantidadeEconomiasAguasMedidas,
								existeImovelVinculadoRateioAreaComum);
					}

					/*
					 * Item 2.3.2 Caso o imóvel condomínio seja ligado de esgoto
					 * (lest_id da tabela imóvel, com o valor correspondente a
					 * ligado de esgoto).
					 */
					if (imovelCondominio.getLigacaoEsgotoSituacao() != null
							&& LigacaoEsgotoSituacao.FATURAMENTO_ATIVO
									.equals(imovelCondominio
											.getLigacaoEsgotoSituacao()
											.getIndicadorFaturamentoSituacao())) {

						// [SF0002] - Determinar Rateio de Esgoto
						determinarRateioEsgoto(imoveisVinculados,
								imovelCondominio, anoMesFaturamento,
								consumoEsgotoImoveisVinculados,
								consumoMinimoLigacao, sistemaParametro,
								quantidadeEconomiasEsgotoNaoMedidas,
								quantidadeEconomiasEsgotoMedidas,
								rateioTipoLigacaoAgua);
					}
				}
			}// laço do for de imoveis condominio
		}
	}

	public Collection pesquisarImovelCondominio(Integer idImovel) throws ControladorException {
		try {
			return repositorioMicromedicao.pesquisarImovelCondominio(idImovel);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public Rota buscarRotaPorMatriculaImovel(Integer imovel, Integer anoMesFaturamentoGrupo) throws ControladorException {
		try {
			return repositorioMicromedicao.buscarRotaPorMatriculaImovel(imovel,	anoMesFaturamentoGrupo);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisar ultima anormalidade de leitura do imovel
	 * 
	 * @author Hugo Amorim
	 * @date 19/02/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public String pesquisarAnormalidadesImovel(Integer idImovel,
			String indicadorAguaEsgoto) throws ControladorException {

		String retorno = null;

		try {
			retorno = repositorioMicromedicao.pesquisarAnormalidadesImovel(
					idImovel, indicadorAguaEsgoto);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Inseri um nova Rota a partir da Rota pai. Utilizado na alteracao de
	 * subdivisao de Rotas.
	 * 
	 * @author Ivan Sérgio
	 * @date 23/02/2010
	 * 
	 * @param idRotaOriginal
	 * @param codigoRota
	 * @param idLeiturista
	 * @return
	 * @throws ControladorException
	 */
	public Integer inserirNovaSubdivisoesDeRota(Integer idRotaOriginal,
			Short codigoRota, Integer idLeiturista) throws ControladorException {

		Integer idInserido = null;

		try {
			FiltroRota filtroRota = new FiltroRota();
			filtroRota.adicionarParametro(new ParametroSimples(
					FiltroRota.ID_ROTA, idRotaOriginal));
			Collection pesquisa = getControladorUtil().pesquisar(filtroRota,
					Rota.class.getName());
			if (pesquisa == null || pesquisa.isEmpty()) {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Rota");
			}

			Rota rota = (Rota) Util.retonarObjetoDeColecao(pesquisa);

			Leiturista leiturista = new Leiturista();
			leiturista.setId(idLeiturista);

			FiltroRotaAcaoCriterio filtroRotaAcaoCriterio = new FiltroRotaAcaoCriterio();
			filtroRotaAcaoCriterio.adicionarParametro(new ParametroSimples(
					FiltroRotaAcaoCriterio.ROTA_ID, idRotaOriginal));
			Collection<RotaAcaoCriterio> rotaAcoesCriterio = (Collection<RotaAcaoCriterio>) getControladorUtil()
					.pesquisar(filtroRotaAcaoCriterio,
							RotaAcaoCriterio.class.getName());
			if (rotaAcoesCriterio == null || rotaAcoesCriterio.isEmpty()) {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Rota Ações Critério da Rota original");
			}

			Rota novaRota = new Rota();

			novaRota.setId(null);
			novaRota.setIndicadorAjusteConsumo(rota.getIndicadorAjusteConsumo());
			novaRota.setDataAjusteLeitura(rota.getDataAjusteLeitura());
			novaRota.setIndicadorFiscalizarCortado(rota
					.getIndicadorFiscalizarCortado());
			novaRota.setIndicadorFiscalizarSuprimido(rota
					.getIndicadorFiscalizarCortado());
			novaRota.setIndicadorFiscalizarSuprimido(rota
					.getIndicadorFiscalizarSuprimido());
			novaRota.setPercentualGeracaoFaixaFalsa(rota
					.getPercentualGeracaoFaixaFalsa());
			novaRota.setIndicadorGerarFiscalizacao(rota
					.getIndicadorGerarFiscalizacao());
			novaRota.setPercentualGeracaoFiscalizacao(rota
					.getPercentualGeracaoFiscalizacao());
			novaRota.setIndicadorUso(rota.getIndicadorUso());
			novaRota.setEmpresa(rota.getEmpresa());
			novaRota.setLeituraTipo(rota.getLeituraTipo());
			novaRota.setEmpresaEntregaContas(rota.getEmpresaEntregaContas());
			novaRota.setIndicadorRotaAlternativa(rota
					.getIndicadorRotaAlternativa());
			novaRota.setIndicadorTransmissaoOffline(rota
					.getIndicadorTransmissaoOffline());

			novaRota.setCodigo(codigoRota);
			novaRota.setFaturamentoGrupo(rota.getFaturamentoGrupo());
			novaRota.setCobrancaGrupo(rota.getCobrancaGrupo());
			novaRota.setLeiturista(leiturista);

			novaRota.setSetorComercial(rota.getSetorComercial());
			novaRota.setEmpresaCobranca(rota.getEmpresaCobranca());
			novaRota.setNumeroSequenciaLeitura(rota.getNumeroSequenciaLeitura());
			novaRota.setUltimaAlteracao(new Date());

			idInserido = (Integer) getControladorUtil().inserir(novaRota);
			novaRota.setId(idInserido);

			for (RotaAcaoCriterio rotaAcaoCriterio : rotaAcoesCriterio) {
				RotaAcaoCriterio novaRotaAcaoCriterio = new RotaAcaoCriterio();
				novaRotaAcaoCriterio.setRota(novaRota);
				novaRotaAcaoCriterio.setCobrancaAcao(rotaAcaoCriterio
						.getCobrancaAcao());
				novaRotaAcaoCriterio.setCobrancaCriterio(rotaAcaoCriterio
						.getCobrancaCriterio());
				novaRotaAcaoCriterio.setUltimaAlteracao(new Date());

				RotaAcaoCriterioPK pk = new RotaAcaoCriterioPK(
						novaRota.getId(), rotaAcaoCriterio.getCobrancaAcao()
								.getId());
				novaRotaAcaoCriterio.setComp_id(pk);

				getControladorUtil().inserir(novaRotaAcaoCriterio);
			}
		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(e.getMessage(), e);
		}

		return idInserido;
	}

	/**
	 * 
	 * Pesquisa numero de hidrometro da ligacao de agua do imovel
	 * 
	 * @author Hugo Amorim
	 * @date 04/03/2010
	 * @param Id
	 *            Imovel
	 * @return Numero do Hidrometro
	 * @throws ErroRepositorioException
	 */
	public String pesquisarNumeroHidrometro(Integer idImovel)
			throws ControladorException {
		try {

			return repositorioMicromedicao.pesquisarNumeroHidrometro(idImovel);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC1000] Informar Medidor de Energia por Rota.
	 * 
	 * Obtém a quantidade de imoveis de acordo com o filtro.
	 * 
	 * @author Hugo Leonardo
	 * @date 12/03/2010
	 * 
	 * @param ColetaMedidorEnergiaHelper
	 * 
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer countColetaMedidorEnergia(ColetaMedidorEnergiaHelper helper)
			throws ControladorException {

		try {
			return this.repositorioMicromedicao
					.pesquisarTotalRegistroColetaMedidorEnergia(helper
							.getLocalidadeId() != null ? helper
							.getLocalidadeId().toString() : null, helper
							.getSetorComercialId() != null ? helper
							.getSetorComercialId().toString() : null, helper
							.getRotaId() != null ? helper.getRotaId()
							.toString() : null, helper.getTipo().toString());

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC1000] Informar Medidor de Energia por Rota.
	 * 
	 * @author Hugo Leonardo
	 * @date 12/03/2010
	 * 
	 * @param FiltrarRelatorioColetaMedidorEnergiaHelper
	 * 
	 * @return Collection<ColetaMedidorEnergiaHelper>
	 * @throws ControladorException
	 */
	public Collection<ColetaMedidorEnergiaHelper> pesquisarColetaMedidorEnergia(
			ColetaMedidorEnergiaHelper helper) throws ControladorException {

		Collection colecaoRetorno = new ArrayList();
		try {

			Collection coletaMedidorEnergia = repositorioMicromedicao
					.pesquisarColetaMedidorEnergia(
							helper.getLocalidadeId() != null ? helper
									.getLocalidadeId().toString() : null,
							helper.getSetorComercialId() != null ? helper
									.getSetorComercialId().toString() : null,
							helper.getRotaId() != null ? helper.getRotaId()
									.toString() : null, helper.getTipo()
									.toString());

			Iterator iteratorColetaMedidorEnergia = coletaMedidorEnergia
					.iterator();

			while (iteratorColetaMedidorEnergia.hasNext()) {

				ColetaMedidorEnergiaHelper medidorHelper = new ColetaMedidorEnergiaHelper();

				Object[] objeto = (Object[]) iteratorColetaMedidorEnergia
						.next();

				// Descrição Empresa
				if (objeto[0] != null) {
					String descricaoEmpresa = (String) objeto[0];

					medidorHelper.setDescricaoEmpresa(descricaoEmpresa);
				}

				// faturamentoGrupo
				if (objeto[1] != null) {
					Integer faturamentoGrupo = (Integer) objeto[1];
					medidorHelper.setFaturamentoGrupo(faturamentoGrupo
							.toString());
				}

				// Id localidade
				if (objeto[2] != null) {
					Integer idLocalidade = (Integer) objeto[2];
					medidorHelper.setLocalidadeId(idLocalidade.toString());
				}

				// Id setorComercial
				if (objeto[3] != null) {
					Integer idSetorComercial = (Integer) objeto[3];
					medidorHelper.setSetorComercialId(idSetorComercial
							.toString());
				}

				// Codigo Rota
				if (objeto[4] != null) {
					Short codigoRota = (Short) objeto[4];
					medidorHelper.setRotaId(codigoRota.toString());
				}

				// Nome sequencialRota
				if (objeto[5] != null) {
					Integer sequencialRota = (Integer) objeto[5];
					medidorHelper.setSequencialRota(sequencialRota.toString());
				}

				// Medidor Energia
				if (objeto[6] != null) {
					String medidorEnergia = (String) objeto[6];

					medidorHelper.setMedidorEnergia(medidorEnergia);
				}

				// Id Imovel, Inscrição e Matricula
				if (objeto[7] != null) {
					Integer idImovel = (Integer) objeto[7];
					medidorHelper.setImovel(idImovel.toString());
					medidorHelper.setInscricao(this.getControladorImovel()
							.pesquisarInscricaoImovel(idImovel));
					medidorHelper.setMatricula(Util
							.retornaMatriculaImovelFormatada(idImovel));
				}

				colecaoRetorno.add(medidorHelper);
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		return colecaoRetorno;
	}

	/**
	 * Seleciona a MedicaoHistorico que vai ser atualizada para que possa ser
	 * registrada a transação
	 * 
	 * @author Arthur Carvalho
	 * @date 25/03/2010
	 * 
	 * @param mesAno
	 * @param idImovel
	 * @param ligacaoAgua
	 * @param medicaoHistorico
	 * @return
	 * @throws ControladorException
	 */
	protected void selecionaAtualizaMedicaoHistoricoREGISTRATRANSACAO(
			Integer idImovel, String mesAno,
			String dataLeituraAnteriorFaturamento,
			String leituraAnteriorFaturamento,
			String dataLeituraAtualInformada, String leituraAtualInformada,
			String consumo, boolean ligacaoAgua, Integer idAnormalidade,
			Integer idleituraSituacaoAtual, Usuario usuarioLogado,
			boolean alterouAnormalidade,
			MotivoInterferenciaTipo motivoInterferenciaTipo)
			throws ControladorException {

		MedicaoHistorico medicaoHistorico = new MedicaoHistorico();

		FiltroMedicaoHistorico filtroMedicao = new FiltroMedicaoHistorico();
		filtroMedicao.adicionarParametro(new ParametroSimples(
				FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO, Util
						.formatarMesAnoComBarraParaAnoMes(mesAno)));

		if (ligacaoAgua) {

			filtroMedicao.adicionarParametro(new ParametroSimples(
					FiltroMedicaoHistorico.LIGACAO_AGUA_ID, idImovel));
		} else {
			filtroMedicao.adicionarParametro(new ParametroSimples(
					FiltroMedicaoHistorico.IMOVEL_ID, idImovel));

		}

		Collection colecaoMedicaoHistorico = this.getControladorUtil()
				.pesquisar(filtroMedicao, MedicaoHistorico.class.getName());

		medicaoHistorico = (MedicaoHistorico) Util
				.retonarObjetoDeColecao(colecaoMedicaoHistorico);

		// Data da Leitura Anterior Faturamento
		if (dataLeituraAnteriorFaturamento != null) {
			medicaoHistorico.setDataLeituraAnteriorFaturamento(Util
					.converteStringParaDate(dataLeituraAnteriorFaturamento));
		}
		// Leitura Anterior Faturamento
		if (leituraAnteriorFaturamento != null) {
			medicaoHistorico.setLeituraAnteriorFaturamento(new Integer(
					leituraAnteriorFaturamento));
		}
		// Data da Leitura Atual Informada
		if (dataLeituraAtualInformada != null) {
			medicaoHistorico.setDataLeituraAtualInformada(Util
					.converteStringParaDate(dataLeituraAtualInformada));
		}
		// Leitura Atual Informada
		if (leituraAtualInformada != null && !leituraAtualInformada.equals("")) {
			medicaoHistorico.setLeituraAtualInformada(new Integer(
					leituraAtualInformada));
			medicaoHistorico.setLeituraAtualFaturamento(new Integer(
					leituraAtualInformada));
		} else {
			medicaoHistorico.setLeituraAtualFaturamento(new Integer(0));
			medicaoHistorico.setLeituraAtualInformada(null);
		}

		// Ultima Alteração
		medicaoHistorico.setUltimaAlteracao(new Date());

		// Numero do consumo Informado
		if (consumo != null && !consumo.equals("")) {
			medicaoHistorico.setNumeroConsumoInformado(new Integer(consumo));
		}
		// Indicador Analisado
		medicaoHistorico
				.setIndicadorAnalisado(MedicaoHistorico.INDICADOR_ANALISADO_ATUALIZADO);

		// Usuario Alteração
		medicaoHistorico.setUsuarioAlteracao(usuarioLogado);

		// Leitura Situacao
		if (idleituraSituacaoAtual != null
				&& idleituraSituacaoAtual.intValue() > 0) {
			LeituraSituacao leituraSituacao = new LeituraSituacao();
			leituraSituacao.setId(idleituraSituacaoAtual);
			medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
		}
		// Motivo Interferencia Tipo
		if (motivoInterferenciaTipo != null) {
			medicaoHistorico
					.setMotivoInterferenciaTipo(motivoInterferenciaTipo);
		}
		// leitura Anormalidade Informada
		// Leitura Anormalidade
		LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
		leituraAnormalidade.setId(idAnormalidade);
		medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
		medicaoHistorico.setLeituraAnormalidadeInformada(leituraAnormalidade);

		RegistradorOperacao registrador = new RegistradorOperacao(
				Operacao.OPERACAO_ANALISAR_EXCECOES_LEITURAS_CONSUMO, idImovel,
				medicaoHistorico.getId(), new UsuarioAcaoUsuarioHelper(
						usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		registrador.registrarOperacao(medicaoHistorico);

		getControladorTransacao().registrarTransacao(medicaoHistorico);

	}

	/**
	 * Registra transacao do consumo historico
	 * 
	 * @author Arthur Carvalho
	 * @date 25/03/2010
	 * 
	 * @param mesAno
	 * @param idImovel
	 * @param consumoHistorico
	 * @return
	 * @throws ControladorException
	 */
	protected void selecionarAtualizaConsumoHistoricoREGISTRATRANSACAO(
			Integer idImovel, String mesAno, Usuario usuarioLogado)
			throws ControladorException {

		ConsumoHistorico consumoHistorico = new ConsumoHistorico();

		FiltroConsumoHistorico filtroConsumo = new FiltroConsumoHistorico();
		filtroConsumo.adicionarParametro(new ParametroSimples(
				FiltroConsumoHistorico.IMOVEL_ID, idImovel));
		filtroConsumo.adicionarParametro(new ParametroSimples(
				FiltroConsumoHistorico.ANO_MES_FATURAMENTO, Util
						.formatarMesAnoComBarraParaAnoMes(mesAno)));

		Collection colecaoConsumoHistorico = this.getControladorUtil()
				.pesquisar(filtroConsumo, ConsumoHistorico.class.getName());

		consumoHistorico = (ConsumoHistorico) Util
				.retonarObjetoDeColecao(colecaoConsumoHistorico);

		// Atualiza o objeto para registrar transação
		Date data = new Date();
		consumoHistorico.setUltimaAlteracao(data);

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ANALISAR_EXCECOES_LEITURAS_CONSUMO, idImovel,
				consumoHistorico.getId(), new UsuarioAcaoUsuarioHelper(
						usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		registradorOperacao.registrarOperacao(consumoHistorico);

		getControladorTransacao().registrarTransacao(consumoHistorico);

	}

	/**
	 * [UC0997] Gerar Resumo de Ligações por Capacidade de Hidrômetro.
	 * 
	 * @author Hugo Leonardo
	 * @date 30/03/2010
	 * 
	 * @param RelatorioResumoLigacoesCapacidadeHidrometroHelper
	 * 
	 * @return Collection<RelatorioResumoLigacoesCapacidadeHidrometroBean>
	 * @throws ControladorException
	 */
	public Collection<RelatorioResumoLigacoesCapacidadeHidrometroBean> pesquisarRelatorioResumoLigacoesCapacidadeHidrometro(
			RelatorioResumoLigacoesCapacidadeHidrometroHelper helper)
			throws ControladorException {

		Collection<RelatorioResumoLigacoesCapacidadeHidrometroBean> retorno = new ArrayList<RelatorioResumoLigacoesCapacidadeHidrometroBean>();
		Collection<RelatorioResumoLigacoesCapacidadeHidrometroBean> beansPorLocalidade = new ArrayList<RelatorioResumoLigacoesCapacidadeHidrometroBean>();
		Collection<RelatorioResumoLigacoesCapacidadeHidrometroBean> beansPorUnidade = new ArrayList<RelatorioResumoLigacoesCapacidadeHidrometroBean>();
		Collection<RelatorioResumoLigacoesCapacidadeHidrometroBean> beansPorGerencia = new ArrayList<RelatorioResumoLigacoesCapacidadeHidrometroBean>();
		Collection<RelatorioResumoLigacoesCapacidadeHidrometroBean> beansPorEstado = new ArrayList<RelatorioResumoLigacoesCapacidadeHidrometroBean>();
		Collection colecaoDadosLocalidade = null;
		Collection colecaoDadosUnidade = null;
		Collection colecaoDadosGerencia = null;
		Collection colecaoDadosEstado = null;

		try {

			// VARIAVEIS PARA ARMAZERNAR DADOS DA PESQUISA
			// POR LOCALIDADE
			Integer idGerenciaLoc = null;
			String nomeGerenciaLoc = null;
			Integer idUnidadeLoc = null;
			String nomeUnidadeLoc = null;
			Integer idLocalidadeLoc = null;
			String nomeLocalidadeLoc = null;
			String capacidadeHidrometroLoc = null;
			String diametroHidrometroLoc = null;
			Integer qtdLigacoesLoc = null;
			Integer qtdEconomiasLoc = null;
			Integer volumeAguaMedidoLoc = null;
			BigDecimal valorFaturadoLoc = null;

			// VARIAVEIS PARA ARMAZERNAR DADOS DA PESQUISA
			// POR UNIDADE DE NEGOCIO
			Integer idGerenciaUni = null;
			String nomeGerenciaUni = null;
			Integer idUnidadeUni = null;
			String nomeUnidadeUni = null;
			String capacidadeHidrometroUni = null;
			String diametroHidrometroUni = null;
			Integer qtdLigacoesUni = null;
			Integer qtdEconomiasUni = null;
			Integer volumeAguaMedidoUni = null;
			BigDecimal valorFaturadoUni = null;

			// VARIAVEIS PARA ARMAZERNAR DADOS DA PESQUISA
			// POR GERENCIA REGIONAL
			Integer idGerenciaGer = null;
			String nomeGerenciaGer = null;
			String capacidadeHidrometroGer = null;
			String diametroHidrometroGer = null;
			Integer qtdLigacoesGer = null;
			Integer qtdEconomiasGer = null;
			Integer volumeAguaMedidoGer = null;
			BigDecimal valorFaturadoGer = null;

			// VARIAVEIS PARA ARMAZERNAR DADOS DA PESQUISA
			// POR ESTADO
			String capacidadeHidrometroEst = null;
			String diametroHidrometroEst = null;
			Integer qtdLigacoesEst = null;
			Integer qtdEconomiasEst = null;
			Integer volumeAguaMedidoEst = null;
			BigDecimal valorFaturadoEst = null;

			// BEAN
			RelatorioResumoLigacoesCapacidadeHidrometroBean bean = null;

			// REALIZA PESQUISA CASO TIPO DE TOTALIZAÇÃO SEJA:

			// Estado por Gerência Regional e por Localidade
			// Estado por Unidade de Negócio e por Localidade
			// Gerência Regional por Localidade
			// Unidade de Negócio por Localidade
			// Localidade
			if (helper.getOpcaoTotalizacao().equals("4")
					|| helper.getOpcaoTotalizacao().equals("5")
					|| helper.getOpcaoTotalizacao().equals("7")
					|| helper.getOpcaoTotalizacao().equals("9")
					|| helper.getOpcaoTotalizacao().equals("10")) {

				colecaoDadosLocalidade = repositorioMicromedicao
						.pesquisarRelatorioResumoLigacoesCapacidadeHidrometro(
								helper, "LOCALIDADE");
			}

			// Estado por Unidade de Negócio
			// Estado por Unidade de Negócio e por Localidade
			// Unidade de Negócio
			// Unidade de Negócio por Localidade
			if (helper.getOpcaoTotalizacao().equals("3")
					|| helper.getOpcaoTotalizacao().equals("5")
					|| helper.getOpcaoTotalizacao().equals("8")
					|| helper.getOpcaoTotalizacao().equals("9")) {

				colecaoDadosUnidade = repositorioMicromedicao
						.pesquisarRelatorioResumoLigacoesCapacidadeHidrometro(
								helper, "UNIDADE");
			}

			// Estado por Gerência Regional
			// Estado por Gerência Regional e por Localidade
			// Gerência Regional
			// Gerência Regional por Localidade
			if (helper.getOpcaoTotalizacao().equals("2")
					|| helper.getOpcaoTotalizacao().equals("4")
					|| helper.getOpcaoTotalizacao().equals("6")
					|| helper.getOpcaoTotalizacao().equals("7")) {

				colecaoDadosGerencia = repositorioMicromedicao
						.pesquisarRelatorioResumoLigacoesCapacidadeHidrometro(
								helper, "GERENCIA");
			}

			// Estado
			// Estado por Gerência Regional
			// Estado por Unidade de Negócio
			// Estado por Gerência Regional e por Localidade
			// Estado por Unidade de Negócio e por Localidade
			if (helper.getOpcaoTotalizacao().equals("1")
					|| helper.getOpcaoTotalizacao().equals("2")
					|| helper.getOpcaoTotalizacao().equals("3")
					|| helper.getOpcaoTotalizacao().equals("4")
					|| helper.getOpcaoTotalizacao().equals("5")) {

				colecaoDadosEstado = repositorioMicromedicao
						.pesquisarRelatorioResumoLigacoesCapacidadeHidrometro(
								helper, "ESTADO");
			}

			if (colecaoDadosLocalidade != null) {
				// GERAR DADOS DAS LOCALIDADES
				for (Iterator iterator = colecaoDadosLocalidade.iterator(); iterator
						.hasNext();) {

					Object[] dados = null;

					dados = (Object[]) iterator.next();

					// Dados Pesquisa
					idGerenciaLoc = (Integer) dados[0];
					nomeGerenciaLoc = (String) dados[1];
					idUnidadeLoc = (Integer) dados[2];
					nomeUnidadeLoc = (String) dados[3];
					idLocalidadeLoc = (Integer) dados[4];
					nomeLocalidadeLoc = (String) dados[5];
					capacidadeHidrometroLoc = (String) dados[6];
					diametroHidrometroLoc = (String) dados[7];
					qtdLigacoesLoc = (Integer) dados[8];
					qtdEconomiasLoc = (Integer) dados[9];
					volumeAguaMedidoLoc = (Integer) dados[10];
					valorFaturadoLoc = (BigDecimal) dados[11];

					if (idLocalidadeLoc != null) {

						bean = new RelatorioResumoLigacoesCapacidadeHidrometroBean(
								idGerenciaLoc, nomeGerenciaLoc, idUnidadeLoc,
								nomeUnidadeLoc, idLocalidadeLoc,
								nomeLocalidadeLoc, capacidadeHidrometroLoc,
								diametroHidrometroLoc, qtdLigacoesLoc,
								qtdEconomiasLoc, volumeAguaMedidoLoc,
								valorFaturadoLoc, "LOCALIDADE - "
										+ nomeLocalidadeLoc);

						beansPorLocalidade.add(bean);
					}
				}
			}
			bean = null;

			if (colecaoDadosUnidade != null) {
				// GERAR DADOS DAS UNIDADES
				for (Iterator iterator = colecaoDadosUnidade.iterator(); iterator
						.hasNext();) {

					Object[] dados = null;

					dados = (Object[]) iterator.next();

					// Dados Pesquisa
					idGerenciaUni = (Integer) dados[0];
					nomeGerenciaUni = (String) dados[1];
					idUnidadeUni = (Integer) dados[2];
					nomeUnidadeUni = (String) dados[3];
					capacidadeHidrometroUni = (String) dados[4];
					diametroHidrometroUni = (String) dados[5];
					qtdLigacoesUni = (Integer) dados[6];
					qtdEconomiasUni = (Integer) dados[7];
					volumeAguaMedidoUni = (Integer) dados[8];
					valorFaturadoUni = (BigDecimal) dados[9];

					if (idUnidadeUni != null) {

						bean = new RelatorioResumoLigacoesCapacidadeHidrometroBean(
								idGerenciaUni, nomeGerenciaUni, idUnidadeUni,
								nomeUnidadeUni, null, null,
								capacidadeHidrometroUni, diametroHidrometroUni,
								qtdLigacoesUni, qtdEconomiasUni,
								volumeAguaMedidoUni, valorFaturadoUni,
								"UNIDADE - " + nomeUnidadeUni);

						beansPorUnidade.add(bean);
					}
				}
			}
			bean = null;

			if (colecaoDadosGerencia != null) {
				// GERAR DADOS DAS GERENCIAS
				for (Iterator iterator = colecaoDadosGerencia.iterator(); iterator
						.hasNext();) {

					Object[] dados = null;

					dados = (Object[]) iterator.next();

					// Dados Pesquisa
					idGerenciaGer = (Integer) dados[0];
					nomeGerenciaGer = (String) dados[1];
					capacidadeHidrometroGer = (String) dados[2];
					diametroHidrometroGer = (String) dados[3];
					qtdLigacoesGer = (Integer) dados[4];
					qtdEconomiasGer = (Integer) dados[5];
					volumeAguaMedidoGer = (Integer) dados[6];
					valorFaturadoGer = (BigDecimal) dados[7];

					if (idGerenciaGer != null) {

						bean = new RelatorioResumoLigacoesCapacidadeHidrometroBean(
								idGerenciaGer, nomeGerenciaGer, null, null,
								null, null, capacidadeHidrometroGer,
								diametroHidrometroGer, qtdLigacoesGer,
								qtdEconomiasGer, volumeAguaMedidoGer,
								valorFaturadoGer, "GERÊNCIA - "
										+ nomeGerenciaGer);

						beansPorGerencia.add(bean);

					}
				}
			}
			bean = null;

			if (colecaoDadosEstado != null) {
				// GERAR DADOS DO ESTADO
				for (Iterator iterator = colecaoDadosEstado.iterator(); iterator
						.hasNext();) {

					Object[] dados = null;

					dados = (Object[]) iterator.next();

					// Dados Pesquisa
					capacidadeHidrometroEst = (String) dados[0];
					diametroHidrometroEst = (String) dados[1];
					qtdLigacoesEst = (Integer) dados[2];
					qtdEconomiasEst = (Integer) dados[3];
					volumeAguaMedidoEst = (Integer) dados[4];
					valorFaturadoEst = (BigDecimal) dados[5];

					// Recupera os parâmetros do sistema
					SistemaParametro sistemaParametro = this
							.getControladorUtil()
							.pesquisarParametrosDoSistema();

					String nomeEstado = sistemaParametro.getNomeEstado();

					bean = new RelatorioResumoLigacoesCapacidadeHidrometroBean(
							null, null, null, null, null, null,
							capacidadeHidrometroEst, diametroHidrometroEst,
							qtdLigacoesEst, qtdEconomiasEst,
							volumeAguaMedidoEst, valorFaturadoEst, "ESTADO - "
									+ nomeEstado);

					beansPorEstado.add(bean);
				}
			}

			// REALIZA CONTRUÇÃO ORDENADA DA
			// COLEÇÃO DE BEANS DE ACORDO COM
			// TIPO DE TOTALIZAÇÃO

			// VARIAVEIS PARA CONTROLE DE FLUXO DA MONTAGEM DA
			// DA COLECÃO DE BEANS POR TOTALIZAÇÃO
			Integer idUnidadeAnterior = null;
			Integer idGerenciaAnterior = null;

			switch (new Integer(helper.getOpcaoTotalizacao())) {
			// Estado
			case 1:
				retorno = beansPorEstado;
				break;
			// Estado por Gerência Regional
			case 2:
				for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanGer : beansPorGerencia) {
					retorno.add(beanGer);
				}
				for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanEst : beansPorEstado) {
					retorno.add(beanEst);
				}
				break;
			// Estado por Unidade de Negócio
			case 3:
				for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanUni : beansPorUnidade) {
					retorno.add(beanUni);
				}
				for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanEst : beansPorEstado) {
					retorno.add(beanEst);
				}
				break;
			// Estado por Gerência Regional e por Localidade
			case 4:
				for (Iterator iteraLocalidades = beansPorLocalidade.iterator(); iteraLocalidades
						.hasNext();) {

					RelatorioResumoLigacoesCapacidadeHidrometroBean beanLoc = (RelatorioResumoLigacoesCapacidadeHidrometroBean) iteraLocalidades
							.next();

					// INICIALIZA ID DA PRIMEIRA GERENCIA
					if (idGerenciaAnterior == null) {
						idGerenciaAnterior = beanLoc.getIdGerenciaRegional();
					}

					if (idGerenciaAnterior.intValue() == beanLoc
							.getIdGerenciaRegional().intValue()) {
						retorno.add(beanLoc);
					} else {
						for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanGer : beansPorGerencia) {
							if (beanGer.getIdGerenciaRegional().intValue() == idGerenciaAnterior
									.intValue()) {
								retorno.add(beanGer);
							}
						}
						idGerenciaAnterior = beanLoc.getIdGerenciaRegional();
						retorno.add(beanLoc);
					}

					if (!iteraLocalidades.hasNext()) {
						for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanGer : beansPorGerencia) {
							if (beanGer.getIdGerenciaRegional().intValue() == idGerenciaAnterior
									.intValue()) {
								retorno.add(beanGer);
							}
						}
					}
				}
				for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanEst : beansPorEstado) {
					retorno.add(beanEst);
				}
				idUnidadeAnterior = null;
				idGerenciaAnterior = null;
				break;
			// Estado por Unidade de Negócio e por Localidade
			case 5:
				for (Iterator iteraLocalidades = beansPorLocalidade.iterator(); iteraLocalidades
						.hasNext();) {

					RelatorioResumoLigacoesCapacidadeHidrometroBean beanLoc = (RelatorioResumoLigacoesCapacidadeHidrometroBean) iteraLocalidades
							.next();

					// INICIALIZA ID DA PRIMEIRA UNIDADE
					if (idUnidadeAnterior == null) {
						idUnidadeAnterior = beanLoc.getIdUnidadeNegocio();
					}

					if (idUnidadeAnterior.intValue() == beanLoc
							.getIdUnidadeNegocio().intValue()) {
						retorno.add(beanLoc);
					} else {
						for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanUni : beansPorUnidade) {
							if (beanUni.getIdUnidadeNegocio().intValue() == idUnidadeAnterior
									.intValue()) {
								retorno.add(beanUni);
							}
						}
						idUnidadeAnterior = beanLoc.getIdUnidadeNegocio();
						retorno.add(beanLoc);
					}

					if (!iteraLocalidades.hasNext()) {
						for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanUni : beansPorUnidade) {
							if (beanUni.getIdUnidadeNegocio().intValue() == idUnidadeAnterior
									.intValue()) {
								retorno.add(beanUni);
							}
						}
					}
				}
				for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanEst : beansPorEstado) {
					retorno.add(beanEst);
				}
				idUnidadeAnterior = null;
				idGerenciaAnterior = null;
				break;
			// Gerência Regional
			case 6:
				retorno = beansPorGerencia;
				break;
			// Gerência Regional por Localidade
			case 7:
				for (Iterator iteraLocalidades = beansPorLocalidade.iterator(); iteraLocalidades
						.hasNext();) {

					RelatorioResumoLigacoesCapacidadeHidrometroBean beanLoc = (RelatorioResumoLigacoesCapacidadeHidrometroBean) iteraLocalidades
							.next();

					// INICIALIZA ID DA PRIMEIRA GERENCIA
					if (idGerenciaAnterior == null) {
						idGerenciaAnterior = beanLoc.getIdGerenciaRegional();
					}

					if (idGerenciaAnterior.intValue() == beanLoc
							.getIdGerenciaRegional().intValue()) {
						retorno.add(beanLoc);
					} else {
						for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanGer : beansPorGerencia) {
							if (beanGer.getIdGerenciaRegional().intValue() == idGerenciaAnterior
									.intValue()) {
								retorno.add(beanGer);
							}
						}
						idGerenciaAnterior = beanLoc.getIdGerenciaRegional();
						retorno.add(beanLoc);
					}

					if (!iteraLocalidades.hasNext()) {
						for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanGer : beansPorGerencia) {
							if (beanGer.getIdGerenciaRegional().intValue() == idGerenciaAnterior
									.intValue()) {
								retorno.add(beanGer);
							}
						}
					}
				}
				idUnidadeAnterior = null;
				idGerenciaAnterior = null;
				break;
			// Unidade de Negócio
			case 8:
				retorno = beansPorUnidade;
				break;
			// Unidade de Negócio por Localidade
			case 9:
				for (Iterator iteraLocalidades = beansPorLocalidade.iterator(); iteraLocalidades
						.hasNext();) {

					RelatorioResumoLigacoesCapacidadeHidrometroBean beanLoc = (RelatorioResumoLigacoesCapacidadeHidrometroBean) iteraLocalidades
							.next();

					// INICIALIZA ID DA PRIMEIRA UNIDADE
					if (idUnidadeAnterior == null) {
						idUnidadeAnterior = beanLoc.getIdUnidadeNegocio();
					}

					if (idUnidadeAnterior.intValue() == beanLoc
							.getIdUnidadeNegocio().intValue()) {
						retorno.add(beanLoc);
					} else {
						for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanUni : beansPorUnidade) {
							if (beanUni.getIdUnidadeNegocio().intValue() == idUnidadeAnterior
									.intValue()) {
								retorno.add(beanUni);
							}
						}
						idUnidadeAnterior = beanLoc.getIdUnidadeNegocio();
						retorno.add(beanLoc);
					}

					if (!iteraLocalidades.hasNext()) {
						for (RelatorioResumoLigacoesCapacidadeHidrometroBean beanUni : beansPorUnidade) {
							if (beanUni.getIdUnidadeNegocio().intValue() == idUnidadeAnterior
									.intValue()) {
								retorno.add(beanUni);
							}
						}
					}
				}
				idUnidadeAnterior = null;
				idGerenciaAnterior = null;
				break;
			// Localidade
			case 10:
				retorno = beansPorLocalidade;
				break;
			default:
				break;
			}
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC0997] Gerar Resumo de Ligações por Capacidade de Hidrômetro.
	 * 
	 * @author Hugo Leonardo
	 * @date 30/03/2010
	 * 
	 * @param RelatorioResumoLigacoesCapacidadeHidrometroHelper
	 * 
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer countRelatorioResumoLigacoesCapacidadeHidrometro(
			RelatorioResumoLigacoesCapacidadeHidrometroHelper helper)
			throws ControladorException {

		try {
			return this.repositorioMicromedicao
					.countRelatorioResumoLigacoesCapacidadeHidrometro(helper);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * [UC0091] Alterar Dados para Faturamento
	 * 
	 * [FS0015] Verificar Imóvel Impressão Simultânea
	 * 
	 * @author Hugo Amorim
	 * @date 08/04/2010
	 */
	public boolean verificarExistenciaArquivoDeImpressao(Integer idImovel,
			Integer tipoMedicao) throws ControladorException {

		try {
			return this.repositorioMicromedicao
					.verificarExistenciaArquivoDeImpressao(idImovel,
							tipoMedicao);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Pesquisa os dados de Medição e Consumo Historico da ligação de Esgoto do
	 * imóvel.
	 * 
	 * @author Arthur Carvalho
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public Collection carregarDadosMedicaoConsumoHistoricoLigacaoEsgoto(
			Integer idImovel) throws ControladorException {

		Collection resultadoPesquisa = null;
		Collection retorno = null;

		try {

			resultadoPesquisa = repositorioMicromedicao
					.carregarDadosMedicaoConsumoHistoricoLigacaoEsgoto(idImovel);

			if (resultadoPesquisa != null && !resultadoPesquisa.isEmpty()) {
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				MedicaoHistorico medicaoHistorico = null;
				ConsumoHistorico consumoHistorico = null;
				ConsumoAnormalidade consumoAnormalidade = null;
				Object[] objetoMedicao = null;
				LeituraAnormalidade leituraAnormalidadeInformada = null;
				LeituraAnormalidade leituraAnormalidadeFaturada = null;
				LeituraSituacao leituraSituacao = null;
				RelatorioHistoricoMedicaoPocoHelper helper = null;
				while (iterator.hasNext()) {
					objetoMedicao = (Object[]) iterator.next();
					helper = new RelatorioHistoricoMedicaoPocoHelper();
					medicaoHistorico = new MedicaoHistorico();

					if (objetoMedicao[0] != null) {
						medicaoHistorico
								.setAnoMesReferencia(((Integer) objetoMedicao[0])
										.intValue());
					}

					if (objetoMedicao[1] != null) {
						medicaoHistorico
								.setDataLeituraAtualInformada((Date) objetoMedicao[1]);
					}

					if (objetoMedicao[2] != null) {
						medicaoHistorico
								.setLeituraAtualInformada((Integer) objetoMedicao[2]);
					}

					if (objetoMedicao[3] != null) {
						medicaoHistorico
								.setDataLeituraAtualFaturamento((Date) objetoMedicao[3]);
					}

					if (objetoMedicao[4] != null) {
						medicaoHistorico
								.setLeituraAtualFaturamento((Integer) objetoMedicao[4]);
					}
					// Leitura Anormalidade Informada
					leituraAnormalidadeInformada = new LeituraAnormalidade();
					if (objetoMedicao[9] != null) {
						leituraAnormalidadeInformada
								.setId((Integer) objetoMedicao[9]);
					}

					if (objetoMedicao[5] != null) {
						leituraAnormalidadeInformada
								.setDescricao((String) objetoMedicao[5]);
					}

					if (leituraAnormalidadeInformada != null) {
						medicaoHistorico
								.setLeituraAnormalidadeInformada(leituraAnormalidadeInformada);
					}
					// Leitura Anormalidade Faturada
					leituraAnormalidadeFaturada = new LeituraAnormalidade();
					if (objetoMedicao[10] != null) {
						leituraAnormalidadeFaturada
								.setId((Integer) objetoMedicao[10]);
					}

					if (objetoMedicao[6] != null) {
						leituraAnormalidadeFaturada
								.setDescricao((String) objetoMedicao[6]);
					}

					if (leituraAnormalidadeFaturada != null) {
						medicaoHistorico
								.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturada);
					}
					// Leitura Situação
					leituraSituacao = new LeituraSituacao();

					if (objetoMedicao[7] != null) {
						leituraSituacao.setDescricao((String) objetoMedicao[7]);
					}

					if (leituraSituacao != null) {
						medicaoHistorico
								.setLeituraSituacaoAtual(leituraSituacao);
					}

					if (objetoMedicao[8] != null) {
						medicaoHistorico
								.setConsumoMedioHidrometro((Integer) objetoMedicao[8]);
					}
					consumoHistorico = new ConsumoHistorico();
					if (objetoMedicao[12] != null) {
						consumoHistorico
								.setConsumoMedio((Integer) objetoMedicao[12]);
					}
					consumoAnormalidade = new ConsumoAnormalidade();
					if (objetoMedicao[13] != null) {
						consumoAnormalidade
								.setDescricaoAbreviada((String) objetoMedicao[13]);
					}

					helper.setMedicaoHistorico(medicaoHistorico);
					helper.setConsumoAnormalidade(consumoAnormalidade);
					helper.setConsumoHistorico(consumoHistorico);

					retorno.add(helper);
				}
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * [UC1022] Relatório de Notificação de Débitos para Impressão Simultânea
	 * 
	 * @author Daniel Alves
	 * @date 19/05/2010
	 */
	public Collection pesquisarNotificacaoDebitosImpressaoSimultanea(
			RelatorioNotificacaoDebitosImpressaoSimultaneaHelper filtro)
			throws ControladorException {

		try {
			return this.repositorioMicromedicao
					.pesquisarNotificacaoDebitosImpressaoSimultanea(filtro);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Pesquisa capacidade do hidrometro
	 * 
	 * @author Arthur Carvalho
	 * @date 17/06/2010
	 */
	public HidrometroCapacidade pesquisarCapacidadeHidrometro(
			String numeroHidrometro) throws ControladorException {

		try {
			return this.repositorioMicromedicao
					.pesquisarCapacidadeHidrometro(numeroHidrometro);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * UC1027 - Exibir Consultar Arquivo Texto Leitura Divisão.
	 * 
	 * @author Hugo Leonardo
	 * @created 04/06/2010
	 * 
	 * @param idArquivoTextoRoteiroEmpresaDivisao
	 * @param situacaoNova
	 * @throws ControladorException
	 */
	public void atualizarArquivoTextoDivisaoEnviado(
			Integer idArquivoTextoRoteiroEmpresaDivisao, int situacaoNova)
			throws ControladorException {

		try {
			this.repositorioMicromedicao.atualizarArquivoTextoDivisaoEnviado(
					idArquivoTextoRoteiroEmpresaDivisao, situacaoNova);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * UC1027 - Exibir Consultar Arquivo Texto Leitura Divisão.
	 * 
	 * @author Hugo Leonardo
	 * @created 04/06/2010
	 * 
	 * @param ids
	 * @param situacaoNova
	 * @throws ControladorException
	 */
	public void atualizarListaArquivoTextoDivisao(Vector<Integer> ids,
			Integer situacaoNova) throws ControladorException {

		if (ids == null || ids.size() == 0) {
			throw new ControladorException("atencao.nenhum_arquivo_selecionado");
		}

		Iterator<Integer> it = ids.iterator();
		try {

			while (it.hasNext()) {
				Integer id = it.next();

				FiltroArquivoTextoRoteiroEmpresaDivisao filtro = new FiltroArquivoTextoRoteiroEmpresaDivisao();
				filtro.adicionarParametro(new ParametroSimples(
						FiltroArquivoTextoRoteiroEmpresaDivisao.ID, id
								.intValue()));
				Collection<ArquivoTextoRoteiroEmpresaDivisao> colFiltro = this
						.getControladorUtil().pesquisar(
								filtro,
								ArquivoTextoRoteiroEmpresaDivisao.class
										.getName());

				ArquivoTextoRoteiroEmpresaDivisao arquivo = (ArquivoTextoRoteiroEmpresaDivisao) Util
						.retonarObjetoDeColecao(colFiltro);

				if (situacaoNova.equals(SituacaoTransmissaoLeitura.LIBERADO)) {
					// Caso exista algum arquivo texto com situação de liberado
					// para o mesmo
					// leiturista que o usuário está tentando liberar, o sistema
					// não irá permitir
					Object[] dadosArquivoLiberado = verificarExistenciaArquivoLiberado(
							id, true);
					if (dadosArquivoLiberado == null
							|| dadosArquivoLiberado.length == 0) {
						this.repositorioMicromedicao
								.atualizarArquivoTextoDivisao(id, situacaoNova);
					} else {
						sessionContext.setRollbackOnly();
						throw new ControladorException(
								"atencao.arquivo_nao_pode_liberar",
								null,
								Util.formatarAnoMesParaMesAno((Integer) dadosArquivoLiberado[0]),
								"" + dadosArquivoLiberado[1]);
					}
				} else if (situacaoNova
						.equals(SituacaoTransmissaoLeitura.EM_CAMPO)) {

					if (arquivo.getSituacaoTransmissaoLeitura().getId()
							.intValue() != SituacaoTransmissaoLeitura.DISPONIVEL
							&& arquivo.getSituacaoTransmissaoLeitura().getId()
									.intValue() != SituacaoTransmissaoLeitura.LIBERADO) {
						throw new ControladorException(
								"atencao.arquivo_nao_pode_em_campo");
					}

				} else if (situacaoNova
						.equals(SituacaoTransmissaoLeitura.FINALIZADO_USUARIO)) {

					if (arquivo.getSituacaoTransmissaoLeitura().getId()
							.intValue() != SituacaoTransmissaoLeitura.EM_CAMPO) {
						throw new ControladorException(
								"atencao.arquivo_nao_pode_finalizar");
					}

				} else if (situacaoNova
						.equals(SituacaoTransmissaoLeitura.DISPONIVEL)) {

					if (arquivo.getSituacaoTransmissaoLeitura().getId()
							.intValue() != SituacaoTransmissaoLeitura.DISPONIVEL
							&& arquivo.getSituacaoTransmissaoLeitura().getId()
									.intValue() != SituacaoTransmissaoLeitura.LIBERADO
							&& arquivo.getSituacaoTransmissaoLeitura().getId()
									.intValue() != SituacaoTransmissaoLeitura.EM_CAMPO) {
						throw new ControladorException(
								"atencao.arquivo_nao_pode_dispobilizar");
					}
				}
			}

			for (Integer id : ids) {

				FiltroArquivoTextoRoteiroEmpresaDivisao filtro = new FiltroArquivoTextoRoteiroEmpresaDivisao();
				filtro.adicionarParametro(new ParametroSimples(
						FiltroArquivoTextoRoteiroEmpresaDivisao.ID, id
								.intValue()));
				Collection<ArquivoTextoRoteiroEmpresaDivisao> colFiltro = this
						.getControladorUtil().pesquisar(
								filtro,
								ArquivoTextoRoteiroEmpresaDivisao.class
										.getName());

				ArquivoTextoRoteiroEmpresaDivisao arquivo = (ArquivoTextoRoteiroEmpresaDivisao) Util
						.retonarObjetoDeColecao(colFiltro);

				SituacaoTransmissaoLeitura situacao = new SituacaoTransmissaoLeitura();
				situacao.setId(situacaoNova);

				arquivo.setSituacaoTransmissaoLeitura(situacao);
				repositorioUtil.atualizar(arquivo);
			}

		} catch (ErroRepositorioException ex) {

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * Obter rota do imóvel através do código da rota do sequencial e da
	 * localidade .
	 * 
	 * @author Breno Santos
	 * @date 13/08/2010
	 * 
	 * @param codRota
	 *            , sequencial, localidade
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	public Integer obterIdRotaPorSetorComercialELocalidade(Integer codRota,
			Integer setorComercial, Integer localidade)
			throws ControladorException {

		Integer idRota = null;
		try {
			idRota = repositorioMicromedicao
					.obterIdRotaDeMovimentoRotEmpresaPelaLocalidade(codRota,
							setorComercial, localidade);
			/*
			 * if(idRota == null || idRota.equals("")){ idRota =
			 * repositorioMicromedicao
			 * .obterIdRotaPorSetorComercialELocalidade(codRota, setorComercial,
			 * localidade); }
			 */

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
		return idRota;
	}

	/**
	 * Pesquisa Dados do Contrato Empresa Servico [UC1055] - Informar Valor de
	 * Item de Serviço Por Contrato
	 * 
	 * @author Hugo Leonardo, Mariana Victor
	 * @date 30/07/2010, 25/11/2010
	 * 
	 * @param idEmpresa
	 * 
	 * @return List<InformarItensContratoServicoHelper>
	 */
	public List<InformarItensContratoServicoHelper> obterDadosItensContratoServico(
			Integer idEmpresa) throws ControladorException {

		List<InformarItensContratoServicoHelper> retorno = null;

		Collection resultadoPesquisa = null;

		FiltroContratoEmpresaServico filtroContratoEmpresaServico = new FiltroContratoEmpresaServico();

		filtroContratoEmpresaServico.adicionarParametro(new ParametroSimples(
				FiltroContratoEmpresaServico.EMPRESA, idEmpresa));
		filtroContratoEmpresaServico
				.adicionarCaminhoParaCarregamentoEntidade(FiltroContratoEmpresaServico.ITEM_SERVICO_CONTRATOS);

		filtroContratoEmpresaServico
				.setCampoOrderBy(FiltroContratoEmpresaServico.DESCRICAO);

		// Procura Contrato Empresa Servico na base
		resultadoPesquisa = getControladorUtil().pesquisar(
				filtroContratoEmpresaServico,
				ContratoEmpresaServico.class.getName());

		if (resultadoPesquisa != null && !resultadoPesquisa.isEmpty()) {

			Iterator iterator = resultadoPesquisa.iterator();

			InformarItensContratoServicoHelper helper = null;
			ContratoEmpresaServico contratoEmpresaServico = null;

			retorno = new ArrayList<InformarItensContratoServicoHelper>();

			while (iterator.hasNext()) {
				Collection resultadoPesquisa2 = null;
				Collection resultadoPesquisa3 = null;

				contratoEmpresaServico = (ContratoEmpresaServico) iterator
						.next();

				helper = new InformarItensContratoServicoHelper();

				Integer idContratoEmpresaServico = contratoEmpresaServico
						.getId();

				FiltroItemServicoContrato filtroItemServicoContrato = new FiltroItemServicoContrato();
				filtroItemServicoContrato
						.adicionarParametro(new ParametroSimples(
								FiltroItemServicoContrato.CONTRATO_EMPRESA_SERVICO,
								idContratoEmpresaServico));

				filtroItemServicoContrato
						.adicionarCaminhoParaCarregamentoEntidade(FiltroItemServicoContrato.ITEM_SERVICO);

				filtroItemServicoContrato
						.setCampoOrderBy(FiltroItemServicoContrato.CONTRATO_EMPRESA_SERVICO);
				filtroItemServicoContrato
						.setCampoOrderBy(FiltroItemServicoContrato.ITEM_SERVICO);

				// Procura Contrato Empresa Servico na base
				resultadoPesquisa2 = getControladorUtil().pesquisar(
						filtroItemServicoContrato,
						ItemServicoContrato.class.getName());

				helper.setContratoEmpresaServico(contratoEmpresaServico);

				FiltroContratoEmpresaAditivo filtroContratoEmpresaAditivo = new FiltroContratoEmpresaAditivo();
				filtroContratoEmpresaAditivo
						.adicionarParametro(new ParametroSimples(
								FiltroContratoEmpresaAditivo.CONTRATO_EMPRESA_SERVICO,
								contratoEmpresaServico));
				resultadoPesquisa3 = getControladorUtil().pesquisar(
						filtroContratoEmpresaAditivo,
						ContratoEmpresaAditivo.class.getName());

				if (resultadoPesquisa2 != null && !resultadoPesquisa2.isEmpty()) {

					helper.setItemServicoContrato((List<ItemServicoContrato>) resultadoPesquisa2);
				}

				if (resultadoPesquisa3 != null && !resultadoPesquisa3.isEmpty()) {

					helper.setContratoEmpresaAditivo((List<ContratoEmpresaAditivo>) resultadoPesquisa3);
				}

				retorno.add(helper);
			}
		}

		return retorno;
	}

	/**
	 * Remover todos os Itens de Servico do Contrato [UC1055] - Informar Valor
	 * de Item de Serviço Por Contrato
	 * 
	 * @author Hugo Leonardo
	 * @date 03/08/2010
	 * 
	 * @param idContratoEmpresaServico
	 * @return void
	 */
	public void removerItemServicoDoContrato(Integer idContratoEmpresaServico,
			Usuario usuarioLogado) throws ControladorException {

		Collection resultadoPesquisa = null;

		try {

			FiltroItemServicoContrato filtro = new FiltroItemServicoContrato();

			filtro.adicionarParametro(new ParametroSimples(
					FiltroItemServicoContrato.CONTRATO_EMPRESA_SERVICO,
					idContratoEmpresaServico));

			filtro.adicionarCaminhoParaCarregamentoEntidade(FiltroItemServicoContrato.CONTRATO_EMPRESA_SERVICO);

			// Procura Item Servic Contrato na base
			resultadoPesquisa = getControladorUtil().pesquisar(filtro,
					ItemServicoContrato.class.getName());

			if (resultadoPesquisa != null && !resultadoPesquisa.isEmpty()) {

				Iterator iterator = resultadoPesquisa.iterator();

				ItemServicoContrato itemServicoContrato = null;

				while (iterator.hasNext()) {

					itemServicoContrato = (ItemServicoContrato) iterator.next();

					// ------------ REGISTRAR TRANSAÇÃO ----------------
					RegistradorOperacao registradorOperacaoItemServicoContrato = new RegistradorOperacao(
							Operacao.OPERACAO_INFORMAR_ITEM_SERVICO_CONTRATO,
							itemServicoContrato.getContratoEmpresaServico()
									.getId(), itemServicoContrato
									.getContratoEmpresaServico().getId(),
							new UsuarioAcaoUsuarioHelper(usuarioLogado,
									UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
					// ------------ REGISTRAR TRANSAÇÃO ----------------
					registradorOperacaoItemServicoContrato
							.registrarOperacao(itemServicoContrato);

					this.repositorioUtil.remover(itemServicoContrato);
				}
			}

			// this.repositorioMicromedicao.removerItemServicoDoContrato(idContratoEmpresaServico);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Remover todos os Aditivos do Contrato [UC1055] - Informar Valor de Item
	 * de Serviço Por Contrato
	 * 
	 * @author Mariana Victor
	 * @date 25/11/2010
	 * 
	 * @param idContratoEmpresaServico
	 * @return void
	 */
	public void removerAditivosDoContrato(Integer idContratoEmpresaServico)
			throws ControladorException {

		Collection resultadoPesquisa = null;

		try {

			FiltroContratoEmpresaAditivo filtro = new FiltroContratoEmpresaAditivo();

			filtro.adicionarParametro(new ParametroSimples(
					FiltroContratoEmpresaAditivo.CONTRATO_EMPRESA_SERVICO,
					idContratoEmpresaServico));

			filtro.adicionarCaminhoParaCarregamentoEntidade(FiltroContratoEmpresaAditivo.CONTRATO_EMPRESA_SERVICO);

			resultadoPesquisa = getControladorUtil().pesquisar(filtro,
					ContratoEmpresaAditivo.class.getName());

			if (resultadoPesquisa != null && !resultadoPesquisa.isEmpty()) {

				Iterator iterator = resultadoPesquisa.iterator();

				ContratoEmpresaAditivo contratoEmpresaAditivo = null;

				while (iterator.hasNext()) {

					contratoEmpresaAditivo = (ContratoEmpresaAditivo) iterator
							.next();

					this.repositorioUtil.remover(contratoEmpresaAditivo);
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC1054] - Gerar Relatório Boletim de Medição
	 * 
	 * @author Hugo Leonardo
	 * @date 05/08/2010
	 * 
	 * @param FiltrarRelatorioBoletimMedicaoHelper
	 * @return Collection<RelatorioBoletimMedicaoHelper>
	 * @throws ControladorException
	 */
	public Collection pesquisarRelatorioBoletimMedicao(
			FiltrarRelatorioBoletimMedicaoHelper helper)
			throws ControladorException {

		Collection colecaoRetorno = new ArrayList();
		try {

			Collection colecaoBoletimMedicao = this.repositorioMicromedicao
					.pesquisarRelatorioBoletimMedicao(helper);

			Iterator iterator = colecaoBoletimMedicao.iterator();

			while (iterator.hasNext()) {

				RelatorioBoletimMedicaoHelper relatorioHelper = new RelatorioBoletimMedicaoHelper();

				Object[] objeto = (Object[]) iterator.next();

				// Gerência Regional
				String gerenciaRegional = "";
				if (objeto[0] != null) {
					gerenciaRegional = objeto[0].toString();

					relatorioHelper.setGerenciaRegional(gerenciaRegional);
				}

				// Empresa
				String empresa = "";
				if (objeto[1] != null) {
					empresa = objeto[1].toString();

					relatorioHelper.setEmpresa(empresa);
				}

				// Número Contrato
				String numeroContrato = "";
				if (objeto[2] != null) {
					numeroContrato = objeto[2].toString();

					relatorioHelper.setNumeroContrato(numeroContrato);
				}

				// Localidade
				String localidade = "";
				if (objeto[3] != null) {
					localidade = objeto[3].toString();

					relatorioHelper.setLocalidade(localidade);
				}

				// Código Item
				String itemCodigo = "";
				if (objeto[4] != null) {
					itemCodigo = objeto[4].toString();

					relatorioHelper.setItemCodigo(itemCodigo);
				}

				// Item Descrição
				String itemDescricao = "";
				if (objeto[5] != null) {
					itemDescricao = objeto[5].toString();

					relatorioHelper.setItemDescricao(itemDescricao);
				}

				// Quantidade
				Integer soma = 0;
				if (objeto[6] != null) {
					soma = (Integer) objeto[6];

					relatorioHelper.setQuantidade(soma);
				}

				// valor
				BigDecimal valor = new BigDecimal("0");
				if (objeto[7] != null) {
					valor = (BigDecimal) objeto[7];

					relatorioHelper.setValor(valor);
				}

				colecaoRetorno.add(relatorioHelper);
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoRetorno;
	}

	/**
	 * [UC1054] - Gerar Relatório Boletim de Medição
	 * 
	 * @author Hugo Leonardo
	 * @date 06/08/2010
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarEmpresasContratoServico()
			throws ControladorException {

		Collection<Empresa> colecaoRetorno = new ArrayList();

		try {

			Collection colecaoEmpresas = this.repositorioMicromedicao
					.pesquisarEmpresasContratoServico();

			Iterator iterator = colecaoEmpresas.iterator();
			Empresa empresa = null;

			while (iterator.hasNext()) {

				empresa = (Empresa) iterator.next();
				colecaoRetorno.add(empresa);
			}

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return colecaoRetorno;
	}

	/**
	 * 
	 * [UC0629] Consultar Arquivo Texto para Leitura
	 * 
	 * [FS0011 - Verificar Leituras];
	 * 
	 * @author Hugo Amorim
	 * @date 20/08/2010
	 */
	public SituacaoLeituraHelper pesquisarSituacaoLeitura(Integer anoMes,
			Integer idGrupo, Integer idRota) throws ControladorException {

		Object[] retorno = null;
		SituacaoLeituraHelper helper = null;
		try {

			Collection retornoConsuta = repositorioMicromedicao
					.pesquisarSituacaoLeitura(anoMes, idGrupo, idRota);

			if (!Util.isVazioOrNulo(retornoConsuta)) {

				retorno = (Object[]) retornoConsuta.iterator().next();

				if (retorno != null) {
					helper = new SituacaoLeituraHelper(
							retorno[0] != null ? ((Integer) retorno[0]).toString()
									: "",
							retorno[1] != null ? ((Integer) retorno[1])
									.toString() : "",
							retorno[2] != null ? ((Integer) retorno[2])
									.toString() : "",
							retorno[3] != null ? ((Integer) retorno[3])
									.toString() : "",
							retorno[4] != null ? ((Integer) retorno[4])
									.toString() : "",
							retorno[5] != null ? ((Integer) retorno[5])
									.toString() : "",
							retorno[6] != null ? ((Integer) retorno[6])
									.toString() : "",
							retorno[7] != null ? ((Integer) retorno[7])
									.toString() : "",
							retorno[8] != null ? ((Integer) retorno[8])
									.toString() : "",
							retorno[9] != null ? ((Integer) retorno[9])
									.toString() : "",
							retorno[10] != null ? (String) retorno[10] : "",
							retorno[11] != null ? ((Integer) retorno[11])
									.toString() : "");
				}
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return helper;

	}

	/**
	 * 
	 * Verifica se uma rota em questão está com os arquivos de impressão
	 * simultanea divididos
	 * 
	 * @autor Bruno Barros.
	 * @date 26/08/2010
	 * 
	 * @param idRota
	 *            - Id da rota a ser pesquisada
	 * 
	 * @return boolean - A rota está dividida
	 */
	public boolean isRotaDividida(Integer idRota, Integer anoMesFaturamento)
			throws ControladorException {
		try {

			return repositorioMicromedicao.isRotaDividida(idRota,
					anoMesFaturamento);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * Verifica se uma rota em questão está com os arquivos de impressão
	 * simultanea divididos com a situação diferente da situação enviada como
	 * parâmetro
	 * 
	 * @autor Sávio Luiz.
	 * @date 30/09/2010
	 * 
	 * @param idRota
	 *            - Id da rota a ser pesquisada
	 * 
	 * @return boolean - A rota está dividida
	 */
	public boolean verificarExistenciaArquivosDivididosSituacaoDiferente(
			Integer idRota, Integer anoMesFaturamento,
			Integer[] idsSituacaoTransmissao) throws ControladorException {
		try {

			return repositorioMicromedicao
					.verificarExistenciaArquivosDivididosSituacaoDiferente(
							idRota, anoMesFaturamento, idsSituacaoTransmissao);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Verifica de imovel é medido ou não-medido
	 * 
	 * retorna true se medido false se não-medido
	 * 
	 * @author Hugo Amorim
	 * @date 26/08/2010
	 */
	public boolean verificarSituacaoMedicao(Integer idImovel)
			throws ControladorException {
		try {

			return repositorioMicromedicao.verificarSituacaoMedicao(idImovel);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC1004] Processar Leitura via Telemetria
	 * 
	 * @author Raphael Rossiter
	 * @date 27/09/2010
	 * 
	 * @param dadosTelemetria
	 * @return TelemetriaLog
	 */
	public TelemetriaLog processarLeituraViaTelemetria(String dadosTelemetria)
			throws ControladorException {

		TelemetriaLog telemetriaLog = new TelemetriaLog();

		try {

			// 2. O sistema efetua a consistência dos dados a partir dos
			// seguintes procedimentos:

			// 2.1. O sistema grava os dados recebidos na tabela TELEMETRIA_LOG
			// com os seguintes dados:
			telemetriaLog.setConteudoStringEnviada(dadosTelemetria);
			telemetriaLog.setRecepcao(new Date());
			telemetriaLog.setUltimaAlteracao(new Date());

			// INSERINDO TELEMETRIA LOG NA BASE
			Integer idTelemetriaLog = (Integer) this.getControladorUtil()
					.inserir(telemetriaLog);
			telemetriaLog.setId(idTelemetriaLog);

			/*
			 * 2.2. Distribui os dados da string enviada (TLOG_CNSTRINGENVIADA)
			 * correspondentes às informações gerais.
			 * 
			 * 2.3. Valida as informações gerais [SB0001  Validar Informações
			 * Gerais].
			 */
			TelemetriaInformacoesGeraisHelper telemetriaInformacoesGeraisHelper = this
					.telemetriaValidarInformacoesGerais(dadosTelemetria);

			if (telemetriaInformacoesGeraisHelper.getTelemetriaRetMot() == null) {

				// 2.4. Grava as informações gerais na tabela TELEMETRIA_MOV
				TelemetriaMov telemetriaMov = new TelemetriaMov();

				telemetriaMov.setTelemetriaLog(telemetriaLog);
				telemetriaMov
						.setQuantidadeConsumidores(telemetriaInformacoesGeraisHelper
								.getQuantidadeConsumidores());
				telemetriaMov.setEnvio(telemetriaInformacoesGeraisHelper
						.getEnvio());
				telemetriaMov
						.setCodigoEmpresa(telemetriaInformacoesGeraisHelper
								.getCodigoEmpresa());
				telemetriaMov
						.setIndicadorConsistenciaLeit(ConstantesSistema.NAO);
				telemetriaMov.setUltimaAlteracao(new Date());

				// INSERINDO TELEMETRIA MOV NA BASE
				Integer idTelemetriaMov = (Integer) this.getControladorUtil()
						.inserir(telemetriaMov);
				telemetriaMov.setId(idTelemetriaMov);

				/*
				 * 2.5. A cada asterisco (*) encontrado na string enviada
				 * (TLOG_CNSTRINGENVIADA), partindo da posição atual mais um:
				 * 
				 * 2.5.1. Distribui os dados da string enviada
				 * (TLOG_CNSTRINGENVIADA) correspondente às leituras.
				 * 
				 * 2.5.2. Valida os dados da leitura [SB0002  Validar Dados
				 * Leitura].
				 */
				TelemetriaDadosLeituraHelper telemetriaDadosLeituraHelper = this
						.telemetriaValidarDadosLeitura(dadosTelemetria);

				if (telemetriaDadosLeituraHelper.getTelemetriaRetMot() == null) {

					Collection<TelemetriaMovReg> colecaoTelemetriaMovReg = telemetriaDadosLeituraHelper
							.getColecaoTelemetriaMovReg();

					// 2.6. Valida a quantidade de consumidores [SB0003 
					// Validar Quantidade Consumidores].
					TelemetriaRetMot telemetriaRetMot = this
							.telemetriaValidarQuantidadeConsumidores(
									telemetriaMov, colecaoTelemetriaMovReg);

					if (telemetriaRetMot == null) {

						Date dataAtual = new Date();

						// 2.5.3. Grava as informações da leitura na tabela
						// TELEMETRIA_MOV_REG
						Iterator it = colecaoTelemetriaMovReg.iterator();

						while (it.hasNext()) {

							TelemetriaMovReg telemetriaMovReg = (TelemetriaMovReg) it
									.next();

							telemetriaMovReg.setTelemetriaMov(telemetriaMov);
							telemetriaMovReg.setUltimaAlteracao(new Date());

							// INSERINDO TELEMETRIA MOV REG NA BASE
							this.getControladorUtil().inserir(telemetriaMovReg);

							// INICIO CONSISTIR
							boolean flagConsistiu = this
									.consistirLeituraTelemetria(telemetriaMovReg);

							if (flagConsistiu) {

								telemetriaMovReg
										.setIndicadorProcessado(ConstantesSistema.SIM);
								telemetriaMovReg.setUltimaAlteracao(dataAtual);

								this.getControladorUtil().atualizar(
										telemetriaMovReg);

							}
							// FIM CONSISTIR
						}

						// ATUALIZANDO O LOG COM O MOTIVO DA REJEIÇÃO IGUAL A
						// TRANSMISSAO EFETUADA COM SUCESSO
						FiltroTelemetriaRetMot filtroTelemetriaRetMot = new FiltroTelemetriaRetMot();

						filtroTelemetriaRetMot
								.adicionarParametro(new ParametroSimples(
										FiltroTelemetriaRetMot.INDICADOR_MOV_ACEITO,
										ConstantesSistema.SIM));

						Collection colecaoTelemetriaRetMot = this
								.getControladorUtil().pesquisar(
										filtroTelemetriaRetMot,
										TelemetriaRetMot.class.getName());

						telemetriaRetMot = (TelemetriaRetMot) Util
								.retonarObjetoDeColecao(colecaoTelemetriaRetMot);

						telemetriaLog.setTelemetriaRetMot(telemetriaRetMot);
						this.atualizarTelemtriaLogMovimentoRejeitado(telemetriaLog);

						telemetriaMov
								.setIndicadorConsistenciaLeit(ConstantesSistema.SIM);
						telemetriaMov.setUltimaAlteracao(dataAtual);

						this.getControladorUtil().atualizar(telemetriaMov);
					} else {

						// ATUALIZANDO O LOG COM O MOTIVO DA REJEIÇÃO
						telemetriaLog.setTelemetriaRetMot(telemetriaRetMot);
						this.atualizarTelemtriaLogMovimentoRejeitado(telemetriaLog);

						// [SB0009]  Encerrar Processo Telemetria
						this.getControladorUtil().remover(telemetriaMov);
					}
				} else {

					// ATUALIZANDO O LOG COM O MOTIVO DA REJEIÇÃO
					telemetriaLog
							.setTelemetriaRetMot(telemetriaDadosLeituraHelper
									.getTelemetriaRetMot());
					this.atualizarTelemtriaLogMovimentoRejeitado(telemetriaLog);

					// [SB0009]  Encerrar Processo Telemetria
					this.getControladorUtil().remover(telemetriaMov);
				}
			} else {

				// ATUALIZANDO O LOG COM O MOTIVO DA REJEIÇÃO
				telemetriaLog
						.setTelemetriaRetMot(telemetriaInformacoesGeraisHelper
								.getTelemetriaRetMot());
				this.atualizarTelemtriaLogMovimentoRejeitado(telemetriaLog);
			}
		} catch (Exception e) {

			/*
			 * COLOCADO PARA VERIFICAR SE JÁ FOI DADO ROLLBACK
			 */
			if (!sessionContext.getRollbackOnly()) {
				sessionContext.setRollbackOnly();
			}

			e.printStackTrace();
		}

		return telemetriaLog;
	}

	/**
	 * [UC1004] Processar Leitura via Telemetria
	 * 
	 * @author Raphael Rossiter
	 * @date 27/09/2010
	 * 
	 * @param telemetriaLog
	 * @throws ControladorException
	 */
	public void atualizarTelemtriaLogMovimentoRejeitado(
			TelemetriaLog telemetriaLog) throws ControladorException {

		try {

			this.repositorioMicromedicao
					.atualizarTelemtriaLogMovimentoRejeitado(telemetriaLog);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC1004] Processar Leitura via Telemetria
	 * 
	 * [SB0001]  Validar Informações Gerais
	 * 
	 * @author Raphael Rossiter
	 * @date 03/09/2010
	 * 
	 * @param dadosTelemetria
	 * @return TelemetriaInformacoesGeraisHelper
	 */
	public TelemetriaInformacoesGeraisHelper telemetriaValidarInformacoesGerais(
			String dadosTelemetria) {

		TelemetriaInformacoesGeraisHelper telemetriaInformacoesGeraisHelper = new TelemetriaInformacoesGeraisHelper();

		String[] dadosParticionados = dadosTelemetria.split("\\*");

		TelemetriaRetMot telemetriaRetMot = null;

		Integer quantidadeConsumidores = null;
		Date dataEnvio = null;
		Integer codigoEmpresa = null;

		// 1.1. Caso a quantidade de consumidores (campo T.01) não seja um campo
		// numérico, rejeitar os dados recebidos
		if (Util.validarValorNaoNumerico((String) dadosParticionados[0])) {

			telemetriaRetMot = new TelemetriaRetMot();
			telemetriaRetMot.setId(TelemetriaRetMot.ID_QUANTIDADE_INVALIDA);
		} else {

			quantidadeConsumidores = Integer.parseInt(dadosParticionados[0]);
		}

		/*
		 * 1.2. Caso a data/hora de envio (campo T.02  formato AAAA-MM-DD
		 * hh:mm:ss) não corresponda a uma data/hora válida, rejeitar os dados
		 * recebidos:
		 */
		if (telemetriaRetMot == null) {

			if (Util.validarDataInvalida((String) dadosParticionados[1],
					"yyyy-MM-dd")) {

				telemetriaRetMot = new TelemetriaRetMot();
				telemetriaRetMot.setId(TelemetriaRetMot.ID_DATA_ENVIO_INVALIDA);
			} else {

				dataEnvio = Util.converteStringParaDateHora(
						(String) dadosParticionados[1], "yyyy-MM-dd");
			}
		}

		// 1.3. Caso a empresa (campo T.03) não seja um campo numérico, rejeitar
		// os dados recebidos:
		if (telemetriaRetMot == null) {

			codigoEmpresa = ConstantesSistema.SIM.intValue();

			// if (Util.validarValorNaoNumerico((String)
			// dadosParticionados[2])){
			//
			// telemetriaRetMot = new TelemetriaRetMot();
			// telemetriaRetMot.setId(TelemetriaRetMot.ID_CODIGO_EMPRESA_INVALIDO);
			// }
			// else{
			//
			// codigoEmpresa = Integer.parseInt(dadosParticionados[2]);
			// }
		}

		telemetriaInformacoesGeraisHelper
				.setQuantidadeConsumidores(quantidadeConsumidores);
		telemetriaInformacoesGeraisHelper.setEnvio(dataEnvio);
		telemetriaInformacoesGeraisHelper.setCodigoEmpresa(codigoEmpresa);
		telemetriaInformacoesGeraisHelper.setTelemetriaRetMot(telemetriaRetMot);

		return telemetriaInformacoesGeraisHelper;
	}

	/**
	 * [UC1004] Processar Leitura via Telemetria
	 * 
	 * [SB0002]  Validar Dados Leitura
	 * 
	 * @author Raphael Rossiter
	 * @date 09/09/2010
	 * 
	 * @param dadosTelemetria
	 * @return TelemetriaDadosLeituraHelper
	 */
	public TelemetriaDadosLeituraHelper telemetriaValidarDadosLeitura(
			String dadosTelemetria) throws ControladorException {

		TelemetriaDadosLeituraHelper telemetriaDadosLeituraHelper = new TelemetriaDadosLeituraHelper();

		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		String[] dadosParticionados = dadosTelemetria.split("\\*");

		TelemetriaRetMot telemetriaRetMot = null;
		Collection<TelemetriaMovReg> colecaoTelemetriaMovReg = new ArrayList();
		boolean primeiraLinha = true;
		FaturamentoGrupo faturamentoGrupoReferencia = null;

		for (int i = 2; i < dadosParticionados.length; i++) {

			String leitura = dadosParticionados[i];
			String[] dadosLeitura = leitura.split(";");

			String inscricao = null;
			Integer leituraHidrometro = null;
			Integer numeroHidrometro = null;
			MedicaoTipo medicaoTipo = null;
			Date dataLeitura = null;
			Imovel imovel = null;
			FaturamentoGrupo faturamentoGrupoImovelCorrente = null;

			TelemetriaMovReg telemetriaMovReg = null;

			// 1.1. Caso a inscrição (campo L.02) não corresponda a um campo
			// numérico, rejeitar os dados recebidos
			inscricao = "0";
			// if (Util.validarValorLongoNaoNumerico((String) dadosLeitura[1])){
			//
			// telemetriaRetMot = new TelemetriaRetMot();
			// telemetriaRetMot.setId(TelemetriaRetMot.ID_INSCRICAO_INVALIDA);
			//
			// break;
			// }
			// else{
			//
			// inscricao = String.valueOf(dadosLeitura[1]);
			// }

			// 1.2. Caso a leitura do consumo (campo L.04) não corresponda a um
			// campo numérico, rejeitar os dados recebidos
			if (Util.validarValorNaoNumerico((String) dadosLeitura[3])) {

				telemetriaRetMot = new TelemetriaRetMot();
				telemetriaRetMot.setId(TelemetriaRetMot.ID_LEITURA_INVALIDA);

				break;
			} else {

				leituraHidrometro = Integer.parseInt(dadosLeitura[3]);
			}

			// 1.3. Caso o hidrômetro (campo L.05) não corresponda a um campo
			// numérico, rejeitar os dados recebidos
			numeroHidrometro = 0;
			// if (Util.validarValorNaoNumerico((String) dadosLeitura[4])){
			//
			// telemetriaRetMot = new TelemetriaRetMot();
			// telemetriaRetMot.setId(TelemetriaRetMot.ID_HIDROMETRO_INVALIDO);
			//
			// break;
			// }
			// else{
			//
			// numeroHidrometro = Integer.parseInt(dadosLeitura[4]);
			// }

			/*
			 * 1.4. Caso o tipo de medição (campo L.06) não corresponda a um
			 * campo numérico, rejeitar os dados recebidos. 1.5. Caso o tipo de
			 * medição (campo L.06) não corresponda ao valor 1 (um) ou 2 (dois),
			 * rejeitar os dados recebidos.
			 */
			if (Util.validarValorNaoNumerico((String) dadosLeitura[5])) {

				telemetriaRetMot = new TelemetriaRetMot();
				telemetriaRetMot
						.setId(TelemetriaRetMot.ID_MEDICAO_TIPO_INVALIDA);

				break;
			} else {

				Integer idMedicaoTipo = Integer.parseInt(dadosLeitura[5]);

				if (!idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)
						&& !idMedicaoTipo.equals(MedicaoTipo.POCO)) {

					telemetriaRetMot = new TelemetriaRetMot();
					telemetriaRetMot
							.setId(TelemetriaRetMot.ID_MEDICAO_TIPO_INVALIDA);

					break;
				} else {

					medicaoTipo = new MedicaoTipo();
					medicaoTipo.setId(idMedicaoTipo);
				}
			}

			/*
			 * 1.6. Caso a data/hora de leitura (campo L.01  formato AAAA-MM-DD
			 * hh:mm:ss) não corresponda a uma data/hora válida, rejeitar os
			 * dados recebidos.
			 */
			if (Util.validarDataHoraInvalida((String) dadosLeitura[0],
					"yyyy-MM-dd HH:mm:ss")) {

				telemetriaRetMot = new TelemetriaRetMot();
				telemetriaRetMot
						.setId(TelemetriaRetMot.ID_DATA_LEITURA_INVALIDA);

				break;
			} else {

				dataLeitura = Util.converteStringParaDateHora(
						(String) dadosLeitura[0], "yyyy-MM-dd HH:mm:ss");
			}

			/*
			 * 1.7. Caso a matrícula (campo L.03) não corresponda a um campo
			 * numérico, rejeitar os dados recebidos 1.8. Caso a matrícula
			 * (campo L.03) não exista no cadastro (não existe ocorrência na
			 * tabela IMOVEL para IMOV_ID=campo L.03), rejeitar os dados
			 * recebidos
			 */
			if (Util.validarValorNaoNumerico((String) dadosLeitura[2])) {

				telemetriaRetMot = new TelemetriaRetMot();
				telemetriaRetMot.setId(TelemetriaRetMot.ID_MATRICULA_INVALIDA);

				break;
			} else {

				Integer idImovel = Integer.parseInt(dadosLeitura[2]);

				try {

					idImovel = this.repositorioMicromedicao
							.pesquisarImovelTelemetria(idImovel);

				} catch (ErroRepositorioException ex) {

					telemetriaRetMot = new TelemetriaRetMot();
					telemetriaRetMot
							.setId(TelemetriaRetMot.ID_MATRICULA_INEXISTENTE);

					break;
				}

				if (idImovel == null) {

					telemetriaRetMot = new TelemetriaRetMot();
					telemetriaRetMot
							.setId(TelemetriaRetMot.ID_MATRICULA_INEXISTENTE);

					break;
				} else {

					imovel = new Imovel();
					imovel.setId(idImovel);
				}
			}

			/*
			 * 1.9. Caso a data de leitura (extrair a data do campo L.01  10
			 * primeiras posições no formato AAAA-MM-DD) estiver fora do
			 * intervalo do período de previsão de leitura do cronograma de
			 * faturamento (campo L.01 não está compreendido entre a data
			 * prevista de leitura do cronograma de faturamento menos 1 (um) dia
			 * e a data prevista de leitura do cronograma de faturamento mais 1
			 * (um) dia), rejeitar os dados recebidos: data prevista de leitura
			 * do cronograma de faturamento = FTAC_DTPREVISTA da tabela
			 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=(FTAT_ID da tabela
			 * FATURAMENTO_ATIVIDADE para FTAT_DSFATURAMENTOATIVIDADE=EFETUAR
			 * LEITURA)
			 * 
			 * E
			 * 
			 * FTCM_ID=(FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL
			 * para FTCM_AMREFERENCIA=(PARM_AMREFERENCIAFATURAMENTO da tabela
			 * SISTEMA_PARAMETROS) e FTGR_ID=(FTGR_ID da tabela ROTA para
			 * ROTA_ID=ROTA_ID da tabela QUADRA para QDRA_ID=QDRA_ID da tabela
			 * IMOVEL para IMOV_ID=campo L.03) )
			 */

			// OBTENDO O GRUPO DO IMÓVEL
			faturamentoGrupoImovelCorrente = this.getControladorImovel()
					.pesquisarGrupoImovel(imovel.getId());

			// OBTENDO A DATA PREVISTA DE FATURAMENTO DO GRUPO DO IMÓVEL
			Date dataPrevista = this.getControladorFaturamento()
					.pesquisarFaturamentoAtividadeCronogramaDataPrevista(
							faturamentoGrupoImovelCorrente.getId(),
							FaturamentoAtividade.EFETUAR_LEITURA,
							sistemaParametro.getAnoMesFaturamento());

			if (dataPrevista == null
					|| (dataLeitura.compareTo(Util.subtrairNumeroDiasDeUmaData(
							dataPrevista, 1)) < 0 || dataLeitura.compareTo(Util
							.adicionarNumeroDiasDeUmaData(dataPrevista, 1)) > 0)) {

				telemetriaRetMot = new TelemetriaRetMot();
				telemetriaRetMot
						.setId(TelemetriaRetMot.ID_DATA_LEITURA_INERVALO_INVALIDO);

				break;
			}

			/*
			 * 1.10. Caso esteja validando a primeira leitura, atribuir o grupo
			 * de faturamento do imóvel (FTGR_ID da tabela ROTA para
			 * ROTA_ID=ROTA_ID da tabela QUADRA para QDRA_ID=QDRA_ID da tabela
			 * IMOVEL para IMOV_ID=campo L.03) ao Grupo de Faturamento
			 * Referência.
			 */
			if (primeiraLinha) {

				faturamentoGrupoReferencia = faturamentoGrupoImovelCorrente;
				primeiraLinha = false;
			}
			/*
			 * 1.11. Caso contrário:
			 * 
			 * 1.11.1. Caso o grupo de faturamento do imóvel (FTGR_ID da tabela
			 * ROTA para ROTA_ID=ROTA_ID da tabela QUADRA para QDRA_ID=QDRA_ID
			 * da tabela IMOVEL para IMOV_ID=campo L.03) seja diferente do Grupo
			 * de Faturamento Referência, rejeitar os dados recebidos.
			 */
			else if (!faturamentoGrupoReferencia.getId().equals(
					faturamentoGrupoImovelCorrente.getId())) {

				telemetriaRetMot = new TelemetriaRetMot();
				telemetriaRetMot
						.setId(TelemetriaRetMot.ID_FATURAMENTO_GRUPO_INVALIDO);

				break;
			}

			// GERANDO O OBJETO COM AS INFORMAÇÕES VALIDADAS
			telemetriaMovReg = new TelemetriaMovReg();

			telemetriaMovReg.setDataLeitura(dataLeitura);
			telemetriaMovReg.setInscricao(inscricao);
			telemetriaMovReg.setLeitura(leituraHidrometro);
			telemetriaMovReg.setNumeroHidrometro(numeroHidrometro);
			telemetriaMovReg.setMedicaoTipo(medicaoTipo);
			telemetriaMovReg.setImovel(imovel);
			telemetriaMovReg.setIndicadorProcessado(ConstantesSistema.NAO);

			colecaoTelemetriaMovReg.add(telemetriaMovReg);
		}

		telemetriaDadosLeituraHelper.setTelemetriaRetMot(telemetriaRetMot);
		telemetriaDadosLeituraHelper
				.setColecaoTelemetriaMovReg(colecaoTelemetriaMovReg);

		return telemetriaDadosLeituraHelper;
	}

	/**
	 * [UC1004] Processar Leitura via Telemetria
	 * 
	 * [SB0003]  Validar Quantidade Consumidores
	 * 
	 * @author Raphael Rossiter
	 * @date 27/09/2010
	 * 
	 * @param telemetriaMov
	 * @param colecaoTelemetriaMovReg
	 * @return TelemetriaRetMot
	 */
	public TelemetriaRetMot telemetriaValidarQuantidadeConsumidores(
			TelemetriaMov telemetriaMov,
			Collection<TelemetriaMovReg> colecaoTelemetriaMovReg) {

		TelemetriaRetMot telemetriaRetMot = null;

		if ((colecaoTelemetriaMovReg == null || colecaoTelemetriaMovReg
				.isEmpty())
				|| (telemetriaMov.getQuantidadeConsumidores().intValue() != colecaoTelemetriaMovReg
						.size())) {

			telemetriaRetMot = new TelemetriaRetMot();
			telemetriaRetMot.setId(TelemetriaRetMot.ID_QUANTIDADE_DIFERENTE);
		}

		return telemetriaRetMot;
	}

	/**
	 * 
	 * [UC0153] Apresentar Dados Para Análise da Medição e Consumo
	 * 
	 * [FS0004] ? Solicitar releitura .Caso o usuário solicite a releitura de
	 * determinado imóvel, o sistema identifica o imóvel, grava os dados
	 * (REMO_ID, IMOV_ID, REMO_ICRELEITURA, USUR_ID, REMO_AMREFERENCIA
	 * preenchido com o valor FTGR_AMREFERENCIA) na tabela RELEITURA_MOBILE e
	 * envia a seguinte mensagem para o celular do leiturista responsável pela
	 * rota (LEIT_ID que esta na tabela rota em que o imovel pertence e
	 * identificar o celular deste (LEIT_NNIMEI) para envio da mensagem):
	 * ?Refazer leitura para o imóvel <IMOV_ID>. Ir para o imóvel??
	 * 
	 * .Caso o imóvel ainda não tenha tido leitura para o ano/mês de referência
	 * (se não existir registro na tabela MOVIMENTO_CONTAPREFATURADA no ano/mês
	 * de referencia), o sistema exibirá a seguinte mensagem: Leitura não
	 * realizada para o imóvel em < FTGR_AMREFERENCIA >;
	 * 
	 * .Caso o leiturista já tenha finalizado a rota (verificar na tabela
	 * ARQUIVO_TEXTO_ROTEIRO_EMPRESA se existem ocorrências para a rota
	 * mencionada no ano/mês de referencia e o campo STIL_ID correspondente a
	 * descrição "FINALIZADO" na tabela SITUACAO_TRANSMISSAO_LEITURA) será
	 * enviada a seguinte mensagem para o operador: ?Rota já foi finalizada pelo
	 * leiturista? e retorna ao passo que chamou este fluxo.
	 * 
	 * @autor Bruno Barros
	 * @date 31/08/2010
	 * 
	 * @param String
	 *            matricula - Imovel cuja releitura será solicitada
	 * @param Usuario
	 *            usuarioLogado - O usuário que está solicitando a releitura
	 */
	public void solicitarReleitura(String matricula, Usuario usuarioLogado)
			throws ControladorException {

		try {

			// Selecionamos o ano mes de faturamento da rota do imóvel informado
			Integer anoMesFaturamento = null;

			FiltroImovel filtro = new FiltroImovel();
			filtro.adicionarParametro(new ParametroSimples("id", matricula));
			filtro.adicionarCaminhoParaCarregamentoEntidade("quadra.rota");

			Collection<Imovel> colImoveis = getControladorUtil().pesquisar(
					filtro, Imovel.class.getName());

			Imovel imovel = null;

			if (colImoveis == null || colImoveis.size() == 0) {
				throw new ControladorException(
						"atencao.matricula.imovel.inexistente");
			} else {
				imovel = colImoveis.iterator().next();
				anoMesFaturamento = this.getControladorFaturamento()
						.retornaAnoMesFaturamentoGrupoDaRota(
								imovel.getQuadra().getRota().getId());
			}

			if (imovel.getIndicadorImovelCondominio().shortValue() == ConstantesSistema.SIM
					|| (imovel.getImovelCondominio() != null && imovel
							.getImovelCondominio().getId() != null)) {
				throw new ControladorException(
						"atencao.nao.releitura.imovel.condominio");
			}

			// Verificamos se a leitura ja havia chegado.
			if (!this.repositorioMicromedicao
					.verificarExistenciaLeituraImpressaoSimultanea(matricula,
							anoMesFaturamento)) {
				throw new ControladorException(
						"atencao.leitura.nao.realizada.imovel", null,
						Util.formatarAnoMesParaMesAno(anoMesFaturamento));
			}

			// Verificamos se o arquivo ja foi finalizado
			Object[] dadosArquivoTextoRoteiroEmpresa = repositorioFaturamento
					.pesquisarArquivoTextoRoteiroEmpresa(imovel.getQuadra()
							.getRota().getId(), anoMesFaturamento);

			if (dadosArquivoTextoRoteiroEmpresa != null) {
				Integer idSituacaoTransmissaoLeitura = (Integer) dadosArquivoTextoRoteiroEmpresa[1];
				if (!idSituacaoTransmissaoLeitura
						.equals(SituacaoTransmissaoLeitura.DISPONIVEL)
						&& !idSituacaoTransmissaoLeitura
								.equals(SituacaoTransmissaoLeitura.LIBERADO)
						&& !idSituacaoTransmissaoLeitura
								.equals(SituacaoTransmissaoLeitura.EM_CAMPO)
						&& !idSituacaoTransmissaoLeitura
								.equals(SituacaoTransmissaoLeitura.FINALIZADO_NAO_TRANSMITIDO)) {
					throw new ControladorException(
							"atencao.rota.ja.finalizada.leiturista", null);
				}
			}

			// Pegamos as leituras atuais
			FiltroMovimentoContaPrefaturada filtroMovimentoContaPrefaturada = new FiltroMovimentoContaPrefaturada();
			filtroMovimentoContaPrefaturada
					.adicionarParametro(new ParametroSimples(
							FiltroMovimentoContaPrefaturada.MATRICULA, imovel
									.getId()));
			filtroMovimentoContaPrefaturada
					.adicionarParametro(new ParametroSimples(
							FiltroMovimentoContaPrefaturada.ANO_MES_REFERENCIA_PRE_FATURAMENTO,
							anoMesFaturamento));

			Collection<MovimentoContaPrefaturada> colMovimentoContaPrefaturada = getControladorUtil()
					.pesquisar(filtroMovimentoContaPrefaturada,
							MovimentoContaPrefaturada.class.getName());

			Integer leituraAtualAgua = null;
			Integer leituraAtualPoco = null;

			LeituraAnormalidade leituraAnormalidadeAtualAgua = null;
			LeituraAnormalidade leituraAnormalidadeAtualPoco = null;

			for (MovimentoContaPrefaturada prefaturada : colMovimentoContaPrefaturada) {
				if (prefaturada.getMedicaoTipo().getId().intValue() == MedicaoTipo.LIGACAO_AGUA) {
					leituraAtualAgua = prefaturada.getLeituraHidrometro();
					leituraAnormalidadeAtualAgua = prefaturada
							.getLeituraAnormalidadeFaturamento();
				} else {
					leituraAtualPoco = prefaturada.getLeituraHidrometro();
					leituraAnormalidadeAtualPoco = prefaturada
							.getLeituraAnormalidadeFaturamento();
				}
			}

			// Verificamos se a solicitação de releitura ja havia sido
			// solicitada
			FiltroReleituraMobile filtroReleituraMobile = new FiltroReleituraMobile();

			filtroReleituraMobile.adicionarParametro(new ParametroSimples(
					FiltroReleituraMobile.ID_IMOVEL, imovel.getId()));
			filtroReleituraMobile.adicionarParametro(new ParametroSimples(
					FiltroReleituraMobile.ANO_MES_FATURAMENTO,
					anoMesFaturamento));
			filtroReleituraMobile.adicionarParametro(new ParametroSimples(
					FiltroReleituraMobile.INDICADOR_RELEITURA,
					ConstantesSistema.NAO));

			Collection<ReleituraMobile> colReleituraMobile = getControladorUtil()
					.pesquisar(filtroReleituraMobile,
							ReleituraMobile.class.getName());

			if (colReleituraMobile != null && colReleituraMobile.size() > 0) {
				throw new ControladorException(
						"atencao.releitura.ja.solicitada", null, matricula);
			}

			// Passou por todas as verificações, nos inserimos a linha
			ReleituraMobile releitura = new ReleituraMobile();

			releitura.setLeituraAtualAgua(leituraAtualAgua);
			releitura.setLeituraAtualPoco(leituraAtualPoco);
			releitura
					.setLeituraAnormalidadeAtualAgua(leituraAnormalidadeAtualAgua);
			releitura
					.setLeituraAnormalidadeAtualPoco(leituraAnormalidadeAtualPoco);

			releitura.setAnoMesReferencia(anoMesFaturamento);
			releitura.setIndicadorMensagemRecebida(new Integer(
					ConstantesSistema.NAO));
			releitura.setIndicadorReleitura(new Integer(ConstantesSistema.NAO));
			releitura.setUltimaAlteracao(new Date());
			releitura.setImovel(imovel);
			releitura.setUsuario(usuarioLogado);

			this.repositorioUtil.inserir(releitura);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * 
	 * Pesquisa os imóveis para a tela de Filtrar Imoveis para Releitura
	 * 
	 * @author Bruno Barros
	 * @date 14/09/2010
	 * 
	 * @param anoMesReferencia
	 * @param idGrupoFaturamento
	 * @param idRota
	 * @param idQuadra
	 * @param idSituacaoTrasmissaoLeitura
	 * @return
	 */
	public Collection<AnalisarImoveisReleituraHelper> pesquisarImovelParaReleitura(
			String anoMesReferencia, String idGrupoFaturamento, String idRota,
			String idQuadra, String idSituacaoTrasmissaoLeitura,
			String idEmpresa) throws ControladorException {

		Collection<ReleituraMobile> colReleituras = null;
		Collection<AnalisarImoveisReleituraHelper> colRetorno = new ArrayList();

		try {

			colReleituras = repositorioMicromedicao
					.pesquisarImovelParaReleitura(anoMesReferencia,
							idGrupoFaturamento, idRota, idQuadra, idEmpresa);

			for (ReleituraMobile releituras : colReleituras) {
				AnalisarImoveisReleituraHelper helper = new AnalisarImoveisReleituraHelper();

				helper.setMatriculaImovel(releituras.getImovel()
						.getMatriculaFormatada());
				helper.setIdQuadra(releituras.getImovel().getQuadra().getId());
				helper.setIdLocalidade(releituras.getImovel().getLocalidade()
						.getId());
				helper.setCodigoSetorComercial(releituras.getImovel()
						.getSetorComercial().getCodigo());
				helper.setCodigoRota(releituras.getImovel().getQuadra()
						.getRota().getCodigo());
				helper.setEmpresa(releituras.getImovel().getQuadra().getRota()
						.getEmpresa().getId());
				helper.setLeituraAtualAgua(releituras.getLeituraAtualAgua());
				helper.setLeituraAnteriorAgua(releituras
						.getLeituraAnteriorAgua());
				helper.setLeituraAtualPoco(releituras.getLeituraAtualPoco());
				helper.setLeituraAnteriorPoco(releituras
						.getLeituraAnteriorPoco());
				helper.setLeituraAnormalidadeAnteriorAgua(releituras
						.getLeituraAnormalidadeAnteriorAgua());
				helper.setLeituraAnormalidadeAtualAgua(releituras
						.getLeituraAnormalidadeAtualAgua());
				helper.setLeituraAnormalidadeAnteriorPoco(releituras
						.getLeituraAnormalidadeAnteriorPoco());
				helper.setLeituraAnormalidadeAtualPoco(releituras
						.getLeituraAnormalidadeAtualPoco());

				Short situacaoReleitura;

				if (releituras.getIndicadorReleitura().intValue() == ConstantesSistema.SIM) {
					situacaoReleitura = AnalisarImoveisReleituraHelper.RELEITURA_REALIZADA;
				} else {
					if (releituras.getIndicadorMensagemRecebida().intValue() == ConstantesSistema.NAO) {
						situacaoReleitura = AnalisarImoveisReleituraHelper.RELEITURA_NAO_REALIZADA;
					} else {
						situacaoReleitura = AnalisarImoveisReleituraHelper.RELEITURA_PENDENTE;
					}
				}

				helper.setIdSituacaoReleitura(situacaoReleitura);

				if (releituras.getIndicadorMensagemRecebida().shortValue() == ConstantesSistema.SIM) {
					helper.setRecebeuMensagem("SIM");
				} else {
					helper.setRecebeuMensagem("NÃO");
				}

				if (idSituacaoTrasmissaoLeitura != null
						&& !idSituacaoTrasmissaoLeitura.equals(""
								+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
					if (idSituacaoTrasmissaoLeitura.equals(helper
							.getIdSituacaoReleitura() + "")) {
						colRetorno.add(helper);
					}
				} else {
					colRetorno.add(helper);
				}
			}

			if (colRetorno == null || colRetorno.size() == 0) {
				throw new ControladorException(
						"atencao.pesquisa.nenhumresultado");
			}

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return colRetorno;
	}

	/**
	 * 
	 * Verifica se a releitura solicitada já foi realizada
	 * 
	 * @author Bruno Barros
	 * @date 13/09/2010
	 * 
	 * @param idImovel
	 *            Imóvel a ser pesquisado
	 * @param anoMesFaturamento
	 *            Ano mes de faturamento a ser pesquisado
	 * @return
	 */
	public boolean releituraJaRealizada(String matricula)
			throws ControladorException {

		Integer anoMesFaturamento = null;

		FiltroImovel filtro = new FiltroImovel();
		filtro.adicionarParametro(new ParametroSimples(FiltroImovel.ID,
				matricula));
		filtro.adicionarCaminhoParaCarregamentoEntidade("quadra.rota");

		Collection<Imovel> colImoveis = getControladorUtil().pesquisar(filtro,
				Imovel.class.getName());

		Imovel imovel = null;

		if (colImoveis == null || colImoveis.size() == 0) {
			throw new ControladorException(
					"atencao.matricula.imovel.inexistente");
		} else {
			imovel = colImoveis.iterator().next();
			anoMesFaturamento = this.getControladorFaturamento()
					.retornaAnoMesFaturamentoGrupoDaRota(
							imovel.getQuadra().getRota().getId());
		}

		FiltroReleituraMobile filtroReleitura = new FiltroReleituraMobile();
		filtroReleitura.adicionarParametro(new ParametroSimples(
				FiltroReleituraMobile.ID_IMOVEL, matricula));
		filtroReleitura.adicionarParametro(new ParametroSimples(
				FiltroReleituraMobile.ANO_MES_FATURAMENTO, anoMesFaturamento));
		Collection<ReleituraMobile> colReleituraMobile = this
				.getControladorUtil().pesquisar(filtroReleitura,
						ReleituraMobile.class.getName());

		boolean ja = true;

		if (colReleituraMobile == null || colReleituraMobile.size() == 0) {
			ja = false;
		} else {
			for (ReleituraMobile mobile : colReleituraMobile) {
				if (mobile.getIndicadorReleitura().intValue() == ConstantesSistema.NAO
						.intValue()) {
					ja = false;
					break;
				}
			}
		}

		return ja;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 20/09/2010
	 * 
	 * @throws ErroRepositorioException
	 */
	public Object[] obterLeituraAnteriorEAtualFaturamentoMedicaoHistorico(
			Integer idImovel, Integer anoMesReferencia)
			throws ControladorException {
		try {

			return repositorioMicromedicao
					.obterLeituraAnteriorEAtualFaturamentoMedicaoHistorico(
							idImovel, anoMesReferencia);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * [UC0629] Consultar Arquivo Texto para Leitura
	 * 
	 * @author Bruno Barros
	 * @date 27/09/2010
	 * 
	 */
	public Collection<ImovelFaltandoSituacaoLeituraHelper> pesquisarImoveisFaltandoSituacaoLeitura(
			Integer idRota, Integer anoMesReferencia)
			throws ControladorException {

		Collection<ImovelFaltandoSituacaoLeituraHelper> colHelpers = null;

		try {
			Collection<Object[]> colIdsImoveis = this.repositorioMicromedicao
					.pesquisarImoveisFaltandoSituacaoLeitura(idRota,
							anoMesReferencia);

			if (colIdsImoveis != null && colIdsImoveis.size() > 0) {
				colHelpers = new ArrayList(colIdsImoveis.size());

				for (Object[] infoImovel : colIdsImoveis) {
					Integer idImovel = (Integer) infoImovel[0];
					String medido = (String) infoImovel[1];

					String endereco = this.getControladorEndereco()
							.pesquisarEnderecoFormatado(idImovel);
					ImovelFaltandoSituacaoLeituraHelper helper = new ImovelFaltandoSituacaoLeituraHelper(
							idImovel + "", endereco, medido);
					colHelpers.add(helper);
				}
			}
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return colHelpers;
	}

	/**
	 * [UC0932] Monitorar Leituras Transmitidas
	 * 
	 * Pesquisa as leituras que foram trasmitidas.
	 * 
	 * @author Bruno Barros
	 * @date 28/09/2010
	 * 
	 * @param idRota
	 * @param anoMesReferencia
	 * @param indicadorContaImpressa
	 * @param indicadorMedido
	 * @return Colecao com as informações necessarias para o prenchimento da
	 *         tela.
	 * 
	 */
	public Collection<MonitorarLeituraMobilePopupHelper> pesquisarImoveisMonitorarLeiturasTransmitidas(
			Integer idRota, Integer anoMesReferencia,
			Short indicadorContaImpressa, Short indicadorMedido)
			throws ControladorException {

		Collection<MonitorarLeituraMobilePopupHelper> colHelpers = null;

		try {
			Collection<Object[]> colDados = this.repositorioMicromedicao
					.pesquisarImoveisMonitorarLeiturasTransmitidas(idRota,
							anoMesReferencia, indicadorContaImpressa,
							indicadorMedido);

			if (colDados != null && colDados.size() > 0) {
				colHelpers = new ArrayList(colDados.size());

				for (Object[] infoImovel : colDados) {
					String inscricao = (String) infoImovel[0];
					Integer idImovel = (Integer) infoImovel[1];
					Integer sequencialRota = (Integer) infoImovel[2];
					Integer leituraAnterior = (Integer) infoImovel[3];
					Integer leituraAtual = (Integer) infoImovel[4];
					Integer idAnormalidade = (Integer) infoImovel[5];
					Date dtLeitura = (Date) infoImovel[6];
					Date dtRecebimento = (Date) infoImovel[7];
					Short icEmissaoConta = (Short) infoImovel[8];
					String motivoNaoEmissao = (String) infoImovel[9];
					Boolean medido = (Boolean) infoImovel[10];

					MonitorarLeituraMobilePopupHelper helper = new MonitorarLeituraMobilePopupHelper();

					helper.setInscricao(inscricao);
					helper.setIdImovel(idImovel + "");
					helper.setSequencialRota((sequencialRota == null ? ""
							: sequencialRota + ""));
					helper.setLeituraAnterior(leituraAnterior + "");

					if (!medido) {
						helper.setLeituraAtual("Não Medido");
					} else {
						helper.setLeituraAtual((leituraAtual != null ? leituraAtual
								+ ""
								: ""));
					}

					helper.setIdAnormalidade((idAnormalidade != null ? idAnormalidade
							+ ""
							: ""));
					helper.setDtLeitura(Util.formatarDataComHora(dtLeitura));
					helper.setDtRecebimento(Util
							.formatarDataComHora(dtRecebimento));
					helper.setIcEmissaoConta((icEmissaoConta.intValue() == ConstantesSistema.SIM ? "SIM"
							: "NÃO"));
					helper.setMotivoNaoEmissao(motivoNaoEmissao);

					String informacoesCliente = "";
					informacoesCliente += "Endereço: "
							+ this.getControladorEndereco()
									.pesquisarEnderecoFormatado(idImovel)
							+ "<BR>";
					Collection<ClienteImovel> colClientes = this
							.getControladorImovel().pesquisarClientesImovel(
									idImovel);

					String dadosClientes = "*****************************Cliente(s)******************************"
							+ "<BR>";

					int i = 0;

					if (colClientes == null || colClientes.isEmpty()) {

						colClientes = this.getControladorImovel()
								.pesquisarClientesImovelDataMax(idImovel);
					}

					for (ClienteImovel cliente : colClientes) {

						dadosClientes += "Nome: "
								+ cliente.getCliente().getNome() + "<BR>";
						dadosClientes += "Tipo da Relação: "
								+ cliente.getClienteRelacaoTipo()
										.getDescricao() + "<BR>";
						dadosClientes += "Data de Inicio da Relação: "
								+ Util.formatarData(cliente
										.getDataInicioRelacao()) + "<BR>";

						i++;

						if (i != colClientes.size()) {
							dadosClientes += "-----------------------------------------------------------------------"
									+ "<BR>";
						}
					}

					informacoesCliente += dadosClientes;

					String dadosCategorias = "******************Categoria(s)/Subcategoria(s)******************"
							+ "<BR>";

					Collection<ImovelSubcategoria> colCategorias = this
							.getControladorImovel().pesquisarCategoriasImovel(
									idImovel);

					i = 0;

					for (ImovelSubcategoria categorias : colCategorias) {
						dadosCategorias += "Categoria: "
								+ categorias.getComp_id().getSubcategoria()
										.getCategoria().getDescricao() + "<BR>";
						dadosCategorias += "SubCategoria: "
								+ categorias.getComp_id().getSubcategoria()
										.getDescricao() + "<BR>";
						dadosCategorias += "Economias: "
								+ categorias.getQuantidadeEconomias() + "<BR>";

						i++;

						if (i != colCategorias.size()) {
							dadosCategorias += "-----------------------------------------------------------------------"
									+ "<BR>";
						}
					}

					informacoesCliente += dadosCategorias;

					helper.setDadosCliente(informacoesCliente);

					Imovel imovel = new Imovel(idImovel);
					Collection<ConsumoHistorico> colConsumoHistorico = this
							.obterUltimosConsumosImovel(imovel);
					helper.setColConsumos(colConsumoHistorico);

					colHelpers.add(helper);
				}
			} else {
				throw new ControladorException(
						"atencao.pesquisa.nenhumresultado");
			}
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return colHelpers;

	}

	/**
	 * [UC0712] Atualizar Leituras e Anormalidades
	 * 
	 * @author Raphael Rossiter
	 * @date 18/10/2010
	 * 
	 * @param dataLeituraCampo
	 * @param faturamentoGrupo
	 * @param anoMesReferencia
	 * @return Date
	 * @throws ControladorException
	 */
	public Date obterDataRealizacaoDaAtividadeEfetuarLeitura(
			Date dataLeituraCampo, FaturamentoGrupo faturamentoGrupo,
			Integer anoMesReferencia) throws ControladorException {

		Date dataLeituraCronograma = null;

		Integer anoMesDataLeitura = Util.formataAnoMes(dataLeituraCampo);
		Integer anoMesFaturamentoAnterior = Util.subtrairMesDoAnoMes(
				anoMesReferencia, 1);
		Integer anoMesFaturamentoPosterior = Util
				.somaUmMesAnoMesReferencia(anoMesReferencia);

		if (anoMesDataLeitura != null && anoMesFaturamentoAnterior != null
				&& anoMesFaturamentoPosterior != null) {

			if (anoMesReferencia.equals(anoMesDataLeitura)
					|| Util.compararAnoMesReferencia(anoMesDataLeitura,
							anoMesFaturamentoAnterior, "=")
					|| Util.compararAnoMesReferencia(anoMesDataLeitura,
							anoMesFaturamentoPosterior, "=")) {

				dataLeituraCronograma = dataLeituraCampo;
			} else {

				dataLeituraCronograma = new Date();
			}
		} else {

			dataLeituraCronograma = dataLeituraCampo;
		}

		return dataLeituraCronograma;
	}

	/**
	 * [UC0933] Alterar Leiturista do Arquivo Texto para Leitura
	 * 
	 * @author Tiago Nascimento, Rômulo Aurélio
	 * @Data ??/??/??, 27/10/2010
	 * 
	 */
	public void alterarLeituristaArquivoLeitura(ArquivoTextoRoteiroEmpresa arq,
			Integer idLeiturista, Integer idGrupoFaturamento,
			Integer anoMesReferencia) throws ControladorException {

		try {
			FiltroLeiturista filtroLeiturista = new FiltroLeiturista();

			filtroLeiturista.adicionarParametro(new ParametroSimples(
					FiltroLeiturista.ID, idLeiturista));

			Collection colecaoLeiturista = getControladorUtil().pesquisar(
					filtroLeiturista, Leiturista.class.getName());

			if (colecaoLeiturista != null && !colecaoLeiturista.isEmpty()) {

				Leiturista leiturista = (Leiturista) colecaoLeiturista
						.iterator().next();

				Integer numeroSequencial = this
						.numeroSequenciaUltimaRota(leiturista.getId());
				numeroSequencial = numeroSequencial + 1;

				arq.setLeiturista(leiturista);
				arq.setNumeroImei(leiturista.getNumeroImei());
				arq.setNumeroSequenciaLeitura(numeroSequencial);
				arq.setUltimaAlteracao(new Date());
				arq.setCodigoLeiturista(leiturista.getCodigoDDD());
				arq.setNumeroFoneLeiturista(leiturista.getNumeroFone());

				getControladorUtil().atualizar(arq);

				arq.getRota().setLeiturista(leiturista);
				arq.getRota().setNumeroSequenciaLeitura(numeroSequencial);
				arq.getRota().setUltimaAlteracao(new Date());

				getControladorUtil().atualizar(arq.getRota());

				// Atualiza Movimento Roteiro Empresa
				// CRC 5297
				// Data: 27/10/2010
				repositorioMicromedicao
						.atualizarLeituristaMovimentoRoteiroEmpresa(
								idGrupoFaturamento, anoMesReferencia,
								leiturista, arq);

			}
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC1070] Filtrar Leituras Telemetria
	 * 
	 * @author Hugo Amorim
	 * @date 27/09/2010
	 * 
	 */
	public Collection<TelemetriaMovReg> filtrarLeiturasTelemetria(
			FiltrarLeiturasTelemetriaHelper helper) throws ControladorException {
		try {

			return repositorioMicromedicao.filtrarLeiturasTelemetria(helper);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC1070] Filtrar Leituras Telemetria
	 * 
	 * @author Hugo Amorim
	 * @date 27/09/2010
	 * 
	 */
	public Integer countFiltrarLeiturasTelemetria(
			FiltrarLeiturasTelemetriaHelper helper) throws ControladorException {
		try {

			return repositorioMicromedicao
					.countFiltrarLeiturasTelemetria(helper);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC1070] Filtrar Leituras Telemetria
	 * 
	 * @author Hugo Amorim
	 * @date 27/09/2010
	 * 
	 */
	public boolean verificarLeiturasTelemetriaNaoProcessadas(
			FiltrarLeiturasTelemetriaHelper helper) throws ControladorException {
		try {

			return repositorioMicromedicao
					.verificarLeiturasTelemetriaNaoProcessadas(helper);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC1070] Filtrar Leituras Telemetria
	 * 
	 * @author Hugo Amorim
	 * @date 27/09/2010
	 * 
	 */
	public boolean verificarGruposDiferentesLeiturasTelemetria(String[] ids)
			throws ControladorException {
		try {

			return repositorioMicromedicao
					.verificarGruposDiferentesLeiturasTelemetria(ids);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC1070] Filtrar Leituras Telemetria
	 * 
	 * @author Hugo Amorim
	 * @date 27/09/2010
	 * 
	 */
	public Collection<TelemetriaMovReg> perquisarLeiturasTelemetriaPorId(
			String[] ids) throws ControladorException {
		try {

			return repositorioMicromedicao
					.perquisarLeiturasTelemetriaPorId(ids);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * UC1027 - Exibir Consultar Arquivo Texto Leitura Divisão.
	 * 
	 * Verifica se existe um arquivo com a situação liberado para o leiturista
	 * que o usuário está querendo liberar o arquivo
	 * 
	 * @author Sávio Luiz
	 * @created 04/10/2010
	 */

	public Object[] verificarExistenciaArquivoLiberado(
			Integer idArquivoTextoRoteiroEmpresa, boolean arquivoDividido)
			throws ControladorException {
		Object[] dadosArquivoLiberado = null;
		try {

			// verifica se o arquivo é dividido ou não para recuperar o
			// leiturista do arquivo
			Integer idLeiturista = this.repositorioMicromedicao
					.recuperaLeituristaArquivoTexto(
							idArquivoTextoRoteiroEmpresa, arquivoDividido);
			// caso o leiturista seja diferente de nulo
			if (idLeiturista != null) {
				// verifica se existe um arquivo na tabela de arquivo dividido
				// para o mesmo leiturista
				// com situação igual a liberado.
				dadosArquivoLiberado = this.repositorioMicromedicao
						.temArquivoTextoDivididoLiberado(idLeiturista);
				// Caso não exista na tabela de arquivo texto dividido,
				// então verifica se existe um arquivo na tabela de arquivo
				// texto para o mesmo leiturista
				// com situação igual a liberado.
				if (dadosArquivoLiberado == null
						|| dadosArquivoLiberado.length == 0) {
					dadosArquivoLiberado = this.repositorioMicromedicao
							.temArquivoTextoLiberado(idLeiturista);
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return dadosArquivoLiberado;
	}

	/**
	 * [UC1068] Consistir Leitura Telemetria
	 * 
	 * @author Hugo Amorim
	 * @date 27/09/2010
	 * 
	 */
	public boolean consistirLeituraTelemetria(TelemetriaMovReg telemetriaMovReg) {
		boolean retorno = false;

		try {

			Vector<DadosMovimentacao> colecaoDados = new Vector<DadosMovimentacao>();

			colecaoDados.add(new DadosMovimentacao(telemetriaMovReg.getImovel()
					.getId(), telemetriaMovReg.getLeitura(), new Integer(0),
					telemetriaMovReg.getDataLeitura(), null,
					new Byte((byte) 0), telemetriaMovReg.getMedicaoTipo()
							.getId()));

			this.atualizarLeituraTelemetria(colecaoDados);

			retorno = true;

		} catch (Exception e) {
			try {

				// Preparando o stacktrace da exceção para atualização na tabela
				ByteArrayOutputStream baos = new ByteArrayOutputStream();
				e.printStackTrace(new PrintStream(baos));

				telemetriaMovReg.setDescricaoErro(IoUtil
						.transformarObjetoParaBytes(baos.toString()));

				getControladorUtil().atualizar(telemetriaMovReg);

				baos.close();

				retorno = false;

			} catch (Exception controladorException) {
				System.out.println("****************************************");
				System.out.println("***EXCEPTION NO ATUALIZAR LOG DE ERRO***");
				System.out.println("****************************************");
				controladorException.printStackTrace();
				System.out.println("****************************************");
				System.out.println("***EXCEPTION NO ATUALIZAR LOG DE ERRO***");
				System.out.println("****************************************");
			}
		}

		return retorno;
	}

	/**
	 * [UC0091] Alterar Dados para Faturamento
	 * 
	 * [FS0015] Verificar Imóvel Impressão Simultânea
	 * 
	 * @author Rômulo Aurélio
	 * @date 08/11/2010
	 */
	public boolean verificarExistenciaArquivoDeImpressaoRotaAlternativa(
			Integer idImovel, Integer tipoMedicao) throws ControladorException {

		try {
			return this.repositorioMicromedicao
					.verificarExistenciaArquivoDeImpressaoRotaAlternativa(
							idImovel, tipoMedicao);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0153] Apresentar Dados Para Análise da Medição e Consumo [FS0006] ?
	 * Verificar alterações
	 * 
	 * Atualiazar MCPF_ICALTERACAO da tabela MOVIMENTO_CONTA_PREFATURADA para
	 * recebe o valor 1.
	 * 
	 * @author Hugo Leonardo
	 * @date 26/10/2010
	 * 
	 * @param mesAno
	 * @param idImovel
	 * @param idMedicaoTipo
	 * @throws ControladorException
	 */
	protected void atualizarMovimentoContaPreFaturada(Integer idImovel,
			String mesAno, Integer idMedicaoTipo,
			String dataLeituraAtualInformada, String leituraAtualInformada,
			boolean alterouAnormalidade, Integer idAnormalidade)
			throws ControladorException {

		FiltroMovimentoContaPrefaturada filtroMovimentoContaPrefaturada = new FiltroMovimentoContaPrefaturada();
		filtroMovimentoContaPrefaturada
				.adicionarParametro(new ParametroSimples(
						FiltroMovimentoContaPrefaturada.MATRICULA, idImovel));

		filtroMovimentoContaPrefaturada
				.adicionarParametro(new ParametroSimples(
						FiltroMovimentoContaPrefaturada.ANO_MES_REFERENCIA_PRE_FATURAMENTO,
						Util.formatarMesAnoComBarraParaAnoMes(mesAno)));

		filtroMovimentoContaPrefaturada
				.adicionarParametro(new ParametroSimples(
						FiltroMovimentoContaPrefaturada.ID_MEDICAO_TIPO,
						idMedicaoTipo));

		Collection movimentoContaPrefaturadaEncontrada = this
				.getControladorUtil().pesquisar(
						filtroMovimentoContaPrefaturada,
						MovimentoContaPrefaturada.class.getName());

		if (!Util.isVazioOrNulo(movimentoContaPrefaturadaEncontrada)) {

			MovimentoContaPrefaturada mcpf = (MovimentoContaPrefaturada) movimentoContaPrefaturadaEncontrada
					.iterator().next();

			mcpf.setIndicadorAlteracao(ConstantesSistema.SIM);
			mcpf.setUtlimaAlteracao(new Date());

			if (dataLeituraAtualInformada != null) {
				mcpf.setDataHoraLeitura(Util
						.converteStringParaDate(dataLeituraAtualInformada));
			}

			if (leituraAtualInformada != null
					&& !leituraAtualInformada.equals("")) {
				mcpf.setLeituraHidrometro(new Integer(leituraAtualInformada));
				mcpf.setLeituraFaturamento(new Integer(leituraAtualInformada));
			} else {
				mcpf.setLeituraHidrometro(null);
				mcpf.setLeituraFaturamento(new Integer(0));
			}

			LeituraAnormalidade leituraAnormalidadeFaturamento = new LeituraAnormalidade();
			leituraAnormalidadeFaturamento.setId(idAnormalidade);
			mcpf.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturamento);

			MedicaoHistorico medicaoHistorico = null;

			if (idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)) {
				medicaoHistorico = pesquisarMedicaoHistoricoTipoAgua(idImovel,
						Util.formatarMesAnoComBarraParaAnoMes(mesAno));
			} else if (idMedicaoTipo.equals(MedicaoTipo.POCO)) {
				medicaoHistorico = pesquisarMedicaoHistoricoTipoPoco(idImovel,
						Util.formatarMesAnoComBarraParaAnoMes(mesAno));
			}

			mcpf.setConsumoMedido(medicaoHistorico.getNumeroConsumoMes());

			mcpf.setLeituraAnormalidadeLeitura(leituraAnormalidadeFaturamento);
			mcpf.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturamento);

			this.getControladorUtil().atualizar(mcpf);
		}
	}

	/**
	 * [UCXXXX] - Obter Volume Medio Agua ou Esgoto RM4548
	 * 
	 * @author Ivan Sergio
	 * @data 13/12/2010
	 * 
	 * @param idImovel
	 * @param faturamentoGrupo
	 * @param idLigacaoTipo
	 * @return houveIntslacaoHidrometro
	 * @throws ControladorException
	 */			
	public int[] obterVolumeMedioAguaEsgoto(Integer idImovel,
			Integer anoMesreferencia, Integer idLigacaoTipo, boolean houveInstalacaoHidrometro)
			throws ControladorException {

		int[] retorno = new int[2];
		retorno[0] = 0;
		retorno[1] = 0;
		Collection dadosConsumo = null;
		Integer consumo = 0;
		Integer mediaConsumo = 0;
		int quantidadeMesesRetroagidos = 0;
		Integer amReferenciaInicial;
		Integer amReferenciaFinal;

		SistemaParametro sistemaParametro = null;

		try {
			sistemaParametro = repositorioUtil.pesquisarParametrosDoSistema();
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		// Seta a Referencia Final
		amReferenciaFinal = Util.subtrairMesDoAnoMes(anoMesreferencia, 1);

		// Seta a Referencia Inicial
		amReferenciaInicial = Util.subtrairMesDoAnoMes(amReferenciaFinal,
				sistemaParametro.getMesesMediaConsumo());

		// Recupera o numero maximo de meses para o calculo da media
		Integer numeroMesesMaximoCalculoMedia = sistemaParametro
				.getNumeroMesesMaximoCalculoMedia().intValue();

		// Seta o novo periodo inicial
		Integer amReferenciaInicialMaximo = Util.subtrairMesDoAnoMes(
				amReferenciaInicial, numeroMesesMaximoCalculoMedia);

		// Verifica a quantidade de meses do intervalo
		int quantidadeMesesPeriodoInformado = Util.retornaQuantidadeMeses(
				amReferenciaFinal, amReferenciaInicial);
		int quantidadeMesesConsiderados = 0;

		try {
			dadosConsumo = this.repositorioMicromedicao
					.obterVolumeMedioAguaOuEsgoto(idImovel,
							amReferenciaInicialMaximo, amReferenciaFinal,
							idLigacaoTipo);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		if (dadosConsumo != null && !dadosConsumo.isEmpty()) {
			Iterator iDadosConsumo = dadosConsumo.iterator();
			Object[] dados = (Object[]) iDadosConsumo.next();
			Integer referencia = (Integer) dados[0];
			Boolean retroagir = false;
			Boolean fimCalculo = false;

			while (!fimCalculo
					&& (quantidadeMesesRetroagidos <= numeroMesesMaximoCalculoMedia)
					&& (quantidadeMesesConsiderados < quantidadeMesesPeriodoInformado)) {
				if (amReferenciaFinal.equals(referencia)) {
					consumo += (Integer) dados[1];
					quantidadeMesesConsiderados++;

					if (iDadosConsumo.hasNext()) {
						dados = (Object[]) iDadosConsumo.next();
						referencia = (Integer) dados[0];
					} else {
						fimCalculo = true;
					}
					retroagir = false;
				} else {
					retroagir = true;
				}

				if (quantidadeMesesRetroagidos < numeroMesesMaximoCalculoMedia) {
					if (retroagir) {
						quantidadeMesesRetroagidos++;
					}
					amReferenciaFinal = Util.subtrairMesDoAnoMes(
							amReferenciaFinal, 1);
				} else {
					fimCalculo = true;
				}
			}

			if (quantidadeMesesConsiderados > 0) {
				mediaConsumo = (consumo / quantidadeMesesConsiderados);
			}
		} else {

			/*
			 * Colocado por Raphael Rossiter em 01/03/2011 OBJ: Para os imóveis
			 * que não tenhão consumo histórico, será colocado como média o seu
			 * consumo mínimo.
			 */
			Integer idConsumoTarifa = this.getControladorImovel()
					.recuperarIdConsumoTarifa(idImovel);

			ConsumoTarifa consumoTarifa = new ConsumoTarifa();
			consumoTarifa.setId(idConsumoTarifa);

			Imovel imovel = new Imovel();
			imovel.setId(idImovel);
			imovel.setConsumoTarifa(consumoTarifa);

			// [UC0105] Obter Consumo Mínimo da Ligação
			mediaConsumo = this.obterConsumoMinimoLigacao(imovel, null);
			quantidadeMesesConsiderados = 1;

		}

		retorno[0] = mediaConsumo;
		retorno[1] = quantidadeMesesConsiderados;

		return retorno;
	}

	/**
	 * Este caso de uso permite a emissão de boletins de medição em formato TXT
	 * 
	 * [UC1054] Gerar Relatório Boletim de Medição
	 * 
	 * @author Mariana Victor
	 * @date 22/02/2011
	 * 
	 * @param
	 * @return byte[]
	 */
	public byte[] emitirBoletimMedicao(Collection colecao, String mesAno)
			throws ControladorException {

		System.out.println("********************");
		System.out.println("INICIO BOLETIM CADASTRO");
		System.out.println("********************");

		StringBuilder boletimCadastroTxt = new StringBuilder();
		int sequencialImpressao = 0;

		if (colecao != null && !colecao.isEmpty()) {

			criarDadosTxtBoletimCadastro(boletimCadastroTxt);

			boletimCadastroTxt.append(System.getProperty("line.separator"));

			Iterator colecaoIterator = colecao.iterator();
			int count = 0;

			while (colecaoIterator.hasNext()) {

				RelatorioBoletimMedicaoHelper helper = (RelatorioBoletimMedicaoHelper) colecaoIterator
						.next();

				count++;

				System.out.println("VEZ QUE ENTRA:" + count + " / "
						+ colecao.size());

				sequencialImpressao++;

				if (helper != null) {
					criarDadosTxtBoletimCadastro(boletimCadastroTxt, helper);
				}

				boletimCadastroTxt.append(System.getProperty("line.separator"));

			}
		}

		System.out.println("********************");
		System.out.println("FIM BOLETIM CADASTRO");
		System.out.println("********************");

		String nomeZip = "BOLETIM_MEDICAO " + mesAno;

		nomeZip = nomeZip.replace("/", "_");
		nomeZip = nomeZip.replace(" ", "_");

		byte[] retornoArray = null;

		try {
			if (boletimCadastroTxt != null) {

				boletimCadastroTxt.append("\u0004");
				// criar o arquivo zip
				File compactado = File.createTempFile("zipHtml" + nomeZip,
						".zip");
				ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(
						compactado));

				File leitura = new File(nomeZip + ".txt");
				BufferedWriter out = new BufferedWriter(new OutputStreamWriter(
						new FileOutputStream(leitura.getAbsolutePath())));
				out.write(boletimCadastroTxt.toString());
				out.flush();
				out.close();
				ZipUtil.adicionarArquivo(zos, leitura);

				// close the stream
				zos.close();

				ByteArrayOutputStream retorno = new ByteArrayOutputStream();

				FileInputStream inputStream = new FileInputStream(compactado);

				int INPUT_BUFFER_SIZE = 1024;
				byte[] temp = new byte[INPUT_BUFFER_SIZE];
				int numBytesRead = 0;

				while ((numBytesRead = inputStream.read(temp, 0,
						INPUT_BUFFER_SIZE)) != -1) {
					retorno.write(temp, 0, numBytesRead);
				}

				inputStream.close();

				leitura.delete();

				// retorno.flush();
				// retorno.close();

				retornoArray = retorno.toByteArray();

			}

			System.out.println("********************");
			System.out.println("FIM GERAÇÃO ARQUIVO");
			System.out.println("********************");

		} catch (IOException e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		} catch (Exception e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

		return retornoArray;

	}

	private void criarDadosTxtBoletimCadastro(StringBuilder boletimCadastroTxt)
			throws ControladorException {

		boletimCadastroTxt.append(Util.completaString("Gerencia Regional", 30));
		boletimCadastroTxt.append(";");

		boletimCadastroTxt.append(Util.completaString("Empresa", 50));
		boletimCadastroTxt.append(";");

		boletimCadastroTxt
				.append(Util.completaString("Numero do Contrato", 18));
		boletimCadastroTxt.append(";");

		boletimCadastroTxt.append(Util.completaString("Localidade", 30));
		boletimCadastroTxt.append(";");

		boletimCadastroTxt.append(Util.completaString("Codigo do Item", 14));
		boletimCadastroTxt.append(";");

		boletimCadastroTxt.append(Util.completaString(
				"Descricao do Item de Contrato", 100));
		boletimCadastroTxt.append(";");

		boletimCadastroTxt.append(Util.completaString("Quantidade", 10));
		boletimCadastroTxt.append(";");

		boletimCadastroTxt.append(Util.completaString("Custo Unitario", 14));
		boletimCadastroTxt.append(";");

		boletimCadastroTxt.append(Util.completaString("Valor Total", 14));
		boletimCadastroTxt.append(";");

	}

	private void criarDadosTxtBoletimCadastro(StringBuilder boletimCadastroTxt,
			RelatorioBoletimMedicaoHelper relatorioBoletimMedicaoHelper)
			throws ControladorException {

		// Início do processo de geração do arquivo txt

		// Gerência Regional
		String gerenciaRegional = "";

		if (relatorioBoletimMedicaoHelper.getGerenciaRegional() != null
				&& !relatorioBoletimMedicaoHelper.getGerenciaRegional().equals(
						"")) {

			gerenciaRegional = relatorioBoletimMedicaoHelper
					.getGerenciaRegional().toString();
		}

		boletimCadastroTxt.append(Util.completaString(gerenciaRegional, 30));
		boletimCadastroTxt.append(";");

		// Empresa
		String empresa = "";

		if (relatorioBoletimMedicaoHelper.getEmpresa() != null
				&& !relatorioBoletimMedicaoHelper.getEmpresa().equals("")) {

			empresa = relatorioBoletimMedicaoHelper.getEmpresa().toString();
		}

		boletimCadastroTxt.append(Util.completaString(empresa, 50));
		boletimCadastroTxt.append(";");

		// Número de Contrato
		String numeroContratro = "";

		if (relatorioBoletimMedicaoHelper.getEmpresa() != null
				&& !relatorioBoletimMedicaoHelper.getEmpresa().equals("")) {

			numeroContratro = relatorioBoletimMedicaoHelper.getNumeroContrato()
					.toString();
		}

		boletimCadastroTxt.append(Util.completaString(numeroContratro, 18));
		boletimCadastroTxt.append(";");

		// Localidade
		String localidade = "";

		if (relatorioBoletimMedicaoHelper.getLocalidade() != null
				&& !relatorioBoletimMedicaoHelper.getLocalidade().equals("")) {

			localidade = relatorioBoletimMedicaoHelper.getLocalidade()
					.toString();
		}

		boletimCadastroTxt.append(Util.completaString(localidade, 30));
		boletimCadastroTxt.append(";");

		// Código do Item de Contrato
		String codigoItemContrato = "";

		if (relatorioBoletimMedicaoHelper.getItemCodigo() != null
				&& !relatorioBoletimMedicaoHelper.getItemCodigo().equals("")) {

			codigoItemContrato = relatorioBoletimMedicaoHelper.getItemCodigo()
					.toString();
		}

		boletimCadastroTxt.append(Util.completaString(codigoItemContrato, 14));
		boletimCadastroTxt.append(";");

		// Descrição do Item de Contrato
		String descricaoItemContrato = "";

		if (relatorioBoletimMedicaoHelper.getItemDescricao() != null
				&& !relatorioBoletimMedicaoHelper.getItemDescricao().equals("")) {

			descricaoItemContrato = relatorioBoletimMedicaoHelper
					.getItemDescricao().toString();
		}

		boletimCadastroTxt.append(Util.completaString(descricaoItemContrato,
				100));
		boletimCadastroTxt.append(";");

		// Quantidade
		Integer quantidade = 0;

		if (relatorioBoletimMedicaoHelper.getQuantidade() != null
				&& !relatorioBoletimMedicaoHelper.getQuantidade().equals("")) {

			quantidade = relatorioBoletimMedicaoHelper.getQuantidade();
		}

		boletimCadastroTxt
				.append(Util.completaString(quantidade.toString(), 10));
		boletimCadastroTxt.append(";");

		// Custo Unitário do Item no Contrato

		BigDecimal custoUnitario = BigDecimal.ZERO;

		if (relatorioBoletimMedicaoHelper.getValor() != null
				&& !relatorioBoletimMedicaoHelper.getValor().equals("")) {

			custoUnitario = relatorioBoletimMedicaoHelper.getValor();
		}

		boletimCadastroTxt.append(Util.completaString(
				Util.formataBigDecimal(custoUnitario, 2, true), 14));
		boletimCadastroTxt.append(";");

		// Custo Unitário do Item no Contrato

		BigDecimal valorTotal = custoUnitario.multiply(new BigDecimal(
				quantidade.toString()));

		boletimCadastroTxt.append(Util.completaString(
				Util.formataBigDecimal(valorTotal, 2, true), 14));
		boletimCadastroTxt.append(";");

	}

	/**
	 * [UC-1127] - Gerar RA e OS para Anormalidade Consumo
	 * 
	 * [SB0002] - Define Data Prevista
	 * 
	 * @author Bruno Barros
	 * @date 16/02/2011
	 * 
	 * @param helper
	 * 
	 * @return
	 * @throws ControladorException
	 */
	private void definirDataPrevista(GerarRAOSAnormalidadeConsumoHelper helper)
			throws ControladorException {

		/*
		 * Caso o sistema deva considerar apenas os dias úteis no cálculo da
		 * data prevista (PARM_ICCALCULOPREVISAORADIASUTEIS com o valor um na
		 * tabela cadastro.SISTEMA_PARAMETROS)
		 */
		SistemaParametro sp = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		if (sp.getIndicadorCalculoPrevisaoRADiasUteis().intValue() == ConstantesSistema.SIM) {
			/*
			 * 
			 * 1.1.1. Data Prevista = Data válida obtida a partir da Data Atual
			 * + o número de dias previstos para a especificação do tipo de
			 * solicitação (STEP_NNDIAPRAZO da tabela
			 * atendimentopublico.SOLICITACAO_TIPO_ESPEC com
			 * STEP_ID=Especificação do Tipo de Solicitação), considerando o
			 * número de dias previstos para a especificação do tipo de
			 * solicitação como dias úteis (SEGUNDA a SEXTA, desde que não seja
			 * feriado).
			 */
			// FERIADO NACIONAL
			Collection<NacionalFeriado> colecaoFeriadosNacionais = getControladorUtil()
					.pesquisarFeriadosNacionais();

			helper.setDataPrevistaRA(Util.formatarData(Util
					.adicionarNumeroDiasUteisDeUmaData(
							Util.formatarDataSemHora(new Date()),
							helper.getNumeroDiasPrazoAtendimentoRA(),
							colecaoFeriadosNacionais, null)));
		}
	}

	/**
	 * [UCXXXX] - Obter Volume Medio Agua ou Esgoto RM4548 Método para descobrir
	 * o tipo de ligação do imóvel para poder chamar o método de
	 * obterVolumeMedioAguaEsgoto
	 * 
	 * [UC-1127] - Gerar RA e OS para Anormalidade Consumo
	 * 
	 * @author Sávio Luiz
	 * @data 23/02/2011
	 * @param imovel
	 *            (Precisa que a situação da Ligação de Água e Esgoto do imóvel
	 *            esteja carregado. HidrometroInstalaçãoHistórico da ligação de
	 *            água do imóvel também deve estar carregado)
	 * @return
	 * @throws ControladorException
	 */

	public int verificarTipoLigacao(Imovel imovel) {
		int idTipoLigacao = 1;
		// CASO O IMÓVEL SEJA PARA FATURAR ÁGUA
		if (imovel.getLigacaoAguaSituacao() != null
				&& imovel.getLigacaoAguaSituacao()
						.getIndicadorFaturamentoSituacao() != null
				&& imovel.getLigacaoAguaSituacao()
						.getIndicadorFaturamentoSituacao()
						.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
				|| (imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua()
						.getHidrometroInstalacaoHistorico() != null)) {
			idTipoLigacao = 1;
		} else {
			// CASO O IMÓVEL SEJA PARA FATURAR ESGOTO
			if (imovel.getLigacaoEsgotoSituacao() != null
					&& imovel.getLigacaoEsgotoSituacao()
							.getIndicadorFaturamentoSituacao() != null
					&& imovel.getLigacaoEsgotoSituacao()
							.getIndicadorFaturamentoSituacao()
							.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)
					|| (imovel.getLigacaoAgua() != null && imovel
							.getLigacaoAgua()
							.getHidrometroInstalacaoHistorico() != null)) {
				idTipoLigacao = 2;
			}
		}
		return idTipoLigacao;
	}

	/**
	 * Pesquisa do relatorio consultar arquivo texto leitura
	 * 
	 * @author Rafael Pinto
	 * @date 11/03/2011
	 * 
	 * @param FiltroRelatorioLeituraConsultarArquivosTextoHelper
	 * @throws ErroRepositorioException
	 */
	public Collection<ArquivoTextoRoteiroEmpresa> consultarRelatorioLeituraConsultarArquivosTexto(
			FiltroRelatorioLeituraConsultarArquivosTextoHelper helper)
			throws ControladorException {

		Collection<ArquivoTextoRoteiroEmpresa> retorno = new ArrayList<ArquivoTextoRoteiroEmpresa>();

		try {

			Collection<Object[]> colecaoObject = this.repositorioMicromedicao
					.consultarRelatorioLeituraConsultarArquivosTexto(helper);

			Iterator iteratorObject = colecaoObject.iterator();
			while (iteratorObject.hasNext()) {
				Object[] arrayObject = (Object[]) iteratorObject.next();

				ArquivoTextoRoteiroEmpresa arquivo = new ArquivoTextoRoteiroEmpresa();

				arquivo.setAnoMesReferencia((Integer) arrayObject[0]);
				arquivo.setNumeroSequenciaLeitura((Integer) arrayObject[1]);

				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				faturamentoGrupo.setId((Integer) arrayObject[2]);

				arquivo.setFaturamentoGrupo(faturamentoGrupo);

				if (arrayObject[3] != null) {
					Rota rota = new Rota();

					rota.setId((Integer) arrayObject[3]);
					rota.setCodigo((Short) arrayObject[4]);

					arquivo.setRota(rota);
				}

				arquivo.setCodigoSetorComercial1((Integer) arrayObject[5]);
				arquivo.setQuantidadeImovel((Integer) arrayObject[6]);

				if (arrayObject[7] != null) {
					arquivo.setMotivoFinalizacao((String) arrayObject[7]);
				}

				arquivo.setUltimaAlteracao((Date) arrayObject[8]);

				if (arrayObject[9] != null) {
					ServicoTipoCelular servicoTipoCelular = new ServicoTipoCelular();

					servicoTipoCelular.setId((Integer) arrayObject[9]);
					servicoTipoCelular.setDescricao((String) arrayObject[10]);

					arquivo.setServicoTipoCelular(servicoTipoCelular);
				}

				Localidade localidade = new Localidade();
				localidade.setId((Integer) arrayObject[11]);
				localidade.setDescricao((String) arrayObject[12]);

				arquivo.setLocalidade(localidade);

				SituacaoTransmissaoLeitura situacaoTransmissaoLeitura = new SituacaoTransmissaoLeitura();
				situacaoTransmissaoLeitura.setId((Integer) arrayObject[13]);
				situacaoTransmissaoLeitura
						.setDescricaoSituacao((String) arrayObject[14]);

				arquivo.setSituacaoTransmissaoLeitura(situacaoTransmissaoLeitura);

				if (arrayObject[15] != null) {

					Leiturista leiturista = new Leiturista();
					leiturista.setId((Integer) arrayObject[15]);

					if (arrayObject[16] != null) {
						Cliente cliente = new Cliente();
						cliente.setNome((String) arrayObject[16]);

						leiturista.setCliente(cliente);
					}

					if (arrayObject[17] != null) {
						Funcionario funcionario = new Funcionario();
						funcionario.setNome((String) arrayObject[17]);

						leiturista.setFuncionario(funcionario);
					}

					arquivo.setLeiturista(leiturista);
				}
				retorno.add(arquivo);

			}

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Pesquisa do relatorio consultar arquivo texto leitura
	 * 
	 * @author Rafael Pinto
	 * @date 11/03/2011
	 * 
	 * @param FiltroRelatorioLeituraConsultarArquivosTextoHelper
	 * @throws ErroRepositorioException
	 */
	public Integer consultarCountRelatorioLeituraConsultarArquivosTexto(
			FiltroRelatorioLeituraConsultarArquivosTextoHelper helper)
			throws ControladorException {

		try {

			return repositorioMicromedicao
					.consultarCountRelatorioLeituraConsultarArquivosTexto(helper);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC-1127] - Gerar RA e OS para Anormalidade Consumo
	 * 
	 * [FS0005] - Verificar existência de RA para o imóvel com a mesma
	 * especificação
	 * 
	 * @author Bruno Barros
	 * @date 16/02/2011
	 * 
	 * @param idImovel
	 * @param SolicitacaoTipoEspecificacao
	 * @return
	 * @throws ControladorException
	 */
	private boolean existeRAImovelMesmaEspecificacao(Integer idImovel,
			Integer idSolicitacaoEspecificacaoTipo) throws ControladorException {

		FiltroRegistroAtendimento filtroRAMesmaEspecificacao = new FiltroRegistroAtendimento();

		filtroRAMesmaEspecificacao.adicionarParametro(new ParametroSimples(
				FiltroRegistroAtendimento.IMOVEL_ID, idImovel));
		filtroRAMesmaEspecificacao.adicionarParametro(new ParametroSimples(
				FiltroRegistroAtendimento.SOLICITACAO_TIPO_ESPECIFICACAO,
				idSolicitacaoEspecificacaoTipo));
		filtroRAMesmaEspecificacao.adicionarParametro(new ParametroSimples(
				FiltroRegistroAtendimento.CODIGO_SITUACAO,
				RegistroAtendimento.SITUACAO_PENDENTE));
		Collection<RegistroAtendimento> colRegistroAtendimento = this
				.getControladorUtil().pesquisar(filtroRAMesmaEspecificacao,
						RegistroAtendimento.class.getName());

		return colRegistroAtendimento != null
				&& colRegistroAtendimento.size() > 0;
	}

	/**
	 * [UC-1127] - Gerar RA e OS para Anormalidade Consumo
	 * 
	 * [FS0006] - Verificar existência de unidade de destino para o registro de
	 * atendimento
	 * 
	 * @author Bruno Barros
	 * @date 16/02/2011
	 * 
	 * @param idSolicitacaoEspecificacaoTipo
	 * 
	 * @return
	 * @throws ControladorException
	 */
	private boolean unidadeDestinoPermiteAberturaRA(
			GerarRAOSAnormalidadeConsumoHelper helper)
			throws ControladorException {

		boolean retorno = false;

		UnidadeOrganizacional uo = null;

		try {
			FiltroSolicitacaoTipoEspecificacao filtroSolicitacaoTipoEspecificacao = new FiltroSolicitacaoTipoEspecificacao();

			filtroSolicitacaoTipoEspecificacao
					.adicionarParametro(new ParametroSimples(
							FiltroSolicitacaoTipoEspecificacao.ID, helper
									.getIdSolicitacaoTipoEspecificacao()));
			// filtroSolicitacaoTipoEspecificacao.adicionarParametro( new
			// ParametroNaoNulo(
			// FiltroSolicitacaoTipoEspecificacao.UNIDADE_ORGANIZACIONAL ) );
			filtroSolicitacaoTipoEspecificacao
					.adicionarCaminhoParaCarregamentoEntidade("solicitacaoTipo.solicitacaoTipoGrupo");
			filtroSolicitacaoTipoEspecificacao
					.adicionarCaminhoParaCarregamentoEntidade("unidadeOrganizacional.unidadeCentralizadora");

			Collection<SolicitacaoTipoEspecificacao> colSolicitacaoTipoEspecificacao = this
					.getControladorUtil().pesquisar(
							filtroSolicitacaoTipoEspecificacao,
							SolicitacaoTipoEspecificacao.class.getName());
			SolicitacaoTipoEspecificacao ste = (SolicitacaoTipoEspecificacao) Util
					.retonarObjetoDeColecao(colSolicitacaoTipoEspecificacao);
			helper.setIdSolicitacaoTipoGrupo(ste.getSolicitacaoTipo()
					.getSolicitacaoTipoGrupo().getId());
			helper.setNumeroDiasPrazoAtendimentoRA(ste.getDiasPrazo());
			helper.setIdSolicitacaoTipo(ste.getSolicitacaoTipo().getId());
			helper.setIdServicoTipo(ste.getServicoTipo().getId());

			uo = ste.getUnidadeOrganizacional();

			/*
			 * Caso a especificação esteja associada a uma unidade (UNID_ID com
			 * o valor diferente de nulo na tabela
			 * atendimentopublico.SOLICITACAO_TIPO_ESPEC para
			 * STEP_ID=Especificação do Tipo de Solicitação)
			 */
			if (uo != null) {
				/*
				 * Caso a unidade de destino da especificação não possa receber
				 * trâmite de registro de atendimento (UNID_ICTRAMITE=2 na
				 * tabela cadastro.UNIDADE_ORGANIZACIONAL para UNID_ID=UNID_ID
				 * da tabela atendimentopublico.SOLICITACAO_TIPO_ESPEC)
				 */
				if (uo.getIndicadorTramite() == ConstantesSistema.NAO) {
					retorno = false;
				} else {
					/*
					 * Caso contrário, atribuir a unidade de destino da
					 * especificação (UNID_ID da tabela
					 * atendimentopublico.SOLICITACAO_TIPO_ESPEC) à Unidade
					 * Destino do RA
					 */
					helper.setUnidadeOrganizacional(uo);
					retorno = true;
				}
				// Caso contrário, ou seja, a especificação não está associada a
				// uma unidade:
			} else {
				/*
				 * Caso não exista unidade de destino associada à localidade do
				 * imóvel e ao grupo do tipo de solicitação da especificação
				 * (não existe ocorrência na tabela
				 * atendimentopublico.LOCALID_SOLIC_TIPO_GRUPO para
				 * LOCA_ID=LOCA_ID da tabela cadastro.IMOVEL para
				 * IMOV_ID=IMOV_ID da tabela micromedicao.CONSUMO_HISTORICO e
				 * SOTG_ID=SOTG_ID da tabela atendimentopublico.SOLICITACAO_TIPO
				 * para SOTP_ID=SOTP_ID da tabela
				 * atendimentopublico.SOLICITACAO_TIPO_ESPEC para
				 * STEP_ID=Especificação do Tipo de Solicitação), passar para o
				 * próximo imóvel.
				 */
				uo = repositorioMicromedicao
						.unidadeDestinoAssociadaLocalidadeImovelGrupoTipoSolicitacaoEspecificacao(
								helper.getIdLocalidadeImovel(),
								helper.getIdSolicitacaoTipoGrupo());

				if (uo == null) {
					retorno = false;
					/*
					 * Caso contrário, ou seja, existe unidade de destino
					 * associada à localidade do imóvel e ao grupo do tipo de
					 * solicitação da especificação
					 */
				} else {
					/*
					 * Caso a unidade de destino associada à localidade do
					 * imóvel e ao grupo do tipo de solicitação da especificação
					 * não possa receber trâmite de registro de atendimento
					 * (UNID_ICTRAMITE=2 na tabela
					 * cadastro.UNIDADE_ORGANIZACIONAL para UNID_ID=UNID_ID da
					 * tabela atendimentopublico.LOCALID_SOLIC_TIPO_GRUPO),
					 * passar para o próximo imóvel
					 */
					if (uo.getIndicadorTramite() == ConstantesSistema.NAO) {
						retorno = false;
					} else {
						/*
						 * Caso contrário, atribuir a unidade de destino
						 * associada à localidade do imóvel e ao grupo do tipo
						 * de solicitação da especificação (UNID_ID da tabela
						 * atendimentopublico.LOCALID_SOLIC_TIPO_GRUPO) à
						 * Unidade Destino do RA
						 */
						helper.setUnidadeOrganizacional(uo);
						retorno = true;
					}
				}
			}

			if (uo != null) {

				/*
				 * 
				 * Caso a Unidade Destino do RA esteja associada a uma unidade
				 * centralizadora (UNID_IDCENTRALIZADORA com o valor diferente
				 * de nulo na tabela cadastro.UNIDADE_ORGANIZACIONAL para
				 * UNID_ID=Unidade Destino do RA)
				 */
				if (uo.getUnidadeCentralizadora() != null) {
					/*
					 * 
					 * Caso a unidade centralizadora não possa receber trâmite
					 * de registro de atendimento (UNID_ICTRAMITE=2 na tabela
					 * cadastro.UNIDADE_ORGANIZACIONAL para
					 * UNID_ID=UNID_IDCENTRALIZADORA da tabela
					 * cadastro.UNIDADE_ORGANIZACIONAL para UNID_ID=Unidade
					 * Destino do RA), passar para o próximo imóvel
					 */
					if (uo.getUnidadeCentralizadora().getIndicadorTramite() == ConstantesSistema.NAO) {
						retorno = false;
					} else {
						/*
						 * Caso contrário, atribuir a unidade centralizadora
						 * (UNID_IDCENTRALIZADORA da tabela
						 * cadastro.UNIDADE_ORGANIZACIONAL para UNID_ID=Unidade
						 * Destino do RA) à Unidade Destino do RA
						 */
						helper.setUnidadeOrganizacional(uo
								.getUnidadeCentralizadora());
						retorno = true;
					}
				}
			}

			/*
			 * 
			 * Caso a Unidade Destino do RA não esteja ativa (UNID_ICUSO=2 na
			 * tabela cadastro.UNIDADE_ORGANIZACIONAL para UNID_ID=Unidade
			 * Destino do RA), passar para o próximo imóvel
			 */
			if (helper.getUnidadeOrganizacional().getIndicadorUso() == ConstantesSistema.NAO) {
				retorno = false;
			}

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * [UC0800] - Obter Consumo Não Medido
	 * 
	 * [SB0005] - Determinar consumo mínimo da subcategoria por pontos de
	 * utilização [FS0007]  Verificar existência do consumo mínimo por
	 * subcategoria (pontos) [SB0006] - Determinar consumo mínimo da categoria
	 * por pontos de utilização
	 * 
	 * [SB0007] - Determinar consumo mínimo da subcategoria por número de
	 * moradores. [FS0006] Verificar existência do consumo mínimo por
	 * subcategoria (moradores) [SB0008] - Determinar consumo mínimo da
	 * categoria por número de moradores.
	 * 
	 * Obter o consumo mínimo associado ao ponto de utilização e a subcategoria
	 * ou a categoria informada
	 * 
	 * @author Mariana Victor
	 * @date 23/05/2011
	 * 
	 * @param areaConstruida
	 * @param anoMesReferencia
	 * @param subcategoria
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarConsumoMinimoParametro(BigDecimal numeroParametro,
			Integer anoMesReferencia, Subcategoria subcategoria,
			Categoria categoria) throws ControladorException {

		Integer consumoMinimoArea = null;

		Integer idCategoria = null;

		if (subcategoria != null) {

			idCategoria = subcategoria.getCategoria().getId();

			try {

				consumoMinimoArea = this.repositorioMicromedicao
						.pesquisarConsumoMinimoParametro(numeroParametro,
								anoMesReferencia, subcategoria.getId(), null);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

		} else {
			idCategoria = categoria.getId();
		}

		/*
		 * [FS0006]  Verificar existência do consumo mínimo por subcategoria
		 * (moradores)
		 * 
		 * [FS0007]  Verificar existência do consumo mínimo por subcategoria
		 * (pontos)
		 */
		if (subcategoria == null || consumoMinimoArea == null) {

			try {

				consumoMinimoArea = this.repositorioMicromedicao
						.pesquisarConsumoMinimoParametro(numeroParametro,
								anoMesReferencia, null, idCategoria);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

		return consumoMinimoArea;
	}

	/**
	 * [UC0000] Obter Consumo Não Medido por Parâmetro
	 * 
	 * @author Mariana Victor
	 * @date 23/05/2011
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer obterConsumoNaoMedidoPorParametro(Integer idImovel,
			Integer anoMesReferencia, Integer indicadorVolumeFixo)
			throws ControladorException {

		Integer consumoNaoMedido = 0;

		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		// [UC0801] - Obter Quantidade de Economias por Subcategoria
		Collection<Subcategoria> colecaoSubcategoria = this
				.getControladorImovel().obterQuantidadeEconomiasSubCategoria(
						idImovel);

		// 2. O sistema obtém o tipo de parâmetro que deverá ser utilizada para
		// o cálculo do consumo mínimo
		Integer codigoTipoCalculoNaoMedido = sistemaParametro
				.getCodigoTipoCalculoNaoMedido();

		if (codigoTipoCalculoNaoMedido.equals(new Integer(2))) {
			// [FS0001] - Verificar "Pontos de Utilização" Não Informado.
			Short pontosUtilizacaoImovel = this
					.verificarPontoUtilizacaoNaoInformada(idImovel);

			if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {

				Iterator iterator = colecaoSubcategoria.iterator();

				while (iterator.hasNext()) {

					Subcategoria subcategoria = (Subcategoria) iterator.next();

					Integer quantidadeSubCategoria = null;

					try {

						quantidadeSubCategoria = this.repositorioMicromedicao
								.pesquisarConsumoMinimoSubCategoria(subcategoria
										.getId());

					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}

					Integer consumoMinimo;

					if (quantidadeSubCategoria != null
							&& quantidadeSubCategoria.compareTo(new Integer(0)) != 0) {

						consumoMinimo = this.pesquisarConsumoMinimoParametro(
								pontosUtilizacaoImovel, anoMesReferencia,
								subcategoria, null);

					} else {

						consumoMinimo = this.pesquisarConsumoMinimoParametro(
								pontosUtilizacaoImovel, anoMesReferencia, null,
								subcategoria.getCategoria());

					}

					// Multiplica o consumo mínimo pela quantidade de economias
					// da subcategoria.
					consumoNaoMedido = consumoNaoMedido
							+ (consumoMinimo * subcategoria
									.getQuantidadeEconomias());
				}
			}
		} else if (codigoTipoCalculoNaoMedido.equals(new Integer(3))) {
			// [FS0002] - Verificar Número de Moradores Não Informado.
			Short numeroMoradores = this
					.verificarNumeroMoradoresNaoInformado(idImovel);

			if (colecaoSubcategoria != null && !colecaoSubcategoria.isEmpty()) {

				Iterator iterator = colecaoSubcategoria.iterator();

				while (iterator.hasNext()) {

					Subcategoria subcategoria = (Subcategoria) iterator.next();

					Integer quantidadeSubCategoria = null;

					try {

						quantidadeSubCategoria = this.repositorioMicromedicao
								.pesquisarConsumoMinimoSubCategoria(subcategoria
										.getId());

					} catch (ErroRepositorioException e) {
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}

					Integer consumoMinimo;

					if (quantidadeSubCategoria != null
							&& quantidadeSubCategoria.compareTo(new Integer(0)) != 0) {

						consumoMinimo = this
								.pesquisarConsumoMinimoParametroNumeroMoradores(
										numeroMoradores, anoMesReferencia,
										subcategoria, null);

					} else {

						consumoMinimo = this
								.pesquisarConsumoMinimoParametroNumeroMoradores(
										numeroMoradores, anoMesReferencia,
										null, subcategoria.getCategoria());

					}

					// Multiplica o consumo mínimo pela quantidade de economias
					// da subcategoria.
					consumoNaoMedido = consumoNaoMedido
							+ (consumoMinimo * subcategoria
									.getQuantidadeEconomias());
				}
			}
		}

		return consumoNaoMedido;
	}

	/**
	 * [UC0000] Obter Consumo Não Medido por Parâmetro [FS0001] - Verificar
	 * "Pontos de Utilização" Não Informado.
	 * 
	 * @author Mariana Victor
	 * @date 23/05/2011
	 * 
	 * @param idImovel
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	protected Short verificarPontoUtilizacaoNaoInformada(Integer idImovel)
			throws ControladorException {

		Short pontosUtilizacaoImovel = null;

		try {

			pontosUtilizacaoImovel = this.repositorioImovel
					.pesquisarPontosUtilizacaoImovel(idImovel);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		/*
		 * 1. Caso não exista pontos de utilização no imóvel
		 * (IMOV_NNPONTOUTILIZACAO da tabela IMOVEL com valor igual a nulo),
		 * 1.1. O sistema deverá atribuir o valor 1(um) para ao ponto de
		 * utilização do imóvel.
		 */
		if (pontosUtilizacaoImovel == null) {
			pontosUtilizacaoImovel = new Short("1");
		}

		return pontosUtilizacaoImovel;
	}

	/**
	 * [UC0000] Obter Consumo Não Medido por Parâmetro
	 * 
	 * @author Mariana Victor
	 * @date 23/05/2011
	 * 
	 * @param areaConstruida
	 * @param anoMesReferencia
	 * @param subcategoria
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarConsumoMinimoParametro(Short pontosUtilizacao,
			Integer anoMesReferencia, Subcategoria subcategoria,
			Categoria categoria) throws ControladorException {

		Integer consumoMinimoArea = null;

		Integer idCategoria = null;

		if (subcategoria != null) {

			idCategoria = subcategoria.getCategoria().getId();

			try {

				consumoMinimoArea = this.repositorioMicromedicao
						.pesquisarConsumoMinimoParametro(pontosUtilizacao,
								anoMesReferencia, subcategoria.getId(), null);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

		} else {
			idCategoria = categoria.getId();
		}

		// Caso não seja encontrado o consumo para subcategoria, será utilizado
		// o consumo da categoria.
		if (subcategoria == null || consumoMinimoArea == null) {

			try {

				consumoMinimoArea = this.repositorioMicromedicao
						.pesquisarConsumoMinimoParametro(pontosUtilizacao,
								anoMesReferencia, null, idCategoria);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

		return consumoMinimoArea;
	}

	/**
	 * [UC0000] Obter Consumo Não Medido por Parâmetro [FS0002] - Verificar
	 * Número de Moradores Não Informado.
	 * 
	 * @author Mariana Victor
	 * @date 23/05/2011
	 * 
	 * @param idImovel
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	protected Short verificarNumeroMoradoresNaoInformado(Integer idImovel)
			throws ControladorException {

		Short numeroMoradores = null;

		try {

			numeroMoradores = this.repositorioImovel
					.pesquisarNumeroMoradoresImovel(idImovel);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		/*
		 * 1. Caso não exista número de moradores no imóvel (IMOV_NNMORADOR da
		 * tabela IMOVEL com valor igual a nulo), 1.1. O sistema deverá atribuir
		 * o valor 1(um) para ao número de morador do imóvel.
		 */
		if (numeroMoradores == null) {
			numeroMoradores = new Short("1");
		}

		return numeroMoradores;
	}

	/**
	 * [UC0000] Obter Consumo Não Medido por Parâmetro
	 * 
	 * @author Mariana Victor
	 * @date 23/05/2011
	 * 
	 * @param areaConstruida
	 * @param anoMesReferencia
	 * @param subcategoria
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarConsumoMinimoParametroNumeroMoradores(
			Short numeroMoradores, Integer anoMesReferencia,
			Subcategoria subcategoria, Categoria categoria)
			throws ControladorException {

		Integer consumoMinimoNumeroMoradores = null;

		Integer idCategoria = null;

		if (subcategoria != null) {

			idCategoria = subcategoria.getCategoria().getId();

			try {

				consumoMinimoNumeroMoradores = this.repositorioMicromedicao
						.pesquisarConsumoMinimoParametro(numeroMoradores,
								anoMesReferencia, subcategoria.getId(), null);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

		} else {
			idCategoria = categoria.getId();
		}

		// Caso não seja encontrado o consumo para subcategoria, será utilizado
		// o consumo da categoria.
		if (subcategoria == null || consumoMinimoNumeroMoradores == null) {

			try {

				consumoMinimoNumeroMoradores = this.repositorioMicromedicao
						.pesquisarConsumoMinimoParametro(numeroMoradores,
								anoMesReferencia, null, idCategoria);

			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

		return consumoMinimoNumeroMoradores;
	}

	/**
	 * <b>[UC1180] Relatório Imóveis com Leituristas</b>:
	 * 
	 * <ul>
	 * <li>
	 * <b>[SB0001] Gerar Relatório do Tipo 1</b>: Quantitativo de imóveis com
	 * leituras através da WEB</li>
	 * <li>
	 * <b>[SB0002] Gerar Relatório do Tipo 2</b>: Quantitativo de imóveis sem
	 * leituras através da ISC e WEB</li>
	 * <li>
	 * <b>[SB0003] Gerar Relatório do Tipo 3</b>: Quantitativo de imóveis que
	 * estão na rota mas não foram recebidos através da ISC</p></li>
	 * </ul>
	 * 
	 * @author Magno Gouveia
	 * @date 06/06/2011
	 * 
	 * @param FiltrarRelatorioImoveisComLeiturasHelper
	 * 
	 * @return Collection<RelatorioImoveisComLeiturasQuantitativosBean>
	 * @throws ControladorException
	 */
	public Collection<RelatorioImoveisComLeiturasQuantitativosBean> filtrarRelatorioImoveisComLeiturasQuantitativos(
			FiltrarRelatorioImoveisComLeiturasHelper helper,
			int parametroPersistirRelatorio) throws ControladorException {

		Collection<Object[]> colecaoImoveisComLeituras = new ArrayList<Object[]>();
		Collection<RelatorioImoveisComLeiturasQuantitativosBean> beans = new ArrayList<RelatorioImoveisComLeiturasQuantitativosBean>();

		try {
			colecaoImoveisComLeituras = this.repositorioMicromedicao
					.filtrarRelatorioImoveisComLeiturasQuantitativos(helper,
							parametroPersistirRelatorio);

			if (colecaoImoveisComLeituras != null
					&& !colecaoImoveisComLeituras.isEmpty()) {

				String mesAnoReferencia = "";
				if (helper.getMesAnoReferencia() != null) {
					mesAnoReferencia = Util.formatarAnoMesParaMesAno(helper
							.getMesAnoReferencia());
				}

				Integer grupoFaturamento = 0;
				if (helper.getGrupoFaturamento() != null) {
					grupoFaturamento = helper.getGrupoFaturamento();
				}

				Iterator it = colecaoImoveisComLeituras.iterator();

				while (it.hasNext()) {
					Object[] campos = (Object[]) it.next();

					// Empresa
					String empresa = "";
					if (campos[0] != null) {
						empresa = (String) campos[0];
					}

					// Localidade
					String localidade = "";
					if (campos[1] != null && campos[2] != null) {
						localidade = (Integer) campos[1] + " - "
								+ (String) campos[2];
					}

					// Setor Comercial
					String setorComercial = "";
					if (campos[3] != null && campos[4] != null) {
						setorComercial = (Integer) campos[3] + " - "
								+ (String) campos[4];
					}

					// Rota
					Integer rota = 0;
					if (campos[5] != null) {
						rota = (Integer) campos[5];
					}

					// clienteLeiturista ou funcionarioLeiturista
					String leiturista = "";
					if (campos[6] != null) {
						leiturista = (String) campos[6];
					} else if (campos[7] != null) {
						leiturista = (String) campos[7];
					}

					// Quantidade Imoveis Leituras WEB
					Integer qtdImoveisLeiturasWEB = 0;
					if (campos[8] != null) {
						qtdImoveisLeiturasWEB = (Integer) campos[8];
					}

					beans.add(new RelatorioImoveisComLeiturasQuantitativosBean(
							mesAnoReferencia, grupoFaturamento, empresa,
							localidade, setorComercial, rota, leiturista,
							qtdImoveisLeiturasWEB));
				}
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return beans;
	}

	/**
	 * <b>[UC1180] Relatório Imóveis com Leituristas</b>:
	 * 
	 * <ul>
	 * <li>
	 * <b>[SB0004] Gerar Relatório do Tipo 4</b>: Relação de imóveis com
	 * leituras não recebidas através da ISC</b></li>
	 * <li>
	 * <b>[SB0005] Gerar Relatório do Tipo 5</b>: Relação de imóveis não medidos
	 * que não estão na rota de ISC</b></li>
	 * <li>
	 * <b>[SB0006] Gerar Relatório do Tipo 6</b>: Relação de imóveis medidos que
	 * não estão na rota de ISC</b></li>
	 * </ul>
	 * 
	 * @author Magno Gouveia
	 * @date 10/06/2011
	 * 
	 * @param helper
	 * 
	 * @return Collection<RelatorioImoveisComLeiturasRelacaoBean>
	 * @throws ControladorException
	 */
	public Collection<RelatorioImoveisComLeiturasRelacaoBean> filtrarRelatorioImoveisComLeiturasRelacao(
			FiltrarRelatorioImoveisComLeiturasHelper helper,
			int parametroPersistirRelatorio) throws ControladorException {
		Collection<Object[]> colecaoImoveisComLeituras = new ArrayList<Object[]>();
		Collection<RelatorioImoveisComLeiturasRelacaoBean> beans = new ArrayList<RelatorioImoveisComLeiturasRelacaoBean>();

		try {
			colecaoImoveisComLeituras = this.repositorioMicromedicao
					.filtrarRelatorioImoveisComLeiturasRelacao(helper,
							parametroPersistirRelatorio);

			if (colecaoImoveisComLeituras != null
					&& !colecaoImoveisComLeituras.isEmpty()) {

				String mesAnoReferencia = "";
				if (helper.getMesAnoReferencia() != null) {
					mesAnoReferencia = Util.formatarAnoMesParaMesAno(helper
							.getMesAnoReferencia());
				}

				Integer grupoFaturamento = 0;
				if (helper.getGrupoFaturamento() != null) {
					grupoFaturamento = helper.getGrupoFaturamento();
				}

				Iterator it = colecaoImoveisComLeituras.iterator();

				while (it.hasNext()) {
					Object[] campos = (Object[]) it.next();

					// Empresa
					String empresa = "";
					if (campos[0] != null) {
						empresa = (String) campos[0];
					}

					// Localidade
					String localidade = "";
					if (campos[1] != null && campos[2] != null) {
						localidade = (Integer) campos[1] + " - "
								+ (String) campos[2];
					}

					// Setor Comercial
					String setorComercial = "";
					if (campos[3] != null && campos[4] != null) {
						setorComercial = (Integer) campos[3] + " - "
								+ (String) campos[4];
					}

					// Rota
					Integer rota = 0;
					if (campos[5] != null) {
						rota = (Integer) campos[5];
					}

					// clienteLeiturista ou funcionarioLeiturista
					String leiturista = "";
					if (campos[6] != null) {
						leiturista = (String) campos[6];
					} else if (campos[7] != null) {
						leiturista = (String) campos[7];
					}

					// Quantidade Imoveis Leituras WEB
					String imovel = "";
					if (campos[8] != null) {
						imovel = (String) campos[8];
					}

					beans.add(new RelatorioImoveisComLeiturasRelacaoBean(
							mesAnoReferencia, grupoFaturamento, empresa,
							localidade, setorComercial, rota, leiturista,
							imovel));
				}
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return beans;
	}

	/**
	 * <b>[UC1180] Relatório Imóveis com Leituristas</b>:
	 * 
	 * <ul>
	 * <li>
	 * <b>[SB0007] Gerar Relatório do Tipo 7</b>: Quantitativo de imóveis com
	 * leituras enviado e recebidos</b></li>
	 * </ul>
	 * 
	 * @author Magno Gouveia
	 * @date 13/06/2011
	 * 
	 * @param helper
	 * 
	 * @return Collection<RelatorioImoveisComLeiturasTipo7Bean>
	 * @throws ControladorException
	 */
	public Collection<RelatorioImoveisComLeiturasTipo7Bean> filtrarRelatorioImoveisComLeiturasTipo7(
			FiltrarRelatorioImoveisComLeiturasHelper helper)
			throws ControladorException {
		Collection<Object[]> colecaoImoveisComLeituras = new ArrayList<Object[]>();
		Collection<RelatorioImoveisComLeiturasTipo7Bean> beans = new ArrayList<RelatorioImoveisComLeiturasTipo7Bean>();

		try {
			colecaoImoveisComLeituras = this.repositorioMicromedicao
					.filtrarRelatorioImoveisComLeiturasTipo7(helper);

			if (colecaoImoveisComLeituras != null
					&& !colecaoImoveisComLeituras.isEmpty()) {

				String mesAnoReferencia = "";
				if (helper.getMesAnoReferencia() != null) {
					mesAnoReferencia = Util.formatarAnoMesParaMesAno(helper
							.getMesAnoReferencia());
				}

				Integer grupoFaturamento = 0;
				if (helper.getGrupoFaturamento() != null) {
					grupoFaturamento = helper.getGrupoFaturamento();
				}

				Iterator it = colecaoImoveisComLeituras.iterator();

				while (it.hasNext()) {
					Object[] campos = (Object[]) it.next();

					// Empresa
					String empresa = "";
					if (campos[0] != null) {
						empresa = (String) campos[0];
					}

					Integer rota = 0;
					if (campos[1] != null) {
						rota = (Integer) campos[1];
					}

					String leiturista = "";
					if (campos[2] != null) {
						leiturista = (String) campos[2];
					}

					Integer enviados = 0;
					if (campos[3] != null) {
						enviados = (Integer) campos[3];
					}

					Integer recebidos = 0;
					if (campos[4] != null) {
						recebidos = (Integer) campos[4];
					}

					Integer diferencaRecebidosEnviados = 0;
					if (campos[5] != null) {
						diferencaRecebidosEnviados = (Integer) campos[5];
					}

					Integer qtdMedidosNaoImpressos = 0;
					if (campos[6] != null) {
						qtdMedidosNaoImpressos = (Integer) campos[6];
					}

					Integer qtdNaoMedidosNaoImpressos = 0;
					if (campos[7] != null) {
						qtdNaoMedidosNaoImpressos = (Integer) campos[7];
					}

					beans.add(new RelatorioImoveisComLeiturasTipo7Bean(
							mesAnoReferencia, grupoFaturamento, empresa, rota,
							leiturista, enviados, recebidos,
							diferencaRecebidosEnviados, qtdMedidosNaoImpressos,
							qtdNaoMedidosNaoImpressos));
				}
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return beans;
	}

	/**
	 * [UC0713] Emitir Ordem de Serviço Seletiva [SB0002] Gerar TXT
	 * 
	 * @author Vivianne Sousa
	 * @date 29/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarUltimoConsumoFaturadoImovel(Integer idImovel,
			Integer tipoLigacao) throws ControladorException {

		try {
			return repositorioMicromedicao
					.pesquisarUltimoConsumoFaturadoImovel(idImovel, tipoLigacao);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0713] Emitir Ordem de Serviço Seletiva [SB0002] Gerar TXT
	 * 
	 * @author Vivianne Sousa
	 * @date 29/06/2011
	 * 
	 * @param idImovel
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosHidrometro(Integer idImovel)
			throws ControladorException {

		try {
			return repositorioMicromedicao.pesquisarDadosHidrometro(idImovel);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [MA2011061011]
	 * 
	 * @author Paulo Diniz
	 * @date 02/07/2011
	 * 
	 * @param idHidrometro
	 * 
	 * @return HidrometroMovimentado
	 * @throws ControladorException
	 */
	public Date pesquisarMaiorDataHidrometroMovimentado(Integer idHidrometro)
			throws ControladorException {

		try {
			return repositorioMicromedicao
					.pesquisarMaiorDataHidrometroMovimentado(idHidrometro);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [MA2011061010]
	 * 
	 * @param faixaInicial
	 *            Descricao do parametro
	 * @param faixaFinal
	 *            Descricao do parametro
	 * @return Description of the Return Value
	 * @exception ControladorException
	 *                Description of the Exception
	 */
	public Integer pesquisarNumeroHidrometroMovimentacaoPorFaixaCount(
			String fixo, String faixaInicial, String faixaFinal)
			throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquisarNumeroHidrometroMovimentacaoPorFaixaCount(fixo,
							faixaInicial, faixaFinal);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [MA2011061010]
	 * 
	 * pesquisa uma colecao de HidrometroMovimentacao
	 * 
	 * @param faixaInicial
	 *            Descricao do parametro
	 * @param faixaFinal
	 *            Descricao do parametro
	 * @return Description of the Return Value
	 * @exception ErroRepositorioException
	 *                Description of the Exception
	 */
	public Collection pesquisarNumeroHidrometroMovimentacaoPorFaixaPaginacao(
			String faixaInicial, String faixaFinal, Integer numeroPagina)
			throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquisarNumeroHidrometroMovimentacaoPorFaixaPaginacao(
							faixaInicial, faixaFinal, numeroPagina);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [MA2011061010]
	 * 
	 * pesquisa uma colecao de HidrometroMovimentacao
	 * 
	 * @param faixaInicial
	 *            Descricao do parametro
	 * @param faixaFinal
	 *            Descricao do parametro
	 * @return Description of the Return Value
	 * @exception ErroRepositorioException
	 *                Description of the Exception
	 */
	public Collection pesquisarNumeroHidrometroMovimentacaoPorFaixa(
			String faixaInicial, String faixaFinal) throws ControladorException {
		try {
			return repositorioMicromedicao
					.pesquisarNumeroHidrometroMovimentacaoPorFaixa(
							faixaInicial, faixaFinal);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo [SB0007-Rateio Por Área Comum] RM3221
	 * - analista:Claudio Lira
	 * 
	 * @author Vivianne Sousa
	 * @date 16/08/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void efetuarRateioPorAreaComum(Collection<Imovel> imoveisVinculados,
			Integer anoMesFaturamento, int quantidadeEconomiasAguasMedidas,
			Integer idConsumoHistoricoLigacaoAgua, int consumoAguaSerRateada,
			Integer idPocoImovelCondominio, Integer consumoMinimoLigacao,
			Integer consumoLigacaoAguaImovelCondominio)
			throws ControladorException {

		try {

			Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados
					.iterator();
			while (iteratorImoveisVinculados.hasNext()) {
				// Recupera o imóvel vinculado
				Imovel imovelVinculado = iteratorImoveisVinculados.next();

				// 1.O sistema identifica o imóvel que tem indicação
				// de área comum para receber o rateio de consumo
				if (imovelVinculado.getIndicadorImovelAreaComum().equals(
						ConstantesSistema.SIM)) {

					// Recupera o consumo histórico do imóvel vinculado para ser
					// atualizado
					ConsumoHistorico consumoHistorico = this.repositorioMicromedicao
							.obterConsumoHistoricoImovel(
									imovelVinculado.getId(), anoMesFaturamento,
									LigacaoTipo.LIGACAO_AGUA);

					// Caso o indicador de faturamento seja 1
					// atualiza os dados do consumo histórico do imóvel
					// vinculado.
					if (consumoHistorico
							.getIndicadorFaturamento()
							.toString()
							.equals(ConstantesSistema.INDICADOR_USO_ATIVO
									.toString())) {

						// 2.1. CSHI_NNCONSUMORATEIO = Consumo de Água a Ser
						// Rateado
						Integer consumoRateio = consumoAguaSerRateada;
						consumoHistorico.setConsumoRateio(consumoRateio);

						// 2.2. Caso o consumo faturado seja inferior ao consumo
						// rateio
						// CSHI_NNCONSUMORATEIO = CSHI_NNCONSUMOFATURADOMES *
						// (-1)
						// assegurando, desse modo, que o consumo a ser cobrado
						// não será um valor negativo;
						if (consumoHistorico.getNumeroConsumoFaturadoMes() != null
								&& consumoHistorico.getConsumoRateio() != null
								&& consumoHistorico
										.getNumeroConsumoFaturadoMes()
										.intValue() < (consumoHistorico
										.getConsumoRateio().intValue() * -1)) {

							consumoHistorico.setConsumoRateio(new Integer(
									consumoHistorico
											.getNumeroConsumoFaturadoMes()
											.intValue()
											* -1));
						}

						// Caso o número do consumo faturado do mês seja
						// diferente de nulo o consumo faturado do mês vai ser
						// igual a
						// ele mais o consumo de rateio.
						Integer numeroConsumoFaturadoMesAtual = consumoHistorico
								.getNumeroConsumoFaturadoMes();
						Integer numeroConsumoFaturadoMes = 0;
						if (numeroConsumoFaturadoMesAtual != null) {
							numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual;
						}
						if (consumoHistorico.getConsumoRateio() != null) {
							numeroConsumoFaturadoMes = numeroConsumoFaturadoMes
									+ consumoHistorico.getConsumoRateio();
						}

						// Obter quantidade de economias do imóvel condominio
						Short quantidadeEconomiasImovel = imovelVinculado
								.getQuantidadeEconomias();

						// caso a quantidade de economias seja nulo atribuir o
						// valor zero
						if (quantidadeEconomiasImovel == null) {
							quantidadeEconomiasImovel = 0;
						}

						// Caso o imóvel condomínio possua poço e o consumo da
						// ligação
						// de água do imóvel condomínio para o mês de
						// faturamento
						// corrente não seja superior a soma dos consumos
						// mínimos
						// calculados no passo 2.2.5 do fluxo principal.
						if ((idPocoImovelCondominio != null && idPocoImovelCondominio
								.intValue() != 0)
								&& (consumoLigacaoAguaImovelCondominio != null && (consumoLigacaoAguaImovelCondominio
										.intValue() < consumoMinimoLigacao
										.intValue()))) {

							numeroConsumoFaturadoMes = (consumoLigacaoAguaImovelCondominio / quantidadeEconomiasAguasMedidas)
									* quantidadeEconomiasImovel;
						}

						// Atualiza os dados do consumo histórico
						consumoHistorico
								.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
						consumoHistorico
								.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
						consumoHistorico
								.setConsumoImovelCondominio(idConsumoHistoricoLigacaoAgua);
						consumoHistorico.setUltimaAlteracao(new Date());
						this.getControladorBatch().atualizarObjetoParaBatch(
								consumoHistorico);
					}
				} else {
					ConsumoHistorico consumoHistorico = this.repositorioMicromedicao
							.obterConsumoHistoricoImovel(
									imovelVinculado.getId(), anoMesFaturamento,
									LigacaoTipo.LIGACAO_AGUA);

					// Caso o indicador de faturamento seja 1
					// atualiza os dados do consumo histórico do imóvel
					// vinculado.
					if (consumoHistorico
							.getIndicadorFaturamento()
							.toString()
							.equals(ConstantesSistema.INDICADOR_USO_ATIVO
									.toString())) {
						consumoHistorico
								.setConsumoImovelVinculadosCondominio(consumoHistorico
										.getNumeroConsumoFaturadoMes());
						consumoHistorico.setConsumoRateio(new Integer(0));
						consumoHistorico
								.setConsumoImovelCondominio(idConsumoHistoricoLigacaoAgua);
						consumoHistorico.setUltimaAlteracao(new Date());
						this.getControladorBatch().atualizarObjetoParaBatch(
								consumoHistorico);
					}
				}

			}
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @author Magno Gouveia
	 * @since 02/09/2011
	 * @return
	 */
	private boolean anoMesInicioSuperiorAnoMesMovimento(Integer idImovel,
			Integer idFaturamentoSituacao, Integer anoMesMovimento)
			throws ControladorException {
		boolean retorno = false;

		try {
			Integer anoMesFaturamentoSituacaoInicio = this.repositorioMicromedicao
					.pesquisarAnoMesFaturamentoSituacaoInicio(idImovel,
							idFaturamentoSituacao);

			if (anoMesFaturamentoSituacaoInicio != null
					&& anoMesFaturamentoSituacaoInicio
							.compareTo(anoMesMovimento) == 1) {
				retorno = true;
			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return retorno;
	}

	/**
	 * [UC0840] - Atualizar Faturamento do Movimento Celular
	 * 
	 * @author Raphael Rossiter
	 * @date 27/09/2011
	 * 
	 * @return [0] = id do consumo historico, [1] = consumo faturado no mês, [2]
	 *         = tipo de poço do imóvel
	 * @throws ControladorException
	 */
	public Object[] obterConsumoLigacaoAguaOuEsgotoDoImovel(Integer idImovel,
			Integer anoMesFaturamento, Integer idLigacaoTipo)
			throws ControladorException {

		Object[] retorno = null;

		try {

			retorno = (Object[]) this.repositorioMicromedicao
					.obterConsumoLigacaoAguaOuEsgotoDoImovel(idImovel,
							anoMesFaturamento, idLigacaoTipo);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Método que obtem o consumo do imóvel não medido,
	 * através da verificação do parâmetro que define
	 * como será o cálculo de consumo para imóvel
	 * não medido.
	 * 
	 * @param imovel
	 * @return consumoNaoMedido
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public int obterConsumoNaoMedido(Imovel imovel) throws ControladorException {

		/*Obtém parâmetro "Não Medido por Tarifa de Consumo", se for sim o consumo minino para imoveis
		* não medidos será igual ao consumo definido no sistema(por categoria ou subcategoria), ou seja,
		* será calculado pela tarifa de consumo, se for não, entao o consumo minimo será o da subcategoria
		*/
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			
		if (sistemaParametro.getIndicadorNaoMedidoTarifa().equals(ConstantesSistema.SIM)){
			return obterConsumoMinimoLigacao(imovel, null);
		} else{
			return this.obterConsumoNaoMedidoSemTarifa(imovel.getId(), sistemaParametro
			.getAnoMesFaturamento());
		}
	}
	

	private void verificarAnormalidadeDeConsumo(Imovel imovel,
			ConsumoHistorico consumoHistoricoEsgoto,
			FaturamentoGrupo faturamentoGrupo,
			MedicaoHistorico medicaoHistoricoPoco, MedicaoTipo medicaoTipo,
			int[] consumoMedioHidrometro, int leituraAnterior)
			throws ControladorException {
		// Obtém a quantidade de economias por categoria
		Collection colecaoCategoria = getControladorImovel()
				.obterQuantidadeEconomiasCategoria(imovel);

		consumoHistoricoEsgoto.setImovel(imovel);
		// [SB0014] - Verificar Estouro de Consumo
		if (!verificarEstouroConsumo(consumoHistoricoEsgoto,
				consumoMedioHidrometro, consumoMedioHidrometro, faturamentoGrupo, 
				medicaoTipo, colecaoCategoria,
				medicaoHistoricoPoco, leituraAnterior)) {

			// [SB0015] - Verificar Alto Consumo
			verificarAltoConsumo(consumoHistoricoEsgoto, colecaoCategoria, 
					imovel, faturamentoGrupo,consumoMedioHidrometro, 
					medicaoTipo, medicaoHistoricoPoco);
		}

		if ((medicaoHistoricoPoco.getLeituraSituacaoAtual().getId()
				.intValue() == LeituraSituacao.CONFIRMADA.intValue() || medicaoHistoricoPoco
				.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.REALIZADA
				.intValue())
				&& medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() == null) {

			// [SB0016] - Verificar Baixo Consumo
			verificarBaixoConsumo(consumoHistoricoEsgoto,
					colecaoCategoria,imovel, faturamentoGrupo,
					consumoMedioHidrometro, medicaoTipo,
					medicaoHistoricoPoco);
		}
	}
	
	/**
	 *
	 * Adição do médoto pesquisarImovelHidrometroInstaladoMaiorDataInstalacao()
	 * 
	 * Pesquisa o imóvel no qual o hidrômetro está instalado por maior data de instalação
	 */
	
	public String pesquisarImovelHidrometroInstaladoMaiorDataInstalacao(
			Integer idHidrometro) throws ControladorException {

		String idImovel = "";
		Object[] dadosHidrometro = null;

		try {

			dadosHidrometro = repositorioMicromedicao
					.pesquisarImovelHidrometroInstaladoMaiorDataInstalacao(idHidrometro);

			if (dadosHidrometro != null) {

				// Id do Imóvel
				if (dadosHidrometro[0] != null) { // 0
					idImovel = ((Integer) dadosHidrometro[0]).toString();
				}
				// Id da Ligação de Água
				if (dadosHidrometro[1] != null) { // 1
					idImovel = ((Integer) dadosHidrometro[1]).toString();
				}
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return idImovel;
	}
	
	/**
	 * 
	 * Alteracao feita para a rota dividida não finalizar os imoveis por IMEI, 
	 * e sim, pelo numero do arquivo dividido.
	 */
	/**
	 * Metodo para atualizar a rota dividida por partes
	 * 
	 * @author Pamela Gatinho
	 * @date 04/02/2011
	 * 
	 * @param idRota
	 * @param anoMesFaturamento
	 * @param numeroSequenciaArquivo
	 * @param situacaoAnterior
	 * @param situacaoNova
	 * @throws ControladorException
	 */
	public void atualizarArquivoTextoDividido(Integer idRota, Integer anoMesFaturamento, Integer numeroSequenciaArquivo, 
			int situacaoAnterior, int situacaoNova) throws ControladorException {
		try {
			this.repositorioMicromedicao.atualizarArquivoTextoDividido(idRota, anoMesFaturamento,
					numeroSequenciaArquivo, situacaoAnterior, situacaoNova);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}
	
	/**
	 * 
	 * Criação do método para obter uma rota. 
	 */
	/**
	 * Método para buscar uma rota pelo id
	 * 
	 * @author Pamela Gatinho
	 * @date 14/04/2011
	 * 
	 * @param idRota 
	 * @throws ControladorException
	 */
	public Rota pesquisarRota(Integer idRota) throws ControladorException {
		try {
			return this.repositorioMicromedicao.pesquisarRota(idRota);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	/**
	 * 
	 * Pamela Gatinho - 06/06/2011
	 * Adicionando o método para verificar se houve
	 * substituicao de hidrometro no período da leitura
	 * anterior faturada até a data atual
	 */
	public boolean verificarInstalacaoSubstituicaoHidrometro(Integer idImovel, MedicaoTipo medicaoTipo) 
		throws ControladorException{
		try {
			
			Date dataLeituraAnteriorFaturada = this.obterDataLeituraAnterior(idImovel, medicaoTipo);
			Date dataInstalacaoHidrometro = this.obterDataInstalacaoHidrometro(idImovel);
			
			if ( (dataLeituraAnteriorFaturada != null && dataInstalacaoHidrometro != null)
					&& (
						((Util.compararData(dataInstalacaoHidrometro, new Date()) < 0) && (Util.compararData(dataInstalacaoHidrometro, dataLeituraAnteriorFaturada) > 0))
						|| (Util.compararData(dataInstalacaoHidrometro, dataLeituraAnteriorFaturada) == 0)
					    )) {
				
				return true;
			} 
			
		} catch (ControladorException e) {
			e.printStackTrace();
		}
		return false;
	}
	
	/**
	 * 
	 * Pamela Gatinho - 06/06/2011
	 * Método para consultar a leitura anterior 
	 * faturada do imóvel 
	 */
	private Date obterDataLeituraAnterior(Integer idImovel,
			MedicaoTipo medicaoTipo) throws ControladorException {
		
		Date dataLeituraFaturada = null;
		
		FaturamentoGrupo faturamentoGrupo = getControladorImovel().pesquisarGrupoImovel(idImovel);
		
		Integer anoMesReferencia = faturamentoGrupo.getAnoMesReferencia();
		
		Integer anoMesReferenciaAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia, 1);
		
		String filtroPoTipoMedicao = "";

		if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA
				.intValue()) {
			filtroPoTipoMedicao = FiltroMedicaoHistorico.LIGACAO_AGUA_ID;
		} else {
			filtroPoTipoMedicao = FiltroMedicaoHistorico.IMOVEL_ID;
		}

		FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();
		filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
				filtroPoTipoMedicao, idImovel));
		filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
				FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO,
				anoMesReferencia));
		Collection<MedicaoHistorico> colMedicaoHistoricoMenos1Mes = getControladorUtil()
				.pesquisar(filtroMedicaoHistorico,
						MedicaoHistorico.class.getName());
		MedicaoHistorico medicaoHistoricoAtual = (MedicaoHistorico) Util
				.retonarObjetoDeColecao(colMedicaoHistoricoMenos1Mes);

		if (medicaoHistoricoAtual != null && !medicaoHistoricoAtual.equals("")) {
			dataLeituraFaturada = medicaoHistoricoAtual.getDataLeituraAnteriorFaturamento();
		} else {
			Imovel imovel = new Imovel();
			imovel.setId(idImovel);
			
			Collection colecaoDadosMedicaoHistorico = this.obterDadosTiposMedicao(imovel, anoMesReferenciaAnterior);
			
			if (colecaoDadosMedicaoHistorico != null && !colecaoDadosMedicaoHistorico.isEmpty()){
				
				Iterator iterator = colecaoDadosMedicaoHistorico.iterator();
					
				while(iterator.hasNext()){
						
					Object[] arrayMedicaoHistorico = (Object[]) iterator.next();
					
					if (arrayMedicaoHistorico[4] != null) {
						dataLeituraFaturada = (Date) arrayMedicaoHistorico[4];
					}
						
				}
			}
		}
		return dataLeituraFaturada;

	}
	
	/**
	 * 
	 * Pamela Gatinho - 06/06/2011
	 * Método para consultar a leitura anterior 
	 * faturada do imóvel 
	 */
	private Date obterDataInstalacaoHidrometro(Integer idImovel) throws ControladorException {
		
		Date dataInstalacaoHidrometro = null;
		Imovel imovel = new Imovel();
		imovel.setId(idImovel);
		
		SistemaParametro sistemaParametro = this.getControladorUtil()
		.pesquisarParametrosDoSistema();
		
		Integer anoMesReferenciaAnterior = Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(), 1);
		
		Collection colecaoDadosMedicaoHistorico = this.obterDadosTiposMedicao(imovel, anoMesReferenciaAnterior);
		
		if (colecaoDadosMedicaoHistorico != null && !colecaoDadosMedicaoHistorico.isEmpty()){
			
			Iterator iterator = colecaoDadosMedicaoHistorico.iterator();
				
			while(iterator.hasNext()){
				Object[] arrayMedicaoHistorico = (Object[]) iterator.next();
				
				if (arrayMedicaoHistorico[2] != null) {
					dataInstalacaoHidrometro = (Date) arrayMedicaoHistorico[2];
				} 
			}
		}
		return dataInstalacaoHidrometro;
	}
	
	private Date obterDataLeituraAnteriorCronograma(FaturamentoGrupo grupo, Integer anoMesFaturamentoAnterior) {
		Date dataLeituraAnteriorFaturamento = null;
		try {
			
			dataLeituraAnteriorFaturamento = (Date) getControladorFaturamento().pesquisarFaturamentoAtividadeCronogramaDataRealizada(
							grupo.getId(), FaturamentoAtividade.EFETUAR_LEITURA, anoMesFaturamentoAnterior);

		} catch (ControladorException e) {
			e.printStackTrace();
		}
		
		if(dataLeituraAnteriorFaturamento == null || dataLeituraAnteriorFaturamento.equals("")){
			try {
				dataLeituraAnteriorFaturamento = (Date) getControladorFaturamento().pesquisarFaturamentoAtividadeCronogramaDataPrevista(
								grupo.getId(), FaturamentoAtividade.EFETUAR_LEITURA, anoMesFaturamentoAnterior);

			} catch (ControladorException e) {
				e.printStackTrace();
			}
		}
		
		if(dataLeituraAnteriorFaturamento == null || dataLeituraAnteriorFaturamento.equals("")){
			dataLeituraAnteriorFaturamento = Util.subtrairNumeroDiasDeUmaData(new Date(), 30);
		}
		
		return dataLeituraAnteriorFaturamento;
	}
	
	public boolean verificarSubstituicaoHidrometro(Imovel imovel, MedicaoHistorico medicaoHistorico, 
			SistemaParametro sistemaParametro) throws ControladorException {
		
		boolean retorno = false;
		if (!imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO)) {
			
			Date dataInstalacao = null;
			
			Integer anoMesAnterior = Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(), 1);
			
			MedicaoHistorico medicaoHistoricoAnterior = pesquisarMedicaoHistoricoAnterior(imovel.getId(), 
					anoMesAnterior, medicaoHistorico.getMedicaoTipo().getId());
			
			if (medicaoHistorico.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)) {
				
				// Obtém a data de instalação do hidrômetro
				dataInstalacao = imovel.getLigacaoAgua()
				.getHidrometroInstalacaoHistorico().getDataInstalacao();
				
				// Caso seja medição de <<<POÇO>>>
			} else if (medicaoHistorico.getMedicaoTipo().getId().equals(MedicaoTipo.POCO)) {
				
				// Obtém a data de instalação do hidrômetro
				dataInstalacao = imovel.getHidrometroInstalacaoHistorico()
				.getDataInstalacao();
			}
			/**
			 * Alterando para verificar substituição a partir
			 * da data de leitura INFORMADA, e não faturada
			 */
			if (dataInstalacao != null && medicaoHistoricoAnterior != null &&
					medicaoHistoricoAnterior.getDataLeituraAtualInformada() != null &&
					medicaoHistorico.getDataLeituraAtualInformada() != null &&
					((Util.compararData(medicaoHistoricoAnterior.getDataLeituraAtualInformada()
							, dataInstalacao) <= 0)
							&& (Util.compararData(dataInstalacao, medicaoHistorico
									.getDataLeituraAtualInformada()) <= 0))
									&& ( medicaoHistoricoAnterior != null 
											&& (medicaoHistoricoAnterior.getLeituraAtualInformada() != null
													|| ( medicaoHistoricoAnterior.getLeituraAnormalidadeInformada() != null
															&& !medicaoHistoricoAnterior.getLeituraAnormalidadeInformada().getId().equals(new Integer(0)))))) { 
				retorno =  true;
			} 
		}
		return retorno;
	}
	
	/**
	 * 
	 * Pamela Gatinho - 15/06/2011
	 * Metodo para verificar se o imovel era fixo e virou hidrometrado
	 * @param imovel
	 * @param medicaoHistorico
	 * @return
	 */
	private boolean verificarImovelFixoAgoraHidrometrado(Imovel imovel, MedicaoHistorico medicaoHistorico, SistemaParametro sistemaParametro) {
		Date dataInstalacaoHidrometro = imovel.getLigacaoAgua()
				.getHidrometroInstalacaoHistorico().getDataInstalacao();
		
		try {
			Date dataLigacaoAguaImovel = imovel.getLigacaoAgua().getDataLigacao();
			
			Integer anoMesAnterior = Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(), 1);
			
			MedicaoHistorico medicaoHistoricoAnterior = pesquisarMedicaoHistoricoAnterior(imovel.getId(), 
					anoMesAnterior, medicaoHistorico.getMedicaoTipo().getId());
			
			if (!imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO)) {
				
				if (medicaoHistoricoAnterior == null 
						&& (Util.compararData(dataInstalacaoHidrometro,	medicaoHistorico.getDataLeituraAnteriorFaturamento()) == 0)
						&& (Util.compararData(dataLigacaoAguaImovel,dataInstalacaoHidrometro) < 0)) {
					return true;
				}
				
			}
		} catch (ControladorException e) {
			
			e.printStackTrace();
		}
		return false;
	}
	
	
	/**
	 * 
	 * Pamela Gatinho - 15/06/2011
	 * Metodo para verificar se o imovel possui uma nova ligacao de agua
	 * @param imovel
	 * @param medicaoHistorico
	 * @return
	 */
	private boolean verificarImovelNovaLigacaoAgua(Imovel imovel, MedicaoHistorico medicaoHistorico, SistemaParametro sistemaParametro) {
		Date dataInstalacaoHidrometro = imovel.getLigacaoAgua()
				.getHidrometroInstalacaoHistorico().getDataInstalacao();
		
		Date dataLigacaoAguaImovel = imovel.getLigacaoAgua().getDataLigacao();
		try {
			
			Integer anoMesAnterior = Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(), 1);
			
			MedicaoHistorico medicaoHistoricoAnterior = pesquisarMedicaoHistoricoAnterior(imovel.getId(), 
					anoMesAnterior, medicaoHistorico.getMedicaoTipo().getId());
			
			if (!imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO)) {
	
				if (medicaoHistoricoAnterior == null 
						&& (Util.compararData(dataInstalacaoHidrometro,	medicaoHistorico.getDataLeituraAnteriorFaturamento()) == 0)
						&& (Util.compararData(dataLigacaoAguaImovel,dataInstalacaoHidrometro) == 0)) {
					return true;
				}
			}
		} catch (ControladorException e) {
			
			e.printStackTrace();
		}

		return false;
	}
	
	/**
	 * 
	 * Metodo para determinar se o tipo de consumo foi real ou estimado
	 * 
	 * @param medicaoHistorico
	 * @return
	 */
	private ConsumoTipo determinarConsumoTipo(MedicaoHistorico medicaoHistorico) {
		ConsumoTipo consumoTipo = new ConsumoTipo();
		if (medicaoHistorico.getLeituraSituacaoAnterior().getId().intValue() == LeituraSituacao.CONFIRMADA
				.intValue()
				|| medicaoHistorico.getLeituraSituacaoAnterior().getId()
				.intValue() == LeituraSituacao.REALIZADA.intValue()) {
			consumoTipo.setId(ConsumoTipo.REAL);
		} else {
			consumoTipo.setId(ConsumoTipo.ESTIMADO);
		}
		
		return consumoTipo;
	}
	
	private void determinarAjusteMensal(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico, Imovel imovel,
			Rota rota, int consumoMedioHidrometro, SistemaParametro sistemaParametro) {

		if (rota.getIndicadorAjusteConsumo() != null && rota.getIndicadorAjusteConsumo().intValue() == Rota.INDICADOR_AJUSTE_MENSAL) {
			ajusteMensalConsumo(medicaoHistorico, consumoHistorico, imovel,
					medicaoHistorico.getMedicaoTipo(), rota,
					consumoMedioHidrometro, sistemaParametro);
		}
	}
	
	/**
	 * 
	 * 20/06/2011 - Pamela Gatinho
	 * Metodo para obter o número máximo de leitura do hidrômetro
	 * @param imovel
	 * @return
	 */
	private Double obterNumeroLimiteHidrometro(MedicaoHistorico medicaoHistorico, Imovel imovel) {
		Integer numeroDigitosLeitura = null;
		
		if (medicaoHistorico.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)) {
			
			// Obtém o número de digitos da leitura
			numeroDigitosLeitura = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()
						.getHidrometro().getNumeroDigitosLeitura().intValue();
			
		} else if (medicaoHistorico.getMedicaoTipo().getId().equals(MedicaoTipo.POCO)) {
			
			// Obtém o número de digitos da leitura
			numeroDigitosLeitura = imovel.getHidrometroInstalacaoHistorico()
						.getHidrometro().getNumeroDigitosLeitura().intValue();
		}
		Double numeroLimite = (Math.pow(10.0, numeroDigitosLeitura) - 1);
		
		return numeroLimite;
	}
	
	/**
	 * 
	 * 20/06/2011 - Pamela Gatinho
	 * 
	 * Verifica se o imóvel possui situação especial de faturamento
	 * @param medicaoHistorico
	 * @param consumoHistorico
	 * @param imovel
	 * @param faturamentoGrupo
	 * @param consumoMedioHidrometro
	 * @param leituraAnterior
	 * @throws ControladorException
	 */
	@SuppressWarnings("unchecked")
	private boolean verificarSituacaoEspecialFaturamentoImovel(Imovel imovel,
			FaturamentoGrupo faturamentoGrupo) throws ControladorException {
		
		boolean retorno = false;
		/*
		 * Data: 21/05/2009
		 * Autor: Bruno Barros
		 * Analista Solicitante: Sávio
		 * 
		 * Alteração Solicitada: Caso FTGR_AMREFERENCIA da tabela
		 * FATURAMENTO_GRUPO, com FTGR_ID = ao grupo que está sendo
		 * faturado, enteja entre FTSH_AMFATURAMENTOSITUACAO INICIO
		 * e FTSH_AMFATURAMENTOSITUACAOFIM da tabela 
		 * FATURAMENTO_SITUACAO_HISTORICO atribuir FTST_ID da tabela
		 * imovel. CASO CONTRARIO, nulo.
		 */
		
		FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = obterSituacaoEspecialFaturamentoImovel(imovel);
		
		// Verificamos se anomesreferencia do grupo que esta sendo faturado
		// está entre o os meses inicial e final do FATURAMENTO_SITUACAO_HISTORICO
		if ( faturamentoSituacaoHistorico != null &&
			 faturamentoGrupo != null &&
		     faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio() &&
			 faturamentoGrupo.getAnoMesReferencia() <= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoFim() &&
		/*
		 * FIM ALTERAÇÃO BRUNO BARROS
		 * 
		 * CODIGO ANTERIOR: Código não implementado
		 */				 
			 imovel.getFaturamentoSituacaoTipo() != null && 
			 imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua() != null && 
			 imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue() == 1) {

			retorno = true;
		}
		
		return retorno;
	}

	/**
	 * 
	 * Essa consulta se transformou em método, para ser acessado
	 * por outros controladores.
	 * 
	 * @param imovel
	 * @return
	 * @throws ControladorException
	 */
	public FaturamentoSituacaoHistorico obterSituacaoEspecialFaturamentoImovel(
			Imovel imovel) throws ControladorException {
		/*
		 * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson
		 * Carvalho
		 * 
		 * Sistema determina os dados para faturamento caso o imóvel esteja
		 * com situação de faturamento especial (DIFERENTE DE NULO) e que
		 * seja válido para água.
		 */
		FiltroFaturamentoSituacaoHistorico filtroFaturamentoSituacaoHistorico = 
			new FiltroFaturamentoSituacaoHistorico();
		filtroFaturamentoSituacaoHistorico.adicionarParametro( 
				new ParametroSimples( 
						FiltroFaturamentoSituacaoHistorico.ID_IMOVEL, imovel.getId() ) );
		filtroFaturamentoSituacaoHistorico.adicionarParametro( 
				new ParametroNulo ( 
						FiltroFaturamentoSituacaoHistorico.ANO_MES_FATURAMENTO_RETIRADA ) );
		
		Collection<FaturamentoSituacaoHistorico> 
			colFiltroFaturamentoSituacaoHistorico = 
				this.getControladorUtil().pesquisar( 
						filtroFaturamentoSituacaoHistorico,
						FaturamentoSituacaoHistorico.class.getName());
		
		FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = 
			( FaturamentoSituacaoHistorico ) Util.retonarObjetoDeColecao( colFiltroFaturamentoSituacaoHistorico );
		return faturamentoSituacaoHistorico;
	}
	
	/**
	 * 
	 * 20/06/2011 - Pamela Gatinho
	 * 
	 * Verifica se o consumo a ser cobrado no mês é menor que o consumo
     * mínimo de água 
     * 
	 * @param medicaoHistorico
	 * @param consumoHistorico
	 * @param imovel
	 * @param consumoTipo
	 * @param consumoAnormalidade
	 */
	private void verificarConsumoMinimoCobrado(
			MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistorico, Imovel imovel,
			ConsumoTipo consumoTipo, ConsumoAnormalidade consumoAnormalidade) {
		
		Integer consumoMinimoBolsaAgua = Integer.valueOf(Fachada.getInstancia().getFaturamentoParametro(FaturamentoParametro.NOME_PARAMETRO_FATURAMENTO.CONSUMO_MINIMO_BOLSA_AGUA.toString()));
		// Caso o consumo a ser cobrado no mês seja menor que o consumo
		// mínimo de água
		if ((imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua() != null)
				&& (consumoHistorico.getNumeroConsumoFaturadoMes()
						.intValue() < imovel.getLigacaoAgua()
						.getNumeroConsumoMinimoAgua().intValue())) {
			// Seta o consumo histórico
			consumoHistorico.setNumeroConsumoFaturadoMes(imovel
					.getLigacaoAgua().getNumeroConsumoMinimoAgua());
			// Seta o consumo anormalidade
			consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

		} else if (medicaoHistorico.getNumeroConsumoInformado() != null) {
			// Seta o consumo histórico
			consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico
					.getNumeroConsumoInformado());
			// Seta o consumo anormalidade
			consumoTipo.setId(ConsumoTipo.INFORMADO);

			consumoAnormalidade
					.setId(ConsumoAnormalidade.CONSUMO_INFORMADO);

		}
		
		if (consumoHistorico.getImovel().getImovelPerfil().getId().equals(ImovelPerfil.BOLSA_AGUA)
				&& (consumoHistorico.getNumeroConsumoFaturadoMes() < consumoMinimoBolsaAgua)) {
			// Seta o consumo histórico
			consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoBolsaAgua);
			consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_BOLSA_AGUA);
		}	
	}
	
	/**
	 * 
	 * 20/06/2011 - Pamela Gatinho
	 * Verificar se o consumo está fora de faixa
	 * 
	 * @param medicaoHistorico
	 * @param consumoHistorico
	 * @param consumoMedioHidrometro
	 * @param imovel
	 */
	private boolean verificarConsumoForaDeFaixa(MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistorico, int consumoMedioHidrometro,
			Imovel imovel) {
		
		boolean retorno = false;
		// Calcular faixa de leitura esperada
		int[] faixaLeituraEsperada = null;
		
		Hidrometro hidrometro = null;
		if (medicaoHistorico.getMedicaoTipo().getId().intValue() == MedicaoTipo.POCO) {
			hidrometro = imovel.getHidrometroInstalacaoHistorico()
			.getHidrometro();
		} else {
			hidrometro = imovel.getLigacaoAgua()
			.getHidrometroInstalacaoHistorico().getHidrometro();
		}
		
		faixaLeituraEsperada = calcularFaixaLeituraEsperada(
				consumoMedioHidrometro, medicaoHistorico, hidrometro, null);
		
		// Caso a leitura atual informada esteja fora da faixa de leitura
		// esperada
		if (medicaoHistorico.getLeituraAtualFaturamento() < faixaLeituraEsperada[0]
		         || medicaoHistorico.getLeituraAtualFaturamento() > faixaLeituraEsperada[1]) {
			retorno = true;
		}
		
		return retorno;
	}
	
	private boolean verificarViradaDeHidrometro(MedicaoHistorico medicaoHistorico, Imovel imovel, 
			int leituraAnterior, int consumoMedioHidrometro) {
			
			boolean retorno = false;
			
			int numeroDigitosLeitura = 0;
			Hidrometro hidrometro = null;
			Date dataInstalacao = null;

			// Identifica e armazena a data de instalação de acordo com o tipo de  medição
			if (medicaoHistorico.getMedicaoTipo().getId() == MedicaoTipo.LIGACAO_AGUA) {
				// Obtém a data de instalação do hidrômetro
				dataInstalacao = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();
				
				// Obtém o hidrômetro
				hidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro();
				
				// Obtém o número de digitos da leitura
				numeroDigitosLeitura = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()
							.getHidrometro().getNumeroDigitosLeitura().intValue();
				
			} else if (medicaoHistorico.getMedicaoTipo().getId() == MedicaoTipo.POCO) {
				// Obtém a data de instalação do hidrômetro
				dataInstalacao = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();
				
				// Obtém o hidrômetro
				hidrometro = imovel.getHidrometroInstalacaoHistorico().getHidrometro();
				
				// Obtém o número de digitos da leitura
				numeroDigitosLeitura = imovel.getHidrometroInstalacaoHistorico()
							.getHidrometro().getNumeroDigitosLeitura().intValue();
			}
			
			Double valor = new Double((Math.pow(10.0, numeroDigitosLeitura)));
			// Obtém o consumo calculado
			int consumoCalculado = (medicaoHistorico.getLeituraAtualInformada() + valor
					.intValue())
					- leituraAnterior;
			// Obtém 2x o consumo médio do hidrometro
			int duasVezesConsumoMedioHidrometro = (consumoMedioHidrometro * 2);
	
			// Caso exista virada de hidrômetro
			if ((consumoCalculado <= 200 || consumoCalculado <= duasVezesConsumoMedioHidrometro)
					&& (consumoCalculado > 0)) {
				retorno = true;
		}
			
		return retorno;
	}
	
	/**
	 * 
	 * 27/06/2011 - Pamela Gatinho
	 * Metodo para salvar no banco as informacoes que foram 
	 * processadas pelo IS, sem refazer os cálculos já feitos no IS.
	 * @throws ControladorException 
	 */
	public void processarImoveisImpressaoSimultanea(FaturamentoGrupo faturamentoGrupo, MovimentoContaPrefaturada movimentoContaPreFaturada) 
	throws ControladorException {
		
		try {
			
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			
			/*
			 * Usar o AnoMes de Faturamento do FaturamentoGrupo
			 * Autor: Thiago Nascimento
			 */
			sistemaParametro.setAnoMesFaturamento(faturamentoGrupo.getAnoMesReferencia());

			Collection colecaoInserirMedicaoHistoricoAgua = new ArrayList();
			Collection colecaoAtualizarMedicaoHistoricoAgua = new ArrayList();
			Collection colecaoInserirConsumoHistoricoAgua = new ArrayList();

			Collection colecaoInserirMedicaoHistoricoEsgoto = new ArrayList();
			Collection colecaoAtualizarMedicaoHistoricoEsgoto = new ArrayList();
			Collection colecaoInserirConsumoHistoricoEsgoto = new ArrayList();

			//Pesquisar a Rota de Cada Imovel
			Rota rota = null;
				

			// Criação dos objetos
			Object[] arrayImovel = null;
			Imovel imovel = null;

			int quantidadeEconomias = 0;
			
			// Criação das coleções que serão usadas para persistir
			colecaoInserirMedicaoHistoricoAgua.clear();
			colecaoAtualizarMedicaoHistoricoAgua.clear();
			colecaoInserirConsumoHistoricoAgua.clear();
			colecaoInserirConsumoHistoricoEsgoto.clear();

			Integer idConta = null;

			
			Integer matricula =  movimentoContaPreFaturada.getImovel().getId();

			arrayImovel = this.repositorioMicromedicao.pesquisarImovelPelaMatricula(matricula);
			
			rota = this.repositorioMicromedicao.buscarRotaDoImovel(matricula);
			
			imovel = obterImovelLigadoCortadoAguaLigadoEsgoto(arrayImovel);
			
									
			EsferaPoder esferaPoder = null;
			
			if (arrayImovel[26] != null) {
				esferaPoder = new EsferaPoder();
				esferaPoder.setId((Integer) arrayImovel[26]);
			}
			
			idConta = (Integer) getControladorImovel()
					.pesquisarImovelIdComConta(imovel.getId(),
							sistemaParametro.getAnoMesFaturamento());

			
			Integer idDebitoCreditoSituacaoAtual = 
				this.getControladorFaturamento().
					pesquisarDebitoCreditoSituacaoAtualConta( 
							imovel.getId(), 
							sistemaParametro.getAnoMesFaturamento() );
			
			// CASO NÃO EXISTA CONTA PARA O IMÓVEL NO ANO/MÊS DE
			// REFERÊNCIA OU DEBITO CREDITO SITUACAO ATUAL SEJA
			// DE CONTA PRE FATURADA
			// ALTERADO POR BRUNO BARROS 
			// DATA: 22/09/2009
			if (idConta == null || 
				idConta.equals("") || 
				idDebitoCreditoSituacaoAtual.intValue() == DebitoCreditoSituacao.PRE_FATURADA.intValue() ) {
				
					
					/*
					 * Alterado por Raphael Rossiter em 17/09/2007
					 * (Analistas: Aryed Lins e Eduardo Borges) OBJ:
					 * Apagar apenas o consumo dos imóveis que não
					 * tenham contas geradas para o anoMesfaturamento
					 */

					/*
					 * Deleta os consumos históricos existentes na base
					 * para a rota no ano mês de faturamento.
					 */
					repositorioMicromedicao
							.deletarConsumoHistoricoCondominioRETIRAR(
									imovel.getId(), sistemaParametro
											.getAnoMesFaturamento()
											.intValue());

					repositorioMicromedicao
							.deletarConsumoHistoricoRETIRAR(imovel
									.getId(), sistemaParametro
									.getAnoMesFaturamento().intValue());
					
					// Alterado por Sávio Luiz Data:21/11/2007 Analista:Aryed Lins
					// Se o mês de faturamento for igual a 11 e o indicador
					// faturamento
					// antecipado for igual a 1, então seta o mes de faturamento
					// igual a
					// 12 para deletar os consumos historicos.
					if (Util.obterMes(sistemaParametro
							.getAnoMesFaturamento()) == 11) {
						if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(
								ConstantesSistema.SIM)) {
							Integer anoMesReferenciaFaturamentoAntecipado = Util
									.somarData(sistemaParametro
											.getAnoMesFaturamento());
							
							/*
							 * Deleta os consumos históricos existentes na base
							 * para a rota no ano mês de faturamento.
							 */
							repositorioMicromedicao
									.deletarConsumoHistoricoCondominioRETIRAR(
											imovel.getId(), anoMesReferenciaFaturamentoAntecipado);

							repositorioMicromedicao
									.deletarConsumoHistoricoRETIRAR(imovel
											.getId(), anoMesReferenciaFaturamentoAntecipado);
						}
					}

					// [UC0068] - Obter Consumo Médio do Imóvel
					boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(imovel.getId(), 
							movimentoContaPreFaturada.getMedicaoTipo());
					
					int[] consumoMedio = obterVolumeMedioAguaEsgoto(
							imovel.getId(),
							sistemaParametro.getAnoMesFaturamento(),
							movimentoContaPreFaturada.getMedicaoTipo().getId(), houveIntslacaoHidrometro);
					int mediaConsumoHidrometro = consumoMedio[0];
					

					// [UC0810] Obter Quantidade de Economias Virtuais
                    quantidadeEconomias = this.getControladorImovel()
                        .obterQuantidadeEconomiasVirtuais(imovel.getId()); 
					// quantidadeEconomias = imovel.getQuantidadeEconomias();

					// Cria o objeto histórico de medição e histórico de
					// consumos
					MedicaoHistorico medicaoHistorico = null;
					ConsumoHistorico consumoHistoricoAgua = null;
					ConsumoHistorico consumoHistoricoEsgoto = null;

					LigacaoTipo ligacaoTipo = new LigacaoTipo();

					// Obtém a situação da ligacao de água
					/*int ligacaoAguaSituacao = imovel
							.getLigacaoAguaSituacao().getId()
							.intValue();*/

					Short ligacaoAguaSituacaoIndicadorFaturamento = imovel
					.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao();
					
					// Obtém a situação da ligacao de esgoto
					/*int ligacaoEsgotoSituacao = imovel
							.getLigacaoEsgotoSituacao().getId()
							.intValue(); */

					
//							Obtém a situação da ligacao de esgoto
					Short ligacaoEsgotoSituacaoIndicadorFaturamento = imovel
							.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao();
					
					// CASO O IMÓVEL SEJA LIGADO OU CORTADO DE ÁGUA
					if (ligacaoAguaSituacaoIndicadorFaturamento.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
							|| (imovel.getLigacaoAgua()!=null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()!=null)){
						
						ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

						consumoHistoricoAgua = new ConsumoHistorico();
						consumoHistoricoAgua.setRota(rota);
						
						consumoHistoricoAgua.setLigacaoTipo(ligacaoTipo);

						/*
						 * [SF0001] - Determinar Dados para Faturamento
						 * de Água (Para cada imóvel selecionado)
						 */
						long t1 = System.currentTimeMillis();
						
						determinarDadosConsumoHistorico(medicaoHistorico, consumoHistoricoAgua, 
								imovel, faturamentoGrupo, sistemaParametro, consumoMedio,
								rota,colecaoInserirConsumoHistoricoAgua, movimentoContaPreFaturada);
						
						logPerformance("processarConsumoHistoricoImoveis" +
								imovel.getId(), t1, System.currentTimeMillis());

					}

					// CASO O IMÓVEL SEJA LIGADO DE ESGOTO
					if (ligacaoEsgotoSituacaoIndicadorFaturamento.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)
							|| (imovel.getHidrometroInstalacaoHistorico()!=null)) {

						ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

						consumoHistoricoEsgoto = new ConsumoHistorico();
						consumoHistoricoEsgoto.setRota(rota);
						consumoHistoricoEsgoto.setLigacaoTipo(ligacaoTipo);

						// [SF0002] - Determinar Dados para Faturamento
						// de Esgoto
						long t1 = System.currentTimeMillis();
						
						determinarDadosConsumoHistorico(medicaoHistorico, consumoHistoricoEsgoto, 
								imovel, faturamentoGrupo, sistemaParametro, consumoMedio,
								rota,colecaoInserirConsumoHistoricoEsgoto, movimentoContaPreFaturada);
						
//						determinarDadosFaturamentoEsgoto(imovel,
//								consumoMedioImovel,
//								consumoHistoricoEsgoto,
//								consumoHistoricoAgua,
//								quantidadeEconomias, sistemaParametro,
//								rota,
//								colecaoInserirConsumoHistoricoEsgoto,
//								faturamentoGrupo,
//								colecaoInserirMedicaoHistoricoEsgoto,
//								colecaoAtualizarMedicaoHistoricoEsgoto, esferaPoder);
						
						logPerformance("processarConsumoHistoricoImoveis" +
								imovel.getId(), t1, System.currentTimeMillis());


					}
				}

		
			// INSERIR CONSUMO HISTORICO
			getControladorBatch().inserirColecaoObjetoParaBatchSemTransacao(colecaoInserirConsumoHistoricoAgua);
			getControladorBatch().inserirColecaoObjetoParaBatchSemTransacao(colecaoInserirConsumoHistoricoEsgoto);
			
			// INSERIR MEDICAO HISTORICO
			getControladorBatch().inserirColecaoObjetoParaBatchSemTransacao(colecaoInserirMedicaoHistoricoAgua);
			getControladorBatch().inserirColecaoObjetoParaBatchSemTransacao(colecaoInserirMedicaoHistoricoEsgoto);
		
			// ATUALIZAR MEDICAO HISTORICO
			getControladorBatch().atualizarColecaoObjetoParaBatchSemTransacao(colecaoAtualizarMedicaoHistoricoAgua);
			getControladorBatch().atualizarColecaoObjetoParaBatchSemTransacao(colecaoAtualizarMedicaoHistoricoEsgoto);
		
			
		} catch (Exception e) {			  
			throw new ControladorException("erro.sistema", e);		
			
		}
	}
	
	/**
	 *  
	 * 27/06/2011 - Pamela Gatinho
	 * 
	 * @param medicaoHistorico
	 * @param consumoHistorico
	 * @param imovel
	 * @param faturamentoGrupo
	 * @param sistemaParametro
	 * @param consumoMedioImovel
	 * @param rota
	 * @param colecaoInserirMedicaoHistorico
	 * @param colecaoAtualizarMedicaoHistorico
	 * @param colecaoInserirConsumoHistorico
	 * @throws ControladorException
	 */
	private void determinarDadosConsumoHistorico(
			MedicaoHistorico medicaoHistorico,
			ConsumoHistorico consumoHistorico, Imovel imovel,
			FaturamentoGrupo faturamentoGrupo,
			SistemaParametro sistemaParametro, int[] consumoMedioImovel,
			Rota rota, Collection colecaoInserirConsumoHistorico, MovimentoContaPrefaturada movimentoContaPreFaturada)
			throws ControladorException {
		
		// Seta o imóvel
		consumoHistorico.setImovel(imovel);

		// Seta a anormalidade de consumo
		consumoHistorico.setConsumoAnormalidade(movimentoContaPreFaturada.getConsumoAnormalidade());
		
		// Seta o tipo de consumo
		consumoHistorico.setConsumoTipo(movimentoContaPreFaturada.getConsumoTipo());
		
		// Seta o consumo faturado
		consumoHistorico.setNumeroConsumoFaturadoMes(movimentoContaPreFaturada.getConsumoCobrado());
		
		// Seta a referência de faturamento
		consumoHistorico.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
		
		// Seta o indicador alteração últimos consumos
		consumoHistorico.setIndicadorAlteracaoUltimosConsumos(new Short("2"));
		
		// Seta o indicador ajuste
		consumoHistorico.setIndicadorAjuste(rota.getIndicadorAjusteConsumo());
		
		// Seta o consumo rateio
		consumoHistorico.setConsumoRateio(null);
		
		// Seta o consumo histórico condomínio
		consumoHistorico.setConsumoHistoricoCondominio(null);
		
		// Seta o indicador imóvel condomínio
		consumoHistorico.setIndicadorImovelCondominio(imovel.getIndicadorImovelCondominio());
		
		// Seta o consumo médio do imóvel
		consumoHistorico.setConsumoMedio(new Integer(consumoMedioImovel[0]));
		
		// Seta o consumo mínimo de água
		consumoHistorico.setConsumoMinimo(imovel.getLigacaoAgua() != null ? 
				imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua() : null);

		// Seta o percentual de coleta
		consumoHistorico.setPercentualColeta(null);
		
		// Seta a última alteração
		consumoHistorico.setUltimaAlteracao(new Date());
		
		// Seta o rateio tipo
		if (consumoHistorico.getId() == null) {
			RateioTipo rateioTipo = new RateioTipo();
			rateioTipo.setId(RateioTipo.SEM_RATEIO);
			consumoHistorico.setRateioTipo(rateioTipo);
		}
		// Seta o poco tipo
		consumoHistorico.setPocoTipo(imovel.getPocoTipo());
		// Seta o faturamento situação tipo
		
		/*
		 * Data: 21/05/2009
		 * Autor: Bruno Barros
		 * Analista Solicitante: Sávio
		 * 
		 * Alteração Solicitada: Caso FTGR_AMREFERENCIA da tabela
		 * FATURAMENTO_GRUPO, com FTGR_ID = ao grupo que está sendo
		 * faturado, não enteja entre FTSH_AMFATURAMENTOSITUACAO INICIO
		 * e FTSH_AMFATURAMENTOSITUACAOFIM da tabela 
		 * FATURAMENTO_SITUACAO_HISTORICO atribuir FTST_ID da tabela
		 * imovel. CASO CONTRARIO, nulo.
		 */
		
		FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = obterSituacaoEspecialFaturamentoImovel(imovel);
		
		// Verificamos se anomesreferencia do grupo que esta sendo faturado
		// está entre o os meses inicial e final do FATURAMENTO_SITUACAO_HISTORICO
		if ( imovel.getFaturamentoSituacaoTipo() != null &&
		     faturamentoSituacaoHistorico != null &&
			 faturamentoGrupo != null &&
		     faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio() &&
			 faturamentoGrupo.getAnoMesReferencia() <= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoFim() ){
			consumoHistorico.setFaturamentoSituacaoTipo(imovel
					.getFaturamentoSituacaoTipo());			
		} else {
			consumoHistorico.setFaturamentoSituacaoTipo( null );
		}		
		/*
		 * FIM ALTERAÇÃO BRUNO BARROS
		 * 
		 * CODIGO ANTERIOR:
		 consumoHistorico.setFaturamentoSituacaoTipo(
		 	imovel.getFaturamentoSituacaoTipo() ); 
		 */
		
		/*
		 * Colocado por Raphael Rossiter em 02/06/2008 - Analista: Aryed Lins
		 * OBJ: Incluir gravação do consumo a ser cobrado na coluna CSHI_NNCONSUMOCALCULOMEDIA
		 * na tabela CONSUMO_HISTORICO.
		 */
		consumoHistorico.setNumeroConsumoCalculoMedia(consumoHistorico.getNumeroConsumoFaturadoMes());

		
		//COLOCANDO O CONSUMO_HISTORICO NA COLEÇÃO QUE SERÁ INSERIDA NO BANCO
		//--------------------------------------------------------------------
		boolean faturar = this.getControladorFaturamento().permiteFaturamentoParaAgua(imovel.getLigacaoAguaSituacao(),
				consumoHistorico.getNumeroConsumoFaturadoMes(), consumoHistorico.getConsumoTipo());
		
		/*
		 * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson
		 * Carvalho Seta o indicador de faturamento paralisação
		 */
		if (imovel.getFaturamentoSituacaoTipo() == null && faturar) {
			consumoHistorico.setIndicadorFaturamento(new Short("1"));
        /*
         * Data: 21/05/2009
         * Autor: Bruno Barros
         * Analista Solicitante: Sávio
         * 
         * Alteração Solicitada: Para atribuir indicador 2 no indicador
         * de faturamento, adicionar a seguinte validação: 
         * Caso FTGR_AMREFERENCIA da tabela
         * FATURAMENTO_GRUPO, com FTGR_ID = ao grupo que está sendo
         * faturado, não enteja entre FTSH_AMFATURAMENTOSITUACAO INICIO
         * e FTSH_AMFATURAMENTOSITUACAOFIM da tabela 
         * FATURAMENTO_SITUACAO_HISTORICO atribuir FTST_ID da tabela
         * imovel. CASO CONTRARIO, nulo.
         */	
		} else if (
				  	// Verificamos se anomesreferencia do grupo que esta sendo faturado
				  	// está entre o os meses inicial e final do FATURAMENTO_SITUACAO_HISTORICO
				  	( faturamentoSituacaoHistorico != null &&
				  	  faturamentoGrupo != null &&
				  	  faturamentoGrupo.getAnoMesReferencia() >= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoInicio() &&
				  	  faturamentoGrupo.getAnoMesReferencia() <= faturamentoSituacaoHistorico.getAnoMesFaturamentoSituacaoFim() ) &&
        /*
         * FIM ALTERAÇÃO BRUNO BARROS
         * 
         * CODIGO ANTERIOR: Não havia essa codificação
         */				
					( imovel.getFaturamentoSituacaoTipo() != null && 
				      imovel.getFaturamentoSituacaoTipo().getIndicadorParalisacaoFaturamento().intValue() == 1 && 
				      imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue() == 1 ) || 
				      ( !faturar ) ) {
			consumoHistorico.setIndicadorFaturamento(new Short("2"));
		} else {
			if(faturar){
			 consumoHistorico.setIndicadorFaturamento(new Short("1"));
			}else{
				consumoHistorico.setIndicadorFaturamento(new Short("2"));
			}
		}
		
		colecaoInserirConsumoHistorico.add(consumoHistorico);
	}
	
	
	private void determinarDadosMedicaoHistorico(MovimentoContaPrefaturada movimentoContaPreFaturada,
			SistemaParametro sistemaParametro, ConsumoHistorico consumoHistorico, Collection colecaoInserirMedicaoHistoricoAgua,
			Collection colecaoAtualizarMedicaoHistoricoAgua, EsferaPoder esferaPoder) throws ControladorException {
		
		Imovel imovel = movimentoContaPreFaturada.getImovel();
		
		if (imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) {

			MedicaoTipo medicaoTipo = new MedicaoTipo();
			medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);

			MedicaoHistorico medicaoHistorico = obterDadosHistoricoMedicao(movimentoContaPreFaturada.getFaturamentoGrupo(),imovel, medicaoTipo, sistemaParametro);
			
			boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(imovel.getId(), medicaoTipo);
			
			int[] mediaHidrometro = obterVolumeMedioAguaEsgoto(
					imovel.getId(),
					sistemaParametro.getAnoMesFaturamento(),
					medicaoTipo.getId(), houveIntslacaoHidrometro);
			int mediaConsumoHidrometro = mediaHidrometro[0];
			// Set consumo medio do hidrometro
			medicaoHistorico.setConsumoMedioHidrometro(mediaHidrometro[0]);
			
			// Set o consumo faturado
			medicaoHistorico.setNumeroConsumoMes(movimentoContaPreFaturada.getConsumoMedido());
			
			// Seta a leitura atual informada
			medicaoHistorico.setLeituraAtualInformada(movimentoContaPreFaturada.getLeituraHidrometro());
			
			// Seta a leitura atual faturada
			medicaoHistorico.setLeituraAtualFaturamento(movimentoContaPreFaturada.getLeituraFaturamento());
			
			// Seta a anormalidade de faturamento
			medicaoHistorico.setLeituraAnormalidadeFaturamento(movimentoContaPreFaturada.getLeituraAnormalidadeFaturamento());
			
			// Seta a data de leitura faturada
			//medicaoHistorico.setDataLeituraAtualFaturamento(movimentoContaPreFaturada.ge);
			
			// Seta a data de leitura informada
			medicaoHistorico.setDataLeituraAtualInformada(movimentoContaPreFaturada.getDataHoraLeitura());
			
			// Seta a anormalidade informada
			medicaoHistorico.setLeituraAnormalidadeInformada(movimentoContaPreFaturada.getLeituraAnormalidadeLeitura());
			
			if (medicaoHistorico.getId() == null) {
				colecaoInserirMedicaoHistoricoAgua.add(medicaoHistorico);
			} else {
				colecaoAtualizarMedicaoHistoricoAgua.add(medicaoHistorico);
			}
			
			int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());
			
			if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(
					ConstantesSistema.SIM)) {
				
				// Verifica se é faturamento antecipado
				if (imovel.getIndicadorDebitoConta().equals(
						Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
						&& (mes == 11)
						&& esferaPoder != null
						&& (esferaPoder.getId().equals(
								new Integer(EsferaPoder.MUNICIPAL))
								|| esferaPoder.getId().equals(
										new Integer(EsferaPoder.ESTADUAL)) || esferaPoder
								.getId().equals(
										new Integer(EsferaPoder.FEDERAL)))) {

					MedicaoHistorico medicaoHistoricoPosterior = new MedicaoHistorico();

					// Adiciona 1 ao mês/ano de faturamento para gerar o mês de
					// dezembro
					Integer anoMesFaturamentoAntecipado = (Util.somaMesAnoMesReferencia(sistemaParametro.getAnoMesFaturamento(), 1));
					
					sistemaParametro.setAnoMesFaturamento(anoMesFaturamentoAntecipado);

					medicaoHistoricoPosterior = obterDadosHistoricoMedicao(
							movimentoContaPreFaturada.getFaturamentoGrupo(), imovel, medicaoTipo,
							sistemaParametro);

					// // [UC0102] - Obter Consumo Médio do Hidrômetro
					// int[] consumoMedioHidrometroPosterior =
					// obterConsumoMedioHidrometro(imovel,
					// sistemaParametro, medicaoTipo);

					// Retorna ao mês de referência atual
					Integer anoMesFaturamentoAtual = Util.subtrairMesDoAnoMes(anoMesFaturamentoAntecipado, 1);
					
					sistemaParametro.setAnoMesFaturamento(anoMesFaturamentoAtual);

					medicaoHistoricoPosterior
							.setLeituraAnormalidadeFaturamento(medicaoHistorico
									.getLeituraAnormalidadeFaturamento());
					medicaoHistoricoPosterior
							.setLeituraAnteriorFaturamento(medicaoHistorico
									.getLeituraAtualFaturamento());
					medicaoHistoricoPosterior
							.setDataLeituraAnteriorFaturamento(medicaoHistorico
									.getDataLeituraAtualFaturamento());

					Date dataAtual = new Date();
					
					int qtdDIas = (int) getControladorFaturamento().obterDiferencaDiasCronogramas(
							sistemaParametro.getAnoMesFaturamento(), movimentoContaPreFaturada.getRota(), 
							FaturamentoAtividade.EFETUAR_LEITURA);
					
					medicaoHistoricoPosterior.setDataLeituraAtualFaturamento(
							Util.adicionarNumeroDiasDeUmaData(dataAtual, qtdDIas));

					Integer leituraAtual = medicaoHistorico
							.getLeituraAtualFaturamento()
							+ consumoHistorico.getNumeroConsumoFaturadoMes();

					medicaoHistoricoPosterior
							.setLeituraAtualFaturamento(leituraAtual);

					// // Seta o consumo médio do hidrômetro
					// medicaoHistoricoPosterior.setConsumoMedioHidrometro(new
					// Integer(
					// consumoMedioHidrometroPosterior[0]));

					medicaoHistoricoPosterior
							.setConsumoMedioHidrometro(medicaoHistorico
									.getConsumoMedioHidrometro());

					medicaoHistoricoPosterior.setUltimaAlteracao(new Date());

					if (medicaoHistoricoPosterior.getId() == null) {
						colecaoInserirMedicaoHistoricoAgua
								.add(medicaoHistoricoPosterior);
					} else {
						colecaoAtualizarMedicaoHistoricoAgua
								.add(medicaoHistoricoPosterior);
					}

				}

			}

		}
	}
	
	public MedicaoHistorico pesquisarMedicaoHistoricoAnterior(Integer idImovel,
			Integer anoMes, Integer idMedicaoTipo) throws ControladorException {
		
		MedicaoHistorico medicaoHistorico = null; 
		try {		
			Object[] dadosMedicaoHistorico = repositorioMicromedicao.pesquisarMedicaoHistoricoAnterior(idImovel, anoMes, idMedicaoTipo);

			if (dadosMedicaoHistorico != null && dadosMedicaoHistorico.length > 0) {
				medicaoHistorico = new MedicaoHistorico();
				
				//Data da leitura atual faturada
				if (dadosMedicaoHistorico[0] != null) {
					medicaoHistorico.setDataLeituraAtualFaturamento((Date) dadosMedicaoHistorico[0]);
				} else {
					medicaoHistorico.setDataLeituraAtualFaturamento(null);
				}
				
				//Leitura atual faturada
				if (dadosMedicaoHistorico[1] != null) {
					medicaoHistorico.setLeituraAtualFaturamento((Integer) dadosMedicaoHistorico[1]);
				} else {
					medicaoHistorico.setLeituraAtualFaturamento(0);
				}
				
				//Leitura atual informada
				if (dadosMedicaoHistorico[2] != null) {
					medicaoHistorico.setLeituraAtualInformada((Integer) dadosMedicaoHistorico[2]);
				} else {
					medicaoHistorico.setLeituraAtualInformada(null);
				}
				
				// Situacao da leitura atual 
				if (dadosMedicaoHistorico[3] != null) {
					LeituraSituacao leituraSituacao = new LeituraSituacao();
					leituraSituacao.setId((Integer) dadosMedicaoHistorico[3]);
					
					medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
				} else {
					medicaoHistorico.setLeituraSituacaoAtual(null);
				}
				
				//Anormalidade informada leituraAnormalidadeInformada.id
				if (dadosMedicaoHistorico[4] != null) {
					LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
					leituraAnormalidade.setId((Integer) dadosMedicaoHistorico[4]);
					
					medicaoHistorico.setLeituraAnormalidadeInformada(leituraAnormalidade);
				} else {
					medicaoHistorico.setLeituraAnormalidadeInformada(null);
				}
				
				//Id do medicao historico
				if (dadosMedicaoHistorico[5] != null) {
					medicaoHistorico.setId((Integer) dadosMedicaoHistorico[5]);
				} 
				
				//Data leitura informada
				if (dadosMedicaoHistorico[6] != null) {
					medicaoHistorico.setDataLeituraAtualInformada((Date) dadosMedicaoHistorico[6]);
				} else {
					medicaoHistorico.setDataLeituraAtualInformada(null);
				}
			}

			return medicaoHistorico;
			
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	/*
	 * 
	 * Atualizar campos em Medição Histórico e Consumo Histórico na retificação da conta
	 * 
	 * */
	/**
	 * Método para atualizar a leitura atual faturada no medição histórico,
	 * na retificação da conta
	 *
	 * Autor: Adriana Muniz
	 * Data: 22/07/2011
	 * @param leituraAtual
	 * @param anoMesReferencia
	 * @param idImovel
	 * @throws ControladorException
	 */
	public void atualizarLeituraRetificarConta(Integer leituraAtual, int anoMesReferencia, Integer idImovel)
	throws ControladorException {
		try {
			repositorioMicromedicao.atualizarLeituraRetificaConta(leituraAtual, 
					anoMesReferencia, idImovel);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 *  
	 * relatório de extrato de debito
	 * 
	 * Pesquisa uma rota pelo id da localidade e do setor comercial
	 * 
	 * @author Pamela Gatinho
	 * @date 01/08/2011
	 * 
	 * @param idLocalidade
	 * @param codigoSetorComercial
	 * @throws ControladorException
	 */
	public Rota obterRotaPorLocalidadeSetorComercial(Integer idLocalidade,
			Integer codigoSetorComercial)
			throws ControladorException {

		try {
			return this.repositorioMicromedicao.obterRotaPorLocalidadeSetorComercial(
					idLocalidade, codigoSetorComercial);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	/**
	 * 
	 * Retornar Arquivo Texto Roteiro Empresa completo
	 * 
	 * @author Felipe Santos
	 * @date 28/07/2011
	 * 
	 */
	public Collection pesquisarArquivosTextoRoteiroEmpresaCompletoParaArquivoZip(
			String[] ids) throws ControladorException {

		Collection colecaoArquivoTextoRoteiroEmpresa = new ArrayList();

		try {
			colecaoArquivoTextoRoteiroEmpresa = repositorioMicromedicao
					.pesquisarArquivosTextoRoteiroEmpresaCompletoParaArquivoZip(ids);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return colecaoArquivoTextoRoteiroEmpresa;

	}
	
	/**
	 * Retornar Arquivo Texto Roteiro Empresa por 
	 * Localidade, Id da Rota e Ano/Mês de Referência
	 * 
	 * @author Felipe Santos
	 * @date 05/08/2011
	 * 
	 */
	public ArquivoTextoRoteiroEmpresa pesquisarArquivosTextoRoteiroEmpresaTransmissaoOffline(
			Integer idLocalidade,Integer idRota, Integer anoMesReferencia) throws ControladorException {

		ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = new ArquivoTextoRoteiroEmpresa();

		try {
			arquivoTextoRoteiroEmpresa = repositorioMicromedicao
					.pesquisarArquivosTextoRoteiroEmpresaTransmissaoOffline(idLocalidade, idRota, anoMesReferencia);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return arquivoTextoRoteiroEmpresa;
	}
	
	/**
	 * Retornar Arquivo Texto Roteiro Empresa Divisão
	 * 
	 * @author Felipe Santos
	 * @date 05/08/2011
	 */
	public ArquivoTextoRoteiroEmpresaDivisao pesquisarArquivosTextoRoteiroEmpresaDivisao(Integer atreId, 
			Integer numeroSequenciaArquivo) throws ControladorException {

		ArquivoTextoRoteiroEmpresaDivisao arquivoTextoRoteiroEmpresaDivisao = new ArquivoTextoRoteiroEmpresaDivisao();

		try {
			arquivoTextoRoteiroEmpresaDivisao = repositorioMicromedicao
					.pesquisarArquivoTextoRoteiroEmpresaDivisao(atreId, numeroSequenciaArquivo);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		return arquivoTextoRoteiroEmpresaDivisao;
	}
	
	/**
	 * 
	 * Pamela Gatinho - 08/09/2011
	 * 
	 * Gerar dados para o relatorio de leituras realizadas
	 * 
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @param tipoRelatorio
	 * @param usuarioLogado
	 * 
	 * @return
	 * 
	 * @throws ControladorException
	 */
	public Collection pesquisarDadosRelatorioLeiturasRealizadas(
			int anoMesFaturamento, Integer idFaturamentoGrupo) throws ControladorException {

		Collection retorno = new ArrayList();
		try {
			Collection colecaoObjeto = repositorioMicromedicao
					.pesquisarDadosRelatorioLeiturasRealizadas(anoMesFaturamento, idFaturamentoGrupo);
			if (colecaoObjeto != null && !colecaoObjeto.isEmpty()) {
				Iterator iterator = colecaoObjeto.iterator();

				while (iterator.hasNext()) {
					RelatorioLeiturasRealizadasHelper relatorioLeiturasRealizadasHelper = new RelatorioLeiturasRealizadasHelper();
					Object[] objeto = (Object[]) iterator.next();
					
					// referencia
					if (objeto[0] != null) {
						relatorioLeiturasRealizadasHelper.setAnoMesReferencia((String) objeto[0]);
					}

					// grupo
					if (objeto[1] != null) {
						relatorioLeiturasRealizadasHelper.setGrupo((String) objeto[1]);
					}
					
					// empresa
					if (objeto[2] != null) {
						relatorioLeiturasRealizadasHelper.setEmpresa((String) objeto[2]);
					}
					// localidade
					if (objeto[4] != null) {
						relatorioLeiturasRealizadasHelper.setLocalidade((String) objeto[4]);
					}
					
					// qtd rotas em campo
					if (objeto[5] != null) {
						relatorioLeiturasRealizadasHelper.setQtdRotasEmCampo((Integer) objeto[5]);
					}
					// qtd rotas transmitidas
					if (objeto[6] != null) {
						relatorioLeiturasRealizadasHelper.setQtdRotasTransmitidas((Integer) objeto[6]);
					}
					// qtd rotas finalizadas pelo usuario
					if (objeto[7] != null) {
						relatorioLeiturasRealizadasHelper.setQtdRotasFinalizadasPeloUsuario((Integer) objeto[7]);
					}
					// qtd total
					if (objeto[8] != null) {
						relatorioLeiturasRealizadasHelper.setQtdTotalLocal((Integer) objeto[8]);
					}
					// qtd imoveis em campo
					if (objeto[9] != null) {
						relatorioLeiturasRealizadasHelper.setQtdImoveisEmCampo((Integer) objeto[9]);
					}
					// qtd imoveis transmitidos rota parcial
					if (objeto[10] != null) {
						relatorioLeiturasRealizadasHelper.setQtdImoveisTransmitidosDeRotaParcial((Integer) objeto[10]);
					}
					
					relatorioLeiturasRealizadasHelper
							.setAnoMesReferencia(Util
									.formatarAnoMesParaMesAnoSemBarra(anoMesFaturamento));

					retorno.add(relatorioLeiturasRealizadasHelper);

				}

			}
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}
	
	
	/**
	 * Autor: Adriana Muniz
	 * Data: 22/07/2011
	 * 
	 * Verifica se há diferença entre a leitura persistida e a passada como parametro
	 * 
	 * Utilizado na retificação de contas
	 * 
	 * @param leituraAtual
	 * @param anoMesReferencia
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public boolean verificarLeituraAtualFaturadaImovel(Integer leituraAtual, int anoMesReferencia, Integer idImovel) throws ControladorException {
		boolean leituraAlterada = false;
		try{
			Object[] leituras;
			Integer leituraAtualFaturada;
			
			leituras = repositorioMicromedicao.obterLeituraAnteriorEAtualFaturamentoMedicaoHistorico(idImovel, anoMesReferencia);
			
			
			if(leituras.length > 0){
				leituraAtualFaturada = (Integer)leituras[1];
				
				if((leituraAtualFaturada != null && !leituraAtualFaturada.equals(leituraAtual))
								|| (leituraAtualFaturada == null && leituraAtual != null))
			/*	if(!leituraAnteriorPesquisada.equals(leituraAnterior) ||
						!leituraAtualPesquisada.equals(leituraAtual))*/
					leituraAlterada = true;
			}
			
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		
		return leituraAlterada;
	}
	
	/**
	 * Autor: Adriana Muniz
	 * Data: 22/07/2011
	 * 
	 * Consulta arquivo de rota por ano/mes referencia e grupo
	 * 
	 * Utilizado na retificação de contas
	 * 
	 * @param idGrupo
	 * @param referencia
	 * @return
	 * @throws ControladorException
	 */
	public boolean pesquisaArquivoRotaPorGrupoEReferencia(Integer idGrupo, int referencia)
		throws ControladorException {
		
		boolean pesquisa;
		
		try {
			pesquisa = repositorioMicromedicao.pesquisaArquivoRotaPorGrupoEReferencia(
					idGrupo, Util.somaUmMesAnoMesReferencia(referencia));
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		
		return pesquisa;
	}
	
	/**
	 *
	 * 
	 * Método para obter todos os imóveis que faltam ser processados
	 * na transmissão offline do arquivo de retorno do IS 
	 * 
	 * @author Felipe Santos
	 * @date 26/01/2012
	 * 
	 * @param idRota
	 * @return List<Integer> retorno
	 * @throws ErroRepositorioException
	 */
	public List<Integer> obterImoveisNaoEnviadosMovimentoContaPreFaturada(Integer idRota, Integer anoMesFaturamento)
			throws ControladorException {

		List<Integer> listaImoveisNaoTransmitidos = null;
		
		try {
			listaImoveisNaoTransmitidos = repositorioFaturamento.obterImoveisFaltandoTransmitir(idRota, anoMesFaturamento);
			
			/*
			 * Felipe Santos - 26/01/2012
			 * 
			 * Verificação para rotas com imóveis condomínio a
			 * serem incluídos no arquivo parcial da rota CASO
			 * não tenha encerrado a leitura do condomínio.
			 */
			
			// obtém os dados da rota
			Rota rota = repositorioMicromedicao.pesquisarRota(idRota);
			
			// pesquisa imoveis condominio macro na rota
			Collection colecaoImoveisCondominioMacroPorRota = repositorioFaturamento.pesquisarImoveisCondominioMacro(rota);
			
			Iterator colecaoImoveisPorRotaIterator = (Iterator) colecaoImoveisCondominioMacroPorRota.iterator();
			
			Imovel imovel = null;			
			
			// caso haja condominio na rota será verificado 
			// se falta leitura para algum imovel micro
			if (colecaoImoveisCondominioMacroPorRota != null && !colecaoImoveisCondominioMacroPorRota.isEmpty()) {
				
				while (colecaoImoveisPorRotaIterator.hasNext()) {
					
					boolean indicadorCondominioNaoTransmitido = false;
					
					imovel = (Imovel) colecaoImoveisPorRotaIterator.next();
				
					// lista de imoveis de condominio
					List<Integer> listaImoveisCondominio = new ArrayList<Integer>();

					// adiciona o imovel macro la lista de imoveis de condominio
					listaImoveisCondominio.add(imovel.getId());

					// lista de condominios micro
					List<Integer> listaImoveisMicro = repositorioFaturamento.pesquisarImoveisCondominioMicro(imovel.getId());

					// adiciona todos os imoveis micro na lista de condominio
					listaImoveisCondominio.addAll(listaImoveisMicro);
					
					// para cada imovel não transmitido, verifica se esse imóvel
					// contém na lista de imóveis condomínio. Caso esteja, remove
					// o imóvel da lista de condomonio
					for (int i = 0; i < listaImoveisNaoTransmitidos.size(); i++) {

						Integer imovelNaoTransmitido = listaImoveisNaoTransmitidos.get(i);
						
						if (listaImoveisCondominio.contains(imovelNaoTransmitido)) {
							listaImoveisCondominio.remove(imovelNaoTransmitido);
							indicadorCondominioNaoTransmitido = true;
						} 
					}
					
					if (indicadorCondominioNaoTransmitido == true) {
						// adiciona os imóveis restantes do condominio na lista de
						// imóveis não transmitidos
						listaImoveisNaoTransmitidos.addAll(listaImoveisCondominio);
					}									
				}
			}			
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		
		return listaImoveisNaoTransmitidos;
	}
	
	private Integer obterLeituraInstalacaoHidrometro(FaturamentoGrupo faturamentoGrupo, Imovel imovel) {

		Integer leituraInicialHidrometro = 0;
		Integer anoMesReferenciaAnterior = Util.subtrairMesDoAnoMes(faturamentoGrupo.getAnoMesReferencia(), 1);
		Collection dadosMedicao;
		try {
			
			dadosMedicao = this.obterDadosTiposMedicao(imovel, anoMesReferenciaAnterior);
		
			if (dadosMedicao != null && !dadosMedicao.isEmpty()){
				
				Iterator iterator = dadosMedicao.iterator();
				
				while(iterator.hasNext()){
						
					Object[] arrayMedicaoHistorico = (Object[]) iterator.next();
					
					if(!arrayMedicaoHistorico[13].equals(null)){
						leituraInicialHidrometro = (Integer)arrayMedicaoHistorico[13];
					}
				}
			}
		} catch (ControladorException e) {
			e.printStackTrace();
		}
		return leituraInicialHidrometro;
	}

	/**
	 * 
	 * @author Pamela Gatinho
	 * @since 23/04/2012
	 * 
	 * Método que calcula o VALOR a ser rateado, baseado no
	 * CONSUMO de rateio do macro.
	 * 
	 * @param imovelCondominio
	 * @param anoMesFaturamento
	 * @param consumoSerRateado
	 * @param consumoAguaSerRateado
	 * @param faturamentoGrupo
	 * 
	 * @return valorConta 
	 * 
	 * @throws ControladorException 
	 */
	private BigDecimal calcularContaAguaParaRateio(
			Imovel imovelCondominio, Integer anoMesFaturamento, int consumoAguaSerRateado, FaturamentoGrupo faturamentoGrupo) throws ControladorException {
		
		Collection colecaoCategoriaOUSubcategoria = getControladorImovel().obterColecaoCategoriaOuSubcategoriaDoImovel(imovelCondominio);
		
		BigDecimal valorConta = new BigDecimal("0.00");
		
		LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
		ligacaoTipoAgua.setId(LigacaoTipo.LIGACAO_AGUA);
		
		ConsumoHistorico consumoHistoricoAgua = this.obterConsumoHistoricoMedicaoIndividualizada(imovelCondominio,
				ligacaoTipoAgua, anoMesFaturamento);
		
		consumoHistoricoAgua.setNumeroConsumoFaturadoMes(consumoAguaSerRateado);
		LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
		ligacaoTipoEsgoto.setId(LigacaoTipo.LIGACAO_ESGOTO);
		
		ConsumoHistorico consumoHistoricoEsgoto = this.obterConsumoHistoricoMedicaoIndividualizada(imovelCondominio,
				ligacaoTipoEsgoto, anoMesFaturamento);
		
		imovelCondominio = this.getControladorImovel().pesquisarImovel(imovelCondominio.getId());
		
		int consumoMinimoLigacao = this.obterConsumoMinimoLigacao(imovelCondominio, null);
		
		DeterminarValoresFaturamentoAguaEsgotoHelper helperValoresAguaEsgoto = new DeterminarValoresFaturamentoAguaEsgotoHelper();
		
		helperValoresAguaEsgoto = getControladorFaturamento()
		.determinarValoresFaturamentoAguaEsgoto(imovelCondominio,
				anoMesFaturamento, colecaoCategoriaOUSubcategoria,
				faturamentoGrupo, consumoHistoricoAgua,
				consumoHistoricoEsgoto);
		
		if (helperValoresAguaEsgoto.getValorTotalAgua() != null) {
			valorConta = valorConta.add(helperValoresAguaEsgoto.getValorTotalAgua());
		}
		
		if (helperValoresAguaEsgoto.getValorTotalEsgoto() != null ) {
			valorConta = valorConta.add(helperValoresAguaEsgoto.getValorTotalEsgoto());
		}
		
		return valorConta;
	}
	
	public void atualizarConsumosCondominios(Rota rota, LigacaoTipo ligacaoTipo) throws ControladorException {
		
		List<Imovel> condominios = getControladorImovel().pesquisarCondominios(rota);
		for (Imovel condominio : condominios) {
			ConsumoHistorico consumoMacro = this.obterConsumoHistorico(condominio, ligacaoTipo, rota.getFaturamentoGrupo().getAnoMesReferencia());
			int consumoMicros = this.obterConsumoLigacaoImoveisVinculados(condominio.getId(), rota.getFaturamentoGrupo().getAnoMesReferencia(), ligacaoTipo.getId());

			if (condominio.getId().intValue() == 2419734) {
				System.out.println("cheguei...");
			}
			if (consumoMacro != null && consumoMacro.getConsumoImovelVinculadosCondominio() != null
					&& consumoMacro.getConsumoImovelVinculadosCondominio().intValue() != consumoMicros) {
				int rateio = consumoMacro.getNumeroConsumoFaturadoMes() - consumoMicros;
				
				consumoMacro.setConsumoRateio(rateio);
				consumoMacro.setConsumoImovelVinculadosCondominio(consumoMicros);
				consumoMacro.setUltimaAlteracao(new Date());
				
				getControladorUtil().atualizar(consumoMacro);
			}
		}
	}
	
	/**
	 * 
	 * Pamela Gatinho - 31/05/2012
	 * 
	 * Metodo que calcula o consumo do a ser rateado de agua e 
	 * esgoto do condominio.
	 *  
	 * @param idImovelCondominio
	 * @param anoMesFaturamento
	 * @param ligacaoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
    public int obterConsumoASerRateado(Integer idImovelCondominio, Integer anoMesFaturamento, Integer ligacaoTipo) {

        Integer consumoImovelCondomino = new Integer(0);

        int consumoASerRateado = 0;
        
        try {
            Object[] dadosConsumoLigacaoAguaImovelCondominio = (Object[]) this.repositorioMicromedicao
                    .obterConsumoLigacaoAguaOuEsgotoDoImovel(idImovelCondominio, anoMesFaturamento, ligacaoTipo);
            
            if (dadosConsumoLigacaoAguaImovelCondominio!= null &&
            	dadosConsumoLigacaoAguaImovelCondominio[0] != null &&
            	dadosConsumoLigacaoAguaImovelCondominio[1] != null) {
            	
            	logger.info("Entrou no if do  obterConsumoASerRateado");
            	
            	Integer idConsumoHistoricoLigacao = (Integer) dadosConsumoLigacaoAguaImovelCondominio[0];
            	Integer consumoLigacaoImovelCondominio = (Integer) dadosConsumoLigacaoAguaImovelCondominio[1];
            	
            	int consumoAguaImoveisVinculados = this.obterConsumoLigacaoImoveisVinculados(idImovelCondominio, anoMesFaturamento, ligacaoTipo);
            	
            	if (consumoLigacaoImovelCondominio != null) {
            		consumoImovelCondomino = consumoLigacaoImovelCondominio;
            	}
            	
            	consumoASerRateado = consumoImovelCondomino - consumoAguaImoveisVinculados;
            }
        } catch (ControladorException e) {
			e.printStackTrace();
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
        
        logger.info("consumoASerRateado = " + consumoASerRateado);

        return consumoASerRateado;
    }
	
	public int obterConsumoLigacaoImoveisVinculados(Integer idImovelCondominio, Integer anoMesFaturamento, Integer ligacaoTipo) throws ControladorException {
		
		int consumoImoveisVinculados = 0;
		
		Collection imoveisVinculadosArrayObject = this.obterImoveisVinculadosDoCondominio(idImovelCondominio);
		
		Iterator imoveisVinculadosIterator = imoveisVinculadosArrayObject.iterator();
		
		while (imoveisVinculadosIterator.hasNext()) {
			
			try {
				Object[] dadosImovelVinculado = (Object[]) imoveisVinculadosIterator.next();
				
				// Obtem o objeto imovel
				Imovel imovelVinculado = this.converterImovelVinculado(dadosImovelVinculado);
				
				Integer consumoLigacaoImovel = null;
				
				Object[] dadosConsumoLigacaoImovel;
					dadosConsumoLigacaoImovel = (Object[]) this.repositorioMicromedicao
						.obterConsumoLigacaoAguaOuEsgotoDoImovel(imovelVinculado.getId(), anoMesFaturamento, ligacaoTipo);
				
				
				// Verifica se possui faturamento ativo para agua ou esgoto
				if ( (ligacaoTipo.equals(LigacaoTipo.LIGACAO_AGUA) && getControladorImovel().isFaturamentoAguaAtivo(imovelVinculado))
					|| (ligacaoTipo.equals(LigacaoTipo.LIGACAO_ESGOTO)&& getControladorImovel().isFaturamentoEsgotoAtivo(imovelVinculado))) {
	
					// Recupera o consumo do imovel
					if (dadosConsumoLigacaoImovel != null && dadosConsumoLigacaoImovel[1] != null) {
						consumoLigacaoImovel = (Integer) dadosConsumoLigacaoImovel[1];
					}
					// Soma o consumo de todos os imóveis
					if (consumoLigacaoImovel != null) {
						consumoImoveisVinculados = consumoImoveisVinculados + consumoLigacaoImovel.intValue();
					}
				} 
			} catch (ErroRepositorioException e) {
				e.printStackTrace();
			}
		}
		
		return consumoImoveisVinculados;
	}
	
	private Imovel converterImovelVinculado(Object[] dadosImovelVinculado) {

		Integer idImovelVinculado = (Integer) dadosImovelVinculado[0];
		
		Short quantidadeEconomia = (Short) dadosImovelVinculado[1];
		Integer idSituacaoLigacaoAguaImovelVinculado = (Integer) dadosImovelVinculado[2];
		Short indFatSitLigacaoAguaImovelVinculado = (Short) dadosImovelVinculado[8];
		Integer idSituacaoLigacaoEsgotoImovelVinculado = (Integer) dadosImovelVinculado[3];
		Short indFatSitLigacaoEsgotoImovelVinculado = (Short) dadosImovelVinculado[9];
		Integer idMedicaoPoco = (Integer) dadosImovelVinculado[4];
		Integer idConsumoTarifa = (Integer) dadosImovelVinculado[5];

		Integer idHidrometroInstalacaoHistorico;
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = null;
		if (dadosImovelVinculado[7] != null) {
			idHidrometroInstalacaoHistorico = (Integer) dadosImovelVinculado[7];
			hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
			hidrometroInstalacaoHistorico.setId(idHidrometroInstalacaoHistorico);
		}

		Integer idLigacaoAgua = (Integer) dadosImovelVinculado[6];
		LigacaoAgua ligacaoAgua = new LigacaoAgua();
		ligacaoAgua.setId(idLigacaoAgua);
		ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);

		// Monta imóvel vinculado e seta os dados no objeto
		ConsumoTarifa consumoTarifa = new ConsumoTarifa();
		consumoTarifa.setId(idConsumoTarifa);

		LigacaoAguaSituacao ligacaoAguaSituacaoImovelVinculado = new LigacaoAguaSituacao();
		ligacaoAguaSituacaoImovelVinculado.setId(idSituacaoLigacaoAguaImovelVinculado);
		ligacaoAguaSituacaoImovelVinculado.setIndicadorFaturamentoSituacao(indFatSitLigacaoAguaImovelVinculado);

		LigacaoEsgotoSituacao ligacaoEsgotoSituacaoImovelVinculado = new LigacaoEsgotoSituacao();
		ligacaoEsgotoSituacaoImovelVinculado.setId(idSituacaoLigacaoEsgotoImovelVinculado);
		ligacaoEsgotoSituacaoImovelVinculado.setIndicadorFaturamentoSituacao(indFatSitLigacaoEsgotoImovelVinculado);
		
		HidrometroInstalacaoHistorico medicaoPoco = new HidrometroInstalacaoHistorico();
		medicaoPoco.setId(idMedicaoPoco);

		Imovel imovelVinculado = new Imovel();
		imovelVinculado.setId(idImovelVinculado);
		imovelVinculado.setLigacaoAgua(ligacaoAgua);
		imovelVinculado.setLigacaoAguaSituacao(ligacaoAguaSituacaoImovelVinculado);
		imovelVinculado.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacaoImovelVinculado);
		imovelVinculado.setHidrometroInstalacaoHistorico(medicaoPoco);
		imovelVinculado.setConsumoTarifa(consumoTarifa);
		imovelVinculado.setQuantidadeEconomias(quantidadeEconomia);

		return imovelVinculado;
	}
	
	public int obterQuantidadeEconomiasCondominio (Integer idImovelCondominio, Integer anoMesFaturamento) {
		int quantidadeEconomias = 0;

		try {
			BigDecimal valorRateioPorEconomia = new BigDecimal(0);
			
			
			Collection imoveisVinculadosArrayObject;
			imoveisVinculadosArrayObject = this.obterImoveisVinculadosDoCondominio(idImovelCondominio);
		
			Iterator iteratorImoveisVinculados = imoveisVinculadosArrayObject.iterator();
			
			while (iteratorImoveisVinculados.hasNext()) {
				
				Object[] dadosImovelVinculado = (Object[]) iteratorImoveisVinculados.next();
				Imovel imovelVinculado = this.converterImovelVinculado(dadosImovelVinculado);
				
				quantidadeEconomias = quantidadeEconomias + imovelVinculado.getQuantidadeEconomias();
			}
		
		} catch (ControladorException e) {
			e.printStackTrace();
		}
		
		return quantidadeEconomias;
	}
	
	public void calcularLeituraConfirmada(Integer leituraAnterior,
			Integer leituraAtual, LeituraSituacao leituraSituacao, Integer idImovel, Integer anoMes, 
			FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro, String dataLeituraAtualInformada, 
			Integer idLeituraAnormalidade, boolean alterouAnormalidade)  throws ControladorException {

		Object[] arrayImovel = null;
		Imovel imovel = new Imovel();
		int mes = 0;
		
		try {
			
			Date dataLeituraAtualInform = Util.converteStringParaDate(dataLeituraAtualInformada);
			
			arrayImovel = this.repositorioMicromedicao.pesquisarImovelPelaMatricula(idImovel);
			Rota rota = this.repositorioMicromedicao.buscarRotaDoImovel(idImovel);
			rota = this.repositorioMicromedicao.pesquisarRota(rota.getId());
			
			imovel = obterImovelLigadoCortadoAguaLigadoEsgoto(arrayImovel);

			MedicaoTipo medicaoTipo = new MedicaoTipo(MedicaoTipo.LIGACAO_AGUA);
			MedicaoHistorico medicaoHistoricoAgua = obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo, sistemaParametro);

			LigacaoTipo ligacaoTipo = new LigacaoTipo(LigacaoTipo.LIGACAO_AGUA);
			ConsumoHistorico consumoHistoricoAgua = obterConsumoHistorico(imovel, ligacaoTipo, anoMes);

			ConsumoTipo consumoTipo = new ConsumoTipo(ConsumoTipo.REAL);
			consumoHistoricoAgua.setConsumoTipo(consumoTipo);

			int consumoMedidoMes = leituraAtual - obterLeituraAnterior(medicaoHistoricoAgua);
			int consumoFaturadoMes = consumoMedidoMes;

			consumoHistoricoAgua.setNumeroConsumoFaturadoMes(new Integer(consumoFaturadoMes));
			consumoHistoricoAgua.setImovel(imovel);
			consumoHistoricoAgua.setUltimaAlteracao(new Date());
			
			medicaoHistoricoAgua.setNumeroConsumoMes(new Integer(consumoMedidoMes));
			medicaoHistoricoAgua.setLeituraSituacaoAtual(leituraSituacao);
			medicaoHistoricoAgua.setDataLeituraAtualInformada(dataLeituraAtualInform);
			medicaoHistoricoAgua.setLeituraCampo(leituraAtual);
			medicaoHistoricoAgua.setUltimaAlteracao(new Date());
			
			if(alterouAnormalidade) {
				if(medicaoHistoricoAgua.getLeituraAnormalidadeInformada() == null) {
					medicaoHistoricoAgua.setLeituraAnormalidadeInformada(new LeituraAnormalidade());
				}
				
				medicaoHistoricoAgua.getLeituraAnormalidadeInformada().setId(idLeituraAnormalidade);
			}

			boolean houveInstalacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(imovel.getId(), medicaoTipo);
			
			int[] consumoMedioHidrometro = obterVolumeMedioAguaEsgoto(imovel.getId(), sistemaParametro.getAnoMesFaturamento(), medicaoTipo.getId(), houveInstalacaoHidrometro);
//			int mediaConsumoHidrometro = consumoMedioHidrometro[0];
			consumoHistoricoAgua.setNumeroConsumoCalculoMedia(consumoFaturadoMes);

			determinarAjusteMensal(medicaoHistoricoAgua, consumoHistoricoAgua, imovel, rota, consumoMedioHidrometro[0], sistemaParametro);
			
			repositorioUtil.atualizar(consumoHistoricoAgua);
			repositorioUtil.atualizar(medicaoHistoricoAgua);
			
			atualizarExcecoesConsumoHistoricoEsgoto(consumoHistoricoAgua);
			atualizarExcecoesMedicaoHistoricoEsgoto(medicaoHistoricoAgua, faturamentoGrupo, sistemaParametro, alterouAnormalidade);
			
			mes = Util.obterMes(faturamentoGrupo.getAnoMesReferencia());
			Short indicadorDebitoContaImovel = (Short)arrayImovel[15];
			EsferaPoder esferaPoder = null;

			if (arrayImovel[26] != null) {
				esferaPoder = new EsferaPoder();
				esferaPoder.setId((Integer) arrayImovel[26]);
			}
			
			if (isConsumoAntecipado(mes, indicadorDebitoContaImovel, esferaPoder)){
				
				Integer anoMesReferenciaAntecipada = Util.somaMesAnoMesReferencia(faturamentoGrupo.getAnoMesReferencia(), 1);
				faturamentoGrupo.setAnoMesReferencia(anoMesReferenciaAntecipada);
				sistemaParametro.setAnoMesFaturamento(anoMesReferenciaAntecipada);
				anoMes = anoMesReferenciaAntecipada;
				
				MedicaoHistorico medicaoHistoricoAntecipado = obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo, sistemaParametro);
				ConsumoHistorico consumoHistoricoAntecipado = obterConsumoHistorico(imovel, ligacaoTipo, anoMes);
				
				consumoHistoricoAntecipado.setNumeroConsumoFaturadoMes(new Integer(consumoFaturadoMes));
				consumoHistoricoAntecipado.setImovel(imovel);
				consumoHistoricoAntecipado.setUltimaAlteracao(new Date());
				medicaoHistoricoAntecipado.setNumeroConsumoMes(new Integer(consumoMedidoMes));
				medicaoHistoricoAntecipado.setLeituraCampo(leituraAtual);
				medicaoHistoricoAntecipado.setUltimaAlteracao(new Date());
				if(alterouAnormalidade) {
					if(medicaoHistoricoAntecipado.getLeituraAnormalidadeInformada() == null)
						medicaoHistoricoAntecipado.setLeituraAnormalidadeInformada(new LeituraAnormalidade());
					
					medicaoHistoricoAntecipado.getLeituraAnormalidadeInformada().setId(idLeituraAnormalidade);
				}
				
				consumoHistoricoAntecipado.setNumeroConsumoCalculoMedia(consumoFaturadoMes);

				repositorioUtil.atualizar(consumoHistoricoAntecipado);
				repositorioUtil.atualizar(medicaoHistoricoAntecipado);
				
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private void atualizarExcecoesConsumoHistoricoEsgoto(ConsumoHistorico consumoHistoricoAgua) throws ControladorException, ErroRepositorioException {
		ConsumoHistorico consumoHistoricoEsgoto = obterConsumoHistorico(consumoHistoricoAgua.getImovel(), 
				new LigacaoTipo(LigacaoTipo.LIGACAO_ESGOTO), consumoHistoricoAgua.getReferenciaFaturamento());
		
		if (consumoHistoricoEsgoto != null) {
			consumoHistoricoEsgoto.setConsumoTipo(consumoHistoricoAgua.getConsumoTipo());
			consumoHistoricoEsgoto.setConsumoTipo(consumoHistoricoAgua.getConsumoTipo());
			consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(new Integer(consumoHistoricoAgua.getNumeroConsumoFaturadoMes()));
			consumoHistoricoEsgoto.setImovel(consumoHistoricoAgua.getImovel());
			consumoHistoricoEsgoto.setUltimaAlteracao(new Date());
			consumoHistoricoEsgoto.setNumeroConsumoCalculoMedia(consumoHistoricoAgua.getNumeroConsumoCalculoMedia());
			repositorioUtil.atualizar(consumoHistoricoEsgoto);
		}
	}
	
	private void atualizarExcecoesMedicaoHistoricoEsgoto(MedicaoHistorico medicaoHistoricoAgua, FaturamentoGrupo faturamentoGrupo, 
			SistemaParametro sistemaParametro, boolean alterouAnormalidade) throws ControladorException, ErroRepositorioException {
		MedicaoHistorico medicaoHistoricoEsgoto = obterDadosHistoricoMedicao(faturamentoGrupo, new Imovel(medicaoHistoricoAgua.getLigacaoAgua().getId()), 
				new MedicaoTipo(MedicaoTipo.POCO), sistemaParametro);
	
		if (medicaoHistoricoEsgoto != null) {
			medicaoHistoricoEsgoto.setNumeroConsumoMes(new Integer(medicaoHistoricoAgua.getNumeroConsumoMes()));
			medicaoHistoricoEsgoto.setLeituraSituacaoAtual(medicaoHistoricoAgua.getLeituraSituacaoAtual());
			medicaoHistoricoEsgoto.setDataLeituraAtualInformada(medicaoHistoricoAgua.getDataLeituraAtualInformada());
			medicaoHistoricoEsgoto.setLeituraCampo(medicaoHistoricoAgua.getLeituraCampo());
			medicaoHistoricoEsgoto.setUltimaAlteracao(new Date());
			medicaoHistoricoEsgoto.setLeituraAnormalidadeInformada(medicaoHistoricoAgua.getLeituraAnormalidadeInformada());
			repositorioUtil.atualizar(medicaoHistoricoEsgoto);
		}
	}

	private boolean isConsumoAntecipado(int mes,
			Short indicadorDebitoContaImovel, EsferaPoder esferaPoder) {
		return indicadorDebitoContaImovel.equals(
				Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
				&& (mes == 11)
				&& esferaPoder != null
				&& (esferaPoder.getId().equals(
						new Integer(EsferaPoder.MUNICIPAL))
						|| esferaPoder.getId().equals(
								new Integer(EsferaPoder.ESTADUAL)) || esferaPoder
						.getId().equals(
								new Integer(EsferaPoder.FEDERAL)));
	}
	
	/**
	 * Buscar Rota a qual o imóvel pertence.
	 * 
	 * @param matricula
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Rota buscarRotaDoImovel(Integer matricula) throws ControladorException {
		Rota rota = null;

		try {
			rota = repositorioMicromedicao.buscarRotaDoImovel(matricula);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return rota;

	}
	
	/**
	 * 
	 * Verificar se o imóvel está com o arquivo de leitura em campo.
	 * 
	 * @author Pamela Gatinho
	 * @date 01/10/2013
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return
	 * @throws ControladorException
	 */
	public void validarImovelEmCampo(Integer idImovel) throws ControladorException {
		try {
			if (isImovelEmCampo(idImovel)) {
				Rota rota = this.buscarRotaDoImovel(idImovel);
				throw new ControladorException("atencao.imovel_em_campo", null, Util.formatarAnoMesParaMesAno(rota.getFaturamentoGrupo().getAnoMesReferencia()).toString());
			}
		} catch (ControladorException ex) {
			throw ex;
		} catch (Exception e) {
			throw new ControladorException("erro.sistema");
		}
	}
	
	public boolean isImovelEmCampo(Integer idImovel) throws Exception {
		Rota rota = this.buscarRotaDoImovel(idImovel);
		
		boolean isProcessoIniciado = getControladorBatch().isProcessoFaturamentoIniciado(rota.getFaturamentoGrupo());
		
		return (rota.isRotaImpressaoSimultanea() && isProcessoIniciado);
	}
	
	/**
	 *
	 * 
	 * @autor: Wellington Rocha
	 * @date: 03/07/2012
	 * 
	 *        Pesquisar Hidrometro Protecao
	 * 
	 * @return Collection
	 * @throws ControladorException
	 * 
	 */
	public Collection<HidrometroProtecao> pesquisarHidrometroProtecao()
			throws ControladorException {
		try {
			Collection<HidrometroProtecao> hidrometros = new ArrayList<HidrometroProtecao>();
			Collection colecao = this.repositorioMicromedicao.pesquisarHidrometroProtecao();

			if (colecao != null && !colecao.isEmpty()) {
				Iterator colecaoIterator = colecao.iterator();

				while (colecaoIterator.hasNext()) {
					HidrometroProtecao hidrometroProtecao = (HidrometroProtecao) colecaoIterator
							.next();
					hidrometros.add(hidrometroProtecao);
				}
			}

			return hidrometros;
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 *
	 * 
	 * @autor: Wellington Rocha
	 * @date: 03/07/2012
	 * 
	 *        Pesquisar Hidrometro Marca
	 * 
	 * @return Collection
	 * @throws ControladorException
	 * 
	 */
	public Collection<HidrometroMarca> pesquisarHidrometroMarca()
			throws ControladorException {
		try {
			Collection<HidrometroMarca> hidrometros = new ArrayList<HidrometroMarca>();
			Collection colecao = this.repositorioMicromedicao.pesquisarHidrometroMarca();

			if (colecao != null && !colecao.isEmpty()) {
				Iterator colecaoIterator = colecao.iterator();

				while (colecaoIterator.hasNext()) {
					HidrometroMarca hidrometroMarca = (HidrometroMarca) colecaoIterator
							.next();
					hidrometros.add(hidrometroMarca);
				}
			}

			return hidrometros;
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	public Collection<DadosMovimentacao> buscarImoveisFaturamentoSeletivo(Integer matriculaImovel, Rota rota, boolean manter) throws ControladorException, ErroRepositorioException {
		Collection<DadosMovimentacao> colecao = new ArrayList<DadosMovimentacao>();
		
		Integer anoMesReferencia = rota.getFaturamentoGrupo().getAnoMesReferencia();
		
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		sistemaParametro.setAnoMesFaturamento(anoMesReferencia);
		
		Collection<ImovelPorRotaHelper> colecaoImoveisPorRotaHelper = repositorioMicromedicao.buscarImoveisFaturamentoSeletivo(matriculaImovel, rota.getId(), rota.getFaturamentoGrupo().getAnoMesReferencia());

		Iterator<ImovelPorRotaHelper> iteratorImovelPorRotaHelper = colecaoImoveisPorRotaHelper.iterator();
		while (iteratorImovelPorRotaHelper.hasNext()) {
			
			DadosMovimentacao dado = obterDadosMedicaoImovelPorRota(rota, anoMesReferencia, manter, sistemaParametro, iteratorImovelPorRotaHelper);
			
			if (dado != null) {
				colecao.add(dado);
			}
		}

		return colecao;
	}
	
	public LigacaoAgua obterLigacaoAgua(Integer idLigacao) throws ControladorException {
		try {
			return repositorioMicromedicao.obterLigacaoAgua(idLigacao);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	public void incluirMedicaoHistoricoFaturamentoSeletivo(ImovelFaturamentoSeletivo imovelFaturamentoSeletivo) throws Exception {
		
		LigacaoAgua ligacaoAgua = this.obterLigacaoAgua(imovelFaturamentoSeletivo.getIdImovel());
		Imovel imovel = getControladorImovel().pesquisarImovel(imovelFaturamentoSeletivo.getIdImovel());
		MedicaoTipo medicaoTipo = new MedicaoTipo(MedicaoTipo.LIGACAO_AGUA);
		
		FaturamentoGrupo grupo = getControladorImovel().pesquisarGrupoImovel(ligacaoAgua.getId());
		Integer anoMesAnterior = Util.subtrairMesDoAnoMes(new Integer(grupo.getAnoMesReferencia()).intValue(), 1);
		
		//MedicaoHistorico medicaoAnterior = this.pesquisarMedicaoHistoricoAnterior(ligacaoAgua.getId(),anoMesAnterior, medicaoTipo.getId());
		
		boolean houveIntslacaoHidrometro = this.verificarInstalacaoSubstituicaoHidrometro(ligacaoAgua.getId(),medicaoTipo);
		
		int[] consumoMedioHidrometro = this.obterVolumeMedioAguaEsgoto(ligacaoAgua.getId(),
				grupo.getAnoMesReferencia(), LigacaoTipo.LIGACAO_AGUA, houveIntslacaoHidrometro);
		
		MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
		
		//medicaoHistorico = verificarExistenciaHistoricoMedicao(grupo,medicaoHistorico, imovel, medicaoTipo, sistemaParametro);
		
		SimpleDateFormat dataFormatada = new SimpleDateFormat("dd/MM/yyyy");
		Date dataLeituraInformada = dataFormatada.parse(imovelFaturamentoSeletivo.getDataLeitura());
		
		medicaoHistorico.setAnoMesReferencia(grupo.getAnoMesReferencia());
		medicaoHistorico.setConsumoMedioHidrometro(consumoMedioHidrometro[0]);
		//medicaoHistorico.setDataLeituraAnteriorFaturamento(medicaoAnterior.getDataLeituraAtualFaturamento());
		//medicaoHistorico.setLeituraAnteriorFaturamento(medicaoAnterior.getLeituraAtualFaturamento());
		//medicaoHistorico.setLeituraAnteriorInformada(medicaoAnterior.getLeituraAnteriorInformada());
		//medicaoHistorico.setLeituraSituacaoAnterior(medicaoAnterior.getLeituraSituacaoAtual());
		medicaoHistorico.setDataLeituraAtualInformada(dataLeituraInformada);
		medicaoHistorico.setHidrometroInstalacaoHistorico(ligacaoAgua.getHidrometroInstalacaoHistorico());
		medicaoHistorico.setLeituraSituacaoAtual(new LeituraSituacao(LeituraSituacao.REALIZADA));
		medicaoHistorico.setLeituraAtualInformada(imovelFaturamentoSeletivo.getLeitura());
		medicaoHistorico.setLigacaoAgua(ligacaoAgua);
		medicaoHistorico.setMedicaoTipo(medicaoTipo);
		medicaoHistorico.setUltimaAlteracao(new Date());
		medicaoHistorico.setIndicadorAnalisado(ConstantesSistema.NAO);
		medicaoHistorico.setDataLeituraAtualFaturamento(dataLeituraInformada);
		medicaoHistorico.setLeituraAtualFaturamento(imovelFaturamentoSeletivo.getLeitura());
		
		if (imovelFaturamentoSeletivo.getAnormalidade() != null && !imovelFaturamentoSeletivo.getAnormalidade().equals(new Integer(0))) {
			medicaoHistorico.setLeituraAnormalidadeInformada(new LeituraAnormalidade(imovelFaturamentoSeletivo.getAnormalidade()));
		}
		
		getControladorUtil().inserirComCommit(medicaoHistorico);
	}
	
	public void processarMovimentoContaPreFaturadaFaturamentoSeletivo(ImovelFaturamentoSeletivo imovelFaturamentoSeletivo) throws ControladorException {
		
		Imovel imovel = getControladorImovel().pesquisarImovel(imovelFaturamentoSeletivo.getIdImovel());
		Rota rota = this.buscarRotaDoImovel(imovel.getId());
		LeituraAnormalidade anormalidade = new LeituraAnormalidade(imovelFaturamentoSeletivo.getAnormalidade());

		MovimentoContaPrefaturada movimento = new MovimentoContaPrefaturada();
		movimento.setImovel(imovel);
		movimento.setLeituraAnormalidadeLeitura(anormalidade);
		movimento.setLeituraHidrometro(imovelFaturamentoSeletivo.getLeitura());
		movimento.setDataHoraLeitura(Util.converteStringParaDate(imovelFaturamentoSeletivo.getDataLeitura()));
		movimento.setMedicaoTipo(new MedicaoTipo(MedicaoTipo.LIGACAO_AGUA));
		movimento.setFaturamentoGrupo(rota.getFaturamentoGrupo());
		movimento.setRota(rota);
		movimento.setIndicadorSituacaoLeitura(ConstantesSistema.SIM);
		movimento.setLeituraAnormalidadeLeitura(anormalidade);
		movimento.setMovimentoContaPrefaturadaCategorias(null);
		movimento.setIndicadorGeracaoConta(ConstantesSistema.SIM);
		movimento.setIndicadorEmissaoConta(ConstantesSistema.NAO);
		movimento.setValorRateioAgua(new BigDecimal("0.00"));
		movimento.setValorRateioEsgoto(new BigDecimal("0.00"));
		movimento.setAnoMesReferenciaPreFaturamento(rota.getFaturamentoGrupo().getAnoMesReferencia());
		movimento.setDataHoraGeracaoMovimento(new Date());
		movimento.setIndicadorAtualizacaoFaturamento(ConstantesSistema.SIM);
		movimento.setIndicadorRetransmissao(ConstantesSistema.NAO);
		movimento.setIndicadorAlteracao(ConstantesSistema.NAO);
		movimento.setUtlimaAlteracao(new Date());
		
		Collection<MovimentoContaPrefaturada> colecaoMovimentos = new ArrayList<MovimentoContaPrefaturada>();
		
		Integer id = (Integer) getControladorUtil().inserir(movimento);
		movimento.setId(id);
		
	}
	
	public Collection<Imovel> obterImoveisVinculadosDoCondominio(Integer idImovelCondominio) throws ControladorException{
		try {
			return this.repositorioMicromedicao.getImovelVinculadosImovelCondominio(idImovelCondominio);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	public Collection<Integer> obterIdsRotasPelaLocalidade(Integer idLocalidade) throws ControladorException {
		try {
			return repositorioMicromedicao.obterIdsRotasPelaLocalidade(idLocalidade);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}
}
