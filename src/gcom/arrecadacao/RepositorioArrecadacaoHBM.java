package gcom.arrecadacao;
 
import gcom.arrecadacao.aviso.AvisoBancario;
import gcom.arrecadacao.aviso.bean.AvisoBancarioHelper;
import gcom.arrecadacao.aviso.bean.MovimentarPagamentosDevolucoesHelper;
import gcom.arrecadacao.aviso.bean.PagamentosDevolucoesHelper;
import gcom.arrecadacao.aviso.bean.ValoresArrecadacaoDevolucaoAvisoBancarioHelper;
import gcom.arrecadacao.banco.Agencia;
import gcom.arrecadacao.banco.Banco;
import gcom.arrecadacao.bean.ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper;
import gcom.arrecadacao.bean.MovimentoArrecadadoresPorNSAHelper;
import gcom.arrecadacao.bean.PesquisarAnaliseArrecadacaoHelper;
import gcom.arrecadacao.bean.PesquisarAnaliseAvisosBancariosHelper;
import gcom.arrecadacao.bean.PesquisarAvisoBancarioPorContaCorrenteHelper;
import gcom.arrecadacao.debitoautomatico.DebitoAutomatico;
import gcom.arrecadacao.debitoautomatico.DebitoAutomaticoMovimento;
import gcom.arrecadacao.pagamento.FiltroPagamento;
import gcom.arrecadacao.pagamento.GuiaPagamento;
import gcom.arrecadacao.pagamento.Pagamento;
import gcom.arrecadacao.pagamento.PagamentoCartaoDebito;
import gcom.arrecadacao.pagamento.PagamentoHistorico;
import gcom.arrecadacao.pagamento.PagamentoSituacao;
import gcom.cadastro.cliente.Cliente;
import gcom.cadastro.cliente.ClienteEndereco;
import gcom.cadastro.cliente.ClienteFone;
import gcom.cadastro.cliente.ClienteImovel;
import gcom.cadastro.cliente.ClienteRelacaoTipo;
import gcom.cadastro.cliente.IClienteFone;
import gcom.cadastro.endereco.LogradouroBairro;
import gcom.cadastro.endereco.LogradouroCep;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cobranca.CobrancaDocumento;
import gcom.cobranca.CobrancaDocumentoItem;
import gcom.cobranca.DocumentoTipo;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.cobranca.parcelamento.ParcelamentoPagamentoCartaoCredito;
import gcom.fachada.Fachada;
import gcom.faturamento.ImpostoTipo;
import gcom.faturamento.conta.Conta;
import gcom.faturamento.conta.ContaGeral;
import gcom.faturamento.conta.ContaHistorico;
import gcom.faturamento.conta.ContaMotivoCancelamento;
import gcom.faturamento.conta.Fatura;
import gcom.faturamento.credito.CreditoARealizar;
import gcom.faturamento.credito.CreditoOrigem;
import gcom.faturamento.credito.CreditoRealizado;
import gcom.faturamento.credito.CreditoTipo;
import gcom.faturamento.debito.DebitoACobrar;
import gcom.faturamento.debito.DebitoACobrarGeral;
import gcom.faturamento.debito.DebitoCobrado;
import gcom.faturamento.debito.DebitoCreditoSituacao;
import gcom.faturamento.debito.DebitoTipo;
import gcom.financeiro.FinanciamentoTipo;
import gcom.financeiro.lancamento.LancamentoItem;
import gcom.financeiro.lancamento.LancamentoItemContabil;
import gcom.financeiro.lancamento.LancamentoTipo;
import gcom.micromedicao.bean.ConsultarArquivoTextoRoteiroEmpresaHelper;
import gcom.relatorio.arrecadacao.GuiaDevolucaoRelatorioHelper;
import gcom.relatorio.arrecadacao.RelatorioAnaliseArrecadacaoBean;
import gcom.relatorio.arrecadacao.RelatorioAnaliseAvisosBancariosBean;
import gcom.relatorio.arrecadacao.RelatorioAvisoBancarioPorContaCorrenteBean;
import gcom.relatorio.arrecadacao.RelatorioDocumentoNaoAceitosBean;
import gcom.relatorio.arrecadacao.RelatorioTranferenciaPagamentoBean;
import gcom.relatorio.arrecadacao.dto.ResumoCreditosAvisosBancariosDTO;
import gcom.relatorio.arrecadacao.pagamento.GuiaPagamentoRelatorioHelper;
import gcom.util.CollectionUtil;
import gcom.util.ConstantesSistema;
import gcom.util.ControladorException;
import gcom.util.ErroRepositorioException;
import gcom.util.HibernateUtil;
import gcom.util.Util;
import gcom.util.filtro.GeradorHQLCondicional;
import gcom.util.filtro.ParametroSimples;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;

import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.StatelessSession;
import org.hibernate.type.Type;


public class RepositorioArrecadacaoHBM implements IRepositorioArrecadacao {

	protected static IRepositorioArrecadacao instancia;

	protected RepositorioArrecadacaoHBM() {
	}

	public static IRepositorioArrecadacao getInstancia() {

		String dialect = HibernateUtil.getDialect();
		
		if (dialect.toUpperCase().contains("ORACLE")){
			if (instancia == null) {
				instancia = new RepositorioArrecadacaoHBM();
			}
		} else {
			if (instancia == null) {
				instancia = new RepositorioArrecadacaoPostgresHBM();
			}
		}
	
		return instancia;
	}

	public Integer pesquisarIdRegistroCodigo(String codigoRegistro)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT rc.id " + "FROM RegistroCodigo rc "
					+ "WHERE rc.codigo = :codigoRegistro";

			retorno = (Integer) session.createQuery(consulta).setString(
					"codigoRegistro", codigoRegistro).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Short pesquisarNumeroDiasFloat(Integer codigoBanco,
			Integer idFormaArrecadacao) throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT act.numeroDiaFloat "
					+ "FROM ArrecadadorContratoTarifa act "
					+ "INNER JOIN act.arrecadadorContrato ac "
					+ "INNER JOIN act.arrecadacaoForma af "
					+ "INNER JOIN ac.arrecadador arrec "
					+ "WHERE arrec.codigoAgente = :codigoBanco AND "
					+ "ac.dataContratoEncerramento is null AND "
					+ "af.id = :idFormaArrecadacao";

			retorno = (Short) session.createQuery(consulta).setInteger(
					"codigoBanco", codigoBanco).setInteger(
					"idFormaArrecadacao", idFormaArrecadacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public AvisoBancario pesquisarAvisoBancario(Integer codigoBanco,
			Date dataGeracaoArquivo, Date dataPrevistaCredito,Integer idArrecadadorMovimento,
			Integer idFormaArrecadacao)
			throws ErroRepositorioException {
		AvisoBancario retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT ab "
					+ "FROM AvisoBancario ab "
					+ "INNER JOIN ab.arrecadador arrec "
					+ "LEFT JOIN ab.arrecadadorMovimento arrecMov "
					+ "WHERE arrec.codigoAgente = :codigoBanco AND "
					+ "ab.dataLancamento = :dataGeracaoArquivo AND "
					+ (idFormaArrecadacao != null ? "ab.arrecadacaoForma.id = :idFormaArrecadacao AND " : "")
					+ "(ab.valorArrecadacaoCalculado = 0 OR arrecMov.id = :idArrecadadorMovimento) AND "
					+ "(ab.dataPrevista = :dataPrevistaCredito OR ab.dataRealizada = :dataPrevistaCredito)";

			retorno = (AvisoBancario) session.createQuery(consulta).setInteger(
					"codigoBanco", codigoBanco).setDate("dataGeracaoArquivo",
					dataGeracaoArquivo).setInteger("idFormaArrecadacao", idFormaArrecadacao)
					.setDate("dataPrevistaCredito",
					dataPrevistaCredito)
					.setInteger("idArrecadadorMovimento",idArrecadadorMovimento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Double pesquisarDeducoesAvisoBancario(String codigoAgente,
			Date dataLancamento, String numeroSequencial)
			throws ErroRepositorioException {

		Double retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT sum(vd.valorDeducao) "
					+ "FROM AvisoDeducoes vd "
					+ "LEFT JOIN vd.avisoBancario aviso "
					+ "LEFT JOIN aviso.arrecadador arrecadador "
					+ "WHERE arrecadador.codigoAgente = :codigoAgente "
					+ "AND aviso.dataLancamento = :dataLancamento "
					+ "AND aviso.numeroSequencial = :numeroSequencial";

			BigDecimal big = (BigDecimal) session.createQuery(consulta)
					.setShort("codigoAgente", Short.parseShort(codigoAgente))
					.setDate("dataLancamento", dataLancamento).setShort(
							"numeroSequencial",
							Short.parseShort(numeroSequencial))
					.setMaxResults(1).uniqueResult();

			if (big != null) {
				retorno = new Double(big.toString());
			} else {
				retorno = null;
			}

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Short pesquisarValorMaximoNumeroSequencial(Date dataLancamento,
			String idArrecadador) throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT max(aviso.numeroSequencial) "
					+ "FROM AvisoBancario aviso "
					+ "LEFT JOIN aviso.arrecadador arrecadador "
					+ "WHERE arrecadador.id = :idArrecadador "
					+ "AND aviso.dataLancamento = :dataLancamento";

			retorno = (Short) session.createQuery(consulta).setInteger(
					"idArrecadador", Integer.parseInt(idArrecadador)).setDate(
					"dataLancamento", dataLancamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaGuiaPagamento(Imovel imovel,
			Integer idDebitoTipo, BigDecimal valorPagamento) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select gp.id from GuiaPagamento gp "
					+ "inner join gp.imovel "
					+ "inner join gp.debitoTipo "
					+ "where gp.debitoTipo = :idDebitoTipo "
					+ "and gp.imovel.id = :imovel  and "
					+ "gp.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada) "
					+ "and gp.valorDebito = :valorPagamento "
					+ "order by gp.dataVencimento" ;

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"imovel", imovel.getId()).setInteger("idDebitoTipo",
					idDebitoTipo).setInteger("normal",
					DebitoCreditoSituacao.NORMAL).setInteger("incluida",
					DebitoCreditoSituacao.INCLUIDA).setInteger("retificada",
					DebitoCreditoSituacao.RETIFICADA).
					setBigDecimal("valorPagamento", valorPagamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public GuiaPagamento pesquisarExistenciaGuiaPagamento(Imovel imovel, BigDecimal valorPagamento) throws ErroRepositorioException {

		GuiaPagamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select gp from GuiaPagamento gp "
					+ "inner join gp.imovel "
					+ "inner join gp.debitoTipo "
					+ "where gp.imovel.id = :imovel  and "
					+ "gp.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada) "
					+ "and gp.valorDebito = :valorPagamento "
					+ "order by gp.dataVencimento" ;

			retorno = (GuiaPagamento) session.createQuery(consulta).setInteger(
					"imovel", imovel.getId()).setInteger("normal",
					DebitoCreditoSituacao.NORMAL).setInteger("incluida",
					DebitoCreditoSituacao.INCLUIDA).setInteger("retificada",
					DebitoCreditoSituacao.RETIFICADA).
					setBigDecimal("valorPagamento", valorPagamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaGuiaPagamentoCliente(Integer idCliente,
			Integer idDebitoTipo) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select gp.id from GuiaPagamento gp "
					+ "inner join gp.cliente clie "
					+ "inner join gp.debitoTipo dbtp "
					+ "where dbtp.id = :idDebitoTipo "
					+ "and clie.id = :idCliente  and "
					+ "gp.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idCliente", idCliente).setInteger("idDebitoTipo",
					idDebitoTipo).setInteger("normal",
					DebitoCreditoSituacao.NORMAL).setInteger("incluida",
					DebitoCreditoSituacao.INCLUIDA).setInteger("retificada",
					DebitoCreditoSituacao.RETIFICADA).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarIdArrecadacaoForma(String codigoArrecadacaoForma)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "select af.id from ArrecadacaoForma af "
					+ "where af.codigoArrecadacaoForma = :codigoArrecadacaoForma ";

			retorno = (Integer) session.createQuery(consulta).setString(
					"codigoArrecadacaoForma", codigoArrecadacaoForma)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public ArrecadadorContrato pesquisarNumeroSequecialArrecadadorContrato(
			Integer idArrecadadorContrato) throws ErroRepositorioException {

		ArrecadadorContrato retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "SELECT ac " + "FROM ArrecadadorContrato ac "
					+ "WHERE ac.id = :idArrecadadorContrato AND "
					+ "ac.dataContratoEncerramento is null";

			retorno = (ArrecadadorContrato) session.createQuery(consulta)
					.setInteger("idArrecadadorContrato", idArrecadadorContrato).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer verificarExistenciaBanco(Integer idBanco)
			throws ErroRepositorioException {
		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select banco.id " + "from Banco banco "
					+ "where banco.id = :idBanco";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idBanco", idBanco.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Integer verificarExistenciaAgencia(String codigoAgencia,
			Integer idBanco) throws ErroRepositorioException {
		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select agencia.id "
					+ "from Agencia agencia "
					+ "where agencia.codigoAgencia = :codigoAgencia and agencia.banco.id = :idBanco";

			retorno = (Integer) session.createQuery(consulta).setString(
					"codigoAgencia", codigoAgencia).setInteger("idBanco",
					idBanco).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	
	/**
	 * Pesquisa a agencia
	 * 
	 * @author Sávio Luiz
	 * @date 05/11/2007
	 * 
	 * @return Agencia
	 * @throws ErroRepositorioException
	 */
	public Agencia pesquisarAgencia(String codigoAgencia,
			Integer idBanco) throws ErroRepositorioException {
		Agencia retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select agencia "
					+ "from Agencia agencia "
					+ "where agencia.codigoAgencia = :codigoAgencia and agencia.banco.id = :idBanco";

			retorno = (Agencia) session.createQuery(consulta).setString(
					"codigoAgencia", codigoAgencia).setInteger("idBanco",
					idBanco).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Integer pesquisarIdDepositoArrecadacao(Integer codigoBanco, String codigoConvenio)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT ctba.id " + "FROM ArrecadadorContrato ac "
					+ "INNER JOIN ac.arrecadador arrec "
					+ "INNER JOIN ac.contaBancariaDepositoArrecadacao ctba "
					+ "WHERE arrec.codigoAgente = :codigoBanco AND "
					+ "ac.dataContratoEncerramento is null ";
					
			if (codigoConvenio != null){
				consulta += "AND ac.codigoConvenio = :codigoConvenio ";
				retorno = (Integer) session.createQuery(consulta).setInteger(
						"codigoBanco", codigoBanco.intValue()).setString(
						"codigoConvenio", codigoConvenio).setMaxResults(1)
						.uniqueResult();
			}else{
				retorno = (Integer) session.createQuery(consulta).setInteger(
						"codigoBanco", codigoBanco.intValue()).setMaxResults(1)
						.uniqueResult();
			}
					

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de uso cria um filtro do movimento dos arrecadadores
	 * 
	 * [UC0263] - Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Raphael Rossiter
	 * @date 02/03/2006
	 * 
	 * @param filtroArrecadadorMovimento
	 * @return Uma coleção de objetos do tipo ArrecadadorMovimento de acordo com
	 *         os parâmetros recebidos através do filtro. Está consulta inclui
	 *         os movimentos abertos e fechados
	 * @throws ErroRepositorioException
	 */
	public Collection<ArrecadadorMovimento> filtrarMovimentoArrecadadores(
			FiltroArrecadadorMovimento filtroArrecadadorMovimento)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			retorno = new ArrayList(
					new CopyOnWriteArrayList<ArrecadadorMovimento>(
							GeradorHQLCondicional
									.gerarCondicionalQuery(
											filtroArrecadadorMovimento,
											"arrecadadorMovimento",
											"SELECT DISTINCT arrecadadorMovimento "
													+ "FROM ArrecadadorMovimento arrecadadorMovimento "
													+ "LEFT JOIN arrecadadorMovimento.arrecadadorMovimentoItens "
													+ FiltroArrecadadorMovimento.ALIAS_ARRECADADOR_MOVIMENTO_ITEM
													+ "", session).list()));

			/*
			 * if
			 * (!filtroArrecadadorMovimento.getColecaoCaminhosParaCarregamentoEntidades().isEmpty()) {
			 * PersistenciaUtil.processaObjetosParaCarregamento(filtroArrecadadorMovimento.getColecaoCaminhosParaCarregamentoEntidades(),
			 * retorno); }
			 */
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Calcula o valor total dos avisos bancários de um determinado movimento
	 * 
	 * @author Raphael Rossiter
	 * @date 06/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Um BigDecimal que representa o somatório de todos os avisos
	 *         bancários de um determinado movimento
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterTotalArrecadacaoAvisoBancarioPorMovimentoArrecadadores(
			ArrecadadorMovimento arrecadadorMovimento)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT SUM(avbc.valorArrecadacaoCalculado - avbc.valorDevolucaoCalculado) "
					+ "FROM AvisoBancario avbc "
					+ "INNER JOIN avbc.arrecadadorMovimento armv "
					+ "WHERE armv.id = :idArrecadadorMovimento ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idArrecadadorMovimento", arrecadadorMovimento.getId())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém o número de registros em ocorrência de um determinado movimento
	 * (número de linhas da tabela ARRECADADOR_MOVIMENTO_ITEM com ARMV_ID =
	 * ARMV_ID da tabela ARRECADADOR_MOVIMENTO e AMIT_DSOCORRENCIA diferente de
	 * "OK")
	 * 
	 * @author Raphael Rossiter
	 * @date 06/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Um Integer que representa a quantidade de registros selecionados
	 * @throws ErroRepositorioException
	 */
	public Integer obterNumeroRegistrosEmOcorrenciaPorMovimentoArrecadadores(
			ArrecadadorMovimento arrecadadorMovimento,
			String descricaoOcorrencia) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT COUNT(*) "
					+ "FROM ArrecadadorMovimentoItem amit "
					+ "INNER JOIN amit.arrecadadorMovimento armv "
					+ "WHERE armv.id = :idArrecadadorMovimento "
					+ "AND amit.descricaoOcorrencia <> :descricaoOcorrencia";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idArrecadadorMovimento", arrecadadorMovimento.getId())
					.setString("descricaoOcorrencia", descricaoOcorrencia)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém o número de registros que não foram aceitos de um determinado
	 * movimento (número de linhas da tabela ARRECADADOR_MOVIMENTO_ITEM com
	 * ARMV_ID = ARMV_ID da tabela ARRECADADOR_MOVIMENTO e AMIT_ICACEITACAO
	 * igual a 2 (NÃO))
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Um integer que representa a quantidade de registros selecionados
	 * @throws ControladorException
	 */
	public Integer obterNumeroRegistrosNaoAceitosPorMovimentoArrecadadores(
			ArrecadadorMovimento arrecadadorMovimento, Short indicadorAceitacao)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT COUNT(*) "
					+ "FROM ArrecadadorMovimentoItem amit "
					+ "INNER JOIN amit.arrecadadorMovimento armv "
					+ "WHERE armv.id = :idArrecadadorMovimento "
					+ "AND amit.indicadorAceitacao = :indicadorAceitacao";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idArrecadadorMovimento",
					arrecadadorMovimento.getId().intValue()).setInteger(
					"indicadorAceitacao", indicadorAceitacao.intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os avisos bancários de um determinado movimento
	 * 
	 * @author Raphael Rossiter
	 * @date 09/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Uma Collection com os avisos bancários de um determinado
	 *         movimento
	 * @throws ErroRepositorioException
	 */
	public Collection<AvisoBancario> obterAvisosBancariosPorArrecadadorMovimento(
			ArrecadadorMovimento arrecadadorMovimento)
			throws ErroRepositorioException {

		Collection<AvisoBancario> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT avbc " + "FROM AvisoBancario avbc "
					+ "INNER JOIN avbc.arrecadadorMovimento armv "
					+ "INNER JOIN avbc.arrecadacaoForma arrecadacaoForma "
					+ "WHERE armv.id = :idArrecadadorMovimento ";

			retorno = session.createQuery(consulta).setInteger(
					"idArrecadadorMovimento",
					arrecadadorMovimento.getId().intValue()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Calcula o valor total dos pagamentos associados a um determinado aviso
	 * bancário (soma (PGMT_VLPAGAMENTO) da tabela PAGAMENTO com AVBC_ID =
	 * AVBC_ID da tabela AVISO_BANCARIO)
	 * 
	 * @author Raphael Rossiter
	 * @date 09/03/2006
	 * 
	 * @param avisoBancario
	 * @return Um BigDecimal que representa o somatório de todos os pagamentos
	 *         de um determinado aviso
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterTotalPagamentoPorAvisoBancario(
			AvisoBancario avisoBancario) throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT SUM(pgmt.valorPagamento) "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.avisoBancario avbc "
					+ "WHERE avbc.id = :idAvisoBancario ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idAvisoBancario", avisoBancario.getId().intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Calcula o valor total das devoluções associados a um determinado aviso
	 * bancário (soma (DEVL_VLDEVOLUCAO) da tabela DEVOLUCAO com AVBC_ID =
	 * AVBC_ID da tabela AVISO_BANCARIO)
	 * 
	 * @author Raphael Rossiter
	 * @date 09/03/2006
	 * 
	 * @param avisoBancario
	 * @return Um BigDecimal que representa o somatório de todos as devoluções
	 *         de um determinado aviso
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterTotalDevolucaoPorAvisoBancario(
			AvisoBancario avisoBancario) throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT SUM(devl.valorDevolucao) "
					+ "FROM Devolucao devl "
					+ "INNER JOIN devl.avisoBancario avbc "
					+ "WHERE avbc.id = :idAvisoBancario ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idAvisoBancario", avisoBancario.getId().intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * 
	 * O sistema seleciona os itens do movimento do arrecadador.
	 * 
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author Raphael Rossiter,Vivianne Sousa
	 * @data 20/03/2006,05/12/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Collection<ArrecadadorMovimentoItem>
	 */
	public Collection<ArrecadadorMovimentoItem> consultarItensMovimentoArrecadador(
			ArrecadadorMovimento arrecadadorMovimento, Integer idImovel,
			Short indicadorAceitacao, String descricaoOcorrencia)
			throws ErroRepositorioException {

		Collection<ArrecadadorMovimentoItem> retorno = new ArrayList<ArrecadadorMovimentoItem>();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT amit "
					+ "FROM ArrecadadorMovimentoItem amit "
					+ "INNER JOIN FETCH amit.registroCodigo rgcd "
					+ "INNER JOIN amit.arrecadadorMovimento armv "
					+ "WHERE armv.id = :idArrecadadorMovimento ";
				

			if (idImovel != null && !idImovel.equals("")) {
				consulta = consulta + " AND amit.imovel.id = " + idImovel;
			}

			if (indicadorAceitacao != null && !indicadorAceitacao.equals("")) {
				consulta = consulta + " AND amit.indicadorAceitacao = "
						+ indicadorAceitacao;
			}

			if (descricaoOcorrencia != null && !descricaoOcorrencia.equals("")) {
				if (descricaoOcorrencia
						.equals("" + ConstantesSistema.SEM_ITENS)) {
					// sem itens em ocorrência
					consulta = consulta
							+ " AND amit.descricaoOcorrencia = 'OK' ";
				} else {
					// com itens em ocorrência
					consulta = consulta
							+ " AND amit.descricaoOcorrencia <> 'OK' ";
				}
			}
			

			retorno = session.createQuery(consulta).setInteger(
					"idArrecadadorMovimento", arrecadadorMovimento.getId())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * 
	 * O sistema seleciona os itens do movimento do arrecadador.
	 * 
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author Raphael Rossiter,Vivianne Sousa, Kassia Albuquerque
	 * @data 20/03/2006,05/12/2006,22/08/2007
	 * 
	 * @param arrecadadorMovimento
	 * @return Collection<ArrecadadorMovimentoItem>
	 */
	public Collection<ArrecadadorMovimentoItem> consultarItensMovimentoArrecadador(
			ArrecadadorMovimento arrecadadorMovimento, Integer idImovel,
			Short indicadorAceitacao, String descricaoOcorrencia,String codigoArrecadacaoForma)
			throws ErroRepositorioException {

 		Collection<ArrecadadorMovimentoItem> retorno = new ArrayList<ArrecadadorMovimentoItem>();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT amit "
					+ "FROM ArrecadadorMovimentoItem amit "
					+ "INNER JOIN FETCH amit.registroCodigo rgcd "
					+ "INNER JOIN amit.arrecadadorMovimento armv "
					+ "WHERE armv.id = :idArrecadadorMovimento ";
				

			if (idImovel != null && !idImovel.equals("")) {
				consulta = consulta + " AND amit.imovel.id = " + idImovel;
			}

			if (indicadorAceitacao != null && !indicadorAceitacao.equals("")) {
				consulta = consulta + " AND amit.indicadorAceitacao = "
						+ indicadorAceitacao;
			}

			if (descricaoOcorrencia != null && !descricaoOcorrencia.equals("")) {
				if (descricaoOcorrencia
						.equals("" + ConstantesSistema.SEM_ITENS)) {
					// sem itens em ocorrência
					consulta = consulta
							+ " AND amit.descricaoOcorrencia = 'OK' ";
				} else {
					// com itens em ocorrência
					consulta = consulta
							+ " AND amit.descricaoOcorrencia <> 'OK' ";
				}
			}
			
			// ------------- Forma de Arrecadação -------- Kassia Albuquerque 
			if (codigoArrecadacaoForma != null && !codigoArrecadacaoForma.equals("")) {
				if (codigoArrecadacaoForma.equalsIgnoreCase("1")){
					
					consulta = consulta + " AND ( substr(amit_cnregistro, 117,1) =  '1' OR substr(amit_cnregistro, 117,1) is null )" +
							"AND rgcd.id = 7";
					
				}else if (codigoArrecadacaoForma.equalsIgnoreCase("Z")){
					
					consulta = consulta + " AND rgcd.id = 6 OR (rgcd.id = 7 AND substr(amit_cnregistro, 117,1) = 'Z')";
					
				}else{
					
					consulta = consulta + " AND rgcd.id = 7 and substr(amit_cnregistro, 117,1) = '"+ codigoArrecadacaoForma + "'";
					
				}
				
			}

			retorno = session.createQuery(consulta).setInteger(
					"idArrecadadorMovimento", arrecadadorMovimento.getId())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz a pesquisa de devolução fazendo os carregamentos de clienteContas,
	 * clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * 
	 * @param FiltroDevolucao
	 * @return Collection<Devolucao>
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucao(
			FiltroDevolucao filtroDevolucao) throws ErroRepositorioException {

		Collection<Devolucao> retorno = null;

		Session session = HibernateUtil.getSession();

		try {

			retorno = new ArrayList(
				new CopyOnWriteArraySet<Devolucao>(
					GeradorHQLCondicional.gerarCondicionalQuery(
						filtroDevolucao,
						"devolucao",
						"select distinct devolucao from gcom.arrecadacao.Devolucao devolucao "
							+ "left join fetch devolucao.guiaDevolucao "
							+ "left join fetch devolucao.guiaDevolucao.conta conta "
							+ "left join fetch conta.clienteContas clienteContas "
							+ "left join fetch devolucao.imovel imov "
							+ "left join fetch imov.localidade loca "
							+ "left join fetch imov.setorComercial "
							+ "left join fetch imov.quadra "
							+ "left join fetch devolucao.debitoTipo "
							+ "left join fetch devolucao.avisoBancario avis "
							+ "left join fetch avis.arrecadador arre "
							+ "left join fetch arre.cliente "
							+ "left join fetch devolucao.devolucaoSituacaoAtual "
							+ "left join fetch devolucao.guiaDevolucao.documentoTipo "
							+ "left join fetch loca.gerenciaRegional "
							+ "left join devolucao.imovel.clienteImoveis clienteImoveis "
							+ "left join devolucao.guiaDevolucao.guiaPagamento.clientesGuiaPagamento clientesGuiaPagamento ",
						session).list()));
		
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Rafael Corrêa
	 * @date 21/12/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Collection<Pagamento> pesquisarPagamentoImovel(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamenorioto = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial, 
                    valorPagamentoFinal);

			hql = " select distinct pagamento "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ " INNER JOIN FETCH pagamento.avisoBancario avbc "
					+ " INNER JOIN FETCH avbc.arrecadador arrec "
					+ " INNER JOIN FETCH arrec.cliente clie "
					+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.conta conta "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico contaHistorico "
					+ " LEFT JOIN FETCH pagamento.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamento.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamento.debitoTipo dbtp "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ condicionais ;
			
			if(localidadeInicial != null && localidadeFinal != null
					&& !localidadeInicial.equals("") && !localidadeFinal.equals("")){
				hql = hql + "  order by pagamento.localidade.id, pagamento.imovel.id, "
					+ " pagamento.anoMesReferenciaPagamento, pagamento.dataPagamento ";
					
			}else{
				hql = hql + "  order by  pagamento.anoMesReferenciaPagamento desc , pagamento.dataPagamento desc ";
			}
					
					

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Exclui os dados diários da arrecadação do ano/mês da arrecadação corrente
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 11/04/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @throws ErroRepositorioException
	 */
	public void excluirDadosDiariosArrecadacaoPorAnoMesArrecadacao(
			int anoMesReferenciaArrecadacao) throws ErroRepositorioException {

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Constroi o hql para remover os dados diários da arrecadação
			// referentes ao ano/mês de arrecadação atual
			consulta = "delete ArrecadacaoDadosDiarios ardd where ardd.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao";

			// Executa o hql
			session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.executeUpdate();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Exclui os dados diários da arrecadação do ano/mês da arrecadação corrente
	 * por localidade
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 11/04/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 */
	public void excluirDadosDiariosArrecadacaoPorAnoMesArrecadacaoPorLocalidade(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Constroi o hql para remover os dados diários da arrecadação
			// referentes ao ano/mês de arrecadação atual
			consulta = "delete ArrecadacaoDadosDiarios ardd where ardd.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao and ardd.localidade.id = :idLocalidade";

			// Executa o hql
			session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Exclui os dados diários da devolucao do ano/mês da arrecadação corrente
	 * por localidade
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Francisco do Nascimento
	 * @date 22/10/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 */
	public void excluirDadosDiariosDevolucaoPorAnoMesArrecadacaoPorLocalidade(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Constroi o hql para remover os dados diários de devolucao
			// referentes ao ano/mês de arrecadação atual
			consulta = "delete DevolucaoDadosDiarios dvdd where dvdd.anoMesReferencia = :anoMesReferenciaArrecadacao and dvdd.localidade.id = :idLocalidade";

			// Executa o hql
			session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Acumula a quantidade e o valor dos pagamentos com ano/mês de referência
	 * da arrecadação igual ao ano/mês de referência da arrecadação corrente
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 11/04/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularQuantidadeEValorPagamentoPorAnoMesArrecadacao(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a variávelque vai armazenar a coleção de pagamentos
		Collection retorno = new ArrayList();

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

//			 Cria o hql para acumular o valor e quantidade de pagamentos
			consulta = acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoMontarQuery();
			retorno = session.createSQLQuery(consulta)
				.addScalar("idImovel", Hibernate.INTEGER)
				.addScalar("somaValor", Hibernate.BIG_DECIMAL)
				.addScalar("qtdPagamento", Hibernate.INTEGER)
				.addScalar("idSetor", Hibernate.INTEGER)
				.addScalar("codigoSetor", Hibernate.INTEGER)
				.addScalar("idRota", Hibernate.INTEGER)
				.addScalar("idQuadra", Hibernate.INTEGER)
				.addScalar("numeroQuadra", Hibernate.INTEGER)
				.addScalar("idPerfil", Hibernate.INTEGER)
				.addScalar("idLast", Hibernate.INTEGER)
				.addScalar("idLest", Hibernate.INTEGER)
				.addScalar("idGreg", Hibernate.INTEGER)
				.addScalar("idAviso", Hibernate.INTEGER)
				.addScalar("idArrecadador", Hibernate.INTEGER)
				.addScalar("idTipoDocumento", Hibernate.INTEGER)
				.addScalar("idFormaArrec", Hibernate.INTEGER)
				.addScalar("dataPagamento", Hibernate.DATE)
				.addScalar("idUN", Hibernate.INTEGER)
				.addScalar("idTipoDocumentoAgregador", Hibernate.INTEGER)
				.addScalar("qtdDocumentosAgregados", Hibernate.INTEGER)
//				.addScalar("idTipoDocumentoAgregador", Hibernate.INTEGER)
//				.addScalar("idCobrancaDocumento", Hibernate.INTEGER)
//				.addScalar("idFatura", Hibernate.INTEGER)
//				.addScalar("qtdFaturas", Hibernate.INTEGER)
//				.addScalar("qtdCobrancaDocumento", Hibernate.INTEGER)
				
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("idLocalidade", idLocalidade)				
				.list();
//			System.out.println(">>> " + session.createQuery(consulta).getQueryString());
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de pagamentos
		return retorno;
	}

	/**
	 * Contrucao da query usada no metodo acumularQuantidadeEValorPagamentoPorAnoMesArrecadacao
	 * @author Pedro Alexandre, Francisco do Nascimento
	 * @date 11/04/2006, 01/04/2008
	 *  
	 * @see acumularQuantidadeEValorPagamentoPorAnoMesArrecadacao
	 */
	private String acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoMontarQuery(){
		String queryFinal = "";
		String parteSelect = "select imov.imov_id as idImovel,"
			+ "sum(pgmt.pgmt_vlpagamento) as somaValor,"
			+ "count(pgmt.pgmt_id) as qtdPagamento,"
			+ "stcm.stcm_id as idSetor,"
			+ "stcm.stcm_cdsetorcomercial as codigoSetor,"
			+ "qdra.rota_id as idRota,"
			+ "qdra.qdra_id as idQuadra,"
			+ "qdra.qdra_nnquadra as numeroQuadra,"
			+ "imov.iper_id as idPerfil,"
			+ "imov.last_id as idLast,"
			+ "imov.lest_id as idLest,"
			+ "uneg.greg_id as idGreg,"
			+ "avbc.avbc_id as idAviso,"
			+ "avbc.arrc_id as idArrecadador,"
			+ "pgmt.dotp_id as idTipoDocumento,"
			+ "pgmt.arfm_id as idFormaArrec,"
			+ "pgmt.pgmt_dtpagamento as dataPagamento,"
			+ "uneg.uneg_id  as idUN, "
			+ "pgmt.dotp_idagregador as idTipoDocumentoAgregador ";
			
		String parteFrom = " from arrecadacao.pagamento pgmt "
			+ "left join arrecadacao.aviso_bancario avbc on pgmt.avbc_id = avbc.avbc_id "
			+ "left join cadastro.localidade loca on pgmt.loca_id = loca.loca_id "
			+ "left join cadastro.unidade_negocio uneg on uneg.uneg_id = loca.uneg_id "
			+ "left join cadastro.imovel imov on pgmt.imov_id = imov.imov_id "
			+ "left join cadastro.setor_comercial stcm on imov.stcm_id = stcm.stcm_id "
			+ "left join cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id ";
		
			
		String parteWhere = "where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferenciaArrecadacao " +
				"and loca.loca_id = :idLocalidade ";
		
		String parteGroupBy = "group by imov.imov_id, stcm.stcm_id, stcm.stcm_cdsetorcomercial, qdra.rota_id, " +
				"qdra.qdra_id, qdra.qdra_nnquadra, imov.iper_id, imov.last_id, imov.lest_id, uneg.greg_id, " +
				"avbc.avbc_id, avbc.arrc_id, pgmt.dotp_id, pgmt.arfm_id, pgmt.pgmt_dtpagamento, uneg.uneg_id, " +				
				"pgmt.dotp_idagregador "; 
		
		// Caso o tipo do documento agregador seja igual ao tipo de documento do pagamento
		// DocumentoTipoAgregador, IdDocumento, CountDocumento
		queryFinal = parteSelect +	", count(distinct pgmt.pgmt_id) as qtdDocumentosAgregados "  
			+ parteFrom + parteWhere 
			+ " and (pgmt.dotp_id = pgmt.dotp_idagregador or (pgmt.cbdo_id is null and pgmt.fatu_id is null)) "
			+ parteGroupBy 
			
		// UNION > Caso a identificacao do documento agregador seja diferente de nulo
			+ " UNION "
			+ parteSelect + ", count(distinct pgmt.cbdo_id) as qtdDocumentosAgregados "
			+ parteFrom + parteWhere 
			+ " and pgmt.dotp_id <> pgmt.dotp_idagregador and pgmt.cbdo_id is not null "
			+ parteGroupBy 

		// UNION > Caso a identificacao da fatura seja diferente de nulo
			+ " UNION "
			+ parteSelect + ", count(distinct pgmt.fatu_id) as qtdDocumentosAgregados "
			+ parteFrom + parteWhere 
			+ " and pgmt.dotp_id <> pgmt.dotp_idagregador and pgmt.fatu_id is not null "
			+ parteGroupBy 			
			;		  

		return queryFinal;

	}
	
	/**
	 * Acumula a quantidade e o valor das devolucoes com ano/mês de referência
	 * da arrecadação igual ao ano/mês de referência da arrecadação corrente
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Francisco do Nascimento
	 * @date 01/04/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacao(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a variávelque vai armazenar a coleção de pagamentos
		Collection retorno = new ArrayList();

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Cria o hql para acumular o valor e quantidade de pagamentos
			consulta = acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacaoMontarQuery();
			retorno = session.createSQLQuery(consulta)
				.addScalar("idImovel", Hibernate.INTEGER)
				.addScalar("somaValor", Hibernate.BIG_DECIMAL)
				.addScalar("qtdDevolucoes", Hibernate.INTEGER)
				.addScalar("idSetor", Hibernate.INTEGER)
				.addScalar("codigoSetor", Hibernate.INTEGER)
				.addScalar("idRota", Hibernate.INTEGER)
				.addScalar("idQuadra", Hibernate.INTEGER)
				.addScalar("numeroQuadra", Hibernate.INTEGER)
				.addScalar("idPerfil", Hibernate.INTEGER)
				.addScalar("idLast", Hibernate.INTEGER)
				.addScalar("idLest", Hibernate.INTEGER)
				.addScalar("idGreg", Hibernate.INTEGER)
				.addScalar("idAviso", Hibernate.INTEGER)
				.addScalar("idArrecadador", Hibernate.INTEGER)
				.addScalar("idFormaArrec", Hibernate.INTEGER)
				.addScalar("dataDevolucao", Hibernate.DATE)
				.addScalar("idUN", Hibernate.INTEGER)
				.addScalar("idTipoDocumentoAgregador", Hibernate.INTEGER)
				.addScalar("qtdDocumentosAgregados", Hibernate.INTEGER)
				.addScalar("tipoDevolucao", Hibernate.STRING)
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("idLocalidade", idLocalidade).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de pagamentos
		return retorno;
	}

	/**
	 * Contrucao da query usada no metodo acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacao
	 * @author Francisco do Nascimento
	 * @date 01/04/2008
	 *  
	 * @see acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacao
	 */
	private String acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacaoMontarQuery(){
		String queryFinal = "";
		String parteSelect = "select imov.imov_id as idImovel,"
			+ "sum(dev.devl_vldevolucao) as somaValor,"
			+ "count(dev.devl_id) as qtdDevolucoes,"
			+ "stcm.stcm_id as idSetor,"
			+ "stcm.stcm_cdsetorcomercial as codigoSetor,"
			+ "qdra.rota_id as idRota,"
			+ "qdra.qdra_id as idQuadra,"
			+ "qdra.qdra_nnquadra as numeroQuadra,"
			+ "imov.iper_id as idPerfil,"
			+ "imov.last_id as idLast,"
			+ "imov.lest_id as idLest,"
			+ "uneg.greg_id as idGreg,"
			+ "avbc.avbc_id as idAviso,"
			+ "avbc.arrc_id as idArrecadador,"
//			+ "dotp.id,"
			+ "avbc.arfm_id as idFormaArrec,"
			+ "dev.devl_dtdevolucao as dataDevolucao,"
			+ "uneg.uneg_id as idUN, " 
			+ "dev.dotp_idagregador as idTipoDocumentoAgregador ";
			
		String parteFrom = " from arrecadacao.devolucao dev "
			+ "left join arrecadacao.aviso_bancario avbc on dev.avbc_id=avbc.avbc_id "
//			+ "left join arrecadacao.arrecadador arrc on avbc.arrc_id = arrc.arrc_id "
//			+ "left join arrecadacao.arrecadacao_forma arfm on avbc.arfm_id = arfm.arfm_id "
			+ "left join cadastro.localidade loca on dev.loca_id = loca.loca_id "
			+ "left join cadastro.unidade_negocio uneg on uneg.uneg_id = loca.uneg_id "
//			+ "left join cadastro.gerencia_regional greg on uneg.greg_id = greg.greg_id "
			+ "left join cadastro.imovel imov on dev.imov_id = imov.imov_id "
			+ "left join cadastro.setor_comercial stcm on imov.stcm_id = stcm.stcm_id "
			+ "left join cadastro.quadra qdra on imov.qdra_id = qdra.qdra_id "
//			+ "left join micromedicao.rota rota on qdra.rota_id = rota.rota_id "
//			+ "left join cadastro.imovel_perfil iper on imov.iper_id = iper_id "
//		    + "left join cobranca.documentoTipoAgregador dotpa "
		    ;
			
		String parteWhere = "where dev.devl_amreferenciaarrecadacao = :anoMesReferenciaArrecadacao " +
				"and dev.loca_id = :idLocalidade ";

		String parteGroupBy = "group by imov.imov_id, stcm.stcm_id, stcm.stcm_cdsetorcomercial, qdra.rota_id, qdra.qdra_id, qdra.qdra_nnquadra," +
				"imov.iper_id,imov.last_id,imov.lest_id,uneg.greg_id,avbc.avbc_id,avbc.arrc_id," +
				"avbc.arfm_id,dev.devl_dtdevolucao,uneg.uneg_id, dev.dotp_idagregador ";
		
		// Caso o tipo do documento agregador seja nulo => Tipo de Devolucao Normal
		queryFinal = parteSelect +	", count(dev.devl_id) as qtdDocumentosAgregados, 'N' as tipoDevolucao " // DocumentoTipoAgregador, IdDocumento, CountDocumento 
			+ parteFrom + parteWhere 
			+ " and dev.dotp_idagregador is null "
			+ parteGroupBy 
			
		// UNION > Caso a identificacao do documento agregador seja diferente de nulo e a identificacao do Credito a 
			// Realizar seja diferente de nulo => Tipo de Devolucao Credito
			
			+ " UNION "
			+ parteSelect + ", count(distinct dev.cbdo_id) as qtdDocumentosAgregados, 'C' as tipoDevolucao "
			+ parteFrom 
			+ parteWhere 
			+ " and dev.dotp_idagregador is not null and dev.cbdo_id is not null and dev.crar_id is not null "
			+ parteGroupBy 

		// UNION > Caso a identificacao do Credito a realizar seja nula => Tipo de Devolucao Desconto
			+ " UNION "
			+ parteSelect + ", count(distinct dev.cbdo_id) as qtdDocumentosAgregados, 'D' as tipoDevolucao "
			+ parteFrom 
			+ parteWhere
			+ " and dev.dotp_idagregador is not null and dev.cbdo_id is not null and dev.crar_id is null "
			+ parteGroupBy 			
			;		  

		return queryFinal;

	}
	
	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a pagamento classificado (tabela PAGAMENTO_SITUACAO) e
	 * atualiza o id da conta nos pagamentos (seta CNTA_ID da tabela PAGAMENTO
	 * para CNTA_ID da tabela CONTA)
	 * 
	 * [SF0002] Processar Pagamento de Conta
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 19/04/2006, 06/12/2006
	 * 
	 * @param mapPagamentosProcessados
	 * @return void
	 */
	@SuppressWarnings("rawtypes")
	public void processarPagamentoConta(
			Map<Integer, Collection> mapPagamentosProcessados)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String processarPagamentoConta = "UPDATE Pagamento pgmt "
				+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
				+ "pgmt.contaGeral.id = :conta, "
				+ "ultimaAlteracao = :dataAlteracao "
				+ "WHERE pgmt.id IN(:idsPagamentos)";

		Collection colecaoIdsContas = mapPagamentosProcessados.keySet();
		Iterator iteratorIdsContas = colecaoIdsContas.iterator();

		try {

			int i = 1;

			while (iteratorIdsContas.hasNext()) {

				Integer idConta = (Integer) iteratorIdsContas.next();

				Collection colecaoIdsPagamentos = mapPagamentosProcessados.get(idConta);

				session.createQuery(processarPagamentoConta)
									.setInteger("pagamentoSituacao", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
									.setInteger("conta", idConta)
									.setTimestamp("dataAlteracao", new Date())
									.setParameterList("idsPagamentos", colecaoIdsPagamentos)
									.executeUpdate();

				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();
		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualiza a situacao atual dos pagamentos (PGST_IDATUAL) (tabela
	 * PAGAMENTO_SITUACAO)
	 * 
	 * [SF0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter
	 * @date 19/04/2006
	 * 
	 * @param idsPagamentos
	 * @return void
	 */
	public void atualizarSituacaoPagamento(String[] idsPagamentos,
			Integer pagamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try {

			atualizarSituacaoPagamento = "UPDATE Pagamento "
					+ "SET pgst_idatual = :pagamentoSituacao, pgmt_tmultimaalteracao = :dataAlteracao "
					+ "WHERE pgmt_id IN(:idsPagamentos)";

			session.createQuery(atualizarSituacaoPagamento).setInteger(
					"pagamentoSituacao", pagamentoSituacao).setTimestamp(
					"dataAlteracao", new Date()).setParameterList(
					"idsPagamentos", idsPagamentos).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualiza a situacao atual dos pagamentos (PGST_IDATUAL) (tabela
	 * PAGAMENTO_SITUACAO)
	 * 
	 * [SF0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 19/04/2006, 30/11/2006
	 * 
	 * @param colecaoIdsPagamentos
	 * @param pagamentoSituacao
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoPagamento(Collection colecaoIdsPagamentos,
			Integer pagamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		// Iterator iteratorPagamentos = colecaoIdsPagamentos.iterator();
		String atualizarSituacaoPagamento;
		// String idPagamento = null;
		try {
			atualizarSituacaoPagamento = "UPDATE Pagamento "
					+ "SET pgst_idatual = :pagamentoSituacao, pgmt_tmultimaalteracao = :dataAlteracao "
					+ "WHERE pgmt_id in(:idsPagamentos)";

			session.createQuery(atualizarSituacaoPagamento).setInteger(
					"pagamentoSituacao", pagamentoSituacao).setTimestamp(
					"dataAlteracao", new Date()).setParameterList(
					"idsPagamentos", colecaoIdsPagamentos).executeUpdate();


		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualiza a situacao anterior dos pagamentos (PGST_IDANTERIOR) (tabela
	 * PAGAMENTO_SITUACAO)
	 * 
	 * [SF0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter
	 * @date 19/04/2006
	 * 
	 * @param idsPagamentos
	 * @return void
	 */
	public void atualizarSituacaoAnteriorPagamento(String[] idsPagamentos,
			Integer pagamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try {

			atualizarSituacaoPagamento = "UPDATE Pagamento "
					+ "SET pgst_idanterior = :pagamentoSituacao, pgmt_tmultimaalteracao = :dataAlteracao "
					+ "WHERE pgmt_id IN(:idsPagamentos)";

			session.createQuery(atualizarSituacaoPagamento).setInteger(
					"pagamentoSituacao", pagamentoSituacao).setTimestamp(
					"dataAlteracao", new Date()).setParameterList(
					"idsPagamentos", idsPagamentos).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualiza a situacao atual das devolucoes (DVST_IDATUAL) com valor
	 * correspondente a pagamento em duplicidade não encontrado (tabela
	 * DEVOLUCAO_SITUACAO)
	 * 
	 * [SF0011] Processar Devoluções de Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 15/06/2006
	 * 
	 * @param idsDevolucoes
	 * @return void
	 */
	public void atualizarSituacaoDevolucao(String[] idsDevolucao,
			Integer devolucaoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoDevolucao;

		try {
			for (int i = 0; i < idsDevolucao.length; i++) {
				
				Integer id = new Integer(idsDevolucao[i]);
				
				atualizarSituacaoDevolucao = "UPDATE Devolucao "
					+ "SET dvst_idatual = :devolucaoSituacao, " 
					   + " devl_tmultimaalteracao = :dataAlteracao "
					+ "WHERE devl_id =:idsDevolucao";

				session.createQuery(atualizarSituacaoDevolucao).setInteger(
					"devolucaoSituacao", devolucaoSituacao).setTimestamp(
					"dataAlteracao", new Date()).setParameter(
					"idsDevolucao", id.intValue()).executeUpdate();

			}
			
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualizar Valor Excedente do Pagamento
	 * 
	 * [SF0009] Atualizar Valor Excedente do Pagamento
	 * 
	 * @author Raphael Rossiter
	 * @date 25/04/2006
	 * 
	 * @param pagamento
	 * @return void
	 */
	public void atualizarValorExcedentePagamento(Pagamento pagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarValorExcedente;

		try {

			atualizarValorExcedente = "UPDATE Pagamento "
					+ "SET pgmt_vlexcedente = :valorExcedente, pgmt_tmultimaalteracao = :dataAlteracao "
					+ "WHERE pgmt_id = :idPagamento ";

			session.createQuery(atualizarValorExcedente).setBigDecimal(
					"valorExcedente", pagamento.getValorExcedente())
					.setTimestamp("dataAlteracao", new Date()).setInteger(
							"idPagamento", pagamento.getId()).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualizar Valor Excedente do Pagamento
	 * 
	 * [SF0009] Atualizar Valor Excedente do Pagamento
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 25/04/2006, 29/11/2006
	 * 
	 * @param colecaoPagamento
	 * @return void
	 */
	public void atualizarValorExcedentePagamento(
			Collection<Pagamento> colecaoPagamento)
			throws ErroRepositorioException {

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		Iterator iteratorPagamentos = colecaoPagamento.iterator();
		String atualizarValorExcedente;
		Pagamento pagamento = null;

		try {

			atualizarValorExcedente = "UPDATE Pagamento pgmt "
					+ "SET pgmt.valorExcedente = :valorExcedente, "
					+ "pgmt.ultimaAlteracao = :dataAlteracao "
					+ "WHERE pgmt.id = :idPagamento ";

			int i = 1;
			while (iteratorPagamentos.hasNext()) {
				pagamento = (Pagamento) iteratorPagamentos.next();

				session.createQuery(atualizarValorExcedente).setBigDecimal(
						"valorExcedente", pagamento.getValorExcedente())
						.setTimestamp("dataAlteracao", new Date()).setInteger(
								"idPagamento", pagamento.getId())
						.executeUpdate();

				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a pagamento classificado (tabela PAGAMENTO_SITUACAO) e
	 * atualiza o id da guia de pagamento nos pagamentos (seta GPAG_ID da tabela
	 * PAGAMENTO para GPAG_ID da tabela GUIA_PAGAMENTO)
	 * 
	 * [SF0004] Processar Pagamento de Guia de Pagamento
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 26/04/2006, 11/12/2006
	 * 
	 * @param mapPagamentosProcessados
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoGuiaPagamento(
			Map<Integer, Collection> mapPagamentosProcessados)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String processarPagamentoGuiaPagamento = "UPDATE Pagamento "
				+ "SET pgst_idatual = :pagamentoSituacao, "
				+ "gpag_id = :guiaPagamento, "
				+ "pgmt_tmultimaalteracao = :dataAlteracao "
				+ "WHERE pgmt_id IN(:idsPagamentos)";

		Collection colecaoIdsGuias = mapPagamentosProcessados.keySet();
		Iterator iteratorIdsGuias = colecaoIdsGuias.iterator();

		try {
			int i = 1;

			while (iteratorIdsGuias.hasNext()) {

				Integer idGuiaPagamento = (Integer) iteratorIdsGuias.next();

				Collection colecaoIdsPagamentos = mapPagamentosProcessados
						.get(idGuiaPagamento);

				session
						.createQuery(processarPagamentoGuiaPagamento)
						.setInteger("pagamentoSituacao",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
						.setInteger("guiaPagamento", idGuiaPagamento)
						.setTimestamp("dataAlteracao", new Date())
						.setParameterList("idsPagamentos", colecaoIdsPagamentos)
						.executeUpdate();

				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a pagamento classificado (tabela PAGAMENTO_SITUACAO) e
	 * atualiza o id do débito a cobrar nos pagamentos (seta DBAC_ID da tabela
	 * PAGAMENTO para DBAC_ID da tabela DEBITO_A_COBRAR)
	 * 
	 * [SF0004] Processar Pagamento de Débito a Cobrar
	 * 
	 * @author Raphael Rossiter ,Pedro Alexandre
	 * @date 27/04/2006, 12/12/2006
	 * 
	 * @param mapPagamentosProcessados
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoDebitoACobrar(
			Map<Integer, Collection> mapPagamentosProcessados)
			throws ErroRepositorioException {

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		String processarPagamentoGuiaPagamento = "UPDATE Pagamento pgmt "
				+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
				+ "pgmt.debitoACobrarGeral.id = :debitoACobrar, "
				+ "pgmt.ultimaAlteracao = :dataAlteracao "
				+ "WHERE pgmt.id IN(:idsPagamentos)";

		Collection colecaoIdsDebitosACobrar = mapPagamentosProcessados.keySet();
		Iterator iteratorIdsDebitosACobrar = colecaoIdsDebitosACobrar
				.iterator();

		try {
			int i = 1;

			while (iteratorIdsDebitosACobrar.hasNext()) {

				Integer idDebitoACobrar = (Integer) iteratorIdsDebitosACobrar
						.next();

				Collection colecaoIdsPagamentos = mapPagamentosProcessados
						.get(idDebitoACobrar);

				session
						.createQuery(processarPagamentoGuiaPagamento)
						.setInteger("pagamentoSituacao",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
						.setInteger("debitoACobrar", idDebitoACobrar)
						.setTimestamp("dataAlteracao", new Date())
						.setParameterList("idsPagamentos", colecaoIdsPagamentos)
						.executeUpdate();

				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona a guia de pagamento correspondente ao pagamento
	 * através do imóvel, cliente e do tipo de débito (a partir da tabela
	 * GUIA_PAGAMENTO com IMOV_ID, CLIE_ID e DBTP_ID da tabela PAGAMENTO e
	 * DCST_IDATUAL com valor correspondente a normal da tabela
	 * DEBITO_CREDITO_SITUACAO)
	 * 
	 * [SF0003] Selecionar Guia de Pagamento pela Localidade, Imóvel, Cliente e
	 * Débito Tipo
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 26/04/2006, 14/03/2007, 05/06/2007, 02/10/2007
	 * 
	 * @param imovel
	 * @param cliente
	 * @param debitoTipo
	 * @param anoMesFaturamento
	 * 
	 * @return Collection<GuiaPagamento>
	 */
	public Collection<GuiaPagamento> selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(
			Imovel imovel, Cliente cliente, DebitoTipo debitoTipo,
			Integer anoMesFaturamento) throws ErroRepositorioException {

		Collection<GuiaPagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			if (imovel != null) {
				consulta = "SELECT guiaPagamento "
						+ "FROM GuiaPagamento guiaPagamento "
						+ "WHERE guiaPagamento.imovel.id = :idImovel "
						+ "AND guiaPagamento.debitoTipo.id = :idDebitoTipo "
						+ "AND guiaPagamento.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao "
						//+ "AND guiaPagamento.anoMesReferenciaContabil < :anoMesFaturamento "
						+ "ORDER BY guiaPagamento.dataVencimento";

				retorno = session.createQuery(consulta)
						.setInteger("idImovel",imovel.getId())
						.setInteger("idDebitoTipo",debitoTipo.getId())
						.setInteger("idDebitoCreditoSituacao",DebitoCreditoSituacao.NORMAL)
						//.setInteger("anoMesFaturamento", anoMesFaturamento)
						.list();

			} else if (cliente != null) {
				consulta = "SELECT guiaPagamento "
						+ "FROM GuiaPagamento guiaPagamento "
						+ "WHERE guiaPagamento.cliente.id = :idCliente "
						+ "AND guiaPagamento.debitoTipo.id = :idDebitoTipo "
						+ "AND guiaPagamento.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao "
						//+ "AND guiaPagamento.anoMesReferenciaContabil < :anoMesFaturamento "
						+ "ORDER BY guiaPagamento.dataVencimento";

				retorno = session.createQuery(consulta)
						.setInteger("idCliente",cliente.getId())
						.setInteger("idDebitoTipo",debitoTipo.getId())
						.setInteger("idDebitoCreditoSituacao",DebitoCreditoSituacao.NORMAL)
						//.setInteger("anoMesFaturamento", anoMesFaturamento)
						.list();

			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona o débito a cobrar correspondente ao pagamento através
	 * do imóvel e do tipo de débito (a partir da tabela DEBITO_A_COBRAR com
	 * IMOV_ID e DBTP_ID da tabela PAGAMENTO e DCST_IDATUAL com valor
	 * correspondente a normal da tabela DEBITO_CREDITO_SITUACAO)
	 * 
	 * [SF0005] Selecionar Débito a Cobrar pela Localidade, Imóvel e Débito Tipo
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 26/04/2006, 05/06/2007, 02/10/2007
	 * 
	 * @param imovel,
	 * @param debitoTipo
	 * @param anoMesFaturamento
	 * 
	 * @return Collection<DebitoACobrar>
	 */
	public Collection<DebitoACobrar> selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(
			Imovel imovel, DebitoTipo debitoTipo, Integer anoMesFaturamento)
			throws ErroRepositorioException {

		Collection<DebitoACobrar> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";
		
		Collection<DebitoACobrar> colDebitoACobrar = new ArrayList();
		

		try {

			consulta = "SELECT deb FROM DebitoACobrar deb "
					+ "WHERE deb.imovel.id = :idImovel " 
					+ "AND deb.debitoTipo.id = :idDebitoTipo "
					+ "AND deb.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao "
					+ "ORDER BY deb.geracaoDebito";

			retorno = session.createQuery(consulta)
					.setInteger("idImovel",imovel.getId())
					.setInteger("idDebitoTipo",debitoTipo.getId())
					.setInteger("idDebitoCreditoSituacao",DebitoCreditoSituacao.NORMAL)
					.list();
			
			Iterator iteRetorno = retorno.iterator();
			
			while ( iteRetorno.hasNext() ){
				DebitoACobrar deb = (DebitoACobrar) iteRetorno.next();
				
				FiltroPagamento filtroPagamento = new FiltroPagamento();
				
				filtroPagamento.adicionarParametro( new ParametroSimples( FiltroPagamento.DEBITO_A_COBRAR, deb.getId() ) );
				filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("debitoACobrarGeral");
				filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("debitoACobrarGeral.debitoACobrar");
				Fachada fachada = Fachada.getInstancia();				
				
				Collection colPagamento = fachada.pesquisar( filtroPagamento, Pagamento.class.getName() );
				
				if ( colPagamento != null && colPagamento.size() > 0 ){
					Iterator itePagamento = colPagamento.iterator();
					
					if ( itePagamento.hasNext() ){					
						Pagamento pgto = (Pagamento) itePagamento.next();
						
						if ( pgto.getValorPagamento().compareTo( pgto.getDebitoACobrarGeral().getDebitoACobrar().getValorTotalComBonus() ) == 0 ){
							colDebitoACobrar.add( pgto.getDebitoACobrarGeral().getDebitoACobrar() );
						}					
					}
				}				
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colDebitoACobrar;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * [SF0010] Selecionar Pagamentos não Classificados de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 26/04/2006
	 * 
	 * @param imovel,
	 *            anoMesReferenciaDevolucao
	 * @return Collection<Pagamento>
	 */
	public Collection<Pagamento> selecionarPagamentosNaoClassificadosConta(
			Imovel imovel, Integer anoMesReferenciaDevolucao)
			throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "SELECT pgmt FROM Pagamento pgmt "
					+ "WHERE pgmt.imovel.id = :idImovel AND pgmt.anoMesReferenciaPagamento = :anoMesReferenciaDevolucao "
					+ "AND pgmt.pagamentoSituacaoAtual.id NOT IN(:classificado, :movimentoAberto)";

			retorno = session.createQuery(consulta).setInteger("idImovel",
					imovel.getId()).setInteger("anoMesReferenciaDevolucao",
					anoMesReferenciaDevolucao).setInteger("classificado",
					PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
					"movimentoAberto", PagamentoSituacao.MOVIMENTO_ABERTO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * [SF0012] Selecionar Pagamentos não classificados de guia de pagamento ou
	 * débito a cobrar
	 * 
	 * @author Raphael Rossiter
	 * @date 15/06/2006
	 * 
	 * @param imovel,
	 *            anoMesReferenciaDevolucao
	 * @return Collection<Pagamento>
	 */
	public Collection<Pagamento> selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(
			Imovel imovel, Cliente cliente, DebitoTipo debitoTipo)
			throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			if (imovel != null){
				
				consulta = "SELECT pgmt FROM Pagamento pgmt "
					+ "WHERE pgmt.imovel.id = :idImovel AND " 
					+ " pgmt.debitoTipo.id = :idDebitoTipo "
					+ "AND pgmt.pagamentoSituacaoAtual.id NOT IN(:classificado, :movimentoAberto)";

				retorno = session.createQuery(consulta)
					.setInteger("idImovel", imovel.getId())
					.setInteger("idDebitoTipo", debitoTipo.getId())
					.setInteger("classificado",	PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("movimentoAberto", PagamentoSituacao.MOVIMENTO_ABERTO).list();
				
			} else if (cliente != null) {
				
				consulta = "SELECT pgmt FROM Pagamento pgmt "
					+ "WHERE pgmt.cliente.id = :idCliente AND "
					+ " pgmt.debitoTipo.id = :idDebitoTipo "
					+ "AND pgmt.pagamentoSituacaoAtual.id NOT IN(:classificado, :movimentoAberto)";

				retorno = session.createQuery(consulta)
					.setInteger("idCliente", cliente.getId())
					.setInteger("idDebitoTipo", debitoTipo.getId())
					.setInteger("classificado",	PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("movimentoAberto", PagamentoSituacao.MOVIMENTO_ABERTO).list();
			}
			

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o tipo do documento correspondente a
	 * conta
	 * 
	 * @author Raphael Rossiter
	 * @data 18/04/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Pagamento>
	 */
	public Collection<Object[]> pesquisarPagamentosPorConta(
			Integer anoMesReferencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND dotp.id = :conta "
					+ "ORDER BY loca.id, imov.id, pgmt.anoMesReferenciaPagamento, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger("conta",
					DocumentoTipo.CONTA).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o tipo do documento correspondente a
	 * conta
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 28/11/2006
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idImovel
	 * @param anoMesReferenciaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	@SuppressWarnings("unchecked")
	public Collection<Object[]> pesquisarPagamentosPorConta(
			Integer anoMesReferencia, Integer idLocalidade, Integer idImovel,
			Integer anoMesReferenciaPagamento) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = //"SELECT pgmt.id, pgmt.documentoTipo.id, pgmt.localidade.id, pgmt.valorPagamento, pgst.id, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento, pgmt.indicadorClassificadoRecuperacaoCredito "
					"SELECT pgmt "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.localidade as localidade "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "LEFT JOIN pgmt.documentoTipo as documentoTipo "
					+ "LEFT JOIN pgmt.localidade as localidade "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND imov.id = :idImovel "
					+ "AND pgmt.anoMesReferenciaPagamento = :anoMesReferenciaPagamento "
					+ "AND (pgst.id is null or pgst.id <> :idValorABaixar) "
					+ "AND pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
					+ "ORDER BY imov.id, pgmt.anoMesReferenciaPagamento, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesReferenciaPagamento", anoMesReferenciaPagamento)
					.setInteger("idValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
					.setShort("indicadorClassificacao", ConstantesSistema.NAO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * guia de pagamento e o campo GPAG_ID informado
	 * 
	 * @author Raphael Rossiter
	 * @data 18/04/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoComGuiaInformada(
			Integer anoMesReferencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id, gpag "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "LEFT JOIN pgmt.guiaPagamento as gpag "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND " 
					+ " dotp.id in (:guiaPagamento, :entradaParcelamento ) "
					+ "AND pgmt.guiaPagamento IS NOT NULL "
					+ "ORDER BY gpag.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO)
					.setInteger("entradaParcelamento", DocumentoTipo.ENTRADA_DE_PARCELAMENTO).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * guia de pagamento e o campo GPAG_ID informado
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 28/11/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoComGuiaInformada(
			Integer anoMesReferencia, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, gpag.id, pgmt.valorPagamento, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento, gpag.valorDebito "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "LEFT JOIN pgmt.guiaPagamento as gpag "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND " 
					+ " dotp.id in (:guiaPagamento, :entradaParcelamento ) "
					+ "AND pgmt.guiaPagamento IS NOT NULL AND loca.id = :idLocalidade "
					+ "ORDER BY gpag.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO).setInteger(
					"idLocalidade", idLocalidade)
					.setInteger("entradaParcelamento", DocumentoTipo.ENTRADA_DE_PARCELAMENTO).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * guia de pagamento e o campo GPAG_ID não informado
	 * 
	 * @author Raphael Rossiter
	 * @data 18/04/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoSemGuiaInformada(
			Integer anoMesReferencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, clie.id, dbtp.id, pgmt.valorPagamento, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento, gpag.valorDebito "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "LEFT JOIN pgmt.cliente as clie "
					+ "LEFT JOIN pgmt.debitoTipo as dbtp "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND " 
					+ " dotp.id in (:guiaPagamento, :entradaParcelamento ) "
					+ "AND pgmt.guiaPagamento IS NULL "
					+ "ORDER BY loca.id, imov.id, clie.id, dbtp.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO)
					.setInteger("entradaParcelamento", DocumentoTipo.ENTRADA_DE_PARCELAMENTO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * guia de pagamento e o campo GPAG_ID não informado
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 12/12/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoSemGuiaInformada(
			Integer anoMesReferencia, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, clie.id, dbtp.id, pgmt.valorPagamento, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "LEFT JOIN pgmt.cliente as clie "
					+ "LEFT JOIN pgmt.debitoTipo as dbtp "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND " 
					+ " dotp.id in (:guiaPagamento, :entradaParcelamento ) "
					+ "AND pgmt.guiaPagamento IS NULL "
					+ "AND loca.id = :idLocalidade "
					+ "AND pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
					+ "ORDER BY loca.id, imov.id, clie.id, dbtp.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia)
					.setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO)
					.setInteger("entradaParcelamento", DocumentoTipo.ENTRADA_DE_PARCELAMENTO)
					.setShort("indicadorClassificacao", ConstantesSistema.NAO)
					.setInteger("idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * debito a cobrar e o campo DBAC_ID informado
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 28/11/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarComDebitoInformado(
			Integer anoMesReferencia, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt, "//0 
				+ "dotp.id, " //1
				+ "loca.id, " //2
				+ "imov.id, " //3
				+ "pgst.id, " //4
				+ "dbac.id," //5 
				+ "dbac.valorDebito," //6
				+ "dbac.numeroPrestacaoDebito," //7 
				+ "dbac.numeroPrestacaoCobradas," //8
				+ "dbac.numeroParcelaBonus " //9
				+ "FROM Pagamento as pgmt "
				+ "LEFT JOIN pgmt.documentoTipo as dotp "
				+ "LEFT JOIN pgmt.localidade as loca "
				+ "LEFT JOIN pgmt.imovel as imov "
				+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
				+ "INNER JOIN pgmt.debitoACobrarGeral as dbacGeral "
				+ "INNER JOIN dbacGeral.debitoACobrar as dbac "
				+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia " 
				+ "AND dotp.id = :debitoACobrar "
				+ "AND loca.id = :idLocalidade "
				+ "ORDER BY dbac.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"debitoACobrar", DocumentoTipo.DEBITO_A_COBRAR).setInteger(
					"idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * debito a cobrar e o campo DBAC_ID não informado
	 * 
	 * @author Raphael Rossiter
	 * @data 18/04/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarSemDebitoInformada(
			Integer anoMesReferencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "LEFT JOIN pgmt.debitoTipo as dbtp "
					+ "LEFT JOIN pgmt.debitoACobrarGeral as dbacGeral "
					+ "LEFT JOIN dbacGeral.debitoACobrar as dbac "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND dotp.id = :debitoACobrar "
					+ "AND pgmt.debitoACobrarGeral IS NULL "
					+ "ORDER BY loca.id, imov.id, dbtp.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"debitoACobrar", DocumentoTipo.DEBITO_A_COBRAR).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * debito a cobrar e o campo DBAC_ID não informado
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 28/11/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarSemDebitoInformada(
			Integer anoMesReferencia, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "LEFT JOIN pgmt.debitoTipo as dbtp "
					+ "LEFT JOIN pgmt.debitoACobrarGeral as dbacGeral "
					+ "LEFT JOIN dbacGeral.debitoACobrar as dbac "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND dotp.id = :debitoACobrar "
					+ "AND pgmt.debitoACobrarGeral IS NULL "
					+ "AND loca.id= :idLocalidade "
					+ "AND pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
					+ "ORDER BY loca.id, imov.id, dbtp.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("debitoACobrar", DocumentoTipo.DEBITO_A_COBRAR)
					.setInteger("idLocalidade", idLocalidade)
					.setShort("indicadorClassificacao", ConstantesSistema.NAO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona as devoluções com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela DEVOLUCAO para
	 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o ano/mês de referência preenchido
	 * (DEVL_AMREFERENCIADEVOLUCAO com valor diferente de nulo)
	 * 
	 * @author Raphael Rossiter
	 * @data 14/06/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarDevolucoesEmDuplicidadeOUExcesso(
			Integer anoMesReferencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT devl, loca.id, imov.id, gdev.id "
					+ "FROM Devolucao as devl "
					+ "LEFT JOIN devl.localidade as loca "
					+ "LEFT JOIN devl.imovel as imov "
					+ "LEFT JOIN devl.guiaDevolucao as gdev "
					+ "WHERE devl.anoMesReferenciaArrecadacao <= :anoMesReferencia AND "
					+ "devl.anoMesReferenciaDevolucao IS NOT NULL "
					+ "ORDER BY loca.id, imov.id, devl.anoMesReferenciaDevolucao, devl.dataDevolucao ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona as devoluções com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela DEVOLUCAO para
	 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o ano/mês de referência preenchido
	 * (DEVL_AMREFERENCIADEVOLUCAO com valor diferente de nulo)
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 14/06/2006, 28/11/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarDevolucoesEmDuplicidadeOUExcesso(
			Integer anoMesReferencia, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT devl, loca.id, imov.id, gdev.id "
					+ "FROM Devolucao as devl "
					+ "LEFT JOIN devl.localidade as loca "
					+ "LEFT JOIN devl.imovel as imov "
					+ "LEFT JOIN devl.guiaDevolucao as gdev "
					+ "WHERE devl.anoMesReferenciaArrecadacao <= :anoMesReferencia AND "
					+ "devl.anoMesReferenciaDevolucao IS NOT NULL AND loca.id = :idLocalidade "
					+ "ORDER BY loca.id, imov.id, devl.anoMesReferenciaDevolucao, devl.dataDevolucao ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona as devoluções com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela DEVOLUCAO para
	 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o ano/mês de referência não
	 * preenchido (DEVL_AMREFERENCIADEVOLUCAO com valor diferente nulo)
	 * 
	 * @author Raphael Rossiter
	 * @data 14/06/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarDevolucoesCobradasIndevidamente(
			Integer anoMesReferencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT devl, loca.id, imov.id, gdev.id, clie.id, dbtp.id "
					+ "FROM Devolucao as devl "
					+ "LEFT JOIN devl.localidade as loca "
					+ "LEFT JOIN devl.imovel as imov "
					+ "LEFT JOIN devl.guiaDevolucao as gdev "
					+ "LEFT JOIN devl.cliente as clie "
					+ "LEFT JOIN devl.debitoTipo as dbtp "
					+ "WHERE devl.anoMesReferenciaArrecadacao <= :anoMesReferencia AND "
					+ "devl.anoMesReferenciaDevolucao IS NULL "
					+ "ORDER BY loca.id, imov.id, clie.id, dbtp.id, devl.dataDevolucao ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona as devoluções com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela DEVOLUCAO para
	 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o ano/mês de referência não
	 * preenchido (DEVL_AMREFERENCIADEVOLUCAO com valor diferente nulo)
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 14/06/2006, 28/11/2006
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarDevolucoesCobradasIndevidamente(
			Integer anoMesReferencia, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT devl, loca.id, imov.id, gdev.id, clie.id, dbtp.id, crar.id "
					+ "FROM Devolucao as devl "
					+ "LEFT JOIN devl.localidade as loca "
					+ "LEFT JOIN devl.imovel as imov "
					+ "LEFT JOIN devl.guiaDevolucao as gdev "
					+ "LEFT JOIN devl.cliente as clie "
					+ "LEFT JOIN devl.debitoTipo as dbtp "
					+ "LEFT JOIN devl.creditoARealizarGeral as crar "
					+ "WHERE devl.anoMesReferenciaArrecadacao <= :anoMesReferencia AND "
					+ "devl.anoMesReferenciaDevolucao IS NULL AND loca.id = :idLocalidade "
					+ "ORDER BY loca.id, imov.id, clie.id, dbtp.id, devl.dataDevolucao ";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona a conta correspondente ao pagamento através do imóvel
	 * e ano/mês de referência do pagamento (a partir da tabela CONTA com
	 * IMOV_ID = IMOV_ID da tabela PAGAMENTO, PGMT_AMREFERENCIAPAGAMENTO da
	 * tabela PAGAMENTO e DCST_IDATUAL com o valor correspondente a normal,
	 * retificada ou incluída, da tabela DEBTIO_CREDITO_SITUACAO)
	 * 
	 * [SF0001] Selecionar Conta pelo Imóvel e Ano/Mês de Referência
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2006, 05/06/2007, 02/10/2007
	 * 
	 * @param imovel
	 * @param anoMesReferenciaPagamento
	 * @param anoMesFaturamento
	 * 
	 * @return Conta
	 */
	public Object[] selecionarContaPorImovelAnoMesReferencia(Imovel imovel,
			Integer anoMesReferenciaPagamento, Integer anoMesFaturamento)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cnta.id, " 
					+ "cnta.valorAgua, " 
					+ "cnta.valorEsgoto, " 
					+ "cnta.debitos, " 
					+ "cnta.valorCreditos, " 
					+ "cnta.valorImposto, "
					+ "cnta.referenciaContabil, "
					/**
					 * Classificar detalhadamente documentos inexistentes por débito prescrito,
					 * conta parcelada, conta cancelada ou erro de processamento
					 * @author Wellington Rocha
					 * @date 02/08/2012*/
					+ "dcst.id "
					+ "FROM Conta as cnta "
					+ "INNER JOIN cnta.imovel as imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual as dcst "
					+ "WHERE imov.id = :imovelPagamento AND cnta.referencia = :anoMesReferenciaPagamento "
					+ "AND dcst.id IN(:normal, :retificada, :incluida) ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("imovelPagamento", imovel.getId())
					.setInteger("anoMesReferenciaPagamento", anoMesReferenciaPagamento)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.setMaxResults(1).uniqueResult();
			

			/**
			 * Classificar detalhadamente documentos inexistentes por débito prescrito,
			 * conta parcelada, conta cancelada ou erro de processamento
			 * @author Wellington Rocha
			 * @date 02/08/2012*/
			if(retorno == null){
				consulta = "SELECT cnta.id, " 
					+ "cnta.valorAgua, " 
					+ "cnta.valorEsgoto, " 
					+ "cnta.debitos, " 
					+ "cnta.valorCreditos, " 
					+ "cnta.valorImposto, "
					+ "cnta.referenciaContabil, "
					+ "dcst.id "
					+ "FROM Conta as cnta "
					+ "INNER JOIN cnta.imovel as imov "
					+ "INNER JOIN cnta.debitoCreditoSituacaoAtual as dcst "
					+ "WHERE imov.id = :imovelPagamento AND cnta.referencia = :anoMesReferenciaPagamento "
					+ "AND dcst.id IN(:prescritas, :prescritasIncluidas, :canceladas, :parceladas, :erroProcessamento) ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("imovelPagamento", imovel.getId())
					.setInteger("anoMesReferenciaPagamento", anoMesReferenciaPagamento)
					.setInteger("prescritas", DebitoCreditoSituacao.DEBITO_PRESCRITO)
					.setInteger("prescritasIncluidas", DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS)
					.setInteger("canceladas", DebitoCreditoSituacao.CANCELADA)
					.setInteger("parceladas", DebitoCreditoSituacao.PARCELADA)
					.setInteger("erroProcessamento", DebitoCreditoSituacao.ERRO_PROCESSAMENTO)
					.setMaxResults(1).uniqueResult();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * pesquisa todos os bancos que tenham contrato vigente para arrecadador
	 * contas com forma de arrecadação correspondente a debito automático
	 * 
	 * [SB0002] - Carregar Lista de Bancos
	 * 
	 * @author Sávio Luiz
	 * @date 18/04/2006
	 * 
	 * @return Coleção de Bancos
	 * @throws ErroRepositorioException
	 */

	public Collection<Banco> pesquisaBancosDebitoAutomatico()
			throws ErroRepositorioException {

		Collection<Banco> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select banco.id "
					+ "from Banco banco "
					+ "where banco.id in( "
					//+ "select arrecadador.codigoAgente "
					+ "select arrecadador.id "
					+ "from ArrecadadorContratoTarifa arrcConTarifa "
					+ "inner join arrcConTarifa.arrecadacaoForma arrecadadorForma "
					+ "inner join arrcConTarifa.arrecadadorContrato arrecadadorContrato "
					+ "inner join arrecadadorContrato.arrecadador arrecadador "
					+ "where arrecadadorForma.id = :debitoAutomatico "
					+ "and arrecadadorContrato.dataContratoEncerramento is null) "
					+ "order by banco.id";

			retorno = session.createQuery(consulta).setInteger(
					"debitoAutomatico", ArrecadacaoForma.DEBITO_AUTOMATICO)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * pesquisa os movimentos de débito automático para o banco,referentes ao
	 * grupo e ano/mês de faturamento informados
	 * 
	 * [SB0002] - Carregar Lista de Bancos
	 * 
	 * @author Sávio Luiz, Raphael Rossiter, Anderson Italo
	 * @date 18/04/2006, 01/12/2008, 04/02/2010
	 * 
	 * [FS0006]  Verificar a situação da conta
	 * Caso a situação da conta sejam normal (0) ou retificada (1) ou incluída (2), 
	 * gerar movimentos de débito automático para o banco.
	 * Caso contrário retornar para o passo correspondente no subfluxo.
	 * 
	 * @param idFaturamentoGrupo,anoMesReferenciaFaturamento,idBanco
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisaDebitoAutomaticoMovimento(
			Collection colecaoFaturamentoGrupo, Integer anoMesReferenciaFaturamento,
			Collection colecaoidsBanco) throws ErroRepositorioException {

		Collection<DebitoAutomaticoMovimento> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select banco,debAutoMovimento "
					+ "from DebitoAutomaticoMovimento debAutoMovimento "
					+ "inner join debAutoMovimento.faturamentoGrupo fatGrupo "
					+ "inner join fetch debAutoMovimento.debitoAutomatico debAutomatico "
					+ "inner join fetch debAutomatico.agencia agencia "
					+ "inner join agencia.banco banco "
					+ "left join fetch debAutoMovimento.contaGeral cntaGeral "
					+ "left join fetch cntaGeral.conta conta "
					+ "where debAutoMovimento.numeroSequenciaArquivoEnviado is null "
					+ "and fatGrupo.id in (:colecaoFaturamentoGrupo) "
					+ "and conta.referencia = :anoMesReferenciaFaturamento "
					+ "and (conta.debitoCreditoSituacaoAtual.id = :normal or "
					+ "conta.debitoCreditoSituacaoAtual.id = :retificada or "
					+ "conta.debitoCreditoSituacaoAtual.id = :incluida) "
					+ "and banco.id in (:idsBanco) and "
					
					/*
					 * Colocado por Raphael Rossiter em 01/12/2008 - Analista: Rafael Pinto
					 * OBJ: Não gerar movimento de débito automático para contas que já foram pagas.
					 */
					+ "NOT EXISTS (SELECT pgmt.id FROM Pagamento pgmt WHERE pgmt.contaGeral.id = conta.id) "
					+ "order by banco.id";

			retorno = session.createQuery(consulta).setParameterList(
					"idsBanco", colecaoidsBanco).setParameterList(
					"colecaoFaturamentoGrupo", colecaoFaturamentoGrupo).setInteger(
					"anoMesReferenciaFaturamento", anoMesReferenciaFaturamento)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * 
	 * @author Vivianne Sousa
	 * @date 20/04/2006
	 * 
	 * @param avisoBancarioHelper
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarAvisoBancarioAbertoFechado(
			AvisoBancarioHelper avisoBancarioHelper)
			throws ErroRepositorioException {

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";
		/*
		* Acréscimo do atributo idAvisobancário, para permitir a consulta pelo mesmo
		*/
		Integer idAvisoBancario = avisoBancarioHelper.getIdAvisoBancario();

		Short arrecadadorCodAgente = avisoBancarioHelper
				.getCodigoAgenteArrecadador();
		Date dataLancamentoInicio = avisoBancarioHelper
				.getDataLancamentoInicial();
		Date dataLancamentoFim = avisoBancarioHelper.getDataLancamentoFinal();
		Short indicadorCreditoDebito = avisoBancarioHelper
				.getIndicadorCreditoDebito();
		Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
		Integer idMovimento = avisoBancarioHelper.getIdMovimentoArrecadador();
		Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper
				.getDataPrevistaInicial();
		Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper
				.getDataPrevistaFinal();
		Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper
				.getDataRealizadaInicial();
		Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper
				.getDataRealizadaFinal();
		int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper
				.getAnoMesReferenciaArrecadacaoInicial();
		int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper
				.getAnoMesReferenciaArrecadacaoFinal();
		BigDecimal valorRealizadoInicial = avisoBancarioHelper
				.getValorRealizadoInicial();
		BigDecimal valorRealizadoFinal = avisoBancarioHelper
				.getValorRealizadoFinal();
		BigDecimal valorPrevistoInicial = avisoBancarioHelper
				.getValorPrevistoInicial();
		BigDecimal valorPrevistoFinal = avisoBancarioHelper
				.getValorPrevistoFinal();
		String select = "";

		select = this.selectFiltrarAvisoBancario();

		int flag = 0;
		if (arrecadadorCodAgente == null
				&& (dataLancamentoInicio == null || dataLancamentoFim == null)
				&& (indicadorCreditoDebito == 0 || indicadorCreditoDebito == 3)
				&& idContaBancaria == null
				&& idMovimento == null
				&& (dataPrevisaoCreditoDebitoInicio == null || dataPrevisaoCreditoDebitoFim == null)
				&& (dataRealizacaoCreditoDebitoInicio == null || dataRealizacaoCreditoDebitoFim == null)
				&& (anoMesReferenciaArrecadacaoInicial == 0 || anoMesReferenciaArrecadacaoFinal == 0)
				&& (valorPrevistoInicial == null || valorPrevistoFinal == null)
				&& (valorRealizadoInicial == null || valorRealizadoFinal == null)
				/*
				 * Acréscimo do atributo idAvisobancário
				*/
				&& idAvisoBancario == null) {
			flag = 1;

			// consulta = "select avisoBancario " + " from AvisoBancario
			// avisoBancario ";
			consulta = select;

		} else {
			// consulta = "select avisoBancario " + " from AvisoBancario
			// avisoBancario " + " where ";
			consulta = select + " where ";
		}
		
		/*
		 * Acréscimo do filtro idAvisobancário, para que a consulta possa ser efetuada pelo id
		 * */
		if(idAvisoBancario != null) {
			consulta += " avisoBancario.id = " 
				+ idAvisoBancario + " and";
		}

		if (arrecadadorCodAgente != null) {
			consulta += " avisoBancario.arrecadador.codigoAgente = "
					+ arrecadadorCodAgente + " and";
		}

		if ((dataLancamentoInicio != null) && (dataLancamentoFim != null)) {
			consulta += " avisoBancario.dataLancamento between :dataLancamentoInicio  and "
					+ ":dataLancamentoFim and";

		}

		if (indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3) {
			consulta += " avisoBancario.indicadorCreditoDebito = "
					+ indicadorCreditoDebito + " and";
		}

		if (idContaBancaria != null) {
			consulta += " avisoBancario.contaBancaria.id = " + idContaBancaria
					+ " and";
		}

		if (idMovimento != null) {
			consulta += " avisoBancario.arrecadadorMovimento.id = "
					+ idMovimento + " and";
		}

		if ((dataPrevisaoCreditoDebitoInicio != null)
				&& (dataPrevisaoCreditoDebitoFim != null)) {
			consulta += " avisoBancario.dataPrevista between :dataPrevisaoCreditoDebitoInicio  and "
					+ ":dataPrevisaoCreditoDebitoFim and";

		}

		if ((dataRealizacaoCreditoDebitoInicio != null)
				&& (dataRealizacaoCreditoDebitoFim != null)) {
			consulta += " avisoBancario.dataRealizada between :dataRealizacaoCreditoDebitoInicio  and "
					+ ":dataRealizacaoCreditoDebitoFim and";

		}

		if ((anoMesReferenciaArrecadacaoInicial != 0)
				&& (anoMesReferenciaArrecadacaoFinal != 0)) {
			consulta += " avisoBancario.anoMesReferenciaArrecadacao between "
					+ anoMesReferenciaArrecadacaoInicial + " and "
					+ anoMesReferenciaArrecadacaoFinal + " and";
		}

		if ((valorRealizadoInicial != null) && (valorRealizadoFinal != null)) {

			BigDecimal valorInicialNegativo = valorRealizadoFinal
					.multiply(new BigDecimal("-1.00"));
			BigDecimal valorFinalNegativo = valorRealizadoInicial
					.multiply(new BigDecimal("-1.00"));
			consulta += " ((avisoBancario.valorRealizado between "
					+ valorInicialNegativo + " and " + valorFinalNegativo
					+ ") or (avisoBancario.valorRealizado between "
					+ valorRealizadoInicial + " and " + valorRealizadoFinal
					+ "))" + " and";
		}

		String consultarComOrderBy = "";

		if (flag != 1) {
			consultarComOrderBy = Util.removerUltimosCaracteres(consulta, 4)
					+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
		} else {
			consultarComOrderBy = Util.removerUltimosCaracteres(consulta, 0)
					+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
		}

		// Consulta
		try {

			if ((((dataLancamentoInicio != null) && (dataLancamentoFim != null)) && ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).list();

			} else if (((dataLancamentoInicio != null) && (dataLancamentoFim != null))
					&& ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).list();

			} else if (((dataLancamentoInicio != null) && (dataLancamentoFim != null))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).list();

			} else if (((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).list();

			} else if ((dataLancamentoInicio != null)
					&& (dataLancamentoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).list();

			} else if ((dataPrevisaoCreditoDebitoInicio != null)
					&& (dataPrevisaoCreditoDebitoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).list();

			} else if ((dataRealizacaoCreditoDebitoInicio != null)
					&& (dataRealizacaoCreditoDebitoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).list();

			} else {

				return session.createQuery(consultarComOrderBy).list();
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * pesquisa 2 campos do arrecadador contrato
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * 
	 * @param idBanco
	 * @return Código do Convênio, numero sequencial de envio
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisaCamposArrecadadorContrato(Integer idBanco)
			throws ErroRepositorioException {

		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select arreContrato.id, "// 0
					+ "arreContrato.codigoConvenio, "// 1
					+ "arreContrato.numeroSequencialArquivoEnvioDebitoAutomatico, "// 2
					+ "arreContrato.descricaoEmail, "// 3
					+ "arreContrato.tamanhoMaximoIdentificacaoImovel "// 4
					+ "from ArrecadadorContrato arreContrato "
					+ "inner join arreContrato.arrecadador arrec "
					//+ "where arrec.codigoAgente = :idBanco and "
					+ "where arrec.id = :idBanco and "
					+ "arreContrato.dataContratoEncerramento is null";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idBanco", idBanco).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * pesquisa a agencia passando o id do banco
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * 
	 * @param idBanco
	 * @return Agencia
	 * @throws ErroRepositorioException
	 */

	public Agencia pesquisaAgenciaPorBanco(Integer idBanco)
			throws ErroRepositorioException {

		Agencia retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select agencia " + "from Agencia agencia "
					+ "inner join agencia.banco banco "
					+ "where banco.id = :idBanco ";

			retorno = (Agencia) session.createQuery(consulta).setInteger(
					"idBanco", idBanco).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * atualiza o numero sequencial arquivo envio debito automatico
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * 
	 * @param idBanco
	 * @return Código do Convênio, numero sequencial de envio
	 * @throws ErroRepositorioException
	 */

	public void atualizarNumeroSequencialArrecadadorContrato(
			Integer idArrecadadorContrato, Integer numeroSequencialArquivo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			atualizarImovel = "update gcom.arrecadacao.ArrecadadorContrato "
					+ "set arct_nnnsaenviodebaut = :numeroSequencialArquivo,arct_tmultimaalteracao = :dataUltimaAlteracao where arct_id = :idArrecadadorContrato";

			session.createQuery(atualizarImovel).setInteger(
					"idArrecadadorContrato", idArrecadadorContrato.intValue())
					.setTimestamp("dataUltimaAlteracao", new Date())
					.setInteger("numeroSequencialArquivo",
							numeroSequencialArquivo.intValue()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * pesquisa o email do arrecadador contrato passando o código do banco
	 * 
	 * [SB0003] - Regerar arquivo TXT para um movimento de débito automático
	 * gerado anteriormente
	 * 
	 * @author Sávio Luiz
	 * @date 25/04/2006
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public String pesquisarEmailArrecadadorContrato(Short codigoBanco)
			throws ErroRepositorioException {

		String retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select arrecadadorContrato.descricaoEmail "
					+ "from ArrecadadorContrato arrecadadorContrato "
					+ "inner join arrecadadorContrato.arrecadador arrecadador "
					+ "where arrecadador.codigoAgente = :codigoBanco "
					+ "and arrecadadorContrato.dataContratoEncerramento is null";

			retorno = (String) session.createQuery(consulta).setShort(
					"codigoBanco", codigoBanco).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualizar Devolucao
	 * 
	 * @author Fernanda Paiva
	 * @created 03/05/2006
	 * 
	 * @param valor
	 *            arrecadacao
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public void atualizaValorArrecadacaoAvisoBancaraio(BigDecimal valor,
			Integer codigoAvisoBancario) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaAvisoBancario;

		try {
			// Atualiza em AvisoBancario o valor da arrecadacao
			atualizaAvisoBancario = "update gcom.arrecadacao.aviso.AvisoBancario "
					+ "set avbc_vldevolucaocalculado = :valor, avbc_tmultimaalteracao = :ultimaAlteracao "
					+ "where avbc_id = :codigoAvisoBancario";

			session.createQuery(atualizaAvisoBancario).setBigDecimal("valor",
					(valor)).setInteger("codigoAvisoBancario",
					(codigoAvisoBancario)).setTimestamp("ultimaAlteracao",
					new Date()).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * Faz a pesquisa de guia de devolução para o relatório fazendo os
	 * carregamentos de clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 11/09/2006
	 * 
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaDevolucao> pesquisarGuiaDevolucaoRelatorio(
			FiltroGuiaDevolucao filtroGuiaDevolucao)
			throws ErroRepositorioException {

		Collection<GuiaDevolucao> retorno = null;

		Session session = HibernateUtil.getSession();

		try {

			retorno = new ArrayList(
					new CopyOnWriteArraySet<GuiaDevolucao>(
							GeradorHQLCondicional
									.gerarCondicionalQuery(
											filtroGuiaDevolucao,
											"guiaDevolucao",
											"select distinct guiaDevolucao from gcom.arrecadacao.GuiaDevolucao as guiaDevolucao "
													+ "left join guiaDevolucao.conta.clienteContas clienteContas "
													+ "left join guiaDevolucao.debitoACobrarGeral.debitoACobrar.imovel.clienteImoveis clienteImoveis "
													+ "left join guiaDevolucao.guiaPagamento.clientesGuiaPagamento clientesGuiaPagamento ",
											session).list()));
		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0324] - Filtrar Guia de Devolucao
	 * 
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * 
	 * Faz a pesquisa de guia de devolução fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * 
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaDevolucao> pesquisarGuiaDevolucao(
			FiltroGuiaDevolucao filtroGuiaDevolucao, Integer numeroPagina)
			throws ErroRepositorioException {

		Collection<GuiaDevolucao> retorno = null;

		Session session = HibernateUtil.getSession();

		try {

			retorno = new ArrayList(
					new CopyOnWriteArraySet<GuiaDevolucao>(
							GeradorHQLCondicional
									.gerarCondicionalQuery(
											filtroGuiaDevolucao,
											"guiaDevolucao",
											"select distinct guiaDevolucao from gcom.arrecadacao.GuiaDevolucao as guiaDevolucao "
													+ "left join guiaDevolucao.conta.clienteContas clienteContas "
													+ "left join guiaDevolucao.debitoACobrarGeral.debitoACobrar.imovel.clienteImoveis clienteImoveis "
													+ "left join guiaDevolucao.guiaPagamento.clientesGuiaPagamento clientesGuiaPagamento ",
											session).setFirstResult(
											10 * numeroPagina)
									.setMaxResults(10).list()));
		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0324] - Filtrar Guia de Devolucao
	 * 
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * 
	 * Cria um contador para a pesquisa de guia de devolução para ser utilizado
	 * pelo componente de paginação
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * 
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarGuiaDevolucaoCount(
			FiltroGuiaDevolucao filtroGuiaDevolucao)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		filtroGuiaDevolucao.limparCamposOrderBy();

		try {

			retorno = (Integer) GeradorHQLCondicional
					.gerarCondicionalQuery(
							filtroGuiaDevolucao,
							"guiaDevolucao",
							"select count (guiaDevolucao.id) from gcom.arrecadacao.GuiaDevolucao as guiaDevolucao "
									+ "left join guiaDevolucao.conta.clienteContas clienteContas "
									+ "left join guiaDevolucao.debitoACobrarGeral debitoACobrarGeral " 
									+ "left join debitoACobrarGeral.debitoACobrar debitoACobrar " 
									+ "left join debitoACobrar.imovel imovel " 
									+ "left join imovel.clienteImoveis clienteImoveis "
									+ "left join guiaDevolucao.guiaPagamento.clientesGuiaPagamento clientesGuiaPagamento "
							,
							session).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa, Diogo Peixoto
	 * @created 23/05/2006, 27/04/2011
	 * @param anoMesReferencia
	 * @param estadoMunicipio
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstado(
			int anoMesReferencia, boolean estadoMunicipio) throws ErroRepositorioException{
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		String joinMunicipio = "";
		if(estadoMunicipio){
			joinMunicipio = " INNER JOIN ra.localidade loc INNER JOIN loc.municipio ";
		}
		try {

			consulta = "select sum(ra.valorItemArrecadacao),"
					+ " rt.descricao," + " lt.descricao," + " li.descricao,"
					+ " lic.descricao," + " lt.indicadorImpressao,"
					+ " lt.indicadorTotal," + " lt.id,"
					+ " lt.lancamentoTipo.id," + " ra.categoria.id,"
					+ " rt.id," + " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento"
					+ " from ResumoArrecadacao ra"
					+ " left join ra.lancamentoTipo lt"
					+ " left join ra.lancamentoItem li"
					+ " left join ra.lancamentoItemContabil lic"
					+ " left join ra.recebimentoTipo rt"
					+ joinMunicipio
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
					+ " group by " + " rt.descricao," + " lt.descricao,"
					+ " li.descricao," + " lic.descricao,"
					+ " lt.indicadorImpressao," + " lt.indicadorTotal,"
					+ " lt.id," + " lt.lancamentoTipo.id,"
					+ " ra.categoria.id, rt.id, rt.numeroSequencia, "
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento"
                    + " order by rt.numeroSequencia, "
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorGerenciaRegional(
			int anoMesReferencia) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select sum(ra.valorItemArrecadacao),"
					+ " rt.descricao," + " lt.descricao," + " li.descricao,"
					+ " lic.descricao," + " lt.indicadorImpressao,"
					+ " lt.indicadorTotal," + " lt.id,"
					+ " lt.lancamentoTipo.id," + " ra.categoria.id,"
					+ " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id,"
					+ " rt.id," + " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento"
					+ " from ResumoArrecadacao ra"
					+ " left join ra.lancamentoTipo lt"
					+ " left join ra.lancamentoItem li"
					+ " left join ra.lancamentoItemContabil lic"
					+ " left join ra.recebimentoTipo rt"
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
					+ " group by " + " ra.gerenciaRegional.nome,"
					+ " ra.gerenciaRegional.id," + " rt.descricao,"
					+ " lt.descricao," + " li.descricao," + " lic.descricao,"
					+ " lt.indicadorImpressao," + " lt.indicadorTotal,"
					+ " lt.id," + " lt.lancamentoTipo.id,"
					+ " ra.categoria.id," + " rt.id, rt.numeroSequencia, "
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento"
					+ " order by ra.gerenciaRegional.id," + " rt.numeroSequencia,"
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorLocalidade(
			int anoMesReferencia) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select " 
				    + " sum(ra.valorItemArrecadacao),"//0
					+ " rt.descricao," //1
					+ " lt.descricao," //2
					+ " li.descricao," //3
					+ " lic.descricao," //4
					+ " lt.indicadorImpressao," //5
					+ " lt.indicadorTotal," //6
					+ " lt.id,"//7
					+ " lt.lancamentoTipo.id,"//8 
					+ " ra.categoria.id,"//9
					+ " ra.gerenciaRegional.nome,"//10 
					+ " ra.gerenciaRegional.id,"//11
					+ " ra.localidade.descricao," //12
					+ " ra.localidade.id,"//13
					+ " rt.id," //14
					+ " ra.sequenciaTipoLancamento,"//15
					+ " ra.sequenciaItemTipoLancamento,"//16 
					+ " ra.unidadeNegocio.nome, " //17
					+ " ra.unidadeNegocio.id, " //18
                    + " ra.localidade.codigoCentroCusto " //19
					+ " from ResumoArrecadacao ra"
					+ " left join ra.lancamentoTipo lt"
					+ " left join ra.lancamentoItem li"
					+ " left join ra.lancamentoItemContabil lic"
					+ " left join ra.recebimentoTipo rt"
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " (ra.categoria.id = 1 or" 
					+ " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" 
					+ " ra.categoria.id = 4)"
					+ " group by " 
					+ " ra.gerenciaRegional.nome,"
					+ " ra.gerenciaRegional.id," 
					+ " ra.localidade.descricao,"
					+ " ra.localidade.id," 
					+ " rt.descricao,"
					+ " lt.descricao," 
					+ " li.descricao," 
					+ " lic.descricao,"
					+ " lt.indicadorImpressao," 
					+ " lt.indicadorTotal,"
					+ " lt.id," 
					+ " lt.lancamentoTipo.id,"
					+ " ra.categoria.id," 
					+ " rt.id, rt.numeroSequencia, "
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento,"
					+ " ra.unidadeNegocio.nome, " 
					+ " ra.unidadeNegocio.id, "
                    + " ra.localidade.codigoCentroCusto "
					+ " order by "
					+ " ra.localidade.id,"
					+ " ra.unidadeNegocio.id,"
					+ " ra.gerenciaRegional.id," 
					+ " rt.numeroSequencia," 
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento," 
					+ " ra.categoria.id,"
                    + " ra.localidade.codigoCentroCusto ";
                    

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
			int anoMesReferencia, Integer gerenciaRegional)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(ra.valorItemArrecadacao),"
					+ " rt.descricao," + " lt.descricao," + " li.descricao,"
					+ " lic.descricao," + " lt.indicadorImpressao,"
					+ " lt.indicadorTotal," + " lt.id,"
					+ " lt.lancamentoTipo.id," + " ra.categoria.id,"
					+ " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id,"
					+ " rt.id," + " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento"
					+ " from ResumoArrecadacao ra"
					+ " left join ra.lancamentoTipo lt"
					+ " left join ra.lancamentoItem li"
					+ " left join ra.lancamentoItemContabil lic"
					+ " left join ra.recebimentoTipo rt"
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " ra.gerenciaRegional = :gerenciaRegional and "
					+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
					+ " group by " + " rt.descricao," + " lt.descricao,"
					+ " li.descricao," + " lic.descricao,"
					+ " lt.indicadorImpressao," + " lt.indicadorTotal,"
					+ " lt.id," + " lt.lancamentoTipo.id,"
					+ " ra.categoria.id," + " ra.gerenciaRegional.nome,"
					+ " ra.gerenciaRegional.id," + " rt.id, rt.numeroSequencia, "
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento" + " order by rt.numeroSequencia,"
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"gerenciaRegional", gerenciaRegional).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorGerenciaRegionalPorLocalidade(
			int anoMesReferencia, Integer gerenciaRegional)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(ra.valorItemArrecadacao),"
					+ " rt.descricao," + " lt.descricao," + " li.descricao,"
					+ " lic.descricao," + " lt.indicadorImpressao,"
					+ " lt.indicadorTotal," + " lt.id,"
					+ " lt.lancamentoTipo.id," + " ra.categoria.id,"
					+ " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id,"
					+ " ra.localidade.descricao," + " ra.localidade.id,"
					+ " rt.id," + " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento, ra.localidade.codigoCentroCusto"
					+ " from ResumoArrecadacao ra"
					+ " left join ra.lancamentoTipo lt"
					+ " left join ra.lancamentoItem li"
					+ " left join ra.lancamentoItemContabil lic"
					+ " left join ra.recebimentoTipo rt"
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " ra.gerenciaRegional = :gerenciaRegional and"
					+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
					+ " group by " + " ra.localidade.descricao,"
					+ " ra.localidade.id," + " rt.descricao,"
					+ " lt.descricao," + " li.descricao," + " lic.descricao,"
					+ " lt.indicadorImpressao," + " lt.indicadorTotal,"
					+ " lt.id," + " lt.lancamentoTipo.id,"
					+ " ra.categoria.id," + " ra.gerenciaRegional.nome,"
					+ " ra.gerenciaRegional.id," + " rt.id,"
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento, ra.localidade.codigoCentroCusto" 
					+ " order by "
					+ " ra.localidade.codigoCentroCusto,"
					+ " ra.localidade.id," + " rt.id,"
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"gerenciaRegional", gerenciaRegional).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorLocalidade(
			int anoMesReferencia, Integer localidade)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(ra.valorItemArrecadacao),"
					+ " rt.descricao," + " lt.descricao," + " li.descricao,"
					+ " lic.descricao," + " lt.indicadorImpressao,"
					+ " lt.indicadorTotal," + " lt.id,"
					+ " lt.lancamentoTipo.id," + " ra.categoria.id,"
					+ " ra.localidade.descricao," + " ra.localidade.id,"
					+ " rt.id," + " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento, ra.localidade.codigoCentroCusto"
					+ " from ResumoArrecadacao ra"
					+ " left join ra.lancamentoTipo lt"
					+ " left join ra.lancamentoItem li"
					+ " left join ra.lancamentoItemContabil lic"
					+ " left join ra.recebimentoTipo rt"
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " ra.localidade = :localidade and"
					+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
					+ " group by " + " rt.descricao," + " lt.descricao,"
					+ " li.descricao," + " lic.descricao,"
					+ " lt.indicadorImpressao," + " lt.indicadorTotal,"
					+ " lt.id," + " lt.lancamentoTipo.id,"
					+ " ra.categoria.id," + " ra.localidade.descricao,"
					+ " ra.localidade.id," + " rt.id,"
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento, ra.localidade.codigoCentroCusto" + " order by rt.id,"
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"localidade", localidade).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * Caso a opção seja Estado por Município, o valor do idMunicipio deve ser null
	 * caso seja Município, o valor do idMunicipio deve ser diferente de null
	 * 
	 * @author Diogo Peixoto
	 * @created 20/04/2011
	 * 
	 * @param anoMesReferencia
	 *  
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorMunicipio(int anoMesReferencia)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		
		try {			
			
			sb.append("SELECT SUM(ra.valorItemArrecadacao), "); //0
			sb.append("rt.descricao, "); //1
			sb.append("lt.descricao, "); //2
			sb.append("li.descricao, "); //3
			sb.append("lic.descricao, "); //4
			sb.append("lt.indicadorImpressao, "); //5
			sb.append("lt.indicadorTotal, "); //6
			sb.append("lt.id, "); //7
			sb.append("lt.lancamentoTipo.id, "); //8
			sb.append("ra.categoria.id, "); //9
			sb.append("ra.localidade.descricao, "); //10
			sb.append("ra.localidade.id, "); //11
			sb.append("muni.nome, "); //12 
			sb.append("muni.id, "); //13
			sb.append("rt.id, "); //14
			sb.append("ra.sequenciaTipoLancamento, "); //15
			sb.append("ra.sequenciaItemTipoLancamento "); //16
			sb.append("FROM ResumoArrecadacao ra LEFT JOIN ra.lancamentoTipo lt ");
			sb.append("LEFT JOIN ra.lancamentoItem li ");
			sb.append("LEFT JOIN ra.lancamentoItemContabil lic ");
			sb.append("LEFT JOIN ra.recebimentoTipo rt ");
			sb.append("INNER JOIN ra.localidade loc ");
			sb.append("INNER JOIN loc.municipio muni ");
			sb.append("WHERE ra.anoMesReferencia = :anoMesReferencia and ");
			sb.append("(ra.categoria.id = 1 or" + " ra.categoria.id = 2 or ");
			sb.append("ra.categoria.id = 3 or" + " ra.categoria.id = 4) ");
			sb.append("GROUP BY ");
			sb.append("muni.nome, ");
			sb.append("muni.id, ");
			sb.append("ra.localidade.descricao, ");
			sb.append("ra.localidade.id, ");
			sb.append("rt.descricao, ");
			sb.append("lt.descricao, ");
			sb.append("li.descricao, ");
			sb.append("lic.descricao, ");
			sb.append("lt.indicadorImpressao, ");
			sb.append("lt.indicadorTotal, ");
			sb.append("lt.id, ");
			sb.append("lt.lancamentoTipo.id, ");
			sb.append("ra.categoria.id, ");
			sb.append("rt.id, ");
			sb.append("rt.numeroSequencia, ");
			sb.append("ra.sequenciaTipoLancamento, ");
			sb.append("ra.sequenciaItemTipoLancamento ");
			sb.append("ORDER BY muni.id, ");
			sb.append("ra.localidade.id, ");
			sb.append("rt.id, ");
			sb.append("ra.sequenciaTipoLancamento, ");
			sb.append("ra.sequenciaItemTipoLancamento, ");
			sb.append("ra.categoria.id ");
			
			
			
			
			retorno = session.createQuery(sb.toString()).setInteger("anoMesReferencia", anoMesReferencia).list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Diogo Peixoto
	 * @created 20/04/2011
	 * 
	 * @param anoMesReferencia
	 * @param idMunicipio
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorMunicipio(int anoMesReferencia, Integer idMunicipio)
		throws ErroRepositorioException{
		
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		
		try {
			sb.append("SELECT SUM(ra.valorItemArrecadacao), "); //0
			sb.append("rt.descricao, "); //1
			sb.append("lt.descricao, "); //2
			sb.append("li.descricao, "); //3
			sb.append("lic.descricao, "); //4
			sb.append("lt.indicadorImpressao, "); //5
			sb.append("lt.indicadorTotal, "); //6
			sb.append("lt.id, "); //7
			sb.append("lt.lancamentoTipo.id, "); //8
			sb.append("ra.categoria.id, "); //9
			sb.append("muni.nome, "); //10 
			sb.append("muni.id, "); //11
			sb.append("rt.id, "); //12
			sb.append("ra.sequenciaTipoLancamento, "); //13
			sb.append("ra.sequenciaItemTipoLancamento "); //14
			sb.append("FROM ResumoArrecadacao ra LEFT JOIN ra.lancamentoTipo lt ");
			sb.append("LEFT JOIN ra.lancamentoItem li ");
			sb.append("LEFT JOIN ra.lancamentoItemContabil lic ");
			sb.append("LEFT JOIN ra.recebimentoTipo rt ");
			sb.append("INNER JOIN ra.localidade loc ");
			sb.append("INNER JOIN loc.municipio muni ");
			sb.append("WHERE ra.anoMesReferencia = :anoMesReferencia and ");
			sb.append(" muni.id = :municipio and");
			sb.append("(ra.categoria.id = 1 or" + " ra.categoria.id = 2 or ");
			sb.append("ra.categoria.id = 3 or" + " ra.categoria.id = 4) ");
			sb.append("GROUP BY ");
			sb.append("rt.descricao, ");
			sb.append("lt.descricao, ");
			sb.append("li.descricao, ");
			sb.append("lic.descricao, ");
			sb.append("lt.indicadorImpressao, ");
			sb.append("lt.indicadorTotal, ");
			sb.append("lt.id, ");
			sb.append("lt.lancamentoTipo.id, ");
			sb.append("ra.categoria.id, ");
			sb.append("muni.nome, ");
			sb.append("muni.id, ");
			sb.append("rt.id, ");
			sb.append("ra.sequenciaTipoLancamento, ");
			sb.append("ra.sequenciaItemTipoLancamento ");
			sb.append("ORDER BY ");
			sb.append("rt.id, ");
			sb.append("ra.sequenciaTipoLancamento, ");
			sb.append("ra.sequenciaItemTipoLancamento, ");
			sb.append("ra.categoria.id ");

			retorno = session.createQuery(sb.toString()).setInteger("anoMesReferencia", anoMesReferencia)
														.setInteger("municipio", idMunicipio).list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * Método que vai retornar a quantidade de registros do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa, Diogo Peixoto
	 * @created 02/06/2006, 20/04/2011
	 * 
	 * 
	 * @return Quantidade de Registros
	 * @throws ErroRepositorioException
	 */	
	public Integer consultarQtdeRegistrosResumoArrecadacaoRelatorio(int anoMesReferencia, Integer localidade, Integer gerenciaRegional,
			Integer municipio, String opcaoTotalizacao) throws ErroRepositorioException {
		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			if(opcaoTotalizacao.equals("municipio")){
				consulta = "select count(ra.id)" + " from ResumoArrecadacao ra "
					+ "INNER JOIN ra.localidade loc "
					+ " where ra.anoMesReferencia = :anoMesReferencia "
					+ " and loc.municipio = :municipio "
					+ " and (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)";
				
			}else{
				consulta = "select count(ra.id)" + " from ResumoArrecadacao ra"
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)";
			}

			if (opcaoTotalizacao.equals("localidade") && localidade != null) {

				consulta = consulta + " and ra.localidade = :localidade";

				retorno = (Integer) session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger(
						"localidade", localidade).uniqueResult();

			} else if (opcaoTotalizacao.equals("municipio") && municipio != null) {
				retorno = (Integer) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
																 .setInteger("municipio", municipio).uniqueResult();
			} else if ((opcaoTotalizacao.equals("gerenciaRegionalLocalidade") || opcaoTotalizacao
					.equals("gerenciaRegional"))
					&& gerenciaRegional != null) {

				consulta = consulta
						+ " and ra.gerenciaRegional = :gerenciaRegional";

				retorno = (Integer) session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger(
						"gerenciaRegional", gerenciaRegional).uniqueResult();
			} else {
				retorno = (Integer) session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).uniqueResult();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0352] Emitir Conta
	 * 
	 * pesquisa o nome do banco e código da agencia passando o id do imóvel
	 * 
	 * [SB0017] - Gerar Linhas das contas com Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 26/05/2006
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarParmsDebitoAutomatico(Integer idImovel)
			throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select banco.descricao," 
					+ "agencia.codigoAgencia, "
					+ "banco.id, "
					+ "debAutomatico.identificacaoClienteBanco "
					+ "from DebitoAutomatico debAutomatico "
					+ "inner join debAutomatico.agencia agencia "
					+ "inner join debAutomatico.imovel imov "
					+ "inner join agencia.banco banco "
					+ "where imov.id = :idImovel "
					+ "and debAutomatico.dataExclusao is null ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Inseri os resumos das arrecadações gerados pelo batch no sistema
	 * 
	 * @author Pedro Alexandre
	 * @date 17/05/2006
	 * 
	 * @param colecaoResumoArrecadacao
	 * @throws ErroRepositorioException
	 */
	public void inserirResumoArrecadacao(
			Collection<ResumoArrecadacao> colecaoResumoArrecadacao)
			throws ErroRepositorioException {
		
		
		StatelessSession session = HibernateUtil.getStatelessSession();
		try {

			// Caso a coleção de resumos da arrecadação seja diferente de nulo
			// insere os resumos e a cada 50 registros inseridos comita e limpa
			// a sessão
			if (colecaoResumoArrecadacao != null) {
				// int i = 1;
				for (ResumoArrecadacao resumoArrecadacao : colecaoResumoArrecadacao) {
					session.insert(resumoArrecadacao);
				}
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// session.clear();
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Verifica se já existe resumo da arrecadação para o ano/mês de referência
	 * da arrecadação
	 * 
	 * [FS0003] - Verificar a existência do resumo da arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoArrecadacaoPorAnoMesArrecadacao(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from ResumoArrecadacao resumoArrecadacao "
					+ "where resumoArrecadacao.anoMesReferencia = :anoMesReferenciaArrecadacao ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de resumo de faturamento pesquisada
		// ou nulo se não existir dados para o ano/mês da arrecadação informado
		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Verifica se já existe resumo da arrecadação para o ano/mês de referência
	 * da arrecadação
	 * 
	 * [FS0003] - Verificar a existência do resumo da arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoArrecadacaoPorAnoMesArrecadacao(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from ResumoArrecadacao resumoArrecadacao "
					+ "where resumoArrecadacao.anoMesReferencia = :anoMesReferenciaArrecadacao "
					+ "and resumoArrecadacao.localidade.id = :idLocalidade";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de resumo de faturamento pesquisada
		// ou nulo se não existir dados para o ano/mês da arrecadação informado
		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos classificados de conta do ano/mês de referência da
	 * arrecadação com a situação atual(PGST_IDATUAL) igual a pagamento
	 * classificado ou baixar valor excedente e com o código da conta diferente
	 * de nulo (CNTA_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosClassificadosContas(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.contaGeral.id is not null "
					+ "order by pgmt.contaGeral.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos classificados de guia de pagamento do ano/mês de
	 * referência da arrecadação com a situação atual(PGST_IDATUAL) igual a
	 * pagamento classificado ou baixar valor excedente e com o código da guia
	 * de pagamento diferente de nulo (GPAG_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosClassificadosGuiasPagamento(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesRefereciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.guiaPagamento.id is not null"
					+ "order by pgmt.guiaPagamento.id";
			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos classificados de débito a cobrar do ano/mês de
	 * referência da arrecadação com a situação atual(PGST_IDATUAL) igual a
	 * pagamento classificado ou baixar valor excedente e com o código do débito
	 * a cobrar diferente de nulo (DBAC_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosClassificadosDebitoACobrar(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.debitoACobrarGeral.id is not null "
					+ "order by pgmt.debitoACobrarGeral.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos não classificados do mês, que são do ano/mês de
	 * referência da arrecadação com a situação atual(PGST_IDATUAL) diferente de
	 * pagamento classificado
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosNaoClassificadosMes(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and pgmt.pagamentoSituacaoAtual.id <> "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções classificadas do ano/mês de referência da
	 * arrecadação e com situação atual igual a devolução classificada ou
	 * devolução de outros valores
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesClassificadas(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Devolucao devl "
					+ "where devl.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and (devl.devolucaoSituacaoAtual.id = "
					+ DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " or "
					+ "devl.devolucaoSituacaoAtual.id = "
					+ DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES + ") ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções não classificadas do mês, para situação atual
	 * diferente de devolução classificada e devolução de outros valores
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesNaoClassificadasMes(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Devolucao devl "
					+ "where devl.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and devl.devolucaoSituacaoAtual.id <> "
					+ DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " and "
					+ "devl.devolucaoSituacaoAtual.id <> "
					+ DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês, que sãoos do ano/mês de referência anterior ao da
	 * arrecadação, que foram classificados no mês, com situação atual igual a
	 * pagamento classificado ou baixar valor excedente e com código da conta
	 * diferente de nulo (CNTA_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosContasEfetuadosEmMesesAnterioresClassificadosMes(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.contaGeral.id is not null "
					+ "order by pgmt.contaGeral.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos de guias de pagamento efetuados em meses
	 * anteriores classificados no mês, que são os do ano/mês de referência
	 * anterior ao da arrecadação, que foram classificados no mês, com situação
	 * atual igual a pagamento classificado ou baixar valor excedente e com
	 * código da guia de pagamento diferente de nulo (GPAG_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosGuiasPagamentoEfetuadosEmMesesAnterioresClassificadosMes(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesRefereciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.guiaPagamento.id is not null"
					+ "order by pgmt.guiaPagamento.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos de débitos a cobrar efetuados em meses anteriores
	 * classificados no mês, que são os do ano/mês de referência anterior ao da
	 * arrecadação, que foram classificados no mês, com situação atual igual a
	 * pagamento classificado ou baixar valor excedente e com código do débito a
	 * cobrar diferente de nulo (DBAC_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosDebitoACobrarEfetuadosEmMesesAnterioresClassificadosMes(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.debitoACobrarGeral.id is not null "
					+ "order by pgmt.debitoACobrarGeral.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções efetuadas em meses anteriores classificadas no
	 * mês, que são as do ano/mês de referência anterior ao da arrecadação e que
	 * foram classificadas no mês, comsituação atual igual a devolução
	 * classificada ou devolução de outros valores.
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMes(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Devolucao devl "
					+ "where devl.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
					+ "and (devl.devolucaoSituacaoAtual.id = "
					+ DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " or "
					+ "devl.devolucaoSituacaoAtual.id = "
					+ DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES + ") ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos não classificados com baixa comandada, que são os
	 * que estão com a situação atual com o valor correspondente a baixar
	 * excedente
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosNaoClassificadosComBaixaComandada()
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ "where pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacaoAtual ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"pagamentoSituacaoAtual", PagamentoSituacao.VALOR_A_BAIXAR)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os pagamentos não classificados, que são os do ano/mês de
	 * referência igual ou anterior ao da arrecadação e que estão não
	 * classificados,com situação atual diferente de pagamento classificado e de
	 * baixar valor excedente
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosNaoClassificados(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt "
					+ " where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao"
					+ " and pgmt.pagamentoSituacaoAtual.id <> "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO
					+ " and pgmt.pagamentoSituacaoAtual.id <> "
					+ PagamentoSituacao.VALOR_A_BAIXAR;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções não classificadas, que são as do ano/mês de
	 * referência igual ou anterior ao da arrecadação e que continuam não
	 * classificados, com situação atual com o valor diferente de devolução
	 * classificada e devolução de outros valores.
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesNaoClassificadas(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from Devolucao devl "
					+ "where devl.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ "and devl.devolucaoSituacaoAtual.id <> "
					+ DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " and "
					+ "devl.devolucaoSituacaoAtual.id <> "
					+ DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 100
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor de água por categoria e localidade paa os pagamentos
	 * classificados de conta
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 22/05/2006, 22/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorAguaPagamentosClassificadosConta(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select sum(ctcg.valorAgua) "
					+ "from ContaCategoria ctcg "
					+ "where ctcg.comp_id.categoria.id= :idCategoria "
					+ " and ctcg.comp_id.conta.id in ( select distinct(pgmt.contaGeral.id) "
					+ "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and pgmt.localidade.id =:idLocalidade "
					+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
					+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
					+ "and pgmt.contaGeral.id is not null )";

			retorno = (BigDecimal) session.createQuery(consulta)
				.setInteger("idCategoria", idCategoria)
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
				.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
				.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 200
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor de esgoto por categoria e localidade paa os pagamentos
	 * classificados de conta
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEsgotoPagamentosClassificadosConta(
			Integer idLocalidade, Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select sum(ctcg.valorEsgoto) "
					+ "from ContaCategoria ctcg "
					+ "where ctcg.comp_id.categoria.id= :idCategoria "
					+ " and ctcg.comp_id.conta.id in ( select distinct(pgmt.contaGeral.id) "
					+ "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and pgmt.localidade.id = :idLocalidade "
					+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
					+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
					+ "and pgmt.contaGeral.id is not null " + ") ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idCategoria", idCategoria).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idPagamentoClassificado",
							PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",
							PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * Sequencial do tipo lançamento igual a 700
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * parcelamento de serviço e grupo de parcelamento igual a juros cobrados
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "where dccg.categoria.id= :idCategoria "
					+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
					+ "where dbcb.financiamentoTipo.id = :idFinanciamentoTipo "
					+ " and dbcb.conta.id in( select distinct(pgmt.contaGeral.id) "
					+ "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and pgmt.localidade.id = :idLocalidade "
					+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
					+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
					+ "and pgmt.contaGeral.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.JUROS_PARCELAMENTO)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * Sequencial do tipo lançamento igual a 900
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos créditos realizados por localidade, categoria e item
	 * contábil para os pagamentos classificados de contas, para origem de
	 * crédito igual a valores cobrados indevidamente.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 22/05/2006, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param referencia
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente(
			Integer idLocalidade, 
			Integer referencia,
			Integer idCategoria, 
			Integer idLancamentoItemContabil,
			Collection idsCreditosOrigem)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		try {
			StringBuilder consultaPagamento = new StringBuilder();
			consultaPagamento.append("SELECT distinct pgmt.cnta_id ")
			                 .append("FROM arrecadacao.pagamento pgmt ")
			                 .append("WHERE pgmt.pgmt_amreferenciaarrecadacao = :referencia ")
			                 .append("and pgmt.loca_id= :idLocalidade ")
			                 .append("and (pgmt.pgst_idatual = :classificado or (pgmt.pgst_idatual= :valorABaixar and pgmt.pgst_idanterior = :valorNaoConfere ) ) ")
			                 .append("and pgmt.cnta_id is not null ");
			
			StringBuilder consultaCredito = new StringBuilder();
			consultaCredito.append("SELECT crrz.crrz_id ")
						   .append("FROM faturamento.credito_realizado crrz ")
						   .append("WHERE crrz.lict_id = :idLancamentoItemContabil ")
						   .append("and crrz.crog_id in (:idsCreditosOrigem) ")
						   .append("and crrz.cnta_id in ( ")
						   .append(consultaPagamento.toString())
						   .append(" ) ");
			
			StringBuilder consulta = new StringBuilder();
			consulta.append("SELECT sum(crcg.crcg_vlcategoria) as col_0 ")
			   		.append("FROM faturamento.cred_realizado_catg crcg ")
			   		.append("WHERE crcg.catg_id = :idCategoria ")
			   		.append("and crcg.crrz_id in ( ")
			   		.append(consultaCredito.toString())
			   		.append(" ) ");
			   
			retorno = (BigDecimal) session.createSQLQuery(consulta.toString())
			        .addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setParameterList("idsCreditosOrigem", idsCreditosOrigem)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("referencia", referencia)
					.setInteger("classificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("valorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("valorNaoConfere",PagamentoSituacao.VALOR_NAO_CONFERE)
					.setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1000
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos créditos realizados por localidade e categoria para
	 * os pagamentos classificados de contas, para origem de crédito igual a
	 * descontos concedidos.
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer[] idsCreditosOrigem)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			
			consulta = "select " +
					  "sum(crcg.crcg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.cred_realizado_catg crcg " + 
					  "where " +
					   "crcg.catg_id=:idCategoria  " +
					   "and (crcg.crrz_id in ( " +
					 				"select " +
					 				"crrz.crrz_id " + 
					 				"from " +
					 				"faturamento.credito_realizado crrz " + 
					 				"where " +
					 				"crrz.crog_id in (:idsCreditosOrigem)  " +
					 				"and (crrz.cnta_id in (" +
											 				"select " +
											 				"distinct pgmt.cnta_id " + 
											 				"from " +
											 				"arrecadacao.pagamento pgmt " + 
											 				"where " +
											 				"pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
											 				"and pgmt.loca_id= :idLocalidade  " +
											 				"and (pgmt.pgst_idatual= :idPagamentoClassificado or ( " +
											 				"pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior= :idPagamentoValorNaoConfere)) " + 
											 				"and (pgmt.cnta_id is not null) " +			
					 				")) " +
					 			") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setParameterList("idsCreditosOrigem",idsCreditosOrigem)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idPagamentoValorNaoConfere",PagamentoSituacao.VALOR_NAO_CONFERE)
					.setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Sequencial do tipo lançamento igual a 1700
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor da entrada do parcelamento por localidade e categoria dos
	 * pagamentos classificados de guias de pagamento com tipo de financiamento
	 * igual a entrada de parcelamento
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 22/05/2006, 22/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoEntradaParcelamento(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(gpcg.gpcg_vlcategoria) as col_0 " +
					  "from " +
					   "faturamento.guia_pagamento_categoria gpcg " + 
					  "where " +
					   "gpcg.catg_id=:idCategoria  " +
					   "and (gpcg.gpag_id in ( " +
					 				"select " +
					 				"gpag.gpag_id " + 
					 				"from " +
					 				"faturamento.guia_pagamento gpag " + 
					 				"where " +
					 				"gpag.fntp_id=:idFinanciamentoTipo  " +
					 				"and (gpag.gpag_id in (" +
											 				"select " +
											 				"distinct pgmt.gpag_id as col_0 " + 
											 				"from " +
											 				"arrecadacao.pagamento pgmt " + 
											 				"where " +
											 				"pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
											 				"and pgmt.loca_id= :idLocalidade  " +
											 				"and (pgmt.pgst_idatual= :idPagamentoClassificado or ( " +
											 				"pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior= :idPagamentoValorNaoConfere ) ) " + 
											 				"and (pgmt.gpag_id is not null) " +
					 				")) " +
					 			") " +
					   ")";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.ENTRADA_PARCELAMENTO)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idPagamentoValorNaoConfere",PagamentoSituacao.VALOR_NAO_CONFERE)
					.setMaxResults(1)
					.uniqueResult();

		
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1800
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor da guia de pagamento por localidade, categoria e item
	 * contábil dos pagamentos classificados de guias de pagamento com tipo de
	 * financiamento igual a serviço
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 22/05/2006, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(gpcg.gpcg_vlcategoria) as col_0  " +
					  "from " +
					   "faturamento.guia_pagamento_categoria gpcg  " +
					  "where " +
					   "gpcg.catg_id= :idCategoria  " +
					  " and (gpcg.gpag_id in ( " +
					 				"select " +
					 				"gpag.gpag_id  " +
					 				"from " +
					 				"faturamento.guia_pagamento gpag  " +
					 				"where " +
					 				"gpag.lict_id= :idLancamentoItemContabil  " +
					 				"and gpag.fntp_id != :idFinanciamentoTipo  " +
					 				"and (gpag.gpag_id in (" +
					 				
										 				"select " +
										 				"distinct pgmt.gpag_id as col_0 " + 
										 				"from " +
										 				"arrecadacao.pagamento pgmt " + 
										 				"where " +
										 				"pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
										 				"and pgmt.loca_id= :idLocalidade  " +
										 				"and (pgmt.pgst_idatual= :idPagamentoClassificado or ( " +
										 				"pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior= :idPagamentoValorNaoConfere ) ) " + 
										 				"and (pgmt.gpag_id is not null) " +
					 				
					 				")) " +
					 				") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.ENTRADA_PARCELAMENTO)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idPagamentoValorNaoConfere",PagamentoSituacao.VALOR_NAO_CONFERE)
					.setMaxResults(1)
					.uniqueResult();

		
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1900
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor que falta ser cobrado dos débitos a cobrar dos pagamentos
	 * classificados de débito a cobrar por localidade, categoria e item
	 * contábil
	 * 
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 23/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria,
			boolean incluirFinanciamentos)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {
			
			consulta = "select " +
					  "sum(dbcg.dbcg_vlcategoria-(trunc(dbcg.dbcg_vlcategoria/dbac.dbac_nnprestacaodebito, 2) * (dbac.dbac_nnprestacaocobradas + coalesce(dbac.dbac_nnparcelabonus,0)))) as col_0 " + 
					  "from " +
					   "faturamento.deb_a_cobrar_catg dbcg  " +
					  "inner join " +
					   "faturamento.debito_a_cobrar dbac on dbcg.dbac_id=dbac.dbac_id  " +
					  "where " +
					   "dbcg.dbac_id=dbac.dbac_id  " +
					   "and dbac.lict_id= :idLancamentoItemContabil " +
					   "and dbac.loca_id= :idLocalidade  " +
					   "and dbcg.catg_id= :idCategoria  " +
					   "and (dbac.dbac_id in (" +
										   "select " +
										   "distinct pgmt.dbac_id " + 
										   "from " +
										   "arrecadacao.pagamento pgmt " + 
										   "where " +
										   "pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
										   "and pgmt.loca_id= :idLocalidade  " +
										   "and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										   "and (pgmt.dbac_id is not null) " +
					   ")) ";
					   
			
			if (incluirFinanciamentos) {
				consulta += "and dbac.fntp_id != :idFinanciamentoNormal";
			} else {
				consulta += "and dbac.fntp_id = :idFinanciamentoNormal";
			}

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idFinanciamentoNormal",FinanciamentoTipo.SERVICO_NORMAL)
					.setMaxResults(1)
					.uniqueResult();


			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 2600
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções classificadas para acumular o valor da devolução
	 * por categoria com situação igual a devolução classificada.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 25/05/2006, 21/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesClassificadasSituacaoAtualDevolucaoClassificada(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " + 
					 "from " +
					  "arrecadacao.devolucao devl  " +
					 "left outer join arrecadacao.devolucao_situacao dvst on devl.dvst_idatual=dvst.dvst_id " + 
					 "where " +
					  "devl.devl_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
					  "and dvst.dvst_id= :idDevolucaoSituacaoAtual " +
					  "and devl.loca_id= :idLocalidade " +
					  " and devl.dotp_idagregador is null " + 
					  "group by devl.imov_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1",Hibernate.INTEGER)
			 		.setInteger("idLocalidade",idLocalidade)
			 		.setInteger("idDevolucaoSituacaoAtual",DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA)
			 		.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();			
			
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 2440
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções do tipo descontos por pagamento a vista
	 * 
	 * @author Francisco do Nascimento
	 * @date 03/12/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesDescontosPagamentoAVista(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " + 
					 "from " +
					  "arrecadacao.devolucao devl  " +
					 "where " +
					  "devl.devl_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
					  "and devl.loca_id= :idLocalidade " +
					  " and devl.dotp_idagregador is not null " +
					  " and devl.crar_id is null " +
					  "group by devl.imov_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1",Hibernate.INTEGER)
			 		.setInteger("idLocalidade",idLocalidade)
			 		.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();			
			
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Sequencial do tipo lançamento igual a 2440
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções do tipo descontos por credito
	 * 
	 * @author Francisco do Nascimento
	 * @date 04/12/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesDescontosCreditos(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " + 
					 "from " +
					  "arrecadacao.devolucao devl  " +
					 "where " +
					  "devl.devl_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
					  "and devl.loca_id= :idLocalidade " +
					  " and devl.dotp_idagregador is not null " +
					  " and devl.crar_id is not null " +
					  "group by devl.imov_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1",Hibernate.INTEGER)
			 		.setInteger("idLocalidade",idLocalidade)
			 		.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();			
			
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 2700
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções classificadas para acumular o valor da devolução
	 * por categoria e item contábil com situação igual a devolução de outros
	 * valores.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 25/05/2006, 21/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {
			
			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " + 
					 "from " +
					  "arrecadacao.devolucao devl  " +
					 "left outer join arrecadacao.devolucao_situacao dvst on devl.dvst_idatual=dvst.dvst_id " + 
					 "inner join faturamento.debito_tipo dbtp on devl.dbtp_id=dbtp.dbtp_id  " +
					 "inner join financeiro.lancamento_item_contabil lict on dbtp.lict_id=lict.lict_id " + 
					 "where " +
					 "devl.loca_id= :idLocalidade " +
					 "and devl.devl_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
					 "and dvst.dvst_id= :idDevolucaoSituacaoAtual  " +
					 "and lict.lict_id= :idLancamentoItemContabil " +
					 " and devl.dotp_idagregador is null " +
					 "group by devl.imov_id";

			retorno = session.createSQLQuery(consulta)
			 		.addScalar("col_0",Hibernate.BIG_DECIMAL)
			 		.addScalar("col_1",Hibernate.INTEGER)
					.setInteger("idDevolucaoSituacaoAtual",DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLancamentoItemContabil",idLancamentoItemContabil)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3500
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor de água por localidade e categoria para os pagamentos de
	 * contas efetuados em meses anteriores classificados no mês.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(ctcg.ctcg_vlagua) as col_0  " +
					  "from " +
					   "faturamento.conta_categoria ctcg " + 
					  "where " +
					   "ctcg.catg_id= :idCategoria  " +
					   "and (ctcg.cnta_id in ( " +
					 			"select " +
					 			"distinct pgmt.cnta_id " + 
					 			"from " +
					 			"arrecadacao.pagamento pgmt " + 
					 			"where " +
					 			"pgmt.pgmt_amreferenciaarrecadacao< :anoMesReferenciaArrecadacao " + 
					 			"and pgmt.loca_id= :idLocalidade  " +
					 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
					 			"and (pgmt.cnta_id is not null) " +
					 			") " +
					   ")";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
			 		.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3600
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor de esgoto por localidade e categoria para os pagamentos
	 * de contas efetuados em meses anteriores classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes(
			Integer idLocalidade, Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select sum(ctcg.valorEsgoto) "
					+ "from ContaCategoria ctcg "
					+ "where ctcg.comp_id.categoria.id= :idCategoria "
					+ " and ctcg.comp_id.conta.id in ( select distinct(pgmt.contaGeral.id) "
					+ "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
					+ "and pgmt.localidade.id = :idLocalidade "
					+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
					+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
					+ "and pgmt.contaGeral.id is not null " + ") ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"idCategoria", idCategoria).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).setInteger(
							"idPagamentoClassificado",
							PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",
							PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4100
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual a parcelamento de
	 * serviço e grupo de parcelamento igual a juros cobrados.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "where dccg.categoria.id= :idCategoria "
					+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
					+ "where dbcb.financiamentoTipo.id = :idFinanciamentoTipo "
					+ " and dbcb.conta.id in( select distinct(pgmt.contaGeral.id) "
					+ "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
					+ "and pgmt.localidade.id = :idLocalidade "
					+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
					+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
					+ "and pgmt.contaGeral.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta)
			.setInteger("idCategoria", idCategoria)
			.setInteger("idFinanciamentoTipo",FinanciamentoTipo.JUROS_PARCELAMENTO)
			.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
			.setInteger("idLocalidade", idLocalidade)
			.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
			.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
			.setMaxResults(1)
			.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * Sequencial do tipo lançamento igual a 4300
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos créditos realizados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês, para origem do crédito igual a valores cobrados
	 * indevidamente.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 26/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idLancamentoItemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Coleção de crédito origem de valores cobrados indevidamente
		Collection idsCreditosOrigem = new ArrayList();
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_AGUA);
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO);
		idsCreditosOrigem.add(CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE);
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO);

		// cria a variável que vai conter o hql
		String consulta = "";

		try {
			
			consulta = "select " +
					  "sum(crcg.crcg_vlcategoria) as col_0  " +
					  "from " +
					   "faturamento.cred_realizado_catg crcg  " +
					  "where " +
					   "crcg.catg_id= :idCategoria  " +
					   "and (crcg.crrz_id in ( " +
					 			"select " +
					 			"crrz.crrz_id  " +
					 			"from " +
					 			"faturamento.credito_realizado crrz  " +
					 			"where " +
					 			"crrz.lict_id= :idLancamentoItemContabil  " +
					 			"and (crrz.crog_id in (:idsCreditosOrigem))  " +
					 			"and (crrz.cnta_id in (" +
										 			"select " +
										 			"distinct pgmt.cnta_id " + 
										 			"from " +
										 			"arrecadacao.pagamento pgmt " + 
										 			"where " +
										 			"pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
										 			"and pgmt.loca_id= :idLocalidade  " +
										 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 			"and (pgmt.cnta_id is not null) "	+		
					 			")) " +
					 			") " +
					  ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setParameterList("idsCreditosOrigem", idsCreditosOrigem)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * Sequencial do tipo lançamento igual a 5100
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor das entrads do parcelamento por localidade e categoria
	 * dos pagamento de guias de pagamento efetuados em meses anteriores
	 * classificados no mês com tipo de financiamento igual a entrada de
	 * parcelamento.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(gpcg.gpcg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.guia_pagamento_categoria gpcg " + 
					  "where " +
					   "gpcg.catg_id= :idCategoria  " +
					   "and (gpcg.gpag_id in ( " +
					 			"select " +
					 			"gpag.gpag_id " + 
					 			"from " +
					 			"faturamento.guia_pagamento gpag " + 
					 			"where " +
					 			"gpag.fntp_id= :idFinanciamentoTipo  " +
					 			"and (gpag.gpag_id in (" +
										 			"select " +
										 			"distinct pgmt.gpag_id as col_0 " + 
										 			"from " +
										 			"arrecadacao.pagamento pgmt " + 
										 			"where " +
										 			"pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao  < :anoMesReferenciaArrecadacao " + 
										 			"and pgmt.loca_id= :idLocalidade  " +
										 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 			"and (pgmt.gpag_id is not null) " +
					 			")) " +
					 			") " +
					   ")";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.ENTRADA_PARCELAMENTO)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

	
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 5200
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor das entrads do parcelamento por localidade, categoria e
	 * item contábil dos pagamento de guias de pagamento efetuados em meses
	 * anteriores classificados no mês com tipo de financiamento igual a
	 * serviço.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 26/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta  = "select " +
					  "sum(gpcg.gpcg_vlcategoria) as col_0  " +
					  "from " +
					   "faturamento.guia_pagamento_categoria gpcg  " +
					  "where " +
					   "gpcg.catg_id= :idCategoria  " +
					   "and (gpcg.gpag_id in (  " +   
					 			"select " +
					 			"gpag.gpag_id  " +
					 			"from " +
					 			"faturamento.guia_pagamento gpag  " +
					 			"where " +
					 			"gpag.lict_id= :idLancamentoItemContabil  " +
					 			"and gpag.fntp_id= :idFinanciamentoTipo  " +
					 			"and (gpag.gpag_id in (" +
										 			"select " +
										 			"distinct pgmt.gpag_id as col_0 " + 
										 			"from " +
										 			"arrecadacao.pagamento pgmt " + 
										 			"where " +
										 			"pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
										 			"and pgmt.loca_id= :idLocalidade  " +
										 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 			"and (pgmt.gpag_id is not null) " +
					 			"))    " +  
					 			") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.SERVICO_NORMAL)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.uniqueResult();
			
			
			
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 5300
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor que falta ser cobrado dos débitos a cobrar por
	 * localidade, categoria e item contábil para os pagamentos de débitos a
	 * cobrar efetuados em meses anteriores classificados no mês.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 26/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(dbcg.dbcg_vlcategoria-(trunc(dbcg.dbcg_vlcategoria/dbac.dbac_nnprestacaodebito,2)*dbac.dbac_nnprestacaocobradas)) as col_0 " +
					  "from " +
					   "faturamento.deb_a_cobrar_catg dbcg  " +
					  "inner join  faturamento.debito_a_cobrar dbac on dbcg.dbac_id=dbac.dbac_id  " +
					  "where " +
					   "dbcg.dbac_id=dbac.dbac_id  " +
					   "and dbac.lict_id=:idLancamentoItemContabil  " +
					   "and dbac.loca_id= :idLocalidade  " +
					   "and dbcg.catg_id=:idCategoria  " +
					   "and (dbac.dbac_id in (" +
										   "select " +
										   "distinct pgmt.dbac_id as col_0 " + 
										   "from " +
										   "arrecadacao.pagamento pgmt " + 
										   "where " +
										   "pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
										   "and pgmt.loca_id= :idLocalidade  " +
										   "and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										   "and (pgmt.dbac_id is not null) " +
					   ")) " ;

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 5500
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções efetuadas em meses anteriores classificadas no mês
	 * para acumular o valor da devolução por localidade e categoria com
	 * situação atual igual a devolução classificada.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 30/05/2006, 22/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {
			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " +
					 "from " +
					  "arrecadacao.devolucao devl " + 
					 "where " +
					  "devl.devl_amreferenciaarrecadacao< :anoMesReferenciaArrecadacao " +
					  "and devl.dvst_idatual= :idDevolucaoSituacaoAtual " + 
					  "and devl.loca_id= :idLocalidade " +
					  "group by devl.imov_id";

			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1",Hibernate.INTEGER)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idDevolucaoSituacaoAtual",DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA)
					.setInteger("idLocalidade", idLocalidade)
					.list();
			
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 5600
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções efetuadas em meses anteriores classificadas no mês
	 * para acumular o valor da devolução por localidade, categoria e item
	 * contábil, com situação atual igual a devolução de outros valores.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 31/05/2006, 21/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade,
			Integer idLancamentoItemContabil) throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " + 
					 "from " +
					  "arrecadacao.devolucao devl  " +
					 "left outer join arrecadacao.devolucao_situacao dvst on devl.dvst_idatual=dvst.dvst_id " + 
					 "inner join faturamento.debito_tipo dbtp on devl.dbtp_id=dbtp.dbtp_id  " +
					 "inner join financeiro.lancamento_item_contabil lict on dbtp.lict_id=lict.lict_id " + 
					 "where " +
					  "devl.devl_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
					  "and dvst.dvst_id= :idDevolucaoSituacaoAtual  " +
					  "and devl.loca_id= :idLocalidade " +
					  "and lict.lict_id=:idLancamentoItemContabil " +
					  "group by devl.imov_id";

			retorno = session.createSQLQuery(consulta)
			        .addScalar("col_0",Hibernate.BIG_DECIMAL)
			        .addScalar("col_1",Hibernate.INTEGER)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idDevolucaoSituacaoAtual",DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idLancamentoItemContabil",idLancamentoItemContabil)
					.list();			
			
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 6200 (SOMA DOS SEQ.100,200,3500 e
	 * 3600)
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Este metódo acumular os valores dos sequencias : 100, 200, 3500 e
	 * 3600,para ser acumuldo á soma dos recebimentos de valores contabilizados
	 * como perdas.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 02/06/2006, 26/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorAgua_EsgotoPagamentosClassificadosNoMes_EfetuadosEmMesesAnterioresContaContabilizadasComoPerdas(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select sum(coalesce(ctcg.ctcg_vlagua,0) + coalesce(ctcg.ctcg_vlesgoto,0)) as col_0 "+ 
					  "from " +
					   "faturamento.conta_categoria ctcg  " +
					  "where " +
					   "ctcg.catg_id= :idCategoria  " +
					   "and (ctcg.cnta_id in ( " +
					 			"select " +
					 			"distinct pgmt.cnta_id  " +
					 			"from " +
					 			"arrecadacao.pagamento pgmt			 " +	
					 			"inner join faturamento.conta cnta on pgmt.cnta_id=cnta.cnta_id  " +
					 			"where		 " +		
					 			"pgmt.pgmt_amreferenciaarrecadacao<= :anoMesReferenciaArrecadacao  " +
					 			"and pgmt.loca_id= :idLocalidade  " +
					 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idValorABaixar)  " +
					 			"and (pgmt.cnta_id is not null) " + 
					 			"and (cnta.cnta_amreferenciabaixacontabil is not null) " + 				
					 			") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
					.uniqueResult();
			
	
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 6200 (SOMA DOS SEQ.
	 * 300,400,500,600,700,3700,3800,3900,4000 e 4100)
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Este metódo acumular os valores dos sequencias : 300, 400, 500, 600, 700,
	 * 3700, 3800, 3900, 4000 e 4100,para ser acumulado á soma dos recebimentos
	 * de valores contabilizados como perdas.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 02/06/2006, 26/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosNoMes_EfetuadosEmMesesAnterioresContaContabilizadaComoPerdasFinanciamentoTipoServico_ParcelamentoAgua_ParcelamentoEsgoto_ParcelamentoServico(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		Collection<Integer> idsTipoFinanciamento = new ArrayList();
		idsTipoFinanciamento.add(FinanciamentoTipo.SERVICO_NORMAL);
		idsTipoFinanciamento.add(FinanciamentoTipo.PARCELAMENTO_AGUA);
		idsTipoFinanciamento.add(FinanciamentoTipo.PARCELAMENTO_ESGOTO);
		idsTipoFinanciamento.add(FinanciamentoTipo.PARCELAMENTO_SERVICO);
		
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(dccg.dccg_vlcategoria) as col_0  " +
					  "from " +
					   "faturamento.debito_cobrado_categoria dccg  " +
					  "where " +
					   "dccg.catg_id= :idCategoria  " +
					   "and (dccg.dbcb_id in ( " +
					 			"select " +
					 			"dbcb.dbcb_id  " +
					 			"from " +
					 			"faturamento.debito_cobrado dbcb  " +
					 			"where " +
					 			"(dbcb.fntp_id in (:idsTipoFinanciamento))  " +
					 			"and (dbcb.cnta_id in ( " +
					 						"select " +
					 						"distinct pgmt.cnta_id  " +
					 						"from " +
					 						"arrecadacao.pagamento pgmt, " +
					 						"faturamento.conta cnta  " +
					 						"where " +
					 						"pgmt.cnta_id=cnta.cnta_id " +
					 						"and pgmt.pgmt_amreferenciaarrecadacao<= :anoMesReferenciaArrecadacao  " +
					 						"and pgmt.loca_id=:idLocalidade  " +
					 						"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual=:idValorABaixar)  " +
					 						"and (pgmt.cnta_id is not null)  " +
					 						"and (cnta.cnta_amreferenciabaixacontabil is not null) 	 " +							
					 						") " +
					 			") " +
					 		") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setParameterList("idsTipoFinanciamento", idsTipoFinanciamento)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

			
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 6200 (SOMA DOS
	 * SEQ.800,900,1000,4200,4300 e 4400)
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Este metódo acumular os valores dos sequencias : 800, 900, 1000, 4200,
	 * 4300 e 4400, para ser acumulado negativamente á soma dos recebimentos de
	 * valores contabilizados como perdas.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 02/06/2006, 26/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosClassificadosNoMes_EfetuadosMesesAnterioresContaContabilizadaComoPerdasOrigemCredito_ContasPagasEmDuplicidadeExcesso_ValoresCobradosIndevidamente_DescontosConcedidos(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		Collection<Integer> idsCreditoOrigem = new ArrayList();
		idsCreditoOrigem.add(CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO);
		idsCreditoOrigem.add(CreditoOrigem.VALORES_COBRADOS_INDEVIDAMENTE);
		idsCreditoOrigem.add(CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);
		/**
		 * Contabilizar créditos com crédito origem correspondente 
		 * a Contas Pagas em Excesso
		 * 
		 * @author Wellington Rocha
		 * @date */
		idsCreditoOrigem.add(CreditoOrigem.CONTAS_PAGAS_EM_EXCESSO);
		
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(crcg.crcg_vlcategoria) as col_0 " +
					  "from " +
					   "faturamento.cred_realizado_catg crcg " + 
					  "where " +
					   "crcg.catg_id= :idCategoria " +
					   "and (crcg.crrz_id in ( " +
					 			"select " +
					 			"crrz.crrz_id " + 
					 			"from " +
					 			"faturamento.credito_realizado crrz  " +
					 			"where(crrz.crog_id in (:idsCreditoOrigem)) " + 
					 			"and (crrz.cnta_id in ( " +
					 						"select " +
					 						"distinct pgmt.cnta_id " + 
					 						"from " +
					 						"arrecadacao.pagamento pgmt " +
					 						"inner join faturamento.conta cnta on pgmt.cnta_id=cnta.cnta_id " +
					 						"where " +
					 						"pgmt.pgmt_amreferenciaarrecadacao<= :anoMesReferenciaArrecadacao " + 
					 						"and pgmt.loca_id= :idLocalidade  " +
					 						"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
					 						"and (pgmt.cnta_id is not null)  " +
					 						"and (cnta.cnta_amreferenciabaixacontabil is not null) " +        
					 						") " +
					 				") " +
					 			") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setParameterList("idsCreditoOrigem", idsCreditoOrigem)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();


			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 6200 (SOMA DOS
	 * SEQ.1200,1300,1400,1500,4600,4700,4800 e 4900)
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Este metódo acumular os valores dos sequencias : 1200, 1300, 1400, 1500,
	 * 4600, 4700, 4800 e 4900, para ser acumulado negativamente á soma dos
	 * recebimentos de valores contabilizados como perdas.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 02/06/2006, 22/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {
			
			consulta = "select " +
					  "cnid.cnid_vlimposto as col_0, " +
					  "imov.imov_id as col_1 " + 
					 "from " +
					  "faturamento.conta_impostos_deduzidos cnid  " +
					 "inner join  faturamento.conta cnta on cnid.cnta_id=cnta.cnta_id  " +
					 "inner join  cadastro.imovel imov  on cnta.imov_id=imov.imov_id " + 
					 "where " +
					  "(cnid.imtp_id=:ir  " +
					   "or cnid.imtp_id=:csll  " +
					   "or cnid.imtp_id=:cofins  " +
					   "or cnid.imtp_id=:pispasep) " +
					  "and (cnta.cnta_id in (" +
											  "select " +
											  "distinct pgmt.cnta_id  " +
											  "from " +
											  "arrecadacao.pagamento pgmt, " +
											  "faturamento.conta cnta  " +
											  "where " +
											  "pgmt.cnta_id=cnta.cnta_id  " +
											  "and pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao  " +
											  "and pgmt.loca_id=:idLocalidade  " +
											  "and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual=:idValorABaixar)  " +
											  "and (pgmt.cnta_id is not null)  " +
											  "and (cnta.cnta_amreferenciabaixacontabil is not null) 	 " +	
					  ")) " +
					  "";
			
			retorno = session.createSQLQuery(consulta)
			 		.addScalar("col_0", Hibernate.BIG_DECIMAL)
			 		.addScalar("col_1", Hibernate.INTEGER)
					.setInteger("ir",ImpostoTipo.IR)
					.setInteger("csll",ImpostoTipo.CSLL)
					.setInteger("cofins",ImpostoTipo.COFINS)
					.setInteger("pispasep",ImpostoTipo.PIS_PASEP)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os débitos cobrados das contas dos pagamentos classificados de
	 * contas e dos pagamentos anteriores de conta classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 02/06/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoCobrado> pesquisarDebitosCobradosContasPagamentosClassificados_PagamentosAnterioresContaClassificadosNoMes(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<DebitoCobrado> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from DebitoCobrado dbcb "
					+ "where dbcb.conta.id in ("
					+ "select pgmt.contaGeral.id from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.contaGeral.id is not null "
					+ "order by pgmt.contaGeral.id)";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os créditos realizados das contas dos pagamentos classificados
	 * de contas e dos pagamentos anteriores de conta classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 02/06/2006
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CreditoRealizado> pesquisarCreditosRealizadosContasPagamentosClassificados_PagamentosAnterioresContaClassificadosNoMes(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<CreditoRealizado> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "from CreditoRealizado crrz "
					+ "where crrz.conta.id in ("
					+ "select pgmt.contaGeral.id from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.contaGeral.id is not null "
					+ "order by pgmt.contaGeral.id)";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Conta do Cliente
	 * pesquisarPagamentoClienteConta
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteConta(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal ) throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoCliente(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal );

			// hql = " select distinct pagamento "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + " inner join pagamento.conta as conta "
			// + " inner join conta.clienteContas as clienteContas "
			// + " left join clienteContas.clienteRelacaoTipo as
			// clienteRelacaoTipo "
			// + condicionais
			// + " order by pagamento.localidade.id, pagamento.imovel.id, "
			// + " pagamento.anoMesReferenciaPagamento, pagamento.dataPagamento
			// "
			// + " ";

			hql = " select c.pgmt_id as idPagamento, i.cnta_id as idConta, i.cnta_amreferenciaconta as anoMesConta, i.cnta_vlagua as valorAguaConta, "
					+ " i.cnta_vlesgoto as valorEsgotoConta, i.cnta_vldebitos as valorDebitosConta, i.cnta_vlcreditos as valorCreditosConta, "
					+ " c.pgmt_dtpagamento as dataPagamento, c.pgmt_amreferenciapagamento as anoMesPagamento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " k.pgst_id as idSituacaoPagamentoAnterior, k.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, c.imov_id as idImovel "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " faturamento.conta i "
					+ "  on i.cnta_id = c.cnta_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_conta b "
					+ " on b.cnta_id = c.cnta_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao k "
					+ "  on c.pgst_idanterior = k.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " order by c.loca_id, c.imov_id, c.pgmt_amreferenciapagamento, c.pgmt_dtpagamento ";

			// colecaoPagamento = session.createQuery(hql).list();

			retorno = session
					.createSQLQuery(hql)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("valorAguaConta", Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgotoConta", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitosConta", Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditosConta", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("anoMesPagamento", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAtual", Hibernate.STRING)
					.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAnterior", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar(
							"idImovel", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Guia de Pagamento do Cliente
	 * pesquisarPagamentoClienteGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteGuiaPagamento(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 2. O sistema seleciona os pagamentos de guia de pagamento do
			// cliente informado (a partir da tabela
			// PAGAMENTO com CLIE_ID = Id do cliente informado ou com GPAG_ID =
			// GPAG_ID da tabela
			// CLIENTE_GUIA_PAGAMENTO com CLIE_ID = Id do cliente informado e
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoCliente(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = " SELECT c.pgmt_id as idPagamento, b1.gpag_id as idGuiaPagamento, c.clie_id as idCliente, b1.gpag_vldebito as valorGuia, "
					+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoGuia, k.dbtp_dsdebitotipo as tipoDebitoGuia, "
					+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
					+ " c.imov_id as idImovel, c.loca_id as idLocalidade "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " faturamento.guia_pagamento b1 "
					+ "  on b1.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_guia_pagamento b "
					+ " on b.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " faturamento.debito_tipo k "
					+ " on b1.dbtp_id = k.dbtp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " union "
					+ " SELECT c.pgmt_id as idPagamento, b1.gpag_id as idGuiaPagamento, c.clie_id as idCliente, b1.gpag_vldebito as valorGuia, "
					+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoGuia, k.dbtp_dsdebitotipo as tipoDebitoGuia, "
					+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
					+ " c.imov_id as idImovel, c.loca_id as idLocalidade "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " faturamento.guia_pagamento b1 "
					+ "  on b1.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_guia_pagamento b "
					+ " on b.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " faturamento.debito_tipo k "
					+ " on b1.dbtp_id = k.dbtp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " union "
					+ " SELECT c.pgmt_id as idPagamento, b.gpag_id as idGuiaPagamento, c.clie_id as idCliente, b.gpag_vldebito as valorGuia, "
					+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoGuia, k.dbtp_dsdebitotipo as tipoDebitoGuia, "
					+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
					+ " c.imov_id as idImovel, c.loca_id as idLocalidade "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = c.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.guia_pagamento b "
					+ "  on b.gpag_id = c.gpag_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo k "
					+ " on b.dbtp_id = k.dbtp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id " + " WHERE ";

			idTipoRelacao = null;

			String condicionaisClientePagamento = this
					.criarCondicionaisPagamentoCliente(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			hql = hql
					+ condicionaisClientePagamento
					+ " order by idLocalidade, idImovel, idTipoDebitoPagamento, dataPagamento ";

			// hql = " select distinct pagamento "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + " inner join pagamento.guiaPagamento as guiaPagamento "
			// + " left join guiaPagamento.cliente as cliente "
			// + " left join cliente.clienteImoveis as clienteImoveis "
			// + " left join clienteImoveis.clienteRelacaoTipo as
			// clienteRelacaoTipo "
			// + condicionais
			// + " order by pagamento.localidade.id, pagamento.imovel.id, "
			// + " pagamento.debitoTipo.id, pagamento.dataPagamento "
			// + " ";

			retorno = session
					.createSQLQuery(hql)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("idGuiaPagamento", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("valorGuia", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("anoMesPagamento", Hibernate.INTEGER)
					.addScalar("idTipoDebitoGuia", Hibernate.INTEGER)
					.addScalar("tipoDebitoGuia", Hibernate.STRING)
					.addScalar("idTipoDebitoPagamento", Hibernate.INTEGER)
					.addScalar("tipoDebitoPagamento", Hibernate.STRING)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAtual", Hibernate.STRING)
					.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAnterior", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar(
							"idImovel", Hibernate.INTEGER).addScalar(
							"idLocalidade", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoClienteDebitoACobrar
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteDebitoACobrar(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoCliente(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.dbac_id as idDebitoACobrar, "
					+ " b1.dbac_vldebito as valorDebito, b1.dbac_nnprestacaocobradas as numeroPrestacaoCobradas, "
					+ " b1.dbac_nnprestacaodebito as numeroPrestacaoDebito,  c.pgmt_dtpagamento as dataPagamento, "
					+ " c.pgmt_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoDebito, k.dbtp_dsdebitotipo as tipoDebitoDebito, "
					+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, c.pgmt_vlpagamento as valorPagamento, "
					+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, j.pgst_id as idSituacaoPagamentoAnterior, "
					+ " j.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, b1.imov_id as idImovelDebito," +
                      " c.loca_id as idLocalidade, b1.dbac_nnparcelabonus as numeroParcelaBonus  "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " faturamento.debito_a_cobrar b1 "
					+ "  on b1.dbac_id = c.dbac_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_imovel b "
					+ " on b.imov_id = b1.imov_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " faturamento.debito_tipo k "
					+ "  on b1.dbtp_id = k.dbtp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " order by idLocalidade, idImovel, idTipoDebitoPagamento, dataPagamento ";

			retorno = session
					.createSQLQuery(hql)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idDebitoACobrar", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("numeroPrestacaoCobradas", Hibernate.SHORT)
					.addScalar("numeroPrestacaoDebito", Hibernate.SHORT)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("anoMesPagamento", Hibernate.INTEGER)
					.addScalar("idTipoDebitoDebito", Hibernate.INTEGER)
					.addScalar("tipoDebitoDebito", Hibernate.STRING)
					.addScalar("idTipoDebitoPagamento", Hibernate.INTEGER)
					.addScalar("tipoDebitoPagamento", Hibernate.STRING)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAtual", Hibernate.STRING)
					.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAnterior", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar(
							"idImovelDebito", Hibernate.INTEGER).addScalar(
							"idLocalidade", Hibernate.INTEGER).
                            addScalar("numeroParcelaBonus",Hibernate.SHORT).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoLocalidade(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, Integer numeroPagina, 
            String valorPagamentoInicial, 
            String valorPagamentoFinal)
			throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial, 
                    valorPagamentoFinal);
            
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamento "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ " INNER JOIN FETCH pagamento.avisoBancario avbc "
					+ " INNER JOIN FETCH avbc.arrecadador arrec "
					+ " INNER JOIN FETCH arrec.cliente cliArrec "
					+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.conta conta "
					+ " LEFT JOIN FETCH pagamento.imovel imov "
					+ " LEFT JOIN FETCH imov.localidade locImov "
					+ " LEFT JOIN FETCH imov.setorComercial setComImov "
					+ " LEFT JOIN FETCH imov.quadra quadra "
					+ " LEFT JOIN FETCH pagamento.localidade loc "
					+ " LEFT JOIN FETCH loc.gerenciaRegional gr "
					+ " LEFT JOIN FETCH pagamento.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamento.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ condicionais + " ";

			// olecaoPagamento = session.createQuery(hql).list();

			retorno = session.createQuery(hql)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancario(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos, 
            String valorPagamentoInicial, 
            String valorPagamentoFinal)
			throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamento "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ " INNER JOIN FETCH pagamento.avisoBancario as avisoBancario "
					+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.conta conta "
					+ " LEFT JOIN FETCH pagamento.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamento.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ condicionais + " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadador(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos, 
            String valorPagamentoInicial, 
            String valorPagamentoFinal )
			throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial, 
                    valorPagamentoFinal );
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamento "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ " INNER JOIN FETCH pagamento.arrecadadorMovimentoItem as arrecadadorMovimentoItem "
					+ " INNER JOIN FETCH arrecadadorMovimentoItem.arrecadadorMovimento as arrecadadorMovimento "
					+ " INNER JOIN FETCH pagamento.avisoBancario avbc "
					+ " INNER JOIN FETCH avbc.arrecadador arrec "
					+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.conta conta "
					+ " LEFT JOIN FETCH pagamento.debitoTipo dbtpPagto "
					+ " LEFT JOIN FETCH pagamento.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamento.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamento.arrecadacaoForma arrecForma "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ " LEFT JOIN FETCH pagamento.cliente cli "
					+ condicionais
					+ " order by pagamento.localidade.id, pagamento.imovel.id, "
					+ " pagamento.debitoTipo.id, pagamento.dataPagamento "
					+ " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadadorParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina, String valorPagamentoInicial, 
            String valorPagamentoFinal ) throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal);
            
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamento "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ " INNER JOIN FETCH pagamento.arrecadadorMovimentoItem as arrecadadorMovimentoItem "
					+ " INNER JOIN FETCH arrecadadorMovimentoItem.arrecadadorMovimento as arrecadadorMovimento "
					+ " INNER JOIN FETCH pagamento.avisoBancario avbc "
					+ " INNER JOIN FETCH avbc.arrecadador arrec "
					+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.conta conta "
					+ " LEFT JOIN FETCH pagamento.debitoTipo dbtpPagto "
					+ " LEFT JOIN FETCH pagamento.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamento.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamento.arrecadacaoForma arrecForma "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ " LEFT JOIN FETCH pagamento.cliente cli "
					+ condicionais
					+ " order by pagamento.localidade.id, pagamento.imovel.id, "
					+ " pagamento.debitoTipo.id, pagamento.dataPagamento "
					+ " ";

			retorno = session.createQuery(hql)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * 
	 * @param idImovel
	 * @param idCliente
	 * @param idTipoRelacao
	 * @param localidadeInicial
	 * @param localidadeFinal
	 * @param idAvisoBancario
	 * @param idArrecadador
	 * @param periodoArrecadacaoInicial
	 * @param periodoArrecadacaoFinal
	 * @param periodoPagamentoInicio
	 * @param periodoPagamentoFim
	 * @param dataPagamentoInicial
	 * @param dataPagamentoFinal
	 * @param idsPagamentosSituacoes
	 * @param idsDebitosTipos
	 * @param idsArrecadacaoForma
	 * @param idsDocumentosTipos
	 * @return
	 */
	public String criarCondicionaisPagamento(String idImovel, String idCliente,
			String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal) {

		String sql = " where ";
		if (idImovel != null && !idImovel.equals("")) {
			sql = sql + " pagamento.imovel.id = " + idImovel + " and ";
		}
		if (idCliente != null && !idCliente.equals("")) {
			// sql = sql + " clienteContas.cliente.id = " + idCliente + " and "
			// ;
			sql = sql + " pagamento.cliente.id = " + idCliente + " and ";
		}
		if (idTipoRelacao != null && !idTipoRelacao.equals("")) {
			sql = sql + " clienteRelacaoTipo.id = " + idTipoRelacao + " and ";
		}
		if (localidadeInicial != null && localidadeFinal != null
				&& !localidadeInicial.equals("") && !localidadeFinal.equals("")) {
			sql = sql + " pagamento.localidade.id >= " + localidadeInicial
					+ " and ";
			sql = sql + " pagamento.localidade.id <= " + localidadeFinal
					+ " and ";
		}
		if (idAvisoBancario != null && !idAvisoBancario.equals("")) {
			sql = sql + " pagamento.avisoBancario.id = " + idAvisoBancario
					+ " and ";
		}
		if (idArrecadador != null && !idArrecadador.equals("")) {
			sql = sql + " pagamento.arrecadadorMovimentoItem.arrecadadorMovimento.id = " + idArrecadador + " and ";
		}
		if (periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoInicial.equals("")) {
			sql = sql
					+ " pagamento.anoMesReferenciaArrecadacao >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
					+ " and ";
		}
		if (periodoArrecadacaoFinal != null
				&& !periodoArrecadacaoFinal.equals("")) {
			sql = sql
					+ " pagamento.anoMesReferenciaArrecadacao <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal)
					+ " and ";
		}
		if (periodoPagamentoInicio != null
				&& !periodoPagamentoInicio.equals("")) {
			sql = sql
					+ " pagamento.anoMesReferenciaPagamento >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
					+ " and ";
		}
		if (periodoPagamentoFim != null && !periodoPagamentoFim.equals("")) {
			sql = sql
					+ " pagamento.anoMesReferenciaPagamento <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim)
					+ " and ";
		}

		if (dataPagamentoInicial != null && !dataPagamentoInicial.equals("")) {
			// sql = sql + " pagamento.dataPagamento >= '" +
			// Util.formatarData(dataPagamentoInicial) + "' and " ;
			String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

			if (data1 != null && !data1.equals("")
					&& data1.trim().length() == 8) {

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6)
						+ "-" + data1.substring(6, 8);
			}
			sql = sql + " pagamento.dataPagamento >= to_date('" + data1 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}
		if (dataPagamentoFinal != null && !dataPagamentoFinal.equals("")) {
			// sql = sql + " pagamento.dataPagamento <= '" +
			// Util.formatarData(dataPagamentoFinal) + "' and " ;
			String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

			if (data2 != null && !data2.equals("")
					&& data2.trim().length() == 8) {

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6)
						+ "-" + data2.substring(6, 8);
			}
			sql = sql + " pagamento.dataPagamento <= to_date('" + data2 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}

		if (idsPagamentosSituacoes != null
				&& !idsPagamentosSituacoes.equals("")) {
			String valoresIn = "";
			for (int i = 0; i < idsPagamentosSituacoes.length; i++) {
				if (!idsPagamentosSituacoes[i].equals("")) {
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " pagamento.pagamentoSituacaoAtual.id in ("
						+ valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDebitosTipos != null
				&& !idsDebitosTipos.equals("")
				&& !idsDebitosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDebitosTipos.length; i++) {
				if (!idsDebitosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " pagamento.debitoTipo.id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsArrecadacaoForma != null
				&& !idsArrecadacaoForma.equals("")
				&& !idsArrecadacaoForma[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsArrecadacaoForma.length; i++) {
				if (!idsArrecadacaoForma[i].equals("")) {
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " pagamento.arrecadacaoForma.id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDocumentosTipos != null
				&& !idsDocumentosTipos.equals("")
				&& !idsDocumentosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDocumentosTipos.length; i++) {
				if (!idsDocumentosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " pagamento.documentoTipo.id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
        
        if ( valorPagamentoInicial != null && !valorPagamentoInicial.equals( "" ) &&
             valorPagamentoFinal != null && !valorPagamentoFinal.equals( "" )   ){
            sql += " pagamento.valorPagamento between " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoInicial ) + 
                " and " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoFinal ) + " and ";
        }

		// retira o " and " q fica sobrando no final da query
		sql = Util.removerUltimosCaracteres(sql, 4);
		

		// [SB0006] Ordenar Pagamentos de Acordo com o Tipo de Documento
		// 1. Para os pagamentos com tipo de documento(DOPT_ID) com valor
		// correspondente a conta,
		// ordena os pagamentos pela localidade (LOCA_ID), matrícula do imóvel
		// (IMOV_ID), ano/mês
		// de referênca do pagamento(PGMT_AMREFERENCIAPAGAMENTO), e data de
		// pagamento (PGMT_DTPAGAMENTO)

		// 2. Para os pagamentos com tipo do documento(DOPT_ID) com o valor
		// correspondente a guia de
		// pagamento, ordena os pagamentos pela localidade (LOCA_ID), matrícula
		// do imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGMT_DTPAGAMENTO)

		// 3. Para os pagamentos com tipo de documento(DOPT_ID) com o valor
		// correspondente a débito a
		// cobrar, ordena os pagamentos pela localidade (LOCA_ID), matrícula do
		// imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGMT_DTPAGAMENTO)

		return sql;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamentoRelatorio
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @param idImovel
	 * @param idCliente
	 * @param idTipoRelacao
	 * @param localidadeInicial
	 * @param localidadeFinal
	 * @param idAvisoBancario
	 * @param idArrecadador
	 * @param periodoArrecadacaoInicial
	 * @param periodoArrecadacaoFinal
	 * @param periodoPagamentoInicio
	 * @param periodoPagamentoFim
	 * @param dataPagamentoInicial
	 * @param dataPagamentoFinal
	 * @param idsPagamentosSituacoes
	 * @param idsDebitosTipos
	 * @param idsArrecadacaoForma
	 * @param idsDocumentosTipos
	 * @return
	 */
	public String criarCondicionaisPagamentoCliente(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) {

		String sql = " ";
		if (idImovel != null && !idImovel.equals("")) {
			sql = sql + " c.imov_id = " + idImovel + " and ";
		}
		if (idCliente != null && !idCliente.equals("")) {
			sql = sql + " a.clie_id = " + idCliente + " and ";
		}
		if (idTipoRelacao != null && !idTipoRelacao.equals("")) {
			sql = sql + " b.crtp_id = " + idTipoRelacao + " and ";
		}
		if (localidadeInicial != null && localidadeFinal != null
				&& !localidadeInicial.equals("") && !localidadeFinal.equals("")) {
			sql = sql + " c.loca_id >= " + localidadeInicial + " and ";
			sql = sql + " c.loca_id <= " + localidadeFinal + " and ";
		}
		if (idAvisoBancario != null && !idAvisoBancario.equals("")) {
			sql = sql + " c.avbc_id = " + idAvisoBancario + " and ";
		}
		if (idArrecadador != null && !idArrecadador.equals("")) {
			sql = sql + " f.armv_id = " + idArrecadador + " and ";
		}
		if (periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoInicial.equals("")) {
			sql = sql
					+ " c.pgmt_amreferenciaarrecadacao >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
					+ " and ";
		}
		if (periodoArrecadacaoFinal != null
				&& !periodoArrecadacaoFinal.equals("")) {
			sql = sql
					+ " c.pgmt_amreferenciaarrecadacao <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal)
					+ " and ";
		}
		if (periodoPagamentoInicio != null
				&& !periodoPagamentoInicio.equals("")) {
			sql = sql
					+ " c.pgmt_amreferenciapagamento >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
					+ " and ";
		}
		if (periodoPagamentoFim != null && !periodoPagamentoFim.equals("")) {
			sql = sql
					+ " c.pgmt_amreferenciapagamento <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim)
					+ " and ";
		}

		if (dataPagamentoInicial != null && !dataPagamentoInicial.equals("")) {
			// sql = sql + " pagamento.dataPagamento >= '" +
			// Util.formatarData(dataPagamentoInicial) + "' and " ;
			String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

			if (data1 != null && !data1.equals("")
					&& data1.trim().length() == 8) {

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6)
						+ "-" + data1.substring(6, 8);
			}
			sql = sql + " c.pgmt_dtpagamento >= to_date('" + data1 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}
		if (dataPagamentoFinal != null && !dataPagamentoFinal.equals("")) {
			// sql = sql + " pagamento.dataPagamento <= '" +
			// Util.formatarData(dataPagamentoFinal) + "' and " ;
			String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

			if (data2 != null && !data2.equals("")
					&& data2.trim().length() == 8) {

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6)
						+ "-" + data2.substring(6, 8);
			}
			sql = sql + " c.pgmt_dtpagamento <= to_date('" + data2 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}

		if (idsPagamentosSituacoes != null
				&& !idsPagamentosSituacoes.equals("")) {
			String valoresIn = "";
			for (int i = 0; i < idsPagamentosSituacoes.length; i++) {
				if (!idsPagamentosSituacoes[i].equals("")) {
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.pgst_idatual in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDebitosTipos != null
				&& !idsDebitosTipos.equals("")
				&& !idsDebitosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDebitosTipos.length; i++) {
				if (!idsDebitosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.dbtp_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsArrecadacaoForma != null
				&& !idsArrecadacaoForma.equals("")
				&& !idsArrecadacaoForma[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsArrecadacaoForma.length; i++) {
				if (!idsArrecadacaoForma[i].equals("")) {
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.arfm_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDocumentosTipos != null
				&& !idsDocumentosTipos.equals("")
				&& !idsDocumentosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDocumentosTipos.length; i++) {
				if (!idsDocumentosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.dotp_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
        
        if ( valorPagamentoInicial != null && !valorPagamentoInicial.equals( "" ) &&
                valorPagamentoFinal != null && !valorPagamentoFinal.equals( "" )   ){
               sql += " c.valorPagamento between " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoInicial ) + 
                   " and " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoFinal ) + " and ";
        }
        

		// retira o " and " q fica sobrando no final da query
		sql = Util.removerUltimosCaracteres(sql, 4);

		return sql;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * 
	 * @param idImovel
	 * @param idCliente
	 * @param idTipoRelacao
	 * @param localidadeInicial
	 * @param localidadeFinal
	 * @param idAvisoBancario
	 * @param idArrecadador
	 * @param periodoArrecadacaoInicial
	 * @param periodoArrecadacaoFinal
	 * @param periodoPagamentoInicio
	 * @param periodoPagamentoFim
	 * @param dataPagamentoInicial
	 * @param dataPagamentoFinal
	 * @param idsPagamentosSituacoes
	 * @param idsDebitosTipos
	 * @param idsArrecadacaoForma
	 * @param idsDocumentosTipos
	 * @return
	 */
	public String criarCondicionaisPagamentoRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal ) {

		String sql = " WHERE ";
		if (idImovel != null && !idImovel.equals("")) {
			sql = sql + " imov.id = " + idImovel + " and ";
		}
		if (idCliente != null && !idCliente.equals("")) {
			// sql = sql + " clienteContas.cliente.id = " + idCliente + " and "
			// ;
			sql = sql + " cli.id = " + idCliente + " and ";
		}
		if (idTipoRelacao != null && !idTipoRelacao.equals("")) {
			sql = sql + " clienteRelacaoTipo.id = " + idTipoRelacao + " and ";
		}

		if (localidadeInicial != null && localidadeFinal != null
				&& !localidadeInicial.equals("") && !localidadeFinal.equals("")) {
			sql = sql + " loc.id >= " + localidadeInicial + " and ";
			sql = sql + " loc.id <= " + localidadeFinal + " and ";
		}
		if (idAvisoBancario != null && !idAvisoBancario.equals("")) {
			sql = sql + " avbc.id = " + idAvisoBancario + " and ";
		}
		if (idArrecadador != null && !idArrecadador.equals("")) {
			sql = sql + " arrecMov.id = " + idArrecadador + " and ";
		}
		if (periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoInicial.equals("")) {
			sql = sql
					+ " pagto.anoMesReferenciaArrecadacao >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
					+ " and ";
		}
		if (periodoArrecadacaoFinal != null
				&& !periodoArrecadacaoFinal.equals("")) {
			sql = sql
					+ " pagto.anoMesReferenciaArrecadacao <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal)
					+ " and ";
		}
		if (periodoPagamentoInicio != null
				&& !periodoPagamentoInicio.equals("")) {
			sql = sql
					+ " pagto.anoMesReferenciaPagamento >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
					+ " and ";
		}
		if (periodoPagamentoFim != null && !periodoPagamentoFim.equals("")) {
			sql = sql
					+ " pagto.anoMesReferenciaPagamento <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim)
					+ " and ";
		}

		if (dataPagamentoInicial != null && !dataPagamentoInicial.equals("")) {
			// sql = sql + " pagamento.dataPagamento >= '" +
			// Util.formatarData(dataPagamentoInicial) + "' and " ;
			String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

			if (data1 != null && !data1.equals("")
					&& data1.trim().length() == 8) {

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6)
						+ "-" + data1.substring(6, 8);
			}
			sql = sql + " pagto.dataPagamento >= to_date('" + data1 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}
		if (dataPagamentoFinal != null && !dataPagamentoFinal.equals("")) {
			// sql = sql + " pagamento.dataPagamento <= '" +
			// Util.formatarData(dataPagamentoFinal) + "' and " ;
			String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

			if (data2 != null && !data2.equals("")
					&& data2.trim().length() == 8) {

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6)
						+ "-" + data2.substring(6, 8);
			}
			sql = sql + " pagto.dataPagamento <= to_date('" + data2 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}

		if (idsPagamentosSituacoes != null
				&& !idsPagamentosSituacoes.equals("")) {
			String valoresIn = "";
			for (int i = 0; i < idsPagamentosSituacoes.length; i++) {
				if (!idsPagamentosSituacoes[i].equals("")) {
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " pagtoSitAtual.id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDebitosTipos != null
				&& !idsDebitosTipos.equals("")
				&& !idsDebitosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDebitosTipos.length; i++) {
				if (!idsDebitosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " dbtp.id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsArrecadacaoForma != null
				&& !idsArrecadacaoForma.equals("")
				&& !idsArrecadacaoForma[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsArrecadacaoForma.length; i++) {
				if (!idsArrecadacaoForma[i].equals("")) {
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " arrecForma.id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDocumentosTipos != null
				&& !idsDocumentosTipos.equals("")
				&& !idsDocumentosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDocumentosTipos.length; i++) {
				if (!idsDocumentosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " doctoTp.id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
        
        if ( valorPagamentoInicial != null && !valorPagamentoInicial.equals( "" ) &&
                valorPagamentoFinal != null && !valorPagamentoFinal.equals( "" )   ){
               sql += " pagto.valorPagamento between " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoInicial ) + 
                   " and " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoFinal ) + " and ";
        }        

		// retira o " and " q fica sobrando no final da query
		sql = Util.removerUltimosCaracteres(sql, 4);
		

		// [SB0006] Ordenar Pagamentos de Acordo com o Tipo de Documento
		// 1. Para os pagamentos com tipo de documento(DOPT_ID) com valor
		// correspondente a conta,
		// ordena os pagamentos pela localidade (LOCA_ID), matrícula do imóvel
		// (IMOV_ID), ano/mês
		// de referênca do pagamento(PGMT_AMREFERENCIAPAGAMENTO), e data de
		// pagamento (PGMT_DTPAGAMENTO)

		// 2. Para os pagamentos com tipo do documento(DOPT_ID) com o valor
		// correspondente a guia de
		// pagamento, ordena os pagamentos pela localidade (LOCA_ID), matrícula
		// do imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGMT_DTPAGAMENTO)

		// 3. Para os pagamentos com tipo de documento(DOPT_ID) com o valor
		// correspondente a débito a
		// cobrar, ordena os pagamentos pela localidade (LOCA_ID), matrícula do
		// imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGMT_DTPAGAMENTO)

		return sql;
	}

	/**
	 * Consulta dados da tabela dados diarios arrecadacao
	 * 
	 * @author Fernanda Paiva
	 * @created 09/06/2006
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarDadosDiarios(int anoMesReferencia, int id,
			String descricao, int idElo) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			if (descricao == "ELO") {
				consulta = "select localidade.localidade.id,sum(re.valorPagamentos), re.gerenciaRegional.id, eloPolo.descricao, "
						+ " eloPolo.localidade.id, re.anoMesReferenciaArrecadacao"
						+ " from ArrecadacaoDadosDiarios re,Localidade localidade, Localidade eloPolo "
						+ " where  re.localidade.id = localidade.id "
						+ "and localidade.localidade.id = eloPolo.id "
						+ "and re.anoMesReferenciaArrecadacao = :anoMesReferencia and "
						+ " re.gerenciaRegional.id = :id "
						+ " group by localidade.localidade.id,re.gerenciaRegional.id, eloPolo.descricao, "
						+ " eloPolo.localidade.id, re.anoMesReferenciaArrecadacao";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).list();

			}
			if (descricao == "LOCALIDADE") {
				consulta = "select re.localidade.id, sum(re.valorPagamentos), re.gerenciaRegional.id, eloPolo.descricao, "
						+ " eloPolo.id, re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re, Localidade eloPolo "
						+ " where  re.localidade.id = eloPolo.id and re.anoMesReferenciaArrecadacao = :anoMesReferencia and "
						+ " re.gerenciaRegional.id = :id and eloPolo.localidade = :idElo"
						+ " group by re.localidade.id, re.gerenciaRegional.id, eloPolo.descricao, "
						+ " eloPolo.id, re.anoMesReferenciaArrecadacao ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).setInteger("idElo", idElo).list();
			}
			if (descricao == "ARRECADADOR") {
				consulta = "select cliente.nome, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao, arrecadador.id "
						+ " from ArrecadacaoDadosDiarios re, Arrecadador arrecadador "
						+ "left join arrecadador.cliente cliente"
						+ " where  re.arrecadador.id = arrecadador.id and re.anoMesReferenciaArrecadacao = :anoMesReferencia "
						+ " group by cliente.nome, re.anoMesReferenciaArrecadacao, arrecadador.id ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).list();
			}
			if (descricao == "VALORES") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).list();
			}
			if (descricao == "VALORESGERENCIA") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.gerenciaRegional.id = :id "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).list();
			}
			if (descricao == "VALORESELO") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re,Localidade localidade, Localidade eloPolo "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and eloPolo.localidade.id = :idElo "
						+ " and re.localidade.id = localidade.id "
						+ " and localidade.localidade.id = eloPolo.id "
						+ " and  re.gerenciaRegional.id = :id "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).setInteger("idElo", idElo).list();
			}
			if (descricao == "VALORESLOCALIDADE") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re, Localidade localidade, Localidade eloPolo "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and eloPolo.id = :idElo "
						+ " and re.localidade.id = eloPolo.id "
						+ " and re.gerenciaRegional.id = :id "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).setInteger("idElo", idElo).list();
			}
			if (descricao == "VALORESPORDIA") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re, Localidade localidade "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia "
						+ " and localidade.id = re.localidade.id "
						+ "and localidade.id = :idLocalidade "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger(
						"idLocalidade", idElo).list();
			}

			if (descricao == "VALORESARRECADADOR") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.arrecadador.id = :id "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).list();
			}
			if (descricao == "VALORESCATEGORIA") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.categoria.id = :id "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).list();
			}
			if (descricao == "VALORESPERFIL") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.imovelPerfil.id = :id "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).list();
			}
			if (descricao == "VALORESDOCUMENTO") {
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), "
						+ " re.anoMesReferenciaArrecadacao "
						+ " from ArrecadacaoDadosDiarios re "
						+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.documentoTipo.id = :id "
						+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
						+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger(
						"anoMesReferencia", anoMesReferencia).setInteger("id",
						id).list();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * @param avisoBancarioHelper
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */

	public Integer filtrarAvisoBancarioAbertoFechadoCount(
			AvisoBancarioHelper avisoBancarioHelper,
			AvisoBancarioHelper avisoBancarioHelperNovo)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		Object resultado = null;

		Short arrecadadorCodAgente = avisoBancarioHelper
				.getCodigoAgenteArrecadador();
		Date dataLancamentoInicio = avisoBancarioHelper
				.getDataLancamentoInicial();
		Date dataLancamentoFim = avisoBancarioHelper.getDataLancamentoFinal();
		Short indicadorCreditoDebito = avisoBancarioHelper
				.getIndicadorCreditoDebito();
		Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
		Integer idMovimento = avisoBancarioHelper.getIdMovimentoArrecadador();
		Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper
				.getDataPrevistaInicial();
		Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper
				.getDataPrevistaFinal();
		Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper
				.getDataRealizadaInicial();
		Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper
				.getDataRealizadaFinal();
		int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper
				.getAnoMesReferenciaArrecadacaoInicial();
		int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper
				.getAnoMesReferenciaArrecadacaoFinal();
		BigDecimal valorRealizadoInicial = avisoBancarioHelper
				.getValorRealizadoInicial();
		BigDecimal valorRealizadoFinal = avisoBancarioHelper
				.getValorRealizadoFinal();
		BigDecimal valorPrevistoInicial = avisoBancarioHelper
				.getValorPrevistoInicial();
		BigDecimal valorPrevistoFinal = avisoBancarioHelper
				.getValorPrevistoFinal();
		String tipoAviso = avisoBancarioHelper.getTipoAviso();
		int flag = 0;

		if (arrecadadorCodAgente == null
				&& (dataLancamentoInicio == null || dataLancamentoFim == null)
				&& (indicadorCreditoDebito == 0 || indicadorCreditoDebito == 3)
				&& idContaBancaria == null
				&& idMovimento == null
				&& (dataPrevisaoCreditoDebitoInicio == null || dataPrevisaoCreditoDebitoFim == null)
				&& (dataRealizacaoCreditoDebitoInicio == null || dataRealizacaoCreditoDebitoFim == null)
				&& (anoMesReferenciaArrecadacaoInicial == 0 || anoMesReferenciaArrecadacaoFinal == 0)
				&& (valorPrevistoInicial == null || valorPrevistoFinal == null)
				&& (valorRealizadoInicial == null || valorRealizadoFinal == null)
				&& tipoAviso.equalsIgnoreCase("1")) {
			flag = 1;
			consulta = "select count (avisoBancario.id) from AvisoBancario avisoBancario ";
		} else {
			consulta = "select count (avisoBancario.id) from AvisoBancario avisoBancario "
					+ "where ";
		}

		if (arrecadadorCodAgente != null) {
			consulta += " avisoBancario.arrecadador.codigoAgente = "
					+ arrecadadorCodAgente + " and";
		}

		if ((dataLancamentoInicio != null) && (dataLancamentoFim != null)) {
			consulta += " avisoBancario.dataLancamento between :dataLancamentoInicio  and "
					+ ":dataLancamentoFim and";

		}

		if (indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3) {
			consulta += " avisoBancario.indicadorCreditoDebito = "
					+ indicadorCreditoDebito + " and";
		}

		if (idContaBancaria != null) {
			consulta += " avisoBancario.contaBancaria.id = " + idContaBancaria
					+ " and";
		}

		if (idMovimento != null) {
			consulta += " avisoBancario.arrecadadorMovimento.id = "
					+ idMovimento + " and";
		}

		if ((dataPrevisaoCreditoDebitoInicio != null)
				&& (dataPrevisaoCreditoDebitoFim != null)) {
			consulta += " avisoBancario.dataPrevista between :dataPrevisaoCreditoDebitoInicio  and "
					+ ":dataPrevisaoCreditoDebitoFim and";

		}

		if ((dataRealizacaoCreditoDebitoInicio != null)
				&& (dataRealizacaoCreditoDebitoFim != null)) {
			consulta += " avisoBancario.dataRealizada between :dataRealizacaoCreditoDebitoInicio  and "
					+ ":dataRealizacaoCreditoDebitoFim and";

		}

		if ((anoMesReferenciaArrecadacaoInicial != 0)
				&& (anoMesReferenciaArrecadacaoFinal != 0)) {
			consulta += " avisoBancario.anoMesReferenciaArrecadacao between "
					+ anoMesReferenciaArrecadacaoInicial + " and "
					+ anoMesReferenciaArrecadacaoFinal + " and";
		}

		if ((valorRealizadoInicial != null) && (valorRealizadoFinal != null)) {
			BigDecimal valorInicialNegativo = valorRealizadoFinal
					.multiply(new BigDecimal("-1.00"));
			BigDecimal valorFinalNegativo = valorRealizadoInicial
					.multiply(new BigDecimal("-1.00"));
			consulta += " ((avisoBancario.valorRealizado between "
					+ valorInicialNegativo + " and " + valorFinalNegativo
					+ ") or (avisoBancario.valorRealizado between "
					+ valorRealizadoInicial + " and " + valorRealizadoFinal
					+ "))" + " and";

		}

		// tipoAviso
		if (tipoAviso != null) {
			if (tipoAviso.equalsIgnoreCase("3")) {
				BigDecimal valorSomatorioAcertoCredito = this
						.pesquisarSomatorioAvisoAcerto(1,
								avisoBancarioHelperNovo.getAvisoBancario()
										.getId(), 1);
				BigDecimal valorSomatorioAcertoDebito = this
						.pesquisarSomatorioAvisoAcerto(2,
								avisoBancarioHelperNovo.getAvisoBancario()
										.getId(), 1);

				BigDecimal valorSomatorioAcertoCredito2 = this
						.pesquisarSomatorioAvisoAcerto(1,
								avisoBancarioHelperNovo.getAvisoBancario()
										.getId(), 2);
				BigDecimal valorSomatorioAcertoDebito2 = this
						.pesquisarSomatorioAvisoAcerto(2,
								avisoBancarioHelperNovo.getAvisoBancario()
										.getId(), 2);
				if (valorSomatorioAcertoCredito == null) {
					valorSomatorioAcertoCredito = new BigDecimal("0.00");
				}
				if (valorSomatorioAcertoDebito == null) {
					valorSomatorioAcertoDebito = new BigDecimal("0.00");
				}

				if (valorSomatorioAcertoCredito2 == null) {
					valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
				}
				if (valorSomatorioAcertoDebito2 == null) {
					valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
				}
				// FECHADO
				consulta += " ((avisoBancario.valorArrecadacaoCalculado = "
						+ "(( "
						+ "    avisoBancario.valorArrecadacaoInformado + "
						+ valorSomatorioAcertoCredito + ") - "
						+ valorSomatorioAcertoDebito + ")) and "
						+ " (avisoBancario.valorDevolucaoCalculado = " + "(( "
						+ "    avisoBancario.valorDevolucaoInformado + "
						+ valorSomatorioAcertoCredito2 + ") - "
						+ valorSomatorioAcertoDebito2 + "))) and ";
			} else if (tipoAviso.equalsIgnoreCase("2")) {
				// ABERTO
				BigDecimal valorSomatorioAcertoCredito = this
						.pesquisarSomatorioAvisoAcerto(1,
								avisoBancarioHelperNovo.getAvisoBancario()
										.getId(), 1);
				BigDecimal valorSomatorioAcertoDebito = this
						.pesquisarSomatorioAvisoAcerto(2,
								avisoBancarioHelperNovo.getAvisoBancario()
										.getId(), 1);

				BigDecimal valorSomatorioAcertoCredito2 = this
						.pesquisarSomatorioAvisoAcerto(1,
								avisoBancarioHelperNovo.getAvisoBancario()
										.getId(), 2);
				BigDecimal valorSomatorioAcertoDebito2 = this
						.pesquisarSomatorioAvisoAcerto(2,
								avisoBancarioHelperNovo.getAvisoBancario()
										.getId(), 2);
				if (valorSomatorioAcertoCredito == null) {
					valorSomatorioAcertoCredito = new BigDecimal("0.00");
				}
				if (valorSomatorioAcertoDebito == null) {
					valorSomatorioAcertoDebito = new BigDecimal("0.00");
				}

				if (valorSomatorioAcertoCredito2 == null) {
					valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
				}
				if (valorSomatorioAcertoDebito2 == null) {
					valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
				}
				consulta += " ((avisoBancario.valorArrecadacaoCalculado <> "
						+ "(( "
						+ "    avisoBancario.valorArrecadacaoInformado + "
						+ valorSomatorioAcertoCredito + ") - "
						+ valorSomatorioAcertoDebito + ")) or "
						+ " (avisoBancario.valorDevolucaoCalculado <> " + "(( "
						+ "    avisoBancario.valorDevolucaoInformado + "
						+ valorSomatorioAcertoCredito2 + ") - "
						+ valorSomatorioAcertoDebito2 + "))) and ";
			}

		}

		String consultarComOrderBy = "";

		if (flag != 1) {
			consultarComOrderBy = Util.removerUltimosCaracteres(consulta, 4);
		} else {
			consultarComOrderBy = Util.removerUltimosCaracteres(consulta, 0);
		}

		if (arrecadadorCodAgente != null) {

			// consultarComOrderBy += " group by avisoBancario.arrecadador.id ";
		}
		

		// Consulta
		try {

			if ((((dataLancamentoInicio != null) && (dataLancamentoFim != null)) && ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				resultado = session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).uniqueResult();

			} else if (((dataLancamentoInicio != null) && (dataLancamentoFim != null))
					&& ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))) {

				resultado = session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).uniqueResult();

			} else if (((dataLancamentoInicio != null) && (dataLancamentoFim != null))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				resultado = session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).uniqueResult();

			} else if (((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				resultado = session.createQuery(consultarComOrderBy).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).uniqueResult();

			} else if ((dataLancamentoInicio != null)
					&& (dataLancamentoFim != null)) {

				resultado = session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).uniqueResult();

			} else if ((dataPrevisaoCreditoDebitoInicio != null)
					&& (dataPrevisaoCreditoDebitoFim != null)) {

				resultado = session.createQuery(consultarComOrderBy).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).uniqueResult();

			} else if ((dataRealizacaoCreditoDebitoInicio != null)
					&& (dataRealizacaoCreditoDebitoFim != null)) {

				resultado = session.createQuery(consultarComOrderBy).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).uniqueResult();

			} else {
				resultado = session.createQuery(consultarComOrderBy)
						.uniqueResult();
			}

			if (resultado != null) {
				retorno = (Integer) resultado;
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * @param avisoBancarioHelper
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarAvisoBancarioAbertoFechadoParaPaginacao(
			AvisoBancarioHelper avisoBancarioHelper, Integer numeroPagina)
			throws ErroRepositorioException {

		// Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		Integer idAviso = avisoBancarioHelper.getAvisoBancario().getId();
		String tipoAviso = avisoBancarioHelper.getTipoAviso();

		Short arrecadadorCodAgente = avisoBancarioHelper
				.getCodigoAgenteArrecadador();
		Date dataLancamentoInicio = avisoBancarioHelper
				.getDataLancamentoInicial();
		Date dataLancamentoFim = avisoBancarioHelper.getDataLancamentoFinal();
		Short indicadorCreditoDebito = avisoBancarioHelper
				.getIndicadorCreditoDebito();
		Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
		Integer idMovimento = avisoBancarioHelper.getIdMovimentoArrecadador();
		Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper
				.getDataPrevistaInicial();
		Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper
				.getDataPrevistaFinal();
		Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper
				.getDataRealizadaInicial();
		Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper
				.getDataRealizadaFinal();
		int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper
				.getAnoMesReferenciaArrecadacaoInicial();
		int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper
				.getAnoMesReferenciaArrecadacaoFinal();
		BigDecimal valorRealizadoInicial = avisoBancarioHelper
				.getValorRealizadoInicial();
		BigDecimal valorRealizadoFinal = avisoBancarioHelper
				.getValorRealizadoFinal();
		BigDecimal valorPrevistoInicial = avisoBancarioHelper
				.getValorPrevistoInicial();
		BigDecimal valorPrevistoFinal = avisoBancarioHelper
				.getValorPrevistoFinal();

		int flag = 0;
		BigDecimal valorSomatorioAcertoCredito = this
				.pesquisarSomatorioAvisoAcerto(1, idAviso, 1);
		BigDecimal valorSomatorioAcertoDebito = this
				.pesquisarSomatorioAvisoAcerto(2, idAviso, 1);

		BigDecimal valorSomatorioAcertoCredito2 = this
				.pesquisarSomatorioAvisoAcerto(1, idAviso, 2);
		BigDecimal valorSomatorioAcertoDebito2 = this
				.pesquisarSomatorioAvisoAcerto(2, idAviso, 2);
		if (valorSomatorioAcertoCredito == null) {
			valorSomatorioAcertoCredito = new BigDecimal("0.00");
		}
		if (valorSomatorioAcertoDebito == null) {
			valorSomatorioAcertoDebito = new BigDecimal("0.00");
		}

		if (valorSomatorioAcertoCredito2 == null) {
			valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
		}
		if (valorSomatorioAcertoDebito2 == null) {
			valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
		}
		if (arrecadadorCodAgente == null
				&& (dataLancamentoInicio == null || dataLancamentoFim == null)
				&& (indicadorCreditoDebito == 0 || indicadorCreditoDebito == 3)
				&& idContaBancaria == null
				&& idMovimento == null
				&& (dataPrevisaoCreditoDebitoInicio == null || dataPrevisaoCreditoDebitoFim == null)
				&& (dataRealizacaoCreditoDebitoInicio == null || dataRealizacaoCreditoDebitoFim == null)
				&& (anoMesReferenciaArrecadacaoInicial == 0 || anoMesReferenciaArrecadacaoFinal == 0)
				&& (valorPrevistoInicial == null || valorPrevistoFinal == null)
				&& (valorRealizadoInicial == null || valorRealizadoFinal == null)
				&& tipoAviso.equalsIgnoreCase("1")) {
			flag = 1;
			consulta = "select avisoBancario, " + " case when ("
					+ " (avisoBancario.valorArrecadacaoCalculado = "
					+ " ((avisoBancario.valorArrecadacaoInformado + "
					+ valorSomatorioAcertoCredito + " ) " + " - "
					+ valorSomatorioAcertoDebito + ")" + " ) " + " and "
					+ "(avisoBancario.valorDevolucaoCalculado = "
					+ " ((avisoBancario.valorDevolucaoInformado + "
					+ valorSomatorioAcertoCredito2 + " ) " + " - "
					+ valorSomatorioAcertoDebito2 + ")" + " )) then 'FECHADO' "
					+ " else 'ABERTO' end "
					+ " from AvisoBancario avisoBancario ";

		} else {
			consulta = "select avisoBancario, " + " case when ("
					+ " (avisoBancario.valorArrecadacaoCalculado = "
					+ " ((avisoBancario.valorArrecadacaoInformado + "
					+ valorSomatorioAcertoCredito + " ) " + " - "
					+ valorSomatorioAcertoDebito + ")" + " ) " + " and "
					+ "(avisoBancario.valorDevolucaoCalculado = "
					+ " ((avisoBancario.valorDevolucaoInformado + "
					+ valorSomatorioAcertoCredito2 + " ) " + " - "
					+ valorSomatorioAcertoDebito2 + ")" + " )) then 'FECHADO' "
					+ " else 'ABERTO' end "
					+ " from AvisoBancario avisoBancario " + " where ";
		}

		if (idAviso != null) {
			consulta += " avisoBancario.id = " + idAviso + " and";
		}

		if (arrecadadorCodAgente != null) {
			consulta += " avisoBancario.arrecadador.codigoAgente = "
					+ arrecadadorCodAgente + " and";
		}

		if ((dataLancamentoInicio != null) && (dataLancamentoFim != null)) {
			consulta += " avisoBancario.dataLancamento between :dataLancamentoInicio  and "
					+ ":dataLancamentoFim and";

		}

		if (indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3) {
			consulta += " avisoBancario.indicadorCreditoDebito = "
					+ indicadorCreditoDebito + " and";
		}

		if (idContaBancaria != null) {
			consulta += " avisoBancario.contaBancaria.id = " + idContaBancaria
					+ " and";
		}

		if (idMovimento != null) {
			consulta += " avisoBancario.arrecadadorMovimento.id = "
					+ idMovimento + " and";
		}

		if ((dataPrevisaoCreditoDebitoInicio != null)
				&& (dataPrevisaoCreditoDebitoFim != null)) {
			consulta += " avisoBancario.dataPrevista between :dataPrevisaoCreditoDebitoInicio  and "
					+ ":dataPrevisaoCreditoDebitoFim and";

		}

		if ((dataRealizacaoCreditoDebitoInicio != null)
				&& (dataRealizacaoCreditoDebitoFim != null)) {
			consulta += " avisoBancario.dataRealizada between :dataRealizacaoCreditoDebitoInicio  and "
					+ ":dataRealizacaoCreditoDebitoFim and";

		}

		if ((anoMesReferenciaArrecadacaoInicial != 0)
				&& (anoMesReferenciaArrecadacaoFinal != 0)) {
			consulta += " avisoBancario.anoMesReferenciaArrecadacao between "
					+ anoMesReferenciaArrecadacaoInicial + " and "
					+ anoMesReferenciaArrecadacaoFinal + " and";
		}

		if ((valorRealizadoInicial != null) && (valorRealizadoFinal != null)) {

			BigDecimal valorInicialNegativo = valorRealizadoFinal
					.multiply(new BigDecimal("-1.00"));
			BigDecimal valorFinalNegativo = valorRealizadoInicial
					.multiply(new BigDecimal("-1.00"));
			consulta += " ((avisoBancario.valorRealizado between "
					+ valorInicialNegativo + " and " + valorFinalNegativo
					+ ") or (avisoBancario.valorRealizado between "
					+ valorRealizadoInicial + " and " + valorRealizadoFinal
					+ "))" + " and";
		}

		// tipoAviso
		if (tipoAviso != null) {
			if (tipoAviso.equalsIgnoreCase("3")) {
				// FECHADO
				consulta += " ((avisoBancario.valorArrecadacaoCalculado = "
						+ " ((avisoBancario.valorArrecadacaoInformado + "
						+ valorSomatorioAcertoCredito + " ) " + " - "
						+ valorSomatorioAcertoDebito + ")" + " ) " + " and "
						+ "(avisoBancario.valorDevolucaoCalculado = "
						+ " ((avisoBancario.valorDevolucaoInformado + "
						+ valorSomatorioAcertoCredito2 + " ) " + " - "
						+ valorSomatorioAcertoDebito2 + ")" + " )) and ";
			} else if (tipoAviso.equalsIgnoreCase("2")) {
				// ABERTO
				consulta += " ((avisoBancario.valorArrecadacaoCalculado <> "
						+ " ((avisoBancario.valorArrecadacaoInformado + "
						+ valorSomatorioAcertoCredito + " ) " + " - "
						+ valorSomatorioAcertoDebito + ")" + " ) " + " or "
						+ "(avisoBancario.valorDevolucaoCalculado <> "
						+ " ((avisoBancario.valorDevolucaoInformado + "
						+ valorSomatorioAcertoCredito2 + " ) " + " - "
						+ valorSomatorioAcertoDebito2 + ")" + " )) and ";
			}
		}
		String consultarComOrderBy = "";

		if (flag != 1) {
			consultarComOrderBy = Util.removerUltimosCaracteres(consulta, 4)
					+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
		} else {
			consultarComOrderBy = Util.removerUltimosCaracteres(consulta, 0)
					+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
		}
		

		// Consulta
		try {
			if ((((dataLancamentoInicio != null) && (dataLancamentoFim != null)) && ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).setFirstResult(
						10 * numeroPagina).setMaxResults(10).list();

			} else if (((dataLancamentoInicio != null) && (dataLancamentoFim != null))
					&& ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setFirstResult(
						10 * numeroPagina).setMaxResults(10).list();

			} else if (((dataLancamentoInicio != null) && (dataLancamentoFim != null))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).setFirstResult(
						10 * numeroPagina).setMaxResults(10).list();

			} else if (((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).setFirstResult(
						10 * numeroPagina).setMaxResults(10).list();

			} else if ((dataLancamentoInicio != null)
					&& (dataLancamentoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setFirstResult(
						10 * numeroPagina).setMaxResults(10).list();

			} else if ((dataPrevisaoCreditoDebitoInicio != null)
					&& (dataPrevisaoCreditoDebitoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setFirstResult(
						10 * numeroPagina).setMaxResults(10).list();

			} else if ((dataRealizacaoCreditoDebitoInicio != null)
					&& (dataRealizacaoCreditoDebitoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).setFirstResult(
						10 * numeroPagina).setMaxResults(10).list();

			} else {
				return session.createQuery(consultarComOrderBy).setFirstResult(
						10 * numeroPagina).setMaxResults(10).list();
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 21/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoCliente(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, Integer numeroPagina, String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoCliente(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = " select c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
					+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
					+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
					+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " k.pgst_id as idSituacaoPagamentoAnterior, k.pgst_dsabreviado as situacaoPagamentoAnterior "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " faturamento.conta i "
					+ "  on i.cnta_id = c.cnta_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_conta b "
					+ " on b.cnta_id = c.cnta_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " cobranca.documento_tipo n "
					+ "  on n.dotp_id = c.dotp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao k "
					+ "  on c.pgst_idanterior = k.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " union "
					+ " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
					+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
					+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
					+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " faturamento.debito_a_cobrar b1 "
					+ "  on b1.dbac_id = c.dbac_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_imovel b "
					+ " on b.imov_id = b1.imov_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " cobranca.documento_tipo n "
					+ "  on n.dotp_id = c.dotp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " union "
					+ " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
					+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
					+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
					+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " faturamento.guia_pagamento b1 "
					+ "  on b1.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_guia_pagamento b "
					+ " on b.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " cobranca.documento_tipo n "
					+ "  on n.dotp_id = c.dotp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " union "
					+ " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
					+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
					+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
					+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " faturamento.guia_pagamento b1 "
					+ "  on b1.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_guia_pagamento b "
					+ " on b.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " cobranca.documento_tipo n "
					+ "  on n.dotp_id = c.dotp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " union "
					+ " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
					+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
					+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
					+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior "
					+ " FROM arrecadacao.pagamento c "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = c.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " cobranca.documento_tipo n "
					+ "  on n.dotp_id = c.dotp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id " + " WHERE ";

			idTipoRelacao = null;

			String condicionaisClientePagamento = this
					.criarCondicionaisPagamentoCliente(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                            valorPagamentoFinal);

			hql = hql + condicionaisClientePagamento
					+ " order by idDocumentoTipo, dataPagamento ";

			retorno = session
					.createSQLQuery(hql)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("codigoAgente", Hibernate.SHORT)
					.addScalar("dataLancamento", Hibernate.DATE)
					.addScalar("numeroSequencial", Hibernate.SHORT)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER)
					.addScalar("nomeDocumentoTipo", Hibernate.STRING)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAtual", Hibernate.STRING)
					.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAnterior", Hibernate.STRING)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 21/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection retorno = null;
		// Object pagamentoClienteCount;
		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoCliente(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = " SELECT COUNT(c.pgmt_id) as qtde "
					+ " FROM arrecadacao.pagamento c " 
					+ " INNER JOIN  faturamento.conta i "
					+ " on i.cnta_id = c.cnta_id "
					+ " INNER JOIN " + " cadastro.cliente_conta b "
					+ " on b.cnta_id = c.cnta_id " + " INNER JOIN "
					+ " cadastro.cliente a " + " on a.clie_id = b.clie_id "
					+ " INNER JOIN " + " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id " + " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id " + " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id " + " INNER JOIN "
					+ " cadastro.cliente h " + "  on h.clie_id = g.clie_id "
					+ " WHERE " + condicionais + " union all "
					+ " SELECT COUNT(c.pgmt_id) as qtde "
					+ " FROM arrecadacao.pagamento c " + " INNER JOIN "
					+ " faturamento.debito_a_cobrar b1 "
					+ "  on b1.dbac_id = c.dbac_id " + " INNER JOIN "
					+ " cadastro.cliente_imovel b "
					+ " on b.imov_id = b1.imov_id " + " INNER JOIN "
					+ " cadastro.cliente a " + " on a.clie_id = b.clie_id "
					+ " INNER JOIN " + " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id " + " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id " + " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id " + " INNER JOIN "
					+ " cadastro.cliente h " + "  on h.clie_id = g.clie_id "
					+ " WHERE " + condicionais + " union all "
					+ " SELECT COUNT(c.pgmt_id) as qtde "
					+ " FROM arrecadacao.pagamento c " + " INNER JOIN "
					+ " faturamento.guia_pagamento b1 "
					+ "  on b1.gpag_id = c.gpag_id " + " INNER JOIN "
					+ " cadastro.cliente_guia_pagamento b "
					+ " on b.gpag_id = c.gpag_id " + " INNER JOIN "
					+ " cadastro.cliente a " + " on a.clie_id = b.clie_id "
					+ " INNER JOIN " + " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id " + " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id " + " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id " + " INNER JOIN "
					+ " cadastro.cliente h " + "  on h.clie_id = g.clie_id "
					+ " WHERE " + condicionais + " union all "
					+ " SELECT COUNT(c.pgmt_id) as qtde "
					+ " FROM arrecadacao.pagamento c " + " INNER JOIN "
					+ " cadastro.cliente a " + " on a.clie_id = c.clie_id "
					+ " INNER JOIN " + " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id " + " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id " + " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id " + " INNER JOIN "
					+ " cadastro.cliente h " + "  on h.clie_id = g.clie_id "
					+ " WHERE ";

			idTipoRelacao = null;

			String condicionaisClientePagamento = this
					.criarCondicionaisPagamentoCliente(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                            valorPagamentoFinal);

			hql = hql + condicionaisClientePagamento;

			retorno = session.createSQLQuery(hql).addScalar("qtde",
					Hibernate.INTEGER).list();

			// hql = " select count (pagamento.id) "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + " inner join pagamento.cliente as cliente "
			// + condicionais + " ";

			// pagamentoClienteCount = session.createQuery(hql).setMaxResults(1)
			// .uniqueResult();
			//
			// if (pagamentoClienteCount != null) {
			// retorno = (Integer) pagamentoClienteCount;
			// }

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Vivianne Sousa
	 * @date 21/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancarioParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina, String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal );

			hql = " SELECT DISTINCT pagamento "
					+ " FROM gcom.arrecadacao.pagamento.Pagamento as pagamento "
					+ " INNER JOIN FETCH pagamento.avisoBancario as avisoBancario "
					+ " INNER JOIN FETCH avisoBancario.arrecadador arrec "
					+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.conta conta "
					+ " LEFT JOIN FETCH pagamento.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamento.debitoTipo dbtpPagto "
					+ " LEFT JOIN FETCH pagamento.cliente cliente "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ condicionais + " ";

			retorno = session.createQuery(hql)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Vivianne Sousa
	 * @date 21/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoAvisoBancarioCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ErroRepositorioException {

		int retorno = 0;
		Object pagamentoAvisoBancarioCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal);

			hql = " select count (pagamento.id) "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ " inner join pagamento.avisoBancario as avisoBancario "
					+ condicionais + " ";

			pagamentoAvisoBancarioCount = session.createQuery(hql)
					.setMaxResults(1).uniqueResult();

			if (pagamentoAvisoBancarioCount != null) {
				retorno = (Integer) pagamentoAvisoBancarioCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Vivianne Sousa
	 * @date 22/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Collection<Pagamento> pesquisarPagamentoImovelParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina, String valorPagamentoInicial, 
            String valorPagamentoFinal ) throws ErroRepositorioException {

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal);

			hql = " SELECT distinct pagamento "
					+ " FROM gcom.arrecadacao.pagamento.Pagamento as pagamento "
					+ " INNER JOIN FETCH pagamento.avisoBancario avbc "
					+ " INNER JOIN FETCH avbc.arrecadador arrec "
					+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.conta conta "
					+ " LEFT JOIN FETCH pagamento.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamento.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamento.debitoTipo dbtpPagto "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ condicionais
					+ "  order by pagamento.localidade.id, pagamento.imovel.id, "
					+ "  pagamento.documentoTipo.id, pagamento.dataPagamento "
					+ " ";

			retorno = session.createQuery(hql)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Vivianne Sousa
	 * @date 22/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoImovelCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ErroRepositorioException {

		int retorno = 0;
		Object pagamentoImovelCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal);

			hql = " select count(pagamento.id) "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ condicionais + " ";

			pagamentoImovelCount = session.createQuery(hql).setMaxResults(1)
					.uniqueResult();
			
			if (pagamentoImovelCount != null) {
				retorno += (Integer) pagamentoImovelCount;
			}
					
			hql = "select count(pagamento.id) from gcom.arrecadacao.pagamento.PagamentoHistorico pagamento "
				+ condicionais + " ";
						
			pagamentoImovelCount = session.createQuery(hql).setMaxResults(1).uniqueResult();

			if (pagamentoImovelCount != null) {
				retorno += (Integer) pagamentoImovelCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Collection pesquisarPagamentoImovelRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = "SELECT pagto.id, loc.id, loc.descricao, "
					+ "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
					+ "cliArrec.nome, pagto.dataPagamento, "
					+ "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
					+ "conta.valorAgua, conta.valorEsgoto, conta.debitos, "
					+ "conta.valorCreditos, dbcb.valorDebito, dbcb.numeroPrestacaoDebito, "
					+ "dbcb.numeroPrestacaoCobradas, gpag.valorDebito, pagto.valorPagamento, "
					+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id "
					+ "FROM Pagamento pagto "
					+ "INNER JOIN pagto.localidade loc "
					+ "INNER JOIN loc.gerenciaRegional gr "
					+ "INNER JOIN pagto.avisoBancario avbc "
					+ "INNER JOIN avbc.arrecadador arrec "
					+ "INNER JOIN arrec.cliente cliArrec "
					+ "INNER JOIN pagto.documentoTipo doctoTp "
					+ "LEFT JOIN pagto.imovel imov "
					+ "LEFT JOIN pagto.cliente cli "
					+ "LEFT JOIN pagto.debitoTipo dbtp "
					+ "LEFT JOIN pagto.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN pagto.guiaPagamento gpag "
					+ "LEFT JOIN pagto.debitoACobrarGeral dbcbGeral "
					+ "LEFT JOIN dbcbGeral.debitoACobrar dbcb "
					+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
					+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem "
					+ "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
					+ "LEFT JOIN pagto.arrecadacaoForma arrecForma "
					+ condicionais + " ORDER BY loc.id, imov.id, "
					+ " pagto.anoMesReferenciaPagamento, pagto.dataPagamento ";
			// " select distinct pagamento "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + condicionais
			// + " order by pagamento.localidade.id, pagamento.imovel.id, "
			// + " pagamento.anoMesReferenciaPagamento, pagamento.dataPagamento
			// ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String sql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoCliente(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                    valorPagamentoFinal);

			sql = " select 'CONTA' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
					+ " c.pgmt_dtpagamento as dataPagamento, c.pgmt_amreferenciapagamento as anoMesPagamento, null as tipoDebito, (cnta_vlagua + cnta_vlesgoto + cnta_vldebitos - cnta_vlcreditos) as valorDocumento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					+ " from cadastro.cliente a, cadastro.cliente_conta b, cadastro.localidade d, cadastro.gerencia_regional e, "
					+ " arrecadacao.aviso_bancario f, arrecadacao.arrecadador g, cadastro.cliente h, faturamento.conta i, arrecadacao.pagamento c "
					+ " left join arrecadacao.pagamento_situacao j "
					+ " on c.pgst_idatual = j.pgst_id "
					+ " where a.clie_id = b.clie_id "
					+ " and b.cnta_id = c.cnta_id "
					+ " and c.loca_id = d.loca_id "
					+ " and d.greg_id = e.greg_id "
					+ " and c.avbc_id = f.avbc_id "
					+ " and f.arrc_id = g.arrc_id "
					+ " and g.clie_id = h.clie_id "
					+ " and b.cnta_id = i.cnta_id "
					+ " and "
					+ condicionais
					+ " union "
					+ " select 'DÉBITO A COBRAR' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
					+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
					+ " ((dbac_nnprestacaodebito - dbac_nnprestacaocobradas) * (dbac_vldebito/ dbac_nnprestacaodebito)) as valorDocumento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					+ " from cadastro.cliente a, cadastro.cliente_imovel b, faturamento.debito_a_cobrar b1, cadastro.localidade d, cadastro.gerencia_regional e, "
					+ " arrecadacao.aviso_bancario f, arrecadacao.arrecadador g, cadastro.cliente h, faturamento.debito_tipo k, arrecadacao.pagamento c "
					+ " left join arrecadacao.pagamento_situacao j "
					+ " on c.pgst_idatual = j.pgst_id "
					+ " where a.clie_id = b.clie_id "
					+ " and b.imov_id = b1.imov_id "
					+ " and b1.dbac_id = c.dbac_id "
					+ " and c.loca_id = d.loca_id "
					+ " and d.greg_id = e.greg_id "
					+ " and c.avbc_id = f.avbc_id "
					+ " and f.arrc_id = g.arrc_id "
					+ " and g.clie_id = h.clie_id "
					+ " and b1.dbtp_id = k.dbtp_id "
					+ " and "
					+ condicionais
					+ " union "
					+ " select 'GUIA PAGAMENTO IMOVEL' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
					+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
					+ " (gpag_vldebito) as valorDocumento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					+ " from cadastro.cliente a, cadastro.cliente_guia_pagamento b, faturamento.guia_pagamento b1, cadastro.localidade d, cadastro.gerencia_regional e, "
					+ " arrecadacao.aviso_bancario f, arrecadacao.arrecadador g, cadastro.cliente h, faturamento.debito_tipo k, arrecadacao.pagamento c "
					+ " left join arrecadacao.pagamento_situacao j "
					+ " on c.pgst_idatual = j.pgst_id "
					+ " where a.clie_id = b.clie_id "
					+ " and b.gpag_id = b1.gpag_id "
					+ " and b1.gpag_id = c.gpag_id "
					+ " and c.loca_id = d.loca_id "
					+ " and d.greg_id = e.greg_id "
					+ " and c.avbc_id = f.avbc_id "
					+ " and f.arrc_id = g.arrc_id "
					+ " and g.clie_id = h.clie_id "
					+ " and b1.dbtp_id = k.dbtp_id "
					+ " and "
					+ condicionais
					+ " union "
					+ " select 'GUIA PAGAMENTO CLIENTE' as tipo, "
					+ " d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, "
					+ " e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, " 
					+ " c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, " 
					+ " h.clie_nmcliente as nomeArrecadador, "
					+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, "
					+ " k.dbtp_dsdebitotipo as tipoDebito, "
					+ " (b1.gpag_vldebito) as valorDocumento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, "
					+ " j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					
					+ " from cadastro.cliente a, cadastro.cliente_guia_pagamento b, faturamento.guia_pagamento b1, arrecadacao.pagamento c,"
					+ " cadastro.localidade d, cadastro.gerencia_regional e, arrecadacao.aviso_bancario f, " 
					+ " arrecadacao.arrecadador g, cadastro.cliente h, faturamento.debito_tipo k, "
					+ " arrecadacao.pagamento_situacao j "
					
					+ " where a.clie_id = b.clie_id "// Cliente com Guia
					+ " and b.gpag_id = b1.gpag_id "
					+ " and b1.gpag_id = c.gpag_id "// Guia com Pagamento
					+ " and c.loca_id = d.loca_id "// Pagamento com Localidade
					+ " and d.greg_id = e.greg_id "// Localidade com Gerencia
					+ " and c.avbc_id = f.avbc_id "// Pagamento com Aviso bancario
					+ " and f.arrc_id = g.arrc_id "// Aviso Bancario com Arrecadador
					+ " and g.clie_id = h.clie_id "// Arrecadador com Cleinte do Arrecadador
					+ " and b1.dbtp_id = k.dbtp_id "// Guia com Debito Tipo 
					+ " and c.pgst_idatual = j.pgst_id "
					+ " and "
					+ condicionais
					+ " union "
					+ " select 'PAGAMENTO CLIENTE' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente , a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
					+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
					+ " null as valorDocumento, "
					+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					+ " from cadastro.cliente a, cadastro.localidade d, cadastro.gerencia_regional e, "
					+ " arrecadacao.aviso_bancario f, arrecadacao.arrecadador g, cadastro.cliente h, faturamento.debito_tipo k, arrecadacao.pagamento c "
					+ " left join arrecadacao.pagamento_situacao j "
					+ " on c.pgst_idatual = j.pgst_id "
					+ " where a.clie_id = c.clie_id "
					+ " and   c.loca_id = d.loca_id "
					+ " and   d.greg_id = e.greg_id "
					+ " and   c.avbc_id = f.avbc_id "
					+ " and   f.arrc_id = g.arrc_id "
					+ " and   g.clie_id = h.clie_id "
					+ " and   c.dbtp_id = k.dbtp_id "
					+ " and   c.gpag_id IS NULL " + " and ";

			idTipoRelacao = null;

			String condicionaisClientePagamento = this
					.criarCondicionaisPagamentoCliente(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			sql = sql + condicionaisClientePagamento;

			// "select distinct pagamento " + " from
			// gcom.arrecadacao.pagamento.Pagamento as
			// pagamento " + " inner join pagamento.cliente as cliente " +
			// condicionais + "
			// order by pagamento.documentoTipo.id,pagamento.dataPagamento " + "
			// ";

			retorno = session.createSQLQuery(sql).addScalar("tipo",
					Hibernate.STRING).addScalar("idLocalidade",
					Hibernate.INTEGER).addScalar("nomeLocalidade",
					Hibernate.STRING)
					.addScalar("idGerencia", Hibernate.INTEGER).addScalar(
							"nomeGerencia", Hibernate.STRING).addScalar(
							"idImovel", Hibernate.INTEGER).addScalar(
							"idCliente", Hibernate.INTEGER).addScalar(
							"nomeCliente", Hibernate.STRING).addScalar(
							"nomeArrecadador", Hibernate.STRING).addScalar(
							"dataPagamento", Hibernate.DATE).addScalar(
							"anoMesPagamento", Hibernate.INTEGER).addScalar(
							"tipoDebito", Hibernate.STRING).addScalar(
							"valorDocumento", Hibernate.BIG_DECIMAL).addScalar(
							"valorPagamento", Hibernate.BIG_DECIMAL).addScalar(
							"idSituacaoPagamento", Hibernate.INTEGER)
					.addScalar("situacaoPagamento", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancarioRelatorio(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal
            )
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal );

			hql = "SELECT pagto.id, loc.id, loc.descricao, "
					+ "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
					+ "cliArrec.nome, pagto.dataPagamento, "
					+ "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
					+ "conta.valorAgua, conta.valorEsgoto, conta.debitos, "
					+ "conta.valorCreditos, dbcb.valorDebito, dbcb.numeroPrestacaoDebito, "
					+ "dbcb.numeroPrestacaoCobradas, gpag.valorDebito, pagto.valorPagamento, "
					+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id "
					+ "FROM Pagamento pagto "
					+ "INNER JOIN pagto.localidade loc "
					+ "INNER JOIN loc.gerenciaRegional gr "
					+ "INNER JOIN pagto.avisoBancario avbc "
					+ "INNER JOIN avbc.arrecadador arrec "
					+ "INNER JOIN arrec.cliente cliArrec "
					+ "INNER JOIN pagto.documentoTipo doctoTp "
					+ "LEFT JOIN pagto.imovel imov "
					+ "LEFT JOIN pagto.cliente cli "
					+ "LEFT JOIN pagto.debitoTipo dbtp "
					+ "LEFT JOIN pagto.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN pagto.guiaPagamento gpag "
					+ "LEFT JOIN pagto.debitoACobrarGeral dbcbGeral "
					+ "LEFT JOIN dbcbGeral.debitoACobrar dbcb "
					+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
					+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem "
					+ "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
					+ "LEFT JOIN pagto.arrecadacaoForma arrecForma "
					+ condicionais + " ORDER BY loc.id, imov.id, "
					+ " pagto.anoMesReferenciaPagamento, pagto.dataPagamento ";
			// hql = " select distinct pagamento "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + " inner join pagamento.avisoBancario as avisoBancario "
			// + condicionais + " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadadorRelatorio(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = "SELECT pagto.id, loc.id, loc.descricao, "
					+ "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
					+ "cliArrec.nome, pagto.dataPagamento, "
					+ "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
					+ "conta.valorAgua, conta.valorEsgoto, conta.debitos, "
					+ "conta.valorCreditos, dbcb.valorDebito, dbcb.numeroPrestacaoDebito, "
					+ "dbcb.numeroPrestacaoCobradas, gpag.valorDebito, pagto.valorPagamento, "
					+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id "
					+ "FROM Pagamento pagto "
					+ "INNER JOIN pagto.localidade loc "
					+ "INNER JOIN loc.gerenciaRegional gr "
					+ "INNER JOIN pagto.avisoBancario avbc "
					+ "INNER JOIN avbc.arrecadador arrec "
					+ "INNER JOIN arrec.cliente cliArrec "
					+ "INNER JOIN pagto.documentoTipo doctoTp "
					+ "LEFT JOIN pagto.imovel imov "
					+ "LEFT JOIN pagto.cliente cli "
					+ "LEFT JOIN pagto.debitoTipo dbtp "
					+ "LEFT JOIN pagto.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN pagto.guiaPagamento gpag "
					+ "LEFT JOIN pagto.debitoACobrarGeral dbcbGeral "
					+ "LEFT JOIN dbcbGeral.debitoACobrar dbcb "
					+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
					+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem "
					+ "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
					+ "LEFT JOIN pagto.arrecadacaoForma arrecForma "
					+ condicionais + " ORDER BY loc.id, imov.id, "
					+ " dbtp.id, pagto.dataPagamento ";
			// hql = " select distinct pagamento "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + " inner join pagamento.arrecadadorMovimentoItem as
			// arrecadadorMovimentoItem "
			// + " inner join arrecadadorMovimentoItem.arrecadadorMovimento as
			// arrecadadorMovimento "
			// + condicionais
			// + " order by pagamento.localidade.id, pagamento.imovel.id, "
			// + " pagamento.debitoTipo.id, pagamento.dataPagamento "
			// + " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoLocalidadeRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = "SELECT pagto.id, " + //0
					"loc.id, " //1
					+ "loc.descricao, "//2
					+ "gr.id, " //3
					+ "gr.nome, " //4
					+ "imov.id, " //5
					+ "cli.id, " //6
					+ "cli.nome, "//7
					+ "cliArrec.nome, "//8
					+ "pagto.dataPagamento, "//9
					+ "pagto.anoMesReferenciaPagamento, "//10
					+ "dbtp.descricao, "//11
					+ "conta.valorAgua, " //12
					+ "conta.valorEsgoto, " //13
					+ "conta.debitos, "//14
					+ "conta.valorCreditos, "//15
					+ "dbcb.valorDebito, " //16
					+ "dbcb.numeroPrestacaoDebito, "//17
					+ "dbcb.numeroPrestacaoCobradas, " //18
					+ "gpag.valorDebito, " //19
					+ "pagto.valorPagamento, "//20
					+ "pagtoSitAtual.id, " //21
					+ "pagtoSitAtual.descricao, "//22
					+ "doctoTp.id, "//23
					+ "conta.valorImposto " //24
					+ "FROM Pagamento pagto "
					+ "INNER JOIN pagto.localidade loc "
					+ "INNER JOIN loc.gerenciaRegional gr "
					+ "INNER JOIN pagto.avisoBancario avbc "
					+ "INNER JOIN avbc.arrecadador arrec "
					+ "INNER JOIN arrec.cliente cliArrec "
					+ "INNER JOIN pagto.documentoTipo doctoTp "
					+ "LEFT JOIN pagto.imovel imov "
					+ "LEFT JOIN pagto.cliente cli "
					+ "LEFT JOIN pagto.debitoTipo dbtp "
					+ "LEFT JOIN pagto.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN pagto.guiaPagamento gpag "
					+ "LEFT JOIN pagto.debitoACobrarGeral dbcbGeral "
					+ "LEFT JOIN dbcbGeral.debitoACobrar dbcb "
					+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
					+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem "
					+ "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
					+ "LEFT JOIN pagto.arrecadacaoForma arrecForma "
					+ condicionais + " ORDER BY loc.id, imov.id, "
					+ " dbtp.id, pagto.dataPagamento ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoMovimentoArrecadadorCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, 
            String valorPagamentoInicial, 
            String valorPagamentoFinal ) throws ErroRepositorioException {

		int retorno = 0;
		Object pagamentoMovimentoArrecadadorCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal);

			hql = " select count(pagamento.id) "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ condicionais + " ";

			pagamentoMovimentoArrecadadorCount = session.createQuery(hql)
					.setMaxResults(1).uniqueResult();

			if (pagamentoMovimentoArrecadadorCount != null) {
				retorno = (Integer) pagamentoMovimentoArrecadadorCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoLocalidadeCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, 
            String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ErroRepositorioException {

		int retorno = 0;
		Object pagamentoLocalidadeCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal );

			hql = " select count(pagamento.id) "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ condicionais + " ";

			pagamentoLocalidadeCount = session.createQuery(hql)
					.setMaxResults(1).uniqueResult();

			if (pagamentoLocalidadeCount != null) {
				retorno = (Integer) pagamentoLocalidadeCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer verificarExistenciaGuiaDevolucao(Integer idGuiaDevolucao)
			throws ErroRepositorioException {
		// cria a variável que vai armazenar a coleção pesquisada

		Integer retorno = null;

		// cria a variável que vai armazenar a coleção pesquisada
		// Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select guiaDevolucao.id "
					+ "from GuiaDevolucao guiaDevolucao "
					+ "where guiaDevolucao.id = :idGuiaDevolucao";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idGuiaDevolucao", idGuiaDevolucao.intValue())
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa os avisos bancários para o relatório através das opções
	 * selecionadas no Filtrar Aviso Bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 04/09/06
	 * 
	 * @return Collection<AvisoBancarioRelatorioHelper>
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarAvisoBancarioRelatorio(
			AvisoBancarioHelper avisoBancarioHelper)
			throws ErroRepositorioException {

		String consulta = "";

		Collection retorno = null;

		// Short arrecadadorCodAgente = avisoBancarioHelper
		// .getCodigoAgenteArrecadador();
		// Date dataLancamentoInicio = avisoBancarioHelper
		// .getDataLancamentoInicial();
		// Date dataLancamentoFim =
		// avisoBancarioHelper.getDataLancamentoFinal();
		// Short indicadorCreditoDebito = avisoBancarioHelper
		// .getIndicadorCreditoDebito();
		// Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
		// Integer idMovimento =
		// avisoBancarioHelper.getIdMovimentoArrecadador();
		// Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper
		// .getDataPrevistaInicial();
		// Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper
		// .getDataPrevistaFinal();
		// Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper
		// .getDataRealizadaInicial();
		// Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper
		// .getDataRealizadaFinal();
		// int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper
		// .getAnoMesReferenciaArrecadacaoInicial();
		// int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper
		// .getAnoMesReferenciaArrecadacaoFinal();
		// BigDecimal valorRealizadoInicial = avisoBancarioHelper
		// .getValorRealizadoInicial();
		// BigDecimal valorRealizadoFinal = avisoBancarioHelper
		// .getValorRealizadoFinal();
		// BigDecimal valorPrevistoInicial = avisoBancarioHelper
		// .getValorPrevistoInicial();
		// BigDecimal valorPrevistoFinal = avisoBancarioHelper
		// .getValorPrevistoFinal();
		// String tipoAviso = avisoBancarioHelper.getTipoAviso();

		consulta = "select ab.id, c.nomeAbreviado, ab.dataLancamento, ab.numeroSequencial, "
				+ "ab.indicadorCreditoDebito, ab.numeroDocumento, b.descricaoAbreviada, "
				+ "ag.codigoAgencia, cb.numeroConta, ab.dataRealizada, "
				+ "ab.valorArrecadacaoCalculado, ab.valorDevolucaoCalculado, ab.valorRealizado "
				+ "from AvisoBancario ab "
				+ "inner join ab.arrecadador arrec "
				+ "inner join ab.contaBancaria cb "
				+ "inner join cb.agencia ag "
				+ "inner join ag.banco b "
				+ "inner join arrec.cliente c where ";

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		consulta += " ab.id = "
				+ avisoBancarioHelper.getAvisoBancario().getId().toString()
				+ " and ";

		// if (arrecadadorCodAgente != null) {
		// consulta += " arrec.codigoAgente = " + arrecadadorCodAgente
		// + " and";
		// }
		//
		// if ((dataLancamentoInicio != null) && (dataLancamentoFim != null)) {
		// String dataLancamentoInicialFormatada = Util
		// .recuperaAnoMesDiaDaData(dataLancamentoInicio);
		// dataLancamentoInicialFormatada = "'"
		// + dataLancamentoInicialFormatada.substring(0, 4) + "-"
		// + dataLancamentoInicialFormatada.substring(4, 6) + "-"
		// + dataLancamentoInicialFormatada.substring(6, 8) + "'";
		//
		// String dataLancamentoFinalFormatada = Util
		// .recuperaAnoMesDiaDaData(dataLancamentoFim);
		//
		// dataLancamentoFinalFormatada = "'"
		// + dataLancamentoFinalFormatada.substring(0, 4) + "-"
		// + dataLancamentoFinalFormatada.substring(4, 6) + "-"
		// + dataLancamentoFinalFormatada.substring(6, 8) + "'";
		//
		// consulta += " ab.dataLancamento between "
		// + dataLancamentoInicialFormatada + " and "
		// + dataLancamentoFinalFormatada + " and";
		//
		// }
		//
		// if (indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3) {
		// consulta += " ab.indicadorCreditoDebito = "
		// + indicadorCreditoDebito + " and";
		// }
		//
		// if (idContaBancaria != null) {
		// consulta += " cb.id = " + idContaBancaria + " and";
		// }
		//
		// if (idMovimento != null) {
		// consulta += " ab.arrecadadorMovimento.id = " + idMovimento + " and";
		// }
		//
		// if ((dataPrevisaoCreditoDebitoInicio != null)
		// && (dataPrevisaoCreditoDebitoFim != null)) {
		//
		// String dataPrevisaoCreditoDebitoInicialFormatada = Util
		// .recuperaAnoMesDiaDaData(dataPrevisaoCreditoDebitoInicio);
		// dataPrevisaoCreditoDebitoInicialFormatada = "'"
		// + dataPrevisaoCreditoDebitoInicialFormatada.substring(0, 4)
		// + "-"
		// + dataPrevisaoCreditoDebitoInicialFormatada.substring(4, 6)
		// + "-"
		// + dataPrevisaoCreditoDebitoInicialFormatada.substring(6, 8)
		// + "'";
		//
		// String dataPrevisaoCreditoDebitoFinalFormatada = Util
		// .recuperaAnoMesDiaDaData(dataPrevisaoCreditoDebitoFim);
		//
		// dataPrevisaoCreditoDebitoFinalFormatada = "'"
		// + dataPrevisaoCreditoDebitoFinalFormatada.substring(0, 4)
		// + "-"
		// + dataPrevisaoCreditoDebitoFinalFormatada.substring(4, 6)
		// + "-"
		// + dataPrevisaoCreditoDebitoFinalFormatada.substring(6, 8)
		// + "'";
		//
		// consulta += " ab.dataPrevista between "
		// + dataPrevisaoCreditoDebitoInicialFormatada + " and "
		// + dataPrevisaoCreditoDebitoFinalFormatada + " and";
		//
		// }
		//
		// if ((dataRealizacaoCreditoDebitoInicio != null)
		// && (dataRealizacaoCreditoDebitoFim != null)) {
		//
		// String dataRealizacaoCreditoDebitoInicialFormatada = Util
		// .recuperaAnoMesDiaDaData(dataRealizacaoCreditoDebitoInicio);
		// dataRealizacaoCreditoDebitoInicialFormatada = "'"
		// + dataRealizacaoCreditoDebitoInicialFormatada.substring(0,
		// 4)
		// + "-"
		// + dataRealizacaoCreditoDebitoInicialFormatada.substring(4,
		// 6)
		// + "-"
		// + dataRealizacaoCreditoDebitoInicialFormatada.substring(6,
		// 8) + "'";
		//
		// String dataRealizacaoCreditoDebitoFinalFormatada = Util
		// .recuperaAnoMesDiaDaData(dataRealizacaoCreditoDebitoFim);
		//
		// dataRealizacaoCreditoDebitoFinalFormatada = "'"
		// + dataRealizacaoCreditoDebitoFinalFormatada.substring(0, 4)
		// + "-"
		// + dataRealizacaoCreditoDebitoFinalFormatada.substring(4, 6)
		// + "-"
		// + dataRealizacaoCreditoDebitoFinalFormatada.substring(6, 8)
		// + "'";
		//
		// consulta += " ab.dataRealizada between "
		// + dataRealizacaoCreditoDebitoInicio + " and "
		// + dataRealizacaoCreditoDebitoFim + " and";
		//
		// }
		//
		// if ((anoMesReferenciaArrecadacaoInicial != 0)
		// && (anoMesReferenciaArrecadacaoFinal != 0)) {
		// consulta += " ab.anoMesReferenciaArrecadacao between "
		// + anoMesReferenciaArrecadacaoInicial + " and "
		// + anoMesReferenciaArrecadacaoFinal + " and";
		// }
		//
		// if ((valorPrevistoInicial != null) && (valorPrevistoFinal != null)) {
		// consulta += " ab.valorPrevisto between " + valorPrevistoInicial
		// + " and " + valorPrevistoFinal + " and";
		// }
		//
		// if ((valorRealizadoInicial != null) && (valorRealizadoFinal != null))
		// {
		// consulta += " ab.valorRealizado between " + valorRealizadoInicial
		// + " and " + valorRealizadoFinal + " and";
		//
		// }
		// BigDecimal valorSomatorioAcertoCredito = this
		// .pesquisarSomatorioAvisoAcerto(1, avisoBancarioHelper
		// .getAvisoBancario().getId(), 1);
		// BigDecimal valorSomatorioAcertoDebito = this
		// .pesquisarSomatorioAvisoAcerto(2, avisoBancarioHelper
		// .getAvisoBancario().getId(), 1);
		//
		// BigDecimal valorSomatorioAcertoCredito2 = this
		// .pesquisarSomatorioAvisoAcerto(1, avisoBancarioHelper
		// .getAvisoBancario().getId(), 2);
		// BigDecimal valorSomatorioAcertoDebito2 = this
		// .pesquisarSomatorioAvisoAcerto(2, avisoBancarioHelper
		// .getAvisoBancario().getId(), 2);
		// if (valorSomatorioAcertoCredito == null) {
		// valorSomatorioAcertoCredito = new BigDecimal("0.00");
		// }
		// if (valorSomatorioAcertoDebito == null) {
		// valorSomatorioAcertoDebito = new BigDecimal("0.00");
		// }
		//
		// if (valorSomatorioAcertoCredito2 == null) {
		// valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
		// }
		// if (valorSomatorioAcertoDebito2 == null) {
		// valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
		// }
		// // tipoAviso
		// if (tipoAviso != null) {
		// if (tipoAviso.equalsIgnoreCase("3")) {
		// // FECHADO
		// consulta += " (ab.valorArrecadacaoCalculado = "
		// + " ((ab.valorArrecadacaoInformado + "
		// + valorSomatorioAcertoCredito + " ) " + " - "
		// + valorSomatorioAcertoDebito + ")" + " ) " + " and "
		// + "(ab.valorDevolucaoCalculado = "
		// + " ((ab.valorDevolucaoInformado + "
		// + valorSomatorioAcertoCredito2 + " ) " + " - "
		// + valorSomatorioAcertoDebito2 + ")" + " )) and ";
		// } else if (tipoAviso.equalsIgnoreCase("2")) {
		// // ABERTO
		// consulta += " (ab.valorArrecadacaoCalculado <> "
		// + " ((ab.valorArrecadacaoInformado + "
		// + valorSomatorioAcertoCredito + " ) " + " - "
		// + valorSomatorioAcertoDebito + ")" + " ) " + " or "
		// + "(ab.valorDevolucaoCalculado <> "
		// + " ((ab.valorDevolucaoInformado + "
		// + valorSomatorioAcertoCredito2 + " ) " + " - "
		// + valorSomatorioAcertoDebito2 + ")" + " )) and ";
		// }
		// }

		consulta = Util.removerUltimosCaracteres(consulta, 4)
				+ " order by arrec.codigoAgente, ab.dataLancamento";

		// Consulta
		try {
			retorno = session.createQuery(consulta).list();
			return retorno;

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisa os avisos deduções de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 05/09/06
	 * 
	 * @return Collection<DeducoesRelatorioHelper>
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarAvisoDeducoesAvisoBancarioRelatorio(
			Integer idAvisoBancario) throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select dt.descricaoAbreviado, ad.valorDeducao "
					+ "from AvisoDeducoes ad "
					+ "inner join ad.deducaoTipo dt "
					+ "inner join ad.avisoBancario ab "
					+ "where ab.id = :idAvisoBancario";

			retorno = session.createQuery(consulta).setInteger(
					"idAvisoBancario", idAvisoBancario.intValue()).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa os avisos acertos de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 05/09/06
	 * 
	 * @return Collection<AcertosRelatorioHelper>
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarAvisoAcertosAvisoBancarioRelatorio(
			Integer idAvisoBancario) throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada

		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select b.descricaoAbreviada, ag.codigoAgencia, cb.numeroConta, "
					+ "aa.indicadorCreditoDebito, aa.dataAcerto, aa.valorAcerto "
					+ "from AvisoAcerto aa "
					+ "inner join aa.contaBancaria cb "
					+ "inner join cb.agencia ag "
					+ "inner join ag.banco b "
					+ "inner join aa.avisoBancario ab "
					+ "where ab.id = :idAvisoBancario";

			retorno = session.createQuery(consulta).setInteger(
					"idAvisoBancario", idAvisoBancario.intValue()).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa dos dados diários da arrecadação
	 * 
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Rafael Santos
	 * @date 05/09/2006
	 * 
	 * @return
	 */
	public Collection filtrarDadosDiariosArrecadacao(
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String idLocalidade, String idGerenciaRegional,
			String idArrecadador, String idElo, String[] idsImovelPerfil,
			String[] idsLigacaoAgua, String[] idsLigacaoEsgoto,
			String[] idsDocumentosTipos, String[] idsCategoria,
			String[] idsEsferaPoder) throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		// Collection<ArrecadacaoDadosDiarios> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this
					.criarCondicionaisDadosDiariosArrecadacao(
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							idLocalidade, idGerenciaRegional, idArrecadador,
							idElo, idsImovelPerfil, idsLigacaoAgua,
							idsLigacaoEsgoto, idsDocumentosTipos, idsCategoria,
							idsEsferaPoder);

			hql = " select distinct "
					+ "arrecadacaoDadosDiarios.anoMesReferenciaArrecadacao, "
					+ // 0
					"arrecadacaoDadosDiarios.dataPagamento, "
					+ // 1
					"sum(arrecadacaoDadosDiarios.quantidadePagamentos), "
					+ // 2
					"sum(arrecadacaoDadosDiarios.valorPagamentos), "
					+ // 3
					"sum(arrecadacaoDadosDiarios.quantidadeDocumentos), "
					+ // 4
					"arrecadacaoDadosDiarios.arrecadador.id, "
					+ // 5
					"arrecadacaoDadosDiarios.documentoTipo.id, "
					+ // 6
					"arrecadacaoDadosDiarios.imovelPerfil.id, "
					+ // 7
					"arrecadacaoDadosDiarios.gerenciaRegional.id, "
					+ // 8
					"arrecadacaoDadosDiarios.localidade.id, "
					+ // 9
					"arrecadacaoDadosDiarios.categoria.id, "
					+ // 10
					// "localidade.descricao, " + //11
					// "gerenciaRegional.nome, " + //12
					// "gerenciaRegional.nomeAbreviado, " + //13
					// "documentoTipo.descricaoDocumentoTipo, " + //14
					// "categoria.descricao, " + //15
					// "cliente.nome," + //16
					// "imovelPerfil.descricao," + //17
					"arrecadacaoDadosDiarios.localidade.localidade.id, "
					+ // 18
					"arrecadacaoDadosDiarios.unidadeNegocio.id,  " // 19
					+ "arrecadacaoDadosDiarios.arrecadacaoForma.id,  " //
					+ "arrecadacaoDadosDiarios.documentoTipoAgregador.id  " //
					// "elo.id " //19
					+ " from ArrecadacaoDadosDiarios arrecadacaoDadosDiarios "
					// "left join arrecadacaoDadosDiarios.localidade localidade
					// " +
					// "left join localidade.localidade elo " +
					// "left join arrecadacaoDadosDiarios.gerenciaRegional
					// gerenciaRegional " +
					// "left join arrecadacaoDadosDiarios.documentoTipo
					// documentoTipo " +
					// "left join arrecadacaoDadosDiarios.categoria categoria "
					// +
					// "left join arrecadacaoDadosDiarios.arrecadador
					// arrecadador " +
					// "left join arrecadador.cliente cliente " +
					// "left join arrecadacaoDadosDiarios.imovelPerfil
					// imovelPerfil "
					+ condicionais
					+ " group by arrecadacaoDadosDiarios.anoMesReferenciaArrecadacao,"
					+ "arrecadacaoDadosDiarios.arrecadador.id,"
					+
					// "cliente.nome, " +
					"arrecadacaoDadosDiarios.gerenciaRegional.id,"
					+
					// "gerenciaRegional.nome, " +
					// "gerenciaRegional.nomeAbreviado, " +
					"arrecadacaoDadosDiarios.localidade.id,"
					+
					// "localidade.descricao," +
					// "elo.descricao, " +
					"arrecadacaoDadosDiarios.localidade.localidade.id, "
					+ "arrecadacaoDadosDiarios.imovelPerfil.id,"
					+
					// "imovelPerfil.descricao, " +
					"arrecadacaoDadosDiarios.categoria.id,"
					+
					// "categoria.descricao, " +
					"arrecadacaoDadosDiarios.documentoTipo.id,"
					+
					// "documentoTipo.descricaoDocumentoTipo, " +
					 "arrecadacaoDadosDiarios.arrecadacaoForma.id," +
					"arrecadacaoDadosDiarios.dataPagamento,"
					+ "arrecadacaoDadosDiarios.unidadeNegocio.id, "
					+ "arrecadacaoDadosDiarios.documentoTipoAgregador.id  "
					+ " order by arrecadacaoDadosDiarios.anoMesReferenciaArrecadacao, "
					+ "arrecadacaoDadosDiarios.dataPagamento ";
			// "cliente.nome," +
			// "gerenciaRegional.nome, " +
			// "elo.descricao, " +
			// "localidade.descricao ";

			// "categoria.id, " +
			// "imovelPerfil.descricao, " +
			// "documentoTipo.descricaoDocumentoTipo ";

			// + " order by
			// arrecadacaoDadosDiarios.anoMesReferenciaArrecadacao,arrecadacaoDadosDiarios.dataPagamento,categoria.id
			// ";
			
			retorno = session.createQuery(hql).list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa dos dados diários de devolucao
	 * 
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Francisco do Nascimento
	 * @date 21/07/2008
	 * 
	 * @return
	 */
	public Collection filtrarDevolucaoDadosDiarios(
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String idLocalidade, String idGerenciaRegional,
			String idArrecadador, String idElo, String[] idsImovelPerfil,
			String[] idsLigacaoAgua, String[] idsLigacaoEsgoto,
			String[] idsDocumentosTipos, String[] idsCategoria,
			String[] idsEsferaPoder) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this
					.criarCondicionaisDadosDiariosDevolucao(
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							idLocalidade, idGerenciaRegional, idArrecadador,
							idElo, idsImovelPerfil, idsLigacaoAgua,
							idsLigacaoEsgoto, idsDocumentosTipos, idsCategoria,
							idsEsferaPoder);

			hql = " select distinct "
					+ "devolucaoDadosDiarios.anoMesReferencia, " 	// 0
					+ "devolucaoDadosDiarios.dataDevolucao, "		// 1
					+ "sum(devolucaoDadosDiarios.quantidadeDevolucoes), " 	// 2
					+ "sum(devolucaoDadosDiarios.valorDevolucoes), " 		// 3
					+ "sum(devolucaoDadosDiarios.quantidadeDocumentos), "	// 4
					+ "devolucaoDadosDiarios.arrecadador.id, "				// 5
					+ "devolucaoDadosDiarios.documentoTipo.id, "			// 6
					+ "devolucaoDadosDiarios.imovelPerfil.id, "				// 7
					+ "devolucaoDadosDiarios.gerenciaRegional.id, "			// 8
					+ "devolucaoDadosDiarios.localidade.id, "				// 9
					+ "devolucaoDadosDiarios.categoria.id, "				// 10
					+ "devolucaoDadosDiarios.localidade.localidade.id, "	// 11
					+ "devolucaoDadosDiarios.unidadeNegocio.id, " 			// 12
					+ "devolucaoDadosDiarios.arrecadacaoForma.id, " 		// 13
					+ "devolucaoDadosDiarios.devolucaoTipo, " 				// 14
					+ "devolucaoDadosDiarios.documentoTipoAgregador.id  " 				// 14
					+ " from DevolucaoDadosDiarios devolucaoDadosDiarios "					
					+ condicionais
					+ " group by devolucaoDadosDiarios.anoMesReferencia, "
					+ "devolucaoDadosDiarios.arrecadador.id, "
					+ "devolucaoDadosDiarios.gerenciaRegional.id, "
					+ "devolucaoDadosDiarios.localidade.id, "
					+ "devolucaoDadosDiarios.localidade.localidade.id, "
					+ "devolucaoDadosDiarios.imovelPerfil.id, "
					+ "devolucaoDadosDiarios.categoria.id, "
					+ "devolucaoDadosDiarios.documentoTipo.id, "
					+ "devolucaoDadosDiarios.dataDevolucao, "
					+ "devolucaoDadosDiarios.unidadeNegocio.id, "
					+ "devolucaoDadosDiarios.devolucaoTipo, " 
					+ "devolucaoDadosDiarios.arrecadacaoForma.id, " 
					+ "devolucaoDadosDiarios.documentoTipoAgregador.id  "
					+ " order by devolucaoDadosDiarios.anoMesReferencia, "
					+ "devolucaoDadosDiarios.dataDevolucao ";
			
//			System.out.println("inicio=" + new Date().toString());
			retorno = session.createQuery(hql).list();
//			System.out.println("Fim=" + new Date().toString());
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0333] Consultar Dados Diários da Arrecadação
	 * 
	 * Método para filtrar os dados diários para qualquer aba da funcionalidade
	 * 
	 * @author Francisco do Nascimento
	 * @date 12/11/2008
	 *
	 * @param filtro
	 * @return
	 * @throws ErroRepositorioException 
	 */
	public Collection filtrarDadosDiariosArrecadacao(FiltroConsultarDadosDiariosArrecadacao filtro) throws ErroRepositorioException{
		Collection retorno = new ArrayList();
		
		Session session = HibernateUtil.getSession();
		
		String 	SQLGeral = "SELECT ";
		String	SQLConsultaADD = "SELECT ";
		String 	SQLConsultaADD_FROM = " FROM arrecadacao.arrec_dados_diarios ad ";
		String	SQLConsultaDDD1 = "SELECT ";
		String 	SQLConsultaDDD1_FROM = " FROM ARRECADACAO.DEVOLUCAO_DADOS_DIARIOS dd ";
		Type tipo= null;
		String campoGroupByADD = null;
		String campoGroupByDDD = null;
		
		switch (filtro.getAgrupamento()) {
		case ANO_MES:
			
			SQLConsultaADD += " ad.ardd_amreferenciaarrecadacao ";
			SQLConsultaDDD1 += " dd.dvdd_amreferenciaarrecadacao ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.ardd_amreferenciaarrecadacao ";
			campoGroupByDDD = " dd.dvdd_amreferenciaarrecadacao ";		
			break;
		case ARRECADADOR:
			
			SQLConsultaADD += " ad.arrc_id ";
			SQLConsultaDDD1 += " dd.arrc_id ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.arrc_id ";
			campoGroupByDDD = " dd.arrc_id ";
			break;
		case CATEGORIA:
			
			SQLConsultaADD += " ad.catg_id ";
			SQLConsultaDDD1 += " dd.catg_id ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.catg_id ";
			campoGroupByDDD = " dd.catg_id ";			
			break;			
		case ELO:
			
			SQLConsultaADD += " loc.loca_cdelo ";
			SQLConsultaDDD1 += " loc.loca_cdelo ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " loc.loca_cdelo ";
			campoGroupByDDD = " loc.loca_cdelo ";
			break;			
		case FORMA_ARRECADACAO:

			SQLConsultaADD += " ad.arfm_id ";
			SQLConsultaDDD1 += " dd.arfm_id ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.arfm_id ";
			campoGroupByDDD = " dd.arfm_id ";
			break;			
		case GERENCIA_REGIONAL:

			SQLConsultaADD += " ad.greg_id ";
			SQLConsultaDDD1 += " dd.greg_id ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.greg_id ";
			campoGroupByDDD = " dd.greg_id ";
			break;			
		case LOCALIDADE:
			
			SQLConsultaADD += " ad.loca_id ";
			SQLConsultaDDD1 += " dd.loca_id ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.loca_id ";
			campoGroupByDDD = " dd.loca_id ";
			break;			
		case PERFIL:
			
			SQLConsultaADD += " ad.iper_id ";
			SQLConsultaDDD1 += " dd.iper_id ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.iper_id ";
			campoGroupByDDD = " dd.iper_id ";
			break;			
		case TIPO_DOCUMENTO:

			SQLConsultaADD += " ad.dotp_id ";
			SQLConsultaDDD1 += " dd.dotp_id ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.dotp_id ";
			campoGroupByDDD = " dd.dotp_id ";
			break;			
		case TIPO_DOCUMENTO_AGREGADOR:
			
			SQLConsultaADD += " ad.dotp_idagregador ";
			SQLConsultaDDD1 += " dd.dotp_idagregador ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.dotp_idagregador ";
			campoGroupByDDD = " dd.dotp_idagregador ";
			break;			
		case UNIDADE_NEGOCIO:

			SQLConsultaADD += " ad.uneg_id ";
			SQLConsultaDDD1 += " dd.uneg_id ";
			tipo = Hibernate.INTEGER;
			campoGroupByADD = " ad.uneg_id ";
			campoGroupByDDD = " dd.uneg_id ";
			break;
		case DATA:
			
			SQLConsultaADD += " ad.ardd_dtpagamento ";
			SQLConsultaDDD1 += " dd.dvdd_dtdevolucao ";
			tipo = Hibernate.DATE;
			campoGroupByADD = " ad.ardd_dtpagamento ";
			campoGroupByDDD = " dd.dvdd_dtdevolucao ";
		}
		
		// definindo somatorios para o select
		SQLConsultaADD += " as itemADD, sum(ad.ardd_qtdocumentos) as qtdDocumentos, sum(ad.ardd_qtpagamentos) as qtdPagamentos, " +
				"sum(ad.ardd_vlpagamentos) as debitos ";
		
		SQLConsultaDDD1 += 
			" as itemDDD, sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDescontos, " +
			"  sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDevolucoes, " +
			"  sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDescontos, " +
			"  sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDevolucoes, " +
			"  sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDescontos, " +
			"  sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDevolucoes ";
		
		if (filtro.isAgruparPorArrecadador()) {
			SQLConsultaADD += " ,c.clie_nmcliente as arrecadador "; 
			SQLConsultaDDD1 += " ,c.clie_nmcliente as arrecadador2 "; 
		}
		
		// adicionando as tabelas para os joins
		if (filtro.getAgrupamento().equals(FiltroConsultarDadosDiariosArrecadacao.GROUP_BY.ELO)
				|| (filtro.getIdElo() != null && !filtro.getIdElo().equals(""))){
			SQLConsultaADD_FROM += " LEFT JOIN CADASTRO.LOCALIDADE LOC ON AD.LOCA_ID = LOC.LOCA_ID ";
			SQLConsultaDDD1_FROM += " LEFT JOIN CADASTRO.LOCALIDADE LOC ON DD.LOCA_ID = LOC.LOCA_ID ";
		}
			
		// acrescentando a parte from
		SQLConsultaADD += SQLConsultaADD_FROM;
		SQLConsultaDDD1 += SQLConsultaDDD1_FROM;
		
		if (filtro.isAgruparPorArrecadador()) {
			SQLConsultaADD += 
					" INNER JOIN arrecadacao.arrecadador ar on ar.arrc_id = ad.arrc_id "
				   +" INNER JOIN cadastro.cliente c on c.clie_id = ar.clie_id ";
			
			SQLConsultaDDD1 += 
					" INNER JOIN arrecadacao.arrecadador ar on ar.arrc_id = dd.arrc_id "
				   +" INNER JOIN cadastro.cliente c on c.clie_id = ar.clie_id ";
		}
		
		// metodo gera as condicoes de acordo com os valores preenchidos no filtro
		SQLConsultaADD += montarWhereFiltrarDadosDiariosArrecadacao(filtro, "ad");
		SQLConsultaDDD1 += montarWhereFiltrarDadosDiariosArrecadacao(filtro, "dd");
		
		// retirar o and do final, caso exista
		if (SQLConsultaADD.lastIndexOf("and") >= (SQLConsultaADD.length() - 4)){
			SQLConsultaADD  = Util.removerUltimosCaracteres(SQLConsultaADD , 4);
		}		
		
		// retirar o and do final, caso exista
		if (SQLConsultaDDD1.lastIndexOf("and") >= (SQLConsultaDDD1.length() - 4)){
			SQLConsultaDDD1  = Util.removerUltimosCaracteres(SQLConsultaDDD1, 4);
		}
		
		SQLConsultaADD += " group by " + campoGroupByADD;
		SQLConsultaDDD1 += " group by " + campoGroupByDDD;
		
		if (filtro.isAgruparPorArrecadador()) {
			SQLConsultaADD += " , c.clie_nmcliente";
			SQLConsultaDDD1 += " , c.clie_nmcliente";
			SQLGeral += " coalesce(ardd.itemADD, ddd1.itemDDD) as campoAgrupador, "
					+ "sum(COALESCE(ARDD.qtdDocumentos,0) + COALESCE(DDD1.qtdDocumentosDescontos,0) + COALESCE(DDD1.qtdDocumentosDevolucoes,0)) as qtdDocumentos, "
					+ "sum(COALESCE(ARDD.qtdPagamentos,0) + COALESCE(DDD1.qtdPagamentosDescontos,0) + COALESCE(DDD1.qtdPagamentosDevolucoes,0)) as qtdPagamentos, " 
					+ "sum(COALESCE(ARDD.debitos, 0)) as debitos, "
					+ "sum(COALESCE(DDD1.valorDescontos, 0)) as descontos, " 
					+ "sum(COALESCE(DDD1.valorDevolucoes, 0)) as devolucoes, "
					+ "ardd.arrecadador as arrecadador "
					+ "from (" + SQLConsultaADD + ") ARDD " +
					" full join (" + SQLConsultaDDD1 + ") DDD1 on (ARDD.itemADD = DDD1.itemDDD and ARDD.arrecadador = DDD1.arrecadador2) " +
					" group by arrecadador, campoAgrupador " +
					" order by campoAgrupador ";
		} else {
			SQLGeral += " coalesce(ardd.itemADD, ddd1.itemDDD) as campoAgrupador, (COALESCE(ARDD.qtdDocumentos,0) + COALESCE(DDD1.qtdDocumentosDescontos,0) " +
					"+ COALESCE(DDD1.qtdDocumentosDevolucoes,0)) as qtdDocumentos, (COALESCE(ARDD.qtdPagamentos,0) + " +
					"COALESCE(DDD1.qtdPagamentosDescontos,0) + COALESCE(DDD1.qtdPagamentosDevolucoes,0)) as qtdPagamentos, " +
					"COALESCE(ARDD.debitos, 0) as debitos, COALESCE(DDD1.valorDescontos, 0) as descontos, " +
					"COALESCE(DDD1.valorDevolucoes, 0) as devolucoes from (" + SQLConsultaADD + ") ARDD " +
					" full join (" + SQLConsultaDDD1 + ") DDD1 on (ARDD.itemADD = DDD1.itemDDD) " +
					" order by campoAgrupador ";
		}
		 

		try {
			SQLQuery consulta = session.createSQLQuery(SQLGeral)
					.addScalar("campoAgrupador", tipo)
					.addScalar("qtdDocumentos", Hibernate.INTEGER)
					.addScalar("qtdPagamentos", Hibernate.INTEGER)
					.addScalar("debitos", Hibernate.BIG_DECIMAL)
					.addScalar("descontos", Hibernate.BIG_DECIMAL)
					.addScalar("devolucoes", Hibernate.BIG_DECIMAL);
			if (filtro.isAgruparPorArrecadador()) {
				consulta.addScalar("arrecadador", Hibernate.STRING);
			}
			
			retorno = consulta.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

//		System.out.println("Tempo de execução da query (" + filtro.getAgrupamento() +
//				") " + (System.currentTimeMillis() - t1));
		
		return retorno;

	}
	
	/**
	 * [UC0333] Consultar Dados Diários da Arrecadação
	 * 
	 * Método para montar a parte WHERE da query de 
	 * filtrar os dados diários para qualquer aba da funcionalidade
	 * 
	 * @date 18/11/2008
	 *
	 * @param filtro
	 * @param labelTabela
	 * @return
	 */
	private String montarWhereFiltrarDadosDiariosArrecadacao(FiltroConsultarDadosDiariosArrecadacao filtro,
		String labelTabela){
		String SQLConsultaADD = " WHERE ";
		
		if (filtro.getAnoMesArrecadacao() != null && !filtro.getAnoMesArrecadacao().equals("")
				&& !filtro.getAnoMesArrecadacao().equals("-1")){
			// @TODO: melhorar isso
			if(labelTabela.equals("ad")){
				SQLConsultaADD += labelTabela + ".ardd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao() + " and ";	
			} else {
				SQLConsultaADD += labelTabela + ".dvdd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao() + " and ";
			}
			
		}
		if (filtro.getIdGerenciaRegional() != null && !filtro.getIdGerenciaRegional().equals("")
				&& !filtro.getIdGerenciaRegional().equals("-1")){
			SQLConsultaADD += labelTabela + ".greg_id = " + filtro.getIdGerenciaRegional() + " and ";
		}
		if (filtro.getIdUnidadeNegocio() != null && !filtro.getIdUnidadeNegocio().equals("")
				&& !filtro.getIdUnidadeNegocio().equals("-1")){
			SQLConsultaADD += labelTabela + ".uneg_id = " + filtro.getIdUnidadeNegocio() +  " and ";
		}
		if (filtro.getIdElo() != null && !filtro.getIdElo().equals("")
				&& !filtro.getIdElo().equals("-1")){
			SQLConsultaADD += " loc.loca_cdelo = " + filtro.getIdElo() + " and ";
		}
		if (filtro.getIdLocalidade() != null && !filtro.getIdLocalidade().equals("")
				&& !filtro.getIdLocalidade().equals("-1")){
			SQLConsultaADD += labelTabela + ".loca_id = " + filtro.getIdLocalidade()  + " and ";
		}
		if (filtro.getIdArrecadador() != null && !filtro.getIdArrecadador().equals("")
				&& !filtro.getIdArrecadador().equals("-1")){
			SQLConsultaADD += labelTabela + ".arrc_id = " + filtro.getIdArrecadador()  + " and ";
		}
		if (filtro.getIdFormaArrecadacao() != null && !filtro.getIdFormaArrecadacao().equals("")){
			if (filtro.getIdFormaArrecadacao().equals("0")){
				SQLConsultaADD += labelTabela + ".arfm_id is null and ";
			} else if (!filtro.getIdFormaArrecadacao().equals("-1")){
				SQLConsultaADD += labelTabela + ".arfm_id = " + filtro.getIdFormaArrecadacao()  + " and ";
			}
		}		

		if (filtro.getIdDocumentoTipo() != null && !filtro.getIdDocumentoTipo().equals("")){
			
			if (filtro.getIdDocumentoTipo().equals("0")){
				SQLConsultaADD += labelTabela + ".dotp_id is null and ";	
			} else if (!filtro.getIdDocumentoTipo().equals("-1")){
				SQLConsultaADD += labelTabela + ".dotp_id = " + filtro.getIdDocumentoTipo()  + " and ";
			}
		}		

		if (filtro.getIdsCategoria() != null && filtro.getIdsCategoria().length > 0){
			
			String idsCategoria[] = filtro.getIdsCategoria();
			if (!idsCategoria[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				if (idsCategoria.length == 1){
					SQLConsultaADD += labelTabela + ".catg_id = " + idsCategoria[0] + " and ";
				} else {
					SQLConsultaADD += labelTabela + ".catg_id in ( ";
					for (int j = 0; j < idsCategoria.length; j++) {
						SQLConsultaADD += idsCategoria[j] + ", ";
					}
					SQLConsultaADD = Util.removerUltimosCaracteres(SQLConsultaADD, 2);
					SQLConsultaADD += ") and ";				
				}
			}			
		}		
		if (filtro.getIdsImovelPerfil() != null && filtro.getIdsImovelPerfil().length > 0){
			
			String idsImovelPerfil[] = filtro.getIdsImovelPerfil();
			
			if (!idsImovelPerfil[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				if (idsImovelPerfil.length == 1){
					SQLConsultaADD += labelTabela + ".iper_id = " + idsImovelPerfil[0] + " and ";
				} else {
					SQLConsultaADD += labelTabela + ".iper_id in ( ";
					for (int j = 0; j < idsImovelPerfil.length; j++) {
						SQLConsultaADD += idsImovelPerfil[j] + ", ";
					}
					SQLConsultaADD = Util.removerUltimosCaracteres(SQLConsultaADD, 2);
					SQLConsultaADD += ") and ";				
				}
			}

		}		

		if (filtro.getIdsSituacaoLigacaoAgua() != null && filtro.getIdsSituacaoLigacaoAgua().length > 0){
			
			String idsSituacaoLigacaoAgua[] = filtro.getIdsSituacaoLigacaoAgua();
			
			if (!idsSituacaoLigacaoAgua[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {

				if (idsSituacaoLigacaoAgua.length == 1){
					SQLConsultaADD += labelTabela + ".last_id = " + idsSituacaoLigacaoAgua[0] + " and ";
				} else {
					SQLConsultaADD += labelTabela + ".last_id in ( ";
					for (int j = 0; j < idsSituacaoLigacaoAgua.length; j++) {
						SQLConsultaADD += idsSituacaoLigacaoAgua[j] + ", ";
					}
					SQLConsultaADD = Util.removerUltimosCaracteres(SQLConsultaADD, 2);
					SQLConsultaADD += ") and ";				
				}

			}

		}		

		if (filtro.getIdsSituacaoLigacaoEsgoto() != null && filtro.getIdsSituacaoLigacaoEsgoto().length > 0){
			
			String idsSituacaoLigacaoEsgoto[] = filtro.getIdsSituacaoLigacaoEsgoto();
			
			if (!idsSituacaoLigacaoEsgoto[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {

				if (idsSituacaoLigacaoEsgoto.length == 1){
					SQLConsultaADD += labelTabela + ".lest_id = " + idsSituacaoLigacaoEsgoto[0] + " and ";
				} else {
					SQLConsultaADD += labelTabela + ".lest_id in ( ";
					for (int j = 0; j < idsSituacaoLigacaoEsgoto.length; j++) {
						SQLConsultaADD += idsSituacaoLigacaoEsgoto[j] + ", ";
					}
					SQLConsultaADD = Util.removerUltimosCaracteres(SQLConsultaADD, 2);
					SQLConsultaADD += ") and ";				
				}
				
			}
		}		

		if (filtro.getIdsEsferaPoder() != null && filtro.getIdsEsferaPoder().length > 0){
			
			String idsEsferaPoder[] = filtro.getIdsEsferaPoder();
			
			if (!idsEsferaPoder[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				
				if (idsEsferaPoder.length == 1){
					SQLConsultaADD += labelTabela + ".epod_id = " + idsEsferaPoder[0] + " and ";
				} else {
					SQLConsultaADD += labelTabela + ".epod_id in ( ";
					for (int j = 0; j < idsEsferaPoder.length; j++) {
						SQLConsultaADD += idsEsferaPoder[j] + ", ";
					}
					SQLConsultaADD = Util.removerUltimosCaracteres(SQLConsultaADD, 2);
					SQLConsultaADD += ") and ";				
				}
				
			}

		}		

		if (filtro.getIdsDocumentoTipoAgregador() != null && filtro.getIdsDocumentoTipoAgregador().length > 0){
			
			String idsDocumentoTipoAgregador[] = filtro.getIdsDocumentoTipoAgregador();
			
			if (!idsDocumentoTipoAgregador[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {

				if (idsDocumentoTipoAgregador.length == 1){
					if (idsDocumentoTipoAgregador[0].equals("0")){
						SQLConsultaADD += labelTabela + ".dotp_idagregador is null and ";	
					} else {
						SQLConsultaADD += labelTabela + ".dotp_idagregador = " + idsDocumentoTipoAgregador[0] + " and ";	
					}					
				} else {
					SQLConsultaADD += labelTabela + ".dotp_idagregador in ( ";
					for (int j = 0; j < idsDocumentoTipoAgregador.length; j++) {
						SQLConsultaADD += idsDocumentoTipoAgregador[j] + ", ";
					}
					SQLConsultaADD = Util.removerUltimosCaracteres(SQLConsultaADD, 2);
					SQLConsultaADD += ") and ";				
				}
				
			}

		}		

		return SQLConsultaADD;
		
	}
	
	/**
	 * 
	 * [UC0333] Consultar Dados Diários da Arrecadação
	 *
	 * Verificar se existe dados diarios da arrecadacao de acordo com o filtro 
	 * passado
	 *
	 * @author Francisco do Nascimento
	 * @date 18/11/2008
	 *
	 * @param filtro
	 * @return boolean de existencia dos dados
	 * @throws ErroRepositorioException
	 */
	public boolean verificarExistenciaDadosDiariosArrecadacao(FiltroConsultarDadosDiariosArrecadacao filtro)
		throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		
		String join1 = "";
		String join2 = "";
		
		if (filtro.getIdElo() != null && !filtro.getIdElo().equals("")){
			join1 = " left join cadastro.localidade loc on loc.loca_id = ad.loca_id ";
			join2 = " left join cadastro.localidade loc on loc.loca_id = dd.loca_id ";
		}
		
		String 	SQLVerificarADD = "SELECT ad.ardd_id as id from arrecadacao.arrec_dados_diarios ad "
			+ join1 + montarWhereFiltrarDadosDiariosArrecadacao(filtro, "ad");
		String 	SQLVerificarDDD1 = "SELECT dd.dvdd_id as id from arrecadacao.devolucao_dados_diarios dd "
			+ join2 + montarWhereFiltrarDadosDiariosArrecadacao(filtro, "dd") 
			+ " dd.dvdd_tipodevolucao <> 'N' ";
		String 	SQLVerificarDDD2 = "SELECT dd.dvdd_id as id from arrecadacao.devolucao_dados_diarios dd "
			+ join2 + montarWhereFiltrarDadosDiariosArrecadacao(filtro, "dd") 
			+ " dd.dvdd_tipodevolucao = 'N' ";

		Integer retornoSQL = null;
		boolean retorno = false;
		try {
			SQLVerificarADD = Util.removerUltimosCaracteres(SQLVerificarADD, 4);
			retornoSQL = (Integer) session.createSQLQuery(SQLVerificarADD)
				.addScalar("id", Hibernate.INTEGER).setMaxResults(1).uniqueResult();
			
			if (retornoSQL != null) {
				retorno = true;
			} else {
				retornoSQL = (Integer) session.createSQLQuery(SQLVerificarDDD1)
					.addScalar("id", Hibernate.INTEGER).setMaxResults(1).uniqueResult();
				if (retornoSQL != null){
					retorno = true;
				} else {
					retornoSQL = (Integer) session.createSQLQuery(SQLVerificarDDD2)
					.addScalar("id", Hibernate.INTEGER).setMaxResults(1).uniqueResult();
					if (retornoSQL != null){
						retorno = true;
					}
				}
			}
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * Pesquisa dos dados diários da arrecadação pela Gerencia
	 * 
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Rafael Santos
	 * @date 05/09/2006
	 * 
	 * @return
	 */
	public Collection filtrarDadosDiariosArrecadacaoValoresDiarios(
			String idGerenciaRegional) throws ErroRepositorioException {

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this
					.criarCondicionaisDadosDiariosArrecadacao(null, null, null,
							idGerenciaRegional, null, null, null, null, null,
							null, null, null);

			hql = " select distinct gerenciaRegional.nome,localidade.descricao,elo.descricao "
					+ " from gcom.arrecadacao.ArrecadacaoDadosDiarios as arrecadacaoDadosDiarios "
					+ " inner join arrecadacaoDadosDiarios.gerenciaRegional gerenciaRegional "
					+ " inner join arrecadacaoDadosDiarios.localidade localidade "
					+ " inner join arrecadacaoDadosDiarios.gerenciaRegional gerenciaRegional "
					+ " inner join localidade.localidade elo "
					+ condicionais
					+ " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de dados
	 * diarios da arrecadacao
	 * 
	 * [UC0333] Filtrar Dados Diarios da Arrecadação
	 * 
	 * Pesquisa os dados diarios com os condicionais informados
	 * 
	 * @author Rafael Santos
	 * @date 05/09/06
	 * 
	 * @return
	 */
	public String criarCondicionaisDadosDiariosArrecadacao(
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String idLocalidade, String idGerenciaRegional,
			String idArrecadador, String idElo, String[] idsImovelPerfil,
			String[] idsLigacaoAgua, String[] idsLigacaoEsgoto,
			String[] idsDocumentosTipos, String[] idsCategoria,
			String[] idsEsferaPoder) {

		String sql = " where ";

		// periodo inicial e final
		if (periodoArrecadacaoInicial != null
				&& periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoFinal.equals("")
				&& !periodoArrecadacaoFinal.equals("")) {

			sql = sql
					+ "arrecadacaoDadosDiarios.anoMesReferenciaArrecadacao >= "
					+ periodoArrecadacaoInicial + " and ";
			sql = sql
					+ "arrecadacaoDadosDiarios.anoMesReferenciaArrecadacao <= "
					+ periodoArrecadacaoFinal + " and ";
		}

		// localidade
		if (idLocalidade != null && !idLocalidade.equals("")) {
			sql = sql + " arrecadacaoDadosDiarios.localidade.id = "
					+ idLocalidade + " and ";
		}

		// gerencia regional
		if (idGerenciaRegional != null
				&& !idGerenciaRegional.equals("")
				&& !idGerenciaRegional
						.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
			sql = sql
					+ " arrecadacaoDadosDiarios.localidade.gerenciaRegional.id = "
					+ idGerenciaRegional + " and ";
		}
		// arrecadador
		if (idArrecadador != null && !idArrecadador.equals("")) {
			sql = sql + " arrecadacaoDadosDiarios.arrecadador.id = "
					+ idArrecadador + " and ";
		}
		// elo
		if (idElo != null && !idElo.equals("")) {
			sql = sql + " arrecadacaoDadosDiarios.localidade.localidade.id = "
					+ idElo + " and ";
		}

		// Imovel Perfil
		if (idsImovelPerfil != null && idsImovelPerfil.length > 0) {

			if (!idsImovelPerfil[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsImovelPerfil.length) {
					if (!idsImovelPerfil[i].equals("")) {

						if (i + 1 < idsImovelPerfil.length) {

							sql = sql
									+ " arrecadacaoDadosDiarios.imovelPerfil.id = "
									+ idsImovelPerfil[i] + " or ";

						} else {

							sql = sql
									+ " arrecadacaoDadosDiarios.imovelPerfil.id = "
									+ idsImovelPerfil[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Situação Ligação Água
		if (idsLigacaoAgua != null && idsLigacaoAgua.length > 0) {
			if (!idsLigacaoAgua[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsLigacaoAgua.length) {
					if (!idsLigacaoAgua[i].equals("")) {

						if (i + 1 < idsLigacaoAgua.length) {

							sql = sql
									+ " arrecadacaoDadosDiarios.ligacaoAguaSituacao.id = "
									+ idsLigacaoAgua[i] + " or ";

						} else {

							sql = sql
									+ " arrecadacaoDadosDiarios.ligacaoAguaSituacao.id = "
									+ idsLigacaoAgua[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Situação Ligação Esgoto
		if (idsLigacaoEsgoto != null && idsLigacaoEsgoto.length > 0) {
			if (!idsLigacaoEsgoto[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsLigacaoEsgoto.length) {
					if (!idsLigacaoEsgoto[i].equals("")) {

						if (i + 1 < idsLigacaoEsgoto.length) {

							sql = sql
									+ " arrecadacaoDadosDiarios.ligacaoEsgotoSituacao.id = "
									+ idsLigacaoEsgoto[i] + " or ";

						} else {

							sql = sql
									+ " arrecadacaoDadosDiarios.ligacaoEsgotoSituacao.id = "
									+ idsLigacaoEsgoto[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Categoria
		if (idsCategoria != null && idsCategoria.length > 0) {
			if (!idsCategoria[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO
					+ "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsCategoria.length) {
					if (!idsCategoria[i].equals("")) {

						if (i + 1 < idsCategoria.length) {

							sql = sql
									+ " arrecadacaoDadosDiarios.categoria.id = "
									+ idsCategoria[i] + " or ";

						} else {

							sql = sql
									+ " arrecadacaoDadosDiarios.categoria.id = "
									+ idsCategoria[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// Esfera Poder
		if (idsEsferaPoder != null && idsEsferaPoder.length > 0) {
			if (!idsEsferaPoder[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsEsferaPoder.length) {
					if (!idsEsferaPoder[i].equals("")) {

						if (i + 1 < idsEsferaPoder.length) {

							sql = sql
									+ " arrecadacaoDadosDiarios.esferaPoder.id = "
									+ idsEsferaPoder[i] + " or ";

						} else {

							sql = sql
									+ " arrecadacaoDadosDiarios.esferaPoder.id = "
									+ idsEsferaPoder[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// documento tipo
		if (idsDocumentosTipos != null && idsDocumentosTipos.length > 0) {
			if (!idsDocumentosTipos[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsDocumentosTipos.length) {
					if (!idsDocumentosTipos[i].equals("")) {

						if (i + 1 < idsDocumentosTipos.length) {

							sql = sql
									+ " arrecadacaoDadosDiarios.documentoTipoAgregador.id = "
									+ idsDocumentosTipos[i] + " or ";

						} else {

							sql = sql
									+ " arrecadacaoDadosDiarios.documentoTipoAgregador.id = "
									+ idsDocumentosTipos[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// retira o " and " q fica sobrando no final da query
		sql = Util.removerUltimosCaracteres(sql, 4);

		return sql;
	}
	
	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de dados
	 * diarios da arrecadacao, para os valores de devolucao
	 * 
	 * [UC0333] Filtrar Dados Diarios da Arrecadação
	 * 
	 * Pesquisa os dados diarios com os condicionais informados
	 * 
	 * @author Francisco do Nascimento
	 * @date 21/07/08
	 * 
	 * @return
	 */
	public String criarCondicionaisDadosDiariosDevolucao(
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String idLocalidade, String idGerenciaRegional,
			String idArrecadador, String idElo, String[] idsImovelPerfil,
			String[] idsLigacaoAgua, String[] idsLigacaoEsgoto,
			String[] idsDocumentosTipos, String[] idsCategoria,
			String[] idsEsferaPoder) {

		String sql = " where ";

		// periodo inicial e final
		if (periodoArrecadacaoInicial != null
				&& periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoFinal.equals("")
				&& !periodoArrecadacaoFinal.equals("")) {

			sql = sql
					+ "devolucaoDadosDiarios.anoMesReferencia >= "
					+ periodoArrecadacaoInicial + " and ";
			sql = sql
					+ "devolucaoDadosDiarios.anoMesReferencia <= "
					+ periodoArrecadacaoFinal + " and ";
		}

		// localidade
		if (idLocalidade != null && !idLocalidade.equals("")) {
			sql = sql + " devolucaoDadosDiarios.localidade.id = "
					+ idLocalidade + " and ";
		}

		// gerencia regional
		if (idGerenciaRegional != null
				&& !idGerenciaRegional.equals("")
				&& !idGerenciaRegional
						.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
			sql = sql
					+ " devolucaoDadosDiarios.localidade.gerenciaRegional.id = "
					+ idGerenciaRegional + " and ";
		}
		// arrecadador
		if (idArrecadador != null && !idArrecadador.equals("")) {
			sql = sql + " devolucaoDadosDiarios.arrecadador.id = "
					+ idArrecadador + " and ";
		}
		// elo
		if (idElo != null && !idElo.equals("")) {
			sql = sql + " devolucaoDadosDiarios.localidade.localidade.id = "
					+ idElo + " and ";
		}

		// Imovel Perfil
		if (idsImovelPerfil != null && idsImovelPerfil.length > 0) {

			if (!idsImovelPerfil[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsImovelPerfil.length) {
					if (!idsImovelPerfil[i].equals("")) {

						if (i + 1 < idsImovelPerfil.length) {

							sql = sql
									+ " devolucaoDadosDiarios.imovelPerfil.id = "
									+ idsImovelPerfil[i] + " or ";

						} else {

							sql = sql
									+ " devolucaoDadosDiarios.imovelPerfil.id = "
									+ idsImovelPerfil[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Situação Ligação Água
		if (idsLigacaoAgua != null && idsLigacaoAgua.length > 0) {
			if (!idsLigacaoAgua[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsLigacaoAgua.length) {
					if (!idsLigacaoAgua[i].equals("")) {

						if (i + 1 < idsLigacaoAgua.length) {

							sql = sql
									+ " devolucaoDadosDiarios.ligacaoAguaSituacao.id = "
									+ idsLigacaoAgua[i] + " or ";

						} else {

							sql = sql
									+ " devolucaoDadosDiarios.ligacaoAguaSituacao.id = "
									+ idsLigacaoAgua[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Situação Ligação Esgoto
		if (idsLigacaoEsgoto != null && idsLigacaoEsgoto.length > 0) {
			if (!idsLigacaoEsgoto[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsLigacaoEsgoto.length) {
					if (!idsLigacaoEsgoto[i].equals("")) {

						if (i + 1 < idsLigacaoEsgoto.length) {

							sql = sql
									+ " devolucaoDadosDiarios.ligacaoEsgotoSituacao.id = "
									+ idsLigacaoEsgoto[i] + " or ";

						} else {

							sql = sql
									+ " devolucaoDadosDiarios.ligacaoEsgotoSituacao.id = "
									+ idsLigacaoEsgoto[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Categoria
		if (idsCategoria != null && idsCategoria.length > 0) {
			if (!idsCategoria[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO
					+ "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsCategoria.length) {
					if (!idsCategoria[i].equals("")) {

						if (i + 1 < idsCategoria.length) {

							sql = sql
									+ " devolucaoDadosDiarios.categoria.id = "
									+ idsCategoria[i] + " or ";

						} else {

							sql = sql
									+ " devolucaoDadosDiarios.categoria.id = "
									+ idsCategoria[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// Esfera Poder
		if (idsEsferaPoder != null && idsEsferaPoder.length > 0) {
			if (!idsEsferaPoder[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsEsferaPoder.length) {
					if (!idsEsferaPoder[i].equals("")) {

						if (i + 1 < idsEsferaPoder.length) {

							sql = sql
									+ " devolucaoDadosDiarios.esferaPoder.id = "
									+ idsEsferaPoder[i] + " or ";

						} else {

							sql = sql
									+ " devolucaoDadosDiarios.esferaPoder.id = "
									+ idsEsferaPoder[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// documento tipo
		if (idsDocumentosTipos != null && idsDocumentosTipos.length > 0) {
			if (!idsDocumentosTipos[0]
					.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {
				int i = 0;
				sql = sql + " ( ";
				while (i < idsDocumentosTipos.length) {
					if (!idsDocumentosTipos[i].equals("")) {

						if (i + 1 < idsDocumentosTipos.length) {

							sql = sql
									+ " devolucaoDadosDiarios.documentoTipo.id = "
									+ idsDocumentosTipos[i] + " or ";

						} else {

							sql = sql
									+ " devolucaoDadosDiarios.documentoTipo.id = "
									+ idsDocumentosTipos[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.removerUltimosCaracteres(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// retira o " and " q fica sobrando no final da query
		sql = Util.removerUltimosCaracteres(sql, 4);

		return sql;
	}	

	/**
	 * Retornar Coleção do movimento do arrecadador
	 * 
	 * Seleciona Movimento Arrecadadores
	 * 
	 * @author Fernanda Paiva
	 * @date
	 * @throws ErroRepositorioException
	 */
	public Collection<ArrecadadorMovimento> retornarColecaoMovimentoArrecadadores(
			FiltroArrecadadorMovimento filtro, Integer numeroPagina)
			throws ErroRepositorioException {

		Collection<ArrecadadorMovimento> retorno = null;

		Session session = HibernateUtil.getSession();

		try {

			retorno = new ArrayList(
					new CopyOnWriteArraySet<ArrecadadorMovimento>(
							GeradorHQLCondicional
									.gerarCondicionalQuery(
											filtro,
											"arrecadadorMovimento",
											"SELECT DISTINCT arrecadadorMovimento "
													+ "FROM ArrecadadorMovimento as arrecadadorMovimento "
													+ "LEFT JOIN arrecadadorMovimento.arrecadadorMovimentoItens as "
													+ FiltroArrecadadorMovimento.ALIAS_ARRECADADOR_MOVIMENTO_ITEM
													+ "", session)
									.setFirstResult(10 * numeroPagina)
									.setMaxResults(10).list()));
			/*
			 * if
			 * (!filtro.getColecaoCaminhosParaCarregamentoEntidades().isEmpty()) {
			 * PersistenciaUtil.processaObjetosParaCarregamento(filtro.getColecaoCaminhosParaCarregamentoEntidades(),
			 * retorno); }
			 */
		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public BigDecimal pesquisarSomatorioAvisoAcerto(
			Integer indicadorCreditoDebito, Integer idAviso,
			Integer indicadorArrecadacaoDevolucao)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select sum(avisoAcerto.valorAcerto) from AvisoAcerto avisoAcerto "
					+ " inner join avisoAcerto.avisoBancario avisoBancario "
					+ " where avisoAcerto.indicadorCreditoDebito = :indicadorCreditoDebito"
					+ " and avisoAcerto.indicadorArrecadacaoDevolucao = :indicadorArrecadacaoDevolucao "
					+ " and avisoBancario.id = :idAviso";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"indicadorCreditoDebito", indicadorCreditoDebito)
					.setInteger("indicadorArrecadacaoDevolucao",
							indicadorArrecadacaoDevolucao).setInteger(
							"idAviso", idAviso).setMaxResults(1).uniqueResult();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection filtrarAvisoBancarioAbertoFechadoFinal(
			AvisoBancarioHelper avisoBancarioHelper)
			throws ErroRepositorioException {

		// Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		// //////
		Short arrecadadorCodAgente = avisoBancarioHelper
				.getCodigoAgenteArrecadador();
		Date dataLancamentoInicio = avisoBancarioHelper
				.getDataLancamentoInicial();
		Date dataLancamentoFim = avisoBancarioHelper.getDataLancamentoFinal();
		Short indicadorCreditoDebito = avisoBancarioHelper
				.getIndicadorCreditoDebito();
		Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
		Integer idMovimento = avisoBancarioHelper.getIdMovimentoArrecadador();
		Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper
				.getDataPrevistaInicial();
		Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper
				.getDataPrevistaFinal();
		Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper
				.getDataRealizadaInicial();
		Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper
				.getDataRealizadaFinal();
		int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper
				.getAnoMesReferenciaArrecadacaoInicial();
		int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper
				.getAnoMesReferenciaArrecadacaoFinal();
		BigDecimal valorRealizadoInicial = avisoBancarioHelper
				.getValorRealizadoInicial();
		BigDecimal valorRealizadoFinal = avisoBancarioHelper
				.getValorRealizadoFinal();
		// /////

		Integer idAviso = avisoBancarioHelper.getAvisoBancario().getId();
		String tipoAviso = avisoBancarioHelper.getTipoAviso();

		int flag = 0;
		BigDecimal valorSomatorioAcertoCredito = this
				.pesquisarSomatorioAvisoAcerto(1, idAviso, 1);
		BigDecimal valorSomatorioAcertoDebito = this
				.pesquisarSomatorioAvisoAcerto(2, idAviso, 1);

		BigDecimal valorSomatorioAcertoCredito2 = this
				.pesquisarSomatorioAvisoAcerto(1, idAviso, 2);
		BigDecimal valorSomatorioAcertoDebito2 = this
				.pesquisarSomatorioAvisoAcerto(2, idAviso, 2);
		if (valorSomatorioAcertoCredito == null) {
			valorSomatorioAcertoCredito = new BigDecimal("0.00");
		}
		if (valorSomatorioAcertoDebito == null) {
			valorSomatorioAcertoDebito = new BigDecimal("0.00");
		}

		if (valorSomatorioAcertoCredito2 == null) {
			valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
		}
		if (valorSomatorioAcertoDebito2 == null) {
			valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
		}

		if (arrecadadorCodAgente == null
				&& (dataLancamentoInicio == null || dataLancamentoFim == null)
				&& (indicadorCreditoDebito == 0 || indicadorCreditoDebito == 3)
				&& idContaBancaria == null
				&& idMovimento == null
				&& (dataPrevisaoCreditoDebitoInicio == null || dataPrevisaoCreditoDebitoFim == null)
				&& (dataRealizacaoCreditoDebitoInicio == null || dataRealizacaoCreditoDebitoFim == null)
				&& (anoMesReferenciaArrecadacaoInicial == 0 || anoMesReferenciaArrecadacaoFinal == 0)
				&& (valorRealizadoInicial == null || valorRealizadoFinal == null)
				&& tipoAviso.equalsIgnoreCase("1")) {
			flag = 1;
			consulta = "select avisoBancario, " + " case when ("
					+ " (avisoBancario.valorArrecadacaoCalculado = "
					+ " ((avisoBancario.valorArrecadacaoInformado + "
					+ valorSomatorioAcertoCredito + " ) " + " - "
					+ valorSomatorioAcertoDebito + ")" + " ) " + " and "
					+ "(avisoBancario.valorDevolucaoCalculado = "
					+ " ((avisoBancario.valorDevolucaoInformado + "
					+ valorSomatorioAcertoCredito2 + " ) " + " - "
					+ valorSomatorioAcertoDebito2 + ")" + " )) then 'FECHADO' "
					+ " else 'ABERTO' end "
					+ " from AvisoBancario avisoBancario ";

		} else {
			consulta = "select avisoBancario, " + " case when ("
					+ " (avisoBancario.valorArrecadacaoCalculado = "
					+ " ((avisoBancario.valorArrecadacaoInformado + "
					+ valorSomatorioAcertoCredito + " ) " + " - "
					+ valorSomatorioAcertoDebito + ")" + " ) " + " and "
					+ "(avisoBancario.valorDevolucaoCalculado = "
					+ " ((avisoBancario.valorDevolucaoInformado + "
					+ valorSomatorioAcertoCredito2 + " ) " + " - "
					+ valorSomatorioAcertoDebito2 + ")" + " )) then 'FECHADO' "
					+ " else 'ABERTO' end "
					+ " from AvisoBancario avisoBancario " + " where ";
		}

		// ///////
		if (idAviso != null && !idAviso.equals(0)) {
			consulta += " avisoBancario.id = " + idAviso + " and";
		}

		if (arrecadadorCodAgente != null) {
			consulta += " avisoBancario.arrecadador.codigoAgente = "
					+ arrecadadorCodAgente + " and";
		}

		if ((dataLancamentoInicio != null) && (dataLancamentoFim != null)) {
			consulta += " avisoBancario.dataLancamento between :dataLancamentoInicio  and "
					+ ":dataLancamentoFim and";

		}

		if (indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3) {
			consulta += " avisoBancario.indicadorCreditoDebito = "
					+ indicadorCreditoDebito + " and";
		}

		if (idContaBancaria != null) {
			consulta += " avisoBancario.contaBancaria.id = " + idContaBancaria
					+ " and";
		}

		if (idMovimento != null) {
			consulta += " avisoBancario.arrecadadorMovimento.id = "
					+ idMovimento + " and";
		}

		if ((dataPrevisaoCreditoDebitoInicio != null)
				&& (dataPrevisaoCreditoDebitoFim != null)) {
			consulta += " avisoBancario.dataPrevista between :dataPrevisaoCreditoDebitoInicio  and "
					+ ":dataPrevisaoCreditoDebitoFim and";

		}

		if ((dataRealizacaoCreditoDebitoInicio != null)
				&& (dataRealizacaoCreditoDebitoFim != null)) {
			consulta += " avisoBancario.dataRealizada between :dataRealizacaoCreditoDebitoInicio  and "
					+ ":dataRealizacaoCreditoDebitoFim and";

		}

		if ((anoMesReferenciaArrecadacaoInicial != 0)
				&& (anoMesReferenciaArrecadacaoFinal != 0)) {
			consulta += " avisoBancario.anoMesReferenciaArrecadacao between "
					+ anoMesReferenciaArrecadacaoInicial + " and "
					+ anoMesReferenciaArrecadacaoFinal + " and";
		}

		if ((valorRealizadoInicial != null) && (valorRealizadoFinal != null)) {

			BigDecimal valorInicialNegativo = valorRealizadoFinal
					.multiply(new BigDecimal("-1.00"));
			BigDecimal valorFinalNegativo = valorRealizadoInicial
					.multiply(new BigDecimal("-1.00"));
			consulta += " ((avisoBancario.valorRealizado between "
					+ valorInicialNegativo + " and " + valorFinalNegativo
					+ ") or (avisoBancario.valorRealizado between "
					+ valorRealizadoInicial + " and " + valorRealizadoFinal
					+ "))" + " and";
		}
		// //////

		// tipoAviso
		if (tipoAviso != null && !tipoAviso.equalsIgnoreCase("1")) {
			if (tipoAviso.equalsIgnoreCase("3")) {
				// FECHADO
				consulta += " ((avisoBancario.valorArrecadacaoCalculado = "
						+ " ((avisoBancario.valorArrecadacaoInformado + "
						+ valorSomatorioAcertoCredito + " ) " + " - "
						+ valorSomatorioAcertoDebito + ")" + " ) " + " and "
						+ "(avisoBancario.valorDevolucaoCalculado = "
						+ " ((avisoBancario.valorDevolucaoInformado + "
						+ valorSomatorioAcertoCredito2 + " ) " + " - "
						+ valorSomatorioAcertoDebito2 + ")" + " )) and ";
			} else if (tipoAviso.equalsIgnoreCase("2")) {
				// ABERTO
				consulta += " ((avisoBancario.valorArrecadacaoCalculado <> "
						+ " ((avisoBancario.valorArrecadacaoInformado + "
						+ valorSomatorioAcertoCredito + " ) " + " - "
						+ valorSomatorioAcertoDebito + ")" + " ) " + " or "
						+ "(avisoBancario.valorDevolucaoCalculado <> "
						+ " ((avisoBancario.valorDevolucaoInformado + "
						+ valorSomatorioAcertoCredito2 + " ) " + " - "
						+ valorSomatorioAcertoDebito2 + ")" + " )) and ";
			}
		}
		String consultarComOrderBy = "";
		if (flag != 1) {
			consultarComOrderBy = Util.removerUltimosCaracteres(consulta, 4)
					+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
		} else {
			consultarComOrderBy = Util.removerUltimosCaracteres(consulta, 0)
					+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
		}
		

		// Consulta
		try {
			if ((((dataLancamentoInicio != null) && (dataLancamentoFim != null)) && ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).list();

			} else if (((dataLancamentoInicio != null) && (dataLancamentoFim != null))
					&& ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).list();

			} else if (((dataLancamentoInicio != null) && (dataLancamentoFim != null))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).list();

			} else if (((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))
					&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).list();

			} else if ((dataLancamentoInicio != null)
					&& (dataLancamentoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataLancamentoInicio", dataLancamentoInicio).setDate(
						"dataLancamentoFim", dataLancamentoFim).list();

			} else if ((dataPrevisaoCreditoDebitoInicio != null)
					&& (dataPrevisaoCreditoDebitoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataPrevisaoCreditoDebitoInicio",
						dataPrevisaoCreditoDebitoInicio).setDate(
						"dataPrevisaoCreditoDebitoFim",
						dataPrevisaoCreditoDebitoFim).list();

			} else if ((dataRealizacaoCreditoDebitoInicio != null)
					&& (dataRealizacaoCreditoDebitoFim != null)) {

				return session.createQuery(consultarComOrderBy).setDate(
						"dataRealizacaoCreditoDebitoInicio",
						dataRealizacaoCreditoDebitoInicio).setDate(
						"dataRealizacaoCreditoDebitoFim",
						dataRealizacaoCreditoDebitoFim).list();

			} else {
				return session.createQuery(consultarComOrderBy).list();
			}
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisa os dados da Guia de Pagamento necessários para o relatório
	 * através do id da Guia de Pagamento
	 * 
	 * @author Vivianne Sousa, Mariana Victor
	 * @date 03/10/06, 02/03/2011
	 * 
	 * @return GuiaPagamentoRelatorioHelper
	 * @throws ErroRepositorioException
	 */

	public GuiaPagamentoRelatorioHelper pesquisarGuiaPagamentoRelatorio(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		// cria a variável que vai armazenar o objeto pesquisada
		GuiaPagamentoRelatorioHelper retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {

			String consulta = "select " + " new "
					+ GuiaPagamentoRelatorioHelper.class.getName() + " ( "
					+ "im.id, " 
					+ "gp.dataVencimento, " 
					+ "loc.id, "
					+ "loc.descricao, " 
					+ "gp.valorDebito, "
					+ "gp.dataEmissao, " 
					+ "dt.id, " 
					+ "dt.descricao, " 
					+ "gp.numeroPrestacaoDebito, gp.numeroPrestacaoTotal," 
					+ "gp.observacao, gp.indicadorEmitirObservacao,"
					+ "im.nomeImovel) "
					+ "FROM GuiaPagamento gp  "
					+ "LEFT JOIN gp.localidade loc "
					+ "LEFT JOIN gp.debitoTipo dt " 
					+ "LEFT JOIN gp.imovel im "
					+ "WHERE gp.id =:idGuiaPagamento ";

			retorno = (GuiaPagamentoRelatorioHelper) session.createQuery(
					consulta).setInteger("idGuiaPagamento",
					idGuiaPagamento.intValue()).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa o nome do cliente da guia de pagamento através do id da Guia de
	 * Pagamento e com CRTP_ID com o valor correspondente a usuário(2)
	 * 
	 * @author Vivianne Sousa
	 * @date 04/10/06
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public String pesquisarNomeClienteGuiaPagamentoRelatorio(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		// cria a variável que vai armazenar o objeto pesquisada
		String retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select cli.nome "
					+ "from ClienteGuiaPagamento cgp "
					+ "inner join cgp.cliente cli "
					+ "inner join cgp.clienteRelacaoTipo crtp "
					+ "inner join cgp.guiaPagamento guia "
					+ "where  crtp.id = 2 and guia.id =:idGuiaPagamento ";

			retorno = (String) session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento.intValue())
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados da Guia de Devolução necessários para o relatório
	 * através do id da Guia de Devolução
	 * 
	 * @author Ana Maria
	 * @date 05/10/06
	 * 
	 * @return GuiaDevolucaoRelatorioHelper
	 * @throws ErroRepositorioException
	 */

	public GuiaDevolucaoRelatorioHelper pesquisarGuiaDevolucaoRelatorio(
			Integer idGuiaDevolucao) throws ErroRepositorioException {

		// cria a variável que vai armazenar o objeto pesquisada
		GuiaDevolucaoRelatorioHelper retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {

			String consulta = "select " + " new "
					+ GuiaDevolucaoRelatorioHelper.class.getName() + " ( "
					+ "gdev.id, gdev.valorDevolucao, "
					+ "rgat.id, rgat.observacao, gdev.imovel.id, "
					+ "clie.id, clie.nome, clie.cpf, clie.cnpj, clie.rg, "
					+ "orrg.descricaoAbreviada, unfe.sigla, fuan.nome, "
					+ "fuau.nome, usua.nomeUsuario, gdev.dataValidade) "
					+ "from GuiaDevolucao gdev "
					+ "left join gdev.cliente clie "
					+ "left join clie.orgaoExpedidorRg orrg "
					+ "left join clie.unidadeFederacao unfe "
					+ "left join gdev.registroAtendimento rgat "
					+ "left join gdev.funcionarioAnalista fuan "
					+ "left join gdev.funcionarioAutorizador fuau "
					+ "left join gdev.usuario usua "
					+ "where gdev.id =:idGuiaDevolucao ";

			retorno = (GuiaDevolucaoRelatorioHelper) session.createQuery(
					consulta).setInteger("idGuiaDevolucao",
					idGuiaDevolucao.intValue()).setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa os dados do Cliente pelo Imóvel
	 * 
	 * @author Ana Maria
	 * @date 06/10/06
	 * 
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarClienteImovel(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = "select clie.nome, clie.cpf, clie.cnpj, clie.rg, "
					+ "orrg.descricaoAbreviada, unfe.sigla "
					+ "from ClienteImovel clim "
					+ "inner join clim.cliente clie "
					+ "left join clie.orgaoExpedidorRg orrg "
					+ "left join clie.unidadeFederacao unfe "
					+ "where clim.clienteRelacaoTipo.id = 2 " 
					+ "and clim.imovel.id =:idImovel "
					+ "and clim.dataFimRelacao is null ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para pesquisar os pagamento historicos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos historicos do Imóvel
	 * 
	 * @author Rafael Corrêa
	 * @date 20/12/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoImovel(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ErroRepositorioException {
		Collection<PagamentoHistorico> retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);

			hql = " select distinct pagamentoHistorico "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " LEFT JOIN FETCH pagamentoHistorico.avisoBancario avbc "
					+ " LEFT JOIN FETCH avbc.arrecadador arrec "
					+ " LEFT JOIN FETCH arrec.cliente clie"
					+ " LEFT JOIN FETCH pagamentoHistorico.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamentoHistorico.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico contaHistorico "
					+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoTipo dbtp "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ condicionais;
			
			if(localidadeInicial != null && localidadeFinal != null
					&& !localidadeInicial.equals("") && !localidadeFinal.equals("")){
				hql = hql + "  order by pagamentoHistorico.localidade.id, pagamentoHistorico.imovel.id, "
					+ " pagamentoHistorico.anoMesReferenciaPagamento, pagamentoHistorico.dataPagamento ";
					
			}else{
				hql = hql + "  order by pagamentoHistorico.anoMesReferenciaPagamento desc, pagamentoHistorico.dataPagamento desc ";
			}
					
			if ( dataPagamentoInicial != null && !dataPagamentoInicial.equals("")) {
				String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

				if (data1 != null && !data1.equals("")
						&& data1.trim().length() == 8) {

					data1 = data1.substring(6, 8) + "/" + data1.substring(4, 6) + "/" + data1.substring(0, 4);
				}
				if ( dataPagamentoFinal != null && !dataPagamentoFinal.equals("")) {
					String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

					if (data2 != null && !data2.equals("")
							&& data2.trim().length() == 8) {

						data2 = data2.substring(6, 8) + "/" + data2.substring(4, 6) + "/" + data2.substring(0, 4);
					}
					retorno = session.createQuery(hql)
					.setTimestamp("dataPagamentoInicial",  Util.formatarDataInicial( Util.converteStringParaDate(data1) ) )
					.setTimestamp("dataPagamentoFinal",  Util.formatarDataFinal( Util.converteStringParaDate(data2) ) )
					.list();
				} else {
					retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial",  Util.formatarDataInicial( Util.converteStringParaDate(data1) ) ).list();	
				}
				
				
			} else if ( dataPagamentoFinal != null) {
				String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

				if (data2 != null && !data2.equals("")
						&& data2.trim().length() == 8) {

					data2 = data2.substring(6, 8) + "/" + data2.substring(4, 6) + "/" + data2.substring(0, 4);
				}
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal",  Util.formatarDataFinal( Util.converteStringParaDate(data2) ) ).list();
			}
			else {
				retorno = session.createQuery(hql).list();	
			}

			
			
			

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * 
	 * Filtar a quantiade de pagamento historicos do imovel [UC0255] Filtrar
	 * Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoHistoricoImovelCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) throws ErroRepositorioException {

		int retorno = 0;
		Object pagamentoHistoricoImovelCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);

			hql = " select count(pagamentoHistorico.id) "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ condicionais + " ";

			pagamentoHistoricoImovelCount = session.createQuery(hql)
					.setMaxResults(1).uniqueResult();

			if (pagamentoHistoricoImovelCount != null) {
				retorno = (Integer) pagamentoHistoricoImovelCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os pagamento historicos do Imovel para paginação
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoImovelParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina) throws ErroRepositorioException {

		Collection<PagamentoHistorico> retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);

			hql = " SELECT distinct pagamentoHistorico "
					+ " FROM gcom.arrecadacao.pagamento.PagamentoHistorico as pagamentoHistorico "

					+ " LEFT JOIN FETCH pagamentoHistorico.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico conta "
					+ " LEFT JOIN FETCH pagamentoHistorico.documentoTipo "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoTipo "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior "
					+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamento guiaPagamento "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoACobrarGeral debitoACobrarGeral "
					+ " LEFT JOIN FETCH debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ " LEFT JOIN FETCH guiaPagamento.debitoTipo "
					+ " LEFT JOIN FETCH debitoACobrar.debitoTipo "

					+ condicionais

					+ "  order by pagamentoHistorico.localidade.id, pagamentoHistorico.imovel.id, "
					+ "  pagamentoHistorico.documentoTipo.id, pagamentoHistorico.dataPagamento "
					+ " ";

			retorno = session.createQuery(hql)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os Pagamento Historicos do Cliente Conta
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 20/12/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoClienteConta(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) throws ErroRepositorioException {
		Collection retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this
					.criarCondicionaisPagamentoHistoricoCliente(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);

			hql = " select c.pghi_id as idPagamento, i.cnta_id as idConta, i.cnhi_amreferenciaconta as anoMesConta, i.cnhi_vlagua as valorAguaConta, "
				+ " i.cnhi_vlesgoto as valorEsgotoConta, i.cnhi_vldebitos as valorDebitosConta, i.cnhi_vlcreditos as valorCreditosConta, "
				+ " c.pghi_dtpagamento as dataPagamento, c.pghi_amreferenciapagamento as anoMesPagamento, "
				+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
				+ " k.pgst_id as idSituacaoPagamentoAnterior, k.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, c.imov_id as idImovel "
				+ " FROM arrecadacao.pagamento_historico c "
				+ " INNER JOIN "
				+ " faturamento.conta_historico i "
				+ "  on i.imov_id = c.imov_id and i.cnhi_amreferenciaconta = c.pghi_amreferenciapagamento "
				+ " INNER JOIN ";
				
			if (idTipoRelacao != null && !idTipoRelacao.equals("")){
				
				hql += " cadastro.cliente_conta_historico b on b.cnta_id = i.cnta_id "; 
			}
			else{
				
				hql += " cadastro.cliente_conta_historico b on b.cnta_id = i.cnta_id and b.crtp_id = " + ClienteRelacaoTipo.USUARIO.toString();
			}
			
			hql += " INNER JOIN cadastro.cliente a " + " on a.clie_id = b.clie_id ";
			
			// + " INNER JOIN "
			// + " cadastro.localidade d "
			// + " on c.loca_id = d.loca_id "

			if (idArrecadador != null && !idArrecadador.equals("")) {
				hql = hql + " INNER JOIN " + " arrecadacao.aviso_bancario f "
						+ "  on c.avbc_id = f.avbc_id ";
			}

			hql = hql
					// + " INNER JOIN "
					// + " arrecadacao.arrecadador g "
					// + " on f.arrc_id = g.arrc_id "
					// + " INNER JOIN "
					// + " cadastro.cliente h "
					// + " on h.clie_id = g.clie_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao k "
					+ "  on c.pgst_idanterior = k.pgst_id "
					// + " LEFT OUTER JOIN "
					// + " faturamento.debito_tipo m "
					// + " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " order by c.loca_id, c.imov_id, c.pghi_amreferenciapagamento, c.pghi_dtpagamento ";

			// colecaoPagamento = session.createQuery(hql).list();

			retorno = session
					.createSQLQuery(hql)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("valorAguaConta", Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgotoConta", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitosConta", Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditosConta", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("anoMesPagamento", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAtual", Hibernate.STRING)
					.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAnterior", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar(
							"idImovel", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtrar os pagamentos historicos do Cliente Guia Pagamento
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 06/10/06
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoClienteGuiaPagamento(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ErroRepositorioException {
		Collection<PagamentoHistorico> retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 2. O sistema seleciona os pagamentos de guia de pagamento do
			// cliente informado (a partir da tabela
			// PAGAMENTO com CLIE_ID = Id do cliente informado ou com
			// GPAG_ID =
			// GPAG_ID da tabela
			// CLIENTE_GUIA_PAGAMENTO com CLIE_ID = Id do cliente informado
			// e
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente
			// com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this
					.criarCondicionaisPagamentoHistoricoCliente(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);

			hql = " SELECT c.pghi_id as idPagamento, b1.gpag_id as idGuiaPagamento, c.clie_id as idCliente, b1.gpag_vldebito as valorGuia, "
					+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoGuia, k.dbtp_dsdebitotipo as tipoDebitoGuia, "
					+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
					+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
					+ " c.imov_id as idImovel, c.loca_id as idLocalidade "
					+ " FROM arrecadacao.pagamento_historico c "
					+ " INNER JOIN "
					+ " faturamento.guia_pagamento b1 "
					+ "  on b1.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_guia_pagamento b "
					+ " on b.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " faturamento.debito_tipo k "
					+ " on b1.dbtp_id = k.dbtp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " union "
					+ " SELECT c.pghi_id as idPagamento, b1.gpag_id as idGuiaPagamento, c.clie_id as idCliente, b1.gpag_vldebito as valorGuia, "
					+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoGuia, k.dbtp_dsdebitotipo as tipoDebitoGuia, "
					+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
					+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
					+ " c.imov_id as idImovel, c.loca_id as idLocalidade "
					+ " FROM arrecadacao.pagamento_historico c "
					+ " INNER JOIN "
					+ " faturamento.guia_pagamento b1 "
					+ "  on b1.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_guia_pagamento b "
					+ " on b.gpag_id = c.gpag_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " faturamento.debito_tipo k "
					+ " on b1.dbtp_id = k.dbtp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " union "
					+ " SELECT c.pghi_id as idPagamento, b.gpag_id as idGuiaPagamento, c.clie_id as idCliente, b.gpag_vldebito as valorGuia, "
					+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoGuia, k.dbtp_dsdebitotipo as tipoDebitoGuia, "
					+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
					+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
					+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
					+ " c.imov_id as idImovel, c.loca_id as idLocalidade "
					+ " FROM arrecadacao.pagamento_historico c "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = c.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.guia_pagamento b "
					+ "  on b.gpag_id = c.gpag_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo k "
					+ " on b.dbtp_id = k.dbtp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id " + " WHERE ";

			idTipoRelacao = null;

			String condicionaisClientePagamento = this
					.criarCondicionaisPagamentoHistoricoCliente(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);

			hql = hql
					+ condicionaisClientePagamento
					+ " order by idLocalidade, idImovel, idTipoDebitoPagamento, dataPagamento ";

			retorno = session
					.createSQLQuery(hql)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("idGuiaPagamento", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("valorGuia", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("anoMesPagamento", Hibernate.INTEGER)
					.addScalar("idTipoDebitoGuia", Hibernate.INTEGER)
					.addScalar("tipoDebitoGuia", Hibernate.STRING)
					.addScalar("idTipoDebitoPagamento", Hibernate.INTEGER)
					.addScalar("tipoDebitoPagamento", Hibernate.STRING)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAtual", Hibernate.STRING)
					.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAnterior", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar(
							"idImovel", Hibernate.INTEGER).addScalar(
							"idLocalidade", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os pagamentos historicos do debito a cobrar
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 12/06/06,06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoClienteDebitoACobrar(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ErroRepositorioException {
		Collection retorno = new ArrayList();
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			String condicionais = this
					.criarCondicionaisPagamentoHistoricoCliente(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " SELECT c.pghi_id as idPagamento, c.imov_id as idImovel, c.dbac_id as idDebitoACobrar, "
					+ " b1.dbac_vldebito as valorDebito, b1.dbac_nnprestacaocobradas as numeroPrestacaoCobradas, "
					+ " b1.dbac_nnprestacaodebito as numeroPrestacaoDebito,  c.pghi_dtpagamento as dataPagamento, "
					+ " c.pghi_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoDebito, k.dbtp_dsdebitotipo as tipoDebitoDebito, "
					+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, c.pghi_vlpagamento as valorPagamento, "
					+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, j.pgst_id as idSituacaoPagamentoAnterior, "
					+ " j.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, b1.imov_id as idImovelDebito, c.loca_id as idLocalidade, "
                    + " b1.dbac_nnparcelabonus as numeroParcelaBonus "
					+ " FROM arrecadacao.pagamento_historico c "
					+ " INNER JOIN "
					+ " faturamento.debito_a_cobrar b1 "
					+ "  on b1.dbac_id = c.dbac_id "
					+ " INNER JOIN "
					+ " cadastro.cliente_imovel b "
					+ " on b.imov_id = b1.imov_id "
					+ " INNER JOIN "
					+ " cadastro.cliente a "
					+ " on a.clie_id = b.clie_id "
					+ " INNER JOIN "
					+ " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id "
					+ " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id "
					+ " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id "
					+ " INNER JOIN "
					+ " cadastro.cliente h "
					+ "  on h.clie_id = g.clie_id "
					+ " INNER JOIN "
					+ " faturamento.debito_tipo k "
					+ "  on b1.dbtp_id = k.dbtp_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao j "
					+ "  on c.pgst_idatual = j.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " arrecadacao.pagamento_situacao l "
					+ "  on c.pgst_idanterior = l.pgst_id "
					+ " LEFT OUTER JOIN "
					+ " faturamento.debito_tipo m "
					+ " on c.dbtp_id = m.dbtp_id "
					+ " WHERE "
					+ condicionais
					+ " order by idLocalidade, idImovel, idTipoDebitoPagamento, dataPagamento ";

			retorno = session
					.createSQLQuery(hql)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idDebitoACobrar", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("numeroPrestacaoCobradas", Hibernate.SHORT)
					.addScalar("numeroPrestacaoDebito", Hibernate.SHORT)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("anoMesPagamento", Hibernate.INTEGER)
					.addScalar("idTipoDebitoDebito", Hibernate.INTEGER)
					.addScalar("tipoDebitoDebito", Hibernate.STRING)
					.addScalar("idTipoDebitoPagamento", Hibernate.INTEGER)
					.addScalar("tipoDebitoPagamento", Hibernate.STRING)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAtual", Hibernate.STRING)
					.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER)
					.addScalar("situacaoPagamentoAnterior", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar(
							"idImovelDebito", Hibernate.INTEGER).addScalar(
							"idLocalidade", Hibernate.INTEGER).addScalar("numeroParcelaBonus", Hibernate.SHORT).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtrar a quantidade de pagamento historicos do cliente
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Santos
	 * @date 06/10/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoClienteCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) throws ErroRepositorioException {
		int retorno = 0;
		Object pagamentoHistoricoClienteCount;
		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);

			hql = " select count (pagamentoHistorico.id) "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " inner join pagamentoHistorico.cliente as cliente "
					+ condicionais + " ";

			pagamentoHistoricoClienteCount = session.createQuery(hql)
					.setMaxResults(1).uniqueResult();

			if (pagamentoHistoricoClienteCount != null) {
				retorno = (Integer) pagamentoHistoricoClienteCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os pagamento historicos do cliente
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 21/08/06,06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoCliente(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina) throws ErroRepositorioException {

		Collection<PagamentoHistorico> retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);

			hql = " select distinct pagamentoHistorico "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " inner join pagamentoHistorico.cliente as cliente "
					+ " LEFT JOIN FETCH pagamentoHistorico.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico conta "
					+ " LEFT JOIN FETCH pagamentoHistorico.documentoTipo "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoTipo "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior "
					+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamento guiaPagamento "
					+ " LEFT JOIN FETCH guiaPagamento.debitoTipo "
					+ " LEFT JOIN FETCH pagamentoHistorico.avisoBancario avisoBancario "
					+ " LEFT JOIN FETCH avisoBancario.arrecadador "

					+ condicionais
					+ " order by pagamentoHistorico.documentoTipo.id,pagamentoHistorico.dataPagamento "
					+ " ";

			retorno = session.createQuery(hql)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra a quantiadade dos Pagamento Historicos da Localidade
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoHistoricoLocalidadeCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) throws ErroRepositorioException {
		int retorno = 0;
		Object pagamentoHistoricoLocalidadeCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);

			hql = " select count(pagamentoHistorico.id) "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ condicionais + " ";

			pagamentoHistoricoLocalidadeCount = session.createQuery(hql)
					.setMaxResults(1).uniqueResult();

			if (pagamentoHistoricoLocalidadeCount != null) {
				retorno = (Integer) pagamentoHistoricoLocalidadeCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os Pagamento Historicos da Localidade
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoLocalidade(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina) throws ErroRepositorioException {
		Collection<PagamentoHistorico> retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamentoHistorico "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " INNER JOIN FETCH pagamentoHistorico.avisoBancario avbc "
					+ " INNER JOIN FETCH avbc.arrecadador arrec "
					+ " INNER JOIN FETCH arrec.cliente cliArrec "
					+ " INNER JOIN FETCH pagamentoHistorico.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamentoHistorico.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico conta "
					+ " LEFT JOIN FETCH pagamentoHistorico.imovel imov "
					+ " LEFT JOIN FETCH imov.localidade locImov "
					+ " LEFT JOIN FETCH imov.setorComercial setComImov "
					+ " LEFT JOIN FETCH imov.quadra quadra "
					+ " LEFT JOIN FETCH pagamentoHistorico.localidade loc "
					+ " LEFT JOIN FETCH loc.gerenciaRegional gr "
					+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ condicionais + " ";

			retorno = session.createQuery(hql)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	

	/**
	 * Filtra oas pagamento historicos do Aviso Bancario
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoAvisoBancario(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ErroRepositorioException {
		Collection<PagamentoHistorico> retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamentoHistorico "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " INNER JOIN FETCH pagamentoHistorico.avisoBancario as avisoBancario "
					+ " LEFT JOIN FETCH pagamentoHistorico.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico conta "
					+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ condicionais + " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra a quantidade de pagamento historicos do avio bancario
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoAvisoBancarioCount(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ErroRepositorioException {
		int retorno = 0;
		Object pagamentoHistoricoAvisoBancarioCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);

			hql = " select count (pagamentoHistorico.id) "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " inner join pagamentoHistorico.avisoBancario as avisoBancario "
					+ condicionais + " ";

			pagamentoHistoricoAvisoBancarioCount = session.createQuery(hql)
					.setMaxResults(1).uniqueResult();

			if (pagamentoHistoricoAvisoBancarioCount != null) {
				retorno = (Integer) pagamentoHistoricoAvisoBancarioCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os pagamento historicos do aviso bancario para paginação
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoAvisoBancarioParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina) throws ErroRepositorioException {

		Collection<PagamentoHistorico> retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);

			hql = " select distinct pagamentoHistorico "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " inner join pagamentoHistorico.avisoBancario as avisoBancario "

					+ " LEFT JOIN FETCH pagamentoHistorico.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico conta "
					+ " LEFT JOIN FETCH pagamentoHistorico.cliente "
					+ " LEFT JOIN FETCH pagamentoHistorico.documentoTipo "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoTipo "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior "
					+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamento guiaPagamento "
					+ " LEFT JOIN FETCH pagamentoHistorico.avisoBancario avisoBancario "
					+ " LEFT JOIN FETCH guiaPagamento.debitoTipo "
					+ " LEFT JOIN FETCH avisoBancario.arrecadador "

					+ condicionais + " ";

			retorno = session.createQuery(hql)
					.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtrar pagamentos historicos do movimento arrecador
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoMovimentoArrecadador(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ErroRepositorioException {
		Collection<PagamentoHistorico> retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamentoHistorico "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " INNER JOIN FETCH pagamentoHistorico.arrecadadorMovimentoItem as arrecadadorMovimentoItem "
					+ " INNER JOIN FETCH arrecadadorMovimentoItem.arrecadadorMovimento as arrecadadorMovimento "
					+ " INNER JOIN FETCH pagamentoHistorico.avisoBancario avbc "
					+ " INNER JOIN FETCH avbc.arrecadador arrec "
					+ " INNER JOIN FETCH pagamentoHistorico.documentoTipo doctoTp "
					+ " LEFT JOIN FETCH pagamentoHistorico.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico conta "
					+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamento gpag "
					+ " LEFT JOIN FETCH gpag.debitoTipo dbtpGpag "
					+ " LEFT JOIN FETCH pagamentoHistorico.debitoACobrarGeral dbcbGeral "
					+ " LEFT JOIN FETCH dbcbGeral.debitoACobrar dbcb "
					+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
					+ " LEFT JOIN FETCH pagamentoHistorico.arrecadacaoForma arrecForma "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ " LEFT JOIN FETCH pagamentoHistorico.cliente cli "
					+ condicionais
					+ " order by pagamentoHistorico.localidade.id, pagamentoHistorico.imovel.id, "
					+ " pagamentoHistorico.debitoTipo.id, pagamentoHistorico.dataPagamento "
					+ " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * por historico
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamentoHistorico
	 * 
	 * @author Rafael Santos
	 * @date 07/10/2006
	 * 
	 * @param idImovel
	 * @param idCliente
	 * @param idTipoRelacao
	 * @param localidadeInicial
	 * @param localidadeFinal
	 * @param idAvisoBancario
	 * @param idArrecadador
	 * @param periodoArrecadacaoInicial
	 * @param periodoArrecadacaoFinal
	 * @param periodoPagamentoInicio
	 * @param periodoPagamentoFim
	 * @param dataPagamentoInicial
	 * @param dataPagamentoFinal
	 * @param idsPagamentosSituacoes
	 * @param idsDebitosTipos
	 * @param idsArrecadacaoForma
	 * @param idsDocumentosTipos
	 * @return
	 */
	public String criarCondicionaisPagamentoHistorico(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) {

		String sql = " where ";
		if (idImovel != null && !idImovel.equals("")) {
			sql = sql + " pagamentoHistorico.imovel.id = " + idImovel + " and ";
		}
		if (idCliente != null && !idCliente.equals("")) {
			sql = sql + " pagamentoHistorico.cliente.id = " + idCliente
					+ " and ";
		}
		if (idTipoRelacao != null && !idTipoRelacao.equals("")) {
			sql = sql + " clienteRelacaoTipo.id = " + idTipoRelacao + " and ";
		}
		if (localidadeInicial != null && localidadeFinal != null
				&& !localidadeInicial.equals("") && !localidadeFinal.equals("")) {
			sql = sql + " pagamentoHistorico.localidade.id >= "
					+ localidadeInicial + " and ";
			sql = sql + " pagamentoHistorico.localidade.id <= "
					+ localidadeFinal + " and ";
		}
		if (idAvisoBancario != null && !idAvisoBancario.equals("")) {
			sql = sql + " pagamentoHistorico.avisoBancario.id = "
					+ idAvisoBancario + " and ";
		}
		if (idArrecadador != null && !idArrecadador.equals("")) {
			sql = sql + " arrecadadorMovimento.id = " + idArrecadador + " and ";
		}
		if (periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoInicial.equals("")) {
			sql = sql
					+ " pagamentoHistorico.anoMesReferenciaArrecadacao >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
					+ " and ";
		}
		if (periodoArrecadacaoFinal != null
				&& !periodoArrecadacaoFinal.equals("")) {
			sql = sql
					+ " pagamentoHistorico.anoMesReferenciaArrecadacao <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal)
					+ " and ";
		}
		if (periodoPagamentoInicio != null
				&& !periodoPagamentoInicio.equals("")) {
			sql = sql
					+ " pagamentoHistorico.anoMesReferenciaPagamento >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
					+ " and ";
		}
		if (periodoPagamentoFim != null && !periodoPagamentoFim.equals("")) {
			sql = sql
					+ " pagamentoHistorico.anoMesReferenciaPagamento <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim)
					+ " and ";
		}

		if (dataPagamentoInicial != null && !dataPagamentoInicial.equals("")) {
			
			sql = sql + " pagamentoHistorico.dataPagamento >= :dataPagamentoInicial and ";
			
		}
		if (dataPagamentoFinal != null && !dataPagamentoFinal.equals("")) {
			
			sql = sql + " pagamentoHistorico.dataPagamento <= :dataPagamentoFinal and ";
		}

		if (idsPagamentosSituacoes != null
				&& !idsPagamentosSituacoes.equals("")) {
			String valoresIn = "";
			for (int i = 0; i < idsPagamentosSituacoes.length; i++) {
				if (!idsPagamentosSituacoes[i].equals("")) {
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql
						+ " pagamentoHistorico.pagamentoSituacaoAtual.id in ("
						+ valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDebitosTipos != null
				&& !idsDebitosTipos.equals("")
				&& !idsDebitosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDebitosTipos.length; i++) {
				if (!idsDebitosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " pagamentoHistorico.debitoTipo.id in ("
						+ valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsArrecadacaoForma != null
				&& !idsArrecadacaoForma.equals("")
				&& !idsArrecadacaoForma[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsArrecadacaoForma.length; i++) {
				if (!idsArrecadacaoForma[i].equals("")) {
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " pagamentoHistorico.arrecadacaoForma.id in ("
						+ valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDocumentosTipos != null
				&& !idsDocumentosTipos.equals("")
				&& !idsDocumentosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDocumentosTipos.length; i++) {
				if (!idsDocumentosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " pagamentoHistorico.documentoTipo.id in ("
						+ valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}

		// retira o " and " q fica sobrando no final da query
		sql = Util.removerUltimosCaracteres(sql, 4);
		

		// [SB0006] Ordenar Pagamentos de Acordo com o Tipo de Documento
		// 1. Para os pagamentos com tipo de documento(DOPT_ID) com valor
		// correspondente a conta,
		// ordena os pagamentos pela localidade (LOCA_ID), matrícula do imóvel
		// (IMOV_ID), ano/mês
		// de referênca do pagamento(PGHI_AMREFERENCIAPAGAMENTO), e data de
		// pagamento (PGHI_DTPAGAMENTO)

		// 2. Para os pagamentos com tipo do documento(DOPT_ID) com o valor
		// correspondente a guia de
		// pagamento, ordena os pagamentos pela localidade (LOCA_ID), matrícula
		// do imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGHI_DTPAGAMENTO)

		// 3. Para os pagamentos com tipo de documento(DOPT_ID) com o valor
		// correspondente a débito a
		// cobrar, ordena os pagamentos pela localidade (LOCA_ID), matrícula do
		// imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGHI_DTPAGAMENTO)

		return sql;
	}

	/**
	 * Faz a pesquisa de devoluçãoHistorico fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 09/10/2006
	 * 
	 * @param FiltroDevolucaoHistorico
	 * @return Collection<DevolucaoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<DevolucaoHistorico> pesquisarDevolucaoHistorico(
			FiltroDevolucaoHistorico filtroDevolucaoHistorico)
			throws ErroRepositorioException {

		Collection<DevolucaoHistorico> retorno = null;

		Session session = HibernateUtil.getSession();

		try {

			retorno = new ArrayList(
				new CopyOnWriteArraySet<DevolucaoHistorico>(
					GeradorHQLCondicional.gerarCondicionalQuery(
						filtroDevolucaoHistorico,
						"devolucaoHistorico",
						"select distinct devolucaoHistorico from gcom.arrecadacao.DevolucaoHistorico as devolucaoHistorico "
								+ "left join fetch devolucaoHistorico.guiaDevolucao "
								+ "left join devolucaoHistorico.guiaDevolucao.conta.clienteContas clienteContas "
								+ "left join devolucaoHistorico.imovel.clienteImoveis clienteImoveis "
								+ "left join fetch devolucaoHistorico.imovel as imov "
								+ "left join fetch imov.localidade as loca "
								+ "left join fetch imov.setorComercial "
								+ "left join fetch imov.quadra "
								+ "left join fetch devolucaoHistorico.debitoTipo "
								+ "left join fetch devolucaoHistorico.avisoBancario avis "
								+ "left join fetch avis.arrecadador arre "
								+ "left join fetch arre.cliente "
								+ "left join fetch devolucaoHistorico.devolucaoSituacaoAtual "
								+ "left join fetch devolucaoHistorico.guiaDevolucao.documentoTipo "
								+ "left join fetch loca.gerenciaRegional "
								+ "left join devolucaoHistorico.guiaDevolucao.guiaPagamento.clientesGuiaPagamento clientesGuiaPagamento ",
											session).list()));

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * histórico para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos histórico do tipo Debito a Cobrar do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 13/11/06
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoLocalidadeRelatorio(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = "SELECT pagto.id, loc.id, loc.descricao, "
					+ "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
					+ "cliArrec.nome, pagto.dataPagamento, "
					+ "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
					+ "conta.valorAgua, conta.valorEsgoto, conta.valorDebitos, "
					+ "conta.valorCreditos, "
					+ "CASE WHEN dbcb is not null "
					+ "THEN dbcb.valorDebito "
					+ "ELSE dbcbHist.valorDebito "
					+ "END as valorDebito, "
					+ "CASE WHEN dbcb is not null "
					+ "THEN dbcb.numeroPrestacaoDebito "
					+ "ELSE dbcbHist.prestacaoDebito "
					+ "END as numeroPrestacaoDebito, "
					+ "CASE WHEN dbcb is not null "
					+ "THEN dbcb.numeroPrestacaoCobradas "
					+ "ELSE dbcbHist.prestacaoCobradas "
					+ "END as numeroPrestacaoCobradas, "
					+ "gpag.valorDebito, pagto.valorPagamento, "
					+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id, conta.valorImposto "
					+ "FROM PagamentoHistorico pagto "
					+ "INNER JOIN pagto.localidade loc "
					+ "INNER JOIN loc.gerenciaRegional gr "
					+ "INNER JOIN pagto.avisoBancario avbc "
					+ "INNER JOIN avbc.arrecadador arrec "
					+ "INNER JOIN arrec.cliente cliArrec "
					+ "INNER JOIN pagto.documentoTipo doctoTp "
					+ "LEFT JOIN pagto.imovel imov "
					+ "LEFT JOIN pagto.cliente cli "
					+ "LEFT JOIN pagto.debitoTipo dbtp "
					+ "LEFT JOIN pagto.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.contaHistorico conta "
					+ "LEFT JOIN pagto.guiaPagamento gpag "
					+ "LEFT JOIN pagto.debitoACobrarGeral dbcbGeral "
					+ "LEFT JOIN dbcbGeral.debitoACobrar dbcb "
					+ "LEFT JOIN dbcbGeral.debitoACobrarHistorico dbcbHist "
					+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
					+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem "
					+ "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
					+ "LEFT JOIN pagto.arrecadacaoForma arrecForma "
					+ condicionais + " ORDER BY loc.id, imov.id, "
					+ " dbtp.id, pagto.dataPagamento ";

			// hql = " select distinct pagamentoHistorico "
			// + " from gcom.arrecadacao.pagamento.PagamentoHistorico as
			// pagamentoHistorico "
			// + condicionais
			// + " order by pagamentoHistorico.localidade.id,
			// pagamentoHistorico.imovel.id, "
			// + " pagamentoHistorico.debitoTipo.id,
			// pagamentoHistorico.dataPagamento "
			// + " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta dados da tabela dados diarios arrecadacao
	 * 
	 * @author Rafael Santos
	 * @created 21/10/2006
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarDadosDiarios(int idGerenciaRegional,
			int idLocalidade, int idElo) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select gerenciaRegional.nome,localidade.descricao,elo.descricao "
					+ " from ArrecadacaoDadosDiarios arrecadacaoDadosDiarios "
					+ "left join arrecadacaoDadosDiarios.localidade localidade "
					+ "left join localidade.localidade elo "
					+ "left join arrecadacaoDadosDiarios.gerenciaRegional gerenciaRegional"
					+ " where " + "localidade.id = :idLocalidade ";
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setMaxResults(1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa conta e agência do sistema de parâmetros
	 * 
	 * @author Ana Maria
	 * @date 23/10/06
	 * 
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaAgenciaSistemaParametro()
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select cont.numeroConta, agen.codigoAgencia"
					+ " from SistemaParametro parm"
					+ " left join parm.contaBancaria cont"
					+ " left join cont.agencia agen";

			retorno = (Object[]) session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa id do lançamento contabil
	 * 
	 * @author Sávio Luiz
	 * @date 08/11/06
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdLancamentoItemContabil(Integer idCreditoTipo)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select lancamentoItemContab.id "
					+ " from CreditoTipo credTipo "
					+ " left join credTipo.lancamentoItemContabil lancamentoItemContab "
					+ " where credTipo.id = :idCreditoTipo";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idCreditoTipo", idCreditoTipo).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * pesquisar descrição do Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 22/11/06
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public String pesquisarDescricaoDebitoAutomatico(Integer codigoRetorno)
			throws ErroRepositorioException {

		String retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select debAutomaticoRetCod.descricaoDebitoAutomaticoRetornoCodigo "
					+ " from DebitoAutomaticoRetornoCodigo debAutomaticoRetCod "
					+ " where debAutomaticoRetCod.id = :codigoRetorno";

			retorno = (String) session.createQuery(consulta).setInteger(
					"codigoRetorno", codigoRetorno).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a lista de ano/mês de arrecadaçaõ menores e igual ao ano/mês de
	 * arrecadação atual.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 18/04/2006, 29/11/2006
	 * 
	 * @param anoMesArrecadacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesArrecadacaoMenorIgualAtual(
			Integer anoMesArrecadacaoAtual) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select distinct(anoMesReferenciaArrecadacao) from Pagamento pagamento "
					+ " where pagamento.anoMesReferenciaArrecadacao <= :anoMesArrecadacaoAtual";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesArrecadacaoAtual", anoMesArrecadacaoAtual).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a lista de ano/mês de arrecadação menores e igual ao ano/mês de
	 * arrecadação atual e igual ao id do imóvel informado.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 18/04/2006, 29/11/2006
	 * 
	 * @param anoMesArrecadacaoAtual
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesArrecadacaoMenorIgualAtualPorImovel(
			Integer anoMesArrecadacaoAtual, Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select distinct(anoMesReferenciaArrecadacao) from Pagamento pagamento "
					+ " where pagamento.anoMesReferenciaArrecadacao <= :anoMesArrecadacaoAtual "
					+ "and pagamento.imovel.id = :idImovel";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesArrecadacaoAtual", anoMesArrecadacaoAtual)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar uma coleção de ids de localidades que possuem pagamentos
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 29/11/2006
	 * 
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsImovelPorLocalidade(Integer idLocalidade,
			Integer numeroIndice, Integer quantidadeRegistros)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select distinct(imov.id) from Pagamento pgmt "
					+ "inner join pgmt.imovel imov "
					+ "inner join imov.localidade loca "
					+ "left join pgmt.pagamentoSituacaoAtual pgstIdAtual "
					+ "where loca.id = :idLocalidade and (pgstIdAtual.id is null or pgstIdAtual.id <> :idValorABaixar) "
					+ " and pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao " 
					+ "order by imov.id";

			retorno = session.createQuery(consulta)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
					.setShort("indicadorClassificacao", ConstantesSistema.NAO)
					.setMaxResults(quantidadeRegistros).setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de Movimento
	 * Arrecadadores
	 * 
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @return
	 */
	public String criarCondicionaisMovimentoArrecadador(String codigoBanco,
			String codigoRemessa, String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado) {

		// String from = " FROM arrecadacao.arrecadador_movimento
		// arrecadadorMovimento ";
		String where = " WHERE ";

		// ------------------- Where -------------------------
		if (codigoBanco != null && !codigoBanco.equals("")) {
			where = where + " arrecadadorMovimento.armv_cdbanco = "
					+ codigoBanco + " and ";
		}

		if (codigoRemessa != null && !codigoRemessa.equals("")) {
			where = where + " arrecadadorMovimento.armv_cdremessa = "
					+ codigoRemessa + " and ";
		}

		if (descricaoIdentificacaoServico != null
				&& !descricaoIdentificacaoServico.trim().equals("")) {
			where = where
					+ " arrecadadorMovimento.armv_dsidentificacaoservico = '"
					+ descricaoIdentificacaoServico.trim() + "' and ";
		}

		if (numeroSequencialArquivo != null
				&& !numeroSequencialArquivo.equals("")) {
			where = where + " arrecadadorMovimento.armv_nnnsa = "
					+ numeroSequencialArquivo + " and ";
		}

		if (dataGeracaoInicio != null && !dataGeracaoInicio.equals("")) {

			String data1 = Util.recuperaDataInvertida(dataGeracaoInicio);

			if (data1 != null && !data1.equals("")
					&& data1.trim().length() == 8) {

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6)
						+ "-" + data1.substring(6, 8);
			}
			where = where + " arrecadadorMovimento.armv_dtgeracao >= to_date('" + data1

					+ "', 'YYYY/MM/DD' ) and ";
		}

		if (dataGeracaoFim != null && !dataGeracaoFim.equals("")) {

			String data2 = Util.recuperaDataInvertida(dataGeracaoFim);

			if (data2 != null && !data2.equals("")
					&& data2.trim().length() == 8) {

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6)
						+ "-" + data2.substring(6, 8);
			}
			where = where + " arrecadadorMovimento.armv_dtgeracao <= to_date('" + data2
					+ "', 'YYYY/MM/DD') and ";

		}
		// comentado por sávio em 02/05/2007,foi colocado essa parte no método
		// if (ultimaAlteracaoInicio != null &&
		// !ultimaAlteracaoInicio.equals("")) {
		//
		// where = where + " arrecadadorMovimento.armv_tmultimaalteracao >= '"
		// + Util.formatarDataInicial(ultimaAlteracaoInicio)
		// + "' and ";
		// }
		//
		// if (ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")) {
		//
		// where = where + " arrecadadorMovimento.armv_tmultimaalteracao <= '"
		// + Util.formatarDataFinal(ultimaAlteracaoFim) + "' and ";
		// }

		if (indicadorAbertoFechado != null
				&& !indicadorAbertoFechado.equals("")) {

			if (indicadorAbertoFechado.equals(""
					+ ConstantesSistema.MOVIMENTO_ABERTO)) {
				// where = where + " armv_vltotalmovimento <> (select
				// sum(avbc_vlarrecadacaocalculado)" +
				// " from arrecadacao.aviso_bancario avisoBancario" +
				// " where arrecadadorMovimento.armv_id = avisoBancario.armv_id)
				// and ";

				where = where
						+ " (armv_vltotalmovimento <> (select sum(avbc_vlarrecadacaocalculado)"
						+ " from arrecadacao.aviso_bancario avisoBancario"
						+ " where  arrecadadorMovimento.armv_id = avisoBancario.armv_id)"
						+ " or"
						+ " 0 = (select count(*)"
						+ " from arrecadacao.aviso_bancario aBancario"
						+ " where  arrecadadorMovimento.armv_id = aBancario.armv_id)) and ";

			} else if (indicadorAbertoFechado.equals(""
					+ ConstantesSistema.MOVIMENTO_FECHADO)) {
				where = where
						+ " armv_vltotalmovimento = (select sum(avbc_vlarrecadacaocalculado)"
						+ " from arrecadacao.aviso_bancario avisoBancario"
						+ " where  arrecadadorMovimento.armv_id = avisoBancario.armv_id) and ";

			}
		}

		String subSelectMovimentoArrecadadorItem = "";

		if (indicadorAceitacao != null && !indicadorAceitacao.equals("")) {

			subSelectMovimentoArrecadadorItem = " 0 < (select count(*)"
					+ " from arrecadacao.arrecadador_mov_item arrecadadorMovimentoItem"
					+ " where amit_icaceitacao = "
					+ indicadorAceitacao
					+ " and arrecadadorMovimento.armv_id = arrecadadorMovimentoItem.armv_id";

			if (descricaoOcorrencia != null && !descricaoOcorrencia.equals("")) {
				if (descricaoOcorrencia
						.equals("" + ConstantesSistema.SEM_ITENS)) {
					// sem itens em ocorrência
					subSelectMovimentoArrecadadorItem = subSelectMovimentoArrecadadorItem
							+ " and amit_dsocorrencia = 'OK'";
				} else {
					// com itens em ocorrência
					subSelectMovimentoArrecadadorItem = subSelectMovimentoArrecadadorItem
							+ " and amit_dsocorrencia <> 'OK'";
				}
			}

			subSelectMovimentoArrecadadorItem = subSelectMovimentoArrecadadorItem
					+ ")";

		} else if (descricaoOcorrencia != null
				&& !descricaoOcorrencia.equals("")) {
			if (descricaoOcorrencia.equals("" + ConstantesSistema.SEM_ITENS)) {
				// sem itens em ocorrência
				subSelectMovimentoArrecadadorItem = " 0 < (select count(*)"
						+ " from arrecadacao.arrecadador_mov_item arrecadadorMovimentoItem"
						+ " where amit_dsocorrencia = 'OK'"
						+ " and  arrecadadorMovimento.armv_id = arrecadadorMovimentoItem.armv_id)";

			} else {
				// com itens em ocorrência
				subSelectMovimentoArrecadadorItem = " 0 < (select count(*)"
						+ " from arrecadacao.arrecadador_mov_item arrecadadorMovimentoItem"
						+ " where amit_dsocorrencia <> 'OK'"
						+ " and  arrecadadorMovimento.armv_id = arrecadadorMovimentoItem.armv_id)";
			}
		}

		if (!subSelectMovimentoArrecadadorItem.equals("")) {
			where = where + subSelectMovimentoArrecadadorItem;
		} else {
			// retira o " and " q fica sobrando no final da query
			if (!where.trim().equals("WHERE")) {
				where = Util.removerUltimosCaracteres(where, 4);
			}
		}

		String sql = where;
		return sql;
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param numeroPagina
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarMovimentoArrecadadorParaPaginacao(
			String codigoBanco, String codigoRemessa,
			String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, Integer numeroPagina,
			String indicadorAbertoFechado) throws ErroRepositorioException {

		Collection retorno = null;
		String sql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisMovimentoArrecadador(
					codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
					numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
					ultimaAlteracaoInicio, ultimaAlteracaoFim,
					descricaoOcorrencia, indicadorAceitacao,
					indicadorAbertoFechado);

			sql = " SELECT arrecadadorMovimento.armv_cdbanco as codBanco,"
					+ " arrecadadorMovimento.armv_cdremessa as codRemessa,"
					+ " arrecadadorMovimento.armv_dsidentificacaoservico as descIdentServico,"
					+ " arrecadadorMovimento.armv_nnnsa as numeroSeqArquivo,"
					+ " arrecadadorMovimento.armv_id as id,"
					+ " arrecadadorMovimento.armv_dtgeracao as dataGeracao,"
					+ " arrecadadorMovimento.armv_nnregistrosmovimento as numRegistroMovimento,"
					+ " arrecadadorMovimento.armv_vltotalmovimento as vlTotalMovimento,"
					+ " arrecadadorMovimento.armv_tmultimaalteracao as ultimaAlteracao, "
					+ " arrecadadorMovimento.armv_nmbanco as nomeBanco"
					+ " FROM arrecadacao.arrecadador_movimento arrecadadorMovimento "
					+ condicionais;

			Date dataInicio = null;
			Date dataFim = null;
			if (ultimaAlteracaoInicio != null
					&& !ultimaAlteracaoInicio.equals("")) {

				dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);
				if (condicionais.trim().equals("WHERE")) {
					sql = sql
							+ "arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				} else {
					sql = sql
							+ " and arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				}

			}

			if (ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")) {

				dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);
				sql = sql
						+ " and arrecadadorMovimento.armv_tmultimaalteracao <= :dataFim";

			}
			
			sql = sql + " ORDER BY arrecadadorMovimento.armv_nnnsa";
			
			if (dataInicio != null && dataFim != null) {
				retorno = session.createSQLQuery(sql).addScalar("codBanco",
						Hibernate.SHORT).addScalar("codRemessa",
						Hibernate.SHORT).addScalar("descIdentServico",
						Hibernate.STRING).addScalar("numeroSeqArquivo",
						Hibernate.INTEGER).addScalar("id", Hibernate.INTEGER)
						.addScalar("dataGeracao", Hibernate.DATE).addScalar(
								"numRegistroMovimento", Hibernate.INTEGER)
						.addScalar("vlTotalMovimento", Hibernate.BIG_DECIMAL)
						.addScalar("ultimaAlteracao", Hibernate.TIMESTAMP)
						.addScalar("nomeBanco", Hibernate.STRING).setTimestamp(
								"dataInicio", dataInicio).setTimestamp(
								"dataFim", dataFim).setFirstResult(
								10 * numeroPagina).setMaxResults(10).list();

			} else {

				retorno = session.createSQLQuery(sql).addScalar("codBanco",
						Hibernate.SHORT).addScalar("codRemessa",
						Hibernate.SHORT).addScalar("descIdentServico",
						Hibernate.STRING).addScalar("numeroSeqArquivo",
						Hibernate.INTEGER).addScalar("id", Hibernate.INTEGER)
						.addScalar("dataGeracao", Hibernate.DATE).addScalar(
								"numRegistroMovimento", Hibernate.INTEGER)
						.addScalar("vlTotalMovimento", Hibernate.BIG_DECIMAL)
						.addScalar("ultimaAlteracao", Hibernate.TIMESTAMP)
						.addScalar("nomeBanco", Hibernate.STRING)
						.setFirstResult(10 * numeroPagina).setMaxResults(10)
						.list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer filtrarMovimentoArrecadadoresCount(String codigoBanco,
			String codigoRemessa, String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado)
			throws ErroRepositorioException {

		Integer movimentoArrecadadorCount = null;
		String sql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisMovimentoArrecadador(
					codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
					numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
					ultimaAlteracaoInicio, ultimaAlteracaoFim,
					descricaoOcorrencia, indicadorAceitacao,
					indicadorAbertoFechado);

			sql = " SELECT count (arrecadadorMovimento.armv_id) as qtdeMovimentoArrecadador "
					+ " FROM arrecadacao.arrecadador_movimento arrecadadorMovimento "
					+ condicionais;

			Date dataInicio = null;
			Date dataFim = null;
			if (ultimaAlteracaoInicio != null
					&& !ultimaAlteracaoInicio.equals("")) {

				dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);
				if (condicionais.trim().equals("WHERE")) {
					sql = sql
							+ "arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				} else {
					sql = sql
							+ " and arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				}

			}

			if (ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")) {

				dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);
				sql = sql
						+ " and arrecadadorMovimento.armv_tmultimaalteracao <= :dataFim";

			}
			if (dataInicio != null && dataFim != null) {
				movimentoArrecadadorCount = (Integer) session.createSQLQuery(
						sql).addScalar("qtdeMovimentoArrecadador",
						Hibernate.INTEGER).setTimestamp("dataInicio",
						dataInicio).setTimestamp("dataFim", dataFim)
						.setMaxResults(1).uniqueResult();

			} else {
				movimentoArrecadadorCount = (Integer) session.createSQLQuery(
						sql).addScalar("qtdeMovimentoArrecadador",
						Hibernate.INTEGER).setMaxResults(1).uniqueResult();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return movimentoArrecadadorCount;

	}

	/**
	 * retorna o somatorio de PGMT_VLPAGAMENTO da tabela PAGAMENTO com AMIT_ID
	 * =AMIT_ID da tabela ARRECADADOR_MOVIMENTO_ITEM
	 * 
	 * [UC0254] Efetuar Análise do Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 05/12/2006
	 * 
	 * @param idArrecadadorMovimentoItem
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal recuperaValorPagamentoArrecadadorMovimentoItem(
			Integer idArrecadadorMovimentoItem) throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			
			consulta = "SELECT SUM( COALESCE ( pgmt_vlpagamento, 0 ) ) as valor"
				+ " FROM (" 
					+ " SELECT pgto.pgmt_vlpagamento" 
					+ " FROM arrecadacao.pagamento pgto" 
					+ " WHERE pgto.amit_id = :idArrecadadorMovimentoItem"
				+ " UNION ALL"
					+ " SELECT pgto.pghi_vlpagamento" 
					+ " FROM arrecadacao.pagamento_historico pgto" 
					+ " WHERE pgto.amit_id = :idArrecadadorMovimentoItem ) temp";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta).
				addScalar("valor", Hibernate.BIG_DECIMAL).
				setInteger("idArrecadadorMovimentoItem", idArrecadadorMovimentoItem).
				setMaxResults(1).
				uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * retorna a decrição da Forma de Arrecadação (arfm_dsarrecadacaoforma) da
	 * tabela ARRECADACAO_FORMA a partir do codigoArrecadacaoForma
	 * (arfm_cdarrecadacaoforma) passado
	 * 
	 * [UC0262] Distribuir Dados do Registro do Movimento do Arrecadador
	 * 
	 * @author Vivianne Sousa
	 * @date 06/12/2006
	 * 
	 * @param codigoArrecadacaoForma
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String recuperaDescricaoArrecadacaoForma(
			String codigoArrecadacaoForma) throws ErroRepositorioException {

		String retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select descricao from ArrecadacaoForma "
					+ " where codigoArrecadacaoForma = :codigoArrecadacaoForma";

			retorno = (String) session.createQuery(consulta).setString(
					"codigoArrecadacaoForma", codigoArrecadacaoForma.trim())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Atualiza o valor excedente e a situação dos pagamentos informados para o
	 * tipode situação informada.
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2006, 12/12/2006, 02/10/2007
	 * 
	 * @param colecaoPagamento
	 * @param pagamentoSituacao
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoEValorExcedentePagamento(
			Collection<Pagamento> colecaoPagamento, Integer pagamentoSituacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Iterator<Pagamento> iteratorPagamentos = colecaoPagamento.iterator();
		String atualizarValorExcedente;
		Pagamento pagamento = null;

		try {
			int i = 1;
			while (iteratorPagamentos.hasNext()) {
				pagamento = iteratorPagamentos.next();

				//Conta
				if(pagamento.getContaGeral() != null){
					
					atualizarValorExcedente = "UPDATE Pagamento pgmt "
						+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
						+ "pgmt.valorExcedente = :valorExcedente, "
						+ "pgmt.ultimaAlteracao = :dataAlteracao, "
						+ "pgmt.contaGeral.id = :idConta, "
						+ "pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
						+ "WHERE pgmt.id = :idPagamento ";

					session.createQuery(atualizarValorExcedente)
						.setBigDecimal("valorExcedente", pagamento.getValorExcedente())
						.setTimestamp("dataAlteracao", new Date())
						.setInteger("pagamentoSituacao", pagamentoSituacao)
						.setInteger("idPagamento", pagamento.getId())
						.setInteger("idConta", pagamento.getContaGeral().getId())
						.setShort("indicadorClassificacao", pagamento.getIndicadorClassificadoRecuperacaoCredito())
						.executeUpdate();
					
					//Guia de Pagamento
				}else if(pagamento.getGuiaPagamento() != null){
					
					atualizarValorExcedente = "UPDATE Pagamento pgmt "
						+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
						+ "pgmt.valorExcedente = :valorExcedente, "
						+ "pgmt.ultimaAlteracao = :dataAlteracao, "
						+ "pgmt.guiaPagamento.id = :idGuiaPagamento, "
						+ "pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
						+ "WHERE pgmt.id = :idPagamento ";

					session.createQuery(atualizarValorExcedente)
						.setBigDecimal("valorExcedente", pagamento.getValorExcedente())
						.setTimestamp("dataAlteracao", new Date())
						.setInteger("pagamentoSituacao", pagamentoSituacao)
						.setInteger("idPagamento", pagamento.getId())
						.setInteger("idGuiaPagamento", pagamento.getGuiaPagamento().getId())
						.setShort("indicadorClassificacao", pagamento.getIndicadorClassificadoRecuperacaoCredito())
						.executeUpdate();
					
					//Débito a Cobrar 
				}else if(pagamento.getDebitoACobrarGeral() != null){
					
					atualizarValorExcedente = "UPDATE Pagamento pgmt "
						+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
						+ "pgmt.valorExcedente = :valorExcedente, "
						+ "pgmt.ultimaAlteracao = :dataAlteracao, "
						+ "pgmt.debitoACobrarGeral.id = :idDebitoACobrar, "
						+ "pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
						+ "WHERE pgmt.id = :idPagamento ";

					session.createQuery(atualizarValorExcedente)
						.setBigDecimal("valorExcedente", pagamento.getValorExcedente())
						.setTimestamp("dataAlteracao", new Date())
						.setInteger("pagamentoSituacao", pagamentoSituacao)
						.setInteger("idPagamento", pagamento.getId())
						.setInteger("idDebitoACobrar", pagamento.getDebitoACobrarGeral().getId())
						.setShort("indicadorClassificacao", pagamento.getIndicadorClassificadoRecuperacaoCredito())
						.executeUpdate();
					
				}else{
					atualizarValorExcedente = "UPDATE Pagamento pgmt "
						+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
						+ "pgmt.valorExcedente = :valorExcedente, "
						+ "pgmt.ultimaAlteracao = :dataAlteracao, "
						+ "pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
						+ "WHERE pgmt.id = :idPagamento ";

					session.createQuery(atualizarValorExcedente)
						.setBigDecimal("valorExcedente", pagamento.getValorExcedente())
						.setTimestamp("dataAlteracao", new Date())
						.setInteger("pagamentoSituacao", pagamentoSituacao)
						.setInteger("idPagamento", pagamento.getId())
						.setShort("indicadorClassificacao", pagamento.getIndicadorClassificadoRecuperacaoCredito())
						.executeUpdate();
				}
				
				

				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisar os ids das localidades que possuem pagamentos
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 04/12/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsLocalidadeComPagamentosOuDevolucoes()
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select loca_id as localidade from arrecadacao.devolucao "
					+ "union "
					+ "select loca_id as localidade from arrecadacao.pagamento "
					+ "order by localidade";

			retorno = session.createSQLQuery(consulta).addScalar("localidade",
					Hibernate.INTEGER).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar os ano/mês de referência do pagamentos para um imóvel e ano/mês
	 * de arrecadação informados para o tipo de documento informado.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 06/12/2006
	 * 
	 * @param anoMesArrecadacaoAtual
	 * @param idImovel
	 * @param idDocumentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesReferenciaPagamentoParaImovel(
			Integer anoMesArrecadacaoAtual, Integer idImovel,
			Integer idDocumentoTipo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select distinct(anoMesReferenciaPagamento) from Pagamento pagamento "
					+ " where pagamento.anoMesReferenciaArrecadacao = :anoMesArrecadacaoAtual "
					+ "and pagamento.imovel.id = :idImovel and pagamento.documentoTipo.id = :idDocumentoTipo";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesArrecadacaoAtual", anoMesArrecadacaoAtual)
					.setInteger("idImovel", idImovel).setInteger(
							"idDocumentoTipo", idDocumentoTipo).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a esfera do poder do cliente responsável pelo imóvel.
	 * 
	 * [UC0301] - Gerar Dados Diários da Arrecadacao
	 * 
	 * @author Pedro Alexandre
	 * @date 05/12/2006
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarEsferaPoderClienteResponsavelPeloImovel(
			Integer idImovel) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select cltp.esferaPoder.id from ClienteTipo cltp where cltp.id in "
					+ "(select clie.clienteTipo.id from Cliente clie where clie.id in "
					+ "(select clim.cliente.id from ClienteImovel clim "
					+ "where clim.imovel.id = :idImovel and clim.dataFimRelacao is null and clim.clienteRelacaoTipo.id= :idRelacaoTipo ) ) ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idImovel", idImovel).setInteger("idRelacaoTipo",
					ClienteRelacaoTipo.RESPONSAVEL).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualiza a situção dos pagamentos informados.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 18/04/2006, 12/12/2006
	 * 
	 * @param pagamentoSituacao
	 * @param colecaoPagamentos
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoPagamento(Integer pagamentoSituacao, Collection<Pagamento> colecaoPagamentos) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Iterator<Pagamento> iteratorPagamentos = colecaoPagamentos.iterator();
		String atualizarSituacaoPagamento;
		
		try {

			atualizarSituacaoPagamento = "UPDATE Pagamento pgmt "
					+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
					+ "pgmt.pagamentoSituacaoAnterior.id = :pagamentoSituacaoAnterior, "
					+ "pgmt.ultimaAlteracao = :dataAlteracao "
					+ "WHERE pgmt.id = :idPagamento";

			int i = 1;
			while (iteratorPagamentos.hasNext()) {
				Pagamento pagamento = iteratorPagamentos.next();

				BigInteger pagamentoSituacaoAtual;
				if (pagamento.getPagamentoSituacaoAtual() != null 
						&& !pagamento.getPagamentoSituacaoAtual().getId().equals(pagamentoSituacao) ){
					pagamentoSituacaoAtual = BigInteger.valueOf(pagamento.getPagamentoSituacaoAtual().getId());
				}else{
					pagamentoSituacaoAtual = null;
				}
				
				session.createQuery(atualizarSituacaoPagamento)
							.setInteger("pagamentoSituacao", pagamentoSituacao)
							.setBigInteger("pagamentoSituacaoAnterior", pagamentoSituacaoAtual)
							.setTimestamp("dataAlteracao", new Date())
							.setInteger("idPagamento", pagamento.getId())
							.executeUpdate();
				
				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
			
				i++;
			}
			
			session.flush();
			session.clear();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa uma coleção de ids das categorias cadastradas
	 * 
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 15/12/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsCategorias()
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select cate.id from Categoria cate order by cate.id";

			retorno = session.createQuery(consulta).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa uma coleção de ids dos lançamentos de itens contábeis
	 * cadastrados
	 * 
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 15/12/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosLancamentosItemContabil()
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select lict.id,lict.sequenciaImpressao from LancamentoItemContabil lict order by lict.id";

			retorno = session.createQuery(consulta).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa alguns valores necessarios para obter a situação do aviso
	 * bancario, se aberto ou fechado
	 * 
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2006
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarAvisoBancarioAvisoAcertos(Integer idAvisoBancario)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = " select avbc.valorArrecadacaoCalculado,"
					+ " avbc.valorArrecadacaoInformado,"
					+ " (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto avac"
					+ " where avac.avisoBancario.id = :idAvisoBancario and"
					+ " avac.indicadorCreditoDebito = 1"
					+ " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao1,"
					+ " (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.id = :idAvisoBancario and"
					+ " avac.indicadorCreditoDebito = 2"
					+ " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao2,"
					+ " avbc.valorDevolucaoCalculado,"
					+ " avbc.valorDevolucaoInformado,"
					+ " (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.id = :idAvisoBancario and"
					+ " avac.indicadorCreditoDebito = 1"
					+ " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao1,"
					+ " (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.id = :idAvisoBancario and"
					+ " avac.indicadorCreditoDebito = 2"
					+ " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao2"
					+ " from AvisoBancario as avbc"
					+ " where avbc.id = :idAvisoBancario";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idAvisoBancario", idAvisoBancario).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarAvisoBancario(Integer idAvisoBancario)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select avbc, " + // 0
					"avbc.arrecadador.codigoAgente, " + // 1
					"avbc.arrecadador.cliente.nome, " + // 2
					"avbc.arrecadadorMovimento.id, " + // 3
					"avbc.contaBancaria.agencia.banco.id, " + // 4
					"avbc.contaBancaria.agencia.codigoAgencia, " + // 5
					"avbc.contaBancaria.numeroConta, " + // 6
					"arrecForma.descricao " + // 7
					"from AvisoBancario avbc " + 
					"left join avbc.arrecadacaoForma arrecForma "
					+ "where avbc.id = :idAvisoBancario";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idAvisoBancario", idAvisoBancario).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * somatorio do valor das deduções existentes para o aviso bancario
	 * 
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarSomatorioDeducoesAvisoBancario(
			Integer idAvisoBancario) throws ErroRepositorioException {
		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT sum(vd.valorDeducao) "
					+ "FROM AvisoDeducoes vd "
					+ "LEFT JOIN vd.avisoBancario aviso "
					+ "WHERE aviso.id = :idAvisoBancario ";

			BigDecimal big = (BigDecimal) session.createQuery(consulta)
					.setInteger("idAvisoBancario", idAvisoBancario)
					.setMaxResults(1).uniqueResult();
			if (big != null) {
				retorno = big;
			} else {
				retorno = new BigDecimal("0.00");
			}

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarValorAcertosAvisoBancario(Integer idAvisoBancario)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = " select "
					+ " (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto avac"
					+ " where avac.avisoBancario.id = :idAvisoBancario and"
					+ " avac.indicadorCreditoDebito = 1"
					+ " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao1,"
					+ // 0
					" (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.id = :idAvisoBancario and"
					+ " avac.indicadorCreditoDebito = 2"
					+ " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao2,"
					+ // 1
					" (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.id = :idAvisoBancario and"
					+ " avac.indicadorCreditoDebito = 1"
					+ " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao1,"
					+ // 2
					" (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.id = :idAvisoBancario and"
					+ " avac.indicadorCreditoDebito = 2"
					+ " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao2"
					+ // 3
					" from AvisoBancario as avbc"
					+ " where avbc.id = :idAvisoBancario";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idAvisoBancario", idAvisoBancario).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os avisos deduções de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException.subtract(valorSomatorioAcertosDevolucao
	 */
	public Collection pesquisarDeducoesAvisoBancario(Integer idAvisoBancario)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select dt.descricaoDeducaoTipo, ad.valorDeducao "
					+ "from AvisoDeducoes ad "
					+ "inner join ad.deducaoTipo dt "
					+ "inner join ad.avisoBancario ab "
					+ "where ab.id = :idAvisoBancario";

			retorno = session.createQuery(consulta).setInteger(
					"idAvisoBancario", idAvisoBancario.intValue()).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * pesquisa a lista dos acertos da Arrecadação/Devolucao do Aviso Bancario
	 * 
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAcertosAvisoBancario(Integer idAvisoBancario,
			Integer indicadorArrecadacaoDevolucao)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "SELECT "
					+ "avisoAcerto.contaBancaria.agencia.banco.id, "
					+ "avisoAcerto.contaBancaria.agencia.codigoAgencia, "
					+ "avisoAcerto.contaBancaria.numeroConta, "
					+ "avisoAcerto.indicadorCreditoDebito,  "
					+ "avisoAcerto.dataAcerto, "
					+ "avisoAcerto.valorAcerto "
					+ "FROM AvisoAcerto avisoAcerto "
					+ "WHERE avisoAcerto.avisoBancario.id = :idAvisoBancario "
					+ "AND avisoAcerto.indicadorArrecadacaoDevolucao = :indicadorArrecadacaoDevolucao";

			retorno = session.createQuery(consulta).setInteger(
					"idAvisoBancario", idAvisoBancario.intValue()).setInteger(
					"indicadorArrecadacaoDevolucao",
					indicadorArrecadacaoDevolucao.intValue()).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * O sistema seleciona a lista de pagamentos associados ao aviso bancário a
	 * partir da tabela PAGAMENTO com AVBC_ID=AVBC_ID da tabela AVISO_BANCARIO
	 * classificados por LOCA_ID ,IMOV_ID e PGMT_AMREFERENCIAPAGAMENTO
	 * 
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 15/12/2006
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoAvisoBancario(Integer idAvisoBancario)
			throws ErroRepositorioException {

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "select "
					+ "pagamento.documentoTipo.descricaoAbreviado, "
					+ // 0
					"pagamento.dataPagamento, "
					+ // 1
					"pagamento.localidade.id, "
					+ // 2
					"imovel.id, "
					+ // 3
					"cliente.id, "
					+ // 4
					"pagamento.anoMesReferenciaPagamento, "
					+ // 5
					"debitoTipo.id, "
					+ // 6
					"pagamento.valorPagamento, "
					+ // 7
					"pagamentoSituacaoAtual.descricaoAbreviada "
					+ // 8
					"from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ "left join pagamento.imovel as imovel "
					+ "left join pagamento.cliente as cliente "
					+ "left join pagamento.debitoTipo as debitoTipo "
					+ "left join pagamento.pagamentoSituacaoAtual as pagamentoSituacaoAtual "
					+ "where pagamento.avisoBancario.id = :idAvisoBancario "
					+ "order by pagamento.localidade.id,imovel.id,pagamento.anoMesReferenciaPagamento ";

			retorno = session.createQuery(hql).setInteger("idAvisoBancario",
					idAvisoBancario).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * O sistema seleciona a lista de desvoluções associados ao aviso bancário a
	 * partir da tabela DEVOLUCAO com AVBC_ID=AVBC_ID da tabela AVISO_BANCARIO
	 * 
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 15/12/2006
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucaoAvisoBancario(Integer idAvisoBancario)
			throws ErroRepositorioException {

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "select "
					+ "documentoTipo.descricaoAbreviado, "
					+ // 0
					"devolucao.dataDevolucao, "
					+ // 1
					"devolucao.localidade.id, "
					+ // 2
					"imovel.id, "
					+ // 3
					"cliente.id, "
					+ // 4
					"devolucao.anoMesReferenciaDevolucao, "
					+ // 5
					"debitoTipo.id, "
					+ // 6
					"devolucao.valorDevolucao, "
					+ // 7
					"devolucaoSituacaoAtual.descricaoAbreviado "
					+ // 8
					"from gcom.arrecadacao.Devolucao devolucao "
					+ "left join devolucao.imovel as imovel "
					+ "left join devolucao.cliente as cliente "
					+ "left join devolucao.debitoTipo as debitoTipo "
					+ "left join devolucao.devolucaoSituacaoAtual as devolucaoSituacaoAtual "
					+ "left join devolucao.guiaDevolucao as guiaDevolucao "
					+ "left join guiaDevolucao.documentoTipo as documentoTipo "
					+ "where devolucao.avisoBancario.id = :idAvisoBancario ";

			retorno = session.createQuery(hql).setInteger("idAvisoBancario",
					idAvisoBancario).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0239] - Filtrar Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 15/12/2006
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	private String selectFiltrarAvisoBancario() {

		String retorno = "";

		retorno = "select "
				+ "avisoBancario.arrecadador.id, "
				+ // 0
				"avisoBancario.dataLancamento, "
				+ // 1
				"avisoBancario.numeroSequencial, "
				+ // 2
				"avisoBancario.indicadorCreditoDebito, "
				+ // 3
				"avisoBancario.dataPrevista, "
				+ // 4
				"avisoBancario.dataRealizada, "
				+ // 5
				"avisoBancario.valorRealizado, "
				+ // 6
				"avisoBancario.valorArrecadacaoCalculado, "
				+ // 7
				"avisoBancario.valorArrecadacaoInformado, "
				+ // 8
				"(select sum(avac.valorAcerto) "
				+ "from AvisoAcerto as avac "
				+ "where "
				+ "avac.avisoBancario.id = avisoBancario.id and "
				+ "avac.indicadorCreditoDebito = 1 "
				+ "and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao1, "
				+ // 9
				"(select sum(avac.valorAcerto) "
				+ "from AvisoAcerto as avac "
				+ "where "
				+ "avac.avisoBancario.id = avisoBancario.id and "
				+ "avac.indicadorCreditoDebito = 2 "
				+ "and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao2, "
				+ // 10
				"avisoBancario.valorDevolucaoCalculado, "
				+ // 11
				"avisoBancario.valorDevolucaoInformado, "
				+ // 12
				"(select sum(avac.valorAcerto) "
				+ "from AvisoAcerto as avac "
				+ "where "
				+ "avac.avisoBancario.id = avisoBancario.id and "
				+ "avac.indicadorCreditoDebito = 1 "
				+ "and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao1, "
				+ // 13
				"(select sum(avac.valorAcerto) "
				+ "from AvisoAcerto as avac "
				+ "where "
				+ "avac.avisoBancario.id = avisoBancario.id and "
				+ "avac.indicadorCreditoDebito = 2 "
				+ "and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao2, "
				+ // 14
				"avisoBancario.id " + // 15
				"from AvisoBancario as avisoBancario ";

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1200
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os daods de ContaImpostosDeduzidos dos pagamentos classificados
	 * de contas para acumular o valor do imposto por localidade e categoria e
	 * tipo de imposto.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 15/12/2006, 20/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idTipoImposto
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpostosDeduzidosPagamentosClassificadosContaPorTipoImposto(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idTipoImposto) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
			"  sum(cnid.cnid_vlimposto) as col_0, " +
			"  cnta.imov_id as col_1 " + 
			" from " +
			"  faturamento.conta_impostos_deduzidos cnid  " +
			" inner join faturamento.conta cnta on cnid.cnta_id=cnta.cnta_id " + 
			" where " +
			"  cnid.imtp_id= :idImpostoTipo and ( " +
			"  cnid.cnta_id in (" +
							"select " +
							"distinct pgmt.cnta_id " + 
							"from " +
							"arrecadacao.pagamento pgmt " + 
							"where " +
							"pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
							"and pgmt.loca_id= :idLocalidade  " +
							"and ( pgmt.pgst_idatual= :idPagamentoClassificado or ( " +
							"pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior= :idPagamentoValorNaoConfere ) ) " + 
							"and (pgmt.cnta_id is not null) "+	
							")" +
			"  ) " +
			"group by cnta.imov_id";

		retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1", Hibernate.INTEGER)
					.setInteger("idImpostoTipo",idTipoImposto)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idPagamentoValorNaoConfere",PagamentoSituacao.VALOR_NAO_CONFERE)
					.list();

			

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o valor dos pagamentos não classificados por
	 * situação anterior.
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 18/12/2006, 21/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade,
			Integer idSituacaoAnterior) throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(pgmt.pgmt_vlexcedente) as col_0, " +
					  "pgmt.imov_id as col_1 " + 
					 "from " +
					  "arrecadacao.pagamento pgmt " + 
					 "where " +
					  "pgmt.loca_id= :idLocalidade  " +
					  "and pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " +
					  "and pgmt.pgst_idatual<> :idPagamentoClassificado " +
					  "and pgmt.pgst_idanterior= :idSituacaoAnterior " +
					  "group by pgmt.imov_id ";

			retorno = session.createSQLQuery(consulta)
				.addScalar("col_0",Hibernate.BIG_DECIMAL)
				.addScalar("col_1", Hibernate.INTEGER)
				.setInteger("idLocalidade",idLocalidade)
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
				.setInteger("idSituacaoAnterior",idSituacaoAnterior)
				.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o valor da devolução e o id do imóvel 
	 * pela situação atual da devolução
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 18/12/2006, 21/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idDevolucaoSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesNaoClassificadasMesPorSituacaoAtual(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade,
			Integer idDevolucaoSituacaoAtual) throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";
		
		try {

			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " + 
					 "from " + 
					  "arrecadacao.devolucao devl " +  
					 "where " +
					  "devl.devl_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
					  "and devl.dvst_idatual= :idDevolucaoSituacaoAtual " + 
					  "and devl.loca_id= :idLocalidade " +
					  " and devl.dotp_idagregador is null " +
					  "group by devl.imov_id";
	
			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1", Hibernate.INTEGER)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idDevolucaoSituacaoAtual",idDevolucaoSituacaoAtual)
					.setInteger("idLocalidade", idLocalidade)
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 18/12/2006, 22/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idImpostoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idImpostoTipo) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			
			consulta = "select " +
					 " sum(cnid.cnid_vlimposto) as col_0, " +
					 " cnta.imov_id as col_1 " + 
					 "from " +
					 " faturamento.conta_impostos_deduzidos cnid  " +
					 "inner join faturamento.conta cnta on cnid.cnta_id=cnta.cnta_id " + 
					 "where " +
					 " cnid.imtp_id= :idImpostoTipo  " +
					 " and (cnta.cnta_id in (" +
											 "select " +
											 "distinct pgmt.cnta_id " + 
											 "from " +
											 "arrecadacao.pagamento pgmt " + 
											 "where " +
											 "pgmt.pgmt_amreferenciaarrecadacao > 201212 and  pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
											 "and pgmt.loca_id= :idLocalidade  " +
											 "and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
											 "and (pgmt.cnta_id is not null) "		+	
					 ")) " +
					 " group by cnta.imov_id ";
			
			retorno = session.createSQLQuery(consulta)
			 		.addScalar("col_0", Hibernate.BIG_DECIMAL)
			 		.addScalar("col_1", Hibernate.INTEGER)
					.setInteger("idImpostoTipo",idImpostoTipo)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.list();

		
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 18/12/2006, 22/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idPagamentoSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idPagamentoSituacaoAnterior)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta  = "select " +
					  "sum(pgmt.pgmt_vlexcedente) as col_0, " +
					  "pgmt.imov_id as col_1 " +
					 "from " +
					  "arrecadacao.pagamento pgmt " +
					 "where " +
					  "pgmt.loca_id= :idLocalidade  " +
					  "and pgmt.pgmt_amreferenciaarrecadacao<= :anoMesReferenciaArrecadacao " + 
					  "and pgmt.pgst_idatual= :idPagamentoSituacaoAtual " +
					  "and pgmt.pgst_idanterior= :idPagamentoSituacaoAnterior " +
					  "group by pgmt.imov_id";

			retorno = session.createSQLQuery(consulta)
			        .addScalar("col_0",Hibernate.BIG_DECIMAL)
			        .addScalar("col_1",Hibernate.INTEGER)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idPagamentoSituacaoAnterior", idPagamentoSituacaoAnterior)
					.setInteger("idPagamentoSituacaoAtual",	PagamentoSituacao.VALOR_A_BAIXAR)
					.list();
			
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 18/12/2006, 22/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idPagamentoSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade,
			Integer idPagamentoSituacaoAtual) throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "pgmt.pgmt_vlexcedente as col_0, " +
					  "pgmt.imov_id as col_1, " +
					  "pgmt.pgmt_vlpagamento as col_2 " + 
					 "from " +
					  "arrecadacao.pagamento pgmt " + 
					 "where " +
					  "pgmt.loca_id= :idLocalidade " + 
					  "and pgmt.pgmt_amreferenciaarrecadacao<= :anoMesReferenciaArrecadacao " + 
					  "and pgmt.pgst_idatual= :idPagamentoSituacaoAtual ";
			
			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1",Hibernate.INTEGER)
					.addScalar("col_2",Hibernate.BIG_DECIMAL)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idPagamentoSituacaoAtual", idPagamentoSituacaoAtual)
					.list();


			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 18/12/2006, 22/05/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idDevolucaoSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesNaoClassificadasMesEAnterioresPorSituacaoAtual(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade,
			Integer idDevolucaoSituacaoAtual) throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {
			
			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " +
					 "from " +
					  "arrecadacao.devolucao devl " + 
					 "where " +
					  "devl.devl_amreferenciaarrecadacao<= :anoMesReferenciaArrecadacao " + 
					  "and devl.dvst_idatual= :idDevolucaoSituacaoAtual " + 
					  "and devl.loca_id= :idLocalidade " +
					  "group by devl.imov_id ";

			retorno = session.createSQLQuery(consulta)
			        .addScalar("col_0",Hibernate.BIG_DECIMAL)
			        .addScalar("col_1",Hibernate.INTEGER)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idDevolucaoSituacaoAtual",idDevolucaoSituacaoAtual)
					.setInteger("idLocalidade", idLocalidade)
					.list();

			
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o valor do pagamento classicado e o id do 
	 * imóvel relacionado ao pagamento.
	 * 
	 * [UC0276 Encerrar Arrecadação do Mês]
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 16/12/2006, 20/05/2008 
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade,
			Integer idSituacaoAtual) throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
						  "sum(pgmt.pgmt_vlpagamento) as col_0, " +
						  "pgmt.imov_id as col_1  " +
						 "from " +
						  "arrecadacao.pagamento pgmt " + 
						 "where " +
						  "pgmt.loca_id= :idLocalidade " + 
						  "and pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " +
						  "and pgmt.pgst_idatual<> :idPagamentoClassificado " +
						  "and pgmt.pgst_idatual= :idSituacaoAtual " +
						  "group by pgmt.imov_id";

			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1", Hibernate.INTEGER)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idSituacaoAtual",idSituacaoAtual)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.list();
			
			
/*			// Cria o hql de pesquisa
			consulta = "select pgmt.valorPagamento, imov.id " 
					+ "from Pagamento pgmt "
					+ "inner join pgmt.localidade loca "
					+ "left join pgmt.imovel imov "
					+ "where loca.id= :idLocalidade "
					+ "and pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
					+ "and pgmt.pagamentoSituacaoAtual.id <> :idPagamentoClassificado "
					+ "and pgmt.pagamentoSituacaoAtual.id = :idSituacaoAtual";

			// Executa o hql
			retorno = session.createQuery(consulta)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idSituacaoAtual",idSituacaoAtual)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.list();
*/
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoLocalidadeAmbosRelatorio(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = "SELECT pagto.id, loc.id, loc.descricao, "
					+ "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
					+ "cliArrec.nome, pagto.dataPagamento, "
					+ "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
					+ "conta.valorAgua, conta.valorEsgoto, conta.debitos, "
					+ "conta.valorCreditos, dbcb.valorDebito, dbcb.numeroPrestacaoDebito, "
					+ "dbcb.numeroPrestacaoCobradas, gpag.valorDebito, pagto.valorPagamento, "
					+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id, conta.valorImposto "
					+ "FROM Pagamento pagto "
					+ "INNER JOIN pagto.localidade loc "
					+ "INNER JOIN loc.gerenciaRegional gr "
					+ "INNER JOIN pagto.avisoBancario avbc "
					+ "INNER JOIN avbc.arrecadador arrec "
					+ "INNER JOIN arrec.cliente cliArrec "
					+ "INNER JOIN pagto.documentoTipo doctoTp "
					+ "LEFT JOIN pagto.imovel imov "
					+ "LEFT JOIN pagto.cliente cli "
					+ "LEFT JOIN pagto.debitoTipo dbtp "
					+ "LEFT JOIN pagto.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.conta conta "
					+ "LEFT JOIN pagto.guiaPagamento gpag "
					+ "LEFT JOIN pagto.debitoACobrarGeral dbcbGeral "
					+ "LEFT JOIN dbcbGeral.debitoACobrar dbcb "
					+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
					+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem "
					+ "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
					+ "LEFT JOIN pagto.arrecadacaoForma arrecForma "
					+ condicionais
					+ " UNION "
					+ "SELECT pagto.id, loc.id, loc.descricao, "
					+ "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
					+ "cliArrec.nome, pagto.dataPagamento, "
					+ "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
					+ "conta.valorAgua, conta.valorEsgoto, conta.debitos, "
					+ "conta.valorCreditos, dbcb.valorDebito, dbcb.numeroPrestacaoDebito, "
					+ "dbcb.numeroPrestacaoCobradas, gpag.valorDebito, pagto.valorPagamento, "
					+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id "
					+ "FROM PagamentoHistorico pagto "
					+ "INNER JOIN pagto.localidade loc "
					+ "INNER JOIN loc.gerenciaRegional gr "
					+ "INNER JOIN pagto.avisoBancario avbc "
					+ "INNER JOIN avbc.arrecadador arrec "
					+ "INNER JOIN arrec.cliente cliArrec "
					+ "INNER JOIN pagto.documentoTipo doctoTp "
					+ "LEFT JOIN pagto.imovel imov "
					+ "LEFT JOIN pagto.cliente cli "
					+ "LEFT JOIN pagto.debitoTipo dbtp "
					+ "LEFT JOIN pagto.contaGeral contaGeral "
					+ "LEFT JOIN contaGeral.contaHistorico conta "
					+ "LEFT JOIN pagto.guiaPagamento gpag "
					+ "LEFT JOIN pagto.debitoACobrarGeral dbcbGeral "
					+ "LEFT JOIN dbcbGeral.debitoACobrar dbcb "
					+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
					+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem "
					+ "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
					+ "LEFT JOIN pagto.arrecadacaoForma arrecForma "
					+ condicionais + " ORDER BY loc.id, imov.id, "
					+ " dbtp.id, pagto.dataPagamento ";
			// hql = " select distinct pagamento "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + condicionais
			// + " order by pagamento.localidade.id, pagamento.imovel.id, "
			// + " pagamento.debitoTipo.id, pagamento.dataPagamento "
			// + " ";

			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoImovelAmbosRelatorio(String idImovel)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "SELECT " +
			// 0
			"  pagto.pgmt_id as idPagamento, " +
			// 1		
			"  loc.loca_id as idLocalidade, " +
			// 2
			"  loc.loca_nmlocalidade as nomeLocalidade, " +
			// 3
			"  gr.greg_id as idGerencia, " +
			// 4
			"  gr.greg_nmregional as nomeGerencia, " +
			// 5
			"  imov.imov_id as idImovel, " +
			// 6
			"  cli.clie_id as idCliente, " +
			// 7
			"  cli.clie_nmcliente as nomeCliente, " +
			// 8
			"  cliArrec.clie_nmcliente as nomeClienteArrecadador, " +
			// 9
			"  pagto.pgmt_dtpagamento as dataPagamento, " +
			// 10
			"  pagto.pgmt_amreferenciapagamento as anoMesReferenciaPagamento, " +
			// 11			
			"  dbtp.dbtp_dsdebitotipo as descricaoDebitoTipo, " +
			// 12			
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vlagua " +
			"  else " +
			"    conta.cnta_vlagua " +
			"  end as valorAgua, " +
			// 13			
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vlesgoto " +
			"  else " +
			"    conta.cnta_vlesgoto " +
			"  end as valorEsgoto, " +
			// 14			
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vldebitos " +
			"  else " +
			"    conta.cnta_vldebitos " +
			"  end as debitosConta, " +
			// 15
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vlcreditos " +
			"  else " +
			"    conta.cnta_vlcreditos " +
			"  end as valorCreditos, " +
			// 16
			"  case when ( dbcb.dbac_id is null ) then " +
			"    dbcbHistorico.dahi_vldebito " +
			"  else " +
			"    dbcb.dbac_vldebito " +
			"  end as valorDebitoACobrar, " +
			// 17
			"  case when ( dbcb.dbac_id is null ) then " +
			"    dbcbHistorico.dahi_nnprestacaodebito " +
			"  else " +
			"    dbcb.dbac_nnprestacaodebito " +
			"  end as numeroPrestacaoDebito, " +
			// 18
			"  case when ( dbcb.dbac_id is null ) then " +
			"    dbcbHistorico.dahi_nnprestacaocobradas " +
			"  else " +
			"    dbcb.dbac_nnprestacaocobradas " +
			"  end as numeroPrestacaoCobradas, " +
			// 19
			"  case when ( gpag.gpag_id is null ) then " +
			"    gpagHistorico.gphi_vldebito " +
			"  else " +
			"    gpag.gpag_vldebito " +
			"  end as valorDebitoGuia, " +
			// 20
			"  pagto.pgmt_vlpagamento as valorPagamento, " +
			// 21
			"  pagtoSitAtual.pgst_id as idPagamentoSituacao, " +
			// 22			
			"  pagtoSitAtual.pgst_dsabreviado as descricaoPagamentoSituacao, " +
			// 23			
			"  doctoTp.dotp_id as idDocumentoTipo, " +
			// 24			
			"  doctoTp.dotp_dsdocumentotipo as descricaoDocumentoTipo, " +
			// 25			
			"  pagtoSitAnterior.pgst_dsabreviado as descricaopagamentosituacaoante, " +
			// 26
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vlimpostos " +
			"  else " +
			"    conta.cnta_vlimpostos " +
			"  end as valorImpostos " +
			"FROM " +
			"  arrecadacao.pagamento pagto " +
			"  INNER JOIN cadastro.localidade loc on pagto.loca_id = loc.loca_id " +
			"  INNER JOIN cadastro.gerencia_regional gr on loc.greg_id = gr.greg_id " +
			"  INNER JOIN cobranca.documento_tipo doctoTp on pagto.dotp_id = doctoTp.dotp_id " +
			"  INNER JOIN cadastro.imovel imov on pagto.imov_id = imov.imov_id " +
			"  LEFT OUTER JOIN arrecadacao.aviso_bancario avbc on pagto.avbc_id = avbc.avbc_id " +
			"  LEFT OUTER JOIN arrecadacao.arrecadador arrec on avbc.arrc_id = arrec.arrc_id " +
			"  LEFT OUTER JOIN cadastro.cliente cliArrec on arrec.clie_id = cliArrec.clie_id " +
			"  LEFT OUTER JOIN cadastro.cliente cli on pagto.clie_id = cli.clie_id " +
			"  LEFT OUTER JOIN faturamento.debito_tipo dbtp on pagto.dbtp_id = dbtp.dbtp_id " +
			"  LEFT OUTER JOIN faturamento.conta conta on pagto.cnta_id = conta.cnta_id " +
			"  LEFT OUTER JOIN faturamento.guia_pagamento gpag on pagto.gpag_id = gpag.gpag_id " +
			"  LEFT OUTER JOIN faturamento.guia_pagamento_historico gpagHistorico on pagto.gpag_id = gpagHistorico.gpag_id " +
			"  LEFT OUTER JOIN faturamento.debito_a_cobrar dbcb on pagto.dbac_id = dbcb.dbac_id " +
			"  LEFT OUTER JOIN faturamento.deb_a_cobrar_hist dbcbHistorico on pagto.dbac_id = dbcbHistorico.dbac_id " +
			"  LEFT OUTER JOIN arrecadacao.pagamento_situacao pagtoSitAtual on pagto.pgst_idatual = pagtoSitAtual.pgst_id " +
			"  LEFT OUTER JOIN arrecadacao.pagamento_situacao pagtoSitAnterior on pagto.pgst_idanterior = pagtoSitAnterior.pgst_id " +
			"  LEFT OUTER JOIN arrecadacao.arrecadador_mov_item arrecMovItem on pagto.amit_id = arrecMovItem.amit_id " +
			"  LEFT OUTER JOIN arrecadacao.arrecadador_movimento arrecMov on arrecMovItem.armv_id = arrecMov.armv_id " +
			"  LEFT OUTER JOIN arrecadacao.arrecadacao_forma arrecForma on pagto.arfm_id = arrecForma.arfm_id " +
			"  LEFT OUTER JOIN faturamento.conta_historico contaHistorico on pagto.cnta_id = contaHistorico.cnta_id " +
			"WHERE " +
			"  pagto.imov_id = " + idImovel +
			" UNION " +
			"SELECT " +
			"  pagto.pghi_id as idPagamento, " +
			"  loc.loca_id as idLocalidade, " +
			"  loc.loca_nmlocalidade as nomeLocalidade, " +
			"  gr.greg_id as idGerencia, " +
			"  gr.greg_nmregional as nomeGerencia, " +
			"  imov.imov_id as idImovel, " +
			"  cli.clie_id as idCliente, " +
			"  cli.clie_nmcliente as nomeCliente, " +
			"  cliArrec.clie_nmcliente as nomeClienteArrecadador, " +
			"  pagto.pghi_dtpagamento as dataPagamento, " +
			"  pagto.pghi_amreferenciapagamento as anoMesReferenciaPagamento, " +
			"  dbtp.dbtp_dsdebitotipo as descricaoDebitoTipo, " +
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vlagua " +
			"  else " +
			"    conta.cnta_vlagua " +
			"  end as valorAgua, " +
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vlesgoto " +
			"  else " +
			"    conta.cnta_vlesgoto " +
			"  end as valorEsgoto, " +
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vldebitos " +
			"  else " +
			"    conta.cnta_vldebitos " +
			"  end as debitosConta, " +
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vlcreditos " +
			"  else " +
			"    conta.cnta_vlcreditos " +
			"  end as valorCreditos, " +
			"  case when ( dbcb.dbac_id is null ) then " +
			"    dbcbHistorico.dahi_vldebito " +
			"  else " +
			"    dbcb.dbac_vldebito " +
			"  end as valorDebitoACobrar, " +
			"  case when ( dbcb.dbac_id is null ) then " +
			"    dbcbHistorico.dahi_nnprestacaodebito " +
			"  else " +
			"    dbcb.dbac_nnprestacaodebito " +
			"  end as numeroPrestacaoDebito, " +
			"  case when ( dbcb.dbac_id is null ) then " +
			"    dbcbHistorico.dahi_nnprestacaocobradas " +
			"  else " +
			"    dbcb.dbac_nnprestacaocobradas " +
			"  end as numeroPrestacaoCobradas, " +
			"  case when ( gpag.gpag_id is null ) then " +
			"    gpagHistorico.gphi_vldebito " +
			"  else " +
			"    gpag.gpag_vldebito " +
			"  end as valorDebitoGuia, " +
			"  pagto.pghi_vlpagamento as valorPagamento, " +
			"  pagtoSitAtual.pgst_id as idPagamentoSituacao, " +
			"  pagtoSitAtual.pgst_dsabreviado as descricaoPagamentoSituacao, " +
			"  doctoTp.dotp_id as idDocumentoTipo, " +
			"  doctoTp.dotp_dsdocumentotipo as descricaoDocumentoTipo, " +
			"  pagtoSitAnterior.pgst_dsabreviado as descricaopagamentosituacaoante, " +
			"  case when ( conta.cnta_id is null ) then " +
			"    contaHistorico.cnhi_vlimpostos " +
			"  else " +
			"    conta.cnta_vlimpostos " +
			"  end as valorImpostos " +
			"FROM " +
			"  arrecadacao.pagamento_historico pagto " +
			"  INNER JOIN cadastro.localidade loc on pagto.loca_id = loc.loca_id " +
			"  INNER JOIN cadastro.gerencia_regional gr on loc.greg_id = gr.greg_id " +
			"  INNER JOIN cobranca.documento_tipo doctoTp on pagto.dotp_id = doctoTp.dotp_id " +
			"  INNER JOIN cadastro.imovel imov on pagto.imov_id = imov.imov_id " +
			"  LEFT OUTER JOIN arrecadacao.aviso_bancario avbc on pagto.avbc_id = avbc.avbc_id " +
			"  LEFT OUTER JOIN arrecadacao.arrecadador arrec on avbc.arrc_id = arrec.arrc_id " +
			"  LEFT OUTER JOIN cadastro.cliente cliArrec on arrec.clie_id = cliArrec.clie_id " +
			"  LEFT OUTER JOIN cadastro.cliente cli on pagto.clie_id = cli.clie_id " +
			"  LEFT OUTER JOIN faturamento.debito_tipo dbtp on pagto.dbtp_id = dbtp.dbtp_id " +
			"  LEFT OUTER JOIN faturamento.conta conta on pagto.cnta_id = conta.cnta_id " +
			"  LEFT OUTER JOIN faturamento.guia_pagamento gpag on pagto.gpag_id = gpag.gpag_id " +
			"  LEFT OUTER JOIN faturamento.guia_pagamento_historico gpagHistorico on pagto.gpag_id = gpagHistorico.gpag_id " +
			"  LEFT OUTER JOIN faturamento.debito_a_cobrar dbcb on pagto.dbac_id = dbcb.dbac_id " +
			"  LEFT OUTER JOIN faturamento.deb_a_cobrar_hist dbcbHistorico on pagto.dbac_id = dbcbHistorico.dbac_id " +
			"  LEFT OUTER JOIN arrecadacao.pagamento_situacao pagtoSitAtual on pagto.pgst_idatual = pagtoSitAtual.pgst_id " +
			"  LEFT OUTER JOIN arrecadacao.pagamento_situacao pagtoSitAnterior on pagto.pgst_idanterior = pagtoSitAnterior.pgst_id " +
			"  LEFT OUTER JOIN arrecadacao.arrecadador_mov_item arrecMovItem on pagto.amit_id = arrecMovItem.amit_id " +
			"  LEFT OUTER JOIN arrecadacao.arrecadador_movimento arrecMov on arrecMovItem.armv_id = arrecMov.armv_id " +
			"  LEFT OUTER JOIN arrecadacao.arrecadacao_forma arrecForma on pagto.arfm_id = arrecForma.arfm_id " +
			"  LEFT OUTER JOIN faturamento.conta_historico contaHistorico on pagto.cnta_id = contaHistorico.cnta_id " +
			"WHERE " +
			"  pagto.imov_id = " + idImovel +
			" ORDER BY " +
			"  idDocumentoTipo, " +
			"  anoMesReferenciaPagamento, " +
			"  dataPagamento ";

			retorno = session.createSQLQuery(hql).addScalar("idPagamento",
					Hibernate.INTEGER).addScalar("idLocalidade",
					Hibernate.INTEGER).addScalar("nomeLocalidade",
					Hibernate.STRING)
					.addScalar("idGerencia", Hibernate.INTEGER).addScalar(
							"nomeGerencia", Hibernate.STRING).addScalar(
							"idImovel", Hibernate.INTEGER).addScalar(
							"idCliente", Hibernate.INTEGER).addScalar(
							"nomeCliente", Hibernate.STRING).addScalar(
							"nomeClienteArrecadador", Hibernate.STRING)
					.addScalar("dataPagamento", Hibernate.DATE).addScalar(
							"anoMesReferenciaPagamento", Hibernate.INTEGER)
					.addScalar("descricaoDebitoTipo", Hibernate.STRING)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar(
							"valorEsgoto", Hibernate.BIG_DECIMAL).addScalar(
							"debitosConta", Hibernate.BIG_DECIMAL).addScalar(
							"valorCreditos", Hibernate.BIG_DECIMAL).addScalar(
							"valorDebitoACobrar", Hibernate.BIG_DECIMAL)
					.addScalar("numeroPrestacaoDebito", Hibernate.SHORT)
					.addScalar("numeroPrestacaoCobradas", Hibernate.SHORT)
					.addScalar("valorDebitoGuia", Hibernate.BIG_DECIMAL)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("idPagamentoSituacao", Hibernate.INTEGER)
					.addScalar("descricaoPagamentoSituacao", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar(
							"descricaoDocumentoTipo", Hibernate.STRING)
					.addScalar("descricaopagamentosituacaoante",
							Hibernate.STRING)
					.addScalar("valorImpostos",Hibernate.BIG_DECIMAL).list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o imóvel pelo id fazendo os carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return Imovel
	 * @throws ErroRepositorioException
	 */
	public Imovel pesquisarImovelPagamento(Integer idImovel)
			throws ErroRepositorioException {

		Imovel imovel = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "SELECT imov "
					+ " FROM Imovel imov "
					+ " INNER JOIN FETCH imov.localidade loc "
					+ " INNER JOIN FETCH imov.setorComercial sc "
					+ " INNER JOIN FETCH sc.municipio municipioSc "
					+ " INNER JOIN FETCH municipioSc.unidadeFederacao unidFedSc "
					+ " INNER JOIN FETCH imov.quadra quadra "
					+ " INNER JOIN FETCH imov.ligacaoAguaSituacao ligAguaSit "
					+ " INNER JOIN FETCH imov.ligacaoEsgotoSituacao ligEsgSit "
					+ " LEFT JOIN FETCH imov.logradouroBairro logrBairro "
					+ " LEFT JOIN FETCH logrBairro.bairro bairro "
					+ " LEFT JOIN FETCH bairro.municipio municipioBairro "
					+ " LEFT JOIN FETCH municipioBairro.unidadeFederacao unidFedBairro "
					+ " LEFT JOIN FETCH imov.logradouroCep logrCep "
					+ " LEFT JOIN FETCH logrCep.logradouro logr "
					+ " LEFT JOIN FETCH logrCep.cep cep "
					+ " LEFT JOIN FETCH logr.logradouroTipo logrTp "
					+ " LEFT JOIN FETCH logr.logradouroTitulo logrTit "
					+ " LEFT JOIN FETCH imov.enderecoReferencia endRef "
					+ " LEFT JOIN FETCH imov.perimetroInicial.logradouroTipo logrTipoPerInicial "
					+ " LEFT JOIN FETCH imov.perimetroInicial.logradouroTitulo logrTituloPerInicial "
					+ " LEFT JOIN FETCH imov.perimetroFinal.logradouroTipo logrTipoPerFinal "
					+ " LEFT JOIN FETCH imov.perimetroFinal.logradouroTitulo logrTituloPerFinal "
					+ " WHERE imov.id = :idImovel ";

			imovel = (Imovel) session.createQuery(hql).setInteger("idImovel",
					idImovel).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return imovel;

	}

	/**
	 * Pesquisa o cliente pelo id fazendo os carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return Cliente
	 * @throws ErroRepositorioException
	 */
	public Cliente pesquisarClientePagamento(Integer idCliente)
			throws ErroRepositorioException {

		Cliente cliente = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "SELECT cli " + " FROM Cliente cli "
					+ " INNER JOIN FETCH cli.clienteTipo cliTp "
					+ " LEFT JOIN FETCH cli.ramoAtividade ramo "
					+ " LEFT JOIN FETCH cli.profissao profissao "
					+ " WHERE cli.id = :idCliente ";

			cliente = (Cliente) session.createQuery(hql).setInteger(
					"idCliente", idCliente).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return cliente;

	}

	/**
	 * Pesquisa o endereço de correspondência do cliente pelo seu id fazendo os
	 * carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return ClienteEndereco
	 * @throws ErroRepositorioException
	 */
	public ClienteEndereco pesquisarClienteEnderecoPagamento(Integer idCliente)
			throws ErroRepositorioException {

		ClienteEndereco clienteEndereco = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "SELECT cliEnd "
					+ " FROM ClienteEndereco cliEnd "
					+ " INNER JOIN FETCH cliEnd.cliente cli "
					+ " LEFT JOIN FETCH cliEnd.logradouroCep logrCep "
					+ " LEFT JOIN FETCH cliEnd.enderecoReferencia endRef "
					+ " LEFT JOIN FETCH cliEnd.logradouroBairro logrBairro "
					+ " LEFT JOIN FETCH logrCep.cep cep "
					+ " LEFT JOIN FETCH logrCep.logradouro logr "
					+ " LEFT JOIN FETCH logr.municipio municipioLogr "
					+ " LEFT JOIN FETCH municipioLogr.unidadeFederacao unidFedLogr "
					+ " LEFT JOIN FETCH logr.logradouroTipo logrTp "
					+ " LEFT JOIN FETCH logr.logradouroTitulo logrTit "
					+ " LEFT JOIN FETCH logrBairro.bairro bairro "
					+ " LEFT JOIN FETCH bairro.municipio municipioBairro "
					+ " LEFT JOIN FETCH municipioBairro.unidadeFederacao unidFedBairro "
					+ " LEFT JOIN FETCH cliEnd.perimetroInicial.logradouroTipo logrTipoPerInicial "
					+ " LEFT JOIN FETCH cliEnd.perimetroInicial.logradouroTitulo logrTituloPerInicial "
					+ " LEFT JOIN FETCH cliEnd.perimetroFinal.logradouroTipo logrTipoPerFinal "
					+ " LEFT JOIN FETCH cliEnd.perimetroFinal.logradouroTitulo logrTituloPerFinal "
					+ " WHERE cli.id = :idCliente "
					+ " AND cliEnd.indicadorEnderecoCorrespondencia = "
					+ ClienteEndereco.INDICADOR_ENDERECO_CORRESPONDENCIA
							.toString();

			clienteEndereco = (ClienteEndereco) session.createQuery(hql)
					.setInteger("idCliente", idCliente).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return clienteEndereco;

	}

	/**
	 * Pesquisa o telefone padrão do cliente pelo seu id fazendo os
	 * carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return ClienteFone
	 * @throws ErroRepositorioException
	 */
	public IClienteFone pesquisarClienteFonePagamento(Integer idCliente)
			throws ErroRepositorioException {

		IClienteFone clienteFone = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "SELECT cliFone " + " FROM ClienteFone cliFone "
					+ " INNER JOIN FETCH cliFone.foneTipo foneTp "
					+ " INNER JOIN cliFone.cliente cli "
					+ " WHERE cli.id = :idCliente "
					+ " AND cliFone.indicadorTelefonePadrao = "
					+ ClienteFone.INDICADOR_FONE_PADRAO.toString();

			clienteFone = (IClienteFone) session.createQuery(hql).setInteger(
					"idCliente", idCliente).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return clienteFone;

	}

	/**
	 * Pesquisa os clientes do imóvel pelo seu id do imóvel fazendo os
	 * carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return Collection<ClienteImovel>
	 * @throws ErroRepositorioException
	 */
	public Collection<ClienteImovel> pesquisarClientesImoveisPagamento(
			Integer idImovel) throws ErroRepositorioException {

		Collection<ClienteImovel> retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "SELECT cliImovel " + " FROM ClienteImovel cliImovel "
					+ " INNER JOIN FETCH cliImovel.cliente cli "
					+ " INNER JOIN FETCH cliImovel.clienteRelacaoTipo crtp "
					+ " INNER JOIN cliImovel.imovel imov "
					+ " WHERE imov.id = :idImovel ";

			retorno = session.createQuery(hql).setInteger("idImovel", idImovel)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarMovimentoArrecadadorParaRelatorio(
			String codigoBanco, String codigoRemessa,
			String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado)
			throws ErroRepositorioException {

		Collection retorno = null;
		String sql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisMovimentoArrecadador(
					codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
					numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
					ultimaAlteracaoInicio, ultimaAlteracaoFim,
					descricaoOcorrencia, indicadorAceitacao,
					indicadorAbertoFechado);

			sql = " SELECT arrecadadorMovimento.armv_cdbanco as codBanco,"
					+ " arrecadadorMovimento.armv_cdremessa as codRemessa,"
					+ " arrecadadorMovimento.armv_dsidentificacaoservico as descIdentServico,"
					+ " arrecadadorMovimento.armv_nnnsa as numeroSeqArquivo,"
					+ " arrecadadorMovimento.armv_id as id,"
					+ " arrecadadorMovimento.armv_dtgeracao as dataGeracao,"
					+ " arrecadadorMovimento.armv_nnregistrosmovimento as numRegistroMovimento,"
					+ " arrecadadorMovimento.armv_vltotalmovimento as vlTotalMovimento,"
					+ " arrecadadorMovimento.armv_tmultimaalteracao as ultimaAlteracao,"
					+ " arrecadadorMovimento.armv_nmbanco as nomeBanco "
					+ " FROM arrecadacao.arrecadador_movimento arrecadadorMovimento "
					+ condicionais;

			Date dataInicio = null;
			Date dataFim = null;
			if (ultimaAlteracaoInicio != null
					&& !ultimaAlteracaoInicio.equals("")) {

				dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);
				if (condicionais.trim().equals("WHERE")) {
					sql = sql
							+ "arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				} else {
					sql = sql
							+ " and arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				}

			}

			if (ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")) {

				dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);
				sql = sql
						+ " and arrecadadorMovimento.armv_tmultimaalteracao <= :dataFim";

			}
			if (dataInicio != null && dataFim != null) {

				retorno = session.createSQLQuery(sql).addScalar("codBanco",
						Hibernate.SHORT).addScalar("codRemessa",
						Hibernate.SHORT).addScalar("descIdentServico",
						Hibernate.STRING).addScalar("numeroSeqArquivo",
						Hibernate.INTEGER).addScalar("id", Hibernate.INTEGER)
						.addScalar("dataGeracao", Hibernate.DATE).addScalar(
								"numRegistroMovimento", Hibernate.INTEGER)
						.addScalar("vlTotalMovimento", Hibernate.BIG_DECIMAL)
						.addScalar("ultimaAlteracao", Hibernate.TIMESTAMP)
						.addScalar("nomeBanco", Hibernate.STRING).setTimestamp(
								"dataInicio", dataInicio).setTimestamp(
								"dataFim", dataFim).list();
			} else {
				retorno = session.createSQLQuery(sql).addScalar("codBanco",
						Hibernate.SHORT).addScalar("codRemessa",
						Hibernate.SHORT).addScalar("descIdentServico",
						Hibernate.STRING).addScalar("numeroSeqArquivo",
						Hibernate.INTEGER).addScalar("id", Hibernate.INTEGER)
						.addScalar("dataGeracao", Hibernate.DATE).addScalar(
								"numRegistroMovimento", Hibernate.INTEGER)
						.addScalar("vlTotalMovimento", Hibernate.BIG_DECIMAL)
						.addScalar("ultimaAlteracao", Hibernate.TIMESTAMP)
						.addScalar("nomeBanco", Hibernate.STRING).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 04/01/07
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * 
	 * @throws ControladorException
	 */
	public Integer filtrarMovimentoArrecadadoresRelatorioCount(
			String codigoBanco, String codigoRemessa,
			String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado)
			throws ErroRepositorioException {

		Integer movimentoArrecadadorCount = null;
		String sql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisMovimentoArrecadador(
					codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
					numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
					ultimaAlteracaoInicio, ultimaAlteracaoFim,
					descricaoOcorrencia, indicadorAceitacao,
					indicadorAbertoFechado);

			sql = " SELECT count (arrecadadorMovimento.armv_id) as qtdeMovimentoArrecadador "
					+ " FROM arrecadacao.arrecadador_movimento arrecadadorMovimento inner join "
					+ " arrecadacao.arrecadador_mov_item movimentoItem "
					+ " on arrecadadorMovimento.armv_id = movimentoItem.armv_id "
					+ condicionais;

			Date dataInicio = null;
			Date dataFim = null;
			if (ultimaAlteracaoInicio != null
					&& !ultimaAlteracaoInicio.equals("")) {

				dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);
				if (condicionais.trim().equals("WHERE")) {
					sql = sql
							+ "arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				} else {
					sql = sql
							+ " and arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				}

			}

			if (ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")) {

				dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);
				sql = sql
						+ " and arrecadadorMovimento.armv_tmultimaalteracao <= :dataFim";

			}
			if (dataInicio != null && dataFim != null) {
				movimentoArrecadadorCount = (Integer) session.createSQLQuery(
						sql).addScalar("qtdeMovimentoArrecadador",
						Hibernate.INTEGER).setTimestamp("dataInicio",
						dataInicio).setTimestamp("dataFim", dataFim)
						.setMaxResults(1).uniqueResult();
			} else {

				movimentoArrecadadorCount = (Integer) session.createSQLQuery(
						sql).addScalar("qtdeMovimentoArrecadador",
						Hibernate.INTEGER).setMaxResults(1).uniqueResult();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return movimentoArrecadadorCount;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa a coleção de guias de pagamento categoria para o id da guia
	 * informada.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param idGuiaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoCategoria(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select guiaPagamentoCategoria "
					+ "from GuiaPagamentoCategoria guiaPagamentoCategoria "
					+ "inner join guiaPagamentoCategoria.guiaPagamento guiaPagamento "
					+ "where guiaPagamento.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa a coleção de cliente de guias de pagamento para o id da guia
	 * informada.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param idGuiaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteGuiaPagamento(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select clienteGuiaPagamento "
					+ "from ClienteGuiaPagamento clienteGuiaPagamento "
					+ "inner join clienteGuiaPagamento.guiaPagamento guiaPagamento "
					+ "where guiaPagamento.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Para cada guia de pagamento transferida para o histórico atualiza o
	 * indicador de que a guia de pagamento está no histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param idsGuiasPagamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorGuiaPagamentoNoHistorico(
			Collection idsGuiasPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarGuiaPagamentoGeral;

		try {
			atualizarGuiaPagamentoGeral = "update GuiaPagamentoGeral gpge "
					+ "set gpge.indicadorHistorico = :indicadorHistorico, gpge.ultimaAlteracao = :dataUltimaAlteracao where gpge.id in (:idsGuiasPagamento)";

			session.createQuery(atualizarGuiaPagamentoGeral).setInteger(
					"indicadorHistorico", ConstantesSistema.SIM).setDate(
					"dataUltimaAlteracao", new Date()).setParameterList(
					"idsGuiasPagamento", idsGuiasPagamento).executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Atualiza o ano/mês de referência da arrecadação.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param anoMesArrecadacaoAtual
	 * @param anoMesArrecadacaoNovo
	 * @throws ErroRepositorioException
	 */
	public void atualizarAnoMesArrecadacao(int anoMesArrecadacaoAtual,
			int anoMesArrecadacaoNovo) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarAnoMesArrecadacao;

		try {
			atualizarAnoMesArrecadacao = "update SistemaParametro "
					+ "set parm_amreferenciaarrecadacao = "
					+ anoMesArrecadacaoNovo
					+ " "
					+ "where parm_amreferenciaarrecadacao = :anoMesArrecadacaoAtual";

			session.createQuery(atualizarAnoMesArrecadacao).setInteger(
					"anoMesArrecadacaoAtual", anoMesArrecadacaoAtual)
					.executeUpdate();
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as contas correspondentes aos pagamentos classificados de conta
	 * e os pagamentos anteriores de conta classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param numeroIndice
	 * @param quantidadeRegistros
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarContasDePagamentosClassificadosContaEPagamentosAnterioresContaClassificadosNoMes(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
			Integer numeroIndice, Integer quantidadeRegistros,
			Integer idSetorComercial) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select cnta.id from Conta cnta "
					+ "inner join cnta.quadraConta qdra "
					+ "inner join qdra.setorComercial stcm "
					+ "where cnta.id in "
					+ "(select distinct pgmt.contaGeral.id from Pagamento pgmt where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
					+ " and pgmt.contaGeral.id is not null and pgmt.localidade.id = :idLocalidade) "
					+ " and stcm.id = :idSetorComercial ";

			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("idSetorComercial",
					idSetorComercial).setInteger("anoMesReferenciaArrecadacao",
					anoMesReferenciaArrecadacao).setInteger(
					"idPagamentoClassificado",
					PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",
							PagamentoSituacao.VALOR_A_BAIXAR).setMaxResults(
							quantidadeRegistros).setFirstResult(numeroIndice)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

//	public Collection<GuiaPagamento> pesquisarGuiasPagamentoDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
//			Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
//			Integer numeroIndice, Integer quantidadeRegistros)
//			throws ErroRepositorioException {
//
//		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
//		Collection<GuiaPagamento> retorno = null;
//
//		// Cria uma instância da sessão
//		Session session = HibernateUtil.getSession();
//
//		// Cria a variável que vai conter o hql
//		String consulta = "";
//		
//		/**
//		 * Alguns pagamentos foram para histórico indevidamente
//		 * Alterado clausula where de <= para < no anoMesReferenciaArrecadacao
//		 * 
//		 * @author Wellington Rocha
//		 * @date 18/09/2012*/
//
//		try {
//
//			// Cria o hql de pesquisa
//			consulta = "select pgmt.guiaPagamento from Pagamento pgmt "
//					+ "inner join pgmt.localidade loca "
//					+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
//					+ "and (pgmt.pagamentoSituacaoAtual.id = "
//					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
//					+ "pgmt.pagamentoSituacaoAtual.id = "
//					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
//					+ "and pgmt.guiaPagamento.id is not null "
//					+ "and loca.id = :idLocalidade "
//					+ "order by pgmt.guiaPagamento.id";
//			// Executa o hql
//			retorno = session.createQuery(consulta).setInteger("idLocalidade",
//					idLocalidade).setInteger("anoMesReferenciaArrecadacao",
//					anoMesReferenciaArrecadacao).setMaxResults(
//					quantidadeRegistros).setFirstResult(numeroIndice).list();
//
//			// Erro no hibernate
//		} catch (HibernateException e) {
//			// Levanta a exceção para a próxima camada
//			throw new ErroRepositorioException(e, "Erro no Hibernate");
//		} finally {
//			// Fecha a sessão com o hibernate
//			HibernateUtil.closeSession(session);
//		}
//
//		return retorno;
//	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as guias de pagamento correspondentes aos pagamentos
	 * classificados de guia de pagamento e aos pagamentos anteriores de guia de
	 * pagamento classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaPagamento> pesquisarGuiasPagamentoDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<GuiaPagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select gpag from GuiaPagamento gpag "
					+ "inner join gpag.localidade loca "
					+ "where gpag.id in "
					+ "(select distinct pgmt.guiaPagamento.id from Pagamento pgmt where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ " and pgmt.pagamentoSituacaoAtual.id in (" + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + ", " + PagamentoSituacao.VALOR_A_BAIXAR + ", " + PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO + ") "
					+ " and pgmt.guiaPagamento.id is not null and pgmt.localidade.id = :idLocalidade) "
					+ " and loca.id = :idLocalidade ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesReferenciaArrecadacao",
					anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisar os pagamentos classificados ou com valor excedente baixado e
	 * com valor excedente maior do que zero para transferir para o histórico.
	 */
	public Collection<Integer> pesquisarPagamentosClassificadosOuValorExcedenteBaixado(Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
			int numeroIndice, int quantidadeRegistros) throws ErroRepositorioException {

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();
		
		try {

			consulta.append("select pgmt.id from Pagamento pgmt ")
					.append("inner join pgmt.localidade loca ")
					.append("where ((loca.id= :idLocalidade) and ")
					.append("(pgmt.pagamentoSituacaoAtual.id = :situacaoClassificado) ")
					.append("and (pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao))")
					.append(" or ((pgmt.pagamentoSituacaoAtual.id = :situacaoValorABaixar) ")
					.append("and (pgmt.valorExcedente > 0) and (pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao)) ")
					.append(" or ( (pgmt.pagamentoSituacaoAtual.id = :situacaoDuplicidadeExcessoDevolvido) ")
					.append(" and (pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao) ) ")
					.append(" or (pgmt.pagamentoSituacaoAtual.id in (:classificadoRecuperacaoCreditoDuplicidade , :classificadoRecuperacaoCreditoCancelado)) ")
					.append(" order by pgmt.id");

			retorno = session.createQuery(consulta.toString())
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("situacaoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
				.setInteger("classificadoRecuperacaoCreditoDuplicidade", PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_DUPLICIDADE)
				.setInteger("classificadoRecuperacaoCreditoCancelado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_CANCELADO)
				.setInteger("situacaoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
				.setInteger("situacaoDuplicidadeExcessoDevolvido", PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO)
				.setFirstResult(numeroIndice).setMaxResults(quantidadeRegistros).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisar os pagamentos classificados ou com valor excedente baixado e
	 * com valor excedente maior do que zero para transferir para o histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosClassificadosOuValorExcedenteBaixado(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select pgmt from Pagamento pgmt "
					+ "inner join pgmt.localidade loca "
					+ "where loca.id= :idLocalidade and "
					+ "pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ "and pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO
					+ " or (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR
					+ " and pgmt.valorExcedente > 0) ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesReferenciaArrecadacao",
					anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções classificadas para transferir para o histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param numeroIndice
	 * @param quantidadeRegistros
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesClassificadasPorLocalidade(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
			Integer numeroIndice, Integer quantidadeRegistros)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select devl from Devolucao devl "
					+ "inner join devl.localidade loca "
					+ "where loca.id= :idLocalidade and "
					+ "devl.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ "and devl.devolucaoSituacaoAtual.id = "
					+ DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA
					+ " order by devl.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesReferenciaArrecadacao",
					anoMesReferenciaArrecadacao).setMaxResults(
					quantidadeRegistros).setFirstResult(numeroIndice).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * O sistema seleciona a lista de pagamentos associados ao aviso bancário a
	 * partir da tabela PAGAMENTO com AVBC_ID=AVBC_ID da tabela AVISO_BANCARIO
	 * 
	 * @author Vivianne Sousa
	 * @date 17/01/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoPorAvisoBancario(Integer idAvisoBancario)
			throws ErroRepositorioException {

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "select pagamento "
					+ "from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ "left join fetch pagamento.imovel imovel "
					+ "left join fetch imovel.localidade localidade "
					+ "left join fetch pagamento.contaGeral contaGeral "
					+ "left join fetch contaGeral.conta conta "
					+ "left join fetch contaGeral.contaHistorico contaHistorico "
					+ "left join fetch pagamento.guiaPagamento guiaPagamento "
					+ "left join fetch guiaPagamento.localidade localidadeG "
					+ "left join fetch pagamento.cobrancaDocumento cobrancaDocumento "
					+ "left join fetch cobrancaDocumento.localidade localidadeC "
					+ "where pagamento.avisoBancario.id = :idAvisoBancario ";

			retorno = session.createQuery(hql).setInteger("idAvisoBancario",
					idAvisoBancario).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Ana Maria
	 * @date 29/01/2007
	 * 
	 * @param idGuiaPagamento
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarGuiaPagamento(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT guiaPagamento "
					+ "FROM GuiaPagamento guiaPagamento "
					+ "WHERE guiaPagamento.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Atualiza logradouroBairro de um ou mais imóveis
	 * 
	 * [UC0] Atualizar Logradouro
	 * 
	 * @author Raphael Rossiter
	 * @date 22/02/2007
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarLogradouroBairro(
			LogradouroBairro logradouroBairroAntigo,
			LogradouroBairro logradouroBairroNovo)
			throws ErroRepositorioException {

		String consulta = "";

		Session session = HibernateUtil.getSession();

		try {

			consulta = "UPDATE gcom.arrecadacao.banco.Agencia SET "
					+ "lgbr_id = :idLogradouroBairroNovo, agen_tmultimaalteracao = :ultimaAlteracao "
					+ "WHERE lgbr_id = :idLogradouroBairroAntigo ";

			session.createQuery(consulta).setInteger("idLogradouroBairroNovo",
					logradouroBairroNovo.getId()).setTimestamp(
					"ultimaAlteracao", new Date()).setInteger(
					"idLogradouroBairroAntigo", logradouroBairroAntigo.getId())
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualiza logradouroCep de um ou mais imóveis
	 * 
	 * [UC0] Atualizar Logradouro
	 * 
	 * @author Raphael Rossiter
	 * @date 22/02/2007
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarLogradouroCep(LogradouroCep logradouroCepAntigo,
			LogradouroCep logradouroCepNovo) throws ErroRepositorioException {

		String consulta = "";

		Session session = HibernateUtil.getSession();

		try {

			consulta = "UPDATE gcom.arrecadacao.banco.Agencia SET "
					+ "lgcp_id = :idLogradouroCepNovo, agen_tmultimaalteracao = :ultimaAlteracao "
					+ "WHERE lgcp_id = :idLogradouroCepAntigo ";

			session.createQuery(consulta).setInteger("idLogradouroCepNovo",
					logradouroCepNovo.getId()).setTimestamp("ultimaAlteracao",
					new Date()).setInteger("idLogradouroCepAntigo",
					logradouroCepAntigo.getId()).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa o cliente da guia de pagamento através do id da Guia de
	 * Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 28/02/2007
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarClienteDeGuiaPagamento(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar o objeto pesquisada
		Object[] retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select cli.id, cli.nome, cli.cpf, cli.cnpj "
					+ "from GuiaPagamento  guia "
					+ "inner join guia.cliente cli "
					+ "where guia.id =:idGuiaPagamento ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento.intValue())
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o cliente da guia de pagamento através do id da Guia de
	 * Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarImovelDeClienteGuiaPagamento(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		// cria a variável que vai armazenar o objeto pesquisada
		Object[] retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select cli.id, cli.nome, cli.cpf, cli.cnpj "
					+ "from ClienteGuiaPagamento cgp "
					+ "inner join cgp.cliente cli "
					+ "inner join cgp.clienteRelacaoTipo crtp "
					+ "inner join cgp.guiaPagamento guia "
					+ "where  crtp.id = :clienteRelacaoTipo and guia.id =:idGuiaPagamento ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento.intValue()).setShort(
					"clienteRelacaoTipo", ClienteRelacaoTipo.USUARIO)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o cliente da guia de pagamento através do id da Guia de
	 * Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 28/02/2007
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarClienteDeClienteImovel(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar o objeto pesquisada
		Object[] retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try {
			// cria o HQL para consulta
			String consulta = "select "
					+ "clie.clie_id as idCliente, clie.clie_nncpf as cpf, clie.clie_nncnpj as cnpj,"
					+ "clie.clie_nmcliente as nomeCliente "
					+ "FROM faturamento.guia_pagamento gp  "
					+ "INNER JOIN cadastro.imovel imov  on gp.imov_id = imov.imov_id  "
					+ "LEFT JOIN cadastro.cliente_imovel cliImov on cliImov.imov_id = imov.imov_id "
					+ "LEFT JOIN cadastro.cliente clie on cliImov.clie_id = clie.clie_id "
					+ "LEFT JOIN cadastro.cliente_relacao_tipo crt on cliImov.crtp_id = crt.crtp_id "
					+ "WHERE gp.gpag_id = " + idGuiaPagamento
					+ "AND crt.crtp_id = " + ClienteRelacaoTipo.USUARIO;

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar(
					"idCliente", Hibernate.INTEGER)
					.addScalar("cpf", Hibernate.STRING)
					.addScalar("cnpj", Hibernate.STRING)
					.addScalar("nomeCliente", Hibernate.STRING)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito - remover guia pagamento referente
	 * ao parcelamento
	 * 
	 * remove a guia de pagamento do Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * 
	 * @param
	 * @return void
	 */
	public void removerGuiaPagamentoPagamento(Integer idPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {

			String processarPagamentoConta = "UPDATE Pagamento "
					+ "SET gpag_id = null, pgmt_tmultimaalteracao = :dataAlteracao "
					+ "WHERE pgmt_id =:idPagamento)";

			session.createQuery(processarPagamentoConta).setTimestamp(
					"dataAlteracao", new Date()).setInteger("idPagamento",
					idPagamento).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * Pesquisa os ano/mês de referência dos pagamentos para ano/mês de
	 * referência maior ou igual ao ano/mês de referência atual da arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 07/03/2007
	 * 
	 * @param anoMesArrecadacaoAtual
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesArrecadacaoPagamentoMaiorIgualAnoMesArrecadacaoAtual(
			Integer anoMesArrecadacaoAtual, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = "select distinct(pagamento.anoMesReferenciaArrecadacao) "
					+ "from Pagamento pagamento "
					+ "inner join pagamento.localidade localidade "
					+ "where pagamento.anoMesReferenciaArrecadacao >= :anoMesArrecadacaoAtual "
					+ "and localidade.id = :idLocalidade";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesArrecadacaoAtual", anoMesArrecadacaoAtual)
					.setInteger("idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 20/03/2007
	 * 
	 * @param idDebitoACobrar
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadePagamentosPorDebitoACobrar(
			Integer idDebitoACobrar) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = "SELECT COUNT(*) " + "FROM Pagamento pagamento "
					+ "INNER JOIN pagamento.debitoACobrarGeral debitoACobrarGeral "
					+ "WHERE debitoACobrarGeral.id = :idDebitoACobrar ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idDebitoACobrar", idDebitoACobrar).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualiza a situacao atual dos pagamentos (PGST_IDATUAL) (tabela
	 * PAGAMENTO_SITUACAO)
	 * 
	 * @author Pedro Alexandre
	 * @date 23/03/2007
	 * 
	 * @param colecaoIdsPagamentos
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoPagamentoClassificado(Collection colecaoIdsPagamentos) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try {
			atualizarSituacaoPagamento = "UPDATE Pagamento pgmt "
					+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao,"
					+ " pgmt.pagamentoSituacaoAnterior.id = :pagamentoSituacaoAnterior,"
					+ " pgmt.ultimaAlteracao = :dataAlteracao,"
					+ " pgmt.valorExcedente = null "
					+ "WHERE pgmt.id =:idPagamento";

			int i = 1;

			Iterator iteratorPagamentos = colecaoIdsPagamentos.iterator();
			while (iteratorPagamentos.hasNext()) {

				Pagamento pagamento = (Pagamento) iteratorPagamentos.next();
				
				BigInteger pagamentoSituacaoAtual;
				if (pagamento.getPagamentoSituacaoAtual() != null){
					pagamentoSituacaoAtual = BigInteger.valueOf(pagamento.getPagamentoSituacaoAtual().getId());
				}else{
					pagamentoSituacaoAtual = null;
				}

				session.createQuery(atualizarSituacaoPagamento)
										.setInteger("pagamentoSituacao", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
										.setBigInteger("pagamentoSituacaoAnterior", pagamentoSituacaoAtual)
										.setTimestamp("dataAlteracao", new Date())
										.setInteger("idPagamento", pagamento.getId())
										.executeUpdate();

				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Caso o valor total dos pagamentos seja menor que o valor do documento,
	 * atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a valor não confere (tabela PAGAMENTO_SITUACAO) e atualiza
	 * o id da conta nos pagamentos (seta CNTA_ID da tabela PAGAMENTO para
	 * CNTA_ID da tabela CONTA)
	 * 
	 * [SB0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Pedro Alexandre
	 * @date 28/03/2007
	 * 
	 * @param mapPagamentosValorNaoConfere
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoValorNaoConfereConta(
			Map<Integer, Collection> mapPagamentosValorNaoConfere)
			throws ErroRepositorioException {

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		String processarPagamentoConta = "UPDATE Pagamento pgmt "
				+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
				+ "pgmt.contaGeral.id = :idConta, "
				+ "pgmt.ultimaAlteracao = :dataAlteracao "
				+ "WHERE pgmt.id IN(:idsPagamentos)";

		Collection colecaoIdsContas = mapPagamentosValorNaoConfere.keySet();
		Iterator iteratorIdsContas = colecaoIdsContas.iterator();

		try {

			int i = 1;

			while (iteratorIdsContas.hasNext()) {
				
				Integer idConta = (Integer) iteratorIdsContas.next();

				Collection colecaoIdsPagamentos = mapPagamentosValorNaoConfere
						.get(idConta);

				if (colecaoIdsPagamentos != null
						&& !colecaoIdsPagamentos.isEmpty()) {
					session.createQuery(processarPagamentoConta).setInteger(
							"pagamentoSituacao",
							PagamentoSituacao.VALOR_NAO_CONFERE).setInteger(
							"idConta", idConta).setTimestamp("dataAlteracao",
							new Date()).setParameterList("idsPagamentos",
							colecaoIdsPagamentos).executeUpdate();

					if (i % 50 == 0) {
						session.flush();
						session.clear();
					}
					i++;
				}
			}
			session.flush();
			session.clear();
		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Caso o valor total dos pagamentos seja menor que o valor do documento,
	 * atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a valor não confere (tabela PAGAMENTO_SITUACAO) e atualiza
	 * o id da guia de pagamento nos pagamentos (seta GPAG_ID da tabela
	 * PAGAMENTO para GPAG_ID da tabela GUIA PAGAMENTO)
	 * 
	 * [SB0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Pedro Alexandre
	 * @date 28/03/2007
	 * 
	 * @param mapPagamentosValorNaoConfere
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoValorNaoConfereGuiaPagamento(
			Map<Integer, Collection> mapPagamentosValorNaoConfere)
			throws ErroRepositorioException {

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		String processarPagamentoGuiaPagamento = "UPDATE Pagamento pgmt "
				+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
				+ "pgmt.guiaPagamento.id = :idGuiaPagamento, "
				+ "pgmt.ultimaAlteracao = :dataAlteracao "
				+ "WHERE pgmt.id IN(:idsPagamentos)";

		Collection colecaoIdsGuias = mapPagamentosValorNaoConfere.keySet();
		Iterator iteratorIdsGuias = colecaoIdsGuias.iterator();

		try {

			int i = 1;

			while (iteratorIdsGuias.hasNext()) {
				
				Integer idGuiaPagamento = (Integer) iteratorIdsGuias.next();

				Collection colecaoIdsPagamentos = mapPagamentosValorNaoConfere
						.get(idGuiaPagamento);

				if (colecaoIdsPagamentos != null
						&& !colecaoIdsPagamentos.isEmpty()) {
					session.createQuery(processarPagamentoGuiaPagamento)
							.setInteger("pagamentoSituacao",
									PagamentoSituacao.VALOR_NAO_CONFERE)
							.setInteger("idGuiaPagamento", idGuiaPagamento)
							.setTimestamp("dataAlteracao", new Date())
							.setParameterList("idsPagamentos",
									colecaoIdsPagamentos).executeUpdate();

					if (i % 50 == 0) {
						session.flush();
						session.clear();
					}
					i++;
				}
			}
			session.flush();
			session.clear();
		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Caso o valor total dos pagamentos seja menor que o valor do documento,
	 * atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a valor não confere (tabela PAGAMENTO_SITUACAO) e atualiza
	 * o id do débito a cobrar nos pagamentos (seta DBAC_ID da tabela PAGAMENTO
	 * para DBAC_ID da tabela DEBITO A COBRAR)
	 * 
	 * [SB0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Pedro Alexandre
	 * @date 28/03/2007
	 * 
	 * @param mapPagamentosValorNaoConfere
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoValorNaoConfereDebitoACobrar(
			Map<Integer, Collection> mapPagamentosValorNaoConfere)
			throws ErroRepositorioException {

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		String processarPagamentoDebitoACobrar = "UPDATE Pagamento pgmt "
				+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
				+ "pgmt.debitoACobrarGeral.id = :idDebitoACobrar, "
				+ "pgmt.ultimaAlteracao = :dataAlteracao "
				+ "WHERE pgmt.id IN(:idsPagamentos)";

		Collection colecaoIdsDebitosACobrar = mapPagamentosValorNaoConfere
				.keySet();
		Iterator iteratorIdsDebitosACobrar = colecaoIdsDebitosACobrar
				.iterator();

		try {

			int i = 1;

			while (iteratorIdsDebitosACobrar.hasNext()) {
				
				Integer idDebitoACobrar = (Integer) iteratorIdsDebitosACobrar
						.next();

				Collection colecaoIdsPagamentos = mapPagamentosValorNaoConfere
						.get(idDebitoACobrar);

				if (colecaoIdsPagamentos != null
						&& !colecaoIdsPagamentos.isEmpty()) {
					session.createQuery(processarPagamentoDebitoACobrar)
							.setInteger("pagamentoSituacao",
									PagamentoSituacao.VALOR_NAO_CONFERE)
							.setInteger("idDebitoACobrar", idDebitoACobrar)
							.setTimestamp("dataAlteracao", new Date())
							.setParameterList("idsPagamentos",
									colecaoIdsPagamentos).executeUpdate();

					if (i % 50 == 0) {

						session.flush();
						session.clear();
					}
					i++;
				}
			}
			session.flush();
			session.clear();
		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] - Classificar Pagamentos e Devoluções
	 * 
	 * <Breve descrição sobre o subfluxo>
	 * 
	 * [SB0008] - Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 28/03/2007, 11/06/2007
	 * 
	 * @param colecaoPagamentos
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo(
			Collection colecaoPagamentos) throws ErroRepositorioException {

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		String processarPagamento = "UPDATE Pagamento pgmt "
				+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
				+ "pgmt.contaGeral.id = null, pgmt.guiaPagamento.id = null, pgmt.debitoACobrarGeral.id = null, "
				+ "pgmt.ultimaAlteracao = :dataAlteracao "
				+ "WHERE pgmt.id = :idPagamento";

		Iterator<Pagamento> iteratorPagamentos = colecaoPagamentos.iterator();

		try {

			int i = 1;

			while (iteratorPagamentos.hasNext()) {

				Pagamento pagamento = iteratorPagamentos.next();

				session.createQuery(processarPagamento).setInteger(
						"pagamentoSituacao",
						PagamentoSituacao.VALOR_NAO_CONFERE).setTimestamp(
						"dataAlteracao", new Date()).setInteger("idPagamento",
						pagamento.getId()).executeUpdate();

				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();
		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Remove o id da guia de pagamento dos pagamentos referentes a conta para
	 * poder mandar a guia de pagamento para o histórico.
	 * 
	 * [UC0000] Gerar Histórco para encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 01/04/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void apagarIdGuiaPagamentoPagamentos(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "UPDATE Pagamento "
					+ "SET guiaPagamento = null "
					+ "WHERE id in (select pgmt.id from Pagamento pgmt where pgmt.guiaPagamento.id = :idGuiaPagamento) ";

			session.createQuery(consulta).setInteger("idGuiaPagamento",
					idGuiaPagamento).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisa os movimentos dos arrecadores para a geração do relatório
	 * 
	 * [UCXXXX] Acompanhar Movimento dos Arrecadadores
	 * 
	 * @author Rafael Corrêa
	 * @date 02/04/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarMovimentoArrecadadoresRelatorio(
			Integer mesAnoReferencia, Integer idArrecadador,
			Integer idFormaArrecadacao, Date dataPagamentoInicial,
			Date dataPagamentoFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = null;
		Collection retorno = null;

		try {

			consulta = "(select pg.pgmt_amreferenciaarrecadacao as anoMesReferencia, cli.clie_nmcliente as nomeArrecadador, arf.arfm_dsarrecadacaoforma as arrecadacaoForma, "
					+ " pg.pgmt_dtpagamento as dataPagamento, sum(pg.pgmt_vlpagamento) as valorPagamento, count(distinct pg.amit_id) as qtdeDocumentos, count(pgmt_id) as qtdePagamentos "
					+ " from arrecadacao.pagamento pg "
					+ " inner join arrecadacao.aviso_bancario avb on (pg.avbc_id = avb.avbc_id) "
					+ " inner join arrecadacao.arrecadador arr on (avb.arrc_id = arr.arrc_id) "
					+ " inner join cadastro.cliente cli on (arr.clie_id = cli.clie_id) "
					+ " inner join arrecadacao.arrecadacao_forma arf on (pg.arfm_id = arf.arfm_id) "
					+ " where pgmt_amreferenciaarrecadacao = :mesAnoReferencia and pg.pgmt_dtpagamento between :dataPagamentoInicial and :dataPagamentoFinal ";

			if (idArrecadador != null) {
				consulta = consulta + " and arr.arrc_id = " + idArrecadador;
			}

			if (idFormaArrecadacao != null) {
				consulta = consulta + " and arf.arfm_id = "
						+ idFormaArrecadacao;
			}

			consulta = consulta
					+ " group by pg.pgmt_amreferenciaarrecadacao, cli.clie_nmcliente, arf.arfm_dsarrecadacaoforma, "
					+ " pgmt_dtpagamento "
					+ " order by cli.clie_nmcliente, arf.arfm_dsarrecadacaoforma, pgmt_dtpagamento) "
					+ " union "
					+ " (select pg.pgmt_amreferenciaarrecadacao as anoMesReferencia, cli.clie_nmcliente as nomeArrecadador, arf.arfm_dsarrecadacaoforma as  arrecadacaoForma, '9999-12-01' as dataPagamento, "
					+ " sum(pg.pgmt_vlpagamento) as valorPagamento, count(distinct pg.amit_id) as qtdeDocumentos, count(pgmt_id) as qtdePagamentos "
					+ " from arrecadacao.pagamento pg "
					+ " inner join arrecadacao.aviso_bancario avb on (pg.avbc_id = avb.avbc_id) "
					+ " inner join arrecadacao.arrecadador arr on (avb.arrc_id = arr.arrc_id) "
					+ " inner join cadastro.cliente cli on (arr.clie_id = cli.clie_id) "
					+ " inner join arrecadacao.arrecadacao_forma arf on (pg.arfm_id = arf.arfm_id) "
					+ " where pgmt_amreferenciaarrecadacao = :mesAnoReferencia and pg.pgmt_dtpagamento < :dataPagamentoInicial ";

			if (idArrecadador != null) {
				consulta = consulta + " and arr.arrc_id = " + idArrecadador;
			}

			if (idFormaArrecadacao != null) {
				consulta = consulta + " and arf.arfm_id = "
						+ idFormaArrecadacao;
			}

			consulta = consulta
					+ " group by pg.pgmt_amreferenciaarrecadacao, cli.clie_nmcliente, arf.arfm_dsarrecadacaoforma "
					+ " order by cli.clie_nmcliente, arf.arfm_dsarrecadacaoforma) ";

			retorno = session.createSQLQuery(consulta).addScalar(
					"anoMesReferencia", Hibernate.INTEGER).addScalar(
					"nomeArrecadador", Hibernate.STRING).addScalar(
					"arrecadacaoForma", Hibernate.STRING).addScalar(
					"dataPagamento", Hibernate.DATE).addScalar(
					"valorPagamento", Hibernate.BIG_DECIMAL).addScalar(
					"qtdeDocumentos", Hibernate.INTEGER).addScalar(
					"qtdePagamentos", Hibernate.INTEGER).setInteger(
					"mesAnoReferencia", mesAnoReferencia).setDate(
					"dataPagamentoInicial", dataPagamentoInicial).setDate(
					"dataPagamentoFinal", dataPagamentoFinal).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Sequencial do tipo lançamento igual a 1550
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * doações
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 03/04/2007, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idLancamentoItemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(dccg.dccg_vlcategoria) as col_0  " +
					  "from " +
					   "faturamento.debito_cobrado_categoria dccg  " +
					  "where " +
					   "dccg.catg_id= :idCategoria  " +
					   "and (dccg.dbcb_id in ( " +
					 				"select " +
					 				"dbcb.dbcb_id  " +
					 				"from " +
					 				"faturamento.debito_cobrado dbcb  " +
					 				"where " +
					 				"dbcb.lict_id= :idLancamentoItemContabil  " +
					 				"and dbcb.fntp_id= :idFinanciamentoTipo  " +
					 				"and (dbcb.cnta_id in (" +
											 				"select " +
											 				"distinct pgmt.cnta_id " + 
											 				"from " +
											 				"arrecadacao.pagamento pgmt " + 
											 				"where " +
											 				"pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
											 				"and pgmt.loca_id= :idLocalidade  " +
											 				"and (pgmt.pgst_idatual= :idPagamentoClassificado or ( " +
											 				"pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior= :idPagamentoValorNaoConfere)) " + 
											 				"and (pgmt.cnta_id is not null) "	+		
					 				")) " +
					 				") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.DOACOES)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idPagamentoValorNaoConfere",PagamentoSituacao.VALOR_NAO_CONFERE)
					.setMaxResults(1)
					.uniqueResult();

			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4150
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual doações.
	 * 
	 * @author Pedro Alexandre
	 * @date 03/04/2007
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoDoacoes(
			Integer idLocalidade, Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, Integer idLancamentoItemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) "
					+ "from DebitoCobradoCategoria dccg "
					+ "where dccg.categoria.id="
					+ idCategoria
					+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
					+ "where dbcb.lancamentoItemContabil.id = "
					+ idLancamentoItemContabil
					+ " and dbcb.financiamentoTipo.id ="
					+ FinanciamentoTipo.DOACOES
					+ " and dbcb.conta.id in( select distinct(pgmt.contaGeral.id) "
					+ "from Pagamento pgmt "
					+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
					+ "and pgmt.localidade.id =" + idLocalidade + " "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
					+ "pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR + ") "
					+ "and pgmt.contaGeral.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4000
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual a parcelamento de
	 * serviço e grupo de parcelamento diferente de juros cobrados.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 26/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idLancamentoItemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(dccg.dccg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.debito_cobrado_categoria dccg " + 
					  "where " +
					   "dccg.catg_id= :idCategoria  " +
					   "and (dccg.dbcb_id in ( " +
					 			"select " +
					 			"dbcb.dbcb_id " + 
					 			"from " +
					 			"faturamento.debito_cobrado dbcb " + 
					 			"where " +
					 			"dbcb.lict_id= :idLancamentoItemContabil  " +
					 			"and dbcb.fntp_id= :idFinanciamentoTipo  " +
					 			"and (dbcb.cnta_id in (" +
										 			"select " +
										 			"distinct pgmt.cnta_id " + 
										 			"from " +
										 			"arrecadacao.pagamento pgmt " + 
										 			"where " +
										 			"pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
										 			"and pgmt.loca_id= :idLocalidade  " +
										 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 			"and (pgmt.cnta_id is not null) "	+		
					 			")) " +
					 			") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.DOACOES)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as devoluções classificadas para transferir para o histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesClassificadasPorLocalidade(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";
		
		/**
		 * Algumas guias de devolução foram jogadas para histórico indevidamente
		 * Alterado valor da clausula where de anoMesReferenciaArrecadacao de <= para <
		 * 
		 * @author Wellington Rocha
		 * @date 18/09/2012
		 * */

		try {

			// Cria o hql de pesquisa
			consulta = "select devl from Devolucao devl "
					+ "inner join devl.localidade loca "
					+ "where loca.id= :idLocalidade and "
					+ "devl.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ "and ( devl.devolucaoSituacaoAtual.id = " + DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA 
					+ " or devl.devolucaoSituacaoAtual.id = " + DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES
					+ ")"
					;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesReferenciaArrecadacao",
					anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa as contas correspondentes aos pagamentos classificados de conta
	 * e os pagamentos anteriores de conta classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContasDePagamentosClassificadosContaEPagamentosAnterioresContaClassificadosNoMes(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection<Conta> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select cnta from Conta cnta "
					+ "inner join cnta.localidade loca "
					+ "where cnta.id in "
					+ "(select distinct pgmt.contaGeral.id from Pagamento pgmt where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO
					+ " or pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR
					+ ") "
					+ " and pgmt.contaGeral.id is not null and pgmt.localidade.id = :idLocalidade) "
					+ " and loca.id = :idLocalidade ";

			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesReferenciaArrecadacao",
					anoMesReferenciaArrecadacao).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa a conta
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarConta(Integer idConta)
			throws ErroRepositorioException {

		Conta retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = "select cnta from Conta cnta where cnta.id = :idConta ";

			retorno = (Conta) session.createQuery(consulta).setInteger(
					"idConta", idConta).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisar o pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 10/04/2007
	 * 
	 * @param idPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Pagamento pesquisarPagamento(Integer idPagamento)
			throws ErroRepositorioException {

		Pagamento retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select pgmt from Pagamento pgmt where pgmt.id = :idPagamento ";

			// Executa o hql
			retorno = (Pagamento) session.createQuery(consulta).setInteger(
					"idPagamento", idPagamento).uniqueResult();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Integer> pesquisarIdsSetoresComPagamentosOuDevolucoes()
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select stcm_id as setorComercial from cadastro.setor_comercial where loca_id in (select loca_id from arrecadacao.devolucao "
					+ "union "
					+ "select loca_id as localidade from arrecadacao.pagamento)";

			retorno = session.createSQLQuery(consulta).addScalar(
					"setorComercial", Hibernate.INTEGER).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer pesquisarIdLocalidadePorSetorComercial(
			Integer idSetorComercial) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = "select stcm.localidade.id from SetorComercial stcm where stcm.id = :idSetorComercial";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idSetorComercial", idSetorComercial).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisa os débitos a cobrar correspondentes aos pagamentos classificados
	 * de débito a cobrar e aos pagamentos anteriores de débito a cobrar
	 * classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/04/2007
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoACobrar> pesquisarDebitosACobrarDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<DebitoACobrar> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		/**
		 * Algumas guias de pagamento foram indevidamente jogados para histórico
		 * Alterada a clausula where do anoMesReferenciaArrecadacao de <= para <
		 * 
		 * @author Wellington Rocha
		 * @date 18/09/2012*/

		try {

			consulta = "select dbac from DebitoACobrar dbac "
					+ "inner join dbac.localidade loca "
					+ "where dbac.id in "
					+ "(select distinct pgmt.debitoACobrarGeral.id from Pagamento pgmt where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ "and (pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO
					+ " or pgmt.pagamentoSituacaoAtual.id = "
					+ PagamentoSituacao.VALOR_A_BAIXAR
					+ ") "
					+ " and pgmt.debitoACobrarGeral.id is not null and pgmt.localidade.id = :idLocalidade) "
					+ " and loca.id = :idLocalidade ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesReferenciaArrecadacao",
					anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4400, 4410, 4420, 4430
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos créditos realizados por localidade e categoria, para
	 * os pagamentos de contas efetuados em meses anteriores classificados no
	 * mês, para origem do crédito igual a descontos concedidos.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idOrigemCredito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idOrigemCredito)
			throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(crcg.crcg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.cred_realizado_catg crcg " + 
					  "where " +
					   "crcg.catg_id=:idCategoria " + 
					   "and (crcg.crrz_id in ( " +
					 			"select " +
					 			"crrz.crrz_id " + 
					 			"from " +
					 			"faturamento.credito_realizado crrz " + 
					 			"where " +
					 			"crrz.crog_id= :idOrigemCredito " +
					 			"and (crrz.cnta_id in (" +
									 			"select " +
									 			"distinct pgmt.cnta_id " + 
									 			"from " +
									 			"arrecadacao.pagamento pgmt " + 
									 			"where " +
									 			"pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
									 			"and pgmt.loca_id= :idLocalidade  " +
									 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
									 			"and (pgmt.cnta_id is not null) "	+		
					 			")) " +
					 	") " +
					   ")";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0", Hibernate.BIG_DECIMAL)	
					.setInteger("idCategoria", idCategoria)
					.setInteger("idOrigemCredito",idOrigemCredito)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 400 e 500
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * parcelamento de água ou parcelamento de esgoto.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2007, 22/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idFinanciamentoTipo)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";
		StringBuilder conta = new StringBuilder();
		StringBuilder pgClassificado = new StringBuilder();
		StringBuilder pgRecuperacaoCredito = new StringBuilder();

		try {

			conta.append("select  distinct pgmt.cnta_id ") 
			.append("from arrecadacao.pagamento pgmt ") 
			.append("where pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao ") 
			.append("and pgmt.loca_id= :idLocalidade  ")
			.append("and (pgmt.pgst_idatual= :idPagamentoClassificado or (pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior = :idPagamentoValorNaoConfere)) ") 
			.append("and (pgmt.cnta_id is not null) ");

			consulta  = "select " +
						  "sum(dccg.dccg_vlcategoria) as col_0 " +
						  "from " +
						   "faturamento.debito_cobrado_categoria dccg " + 
						  "where " +
						   "dccg.catg_id=:idCategoria  " +
						   "and (dccg.dbcb_id in ( " +
						 				"select " +
						 				"dbcb.dbcb_id " + 
						 				"from " +
						 				"faturamento.debito_cobrado dbcb " + 
						 				"where " +
						 				"dbcb.fntp_id=:idFinanciamentoTipo  " +
						 				"and (dbcb.cnta_id in (" +
												 				conta.toString() + 			
						 				") ))" +
						   ")";
			
			
			pgClassificado.append("and (pgmt.pgst_idatual= :idPagamentoClassificado or (pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior = :idPagamentoValorNaoConfere)) ");
			pgRecuperacaoCredito.append("and pgmt.pgst_idatual= :idPagamentoClassificado or (pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior = :idPagamentoValorNaoConfere)) ");
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
			 		.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idPagamentoValorNaoConfere",PagamentoSituacao.VALOR_NAO_CONFERE)
					.setInteger("idLocalidade", idLocalidade)
					.setMaxResults(1)
					.uniqueResult();

			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3800
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos débitos cobrados por localidade e categoria para os
	 * pagamentos de contas efetuados em meses anteriores classificados no mês
	 * para tipo de financiamento igual a parcelamento de água.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2007, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idFinanciamentoTipo)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(dccg.dccg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.debito_cobrado_categoria dccg " + 
					  "where " +
					   "dccg.catg_id= :idCategoria  " +
					   "and (dccg.dbcb_id in ( " +
					 				"select " +
					 				"dbcb.dbcb_id " + 
					 				"from " +
					 				"faturamento.debito_cobrado dbcb " + 
					 				"where " +
					 				"dbcb.fntp_id= :idFinanciamentoTipo  " +
					 				"and (dbcb.cnta_id in (" +
										 				"select " +
										 				"distinct pgmt.cnta_id " + 
										 				"from " +
										 				"arrecadacao.pagamento pgmt " + 
										 				"where " +
										 				"pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
										 				"and pgmt.loca_id= :idLocalidade  " +
										 				"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 				"and (pgmt.cnta_id is not null) "			+
					 				")) " +
					 			") " +
					   ")";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
			  		.addScalar("col_0", Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 300
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor do débitos cobrados por localidade, categoria e item
	 * contábil dos pagamentos classificados de conta para tipo de financiamento
	 * igual a serviço
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 22/05/2006, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @param colecaoIdsFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria,
			Collection<Integer> colecaoIdsFinanciamentoTipo)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta  = "select " +
					  "sum(dccg.dccg_vlcategoria) as col_0  " +
					  "from " +
					   "faturamento.debito_cobrado_categoria dccg  " +
					  "where " +
					   "dccg.catg_id= :idCategoria  " +
					   "and (dccg.dbcb_id in ( " +
					 				"select " +
					 				"dbcb.dbcb_id  " +
					 				"from " +
					 				"faturamento.debito_cobrado dbcb  " +
					 				"where " +
					 				"dbcb.lict_id=:idLancamentoItemContabil  " +
					 				"and (dbcb.fntp_id in (:idsFinanciamentosTipo))  " +
					 				"and ( dbcb.cnta_id in (" +
											 				"select " +
											 				"distinct pgmt.cnta_id " + 
											 				"from " +
											 				"arrecadacao.pagamento pgmt " + 
											 				"where " +
											 				"pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
											 				"and pgmt.loca_id= :idLocalidade  " +
											 				"and (pgmt.pgst_idatual= :idPagamentoClassificado or ( " +
											 				"pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior= :idPagamentoValorNaoConfere )) " + 
											 				"and (pgmt.cnta_id is not null) "	+		
					 				")) " +
					 			") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setParameterList("idsFinanciamentosTipo",colecaoIdsFinanciamentoTipo)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("idPagamentoValorNaoConfere",PagamentoSituacao.VALOR_NAO_CONFERE)
					.setMaxResults(1)
					.uniqueResult();

			

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3700
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual a serviço.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 26/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @param idsFinanciamentoTipos
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria,
			Collection<Integer> idsFinanciamentoTipos)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {
			
			consulta  = "select " +
						 " sum(dccg.dccg_vlcategoria) as col_0 " +
						 " from " +
						 "  faturamento.debito_cobrado_categoria dccg " + 
						 " where " +
						 "  dccg.catg_id= :idCategoria  " +
						 "  and (dccg.dbcb_id in ( " +
						 			"select " +
						 			"dbcb.dbcb_id " + 
						 			"from " +
						 			"faturamento.debito_cobrado dbcb " + 
						 			"where " +
						 			"dbcb.lict_id= :idLancamentoItemContabil  " +
						 			"and (dbcb.fntp_id in (:idsFinanciamentoTipos)) " + 
						 			"and (dbcb.cnta_id in (" +
											 			"select " +
											 			"distinct pgmt.cnta_id " + 
											 			"from " +
											 			"arrecadacao.pagamento pgmt " + 
											 			"where " +
											 			"pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
											 			"and pgmt.loca_id= :idLocalidade  " +
											 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
											 			"and (pgmt.cnta_id is not null) "	+		
						 			")) " +
					 				") " +
						   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setParameterList("idsFinanciamentoTipos",idsFinanciamentoTipos)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			
			

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] Registrar Movimento Arrecadadores
	 * 
	 * Atualiza o arrecadador contrato
	 * 
	 * 
	 * @author Sávio Luiz,Vivianne Sousa
	 * @date 19/04/2007,28/11/2007
	 * 
	 * @return Coleção de Bancos
	 * @throws ErroRepositorioException
	 */

	public void atualizarDadosArrecadadorContrato(
			ArrecadadorContrato arrecadadorContrato,
			boolean flagEnvioDebitoAutomatico, boolean flagRetornoCodigoBarras,
			boolean flagRetornoDebitoAutomatico, boolean flagRetornoFichaCompensacao)
			throws ErroRepositorioException {

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "UPDATE gcom.arrecadacao.ArrecadadorContrato "
					+ "SET arct_tmultimaalteracao = :ultimaAlteracao,";
			if (flagRetornoCodigoBarras) {
				consulta += " arct_nnnsaretornocdbarras = "
						+ arrecadadorContrato
								.getNumeroSequecialArquivoRetornoCodigoBarras();
			}
			if (flagRetornoDebitoAutomatico) {
				consulta += " arct_nnnsaretornodebaut = "
						+ arrecadadorContrato
								.getNumeroSequencialArquivoRetornoDebitoAutomatico();
			}
			if (flagEnvioDebitoAutomatico) {

				if (flagRetornoCodigoBarras || flagRetornoDebitoAutomatico) {
					consulta += " ,arct_nnnsaenviodebaut = "
							+ arrecadadorContrato
									.getNumeroSequencialArquivoEnvioDebitoAutomatico();
				} else {
					consulta += " arct_nnnsaenviodebaut = "
							+ arrecadadorContrato
									.getNumeroSequencialArquivoEnvioDebitoAutomatico();
				}
			}
            
            if (flagRetornoFichaCompensacao) {
                consulta += " arct_nnnsaretornofichacomp = "
                        + arrecadadorContrato
                                .getNumeroSequencialArquivoRetornoFichaCompensacao();
            }
            
			consulta += " WHERE arct_id = :idArrecadadorContrato";

			session.createQuery(consulta).setInteger("idArrecadadorContrato",
					arrecadadorContrato.getId()).setTimestamp(
					"ultimaAlteracao", new Date()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisar os ano/mês de referência do pagamentos para um imóvel e ano/mês
	 * de arrecadação informados para o tipo de documento informado.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 06/12/2006
	 * 
	 * @param anoMesArrecadacaoAtual
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesReferenciaPagamentoParaImovel(
			Integer anoMesArrecadacaoAtual, Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select distinct(anoMesReferenciaPagamento) from Pagamento pagamento "
					+ " where pagamento.anoMesReferenciaArrecadacao <= :anoMesArrecadacaoAtual "
					+ "and pagamento.imovel.id = :idImovel and pagamento.anoMesReferenciaPagamento is not null "
					+ "and (pagamento.pagamentoSituacaoAtual.id is null or pagamento.pagamentoSituacaoAtual.id <> :idValorABaixar) "
					+ "and pagamento.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao";

			retorno = session.createQuery(consulta)
					.setInteger("anoMesArrecadacaoAtual", anoMesArrecadacaoAtual)
					.setInteger("idImovel", idImovel)
					.setInteger("idValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
					.setShort("indicadorClassificacao", ConstantesSistema.NAO).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os pagamentos histórios de um aviso
	 * 
	 * @author Rafael Corrêa
	 * @date 23/04/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoAvisoBancario(
			Integer idAvisoBancario) throws ErroRepositorioException {

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {

			hql = "select "
					+ "pagamento.documentoTipo.descricaoAbreviado, "
					+ // 0
					"pagamento.dataPagamento, "
					+ // 1
					"pagamento.localidade.id, "
					+ // 2
					"imovel.id, "
					+ // 3
					"cliente.id, "
					+ // 4
					"pagamento.anoMesReferenciaPagamento, "
					+ // 5
					"debitoTipo.id, "
					+ // 6
					"pagamento.valorPagamento, "
					+ // 7
					"pagamentoSituacaoAtual.descricaoAbreviada "
					+ // 8
					"from gcom.arrecadacao.pagamento.PagamentoHistorico pagamento "
					+ "left join pagamento.imovel as imovel "
					+ "left join pagamento.cliente as cliente "
					+ "left join pagamento.debitoTipo as debitoTipo "
					+ "left join pagamento.pagamentoSituacaoAtual as pagamentoSituacaoAtual "
					+ "where pagamento.avisoBancario.id = :idAvisoBancario "
					+ "order by imovel.id,pagamento.anoMesReferenciaPagamento ";
			
			retorno = session.createQuery(hql).setInteger("idAvisoBancario",
					idAvisoBancario).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Pagamento pesquisarPagamentoDeConta(Integer idConta)
			throws ErroRepositorioException {

		Pagamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt FROM Pagamento as pgmt WHERE pgmt.contaGeral.id = :idConta ";

			retorno = (Pagamento) session.createQuery(consulta).setInteger("idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * @author Sávio Luiz
	 * @data 23/04/2006
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Integer pesquisarIdPagamentoDaGuia(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id " + "FROM Pagamento as pgmt "
					+ "WHERE pgmt.guiaPagamento.id = :idGuiaPagamento ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * @author Sávio Luiz
	 * @data 23/04/2006
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Integer pesquisarIdPagamentoDoDebitoACobrar(Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id " + "FROM Pagamento as pgmt "
					+ "WHERE pgmt.debitoACobrarGeral.id = :idDebitoACobrar ";

			retorno = (Integer) session.createQuery(consulta).setInteger(
					"idDebitoACobrar", idDebitoACobrar).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] Retificar Conta
	 * 
	 * @author Vivianne Sousa
	 * @data 23/04/2006
	 * 
	 * @param idPagamento
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarContaEmPagamento(Integer idPagamento, Integer idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "UPDATE Pagamento pgmt "
					+ "SET pgmt.contaGeral.id = :idConta "
					+ "WHERE pgmt.id = :idPagamento ";

			session.createQuery(consulta)
					.setInteger("idPagamento", idPagamento).setInteger(
							"idConta", idConta).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	private String criarCondicionaisPagamentoHistoricoCliente(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) {

		String sql = " ";
		if (idImovel != null && !idImovel.equals("")) {
			sql = sql + " c.imov_id = " + idImovel + " and ";
		}
		if (idCliente != null && !idCliente.equals("")) {
			sql = sql + " a.clie_id = " + idCliente + " and ";
		}
		if (idTipoRelacao != null && !idTipoRelacao.equals("")) {
			sql = sql + " b.crtp_id = " + idTipoRelacao + " and ";
		}
		if (localidadeInicial != null && localidadeFinal != null
				&& !localidadeInicial.equals("") && !localidadeFinal.equals("")) {
			sql = sql + " c.loca_id >= " + localidadeInicial + " and ";
			sql = sql + " c.loca_id <= " + localidadeFinal + " and ";
		}
		if (idAvisoBancario != null && !idAvisoBancario.equals("")) {
			sql = sql + " c.avbc_id = " + idAvisoBancario + " and ";
		}
		if (idArrecadador != null && !idArrecadador.equals("")) {
			sql = sql + " f.armv_id = " + idArrecadador + " and ";
		}
		if (periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoInicial.equals("")) {
			sql = sql
					+ " c.pghi_amreferenciaarrecadacao >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
					+ " and ";
		}
		if (periodoArrecadacaoFinal != null
				&& !periodoArrecadacaoFinal.equals("")) {
			sql = sql
					+ " c.pghi_amreferenciaarrecadacao <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal)
					+ " and ";
		}
		if (periodoPagamentoInicio != null
				&& !periodoPagamentoInicio.equals("")) {
			sql = sql
					+ " c.pghi_amreferenciapagamento >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
					+ " and ";
		}
		if (periodoPagamentoFim != null && !periodoPagamentoFim.equals("")) {
			sql = sql
					+ " c.pghi_amreferenciapagamento <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim)
					+ " and ";
		}

		if (dataPagamentoInicial != null && !dataPagamentoInicial.equals("")) {
			// sql = sql + " pagamento.dataPagamento >= '" +
			// Util.formatarData(dataPagamentoInicial) + "' and " ;
			String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

			if (data1 != null && !data1.equals("")
					&& data1.trim().length() == 8) {

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6)
						+ "-" + data1.substring(6, 8);
			}
			sql = sql + " c.pghi_dtpagamento >= to_date('" + data1 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}
		if (dataPagamentoFinal != null && !dataPagamentoFinal.equals("")) {
			// sql = sql + " pagamento.dataPagamento <= '" +
			// Util.formatarData(dataPagamentoFinal) + "' and " ;
			String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

			if (data2 != null && !data2.equals("")
					&& data2.trim().length() == 8) {

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6)
						+ "-" + data2.substring(6, 8);
			}
			sql = sql + " c.pghi_dtpagamento <= to_date('" + data2 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}

		if (idsPagamentosSituacoes != null
				&& !idsPagamentosSituacoes.equals("")) {
			String valoresIn = "";
			for (int i = 0; i < idsPagamentosSituacoes.length; i++) {
				if (!idsPagamentosSituacoes[i].equals("")) {
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.pgst_idatual in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDebitosTipos != null
				&& !idsDebitosTipos.equals("")
				&& !idsDebitosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDebitosTipos.length; i++) {
				if (!idsDebitosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.dbtp_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsArrecadacaoForma != null
				&& !idsArrecadacaoForma.equals("")
				&& !idsArrecadacaoForma[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsArrecadacaoForma.length; i++) {
				if (!idsArrecadacaoForma[i].equals("")) {
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.arfm_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDocumentosTipos != null
				&& !idsDocumentosTipos.equals("")
				&& !idsDocumentosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDocumentosTipos.length; i++) {
				if (!idsDocumentosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.dotp_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}

		// retira o " and " q fica sobrando no final da query
		sql = Util.removerUltimosCaracteres(sql, 4);

		return sql;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 04/06/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorUnidadeNegocio(
			int anoMesReferencia) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(ra.valorItemArrecadacao)," // 0
					+ " rt.descricao," // 1
					+ " lt.descricao," // 2
					+ " li.descricao," // 3
					+ " lic.descricao," // 4
					+ " lt.indicadorImpressao," // 5
					+ " lt.indicadorTotal," // 6
					+ " lt.id," // 7
					+ " lt.lancamentoTipo.id," // 8
					+ " ra.categoria.id," // 9
					+ " ra.unidadeNegocio.nome," // 10
					+ " ra.unidadeNegocio.id," // 11
					+ " rt.id," // 12
					+ " ra.sequenciaTipoLancamento," // 13
					+ " ra.sequenciaItemTipoLancamento," // 14
					+ " ra.gerenciaRegional.nome," // 15
					+ " ra.gerenciaRegional.id " // 16
					+ " from ResumoArrecadacao ra"
					+ " left join ra.lancamentoTipo lt"
					+ " left join ra.lancamentoItem li"
					+ " left join ra.lancamentoItemContabil lic"
					+ " left join ra.recebimentoTipo rt"
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " (ra.categoria.id = 1 or"
					+ " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or"
					+ " ra.categoria.id = 4)"
					+ " group by "
					+ " ra.unidadeNegocio.nome,ra.unidadeNegocio.id,"
					+ " rt.descricao, lt.descricao, li.descricao, lic.descricao,"
					+ " lt.indicadorImpressao, lt.indicadorTotal, lt.id, lt.lancamentoTipo.id,"
					+ " ra.categoria.id, rt.id, ra.sequenciaTipoLancamento, ra.sequenciaItemTipoLancamento,"
					+ " ra.gerenciaRegional.nome, ra.gerenciaRegional.id"
					+ " order by "
					+ " ra.gerenciaRegional.nome, ra.unidadeNegocio.nome,"
					+ " rt.id," + " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 04/06/2007
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(
			int anoMesReferencia, Integer unidadeNegocio)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {

			consulta = "select sum(ra.valorItemArrecadacao),"// 0
					+ " rt.descricao," // 1
					+ " lt.descricao," // 2
					+ " li.descricao," // 3
					+ " lic.descricao," // 4
					+ " lt.indicadorImpressao," // 5
					+ " lt.indicadorTotal," // 6
					+ " lt.id," // 7
					+ " lt.lancamentoTipo.id," // 8
					+ " ra.categoria.id," // 9
					+ " ra.unidadeNegocio.nome, " // 10
					+ " ra.unidadeNegocio.id, " // 11
					+ " rt.id," // 12
					+ " ra.sequenciaTipoLancamento," // 13
					+ " ra.sequenciaItemTipoLancamento," // 14
					+ " ra.gerenciaRegional.nome," //15
					+ " ra.gerenciaRegional.id " //16
					+ " from ResumoArrecadacao ra"
					+ " left join ra.lancamentoTipo lt"
					+ " left join ra.lancamentoItem li"
					+ " left join ra.lancamentoItemContabil lic"
					+ " left join ra.recebimentoTipo rt"
					+ " where ra.anoMesReferencia = :anoMesReferencia and"
					+ " ra.unidadeNegocio = :unidadeNegocio and"
					+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
					+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
					+ " group by " + " rt.descricao," + " lt.descricao,"
					+ " li.descricao," + " lic.descricao,"
					+ " lt.indicadorImpressao," + " lt.indicadorTotal,"
					+ " lt.id," + " lt.lancamentoTipo.id,"
					+ " ra.categoria.id," 
					+ " ra.gerenciaRegional.nome," 
					+ " ra.gerenciaRegional.id, "
					+ " ra.unidadeNegocio.nome,"
					+ " ra.unidadeNegocio.id," + " rt.id,"
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento" + " order by rt.id,"
					+ " ra.sequenciaTipoLancamento,"
					+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger(
					"anoMesReferencia", anoMesReferencia).setInteger(
					"unidadeNegocio", unidadeNegocio).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisar pagamentos pelo aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 11/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public PagamentosDevolucoesHelper filtrarPagamentos(
			FiltroPagamento filtroPagamento) throws ErroRepositorioException {

		// Collection<MovimentarPagamentosDevolucoesHelper> retorno = null;
		Session session = HibernateUtil.getSession();
		Collection<Object[]> consulta = new ArrayList();
		PagamentosDevolucoesHelper retorno = null;
		Integer qtdPagamentos = 0;

		try {

			consulta = new ArrayList(
					new CopyOnWriteArrayList<Pagamento>(
							GeradorHQLCondicional
									.gerarCondicionalQuery(
											filtroPagamento,
											"pagamento",
											"select dotp.descricaoAbreviado, pagamento.anoMesReferenciaPagamento, "
													+ "pagamento.valorPagamento, pagamento.dataPagamento, dbtp.descricao, pagamento.id "
													+ "from Pagamento pagamento "
													+ "inner join pagamento.documentoTipo dotp "
													+ "left join pagamento.debitoTipo dbtp"
													+ "", session).list()));

			if (consulta.size() > 0) {
				Collection<MovimentarPagamentosDevolucoesHelper> colecaoMovimentarPagamentosDevolucoes = new ArrayList();
				MovimentarPagamentosDevolucoesHelper helper = null;
				BigDecimal valorTotal = new BigDecimal("0.00");
				for (Iterator iter = consulta.iterator(); iter.hasNext();) {
					qtdPagamentos = qtdPagamentos + 1;
					Object[] element = (Object[]) iter.next();
					helper = new MovimentarPagamentosDevolucoesHelper();
					helper.setTipoDocumento((String) element[0]);
					if (element[1] != null && !element[1].equals("")) {
						helper
								.setMesAnoReferencia(Util
										.formatarAnoMesParaMesAno((Integer) element[1]));
					}
					helper.setValor(Util
							.formatarMoedaReal((BigDecimal) element[2]));
					valorTotal = valorTotal.add((BigDecimal) element[2]);
					helper.setData(Util.formatarData((Date) element[3]));
					if (element[4] != null && !element[4].equals("")) {
						helper.setTipoDebito((String) element[4]);
					}
					helper.setId((Integer) element[5]);

					colecaoMovimentarPagamentosDevolucoes.add(helper);
				}

				retorno = new PagamentosDevolucoesHelper();
				retorno
						.setColecaoMovimentarPagamentos(colecaoMovimentarPagamentosDevolucoes);
				retorno.setValorTotalPagamentos(Util
						.formatarMoedaReal(valorTotal));
				retorno.setQtdPagamentos(qtdPagamentos);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar devoluçãoes pelo aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 11/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public PagamentosDevolucoesHelper filtrarDevolucoes(
			FiltroDevolucao filtroDevolucao) throws ErroRepositorioException {

		// Collection<MovimentarPagamentosDevolucoesHelper> retorno = null;
		Session session = HibernateUtil.getSession();
		Collection<Object[]> consulta = new ArrayList();
		PagamentosDevolucoesHelper retorno = null;
		Integer qtdDevolucoes = 0;

		try {

			consulta = new ArrayList(
					new CopyOnWriteArrayList<Devolucao>(
							GeradorHQLCondicional
									.gerarCondicionalQuery(
											filtroDevolucao,
											"devolucao",
											"select devolucao.anoMesReferenciaArrecadacao, devolucao.valorDevolucao, "
													+ "devolucao.dataDevolucao, dbtp.descricao, devolucao.id "
													+ "from Devolucao devolucao "
													+ "left join devolucao.debitoTipo dbtp "
													+ "", session).list()));

			if (consulta.size() > 0) {
				Collection<MovimentarPagamentosDevolucoesHelper> colecaoMovimentarPagamentosDevolucoes = new ArrayList();
				MovimentarPagamentosDevolucoesHelper helper = null;
				BigDecimal valorTotal = new BigDecimal("0.00");
				for (Iterator iter = consulta.iterator(); iter.hasNext();) {
					qtdDevolucoes = qtdDevolucoes + 1;
					Object[] element = (Object[]) iter.next();
					helper = new MovimentarPagamentosDevolucoesHelper();
					helper.setTipoDocumento("GDEV");
					if (element[0] != null && !element[0].equals("")) {
						helper
								.setMesAnoReferencia(Util
										.formatarAnoMesParaMesAno((Integer) element[0]));
					}
					helper.setValor(Util
							.formatarMoedaReal((BigDecimal) element[1]));
					valorTotal = valorTotal.add((BigDecimal) element[1]);
					helper.setData(Util.formatarData((Date) element[2]));
					if (element[3] != null && !element[3].equals("")) {
						helper.setTipoDebito((String) element[3]);
					}
					helper.setId((Integer) element[4]);

					colecaoMovimentarPagamentosDevolucoes.add(helper);
				}

				retorno = new PagamentosDevolucoesHelper();
				retorno
						.setColecaoMovimentarDevolucoes(colecaoMovimentarPagamentosDevolucoes);
				retorno.setValorTotalDevolucoes(Util
						.formatarMoedaReal(valorTotal));
				retorno.setQtdDevolucoes(qtdDevolucoes);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar valores de arrecadação e devolução do aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 14/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public ValoresArrecadacaoDevolucaoAvisoBancarioHelper pesquisarValoresAvisoBancario(
			Integer idAvisoBancario) throws ErroRepositorioException {

		ValoresArrecadacaoDevolucaoAvisoBancarioHelper retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select "
					+ " new "
					+ ValoresArrecadacaoDevolucaoAvisoBancarioHelper.class
							.getName()
					+ " ( "
					+ "avbc.valorArrecadacaoInformado, avbc.valorArrecadacaoCalculado, "
					+ "avbc.valorDevolucaoInformado, avbc.valorDevolucaoCalculado) "
					+ "from AvisoBancario avbc "
					+ "where avbc.id = :idAvisoBancario ";

			retorno = (ValoresArrecadacaoDevolucaoAvisoBancarioHelper) session
					.createQuery(consulta).setInteger("idAvisoBancario",
							idAvisoBancario.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualizar Pagamentos
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public void atualizarAvisoBancarioPagamentos(
			Collection<Integer> idsPagamentos, Integer idAvisoBancarioD)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try {

			atualizarSituacaoPagamento = "UPDATE Pagamento "
					+ "SET avbc_id = :idAvisoBancarioD, pgmt_tmultimaalteracao = :dataAlteracao "
					+ "WHERE pgmt_id IN(:idsPagamentos)";

			session.createQuery(atualizarSituacaoPagamento).setInteger(
					"idAvisoBancarioD", idAvisoBancarioD).setTimestamp(
					"dataAlteracao", new Date()).setParameterList(
					"idsPagamentos", idsPagamentos).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar valor de arrecadação calculado
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public void atualizarValorArrecadacaoAvisoBancario(
			String valorArrecadacaoInformado, String valorArrecadacaoCalculado,
			Integer idAvisoBancario) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try {

			atualizarSituacaoPagamento = "UPDATE AvisoBancario "
					+ "SET avbc_vlarrecadacaoinformado = :valorArrecadacaoInformado, "
					+ "avbc_vlarrecadacaocalculado = :valorArrecadacaoCalculado, "
					+ "avbc_tmultimaalteracao = :dataAlteracao "
					+ "WHERE avbc_id = :idAvisoBancario";

			session
					.createQuery(atualizarSituacaoPagamento)
					.setBigDecimal(
							"valorArrecadacaoInformado",
							Util
									.formatarMoedaRealparaBigDecimal(valorArrecadacaoInformado))
					.setBigDecimal(
							"valorArrecadacaoCalculado",
							Util
									.formatarMoedaRealparaBigDecimal(valorArrecadacaoCalculado))
					.setTimestamp("dataAlteracao", new Date()).setInteger(
							"idAvisoBancario", idAvisoBancario).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar Devoluções
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public void atualizarAvisoBancarioDevolucoes(
			Collection<Integer> idsDevolucoes, Integer idAvisoBancarioD)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try {

			atualizarSituacaoPagamento = "UPDATE Devolucao "
					+ "SET avbc_id = :idAvisoBancarioD, devl_tmultimaalteracao = :dataAlteracao "
					+ "WHERE devl_id IN(:idsDevolucoes)";

			session.createQuery(atualizarSituacaoPagamento).setInteger(
					"idAvisoBancarioD", idAvisoBancarioD).setTimestamp(
					"dataAlteracao", new Date()).setParameterList(
					"idsDevolucoes", idsDevolucoes).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar valor de devolução calculado
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public void atualizarValorDevolucaoAvisoBancario(
			String valorDevolucaoInformado, String valorDevolucaoCalculado,
			Integer idAvisoBancario) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try {

			atualizarSituacaoPagamento = "UPDATE AvisoBancario "
					+ "SET avbc_vldevolucaoinformado = :valorDevolucaoInformado, "
					+ "avbc_vldevolucaocalculado = :valorDevolucaoCalculado, "
					+ "avbc_tmultimaalteracao = :dataAlteracao "
					+ "WHERE avbc_id = :idAvisoBancario";

			session
					.createQuery(atualizarSituacaoPagamento)
					.setBigDecimal(
							"valorDevolucaoInformado",
							Util
									.formatarMoedaRealparaBigDecimal(valorDevolucaoInformado))
					.setBigDecimal(
							"valorDevolucaoCalculado",
							Util
									.formatarMoedaRealparaBigDecimal(valorDevolucaoCalculado))
					.setTimestamp("dataAlteracao", new Date()).setInteger(
							"idAvisoBancario", idAvisoBancario).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores - Relatório
	 * 
	 * @author Ana Maria
	 * @date 13/07/2007
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> filtrarIdsMovimentoArrecadador(
			String codigoBanco, String codigoRemessa,
			String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado) throws ErroRepositorioException {
		
		Collection<Integer> idsMovimentoArrecadador = null;
		String sql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisMovimentoArrecadador(
					codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
					numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
					ultimaAlteracaoInicio, ultimaAlteracaoFim,
					descricaoOcorrencia, indicadorAceitacao,
					indicadorAbertoFechado);

			sql = " SELECT arrecadadorMovimento.armv_id as id "
					+ " FROM arrecadacao.arrecadador_movimento arrecadadorMovimento "
					+ condicionais;

			Date dataInicio = null;
			Date dataFim = null;
			if (ultimaAlteracaoInicio != null
					&& !ultimaAlteracaoInicio.equals("")) {

				dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);
				if (condicionais.trim().equals("WHERE")) {
					sql = sql
							+ "arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				} else {
					sql = sql
							+ " and arrecadadorMovimento.armv_tmultimaalteracao >= :dataInicio";
				}

			}

			if (ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")) {

				dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);
				sql = sql
						+ " and arrecadadorMovimento.armv_tmultimaalteracao <= :dataFim";

			}
			if (dataInicio != null && dataFim != null) {
				idsMovimentoArrecadador = session.createSQLQuery(
						sql).addScalar("id",
						Hibernate.INTEGER).setTimestamp("dataInicio",
						dataInicio).setTimestamp("dataFim", dataFim)
						.list();

			} else {
				idsMovimentoArrecadador = session.createSQLQuery(
						sql).addScalar("id",
						Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return idsMovimentoArrecadador;
	}
	
	/**
    *
    * [UC0619] Gerar Relação de Acompanhamento dos Movimentos Arrecadadores por NSA
    *
    * @author Ana Maria
    * @date 12/07/2007
    *
    * @param idMovimentoArrecadador
    * @return
    */
   public Collection<MovimentoArrecadadoresPorNSAHelper> gerarMovimentoArrecadadoresNSA
           (Collection<Integer> idsArrecadadorMovimento, Integer codigoFormaArrecadacao)
           throws ErroRepositorioException {

       Session session = HibernateUtil.getSession();
       String consulta1 = null;
       Collection retornoConsulta1 = new ArrayList();
       String consulta2 = null;
       Collection retornoConsulta2 = new ArrayList();
       String consulta3 = null;
       Collection retornoConsulta3 = new ArrayList();       
       String consulta4 = null;
       Collection retornoConsulta4 = new ArrayList();
       Collection retornoTotal = new ArrayList();
       Collection<MovimentoArrecadadoresPorNSAHelper> retorno =new ArrayList();

       try {

            consulta1 = " select count(armv_nmbanco) as qtdeRegistros, armv_nmbanco as banco, "//0,1
                         + " armv_dtgeracao as dataGeracao, armv_nnnsa as nsa,"//2,3
                         + " sum(to_number(substr(amit_cnregistro, 82,12), '000000000000')) as valor,"//4
                         + " actf.actf_vltarifa as tarifa, arfm.arfm_dsarrecadacaoforma as formaArrecadacao"//5,6
                      + " from arrecadacao.arrecadador_mov_item amit, arrecadacao.arrecadacao_forma arfm,"
                      + " arrecadacao.arrecadador_movimento armv, arrecadacao.arrecadador arrc, arrecadacao.arrecadador_contrato arct,"
                      + " arrecadacao.arrecadador_contrato_tar actf"
                      + " where amit.armv_id = armv.armv_id and"
                      + " substr(amit_cnregistro, 117,1) = arfm.arfm_cdarrecadacaoforma and"
                      + " armv.armv_cdbanco = arrc.arrc_cdagente and"
                      + " arct.arrc_id = arrc.arrc_id and"
                      + " (actf.arfm_id = arfm.arfm_id and actf.arct_id = arct.arct_id) and"
                      + " rgcd_id = 7 and armv.armv_id in (:idsArrecadadorMovimento) ";
//                      + " and amit_dsocorrencia = 'OK' " ;
                      if(codigoFormaArrecadacao != null){
                          consulta1 = consulta1 + " and arfm.arfm_id="+codigoFormaArrecadacao; 
                      }
                      consulta1 = consulta1 + " group by armv_nmbanco, armv_dtgeracao, armv_nnnsa, "
                      + " actf.actf_vltarifa, actf.actf_vltarifa, arfm.arfm_dsarrecadacaoforma "
                      + " order by formaArrecadacao ";
                      
                      
                      if(idsArrecadadorMovimento.size()>999){
          				
          				System.out.println("## TAMANHO TOTAL = " + idsArrecadadorMovimento.size());
          				
          				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsArrecadadorMovimento, 999);
          				
          				int qtdQuebras = 999;
          				int indice = idsArrecadadorMovimento.size() / qtdQuebras;                                   
          				if (idsArrecadadorMovimento.size() % qtdQuebras !=0){
          					indice ++;
          				}
          				
          				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);
          				
          				Collection retornoConsultaPart1 = null;
          				
          				for (int i = 0; i < indice; i++) {

      						System.out.println("## TAMANHO PARTIÇÃO DE INDICE  " + indice +" = " + particoes.get(i).size());
      						
      						retornoConsultaPart1 = session.createSQLQuery(consulta1).addScalar("qtdeRegistros",
              	                    Hibernate.INTEGER).addScalar("banco", Hibernate.STRING)
              	                    .addScalar("dataGeracao", Hibernate.DATE)
              	                    .addScalar("nsa", Hibernate.INTEGER)
              	                    .addScalar("valor", Hibernate.LONG)
              	                    .addScalar("tarifa", Hibernate.BIG_DECIMAL)
              	                    .addScalar("formaArrecadacao", Hibernate.STRING).setParameterList(
              	                               "idsArrecadadorMovimento",
              	                             particoes.get(i)).list();  
      						
      						retornoConsulta1.addAll(retornoConsultaPart1);
          				}					
          			}else{
          				retornoConsulta1 = session.createSQLQuery(consulta1).addScalar("qtdeRegistros",
          	                    Hibernate.INTEGER).addScalar("banco", Hibernate.STRING)
          	                    .addScalar("dataGeracao", Hibernate.DATE)
          	                    .addScalar("nsa", Hibernate.INTEGER)
          	                    .addScalar("valor", Hibernate.LONG)
          	                    .addScalar("tarifa", Hibernate.BIG_DECIMAL)
          	                    .addScalar("formaArrecadacao", Hibernate.STRING).setParameterList(
          	                               "idsArrecadadorMovimento",
          	                               idsArrecadadorMovimento).list();  
          			}

          
            retornoTotal.addAll(retornoConsulta1);
            
            consulta2 = " select count(armv_nmbanco) as qtdeRegistros, armv_nmbanco as banco, "//0,1
                  + " armv_dtgeracao as dataGeracao, armv_nnnsa as nsa,"//2,3
                 + " sum(to_number(substr(amit_cnregistro, 82,12), '000000000000')) as valor,"//4
                 + " actf.actf_vltarifa as tarifa, arfm.arfm_dsarrecadacaoforma as formaArrecadacao"//5,6
                 + " from arrecadacao.arrecadador_mov_item amit,"
                 + " arrecadacao.arrecadador_movimento armv, arrecadacao.arrecadador arrc, arrecadacao.arrecadador_contrato arct,"
                 + " arrecadacao.arrecadador_contrato_tar actf, arrecadacao.arrecadacao_forma arfm"
                 + " where amit.armv_id = armv.armv_id and "
                 + " substr(amit_cnregistro, 117,1) = ' ' and"
                 + " armv.armv_cdbanco = arrc.arrc_cdagente and"
                 + " arct.arrc_id = arrc.arrc_id and"
                 + " arfm.arfm_cdarrecadacaoforma = '1' and"
                 + " (actf.arfm_id = arfm.arfm_id and actf.arct_id = arct.arct_id) and"                 
                 + " rgcd_id = 7 and armv.armv_id in(:idsArrecadadorMovimento)";
//                 + " and amit_dsocorrencia = 'OK'  " ;
                 if(codigoFormaArrecadacao != null){
                      consulta2 = consulta2 + " and arfm.arfm_id="+codigoFormaArrecadacao;        
                 }
                
                  consulta2 = consulta2
                 + " group by armv_nmbanco, armv_dtgeracao, armv_nnnsa, "
                 + " actf.actf_vltarifa, actf.actf_vltarifa, arfm.arfm_dsarrecadacaoforma " ;
      
                 
                  if(idsArrecadadorMovimento.size()>999){
        				
        				System.out.println("## TAMANHO TOTAL = " + idsArrecadadorMovimento.size());
        				
        				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsArrecadadorMovimento, 999);
        				
        				int qtdQuebras = 999;
        				int indice = idsArrecadadorMovimento.size() / qtdQuebras;                                   
        				if (idsArrecadadorMovimento.size() % qtdQuebras !=0){
        					indice ++;
        				}
        				
        				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);
        				
        				Collection retornoConsultaPart2 = null;
        				
        				for (int i = 0; i < indice; i++) {

    						System.out.println("## TAMANHO PARTIÇÃO DE INDICE  " + indice +" = " + particoes.get(i).size());
    						
    						retornoConsultaPart2 = session.createSQLQuery(consulta2).addScalar("qtdeRegistros",
    				                Hibernate.INTEGER).addScalar("banco", Hibernate.STRING)
    				                .addScalar("dataGeracao", Hibernate.DATE)
    				                .addScalar("nsa", Hibernate.INTEGER)
    				                .addScalar("valor", Hibernate.LONG)
    				                .addScalar("tarifa", Hibernate.BIG_DECIMAL)
    				                .addScalar("formaArrecadacao", Hibernate.STRING).setParameterList(
    				                           "idsArrecadadorMovimento",
    				                           particoes.get(i)).list();
    						
    						retornoConsulta2.addAll(retornoConsultaPart2);
        				}					
        			}else{
        				retornoConsulta2 = session.createSQLQuery(consulta2).addScalar("qtdeRegistros",
        		                Hibernate.INTEGER).addScalar("banco", Hibernate.STRING)
        		                .addScalar("dataGeracao", Hibernate.DATE)
        		                .addScalar("nsa", Hibernate.INTEGER)
        		                .addScalar("valor", Hibernate.LONG)
        		                .addScalar("tarifa", Hibernate.BIG_DECIMAL)
        		                .addScalar("formaArrecadacao", Hibernate.STRING).setParameterList(
        		                           "idsArrecadadorMovimento",
        		                           idsArrecadadorMovimento).list();  
        			}
                   
                  
                  
                  
                         
           retornoTotal.addAll(retornoConsulta2);
          
            consulta3 = " select count(armv_nmbanco) as qtdeRegistros, armv_nmbanco as banco, "//0,1
                  + " armv_dtgeracao as dataGeracao, armv_nnnsa as nsa,"//2,3
                 + " sum(to_number(substr(amit_cnregistro,53,15), '000000000000000')) as valor,"//4
                 + " actf.actf_vltarifa as tarifa, arfm.arfm_dsarrecadacaoforma as formaArrecadacao"//5,6
                 + " from arrecadacao.arrecadador_mov_item amit,"
                 + " arrecadacao.arrecadador_movimento armv, arrecadacao.arrecadador arrc, arrecadacao.arrecadador_contrato arct,"
                 + " arrecadacao.arrecadador_contrato_tar actf, arrecadacao.arrecadacao_forma arfm"
                 + " where amit.armv_id = armv.armv_id and"
                 + " armv.armv_cdbanco = arrc.arrc_cdagente and"
                 + " arct.arrc_id = arrc.arrc_id and "
                 + " arfm.arfm_cdarrecadacaoforma = 'Z' and"
                 + " (actf.arfm_id = arfm.arfm_id and actf.arct_id = arct.arct_id) and"
                 + " rgcd_id = 6 and armv.armv_id in(:idsArrecadadorMovimento)"
                 + " and amit_dsocorrencia = 'OK' " ;
                 if(codigoFormaArrecadacao != null){
                     consulta3 = consulta3 + " and arfm.arfm_id="+codigoFormaArrecadacao;        
                 }
                  consulta3 = consulta3 + " group by armv_nmbanco, armv_dtgeracao, armv_nnnsa, "
                 + " actf.actf_vltarifa, actf.actf_vltarifa, arfm.arfm_dsarrecadacaoforma ";
                  
                  if(idsArrecadadorMovimento.size()>999){
      				
      				System.out.println("## TAMANHO TOTAL = " + idsArrecadadorMovimento.size());
      				
      				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsArrecadadorMovimento, 999);
      				
      				int qtdQuebras = 999;
      				int indice = idsArrecadadorMovimento.size() / qtdQuebras;                                   
      				if (idsArrecadadorMovimento.size() % qtdQuebras !=0){
      					indice ++;
      				}
      				
      				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);
      				
      				Collection retornoConsultaPart3 = null;
      				
      				for (int i = 0; i < indice; i++) {

  						System.out.println("## TAMANHO PARTIÇÃO DE INDICE  " + indice +" = " + particoes.get(i).size());
  						retornoConsultaPart3  = session.createSQLQuery(consulta3).addScalar("qtdeRegistros",
  				                Hibernate.INTEGER).addScalar("banco", Hibernate.STRING)
  				                .addScalar("dataGeracao", Hibernate.DATE)
  				                .addScalar("nsa", Hibernate.INTEGER)
  				                .addScalar("valor", Hibernate.LONG)
  				                .addScalar("tarifa", Hibernate.BIG_DECIMAL)
  				                .addScalar("formaArrecadacao", Hibernate.STRING).setParameterList(
  				                           "idsArrecadadorMovimento",
  				                         particoes.get(i)).list();
  						
  						retornoConsulta3.addAll(retornoConsultaPart3);
      				}					
      			}else{
      				retornoConsulta3 = session.createSQLQuery(consulta3).addScalar("qtdeRegistros",
      		                Hibernate.INTEGER).addScalar("banco", Hibernate.STRING)
      		                .addScalar("dataGeracao", Hibernate.DATE)
      		                .addScalar("nsa", Hibernate.INTEGER)
      		                .addScalar("valor", Hibernate.LONG)
      		                .addScalar("tarifa", Hibernate.BIG_DECIMAL)
      		                .addScalar("formaArrecadacao", Hibernate.STRING).setParameterList(
      		                           "idsArrecadadorMovimento",
      		                           idsArrecadadorMovimento).list();  
      			}
                 
            
            
            
           retornoTotal.addAll(retornoConsulta3);       
          
            consulta4 = " select count(armv_nmbanco) as qtdeRegistros, armv_nmbanco as banco, "//0,1
                  + " armv_dtgeracao as dataGeracao, armv_nnnsa as nsa,"//2,3
                 + " sum(to_number(substr(amit_cnregistro,79,15), '000000000000000')) as valor,"//4
                 + " actf.actf_vltarifa as tarifa, arfm.arfm_dsarrecadacaoforma as formaArrecadacao"//5,6
                 + " from arrecadacao.arrecadador_mov_item amit,"
                 + " arrecadacao.arrecadador_movimento armv, arrecadacao.arrecadador arrc, arrecadacao.arrecadador_contrato arct,"
                 + " arrecadacao.arrecadador_contrato_tar actf, arrecadacao.arrecadacao_forma arfm"
                 + " where amit.armv_id = armv.armv_id and"
                 + " armv.armv_cdbanco = arrc.arrc_cdagente and"
                 + " arct.arrc_id = arrc.arrc_id and "
                 + " arfm.arfm_cdarrecadacaoforma = 'W' and"
                 + " (actf.arfm_id = arfm.arfm_id and actf.arct_id = arct.arct_id) and"
                 + " rgcd_id = 15 and armv.armv_id in(:idsArrecadadorMovimento) " ;
                 if(codigoFormaArrecadacao != null){
                     consulta4 = consulta4 + " and arfm.arfm_id="+codigoFormaArrecadacao;        
                 }
                  consulta4 = consulta4 + " group by armv_nmbanco, armv_dtgeracao, armv_nnnsa, "
                 + " actf.actf_vltarifa, actf.actf_vltarifa, arfm.arfm_dsarrecadacaoforma ";
                  
                  
      			if(idsArrecadadorMovimento.size()>999){
    				
    				System.out.println("## TAMANHO TOTAL = " + idsArrecadadorMovimento.size());
    				
    				List<List<Integer>> particoes = CollectionUtil.particao((List<Integer>) idsArrecadadorMovimento, 999);
    				
    				int qtdQuebras = 999;
    				int indice = idsArrecadadorMovimento.size() / qtdQuebras;                                   
    				if (idsArrecadadorMovimento.size() % qtdQuebras !=0){
    					indice ++;
    				}
    				
    				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);
    				
    				Collection retornoConsultaPart4 = null;
    				
    				for (int i = 0; i < indice; i++) {

						System.out.println("## TAMANHO PARTIÇÃO DE INDICE  " + indice +" = " + particoes.get(i).size());
						retornoConsultaPart4 = session.createSQLQuery(consulta4).addScalar("qtdeRegistros",
				                Hibernate.INTEGER).addScalar("banco", Hibernate.STRING)
				                .addScalar("dataGeracao", Hibernate.DATE)
				                .addScalar("nsa", Hibernate.INTEGER)
				                .addScalar("valor", Hibernate.LONG)
				                .addScalar("tarifa", Hibernate.BIG_DECIMAL)
				                .addScalar("formaArrecadacao", Hibernate.STRING).setParameterList(
				                           "idsArrecadadorMovimento",
				                           particoes.get(i)).list();
						retornoConsulta4.addAll(retornoConsultaPart4);
    				}					
    			}else{
    				retornoConsulta4 = session.createSQLQuery(consulta4).addScalar("qtdeRegistros",
    		                Hibernate.INTEGER).addScalar("banco", Hibernate.STRING)
    		                .addScalar("dataGeracao", Hibernate.DATE)
    		                .addScalar("nsa", Hibernate.INTEGER)
    		                .addScalar("valor", Hibernate.LONG)
    		                .addScalar("tarifa", Hibernate.BIG_DECIMAL)
    		                .addScalar("formaArrecadacao", Hibernate.STRING).setParameterList(
    		                           "idsArrecadadorMovimento",
    		                           idsArrecadadorMovimento).list();  
    			}
                
                       
           retornoTotal.addAll(retornoConsulta4);       
          
           if (retornoTotal.size() > 0) {
               MovimentoArrecadadoresPorNSAHelper helper = null;
               for (Iterator iter = retornoTotal.iterator(); iter.hasNext();) {
                   Object[] element = (Object[]) iter.next();
                   helper = new MovimentoArrecadadoresPorNSAHelper();
                   helper.setQtdeRegistros((Integer) element[0]);
                   if (element[1] != null && !element[1].equals("")) {
                       helper.setBanco((String) element[1]);
                   }
                   helper.setDataGeracao((Date) element[2]);
                   helper.setNsa((Integer) element[3]);
                   helper.setValor((Long)element[4]);
                    helper.setTarifa((BigDecimal) element[5]);
                    helper.setFormaArrecadacao((String) element[6]);
                    retorno.add(helper);
               }
           }

       } catch (HibernateException e) {
           throw new ErroRepositorioException(e, "Erro no Hibernate");
       } finally {
           HibernateUtil.closeSession(session);
       }

       return retorno;
   }
	
	
	/**
	 * Processamento Rápido
	 * 
	 * @author Raphael Rossiter
	 * @date 17/08/2007
	 * 
	 * @return Collection<Conta>
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContaComPagamentoHistorico()
			throws ErroRepositorioException {

		Collection<Conta> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = 	"SELECT b FROM Conta b " 
					 +	"WHERE b.id IN(13527, 2861, 2079563, 2079188, 2077402, 1882161, " 
					 +  " 2077450, 2608045, 2545376, 53582, 53581, 53584, 53583, 53586, 53585, 53580, "
					 +  " 53579, 2606143) ";

			retorno = (Collection<Conta>) session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	
	/**
	 * [UC0626] Gerar Resumo de Metas Acumulado no Mês (CAERN)
	 * 
	 * @author Sávio Luiz
	 * @data 28/11/2007
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarPagamentoDeContas(Collection idsColecaoConta)
			throws ErroRepositorioException {

		Collection retorno = null;
		
		

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id " + "FROM Pagamento as pgmt "
			        + "INNER JOIN pgmt.contaGeral cntaGeral "
			        + "INNER JOIN cntaGeral.conta cnta "
					+ "WHERE cnta.id in (:colecaoIdsContas) and cnta.dataVencimentoConta <  :dataAtual";

			retorno = session.createQuery(consulta)
					 .setParameterList("colecaoIdsContas", idsColecaoConta)
					 .setTimestamp("dataAtual", new Date())
					 .list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0739] Informar Situação de Expurgo do Pagamento
	 * 
	 * @author Sávio Luiz
	 * @data 02/01/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarDadosPagamentoExpurgado(String dataPagamento,Integer idCliente,Integer anoMesArrecadacao)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		

		try {
			consulta = "SELECT pgto.id,pgto.valorPagamento,pgto.indicadorExpurgado "
					+ "FROM Pagamento pgto "
					+ "WHERE pgto.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao and to_char( pgto.dataPagamento, 'dd/mm/yyyy' ) = :dataPagamento AND pgto.imovel.id in "
					+ "(SELECT clieImov.imovel.id FROM ClienteImovel clieImov "
					+ "	WHERE clieImov.clienteRelacaoTipo.id = :clienteResponsavel AND clieImov.cliente.id = :idCliente)";

			retorno = session.createQuery(consulta).setString("dataPagamento",
					dataPagamento).setInteger("clienteResponsavel",
					ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("idCliente",idCliente).
					setInteger("anoMesReferenciaArrecadacao",anoMesArrecadacao)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC0739] Informar Situação de Expurgo do Pagamento
	 * 
	 * @author Sávio Luiz
	 * @data 02/01/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarDadosPagamentoHistoricoExpurgado(String dataPagamento,Integer idCliente,Integer anoMesArrecadacao)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT pgto.id,pgto.valorPagamento,pgto.indicadorExpurgado "
					+ "FROM PagamentoHistorico pgto "
					+ "WHERE pgto.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao and to_char( pgto.dataPagamento, 'dd/mm/yyyy' ) = :dataPagamento AND pgto.imovel.id in "
					+ "(SELECT clieImov.imovel.id FROM ClienteImovel clieImov "
					+ "	WHERE clieImov.clienteRelacaoTipo.id = :clienteResponsavel AND clieImov.cliente.id = :idCliente)";

			retorno = session.createQuery(consulta).setString("dataPagamento",
					dataPagamento).setInteger("clienteResponsavel",
					ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("idCliente",idCliente)
					.setInteger("anoMesReferenciaArrecadacao",anoMesArrecadacao)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	
	/**
	 * [UC0739] Informar Situação de Expurgadodo Pagamento
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 04/01/2008
	 * 
	 * @param idsPagamentos
	 * @return void
	 */
	public void atualizarSituacaoExpurgado(Collection colecaoPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			if (colecaoPagamento != null && !colecaoPagamento.isEmpty()) {
				Iterator ite = colecaoPagamento.iterator();
				while (ite.hasNext()) {
					Pagamento pagamento = (Pagamento) ite.next();
					
					String atualizarSituacaoPagamento = null;
					
					short inidcadorPagamento = pagamento.getIndicadorPagamento();

					if (inidcadorPagamento == Pagamento.INDICADOR_PAGAMENTO_SIM) {
						atualizarSituacaoPagamento = "UPDATE Pagamento "
								+ "SET pgmt_icexpurgado = :indicadorExpurgado, pgmt_tmultimaalteracao = :dataAlteracao "
								+ "WHERE pgmt_id = :idPagamento";

						session.createQuery(atualizarSituacaoPagamento)
								.setShort("indicadorExpurgado",
										pagamento.getIndicadorExpurgado())
								.setTimestamp("dataAlteracao", new Date())
								.setInteger("idPagamento", pagamento.getId())
								.executeUpdate();
					} else {
						atualizarSituacaoPagamento = "UPDATE PagamentoHistorico "
								+ "SET pghi_icexpurgado = :indicadorExpurgado, pghi_tmultimaalteracao = :dataAlteracao "
								+ "WHERE pghi_id = :idPagamento";

						session.createQuery(atualizarSituacaoPagamento)
								.setShort("indicadorExpurgado",
										pagamento.getIndicadorExpurgado())
								.setTimestamp("dataAlteracao", new Date())
								.setInteger("idPagamento", pagamento.getId())
								.executeUpdate();
					}
				}
			}

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	
	
	
	/**
	 * Pesquisa a ContaHistorico para o imóvel no ano/mês de referência informados
	 *
	 * [UC0300] Classificar Pagamentos e Devoluções
	 *
	 * @author Pedro Alexandre
	 * @date 15/01/2008
	 *
	 * @param imovel
	 * @param anoMesReferenciaPagamento
	 * @param anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] selecionarContaHistoricoPorImovelAnoMesReferencia(Imovel imovel,Integer anoMesReferenciaPagamento, Integer anoMesFaturamento) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select cnhi.id, " 
					+ "cnhi.valorAgua, " 
					+ "cnhi.valorEsgoto, " 
					+ "cnhi.valorDebitos, " 
					+ "cnhi.valorCreditos, " 
					+ "cnhi.valorImposto, "
					+ "cnhi.anoMesReferenciaContabil, "
					/**
					 * Classificar detalhadamente documentos inexistentes por débito prescrito,
					 * conta parcelada, conta cancelada ou erro de processamento
					 * @author Wellington Rocha
					 * @date 02/08/2012*/
					+ "dcst.id "
					+ "from ContaHistorico cnhi "
					+ "inner join cnhi.imovel as imov "
					+ "inner join cnhi.debitoCreditoSituacaoAtual as dcst "
					+ "where imov.id = :imovelPagamento " 
					+ "and cnhi.anoMesReferenciaConta = :anoMesReferenciaPagamento "
					+ "and dcst.id in(:normal, :retificada, :incluida) ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("imovelPagamento", imovel.getId())
					.setInteger("anoMesReferenciaPagamento", anoMesReferenciaPagamento)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.setMaxResults(1).uniqueResult();
			

			/**
			 * Classificar detalhadamente documentos inexistentes por débito prescrito,
			 * conta parcelada, conta cancelada ou erro de processamento
			 * @author Wellington Rocha
			 * @date 02/08/2012*/
			if(retorno == null){
				
				consulta = "select cnhi.id, " 
					+ "cnhi.valorAgua, " 
					+ "cnhi.valorEsgoto, " 
					+ "cnhi.valorDebitos, " 
					+ "cnhi.valorCreditos, " 
					+ "cnhi.valorImposto, "
					+ "cnhi.anoMesReferenciaContabil, "
					+ "dcst.id "
					+ "from ContaHistorico as cnhi "
					+ "inner join cnhi.imovel as imov "
					+ "inner join cnhi.debitoCreditoSituacaoAtual as dcst "
					+ "where imov.id = :imovelPagamento " 
					+ "and cnhi.anoMesReferenciaConta = :anoMesReferenciaPagamento "
					+ "and dcst.id in(:prescritas, :prescritasIncluidas, :canceladas, :parceladas, :erroProcessamento) ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("imovelPagamento", imovel.getId())
					.setInteger("anoMesReferenciaPagamento", anoMesReferenciaPagamento)
					.setInteger("prescritas", DebitoCreditoSituacao.DEBITO_PRESCRITO)
					.setInteger("prescritasIncluidas", DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS)
					.setInteger("canceladas", DebitoCreditoSituacao.CANCELADA)
					.setInteger("parceladas", DebitoCreditoSituacao.PARCELADA)
					.setInteger("erroProcessamento", DebitoCreditoSituacao.ERRO_PROCESSAMENTO)
					.setMaxResults(1).uniqueResult();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	
	/**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Sávio Luiz
	 * @data 10/01/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarDadosComparativosFaturamentoArrecadacaoExpurgo(Integer anoMesReferencia,
			String idGerenciaRegional,String idUnidadeNegocio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		
		String condicaoWhere = "";
		if(idGerenciaRegional != null && !idGerenciaRegional.equals("")){
			condicaoWhere += " where  geRe.greg_id = "+ new Integer(idGerenciaRegional);
		}
		if(idUnidadeNegocio != null && !idUnidadeNegocio.equals("")){
			condicaoWhere += " where unNeg.uneg_id = "+ new Integer(idUnidadeNegocio);
		}
		
			
		try {
			consulta = "select "
					  +"   greg_nmabreviado as regional,"//0
					  +"   uneg_nmabreviado as unidadeNegocio,"//1
					  +"   centroTemp as codigoCentroCusto,"//2
					  +"   nomeLocTemp as nomeLocalidade,"//3
					  +"   gerTemp as gerencia,"//4
					  +"   uniTemp as idUnidadeNegocio,"//5
					  +"   locTemp as idLocalidade,"//6
					  +"   sum( case when tipo = 1 then valor else 0 end ) as valorItemFaturado,"//7
					  +"   sum( case when tipo = 2 then valor else 0 end ) as valorItemArrecadacao, "//8
					  +"   sum( case when tipo = 3 then valor else 0 end ) as valorItemFaturadoLiquido, "//9
					  +"   sum( case when tipo = 4 then valor else 0 end ) as valorItemFaturadoBruto, "//10
					  +"   sum( case when tipo = 5 then valor else 0 end ) as valorItemCancelados "//11
					  +"from "
					  +" (select"
					  +"     1 as tipo,"
					  +"     resFat.greg_id as gerTemp,"
					  +"     resFat.uneg_id as uniTemp,"
					  +"     resFat.loca_id as locTemp,"
					  +"     loc.loca_cdcentrocusto as centroTemp,"
					  +"     loc.loca_nmlocalidade as nomeLocTemp,"
					  +"     sum(resFat.rfat_vlitemfaturamento) as valor "
					  +"  from"
					  +"     financeiro.resumo_faturamento resFat"
					  +"  inner join cadastro.localidade loc on loc.loca_id = resFat.loca_id"
					  +"  where"
					  +"     resFat.rfat_amreferencia = :anoMesReferencia and" 
					  +"     resFat.lctp_id = :idTotalCobradoConta"
					  +"  group by"
					  +"     resFat.greg_id,"
					  +"     resFat.uneg_id,"
					  +"     loc.loca_cdcentrocusto,"
					  +"     resFat.loca_id,"
					  +"     loc.loca_nmlocalidade"
					  +"  union"
					  +"  select" 
					  +"     2 as tipo,"
					  +"     resArrec.greg_id as gerTemp,"
					  +"     resArrec.uneg_id as uniTemp,"
					  +"     resArrec.loca_id as locTemp,"
					  +"     loc.loca_cdcentrocusto as centroTemp,"
					  +"     loc.loca_nmlocalidade as nomeLocTemp,"
					  +"     sum(resArrec.rarr_vlitemarrecadacao) as valor "
					  +"  from "
					  +"     arrecadacao.resumo_arrecadacao resArrec"
					  +"  inner join cadastro.localidade loc on loc.loca_id = resArrec.loca_id"                         
					  +"  where "
					  +"     resArrec.rarr_amreferencia = :anoMesReferencia and" 
					  +"     resArrec.lctp_id = :idTotalRecebimentos"
					  +"     group by"
					  +"     resArrec.greg_id,"
					  +"     resArrec.uneg_id,"
					  +"     loc.loca_cdcentrocusto,"
					  +"     resArrec.loca_id,"
					  +"     loc.loca_nmlocalidade"
					  +"  union"
					  +" select"
					  +"     3 as tipo,"
					  +"     resFat.greg_id as gerTemp,"
					  +"     resFat.uneg_id as uniTemp,"
					  +"     resFat.loca_id as locTemp,"
					  +"     loc.loca_cdcentrocusto as centroTemp,"
					  +"     loc.loca_nmlocalidade as nomeLocTemp,"
					  +"     sum(resFat.rfat_vlitemfaturamento) as valor "
					  +"  from"
					  +"     financeiro.resumo_faturamento resFat"
					  +"  inner join cadastro.localidade loc on loc.loca_id = resFat.loca_id"
					  +"  where"
					  +"     resFat.rfat_amreferencia = :anoMesReferencia and" 
					  +"     resFat.lctp_id = :receitaLiquida and"
					  +"	 (resFat.lcit_id = :itemReceitaLiquida or resFat.lcit_id = :itemTotal)"
					  +"  group by"
					  +"     resfat.greg_id,"
					  +"     resfat.uneg_id,"
					  +"     loc.loca_cdcentrocusto,"
					  +"     resfat.loca_id,"
					  +"     loc.loca_nmlocalidade"
					  +"  union"
					  +" select"
					  +"     4 as tipo,"
					  +"     resFat.greg_id as gerTemp,"
					  +"     resFat.uneg_id as uniTemp,"
					  +"     resFat.loca_id as locTemp,"
					  +"     loc.loca_cdcentrocusto as centroTemp,"
					  +"     loc.loca_nmlocalidade as nomeLocTemp,"
					  +"     sum(resFat.rfat_vlitemfaturamento) as valor "
					  +"  from"
					  +"     financeiro.resumo_faturamento resFat"
					  +"  inner join cadastro.localidade loc on loc.loca_id = resFat.loca_id"
					  +"  where"
					  +"     resFat.rfat_amreferencia = :anoMesReferencia and" 
					  +"     resFat.lctp_id = :receitaBruta"
					  +"  group by"
					  +"     resfat.greg_id,"
					  +"     resfat.uneg_id,"
					  +"     loc.loca_cdcentrocusto,"
					  +"     resfat.loca_id,"
					  +"     loc.loca_nmlocalidade"
					  +"  union"
					  +" select"
					  +"     5 as tipo,"
					  +"     resFat.greg_id as gerTemp,"
					  +"     resFat.uneg_id as uniTemp,"
					  +"     resFat.loca_id as locTemp,"
					  +"     loc.loca_cdcentrocusto as centroTemp,"
					  +"     loc.loca_nmlocalidade as nomeLocTemp,"
					  +"     sum(resFat.rfat_vlitemfaturamento) as valor "
					  +"  from"
					  +"     financeiro.resumo_faturamento resFat"
					  +"  inner join cadastro.localidade loc on loc.loca_id = resFat.loca_id"
					  +"  where"
					  +"     resFat.rfat_amreferencia = :anoMesReferencia and" 
					  +"     resFat.lctp_id = :receitasCanceladas"
					  +"  group by"
					  +"     resfat.greg_id,"
					  +"     resfat.uneg_id,"
					  +"     loc.loca_cdcentrocusto,"
					  +"     resfat.loca_id,"
					  +"     loc.loca_nmlocalidade"
					  +" ) temp "
					  +"inner join cadastro.gerencia_regional geRe on (gerTemp = geRe.greg_id) " 
					  +"inner join cadastro.unidade_negocio unNeg on (uniTemp = unNeg.uneg_id) ";
			consulta += condicaoWhere;
			consulta +=" group by "
					  +"  greg_nmabreviado,"
					  +"  unidadeNegocio,"
					  +"  codigoCentroCusto,"
					  +"  nomeLocalidade,"
					  +"  gerencia,"
					  +"  idUnidadeNegocio,"
					  +"  idLocalidade "
					  +"order by"
					  +"  gerencia,"
					  +"  idUnidadeNegocio,"
					  +"  codigoCentroCusto";
					 
		retorno = session.createSQLQuery(consulta)
			        .addScalar("regional", Hibernate.STRING)
			        .addScalar("unidadeNegocio",Hibernate.STRING)
			        .addScalar("codigoCentroCusto",Hibernate.STRING)
			        .addScalar("nomeLocalidade",Hibernate.STRING)
			        .addScalar("gerencia",Hibernate.INTEGER)
			        .addScalar("idUnidadeNegocio",Hibernate.INTEGER)
			        .addScalar("idLocalidade",Hibernate.INTEGER)
			        .addScalar("valorItemFaturado",Hibernate.BIG_DECIMAL)
			        .addScalar("valorItemArrecadacao",Hibernate.BIG_DECIMAL)
			        .addScalar("valorItemFaturadoLiquido",Hibernate.BIG_DECIMAL)
			        .addScalar("valorItemFaturadoBruto",Hibernate.BIG_DECIMAL)
			        .addScalar("valorItemCancelados",Hibernate.BIG_DECIMAL)
			        .setInteger("idTotalCobradoConta",LancamentoTipo.TOTAL_COBRADO_NAS_CONTAS)
			        .setInteger("idTotalRecebimentos",LancamentoTipo.TOTAL_DOS_RECEBIMENTOS)
			        .setInteger("receitaLiquida",LancamentoTipo.RECEITA_LIQUIDA_INT)
			        .setInteger("itemReceitaLiquida", LancamentoItem.RECEITA_LIQUIDA)
			        .setInteger("itemTotal", LancamentoItem.TOTAL)
			        .setInteger("receitaBruta",LancamentoTipo.RECEITA_BRUTA_INT)
			        .setInteger("receitasCanceladas",LancamentoTipo.TOTAL_RECEITA_CANCELADA)        
			        .setInteger("anoMesReferencia",anoMesReferencia)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * 
	 * [UC0324] - Filtrar Guia de Devolucao
	 * 
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * 
	 *  
	 * @author Roberto Barbalho
	 * @date
	 * 
	 * @param guiaDevolucaoId
	 * @return GuiaDevolucao
	 * @throws ErroRepositorioException
	 */
	public GuiaDevolucao pesquisarGuiaDevolucao(Integer guiaDevolucaoId)
			throws ErroRepositorioException {

		GuiaDevolucao retorno = null;

		Session session = HibernateUtil.getSession();

    	try {
    		
    		   String hql = " from "
    				      + "   GuiaDevolucao as guia  "
    				      + "   left join fetch guia.documentoTipo "
    				      + " where "
    				      + "  guia.id = :id ";    		

			retorno = (GuiaDevolucao) session.createQuery(hql).setInteger("id",guiaDevolucaoId).list().iterator().next();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}	
    
    /**
     * [UC0242] Registrar Movimento dos Arrecadadores
     * 
     * Atualiza o valor total do movimento (armv_vltotalmovimento) (tabela
     * ARRECADADOR_MOVIMENTO)
     * 
     * @author Vivianne Sousa
     * @date 31/01/2008
     * 
     * @param idArrecadadorMovimento
     * @param valorTotalMovimento
     * @return void
     */
    public void atualizarValorMovimentoArrecadadorMovimento(
            Integer idArrecadadorMovimento, BigDecimal valorTotalMovimento) throws ErroRepositorioException {

        Session session = HibernateUtil.getSession();

        String atualizarArrecadadorMovimento;

        try {

            

            atualizarArrecadadorMovimento = "UPDATE ArrecadadorMovimento "
                    + "SET armv_vltotalmovimento = :valorTotalMovimento, armv_tmultimaalteracao = :dataAlteracao "
                    + "WHERE armv_id = :idArrecadadorMovimento";

            session.createQuery(atualizarArrecadadorMovimento)
                    .setInteger("idArrecadadorMovimento", idArrecadadorMovimento)
                    .setBigDecimal("valorTotalMovimento",valorTotalMovimento)
                    .setTimestamp("dataAlteracao", new Date()).executeUpdate();

        } catch (HibernateException e) {

            throw new ErroRepositorioException(e, "Erro no Hibernate");

        } finally {
            HibernateUtil.closeSession(session);
        }
    }

    /**
     * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela Bônus
     * 
     * @author Vivianne Sousa
     * @data 01/02/2008
     * 
     * @param idConta
     * @return dataPagamento
     */
    public Date pesquisarDataPagamentoDeConta(Integer idConta)
            throws ErroRepositorioException {

        Date retorno = null;

        Session session = HibernateUtil.getSession();
        String consulta = null;

        try {
            consulta = "SELECT dataPagamento " + "FROM Pagamento pgmt "
                    + "WHERE pgmt.contaGeral.id = :idConta ";

            retorno = (Date) session.createQuery(consulta).setInteger(
                    "idConta", idConta).setMaxResults(1).uniqueResult();

        } catch (HibernateException e) {
            throw new ErroRepositorioException(e, "Erro no Hibernate");
        } finally {
            HibernateUtil.closeSession(session);
        }

        return retorno;
    }
    
	/**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Sávio Luiz
	 * @data 17/02/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarPagamentoExpurgado(Integer anoMesReferencia,
			String idGerenciaRegional,String idUnidadeNegocio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		
			
		try {
			consulta = "SELECT loc.loca_id as idLocalidade,"//0
				     +" sum(pag.pgmt_vlpagamento) as valorPagamento "//1  
                     +" FROM arrecadacao.pagamento pag,cadastro.localidade loc"
                     +" inner join cadastro.gerencia_regional geRe on (loc.greg_id = geRe.greg_id)"
                     +" inner join cadastro.unidade_negocio unNeg on (loc.uneg_id = unNeg.uneg_id)"
                     +" where loc.loca_id = pag.loca_id and pag.pgmt_amreferenciaarrecadacao = :anoMesReferencia and"
                     +" pag.pgmt_icexpurgado = :icExpurgadoPagamento" ;
		 if(idGerenciaRegional != null && !idGerenciaRegional.equals("")){
	      consulta += " and geRe.greg_id = "+ new Integer(idGerenciaRegional);
		 }
		 if(idUnidadeNegocio != null && !idUnidadeNegocio.equals("")){
		  consulta += " and unNeg.uneg_id = "+ new Integer(idUnidadeNegocio);
		 }
		  
		 consulta += " group by loc.loca_id"
                     +" order by 1";

		retorno = session.createSQLQuery(consulta)
			        .addScalar("idLocalidade",Hibernate.INTEGER)
			        .addScalar("valorPagamento",Hibernate.BIG_DECIMAL)
			        .setInteger("icExpurgadoPagamento",Pagamento.INDICADOR_EXPURGADO_SIM)
			        .setInteger("anoMesReferencia",anoMesReferencia)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Sávio Luiz
	 * @data 17/02/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarPagamentoHistoricoExpurgado(Integer anoMesReferencia,
			String idGerenciaRegional,String idUnidadeNegocio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		
			
		try {
			consulta = "SELECT loc.loca_id as idLocalidade,"//0
				     +" sum(pagHistorico.pghi_vlpagamento) as valorPagamentoHistorico "//1  
                     +" FROM arrecadacao.pagamento_historico pagHistorico,cadastro.localidade loc"
                     +" inner join cadastro.gerencia_regional geRe on (loc.greg_id = geRe.greg_id)"
                     +" inner join cadastro.unidade_negocio unNeg on (loc.uneg_id = unNeg.uneg_id)"
                     +" where loc.loca_id = pagHistorico.loca_id and pagHistorico.pghi_amreferenciaarrecadacao = :anoMesReferencia and"
                     +" pagHistorico.pghi_icexpurgado = :icExpurgadoPagamentoHistorico" ;
		 if(idGerenciaRegional != null && !idGerenciaRegional.equals("")){
	      consulta += " and geRe.greg_id = "+ new Integer(idGerenciaRegional);
		 }
		 if(idUnidadeNegocio != null && !idUnidadeNegocio.equals("")){
		  consulta += " and unNeg.uneg_id = "+ new Integer(idUnidadeNegocio);
		 }
		  
		 consulta += " group by loc.loca_id"
                     +" order by 1";

		retorno = session.createSQLQuery(consulta)
			        .addScalar("idLocalidade",Hibernate.INTEGER)
			        .addScalar("valorPagamentoHistorico",Hibernate.BIG_DECIMAL)
			        .setInteger("icExpurgadoPagamentoHistorico",PagamentoHistorico.INDICADOR_EXPURGADO_SIM)
			        .setInteger("anoMesReferencia",anoMesReferencia)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Object[] acumularValorAguaEsgotoPagamentosClassificadosConta(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			// Cria o hql de pesquisa
			consulta = "select " +
					  "sum(ctcg.ctcg_vlagua) as col_0, " +
					  "sum(ctcg.ctcg_vlesgoto) as col_1 " +
					  "from " +
					  "faturamento.conta_categoria ctcg " + 
					  "where " +
					  "ctcg.catg_id= :idCategoria  " +
					  "and (ctcg.cnta_id in (" +
										  "select " +
										  "distinct pgmt.cnta_id " + 
										  "from " +
										  "arrecadacao.pagamento pgmt " + 
										  "where " +
										  "pgmt.pgmt_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
										  "and pgmt.loca_id= :idLocalidade  " +
										  "and (pgmt.pgst_idatual= :idPagamentoClassificado or ( " +
										  	"pgmt.pgst_idatual= :idPagamentoValorABaixar and pgmt.pgst_idanterior = :idPagamentoValorNaoConfere) ) " + 
										  "and (pgmt.cnta_id is not null) "	+		
					  ")) " ; 

			retorno = (Object[]) session.createSQLQuery(consulta)
			    .addScalar("col_0",Hibernate.BIG_DECIMAL)
			    .addScalar("col_1",Hibernate.BIG_DECIMAL)
				.setInteger("idCategoria", idCategoria)
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
				.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR)
				.setInteger("idPagamentoValorNaoConfere", PagamentoSituacao.VALOR_NAO_CONFERE)
				.setMaxResults(1)
				.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3500
	 * 
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Acumula o valor de água por localidade e categoria para os pagamentos de
	 * contas efetuados em meses anteriores classificados no mês.
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 23/05/2006, 23/05/2008
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] acumularValorAguaEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(ctcg.ctcg_vlagua) as col_0,  " +
					  "sum(ctcg.ctcg_vlesgoto) as col_1  " +
					  "from " +
					   "faturamento.conta_categoria ctcg " + 
					  "where " +
					   "ctcg.catg_id= :idCategoria  " +
					   "and (ctcg.cnta_id in (" +
										   "select " +
										   "distinct pgmt.cnta_id " + 
										   "from " +
										   "arrecadacao.pagamento pgmt " + 
										   "where " +
										   "pgmt.pgmt_amreferenciaarrecadacao > 201212 and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao " + 
										   "and pgmt.loca_id= :idLocalidade  " +
										   "and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										   "and (pgmt.cnta_id is not null) "	+		
					   ") ) " ;
			
			retorno = (Object[]) session.createSQLQuery(consulta)
			 		.addScalar("col_0",Hibernate.BIG_DECIMAL)
			 		.addScalar("col_1",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado CAEMA - GUIA DE PAGAMENTO
	 *
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 *
	 * @param imovel
	 * @param numeroGuia
	 * @param anoGuia
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Integer[] pesquisarExistenciaGuiaPagamento(Imovel imovel,
			Integer numeroGuia, Integer anoGuia) throws ErroRepositorioException {

		Integer[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select gp.id, dbtp.id from GuiaPagamento gp "
					+ "inner join gp.imovel "
					+ "inner join gp.debitoTipo dbtp "
					+ "where gp.imovel.id = :imovel and gp.numeroGuia = :numeroGuia "
					+ "and gp.anoGuia = :anoGuia  and "
					+ "gp.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (Integer[]) session.createQuery(consulta).setInteger(
					"imovel", imovel.getId()).setInteger("numeroGuia",
					numeroGuia).setInteger("anoGuia", anoGuia).setInteger("normal",
					DebitoCreditoSituacao.NORMAL).setInteger("incluida",
					DebitoCreditoSituacao.INCLUIDA).setInteger("retificada",
					DebitoCreditoSituacao.RETIFICADA).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 *
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 *
	 * @param imovel
	 * @param lotePagamento
	 * @param anoGuia
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Integer[] pesquisarExistenciaGuiaPagamentoPorLotePagamento(Imovel imovel,
			Integer lotePagamento, Integer anoGuia) throws ErroRepositorioException {

		Integer[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select gp.id, dbtp.id from GuiaPagamento gp "
					+ "inner join gp.imovel "
					+ "inner join gp.debitoTipo dbtp "
					+ "where gp.imovel.id = :imovel and gp.lotePagamento = :lotePagamento "
					+ "and gp.anoGuia = :anoGuia  and "
					+ "gp.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (Integer[]) session.createQuery(consulta).setInteger(
					"imovel", imovel.getId()).setInteger("lotePagamento",
					lotePagamento).setInteger("anoGuia", anoGuia).setInteger("normal",
					DebitoCreditoSituacao.NORMAL).setInteger("incluida",
					DebitoCreditoSituacao.INCLUIDA).setInteger("retificada",
					DebitoCreditoSituacao.RETIFICADA).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0301] Gerar Dados Diarios da Arrecadacao
	 * Consulta das tarifas dos contratos do arrecadador
	 * 
	 * @author Francisco do Nascimento
	 * @date 18/07/2008
	 * 
	 */
	public ArrecadadorContratoTarifa pesquisarArrecadadorContratoTarifa(Integer idArrecadador,
			Integer idFormaArrecadacao) throws ErroRepositorioException {

		ArrecadadorContratoTarifa retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT act "
					+ "FROM ArrecadadorContratoTarifa act "
					+ "INNER JOIN act.arrecadadorContrato ac "
					+ "INNER JOIN act.arrecadacaoForma af "
					+ "INNER JOIN ac.arrecadador arrec "
					+ "WHERE arrec.id = :idArrecadador AND "
					+ "ac.dataContratoEncerramento is null AND "
					+ "af.id = :idFormaArrecadacao";

			retorno = (ArrecadadorContratoTarifa) session.createQuery(consulta).setInteger(
					"idArrecadador", idArrecadador).setInteger(
					"idFormaArrecadacao", idFormaArrecadacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}	
	
	/**
	 * Exclui resumo arrecadação do ano/mês da arrecadação corrente
	 * por localidade
	 * 
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Vivianne Sousa
	 * @date 11/08/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 */
	public void excluirResumoArrecadacaoPorAnoMesArrecadacaoPorLocalidade(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Constroi o hql para remover os resumos da arrecadação
			// referentes ao ano/mês de arrecadação atual
			consulta = "delete ResumoArrecadacao ra " +
					" where ra.anoMesReferencia = :anoMesReferenciaArrecadacao " +
					" and ra.localidade.id = :idLocalidade";

			// Executa o hql
			session.createQuery(consulta).setInteger(
					"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0826] Gerar Relatório Análise da Arrecação
	 * 
	 * @author Victor Cisneiros
	 * @date 24/07/2008
	 */
    public List<RelatorioAnaliseArrecadacaoBean> pesquisarAnaliseArrecadacao(
    		PesquisarAnaliseArrecadacaoHelper helper) throws ErroRepositorioException {
    	
    	List<RelatorioAnaliseArrecadacaoBean> retorno = new ArrayList<RelatorioAnaliseArrecadacaoBean>();
    	Session session = HibernateUtil.getSession();
    	
    	String where = "";
    	if (helper.getIdArrecadador() != null) {
    		where += " AND a.arrc_id = :idArrecadador ";
    	}
    	if (helper.getIdFormaArrecadacao() != null) {
    		where += " AND a.arfm_id = :idFormaArrecadacao ";
    	}
    	
    	String whereGroup = "";
    	String select = "";
    	String group = "";
		
    	if (helper.getPorArrecadador() && helper.getPorFormaArrecadacao()) {
    		whereGroup = " AND d.arfm_id = a.arfm_id AND arrc.clie_id = c.clie_id ";
    		select +=
	    			", c.clie_id as id_arrecadador, " + // 5
	    			"a.arfm_id as id_arrecadacao_forma, " + // 6
	    			"a.ardd_nndiafloat as dias_float, " + // 7 
	    			"a.ardd_vltarifaunitaria as tarifa_unitaria "; // 8 
    		group += 
	    		"GROUP BY " + 
	    			"c.clie_id, a.arfm_id, a.ardd_dtpagamento, a.ardd_nndiafloat, a.ardd_vltarifaunitaria " + 
	    		"ORDER BY " + 
	    			"c.clie_id, a.arfm_id, a.ardd_dtpagamento ";
    	}
    	else if (helper.getPorArrecadador()) {
    		whereGroup = " AND arrc.clie_id = c.clie_id ";
	    	select +=  
				", c.clie_id as id_arrecadador "; // 5
	    	group += 
				"GROUP BY " + 
					"c.clie_id, a.ardd_dtpagamento " + 
				"ORDER BY " + 
					"c.clie_id, a.ardd_dtpagamento ";
    	}
    	else if (helper.getPorFormaArrecadacao()) {
    		whereGroup = " AND d.arfm_id = a.arfm_id ";
	    	select += 
				", a.arfm_id as id_arrecadacao_forma "; // 5
			group += 
		    	"GROUP BY " + 
					"a.arfm_id, a.ardd_dtpagamento " + 
				"ORDER BY " + 
					"a.arfm_id, a.ardd_dtpagamento ";
    	}
    	else {
    		group += 
				"GROUP BY " + 
					"a.ardd_dtpagamento " + 
				"ORDER BY " + 
					"a.ardd_dtpagamento ";
    	}
    	
    	String consulta =
    		"SELECT " + 
    			"a.ardd_dtpagamento as data_pagamento, " + 
    			"sum(a.ardd_qtdocumentos) as quantidade_documentos, " + 
    			"sum(a.ardd_vltarifa) as valor_tarifa,  " + 
    			"sum(a.ardd_qtpagamentos) as quantidade_pagamentos, " + 
    			"sum(a.ardd_vlpagamentos) as valor_pagamentos, " + 
    			"( " + // valor das devolucoes
    				"SELECT sum(d.dvdd_vldevolucoes) " + 
    				"FROM arrecadacao.devolucao_dados_diarios d " + 
    					" INNER JOIN arrecadacao.arrecadador arrc ON (d.arrc_id = arrc.arrc_id) " +
    				"WHERE d.dvdd_dtdevolucao = a.ardd_dtpagamento " + 
    				"AND (d.dvdd_tipodevolucao = 'C' OR d.dvdd_tipodevolucao = 'D' or d.dvdd_tipodevolucao = 'N') " + whereGroup + 
    			") as valor_devolucoes " + 
    			select +
			"FROM arrecadacao.arrec_dados_diarios a " + 
				"INNER JOIN arrecadacao.arrecadador ar ON (a.arrc_id = ar.arrc_id) " + 
				"INNER JOIN cadastro.cliente c ON (ar.clie_id = c.clie_id) " + 
				"INNER JOIN arrecadacao.arrecadacao_forma af ON (a.arfm_id = af.arfm_id) " + 
			"WHERE " + 
				"a.ardd_amreferenciaarrecadacao = :anoMesReferencia " + where + group;
    	
    	try {
    		SQLQuery q = session.createSQLQuery(consulta);
    		
    		q.addScalar("data_pagamento", Hibernate.DATE);
    		q.addScalar("quantidade_documentos", Hibernate.INTEGER);
    		q.addScalar("valor_tarifa", Hibernate.BIG_DECIMAL);
    		q.addScalar("quantidade_pagamentos", Hibernate.INTEGER);
    		q.addScalar("valor_pagamentos", Hibernate.BIG_DECIMAL);
    		q.addScalar("valor_devolucoes", Hibernate.BIG_DECIMAL);
    		
    		if (helper.getPorArrecadador() && helper.getPorFormaArrecadacao()) {
				q.addScalar("id_arrecadador", Hibernate.INTEGER);
				q.addScalar("id_arrecadacao_forma", Hibernate.INTEGER);
				q.addScalar("dias_float", Hibernate.INTEGER);
				q.addScalar("tarifa_unitaria", Hibernate.BIG_DECIMAL);
			}
			else if (helper.getPorArrecadador()) {
				q.addScalar("id_arrecadador", Hibernate.INTEGER);
			}
			else if (helper.getPorFormaArrecadacao()) {
				q.addScalar("id_arrecadacao_forma", Hibernate.INTEGER);
			}
    		
    		q.setInteger("anoMesReferencia", helper.getMesAno());
    		if (helper.getIdArrecadador() != null) {
    			q.setInteger("idArrecadador", helper.getIdArrecadador());
    		}
    		if (helper.getIdFormaArrecadacao() != null) {
    			q.setInteger("idFormaArrecadacao", helper.getIdFormaArrecadacao());
    		}
    		
    		for (Object[] linha : (List<Object[]>) q.list()) {
    			RelatorioAnaliseArrecadacaoBean bean = new RelatorioAnaliseArrecadacaoBean();
    			bean.setDataPagamento((Date) linha[0]);
    			if (linha[1] != null) bean.setQuantidadeDocumentos((Integer) linha[1]);
    			if (linha[2] != null) bean.setValorTarifa((BigDecimal) linha[2]);
    			if (linha[3] != null) bean.setQuantidadePagamentos((Integer) linha[3]);
    			if (linha[4] != null) bean.setValorArrecadadoBruto((BigDecimal) linha[4]);
    			if (linha[5] != null) bean.setValorArrecadadoDesconto((BigDecimal) linha[5]);
    			
    			if (helper.getPorArrecadador() && helper.getPorFormaArrecadacao()) {
    				bean.setIdArrecadador((Integer) linha[6]);
    				bean.setIdFormaArrecadacao((Integer) linha[7]);
    				bean.setDiasFloat((Integer) linha[8]);
    				bean.setValorTarifaUnitaria((BigDecimal) linha[9]);
    			}
    			else if (helper.getPorArrecadador()) {
    				bean.setIdArrecadador((Integer) linha[6]);
    			}
    			else if (helper.getPorFormaArrecadacao()) {
    				bean.setIdFormaArrecadacao((Integer) linha[6]);
    			}
    			retorno.add(bean);
    		}
    		
    	} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
    }
    
    /**
	 * [UC0827] Gerar Relatório Análise dos Avisos Bancarios
	 * 
	 * @author Victor Cisneiros
	 * @date 30/07/2008
	 */
    public List<RelatorioAnaliseAvisosBancariosBean> pesquisarAnaliseAvisosBancarios(
    		PesquisarAnaliseAvisosBancariosHelper helper) throws ErroRepositorioException {
    	
    	List<RelatorioAnaliseAvisosBancariosBean> retorno = new ArrayList<RelatorioAnaliseAvisosBancariosBean>();
    	Session session = HibernateUtil.getSession();
    	
    	int anoMesArrecadacaoAnterior = Util.subtraiAteSeisMesesAnoMesReferencia(helper.getMesAno(), 1);
    	
    	String where = "";
    	String where2 = "";
    	if (helper.getIdArrecadador() != null) {
    		where += " AND a.arrc_id = :idArrecadador ";
    		where2 += " AND avbc.arrc_id = :idArrecadador ";
    	}
    	if (helper.getIdFormaArrecadacao() != null) {
    		where += " AND a.arfm_id = :idFormaArrecadacao ";
    		where2 += " AND avbc.arfm_id = :idFormaArrecadacao ";
    	}
    	
    	SistemaParametro sistemaParametro = Fachada.getInstancia().pesquisarParametrosDoSistema();
    	Date dataHoraDadosDiarios = sistemaParametro.getDataHoraDadosDiariosArrecadacao();
    	
    	String whereGroup = "";
    	String select = "";
    	String select2 = "";
    	String group = "";
    	String group2 = "";
    	String order = "";
    	String diferencaAcumulada = "";
		
    	if (helper.getPorArrecadador() && helper.getPorFormaArrecadacao()) {
    		whereGroup = " AND avbc.arfm_id = a.arfm_id AND clie.clie_id = ar.clie_id ";
    		
    		diferencaAcumulada = 	    		
	    		", ( " + // 8: valor da diferença acumulada
		    		"SELECT ( " + 
		        		"sum(dfac.dfac_vldiferencaacumulada) " + 
		        	") FROM arrecadacao.diferenca_acumulada dfac " +  
			        	"INNER JOIN arrecadacao.arrecadador arrc ON (dfac.arrc_id = arrc.arrc_id) " + 
			        	"INNER JOIN cadastro.cliente clie ON (arrc.clie_id = clie.clie_id) " + 
		        	"WHERE dfac.arfm_id = a.arfm_id AND clie.clie_id = ar.clie_id AND dfac.dfac_amreferenciaarrecadacao = :anoMesArrecadacaoAnterior" + 
		        ") as diferenca_acumulada, " +
		        "( " + // 9: valor dos acertos na diferenca acumulada
	    			"SELECT ( " +
			    		"(" +
			    			"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") - ( " + 
			            	"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") " + 
			        ") FROM arrecadacao.aviso_acertos ac " + 
			            "INNER JOIN arrecadacao.aviso_bancario avbc ON (ac.avbc_id = avbc.avbc_id) " + 
				        "INNER JOIN arrecadacao.arrecadador arrc ON (avbc.arrc_id = arrc.arrc_id) " + 
				        "INNER JOIN cadastro.cliente clie ON (arrc.clie_id = clie.clie_id) " + 
			            "WHERE avbc.avbc_amreferenciaarrecadacao < :anoMesArrecadacao AND ac.avac_amreferenciaarrecadacao = :anoMesArrecadacao AND avbc.arfm_id = a.arfm_id AND clie.clie_id = ar.clie_id " +
		        ") as acertos_diferenca_acumulada, ";
    		select +=
    			diferencaAcumulada + 
			    "( " + // 10: valor dias float
			    	"SELECT ( " + 
			        	"sum(actf.actf_nndiafloat) " + 
			        ") FROM arrecadacao.arrecadador_contrato_tar actf " + 
			        	"INNER JOIN arrecadacao.arrecadador_contrato arct ON (actf.arct_id = arct.arct_id) " + 
			        	"INNER JOIN arrecadacao.arrecadador arrc ON (arct.arrc_id = arrc.arrc_id) " + 
			        	"INNER JOIN cadastro.cliente clie ON (arrc.clie_id = clie.clie_id) " + 
			        "WHERE actf.arfm_id = a.arfm_id AND clie.clie_id = ar.clie_id " + 
			    ") as dias_float, " + 
			    "( " + // 11: valor tarifa unitaria
			    	"SELECT ( " + 
			        	"sum(actf.actf_vltarifa) " + 
			        ") FROM arrecadacao.arrecadador_contrato_tar actf " + 
			        	"INNER JOIN arrecadacao.arrecadador_contrato arct ON (actf.arct_id = arct.arct_id) " + 
			        	"INNER JOIN arrecadacao.arrecadador arrc ON (arct.arrc_id = arrc.arrc_id) " + 
			        	"INNER JOIN cadastro.cliente clie ON (arrc.clie_id = clie.clie_id) " + 
			        "WHERE actf.arfm_id = a.arfm_id AND clie.clie_id = ar.clie_id " + 
			    ") as tarifa_unitaria, " + 
	    			"ar.clie_id as id_arrecadador, " +
	    			"a.arfm_id as id_arrecadacao_forma ";
			select2 += 
	    		"0,0, " + 
				"ar.clie_id, " + 
				"a.arfm_id ";
    		group +=
	    		"GROUP BY " + 
	    			"ar.clie_id, a.arfm_id, a.avbc_dtrealizada ";
    		group2 +=
	    		"GROUP BY " + 
	    			"ar.clie_id, a.arfm_id, ac.avac_dtacerto ";
    		order += " ORDER BY 14, 15, 1 ";
    	}
    	
    	
    	else if (helper.getPorArrecadador()) {
    		whereGroup = " AND clie.clie_id = ar.clie_id ";
    		diferencaAcumulada = 	    		
	    		", ( " + // 9: valor da diferença acumulada
		    		"SELECT ( " + 
		        		"sum(dfac.dfac_vldiferencaacumulada) " + 
		        	") FROM arrecadacao.diferenca_acumulada dfac " +  
			        	"INNER JOIN arrecadacao.arrecadador arrc ON (dfac.arrc_id = arrc.arrc_id) " + 
			        	"INNER JOIN cadastro.cliente clie ON (arrc.clie_id = clie.clie_id) " + 
		        	"WHERE clie.clie_id = ar.clie_id AND dfac.dfac_amreferenciaarrecadacao = :anoMesArrecadacaoAnterior" + 
		        ") as diferenca_acumulada, " +
	        	"(" + // 10: valor dos acertos na diferenca acumulada
    				"SELECT ( " +
			    		"(" +
			    			"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") - ( " + 
			            	"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") " + 
		            ") FROM arrecadacao.aviso_acertos ac " + 
		            	"INNER JOIN arrecadacao.aviso_bancario avbc ON (ac.avbc_id = avbc.avbc_id) " + 
			        	"INNER JOIN arrecadacao.arrecadador arrc ON (avbc.arrc_id = arrc.arrc_id) " + 
			        	"INNER JOIN cadastro.cliente clie ON (arrc.clie_id = clie.clie_id) " + 
		            	"WHERE avbc.avbc_amreferenciaarrecadacao < :anoMesArrecadacao AND ac.avac_amreferenciaarrecadacao = :anoMesArrecadacao AND clie.clie_id = ar.clie_id " +
	        	") as acertos_diferenca_acumulada, ";
	    	select +=  
	    		diferencaAcumulada + 
				"ar.clie_id as id_arrecadador ";
			select2 += 
				"ar.clie_id ";
	    	group += 
				"GROUP BY " + 
					"ar.clie_id, a.avbc_dtrealizada ";
    		group2 +=
	    		"GROUP BY " + 
	    			"ar.clie_id, ac.avac_dtacerto ";
    		order += " ORDER BY 12, 1 ";
    	}
    	
    	
    	else if (helper.getPorFormaArrecadacao()) {
    		whereGroup = " AND avbc.arfm_id = a.arfm_id ";
    		diferencaAcumulada = 	    		
	    		", ( " + // 9: valor da diferença acumulada
		    		"SELECT ( " + 
		        		"sum(dfac.dfac_vldiferencaacumulada) " + 
		        	") FROM arrecadacao.diferenca_acumulada dfac " +  
		        	"WHERE dfac.arfm_id = a.arfm_id AND dfac.dfac_amreferenciaarrecadacao = :anoMesArrecadacaoAnterior" + 
		        ") as diferenca_acumulada, " +
		        "(" + // 10: valor dos acertos aplicados na diferenca acumulada
	    			"SELECT ( " +
			    		"(" +
			    			"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") - ( " + 
			            	"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") " + 
			        ") FROM arrecadacao.aviso_acertos ac " + 
			            "INNER JOIN arrecadacao.aviso_bancario avbc ON (ac.avbc_id = avbc.avbc_id) " + 
			            "WHERE avbc.avbc_amreferenciaarrecadacao < :anoMesArrecadacao AND ac.avac_amreferenciaarrecadacao = :anoMesArrecadacao AND avbc.arfm_id = a.arfm_id " +
		        ") as acertos_diferenca_acumulada, ";
	    	select += 
	    		diferencaAcumulada + 
				"a.arfm_id as id_arrecadacao_forma ";
			select2 += 
				"a.arfm_id ";
			group += 
		    	"GROUP BY " + 
					"a.arfm_id, a.avbc_dtrealizada ";
    		group2 +=
	    		"GROUP BY " + 
	    			"a.arfm_id, ac.avac_dtacerto ";
    		order += " ORDER BY 12, 1 ";
    	} 
    	
    	
    	else {
    		diferencaAcumulada = 	    		
	    		", ( " + // 8: valor da diferença acumulada
		    		"SELECT ( " + 
		        		"sum(dfac.dfac_vldiferencaacumulada) " + 
		        	") FROM arrecadacao.diferenca_acumulada dfac " +   
		        	"WHERE dfac.dfac_amreferenciaarrecadacao = :anoMesArrecadacaoAnterior" + 
		        ") as diferenca_acumulada, " +
		        "( " + // 9: valor dos acertos aplicados na diferenca acumulada
	    			"SELECT ( " +
			    		"(" +
			    			"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") - ( " + 
			            	"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") " + 
			        ") FROM arrecadacao.aviso_acertos ac " + 
			            "INNER JOIN arrecadacao.aviso_bancario avbc ON (ac.avbc_id = avbc.avbc_id) " + 
			            "WHERE avbc.avbc_amreferenciaarrecadacao < :anoMesArrecadacao AND ac.avac_amreferenciaarrecadacao = :anoMesArrecadacao " +
		        ") as acertos_diferenca_acumulada "; // sem parenteses no final (ultima coluna)
	    	select += 
		    	diferencaAcumulada;
    		group += 
				"GROUP BY " + 
					"a.avbc_dtrealizada ";
    		group2 +=
	    		"GROUP BY " + 
	    			"ac.avac_dtacerto ";
    		order += " ORDER BY 1 ";
    	}
    	
    	String consulta =
    		"( SELECT " + 
    			"a.avbc_dtrealizada as data_realizada, " +  // 0: data_realizada
    			"sum(a.avbc_vlarrecadacaocalculado) as arrecadacao_calculado, " + // 1: arrecadacao_calculado
    			"sum(a.avbc_vlarrecadacaoinformado) as arrecadacao_informado,  " + // 2: arrecadacao_informado
    			"sum(a.avbc_vldevolucaocalculado) as devolucao_calculado, " + // 3: devolucao_calculado
    			"sum(a.avbc_vldevolucaoinformado) as devolucao_informado, " + // 4: devolucao_informado
    			"sum(d.avdd_vldeducao) as valor_deducao, " + // 5: deducao
    			"( " + // 6: valor dos acertos
    				"SELECT ( " +
			    		"(" +
			    			"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") - ( " + 
			            	"+ sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
			            ") " + 
			        ") FROM arrecadacao.aviso_acertos ac " + 
		            	"INNER JOIN arrecadacao.aviso_bancario avbc ON (ac.avbc_id = avbc.avbc_id) " + 
			        	"INNER JOIN arrecadacao.arrecadador arrc ON (avbc.arrc_id = arrc.arrc_id) " + 
			        	"INNER JOIN cadastro.cliente clie ON (arrc.clie_id = clie.clie_id) " + 
    				"WHERE avac_dtacerto = a.avbc_dtrealizada " + whereGroup + " AND avac_amreferenciaarrecadacao = :anoMesArrecadacao " +
    			") as valor_acertos, " + 
    			"sum(a.avbc_vlrealizado) as valor_realizado, " + // 7: valor_realizado 
				"( " + // 8: valor dos acertos aplicados nos avisos bancarios
		    		"(" +
		    			"+ sum( CASE WHEN ac2.avac_iccreditodebito = 1 AND ac2.avac_icarrecadacaodevolucao = 1 THEN ac2.avac_vlacerto ELSE 0 END )" + 
		            	"- sum( CASE WHEN ac2.avac_iccreditodebito = 2 AND ac2.avac_icarrecadacaodevolucao = 1 THEN ac2.avac_vlacerto ELSE 0 END )" + 
		            ") - ( " + 
		            	"+ sum( CASE WHEN ac2.avac_iccreditodebito = 1 AND ac2.avac_icarrecadacaodevolucao = 2 THEN ac2.avac_vlacerto ELSE 0 END )" + 
		            	"- sum( CASE WHEN ac2.avac_iccreditodebito = 2 AND ac2.avac_icarrecadacaodevolucao = 2 THEN ac2.avac_vlacerto ELSE 0 END )" + 
		            ") " + 
			    ") as acertos_avisos " + 
    			select +
    		"FROM arrecadacao.aviso_bancario a " + 
    	    	"INNER JOIN arrecadacao.arrecadador ar ON (a.arrc_id = ar.arrc_id) " + 
    	    	"INNER JOIN cadastro.cliente c ON (ar.clie_id = c.clie_id) " + 
    	    	"INNER JOIN arrecadacao.arrecadacao_forma af ON (a.arfm_id = af.arfm_id) " +
    	    	"LEFT JOIN arrecadacao.aviso_deducoes d ON (a.avbc_id = d.avbc_id) " + 
    	    	"LEFT JOIN arrecadacao.aviso_acertos ac2 ON (ac2.avbc_id = a.avbc_id AND ac2.avac_amreferenciaarrecadacao = :anoMesArrecadacao) " + 
			"WHERE " + 
				"a.avbc_amreferenciaarrecadacao = :anoMesArrecadacao " + where + 
				" AND a.avbc_tmultimaalteracao <= :dataHoraDadosDiarios " + 
			group + 
				
			") UNION (" + 
			
			"SELECT " + 
				"ac.avac_dtacerto, " + 
				"0,0,0,0,0, " + 
				"( " + 
			    	"(" +
		    			"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
		            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END )" + 
		            ") - ( " + 
		            	"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
		            	"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END )" + 
		            ") " + 
				") as valor_acertos, " + 
				"0,0 " + diferencaAcumulada + 
				select2 + 
			"FROM arrecadacao.aviso_acertos ac " + 
				"INNER JOIN arrecadacao.aviso_bancario a ON (ac.avbc_id = a.avbc_id) " + 
				"INNER JOIN arrecadacao.arrecadador ar ON (a.arrc_id = ar.arrc_id) " + 
				"INNER JOIN cadastro.cliente clie ON (ar.clie_id = clie.clie_id) " + 
				"INNER JOIN arrecadacao.arrecadacao_forma af ON (a.arfm_id = af.arfm_id) " + 
			"WHERE ac.avac_amreferenciaarrecadacao = :anoMesArrecadacao " + where + 
			" AND ac.avac_tmultimaalteracao <= :dataHoraDadosDiarios " + 
				"AND ac.avac_dtacerto NOT IN (" +
					"SELECT distinct(avbc.avbc_dtrealizada) " +
					"FROM arrecadacao.aviso_bancario avbc " + 
					"WHERE avbc.avbc_amreferenciaarrecadacao = :anoMesArrecadacao " + where2 + 
					" AND avbc.avbc_tmultimaalteracao <= :dataHoraDadosDiarios " + whereGroup + 
				") " + 
				group2 + 
			
			" ) " + order;
    	
    	try {
    		SQLQuery q = session.createSQLQuery(consulta);
    		
    		q.addScalar("data_realizada", Hibernate.DATE);
    		q.addScalar("arrecadacao_calculado", Hibernate.BIG_DECIMAL);
    		q.addScalar("arrecadacao_informado", Hibernate.BIG_DECIMAL);
    		q.addScalar("devolucao_calculado", Hibernate.BIG_DECIMAL);
    		q.addScalar("devolucao_informado", Hibernate.BIG_DECIMAL);
    		q.addScalar("valor_deducao", Hibernate.BIG_DECIMAL);
    		q.addScalar("valor_acertos", Hibernate.BIG_DECIMAL);
    		q.addScalar("valor_realizado", Hibernate.BIG_DECIMAL);
    		q.addScalar("acertos_avisos", Hibernate.BIG_DECIMAL);
    		q.addScalar("diferenca_acumulada", Hibernate.BIG_DECIMAL);
    		q.addScalar("acertos_diferenca_acumulada", Hibernate.BIG_DECIMAL);
    		
    		if (helper.getPorArrecadador() && helper.getPorFormaArrecadacao()) {
        		q.addScalar("dias_float", Hibernate.INTEGER);
        		q.addScalar("tarifa_unitaria", Hibernate.BIG_DECIMAL);
				q.addScalar("id_arrecadador", Hibernate.INTEGER);
				q.addScalar("id_arrecadacao_forma", Hibernate.INTEGER);
			}
			else if (helper.getPorArrecadador()) {
				q.addScalar("id_arrecadador", Hibernate.INTEGER);
			}
			else if (helper.getPorFormaArrecadacao()) {
				q.addScalar("id_arrecadacao_forma", Hibernate.INTEGER);
			}
    		
    		q.setInteger("anoMesArrecadacao", helper.getMesAno());
    		q.setInteger("anoMesArrecadacaoAnterior", anoMesArrecadacaoAnterior);
    		q.setTimestamp("dataHoraDadosDiarios", dataHoraDadosDiarios);
    		
    		if (helper.getIdArrecadador() != null) {
    			q.setInteger("idArrecadador", helper.getIdArrecadador());
    		}
    		if (helper.getIdFormaArrecadacao() != null) {
    			q.setInteger("idFormaArrecadacao", helper.getIdFormaArrecadacao());
    		}
    		
    		for (Object[] linha : (List<Object[]>) q.list()) {
    			RelatorioAnaliseAvisosBancariosBean bean = new RelatorioAnaliseAvisosBancariosBean();
    			bean.setDataRealizada((Date) linha[0]);
    			if (linha[1] != null) bean.setValorArrecadacaoCalculado((BigDecimal) linha[1]);
    			if (linha[2] != null) bean.setValorArrecadacaoInformado((BigDecimal) linha[2]);
    			if (linha[3] != null) bean.setValorDevolucaoCalculado((BigDecimal) linha[3]);
    			if (linha[4] != null) bean.setValorDevolucaoInformado((BigDecimal) linha[4]);
    			if (linha[5] != null) bean.setValorDeducoes((BigDecimal) linha[5]);
    			if (linha[6] != null) bean.setValorAcertos((BigDecimal) linha[6]);
    			if (linha[7] != null) bean.setValorRealizado((BigDecimal) linha[7]);
    			if (linha[8] != null) bean.setValorAcertosAplicadosAvisos((BigDecimal) linha[8]);
    			if (linha[9] != null) bean.setDiferencaAcumulada((BigDecimal) linha[9]);
    			if (linha[10] != null) bean.setValorAcertosAplicadosDiferenca((BigDecimal) linha[10]);
    			
    			if (helper.getPorArrecadador() && helper.getPorFormaArrecadacao()) {
        			if (linha[11] != null)  bean.setDiasFloat((Integer) linha[11]);
        			if (linha[12] != null)  bean.setValorTarifaUnitaria((BigDecimal) linha[12]);
    				bean.setIdArrecadador((Integer) linha[13]);
    				bean.setIdFormaArrecadacao((Integer) linha[14]);
    			}
    			else if (helper.getPorArrecadador()) {
    				bean.setIdArrecadador((Integer) linha[11]);
    			}
    			else if (helper.getPorFormaArrecadacao()) {
    				bean.setIdFormaArrecadacao((Integer) linha[11]);
    			}
    			retorno.add(bean);
    		}
    		
    	} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
    }
    
    /**
     * [UC0829] Gerar Relatório Avisos Bancarios Por Conta Corrente
     * 
     * @author Victor Cisneiros
     * @date 21/08/2008
     */
    public List<RelatorioAvisoBancarioPorContaCorrenteBean> pesquisarAvisoBancarioPorContaCorrente(
    		PesquisarAvisoBancarioPorContaCorrenteHelper helper) throws ErroRepositorioException {
    	
    	List<RelatorioAvisoBancarioPorContaCorrenteBean> retorno = new ArrayList<RelatorioAvisoBancarioPorContaCorrenteBean>();
    	Session session = HibernateUtil.getSession();
    	
    	String where = "";
    	if (helper.getIdBanco() != null) {
    		where += " AND b.bnco_id = :idBanco ";
    	}
    	if (helper.getIdContaBancaria() != null) {
    		where += " AND cb.ctbc_id = :idContaBancaria ";
    	}
    	
    	String anoMes = String.valueOf(helper.getMesAno());
    	int ano = new Integer(anoMes.substring(0, 4));
    	int mes = new Integer(anoMes.substring(4, 6));
    	
    	String consulta =
    		"( " + 
    		"SELECT " + 
	    		"a.avbc_id as id_aviso, " + // 0 
	    		"a.avbc_dtrealizada as data_realizada,  " + // 1
	    		"a.arrc_id as id_arrecadador,  " + // 2
	    		"c.clie_nmcliente as descricao_arrecadador, " + // 3
	    		"a.arfm_id as id_arrecadacao_forma,  " + // 4
	    		"af.arfm_dsarrecadacaoforma as descricao_arrecadacao_forma, " + // 5
	    		"b.bnco_id as id_banco, " + // 6
	    		"b.bnco_nmbanco as descricao_banco, " + // 7
	    		"cb.ctbc_id as id_conta, " + // 8
	    		"cb.ctbc_nnconta as numero_conta, " + // 9
	    		"ag.agen_id as id_agencia, " + // 10
	    		"ag.agen_cdagencia as codigo_agencia, " + // 11
	    		"ag.agen_nmagencia as descricao_agencia, " + // 12
	    		"cb.ctbc_nncontacontabil as numero_conta_contabil, " + // 13
	    		"ag.agen_nnfone as numero_fone, " +// 14
	    		"ag.agen_nnfoneramal as numero_ramal, " + // 15
	    		"a.avbc_dtlancamento as data_lancamento,  " + // 16
	    		"a.avbc_nnsequencial as sequencial_aviso, " + // 17
	    		"a.avbc_nndocumento as numero_documento, " + // 18
	    		"( CASE WHEN a.avbc_iccreditodebito = 1 THEN a.avbc_vlrealizado ELSE 0 END ) as credito, " + // 19
	    		"( CASE WHEN a.avbc_iccreditodebito = 2 THEN a.avbc_vlrealizado ELSE 0 END ) as debito, " + // 20
	    		"a.avbc_amreferenciaarrecadacao as ano_mes_arrecadacao, " + // 21
	    		"1 " + 
	    	"FROM arrecadacao.aviso_bancario a " + 
		    	"LEFT JOIN arrecadacao.arrecadador ar ON (a.arrc_id = ar.arrc_id) " + 
		    	"LEFT JOIN cadastro.cliente c ON (ar.clie_id = c.clie_id) " + 
		    	"LEFT JOIN arrecadacao.arrecadacao_forma af ON (a.arfm_id = af.arfm_id) " + 
		    	"INNER JOIN arrecadacao.conta_bancaria cb ON (a.ctbc_id = cb.ctbc_id) " + 
		    	"INNER JOIN arrecadacao.agencia ag ON (cb.agen_id = ag.agen_id) " + 
		    	"INNER JOIN arrecadacao.banco b ON (ag.bnco_id = b.bnco_id) " + 
	    	"WHERE " + 
	    		"(a.avbc_amreferenciaarrecadacao = :anoMesReferencia OR (to_char(a.avbc_dtrealizada, 'YYYY') = :ano AND to_char(a.avbc_dtrealizada, 'MM') = :mes)) " + where + 
		    
		    ") UNION ALL ( " + 
		    
		    "SELECT " + 
				"0, " + // 0
				"ac.avac_dtacerto as data_realizada,  " + // 1
				"a.arrc_id as id_arrecadador,  " + // 2
				"c.clie_nmcliente as descricao_arrecadador,  " + // 3
				"a.arfm_id as arrecadacao_forma,  " + // 4
				"af.arfm_dsarrecadacaoforma as descricao_arrecadacao_forma,  " + // 5
	    		"b.bnco_id as id_banco, " + // 6
	    		"b.bnco_nmbanco as descricao_banco, " + // 7
	    		"cb.ctbc_id as id_conta, " + // 8
	    		"cb.ctbc_nnconta as numero_conta, " + // 9
	    		"ag.agen_id as id_agencia, " + // 10
	    		"ag.agen_cdagencia as codigo_agencia, " + // 11
	    		"ag.agen_nmagencia as descricao_agencia, " + // 12
	    		"cb.ctbc_nncontacontabil as numero_conta_contabil, " + // 13
	    		"ag.agen_nnfone as numero_fone, " +// 14
	    		"ag.agen_nnfoneramal as numero_ramal, " + // 15
				" sysdate , " + // 16
				"a.avbc_nnsequencial as sequencial_aviso, " + // 17
				"a.avbc_nndocumento as numero_documento, " + // 18
				"( CASE WHEN ((ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 1) OR (ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 2)) THEN ac.avac_vlacerto ELSE 0 END ) as credito, " + // 19
				"( CASE WHEN ((ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 2) OR (ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 1)) THEN ac.avac_vlacerto ELSE 0 END ) as debito, " + // 20
	    		"a.avbc_amreferenciaarrecadacao as ano_mes_arrecadacao, " +// 21
	    		"10 " + 
			"FROM arrecadacao.aviso_acertos ac " + 
				"INNER JOIN arrecadacao.aviso_bancario a ON (ac.avbc_id = a.avbc_id) " + 
				"LEFT JOIN arrecadacao.arrecadador ar ON (a.arrc_id = ar.arrc_id)  " + 
				"LEFT JOIN cadastro.cliente c ON (ar.clie_id = c.clie_id)  " + 
				"LEFT JOIN arrecadacao.arrecadacao_forma af ON (a.arfm_id = af.arfm_id)  " + 
		    	"INNER JOIN arrecadacao.conta_bancaria cb ON (a.ctbc_id = cb.ctbc_id) " + 
		    	"INNER JOIN arrecadacao.agencia ag ON (cb.agen_id = ag.agen_id) " + 
		    	"INNER JOIN arrecadacao.banco b ON (ag.bnco_id = b.bnco_id) " + 
			"WHERE " + 
				"(ac.avac_amreferenciaarrecadacao = :anoMesReferencia OR (to_char(ac.avac_dtacerto, 'YYYY') = :ano AND to_char(ac.avac_dtacerto, 'MM') = :mes)) " + where +
		    ") ORDER BY 7, 9, 2, 23";
    	
    	try {
    		SQLQuery q = session.createSQLQuery(consulta);
    		
    		q.addScalar("id_aviso", Hibernate.INTEGER);
    		q.addScalar("data_realizada", Hibernate.DATE);
    		q.addScalar("id_arrecadador", Hibernate.INTEGER);
    		q.addScalar("descricao_arrecadador", Hibernate.STRING);
    		q.addScalar("id_arrecadacao_forma", Hibernate.INTEGER);
    		q.addScalar("descricao_arrecadacao_forma", Hibernate.STRING);
    		q.addScalar("id_banco", Hibernate.INTEGER);
    		q.addScalar("descricao_banco", Hibernate.STRING);
    		q.addScalar("id_conta", Hibernate.INTEGER);
    		q.addScalar("numero_conta", Hibernate.STRING);
    		q.addScalar("id_agencia", Hibernate.INTEGER);
    		q.addScalar("codigo_agencia", Hibernate.STRING);
    		q.addScalar("descricao_agencia", Hibernate.STRING);
    		q.addScalar("numero_conta_contabil", Hibernate.INTEGER);
    		q.addScalar("numero_fone", Hibernate.STRING);
    		q.addScalar("numero_ramal", Hibernate.STRING);
    		q.addScalar("data_lancamento", Hibernate.DATE);
    		q.addScalar("sequencial_aviso", Hibernate.INTEGER);
    		q.addScalar("numero_documento", Hibernate.INTEGER);
    		q.addScalar("credito", Hibernate.BIG_DECIMAL);
    		q.addScalar("debito", Hibernate.BIG_DECIMAL);
    		q.addScalar("ano_mes_arrecadacao", Hibernate.INTEGER);
    		
    		q.setInteger("anoMesReferencia", helper.getMesAno());
    		q.setInteger("ano", ano);
    		q.setInteger("mes", mes);
    		
        	if (helper.getIdBanco() != null) {
        		q.setInteger("idBanco", helper.getIdBanco());
        	}
        	if (helper.getIdContaBancaria() != null) {
        		q.setInteger("idContaBancaria", helper.getIdContaBancaria());
        	}
    		
    		for (Object[] linha : (List<Object[]>) q.list()) {
    			RelatorioAvisoBancarioPorContaCorrenteBean bean = new RelatorioAvisoBancarioPorContaCorrenteBean();
    			bean.setIdAviso((Integer) linha[0]);
    			bean.setDataRealizada((Date) linha[1]);
    			bean.setIdArrecadador((Integer) linha[2]);
    			bean.setDescricaoArrecadador((String) linha[3]);
    			bean.setIdArrecadacaoForma((Integer) linha[4]);
    			bean.setDescricaoArrecadacaoForma((String) linha[5]);
    			
    			bean.setIdBanco((Integer) linha[6]);
    			bean.setDescricaoBanco((String) linha[7]);
    			bean.setIdConta((Integer) linha[8]);
    			bean.setNumeroConta((String) linha[9]);
    			bean.setIdAgencia((Integer) linha[10]);
    			bean.setCodigoAgencia((String) linha[11]);
    			
    			bean.setDescricaoAgencia((String) linha[12]);
    			bean.setNumeroContaContabil((Integer) linha[13]);
    			bean.setNumeroFone((String) linha[14]);
    			bean.setNumeroRamal((String) linha[15]); 
    			
    			bean.setDataLancamento((Date) linha[16]);
    			bean.setSequencialAviso((Integer) linha[17]);
    			bean.setNumeroDocumento((Integer) linha[18]);
    			bean.setCredito((BigDecimal) linha [19]);
    			bean.setDebito((BigDecimal) linha[20]);
    			bean.setAnoMesArrecadacao((Integer) linha[21]);
    			
    			retorno.add(bean);
    		}
    		
    	} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
    }
    
    /**
     * [UC0829] Gerar Relatório Avisos Bancarios Por Conta Corrente
     * 
     * @author Victor Cisneiros
     * @date 21/08/2008
     */
    public List<Object[]> pesquisarPagamentosDosAvisos(
    		PesquisarAvisoBancarioPorContaCorrenteHelper helper, Collection<Integer> idsAvisos) throws ErroRepositorioException {
    	
    	List<Object[]> retorno = new ArrayList<Object[]>();
    	Session session = HibernateUtil.getSession();
    	
    	String consulta =
    		"( " + 
    		"SELECT " + 
	    		"a.avbc_id as id_aviso, " + 
	    		"p.pgmt_dtpagamento as data_pagamento, " + 
	    		"sum(p.pgmt_vlpagamento) as valor_pagamento " + 
	    	"FROM arrecadacao.aviso_bancario a  " + 
	    		"INNER JOIN arrecadacao.pagamento p ON (a.avbc_id = p.avbc_id)  " + 
	    	"WHERE  " + 
	    		"a.avbc_id IN (:idsAvisos) " + 
	    	"GROUP BY  " + 
	    		"a.avbc_id, p.pgmt_dtpagamento " + 
	    	
	    	") UNION ALL ( " + 
	    	
	    	"SELECT " + 
	    		"p.avbc_id as id_aviso, " + 
	    		"p.pghi_dtpagamento as data_pagamento, " + 
	    		"sum(p.pghi_vlpagamento) as valor_pagamento " + 
	    	"FROM arrecadacao.pagamento_historico p " + 
	    	"WHERE  " + 
	    		"p.avbc_id IN (:idsAvisos) " + 
	    	"GROUP BY  " + 
	    		"p.avbc_id, p.pghi_dtpagamento " +
	    	") ORDER BY 2 ";
    	
    	try {
    		SQLQuery q = session.createSQLQuery(consulta);
    		
    		q.addScalar("id_aviso", Hibernate.INTEGER);
    		q.addScalar("data_pagamento", Hibernate.DATE);
    		q.addScalar("valor_pagamento", Hibernate.BIG_DECIMAL);
    		
    		q.setParameterList("idsAvisos", idsAvisos);
    		
    		retorno = (List<Object[]>) q.list();
    		
    	} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
    }
    
    /**
     * [UC0828] Atualizar Diferença Acumulada no Mês
     * 
     * @author Victor Cisneiros
     * @date 01/09/2008
     */
    public List<Object[]> pesquisarDiferencaAcumuladaNoMes(int anoMesArrecadacao, int anoMesArrecadacaoAnterior) throws ErroRepositorioException {
    	List<Object[]> retorno = new ArrayList<Object[]>();
    	Session session = HibernateUtil.getSession();
    	
    	String consulta =
    		"SELECT " + 
	    		"( CASE WHEN arrecadador_aviso IS NOT NULL THEN arrecadador_aviso ELSE arrecadador_acerto END ) as arrecadador, " + 
	    		"( CASE WHEN arrecadacao_forma_aviso IS NOT NULL THEN arrecadacao_forma_aviso ELSE arrecadacao_forma_acerto END ) as arrecadacao_forma, " + 
	    		"( " + 
	    			"  ( CASE WHEN diferenca_acumulada_aviso IS NOT NULL THEN diferenca_acumulada_aviso ELSE 0 END ) " +
	    			"+ ( CASE WHEN diferenca_acumulada_acerto IS NOT NULL THEN diferenca_acumulada_acerto ELSE 0 END ) " +
	    		") as diferenca_acumulada, " +
	    		"( " +
	    			"SELECT ( df.dfac_vldiferencaacumulada ) " +
	    			"FROM arrecadacao.diferenca_acumulada df " +
	    			"WHERE  " +
	    				"df.arrc_id = ( CASE WHEN arrecadador_aviso IS NOT NULL THEN arrecadador_aviso ELSE arrecadador_acerto END ) " +
	    				"AND df.arfm_id = ( CASE WHEN arrecadacao_forma_aviso IS NOT NULL THEN arrecadacao_forma_aviso ELSE arrecadacao_forma_acerto END ) " +
	    				"AND df.dfac_amreferenciaarrecadacao = :anoMesArrecadacaoAnterior " +
	    		") as diferenca_acumulada_anterior " +
	    	"FROM ( " + 
		    	"SELECT " + 
					"arrc.arrc_id arrecadador_aviso, " + 
					"arfm.arfm_id as arrecadacao_forma_aviso, " + 
					"( " + 
						"+ sum(a.avbc_vlarrecadacaocalculado) " + 
						"- sum(a.avbc_vlarrecadacaoinformado) " + 
					") - ( " + 
						"+ sum(a.avbc_vldevolucaocalculado) " + 
						"- sum(a.avbc_vldevolucaoinformado) " + 
					") as diferenca_acumulada_aviso " + 
				"FROM arrecadacao.arrecadador arrc CROSS JOIN arrecadacao.arrecadacao_forma arfm " + 
					"LEFT JOIN arrecadacao.aviso_bancario a ON ( " + 
						"a.arrc_id = arrc.arrc_id " + 
						"AND a.arfm_id = arfm.arfm_id " + 
						"AND a.avbc_amreferenciaarrecadacao = :anoMesArrecadacao " + 
					")  " + 
				"GROUP BY " + 
					"arrc.arrc_id, arfm.arfm_id " + 
	
	    	") a FULL JOIN ( " + 
	
		    	"SELECT " + 
					"arrc.arrc_id as arrecadador_acerto, " + 
					"arfm.arfm_id as arrecadacao_forma_acerto, " + 
					"( " + 
						"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END ) " + 
						"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 1 THEN ac.avac_vlacerto ELSE 0 END ) " + 
					") - ( " + 
						"+ sum( CASE WHEN ac.avac_iccreditodebito = 1 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END ) " + 
						"- sum( CASE WHEN ac.avac_iccreditodebito = 2 AND ac.avac_icarrecadacaodevolucao = 2 THEN ac.avac_vlacerto ELSE 0 END ) " + 
					") as diferenca_acumulada_acerto " + 
				"FROM arrecadacao.arrecadador arrc CROSS JOIN arrecadacao.arrecadacao_forma arfm " + 
					"LEFT JOIN arrecadacao.aviso_bancario a ON ( " + 
						"a.arrc_id = arrc.arrc_id " + 
						"AND a.arfm_id = arfm.arfm_id " + 
					") " + 
					"LEFT JOIN arrecadacao.aviso_acertos ac ON (" +
						"ac.avbc_id = a.avbc_id " +
						"AND ac.avac_amreferenciaarrecadacao = :anoMesArrecadacao " + 
					") " + 
				"GROUP BY " + 
					"arrc.arrc_id, arfm.arfm_id " + 
	
	    	") b ON (a.arrecadador_aviso = b.arrecadador_acerto AND a.arrecadacao_forma_aviso = b.arrecadacao_forma_acerto) " + 
	    	"ORDER BY arrecadador, arrecadacao_forma ";
    	try {
    		SQLQuery q = session.createSQLQuery(consulta);
    		
    		q.addScalar("arrecadador", Hibernate.INTEGER);
    		q.addScalar("arrecadacao_forma", Hibernate.INTEGER);
    		q.addScalar("diferenca_acumulada", Hibernate.BIG_DECIMAL);
    		q.addScalar("diferenca_acumulada_anterior", Hibernate.BIG_DECIMAL);
    		
    		q.setInteger("anoMesArrecadacao", anoMesArrecadacao);
    		q.setInteger("anoMesArrecadacaoAnterior", anoMesArrecadacaoAnterior);
    		
    		retorno = (List<Object[]>) q.list();
    		
    	} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
    }
    
    /**
     * [UC0828] Atualizar Diferença Acumulada no Mês
     * 
     * @author Victor Cisneiros
     * @date 01/09/2008
     */
    public void removerDiferencasAcumuladasNoMes(int anoMesArrecadacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "delete DiferencaAcumulada d " +
					"where d.anoMesReferenciaArrecadacao = :anoMesArrecadacao";
	
			session.createQuery(consulta).setInteger(
					"anoMesArrecadacao", anoMesArrecadacao)
					.executeUpdate();
	
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
    }

	/**
	 * [UC0818] Gerar Historico do Encerramento da Arrecadação
	 * 
	 * Pesquisa os creditos a realizar correspondentes as devoluções classificadas
	 * 
	 * @author Vivianne Sousa
	 * @date 26/08/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CreditoARealizar> pesquisarCreditoaRealizarDeDevolucoesClassificadas(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<CreditoARealizar> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";
		
		/**
		 * Algumas guias de pagamento e guias de devolução foram jogados para histórico indevidamente
		 * Alterado clausula where do anoMesReferenciaArrecadacao de <= para <
		 * 
		 * @author Wellington Rocha
		 * @date 18/09/2012
		 * */

		try {

			consulta = "select crar from CreditoARealizar crar "
					+ "inner join crar.localidade loca "
					+ "where crar.id in "
					+ "(select distinct devl.creditoARealizarGeral.id from Devolucao devl " 
					+ "where devl.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
					+ "and devl.devolucaoSituacaoAtual.id = " + DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES 
					+ " and devl.creditoARealizarGeral.id is not null and devl.localidade.id = :idLocalidade) "
					+ " and loca.id = :idLocalidade ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade",
					idLocalidade).setInteger("anoMesReferenciaArrecadacao",
					anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	public Collection<Pagamento> obterPagamentosClassificadosNaoRegistradosCobrancaPorEmpresa(Integer idLocalidade, Integer referencia, int numeroPaginas, int quantidadeRegistros)
			throws ErroRepositorioException {
		Collection<Pagamento> retorno = new ArrayList();
		Session session = HibernateUtil.getSession();
		
		Collection<Object[]> colecaoDadosPagamentos = null;
		StringBuilder consulta = new StringBuilder();
		
		try {
			
			consulta.append(" with valor as (select imov_id,cbdo_id, sum(valor_total) as valor_total , sum(devol_total) as devol_total from ( ")
					.append(" select pg.imov_id ,pg.cbdo_id, sum(pgmt_vlpagamento) as valor_total, 0 as devol_total ")
					.append(" FROM arrecadacao.pagamento pg ")
					.append(" where pg.cbdo_id in (select cbdo_id from arrecadacao.devolucao d) ")
					.append(" group by pg.imov_id ,pg.cbdo_id ")
					.append(" union all ")
					.append(" select d.imov_id ,d.cbdo_id, 0 as valor_total, sum (devl_vldevolucao) as devol_total ")
					.append(" FROM arrecadacao.devolucao d ")
					.append(" where d.cbdo_id in (select cbdo_id from arrecadacao.pagamento pg ) ")
					.append(" group by d.imov_id ,d.cbdo_id ) as x ")
					.append(" group by imov_id ,cbdo_id) ")

					.append(" SELECT pg.pgmt_id as idPagamento, ")
					.append(" pg.pgmt_vlpagamento as valorPagamento, ")
					.append(" cnt.cnta_id as idConta, ")
					.append(" gp.gpag_id as idGuia, ")
					.append(" pgp.parc_id as idParcelamentoGuia, ")
					.append(" pgp.parc_vldebitoatualizado as valorParcelamentoGuia, ")
					.append(" gp.gphi_vldebito as valorGuia, ")
					.append(" dtgp.dbtp_id as debitoTipoGuia, ")
					.append(" dac.dbac_id as idDebito, ")
					.append(" pdac.parc_id as idParcelamentoDebito, ")
					.append(" pdac.parc_vldebitoatualizado as valorParcelamentoDebito, ")
					.append(" dac.dahi_vldebito as valorDebito, ")
					.append(" dac.dbtp_id as deitoTipoDebito, ")
					.append(" pg.pgmt_amreferenciapagamento as referenciaPagamento, ")
					.append(" pg.pgmt_dtpagamento as dataPagamento, ")
					.append(" pg.imov_id as imovel, ")
					.append(" ab.arrc_id as arrecadador, ")
					.append(" pgp.parc_vlconta as valorParcelamentoConta, ")
					.append(" pdac.parc_vlconta as valorParcelamentoContaDebito,   ")
					.append(" dac.dahi_nnprestacaodebito as numPrestacaoDebito, ")
					.append(" dac.dahi_nnprestacaocobradas as numPrestacoesCobradas, ")
					.append(" dac.dahi_nnparcelabonus as numParcelaBonus, ")
					.append(" round(((pg.pgmt_vlpagamento * devol_total) / valor_total),2)  as valorDesconto ")
					.append(" FROM arrecadacao.pagamento pg ")
					.append(" INNER JOIN arrecadacao.aviso_bancario ab on ab.avbc_id = pg.avbc_id ")
					.append(" LEFT JOIN valor v on pg.cbdo_id = v.cbdo_id ")
					.append(" LEFT JOIN faturamento.conta cnt on cnt.cnta_id = pg.cnta_id ")
					.append(" LEFT JOIN faturamento.guia_pagamento gp on gp.gpag_id = pg.gpag_id ")
					.append(" LEFT JOIN cobranca.parcelamento pgp on pgp.parc_id = gp.parc_id ")
					.append(" LEFT JOIN faturamento.debito_tipo dtgp on dtgp.dbtp_id = gp.dbtp_id ")
					.append(" LEFT JOIN faturamento.deb_a_cobrar_hist dac on dac.dbac_id = pg.dbac_id ")
					.append(" LEFT JOIN cobranca.parcelamento pdac on pdac.parc_id = dac.parc_id ")
					.append(" where pg.loca_id = :idLocalidade ")
					.append(" and pg.pgst_idatual = :pagamentoClassificado ")
					.append(" and pg.pgmt_amreferenciaarrecadacao = :referencia")
					.append(" and pg.imov_id IN (select imov_id from cobranca.empresa_cobranca_conta) ")
					.append(" and pg.pgmt_id NOT IN ( select eccp.pgmt_id from cobranca.empr_cobr_conta_pagto eccp where eccp.pgmt_id is not null ) ");

			colecaoDadosPagamentos = session.createSQLQuery(consulta.toString())
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("idGuia", Hibernate.INTEGER)
					.addScalar("idParcelamentoGuia", Hibernate.INTEGER)
					.addScalar("valorParcelamentoGuia", Hibernate.BIG_DECIMAL)
					.addScalar("valorGuia", Hibernate.BIG_DECIMAL)
					.addScalar("debitoTipoGuia", Hibernate.INTEGER)
					.addScalar("idDebito", Hibernate.INTEGER)
					.addScalar("idParcelamentoDebito", Hibernate.INTEGER)
					.addScalar("valorParcelamentoDebito", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("deitoTipoDebito", Hibernate.INTEGER)
					.addScalar("referenciaPagamento", Hibernate.INTEGER)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("arrecadador", Hibernate.INTEGER)
					.addScalar("valorParcelamentoConta", Hibernate.BIG_DECIMAL)
					.addScalar("valorParcelamentoContaDebito", Hibernate.BIG_DECIMAL)
					.addScalar("numPrestacaoDebito", Hibernate.SHORT)
					.addScalar("numPrestacoesCobradas", Hibernate.SHORT)
					.addScalar("numParcelaBonus", Hibernate.SHORT)
			        .setInteger("idLocalidade",idLocalidade)
			        .setInteger("pagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
			        .setInteger("referencia", referencia)
					.setFirstResult(numeroPaginas)
					.setMaxResults(quantidadeRegistros)
					.list();
			
			if (colecaoDadosPagamentos != null && !colecaoDadosPagamentos.isEmpty()) {
				for (Object[] dadosPagamento : colecaoDadosPagamentos) {

					if (dadosPagamento != null) {
						Pagamento pagamento = new Pagamento();
						if (dadosPagamento[0] != null) {
							pagamento.setId((Integer) dadosPagamento[0]);
						}
						if (dadosPagamento[1] != null) {
							pagamento.setValorPagamento((BigDecimal) dadosPagamento[1]);
						}
						if (dadosPagamento[2] != null) {
							ContaGeral conta = new ContaGeral();
							conta.setId((Integer) dadosPagamento[2]);
							pagamento.setContaGeral(conta);
						}
						if (dadosPagamento[3] != null) {
							GuiaPagamento guia = new GuiaPagamento();
							guia.setId((Integer) dadosPagamento[3]);
							if (dadosPagamento[4] != null) {
								Parcelamento parcelamento = new Parcelamento();
								parcelamento.setId((Integer) dadosPagamento[4]);
								if (dadosPagamento[5] != null) {
									parcelamento.setValorDebitoAtualizado((BigDecimal) dadosPagamento[5]);
								}
								if (dadosPagamento[17] != null) {
									parcelamento.setValorConta((BigDecimal) dadosPagamento[17]);
								}
								guia.setParcelamento(parcelamento);
							}
							if (dadosPagamento[6] != null) {
								guia.setValorDebito((BigDecimal) dadosPagamento[6]);
							}
							if (dadosPagamento[7] != null) {
								DebitoTipo debitoTipo = new DebitoTipo();
								debitoTipo.setId((Integer) dadosPagamento[7]);
								guia.setDebitoTipo(debitoTipo);
							}

							pagamento.setGuiaPagamento(guia);
						}
						if (dadosPagamento[8] != null) {
							DebitoACobrar debitoACobrar = new DebitoACobrar();
							debitoACobrar.setId((Integer) dadosPagamento[8]);
							if (dadosPagamento[9] != null) {
								Parcelamento parcelamento = new Parcelamento();
								parcelamento.setId((Integer) dadosPagamento[9]);
								if (dadosPagamento[10] != null) {
									parcelamento.setValorDebitoAtualizado((BigDecimal) dadosPagamento[10]);
								}
								if (dadosPagamento[18] != null) {
									parcelamento.setValorConta((BigDecimal) dadosPagamento[18]);
								}
								debitoACobrar.setParcelamento(parcelamento);

							}
							if (dadosPagamento[11] != null) {
								debitoACobrar.setValorDebito((BigDecimal) dadosPagamento[11]);
							}

							if (dadosPagamento[19] != null) {
								debitoACobrar.setNumeroPrestacaoDebito((Short) dadosPagamento[19]);
							}
							if (dadosPagamento[20] != null) {
								debitoACobrar.setNumeroPrestacaoCobradas((Short) dadosPagamento[20]);
							}
							if (dadosPagamento[21] != null) {
								debitoACobrar.setNumeroParcelaBonus((Short) dadosPagamento[21]);
							}

							if (dadosPagamento[12] != null) {
								DebitoTipo debitoTipo = new DebitoTipo();
								debitoTipo.setId((Integer) dadosPagamento[12]);
								debitoACobrar.setDebitoTipo(debitoTipo);
							}

							DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
							debitoACobrarGeral.setId(debitoACobrar.getId());
							debitoACobrarGeral.setDebitoACobrar(debitoACobrar);

							pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
						}

						if (dadosPagamento[13] != null) {
							pagamento.setAnoMesReferenciaPagamento((Integer) dadosPagamento[13]);
						}
						if (dadosPagamento[14] != null) {
							pagamento.setDataPagamento((Date) dadosPagamento[14]);
						}
						if (dadosPagamento[15] != null) {
							Imovel imovel = new Imovel();
							imovel.setId((Integer) dadosPagamento[15]);
							pagamento.setImovel(imovel);
						}
						if (dadosPagamento[16] != null) {
							Arrecadador arrecadador = new Arrecadador();
							arrecadador.setId((Integer) dadosPagamento[16]);
							AvisoBancario avisoBancario = new AvisoBancario();
							avisoBancario.setArrecadador(arrecadador);
							pagamento.setAvisoBancario(avisoBancario);
						}

						retorno.add(pagamento);
					}
				}
			}
//	        Collection<Pagamento> historico = obterPagamentosHISTORICOClassificadosNaoRegistradosCobrancaPorEmpresa(idLocalidade, referencia, numeroPaginas, quantidadeRegistros); 
//	        
//			if (historico != null && !historico.isEmpty()) {
//				retorno.addAll(historico);
//			}

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;

	}
    
    /**
     * 
     * [UC0818] - Gerar Histórico do Encerramento da Arrecadação
     *
     * Fluxo Principal
     *
     * [FS0001] - Verifica existencia resumo arrecadação   
     *
     * @author bruno
     * @date 24/10/2008
     *
     * @param anoMesReferencia
     * @return
     */
    public Integer verificarExistenciaResumoArrecadacaoParaAnoMes( Integer anoMesReferencia ) throws ErroRepositorioException{        
        Integer retorno = null;
        Session session = HibernateUtil.getSession();
        String consulta = null;
        try {
            consulta = "select count(*) from ResumoArrecadacao "
                    + "where anoMesReferencia = :anoMesReferencia ";

            retorno = (Integer) session.createQuery(consulta).setInteger(
                    "anoMesReferencia", anoMesReferencia).uniqueResult();

        } catch (HibernateException e) {
            // levanta a exceção para a próxima camada
            throw new ErroRepositorioException(e, "Erro no Hibernate");
        } finally {
            // fecha a sessão
            HibernateUtil.closeSession(session);
        }
        return retorno;
    }
    
    
	/**
	 * Atualiza o valor excedente, a situação anterior para NULO e a situação atual dos pagamentos informados para o
	 * tipo de situação informada.
	 * 
	 * @author Raphael Rossiter
	 * @date 27/11/2008
	 * 
	 * @param colecaoPagamento
	 * @param pagamentoSituacao
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoAnteriorAtualEValorExcedentePagamento(
			Collection<Pagamento> colecaoPagamento, Integer pagamentoSituacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Iterator<Pagamento> iteratorPagamentos = colecaoPagamento.iterator();
		String atualizarValorExcedente;
		Pagamento pagamento = null;

		try {
			int i = 1;
			while (iteratorPagamentos.hasNext()) {
				pagamento = iteratorPagamentos.next();

				//Conta
				atualizarValorExcedente = "UPDATE Pagamento pgmt "
					+ "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
					+ "pgmt.valorExcedente = :valorExcedente, "
					+ "pgmt.ultimaAlteracao = :dataAlteracao, "
					+ "pgmt.contaGeral.id = :idConta, "
					+ "pgmt.pagamentoSituacaoAnterior.id = NULL "
					+ "WHERE pgmt.id = :idPagamento ";

				session.createQuery(atualizarValorExcedente)
					.setBigDecimal("valorExcedente", pagamento.getValorExcedente())
					.setTimestamp("dataAlteracao", new Date())
					.setInteger("pagamentoSituacao", pagamentoSituacao)
					.setInteger("idPagamento", pagamento.getId())
					.setInteger("idConta", pagamento.getContaGeral().getId())
					.executeUpdate();

				if (i % 50 == 0) {
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
    
    
	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * guia de pagamento e o campo GPAG_ID informado e
	 * o ano/mês de referência contábil da guia de pagamento seja 
	 * maior ou igual ao ano/mês de referência do faturamento 
	 * 
	 * @author Vivianne Sousa
	 * @data 25/11/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoComGuiaInformadaRefContabilMaiorIgualRefFaturamento(
			Integer anoMesReferencia, Integer idLocalidade, Integer referenciafaturamento)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id, gpag.id, pgmt.valorPagamento "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.guiaPagamento as gpag "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND " 
					+ " dotp.id in (:guiaPagamento, :entradaParcelamento ) "
					+ "AND pgmt.guiaPagamento IS NOT NULL AND loca.id = :idLocalidade "
					+ "AND gpag.anoMesReferenciaContabil > :referenciafaturamento "
					+ "AND pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
					+ "ORDER BY gpag.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta)
			.setInteger("anoMesReferencia", anoMesReferencia)
			.setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO)
			.setInteger("idLocalidade", idLocalidade)
			.setInteger("entradaParcelamento", DocumentoTipo.ENTRADA_DE_PARCELAMENTO)
			.setInteger("referenciafaturamento", referenciafaturamento)
			.setShort("indicadorClassificacao", ConstantesSistema.NAO)
			.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * guia de pagamento e o campo GPAG_ID informado e
	 * o ano/mês de referência contábil da guia de pagamento seja 
	 * menor ao ano/mês de referência do faturamento 
	 * 
	 * @author Vivianne Sousa
	 * @data 25/11/2008
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoComGuiaInformadaRefContabilMenorRefFaturamento(
			Integer anoMesReferencia, Integer idLocalidade, Integer referenciafaturamento)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, gpag.id, pgmt.valorPagamento, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento, gpag.valorDebito "
					+ "FROM Pagamento as pgmt "
					+ "LEFT JOIN pgmt.documentoTipo as dotp "
					+ "LEFT JOIN pgmt.localidade as loca "
					+ "LEFT JOIN pgmt.imovel as imov "
					+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
					+ "LEFT JOIN pgmt.guiaPagamento as gpag "
					+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND " 
					+ " dotp.id in (:guiaPagamento, :entradaParcelamento ) "
					+ "AND pgmt.guiaPagamento IS NOT NULL "
					+ "AND loca.id = :idLocalidade "
					+ "AND gpag.anoMesReferenciaContabil <= :referenciafaturamento "
					+ "AND pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
					+ "ORDER BY gpag.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta)
			.setInteger("anoMesReferencia", anoMesReferencia)
			.setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO)
			.setInteger("idLocalidade", idLocalidade)
			.setInteger("entradaParcelamento", DocumentoTipo.ENTRADA_DE_PARCELAMENTO)
			.setInteger("referenciafaturamento", referenciafaturamento)
			.setShort("indicadorClassificacao", ConstantesSistema.NAO)
			.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * debito a cobrar e o campo DBAC_ID informado e 
	 * o ano/mês de referência contábil do débito a cobrar seja 
	 * menor q o ano/mês de referência do faturamento 
	 * 
	 * @author Vivianne Sousa
	 * @data 25/11/2008
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @param referenciafaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarComDebitoInformadoRefContabilMenorRefFaturamento(
			Integer anoMesReferencia, Integer idLocalidade, Integer referenciafaturamento)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt, "//0 
				+ "dotp.id, " //1
				+ "loca.id, " //2
				+ "imov.id, " //3
				+ "pgst.id, " //4
				+ "dbac.id," //5 
				+ "dbac.valorDebito," //6
				+ "dbac.numeroPrestacaoDebito," //7 
				+ "dbac.numeroPrestacaoCobradas," //8
				+ "dbac.numeroParcelaBonus " //9
				+ "FROM Pagamento as pgmt "
				+ "LEFT JOIN pgmt.documentoTipo as dotp "
				+ "LEFT JOIN pgmt.localidade as loca "
				+ "LEFT JOIN pgmt.imovel as imov "
				+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
				+ "INNER JOIN pgmt.debitoACobrarGeral as dbacGeral "
				+ "INNER JOIN dbacGeral.debitoACobrar as dbac "
				+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia " 
				+ "AND dotp.id = :debitoACobrar "
				+ "AND loca.id = :idLocalidade "
				+ "AND dbac.anoMesReferenciaContabil < :referenciafaturamento "
				+ "AND pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
				+ "ORDER BY dbac.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("debitoACobrar", DocumentoTipo.DEBITO_A_COBRAR)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("referenciafaturamento", referenciafaturamento)
					.setShort("indicadorClassificacao", ConstantesSistema.NAO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * debito a cobrar e o campo DBAC_ID informado e 
	 * o ano/mês de referência contábil do débito a cobrar seja 
	 * maior ou igual ao ano/mês de referência do faturamento 
	 * 
	 * @author Vivianne Sousa
	 * @data 25/11/2008
	 * 
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @param referenciafaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarComDebitoInformadoRefContabilMaiorIgualRefFaturamento(
			Integer anoMesReferencia, Integer idLocalidade, Integer referenciafaturamento)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id, "//0 
				+ "dbac.id," //1 
				+ "pgmt.valorPagamento " //2
				+ "FROM Pagamento as pgmt "
				+ "LEFT JOIN pgmt.documentoTipo as dotp "
				+ "LEFT JOIN pgmt.localidade as loca "
				+ "LEFT JOIN pgmt.imovel as imov "
				+ "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
				+ "INNER JOIN pgmt.debitoACobrarGeral as dbacGeral "
				+ "INNER JOIN dbacGeral.debitoACobrar as dbac "
				+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia " 
				+ "AND dotp.id = :debitoACobrar "
				+ "AND loca.id = :idLocalidade "
				+ "AND dbac.anoMesReferenciaContabil >= :referenciafaturamento "
				+ "AND pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
				+ "ORDER BY dbac.id, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta)
							.setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("debitoACobrar", DocumentoTipo.DEBITO_A_COBRAR)
							.setInteger("idLocalidade", idLocalidade)
							.setInteger("referenciafaturamento", referenciafaturamento)
							.setShort("indicadorClassificacao", ConstantesSistema.NAO)
							.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
    
    /**
     * [UC0300] Classificar Pagamentos e Devoluções
     * 
     * O sistema seleciona os pagamentos com ano/mês de referência da
     * arrecadação igual ou menor que o ano/mês de referência da arrecadação
     * corrente (seleciona a partir da tabela PAGAMENTO para
     * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
     * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
     * debito a cobrar e o campo DBAC_ID informado e 
     * o ano/mês de referência contábil do débito a cobrar seja 
     * maior ou igual ao ano/mês de referência do faturamento 
     * 
     * @author Bruno Barros
     * @data 16/06/2009
     * 
     * @param anoMesReferenciaFaturamento
     * @param idLocalidade
     * @param referenciafaturamento
     * @return Collection<Object[]>
     */
    public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarHistoricoComDebitoInformadoRefContabil(
            Integer anoMesReferencia, Integer idLocalidade)
            throws ErroRepositorioException {

        Collection<Object[]> retorno = new ArrayList();

        Session session = HibernateUtil.getSession();
        String consulta = null;

        try {
            consulta = "SELECT pgmt.id, "//0 
                + "dbach.id," //1 
                + "pgmt.valorPagamento, " //2
                + "pgmt.pagamentoSituacaoAtual.id " // 3
                + "FROM Pagamento as pgmt "
                + "LEFT JOIN pgmt.documentoTipo as dotp "
                + "LEFT JOIN pgmt.localidade as loca "
                + "LEFT JOIN pgmt.imovel as imov "
                + "LEFT JOIN pgmt.pagamentoSituacaoAtual as pgst "
                + "INNER JOIN pgmt.debitoACobrarGeral as dbacGeral "
                + "INNER JOIN dbacGeral.debitoACobrarHistorico as dbach "
                + "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia " 
                + "AND dotp.id = :debitoACobrar "
                + "AND loca.id = :idLocalidade "
                + "AND pgmt.indicadorClassificadoRecuperacaoCredito = :indicadorClassificacao "
                + "ORDER BY dbach.id, pgmt.dataPagamento ";

            retorno = session.createQuery(consulta)
            		.setInteger("anoMesReferencia", anoMesReferencia)
            		.setInteger("debitoACobrar", DocumentoTipo.DEBITO_A_COBRAR)
            		.setInteger("idLocalidade", idLocalidade)
            		.setShort("indicadorClassificacao", ConstantesSistema.NAO)
            		.list();

        } catch (HibernateException e) {
            throw new ErroRepositorioException(e, "Erro no Hibernate");
        } finally {
            HibernateUtil.closeSession(session);
        }

        return retorno;
    }
    
	
	
	/**
	 * Pesquisa os bancos q tem imoveis cadastrados em debito automatico
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarBancoDebitoAutomatico()
		throws ErroRepositorioException {
		
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		try{
			String select = "select distinct(banco.id) from DebitoAutomatico debito "
					+ " inner join debito.agencia agencia "
					+ " inner join agencia.banco banco";
			
			retorno = session.createQuery(select).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
		
	}
	
	 /**
	  * [UC0146] Manter Conta
	  * 
	  * FS0028 - Verificar parâmetro consulta e débito automático
	  * @return
	  * @throws ErroRepositorioException
	  */
		public Integer countImoveisBancoDebitoAutomatico(String[] bancos, 
				Integer anoMesInicial,Integer anoMesFinal, Date dataVencimentoInicial,
				Date dataVencimentoFinal, String indicadorContaPaga, Integer somenteDebitoAutomatico)
			throws ErroRepositorioException {
			
			Integer retorno = null;
			
			Session session = HibernateUtil.getSession();
			Map parameters = new HashMap();
			Query query = null;
			
			try{
				String select = "select count(conta.imovel.id) "
				 + " from DebitoAutomaticoMovimento dam "
				 + " inner join dam.debitoAutomatico da " 
				 + " inner join dam.contaGeral.conta conta "
				 + " inner join da.agencia ag"
				 + " inner join conta.debitoCreditoSituacaoAtual dcst "
				 + " left  join conta.debitoCreditoSituacaoAnterior dcsan "
				 + " inner join conta.imovel imov "
				 + " inner join conta c "
				 + " where ag.banco.id in (:idBanco) " 
				 + " and dcst.id in(:normal, :retificada) "
				 + " and conta.referencia between :anoMesInicial and :anoMesFinal " 
				 + " and da.dataExclusao is null "
				 + " and dam.numeroSequenciaArquivoEnviado is null";
				
				if (somenteDebitoAutomatico != null && somenteDebitoAutomatico == 1) {
					select += " and c.indicadorDebitoConta = 1 ";
				}
				
				if(dataVencimentoInicial != null){
					select += " and conta.dataVencimentoConta between :vencimentoInicial and :vencimentoFinal ";
					parameters.put("vencimentoInicial", dataVencimentoInicial);
					parameters.put("vencimentoFinal", dataVencimentoFinal);
				}
				
				if(!indicadorContaPaga.equals("3")){
					if(indicadorContaPaga.equals("1")){
						select +=	" and exists ";
					}else{
						select +=	" and not exists ";
					}
					select +=	" (select conta.id " 
						 	 + "from Pagamento pgmt " 
						 	 + "inner join pgmt.contaGeral cntaGeral "
						 	 + "inner join cntaGeral.conta cnta "
						 	 + "where cnta.id = conta.id) ";
				}
				
				query = session.createQuery(select);
				
				Set set = parameters.keySet();
				Iterator iterMap = set.iterator();
				while (iterMap.hasNext()) {
					String key = (String) iterMap.next();
					if (parameters.get(key) instanceof Date) {
						Date data = (Date) parameters.get(key);
						query.setDate(key, data);
					}
		
				}

				retorno = (Integer)query
					.setParameterList("idBanco", bancos)
					.setInteger("anoMesInicial", anoMesInicial)
					.setInteger("anoMesFinal", anoMesFinal)
					.setInteger("normal",
							DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada",
							DebitoCreditoSituacao.RETIFICADA)
					.setMaxResults(1).uniqueResult();

			} catch (HibernateException e) {
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				HibernateUtil.closeSession(session);
			}
			
			return retorno;
			
		}
		
		/**
		  * [UC0146] Manter Conta
		  * 
		  * FS0028 - Verificar parâmetro consulta e débito automático
		  * @return
		  * @throws ErroRepositorioException
		  */
			public Collection pesquisarImoveisBancoDebitoAutomatico(String[] bancos)
				throws ErroRepositorioException {
				
				Collection retorno = null;
				
				Session session = HibernateUtil.getSession();
				
				try{
					String select = "select distinct(da.imovel.id) "
					 + " from DebitoAutomatico da "
					 + " inner join da.agencia ag"
					 + " where ag.banco.id in (:idBanco) " 
					 + " and da.dataExclusao is null";

					retorno = session.createQuery(select)
						.setParameterList("idBanco", bancos)
						.list();

				} catch (HibernateException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				} finally {
					HibernateUtil.closeSession(session);
				}
				
				return retorno;
				
			}
			
			/**
			  * [UC0146] Manter Conta
			  * 
			  * FS0028 - Verificar parâmetro consulta e débito automático
			  * @return
			  * @throws ErroRepositorioException
			  */
				public Collection selecionarImoveisBancoDebitoAutomatico(String[] bancos, 
						Integer anoMesInicial,Integer anoMesFinal, Date dataVencimentoInicial,
						Date dataVencimentoFinal, String indicadorContaPaga)
					throws ErroRepositorioException {
					
					Collection retorno = null;
					
					Session session = HibernateUtil.getSession();
					Map parameters = new HashMap();
					Query query = null;
					
					try{
						String select = "select conta.imovel.id "
						 + " from DebitoAutomaticoMovimento dam "
						 + " inner join dam.debitoAutomatico da " 
						 + " inner join dam.contaGeral.conta conta "
						 + " inner join da.agencia ag"
						 + " where ag.banco.id in (:idBanco) " 
						 + " and conta.referencia between :anoMesInicial and :anoMesFinal "
						 + " and da.dataExclusao is null " 
						 + " and dam.numeroSequenciaArquivoEnviado is null";
						
						if(dataVencimentoInicial != null){
							select += " and conta.dataVencimentoConta between :vencimentoInicial and :vencimentoFinal ";
							parameters.put("vencimentoInicial", dataVencimentoInicial);
							parameters.put("vencimentoFinal", dataVencimentoFinal);
						}
						
						if(!indicadorContaPaga.equals("3")){
							if(indicadorContaPaga.equals("1")){
								select +=	" and exists ";
							}else{
								select +=	" and not exists ";
							}
							select +=	" (select conta.id " 
								 	 + "from Pagamento pgmt " 
								 	 + "inner join pgmt.contaGeral cntaGeral "
								 	 + "inner join cntaGeral.conta cnta "
								 	 + "where cnta.id = conta.id) ";
						}
						
						query = session.createQuery(select);
						
						Set set = parameters.keySet();
						Iterator iterMap = set.iterator();
						while (iterMap.hasNext()) {
							String key = (String) iterMap.next();
							if (parameters.get(key) instanceof Date) {
								Date data = (Date) parameters.get(key);
								query.setDate(key, data);
							}
				
						}

						retorno = query
							.setParameterList("idBanco", bancos)
							.setInteger("anoMesInicial", anoMesInicial)
							.setInteger("anoMesFinal", anoMesFinal)
							.list();

					} catch (HibernateException e) {
						throw new ErroRepositorioException(e, "Erro no Hibernate");
					} finally {
						HibernateUtil.closeSession(session);
					}
					
					return retorno;
					
				}
	
	
	  /**
	 * Consultar os dodos cliente usuário do Imovel 
	 * 
	 * dados[0] = NomeArrecadador
	 * 
	 * @author Arthur Carvalho
	 * @date 12/03/2009
	 * 
	 * @param idImovel
	 * @return Collection
	 * @throws ControladorException
	 */

	public Collection<Object[]> consultarNomeArrecadadorNomeAgencia(
			String idArrecadadorMovimento) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		String consulta = null;

		Session session = HibernateUtil.getSession();
		try {

			consulta = "SELECT arrecadadorMovimento.nomeBanco "// 0
				
					+ "from ArrecadadorMovimento arrecadadorMovimento "
				
					+ "where arrecadadorMovimento.id = :idArrecadadorMovimento ";
							//"and arrecadadorMovimento.indicadorExclusao != 1 ";

			retorno = session.createQuery(consulta).setInteger("idArrecadadorMovimento",
					Integer.parseInt( idArrecadadorMovimento) ).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado COSANPA - CONTA
	 *
	 * @author Raphael Rossiter
	 * @date 01/06/2009
	 *
	 * @param numeroFatura
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarExistenciaContaPorNumeroFatura(String numeroFatura) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ct.id, ct.referencia, imov.id, loca.id from Conta ct "
					+ "inner join ct.imovel imov "
					+ "inner join ct.debitoCreditoSituacaoAtual "
					+ "inner join ct.localidade loca "
					+ "where ct.numeroFatura = :numeroFatura and "
					+ "ct.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (Object[]) session.createQuery(consulta)
					.setString("numeroFatura", numeroFatura)
					.setInteger("normal",DebitoCreditoSituacao.NORMAL)
					.setInteger("incluida",DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada",DebitoCreditoSituacao.RETIFICADA).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado COSANPA - DOCUMENTO DE COBRANÇA
	 *
	 * @author Raphael Rossiter
	 * @date 01/06/2009
	 *
	 * @param numeroDocumentoFatura
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsCobrancaDocumentoPorNumeroDocumentoFatura(String numeroDocumentoFatura) 
		throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			
			consulta = "SELECT cd.valorAcrescimos, cd.valorDesconto, cd.emissao, cd.id, "
					+ "cd.valorTaxa,loca.id, documentoTipo.id, imov.id, locaImovel.id "
					+ "FROM CobrancaDocumento cd "
					+ "INNER JOIN cd.documentoTipo documentoTipo "
					+ "INNER JOIN cd.imovel imov "
					+ "INNER JOIN imov.localidade locaImovel "
					+ "LEFT JOIN cd.localidade loca "
					+ "WHERE cd.numeroDocumentoFatura = :numeroDocumentoFatura ";

			retorno = (Object[]) session.createQuery(consulta)
					.setString("numeroDocumentoFatura", numeroDocumentoFatura)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado COSANPA - DOCUMENTO DE COBRANÇA
	 *
	 * @author Raphael Rossiter
	 * @date 02/06/2009
	 *
	 * @param idCobrancaDocumento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, " 
					+ // 13
					"loca.id, " 
					+ // 14
					"imov.id, " // 15
					+ 
					"debitoACobrar.numeroPrestacaoDebito, " // 16
					+ 
					"debitoACobrar.numeroPrestacaoCobradas " // 17
					+ "FROM CobrancaDocumentoItem cdi "
					+ "INNER JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.imovel imov "
					+ "WHERE cd.id = :idCobrancaDocumento ";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Vivianne Sousa
	 * @date 01/06/2009
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosMesEMesesAnterioresCampanhaSolidariedadeCrianca(
			Integer anoMesReferenciaArrecadacao, 
			Integer idLocalidade, Integer idRD) throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "pgmt.pgmt_vlpagamento as col_0, " + 
					  "pgmt.imov_id as col_1 " +
					 "from " +
					  "arrecadacao.pagamento pgmt " + 
					  "inner join " +
					  "cobranca.cobranca_documento cbdo " +
					  "on pgmt.cbdo_id = cbdo.cbdo_id " +
					 "where " +
					  "pgmt.loca_id= :idLocalidade " + 
					  "and pgmt.pgmt_amreferenciaarrecadacao<= :anoMesReferenciaArrecadacao " + 
					  "and pgmt.dotp_idagregador = :extratoDebito " +
					  "and cbdo.rdir_id = :campanhaSolidariedadeCrianca ";
			
			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1",Hibernate.INTEGER)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("anoMesReferenciaArrecadacao",anoMesReferenciaArrecadacao)
					.setInteger("extratoDebito" ,DocumentoTipo.EXTRATO_DE_DEBITO)
					.setInteger("campanhaSolidariedadeCrianca", idRD)
					.list();


			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Sequencial do tipo lançamento igual a 2450
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções do tipo descontos por pagamento a vista da campanha de solidariedade a criança
	 * 
	 * @author Vivianne Sousa
	 * @date 01/06/2009
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesDescontosPagamentoAVistaCampanhaCrianca(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade, Integer idRDComPercentualDoacao)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(devl.devl_vldevolucao) as col_0, " +
					  "devl.imov_id as col_1 " + 
					 "from " +
					  "arrecadacao.devolucao devl  " +
					  "inner join " +
					  "cobranca.cobranca_documento cbdo " +
					  "on devl.cbdo_id = cbdo.cbdo_id " +
					 "where " +
					  "devl.devl_amreferenciaarrecadacao= :anoMesReferenciaArrecadacao " + 
					  "and devl.loca_id= :idLocalidade " +
					  " and devl.dotp_idagregador  = :extratoDebito " +
					  " and devl.crar_id is null " +
					  " and cbdo.rdir_id = :idRDComPercentualDoacao " +
					  "group by devl.imov_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.addScalar("col_1",Hibernate.INTEGER)
			 		.setInteger("idLocalidade",idLocalidade)
			 		.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
			 		.setInteger("extratoDebito" ,DocumentoTipo.EXTRATO_DE_DEBITO)
					.setInteger("idRDComPercentualDoacao", idRDComPercentualDoacao)
					.list();			
			
			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado COSANPA - GUIA DE PAGAMENTO
	 *
	 * @author Raphael Rossiter
	 * @date 29/06/2009
	 *
	 * @param numeroFatura
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarExistenciaGuiaPagamentoPorNumeroGuiaFatura(String numeroGuiaFatura) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select guia.id, imov.id, loca.id, dbtp.id from GuiaPagamento guia "
					+ "inner join guia.imovel imov "
					+ "inner join guia.debitoCreditoSituacaoAtual "
					+ "inner join guia.localidade loca "
					+ "inner join guia.debitoTipo dbtp "
					+ "where guia.numeroGuiaFatura = :numeroGuiaFatura and "
					+ "guia.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (Object[]) session.createQuery(consulta)
					.setString("numeroGuiaFatura", numeroGuiaFatura)
					.setInteger("normal",DebitoCreditoSituacao.NORMAL)
					.setInteger("incluida",DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada",DebitoCreditoSituacao.RETIFICADA).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 * 
	 * [SB0008] - Distribuir Pagamento Legado COSANPA
	 * 
	 * @author Raphael Rossiter
	 * @created 27/07/2009
	 * 
	 * @param numeroFatura
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarFaturaPorNumeroFatura(String numeroFatura)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT fatu.id FROM Fatura fatu "
					+ "INNER JOIN FETCH fatu.cliente clie "
					+ "WHERE fatu.numeroFatura = :numeroFatura ";

			retorno = (Integer) session.createQuery(consulta).setString("numeroFatura",
					numeroFatura).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0016] - Processar Pagamento Antecipado de Conta
	 *
	 * @author Raphael Rossiter
	 * @date 13/10/2009
	 *
	 * @param idGuiaPagamento
	 * @return Conta
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarContaParaPagamentoParcial(Integer idGuiaPagamento) 
		throws ErroRepositorioException {

		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cntaGeral from GuiaPagamentoItem gpai "
					+ "inner join gpai.guiaPagamentoGeral gpagGeral "
					+ "inner join gpai.contaGeral cntaGeral "
					+ "where gpagGeral.id = :idGuiaPagamento ";

			ContaGeral contaGeral = (ContaGeral) session.createQuery(consulta).setInteger(
					"idGuiaPagamento", idGuiaPagamento).setMaxResults(1)
					.uniqueResult();
			
			if (contaGeral != null){
				
				consulta = "select cnta from Conta cnta "
					+ "where cnta.id = :idContaGeral ";

				retorno = (Conta) session.createQuery(consulta).setInteger(
					"idContaGeral", contaGeral.getId().intValue()).setMaxResults(1)
					.uniqueResult();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 * 
	 * [SB0008] - Distribuir Pagamento Legado COSANPA
	 * 
	 * @author Raphael Rossiter
	 * @created 27/07/2009
	 * 
	 * @param numeroFatura
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Fatura pesquisarFaturaPorNumeroFaturaObjetpCompleto(String numeroFatura)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Fatura retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT fatu FROM Fatura fatu "
					+ "INNER JOIN FETCH fatu.cliente clie "
					+ "WHERE fatu.numeroFatura = :numeroFatura ";

			retorno = (Fatura) session.createQuery(consulta).setString("numeroFatura",
					numeroFatura).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	
	/**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Rômulo Aurélio
	 * @data 26/10/2008
	 * Pesquisa Quantidadede contas faturas para localidade/ referência
	*/
	public Object[] pesquisarQuantidadeContasFaturadas(Integer idLocalidade,
			Integer anoMesReferencia) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select "
					+ "temp.loca_id as localidade, "
					+ "sum(qtde) as quantidade "
					+ "from "
					+ "(select "
					+ "ct.loca_id, "
					+ "count(*) as qtde "
					+ "from faturamento.conta ct "
					+ "inner join cadastro.localidade lc on lc.loca_id = ct.loca_id  "
					+ "where cnta_amreferenciaconta = :anoMesReferencia and lc.loca_id = :idLocalidade "
					+ "and dcst_idatual in (0, 1, 2, 3) "
					+ "group by temp.loca_id "
					+ "union "
					+ "select "
					+ "ch.loca_id as localidade, "
					+ "count(*)as qtde "
					+ "from faturamento.conta_historico ch "
					+ "inner join cadastro.localidade lc on lc.loca_id = ch.loca_id "
					+ "where cnhi_amreferenciaconta = :anoMesReferencia and lc.loca_id = :idLocalidade "
					+ "and dcst_idatual in (0, 1, 2, 3) "
					+ "group by ch.loca_id ) temp  "
					+ "group by ch.loca_id";

			retorno = (Object[])session.createSQLQuery(consulta).addScalar("quantidade",
					Hibernate.INTEGER).addScalar("localidade",
					Hibernate.INTEGER).setInteger("idLocalidade", idLocalidade)
					.setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Rômulo Aurélio
	 * @data 26/10/2008
	 * Quantidade/valor de documentos pagoa para unidade de negócio / referência
	 */ 
	public Object[] pesquisarQuantidadeDocumentosPagos(Integer idLocalidade,
			Integer anoMesReferencia) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select "
                       + "ph.loca_id localidade, "
                       + "count(*) as quantidade "
                       + "from arrecadacao.pagamento_historico ph "
                       + "inner join cadastro.localidade lc on lc.loca_id = ph.loca_id  "
                       + "where pghi_amreferenciaarrecadacao = :anoMesReferencia and lc.loca_id  = :idLocalidade "
                       + "group by ph.loca_id  ";

			retorno = (Object[]) session.createSQLQuery(consulta)
						.addScalar("quantidade",Hibernate.INTEGER)
						.addScalar("localidade",Hibernate.INTEGER)
						.setInteger("idLocalidade", idLocalidade)
						.setInteger("anoMesReferencia", anoMesReferencia)
						.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Arthur Carvalho
	 * @date 16/12/09
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ErroRepositorioException {

		int retorno = 0;
		Object pagamentoImovelCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal);

			hql = " select count(pagamento.id) "
					+ " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
					+ condicionais + " ";

			pagamentoImovelCount = session.createQuery(hql).setMaxResults(1)
					.uniqueResult();
			
			if (pagamentoImovelCount != null) {
				retorno += (Integer) pagamentoImovelCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Pesquisar o pagamento
	 * 
	 * @author Ivan Sergio
	 * @date 26/03/2010
	 * 
	 * @param idPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Pagamento pesquisarPagamentoParaEncerrarArrecadacao(Integer idPagamento)
			throws ErroRepositorioException {


		Pagamento retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "select pgmt " +
				"from Pagamento pgmt " +
				"inner join fetch pgmt.avisoBancario avbc " +
				"inner join fetch pgmt.documentoTipo as dctp " +
				"inner join fetch pgmt.localidade as loca " +
				"left join fetch pgmt.arrecadacaoForma as arfr " +
				"left join fetch pgmt.arrecadadorMovimentoItem as amvi " +
				"left join fetch pgmt.cliente as clie " +
				"left join fetch pgmt.contaGeral as cntg " +
				"left join fetch pgmt.debitoACobrarGeral as dbag " +
				"left join fetch pgmt.debitoTipo as dbtp " +
				"left join fetch pgmt.guiaPagamento as gupg " +
				"left join fetch pgmt.imovel as imov " +
				"left join fetch pgmt.pagamentoSituacaoAnterior as pgan " +
				"left join fetch pgmt.pagamentoSituacaoAtual as pgat " +
				"left join fetch pgmt.cobrancaDocumento as cbdo " +
				"left join fetch pgmt.documentoTipoAgregador as dcta " +
				"left join fetch pgmt.fatura as fatu " +
				"where pgmt.id = :idPagamento ";

			retorno = (Pagamento) session.createQuery(consulta).setInteger(
					"idPagamento", idPagamento).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}	

	/**
	 * Pesquisa Guia pelo Id
	 * 
	 * @author Hugo Amorim
	 * @date 11/01/2010
	 * 
	 * @param idGuia
	 * @return idGuia
	 * @exception ErroRepositorioException
	 *                
	 */
	public Integer pesquisarExistenciaGuiaPagamento(Integer idGuia) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select gp.id "
					+ "from GuiaPagamento gp "
					+ "where gp.id = :idGuia "
					+ "and gp.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada) "
					+ "order by gp.dataVencimento";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idGuia", idGuia)
					.setInteger("normal",DebitoCreditoSituacao.NORMAL)
					.setInteger("incluida",DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada",DebitoCreditoSituacao.RETIFICADA)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 *
	 * @author Raphael Rossiter
	 * @date 03/02/2010
	 *
	 * @param idArrecadador
	 * @param numeroNsa
	 * @param codigoOpcaoExtrato
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarNumeroNsaPorArrecadador(Integer idArrecadador, Integer numeroNsa,
			String codigoOpcaoExtrato) throws ErroRepositorioException {
	Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT sequ.numeroNsa "
					+ "FROM SequenciaCartao sequ "
					+ "INNER JOIN sequ.arrecadador arrc "
					+ "where arrc.id = :idArrecadador "
					+ "AND sequ.numeroNsa = :numeroNsa AND sequ.codigoOpcaoExtrato = :codigoOpcaoExtrato ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idArrecadador", idArrecadador)
					.setInteger("numeroNsa", numeroNsa)
					.setString("codigoOpcaoExtrato", codigoOpcaoExtrato)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}	


	/**
	 * [UC0978] Pesquisa Relatório de Pagamento para Entidades Beneficentes Analitico
	 * 
	 * @author Daniel Alves
	 * @data   26/01/2010
	 * @param  anoMesInicial = periodo inicial do relatorio
	 *         anoMesFinal   = periodo final do relatorio
	 *         idUnidadeBeneficente
	 *         idGerenciaRegional
	 *         idUnidadeNegocio
	 *         idLocalidade
	 *         opcaoTotalizacao
	 * @exception ErroRepositorioException
	 */ 
	public Collection pesquisarPagamentoEntidadesBeneficentesAnalitico(String anoMesInicial, String anoMesFinal,
			String idEntidadeBeneficente, String idGerenciaRegional, String idUnidadeNegocio, String idLocalidade,
			int opcaoTotalizacao
			) throws ErroRepositorioException {
		
		//Filtro para o caso de seleção de apenas uma Entidade/Gerencia/Unidade/Localidade especifica.
		String filtroWhere = "";
		//variavel para controlar se vai ser usado mais de 1 filtro no where da SQL
		boolean filtro = false;
		if(idEntidadeBeneficente != null && !idEntidadeBeneficente.trim().equals("")
				&& !idEntidadeBeneficente.trim().equals("-1")){
			filtroWhere = "where eb.eben_id = " + idEntidadeBeneficente;
			filtro = true;		
		}
		
		if(opcaoTotalizacao == 3 || opcaoTotalizacao == 8 || opcaoTotalizacao == 9){
			if(filtro){
				filtroWhere = filtroWhere + " and gr.greg_id = " + idGerenciaRegional;
			}else{
				filtroWhere = "where gr.greg_id = " + idGerenciaRegional;				
			}					
		}else if(opcaoTotalizacao == 5 || opcaoTotalizacao == 10){
			if(filtro){
				filtroWhere = filtroWhere + " and un.uneg_id = " + idUnidadeNegocio;
			}else{
				filtroWhere = "where un.uneg_id = " + idUnidadeNegocio;				
			}						
		}else if(opcaoTotalizacao == 7){
			if(filtro){				
				filtroWhere = filtroWhere + " and im.loca_id = " + idLocalidade;
			}else{
				filtroWhere = "where im.loca_id = " + idLocalidade;				
			}
		}
				
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select doacao.imov_id as matricula, "+
                              "cl.clie_nmcliente as nome, "+
                              "eb.eben_id, "+                              
                              "ebcl.clie_nmcliente as nome_entidade, "+                       
                              "im.loca_id, "+
                              "lc.loca_nmlocalidade, "+
                              "un.uneg_id, "+
                              "un.uneg_nmunidadenegocio, "+
                              "gr.greg_id, "+
                              "gr.greg_nmregional, "+                              
                              "pagamento.pgmt_vlpagamento, "+       
                              "pagamento.pgmt_amreferenciaarrecadacao "+
                              ""+
                        "from cadastro.imovel_doacoes doacao "+
                       "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) "+
                       "inner join cadastro.cliente ebcl on (ebcl.clie_id = eb.clie_id) "+
                       "inner join cadastro.cliente_imovel cl_im on (cl_im.imov_id = doacao.imov_id) and (cl_im.crtp_id=2) "+
                       "inner join cadastro.cliente cl on (cl.clie_id = cl_im.clie_id) and (cl_im.clim_dtrelacaofim is null) "+
                       ""+
                       "inner join cadastro.imovel im on (im.imov_id = cl_im.imov_id) "+
                       "inner join cadastro.localidade lc on (im.loca_id = lc.loca_id) "+
                       "inner join cadastro.unidade_negocio un on (un.uneg_id = lc.uneg_id) "+
                       "inner join cadastro.gerencia_regional gr on (un.greg_id = gr.greg_id) "+
                       ""+                       
                       "inner join "+
                       "(select doacao.eben_id, doacao.imov_id, pgmt_vlpagamento, pgmt_amreferenciaarrecadacao "+
                          "from cadastro.imovel_doacoes doacao " +
                         "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
                         "inner join faturamento.guia_pagamento guia on (guia.imov_id = doacao.imov_id) " +
                         "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=guia.dbtp_id) " +
                         "inner join arrecadacao.pagamento pagamento on (pagamento.gpag_id = guia.gpag_id) and (pagamento.pgmt_amreferenciaarrecadacao between :anoMesInicial and :anoMesFinal) " +
                        "UNION ALL " +
                        "select doacao.eben_id, doacao.imov_id, pghi_vlpagamento, pghi_amreferenciaarrecadacao " +
                          "from cadastro.imovel_doacoes doacao " +
                         "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
                         "inner join faturamento.guia_pagamento_historico guia on (guia.imov_id = doacao.imov_id) " +
                         "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=guia.dbtp_id) " +
                         "inner join arrecadacao.pagamento_historico pagamento on (pagamento.gpag_id = guia.gpag_id and pagamento.pghi_amreferenciapagamento between :anoMesInicial and :anoMesFinal) " +
                        "UNION ALL " +
                        "select doacao.eben_id, doacao.imov_id, dbcb_vlprestacao, pgmt_amreferenciaarrecadacao " +
                          "from cadastro.imovel_doacoes doacao " +
                         "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
                         "inner join faturamento.conta conta on (conta.imov_id = doacao.imov_id) " +
                         "inner join faturamento.debito_cobrado debito_cobrado on (debito_cobrado.cnta_id = conta.cnta_id) " +
                         "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=debito_cobrado.dbtp_id) " +
                         "inner join arrecadacao.pagamento pagamento on (pagamento.cnta_id = conta.cnta_id and pagamento.pgmt_amreferenciaarrecadacao between :anoMesInicial and :anoMesFinal) " +
                        "UNION ALL " +
                        "select doacao.eben_id, doacao.imov_id, dbhi_vlprestacao, pghi_amreferenciaarrecadacao " +
                          "from cadastro.imovel_doacoes doacao " +
                         "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
                         "inner join faturamento.conta_historico conta on (conta.imov_id = doacao.imov_id) " +
                         "inner join faturamento.debito_cobrado_historico debito_cobrado on (debito_cobrado.cnta_id = conta.cnta_id) " +
                         "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=debito_cobrado.dbtp_id) " +
                         "inner join arrecadacao.pagamento_historico pagamento on (pagamento.cnta_id = conta.cnta_id and pagamento.pghi_amreferenciapagamento between :anoMesInicial and :anoMesFinal) " +
                         " ) pagamento on (pagamento.imov_id = doacao.imov_id) and (doacao.eben_id = pagamento.eben_id) " +                      
                         " "+filtroWhere+" "+
		                         "group by eb.eben_id," +
		                         "gr.greg_id, "+
		                         "un.uneg_id, "+
		                         "im.loca_id, " +                                  
		                         "pagamento.pgmt_amreferenciaarrecadacao," +
		                         "im.stcm_id, im.qdra_id, im.imov_nnlote, im.imov_nnsublote, " +//ordenacao pela Inscricao
		                         "pagamento.pgmt_vlpagamento," +
		                         "doacao.imov_id," +
		                         "cl.clie_nmcliente," +
		                         "ebcl.clie_nmcliente," +
		                         "lc.loca_nmlocalidade," +
		                         "un.uneg_nmunidadenegocio," +
		                         "gr.greg_nmregional " +
		                         "order by eb.eben_id," +
                                  "gr.greg_id, "+
                                  "un.uneg_id, "+
                                  "im.loca_id, " +                                  
                                  "pagamento.pgmt_amreferenciaarrecadacao," +
                                  "im.stcm_id, im.qdra_id, im.imov_nnlote, im.imov_nnsublote, " +//ordenacao pela Inscricao
                                  "pagamento.pgmt_vlpagamento," +
                                  "matricula," +
                                  "cl.clie_nmcliente," +
                                  "ebcl.clie_nmcliente," +
                                  "lc.loca_nmlocalidade," +
                                  "un.uneg_nmunidadenegocio," +
                                  "gr.greg_nmregional";
						
			retorno =  (Collection) session.createSQLQuery(consulta)
						.addScalar("matricula",Hibernate.STRING)
						.addScalar("nome", Hibernate.STRING)
						.addScalar("eben_id", Hibernate.STRING)						
						.addScalar("nome_entidade",Hibernate.STRING)												
						.addScalar("loca_id", Hibernate.STRING)
						.addScalar("loca_nmlocalidade",Hibernate.STRING)
						.addScalar("uneg_id",Hibernate.STRING)
						.addScalar("uneg_nmunidadenegocio",Hibernate.STRING)
						.addScalar("greg_id",Hibernate.STRING)
						.addScalar("greg_nmregional",Hibernate.STRING)
						.addScalar("pgmt_vlpagamento",Hibernate.STRING)
						.addScalar("pgmt_amreferenciaarrecadacao",Hibernate.STRING)
						.setString("anoMesInicial", anoMesInicial)
						.setString("anoMesFinal", anoMesFinal).list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0978] Pesquisa Relatório de Pagamento para Entidades Beneficentes Sintetico
	 * 
	 * @author Daniel Alves
	 * @data   26/01/2010
	 * @param  anoMesInicial = periodo inicial do relatorio
	 *         anoMesFinal   = periodo final do relatorio
	 *         idUnidadeBeneficente
	 *         idGerenciaRegional
	 *         idUnidadeNegocio
	 *         idLocalidade
	 *         opcaoTotalizacao
	 * @exception ErroRepositorioException
	 */ 
	public Collection pesquisarPagamentoEntidadesBeneficentesSintetico(String anoMesInicial, String anoMesFinal,
			String idEntidadeBeneficente, String idGerenciaRegional, String idUnidadeNegocio, String idLocalidade,
			int opcaoTotalizacao
			) throws ErroRepositorioException {
		
		//Filtro para o caso de seleção de apenas uma Entidade/Gerencia/Unidade/Localidade especifica.
		String sqlWhere = " WHERE 1=1 ";

		if(idEntidadeBeneficente != null && !idEntidadeBeneficente.trim().equals("")
				&& !idEntidadeBeneficente.trim().equals("-1")){
			sqlWhere = sqlWhere + " and eb.eben_id = " + idEntidadeBeneficente;
	
		}	
		if(opcaoTotalizacao == 3 || opcaoTotalizacao == 8 || opcaoTotalizacao == 9){
		
			sqlWhere = sqlWhere + " and gr.greg_id = " + idGerenciaRegional;
								
		}else if(opcaoTotalizacao == 5 || opcaoTotalizacao == 10){
			
			sqlWhere = sqlWhere + " and un.uneg_id = " + idUnidadeNegocio;
									
		}else if(opcaoTotalizacao == 7){
					
			sqlWhere = sqlWhere + " and im.loca_id = " + idLocalidade;			
		}
				
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select eb.eben_id, " +
					          "ebcl.clie_nmcliente as nome_entidade, " +
					          "lc.loca_id, lc.loca_nmlocalidade, " +
					          "un.uneg_id, un.uneg_nmunidadenegocio, " +
					          "gr.greg_id, gr.greg_nmregional, " +
					          "im.imov_id, " +
					          "pagamento.pgmt_vlpagamento, " +
					          "pagamento.pgmt_amreferenciaarrecadacao " +
					          
					          
					     "from cadastro.imovel_doacoes doacao " +
					    "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
					    "inner join cadastro.cliente ebcl on (ebcl.clie_id = eb.clie_id) " +
					    "inner join cadastro.cliente_imovel cl_im on (cl_im.imov_id = doacao.imov_id) and (cl_im.crtp_id=2) " +
					    "inner join cadastro.cliente cl on (cl.clie_id = cl_im.clie_id) and (cl_im.clim_dtrelacaofim is null) " +
					    
					    "inner join cadastro.imovel im on (im.imov_id = cl_im.imov_id) " +
					    "inner join cadastro.localidade lc on (im.loca_id = lc.loca_id) " +
					    "inner join cadastro.unidade_negocio un on (un.uneg_id = lc.uneg_id) "+ 
                        "inner join cadastro.gerencia_regional gr on (un.greg_id = gr.greg_id) " +                        
                        "inner join " +
                        "(select doacao.eben_id, doacao.imov_id, pgmt_vlpagamento, pgmt_amreferenciaarrecadacao " +
                           "from cadastro.imovel_doacoes doacao " +
                          "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
                          "inner join faturamento.guia_pagamento guia on (guia.imov_id = doacao.imov_id) " +
                          "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=guia.dbtp_id) " +
                          "inner join arrecadacao.pagamento pagamento on (pagamento.gpag_id = guia.gpag_id and pagamento.pgmt_amreferenciaarrecadacao between :anoMesInicial and :anoMesFinal) " +
                          "group by doacao.eben_id, doacao.imov_id, pgmt_vlpagamento, pgmt_amreferenciaarrecadacao " +
                        "UNION ALL " +
                         "select doacao.eben_id, doacao.imov_id, pghi_vlpagamento, pghi_amreferenciaarrecadacao " +
                           "from cadastro.imovel_doacoes doacao " +
                          "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
                          "inner join faturamento.guia_pagamento_historico guia on (guia.imov_id = doacao.imov_id) " +
                          "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=guia.dbtp_id) " +
                          "inner join arrecadacao.pagamento_historico pagamento on (pagamento.gpag_id = guia.gpag_id and pagamento.pghi_amreferenciapagamento between :anoMesInicial and :anoMesFinal ) " +
                          "group by doacao.eben_id, doacao.imov_id, pghi_vlpagamento, pghi_amreferenciaarrecadacao " +
                        "UNION ALL " +
                         "select doacao.eben_id, doacao.imov_id, dbcb_vlprestacao, pgmt_amreferenciaarrecadacao " +
                           "from cadastro.imovel_doacoes doacao "+
                          "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
                          "inner join faturamento.conta conta on (conta.imov_id = doacao.imov_id) " +
                          "inner join faturamento.debito_cobrado debito_cobrado on (debito_cobrado.cnta_id = conta.cnta_id) " +
                          "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=debito_cobrado.dbtp_id) " +
                          "inner join arrecadacao.pagamento pagamento on (pagamento.cnta_id = conta.cnta_id and pagamento.pgmt_amreferenciaarrecadacao between :anoMesInicial and :anoMesFinal ) " +
                          "group by doacao.eben_id, doacao.imov_id, dbcb_vlprestacao, pgmt_amreferenciaarrecadacao " +
                        "UNION ALL " +
                         "select doacao.eben_id, doacao.imov_id, dbhi_vlprestacao, pghi_amreferenciaarrecadacao " +
                           "from cadastro.imovel_doacoes doacao " +
                          "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
                          "inner join faturamento.conta_historico conta on (conta.imov_id = doacao.imov_id) " +
                          "inner join faturamento.debito_cobrado_historico debito_cobrado on (debito_cobrado.cnta_id = conta.cnta_id) " +
                          "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=debito_cobrado.dbtp_id) " +
                          "inner join arrecadacao.pagamento_historico pagamento on (pagamento.cnta_id = conta.cnta_id and pagamento.pghi_amreferenciapagamento between :anoMesInicial and :anoMesFinal ) " +
                          "group by doacao.eben_id, doacao.imov_id, dbhi_vlprestacao, pghi_amreferenciaarrecadacao " + 
                       ") pagamento on (pagamento.imov_id = doacao.imov_id) and (doacao.eben_id = pagamento.eben_id) " +
                       " "+sqlWhere+" "+
                       "group by eb.eben_id, ebcl.clie_nmcliente, " +
                                "lc.loca_id, lc.loca_nmlocalidade, " +
                                "un.uneg_id, un.uneg_nmunidadenegocio, " +
                                "gr.greg_id, gr.greg_nmregional, " +
                                "im.imov_id, " +
                            	"pagamento.pgmt_vlpagamento, " +
                            	"pagamento.pgmt_amreferenciaarrecadacao " + 
                                

                     //ordena a sql ao contrario para preencher o design do relatorio 
                       "order by eb.eben_id desc, " +                                                                           
                                "gr.greg_id desc, "+
                                "un.uneg_id desc, "+
                                "lc.loca_id desc ";
			
						
			retorno =  (Collection) session.createSQLQuery(consulta)
						.addScalar("eben_id", Hibernate.STRING)						
						.addScalar("nome_entidade",Hibernate.STRING)												
						.addScalar("loca_id", Hibernate.STRING)
						.addScalar("loca_nmlocalidade",Hibernate.STRING)
						.addScalar("uneg_id",Hibernate.STRING)
						.addScalar("uneg_nmunidadenegocio",Hibernate.STRING)
						.addScalar("greg_id",Hibernate.STRING)
						.addScalar("greg_nmregional",Hibernate.STRING)
						.addScalar("imov_id",Hibernate.INTEGER)
						.addScalar("pgmt_vlpagamento",Hibernate.BIG_DECIMAL)
						.addScalar("pgmt_amreferenciaarrecadacao",Hibernate.INTEGER)
						.setString("anoMesInicial", anoMesInicial)
						.setString("anoMesFinal", anoMesFinal).list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0978] Count para Relatório de Pagamento para Entidades Beneficentes Analitico
	 * 
	 * @author Daniel Alves
	 * @data   26/01/2010
	 * @param  anoMesInicial = periodo inicial do relatorio
	 *         anoMesFinal   = periodo final do relatorio
	 *         idUnidadeBeneficente
	 *         idGerenciaRegional
	 *         idUnidadeNegocio
	 *         idLocalidade
	 *         opcaoTotalizacao
	 *   
	 * @exception ErroRepositorioException
	 */ 
	public int pesquisarPagamentoEntidadesBeneficentesAnaliticoCount(String anoMesInicial, String anoMesFinal,
			String idEntidadeBeneficente, String idGerenciaRegional, String idUnidadeNegocio, String idLocalidade,
			int opcaoTotalizacao
			) throws ErroRepositorioException {
		
		//Filtro para o caso de seleção de apenas uma Entidade/Gerencia/Unidade/Localidade especifica.
		String sqlWhere = " WHERE 1=1 ";
		
		if(idEntidadeBeneficente != null && !idEntidadeBeneficente.trim().equals("")
				&& !idEntidadeBeneficente.trim().equals("-1")){
			sqlWhere = sqlWhere + " and pagamento.eben_id = " + idEntidadeBeneficente;
	
		}	
		if(opcaoTotalizacao == 3 || opcaoTotalizacao == 8 || opcaoTotalizacao == 9){
		
			sqlWhere = sqlWhere + " and gr.greg_id = " + idGerenciaRegional;
								
		}else if(opcaoTotalizacao == 5 || opcaoTotalizacao == 10){
			
			sqlWhere = sqlWhere + " and un.uneg_id = " + idUnidadeNegocio;
									
		}else if(opcaoTotalizacao == 7){
					
			sqlWhere = sqlWhere + " and im.loca_id = " + idLocalidade;			
		}
				
		int retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(*) as contadorImovel from " +
  					   "(select doacao.eben_id, doacao.imov_id, pgmt_vlpagamento, pgmt_amreferenciaarrecadacao " +
					      "from cadastro.imovel_doacoes doacao " +
					     "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
					     "inner join faturamento.guia_pagamento guia on (guia.imov_id = doacao.imov_id) " +
					     "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=guia.dbtp_id) " +
					     "inner join arrecadacao.pagamento pagamento on (pagamento.gpag_id = guia.gpag_id and pagamento.pgmt_amreferenciaarrecadacao between :anoMesInicial and :anoMesFinal) " +
					     "group by doacao.eben_id, doacao.imov_id, pgmt_vlpagamento, pgmt_amreferenciaarrecadacao " + 
					    "UNION ALL " +
					    "select doacao.eben_id, doacao.imov_id, pghi_vlpagamento, pghi_amreferenciaarrecadacao " +
					      "from cadastro.imovel_doacoes doacao " +
				         "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
				         "inner join faturamento.guia_pagamento_historico guia on (guia.imov_id = doacao.imov_id) " +
				         "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=guia.dbtp_id) " +
				         "inner join arrecadacao.pagamento_historico pagamento on (pagamento.gpag_id = guia.gpag_id and pagamento.pghi_amreferenciapagamento between :anoMesInicial and :anoMesFinal) " +
				         "group by doacao.eben_id, doacao.imov_id, pghi_vlpagamento, pghi_amreferenciaarrecadacao " + 
					    "UNION ALL " +
					    "select doacao.eben_id, doacao.imov_id, dbcb_vlprestacao, pgmt_amreferenciaarrecadacao " +
					      "from cadastro.imovel_doacoes doacao " +
				         "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
					     "inner join faturamento.conta conta on (conta.imov_id = doacao.imov_id) " +
					     "inner join faturamento.debito_cobrado debito_cobrado on (debito_cobrado.cnta_id = conta.cnta_id) " +
					     "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=debito_cobrado.dbtp_id) " +
					     "inner join arrecadacao.pagamento pagamento on (pagamento.cnta_id = conta.cnta_id and pagamento.pgmt_amreferenciaarrecadacao between :anoMesInicial and :anoMesFinal) " +
					     "group by doacao.eben_id, doacao.imov_id, dbcb_vlprestacao, pgmt_amreferenciaarrecadacao " +
					    "UNION ALL " +
					    "select doacao.eben_id, doacao.imov_id, dbhi_vlprestacao, pghi_amreferenciaarrecadacao " +
					      "from cadastro.imovel_doacoes doacao " +
					     "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
					     "inner join faturamento.conta_historico conta on (conta.imov_id = doacao.imov_id) " +
					     "inner join faturamento.debito_cobrado_historico debito_cobrado on (debito_cobrado.cnta_id = conta.cnta_id) " +
					     "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=debito_cobrado.dbtp_id) " +
					     "inner join arrecadacao.pagamento_historico pagamento on (pagamento.cnta_id = conta.cnta_id and pagamento.pghi_amreferenciapagamento between :anoMesInicial and :anoMesFinal) " +
					     "group by doacao.eben_id, doacao.imov_id, dbhi_vlprestacao, pghi_amreferenciaarrecadacao " +					     
				       ") pagamento "+
				       "inner join cadastro.imovel im on (im.imov_id = pagamento.imov_id) " +
					   "inner join cadastro.localidade lc on (im.loca_id = lc.loca_id) " +
					   "inner join cadastro.unidade_negocio un on (un.uneg_id = lc.uneg_id) " +
					   "inner join cadastro.gerencia_regional gr on (un.greg_id = gr.greg_id) " +				       
					     " " +sqlWhere;
                           
						
			retorno =  (Integer) session.createSQLQuery(consulta)
						.addScalar("contadorImovel", Hibernate.INTEGER)							
						.setString("anoMesInicial", anoMesInicial)
						.setString("anoMesFinal", anoMesFinal).uniqueResult();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0978] Count para Relatório de Pagamento para Entidades Beneficentes Sintetico
	 * 
	 * @author Daniel Alves
	 * @data   26/01/2010
	 * @param  anoMesInicial = periodo inicial do relatorio
	 *         anoMesFinal   = periodo final do relatorio
	 *         idUnidadeBeneficente
	 *         idGerenciaRegional
	 *         idUnidadeNegocio
	 *         idLocalidade
	 *         opcaoTotalizacao
	 *   
	 * @exception ErroRepositorioException
	 */ 
	public int pesquisarPagamentoEntidadesBeneficentesSinteticoCount(String anoMesInicial, String anoMesFinal,
			String idEntidadeBeneficente, String idGerenciaRegional, String idUnidadeNegocio, String idLocalidade,
			int opcaoTotalizacao
			) throws ErroRepositorioException {
		
		//Filtro para o caso de seleção de apenas uma Entidade/Gerencia/Unidade/Localidade especifica.
		String sqlWhere = " WHERE 1=1 ";

		if(idEntidadeBeneficente != null && !idEntidadeBeneficente.trim().equals("")
				&& !idEntidadeBeneficente.trim().equals("-1")){
			sqlWhere = sqlWhere + " and pagamento.eben_id = " + idEntidadeBeneficente;
	
		}	
		if(opcaoTotalizacao == 3 || opcaoTotalizacao == 8 || opcaoTotalizacao == 9){
		
			sqlWhere = sqlWhere + " and gr.greg_id = " + idGerenciaRegional;
								
		}else if(opcaoTotalizacao == 5 || opcaoTotalizacao == 10){
			
			sqlWhere = sqlWhere + " and un.uneg_id = " + idUnidadeNegocio;
									
		}else if(opcaoTotalizacao == 7){
					
			sqlWhere = sqlWhere + " and im.loca_id = " + idLocalidade;			
		}
				
		int retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(*) as contadorTotal from " +
					    "(select pagamento.eben_id,count(pagamento.imov_id) contadorImovel from " +
					      "(select doacao.eben_id, doacao.imov_id, pgmt_vlpagamento, pgmt_amreferenciaarrecadacao " +
					         "from cadastro.imovel_doacoes doacao " +
					        "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
					        "inner join faturamento.guia_pagamento guia on (guia.imov_id = doacao.imov_id) " +
					        "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=guia.dbtp_id) " +
					        "inner join arrecadacao.pagamento pagamento on (pagamento.gpag_id = guia.gpag_id and pagamento.pgmt_amreferenciaarrecadacao between :anoMesInicial and :anoMesFinal) " +
					        "group by doacao.eben_id, doacao.imov_id, pgmt_vlpagamento, pgmt_amreferenciaarrecadacao " + 
					       "UNION ALL " +
					       "select doacao.eben_id, doacao.imov_id, pghi_vlpagamento, pghi_amreferenciaarrecadacao " +
					         "from cadastro.imovel_doacoes doacao " +
					        "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
					        "inner join faturamento.guia_pagamento_historico guia on (guia.imov_id = doacao.imov_id) " +
					        "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=guia.dbtp_id) " +
					        "inner join arrecadacao.pagamento_historico pagamento on (pagamento.gpag_id = guia.gpag_id and pagamento.pghi_amreferenciapagamento between :anoMesInicial and :anoMesFinal) " +
					        "group by doacao.eben_id, doacao.imov_id, pghi_vlpagamento, pghi_amreferenciaarrecadacao " + 
					       "UNION ALL " +
					       "select doacao.eben_id, doacao.imov_id, dbcb_vlprestacao, pgmt_amreferenciaarrecadacao " +
					         "from cadastro.imovel_doacoes doacao " +
					        "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
					        "inner join faturamento.conta conta on (conta.imov_id = doacao.imov_id) " +
					        "inner join faturamento.debito_cobrado debito_cobrado on (debito_cobrado.cnta_id = conta.cnta_id) " +
					        "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=debito_cobrado.dbtp_id) " +
					        "inner join arrecadacao.pagamento pagamento on (pagamento.cnta_id = conta.cnta_id and pagamento.pgmt_amreferenciaarrecadacao between :anoMesInicial and :anoMesFinal) " +
					        "group by doacao.eben_id, doacao.imov_id, dbcb_vlprestacao, pgmt_amreferenciaarrecadacao " +
					       "UNION ALL " +
					       "select doacao.eben_id, doacao.imov_id, dbhi_vlprestacao, pghi_amreferenciaarrecadacao " +
					         "from cadastro.imovel_doacoes doacao " +
					        "inner join cadastro.entidade_beneficente eb on (eb.eben_id = doacao.eben_id) " +
					        "inner join faturamento.conta_historico conta on (conta.imov_id = doacao.imov_id) " +
					        "inner join faturamento.debito_cobrado_historico debito_cobrado on (debito_cobrado.cnta_id = conta.cnta_id) " +
					        "inner join faturamento.debito_tipo debitoTipo on (debitoTipo.dbtp_nncodigoconstante = 1 and debitoTipo.dbtp_id=debito_cobrado.dbtp_id) " +
					        "inner join arrecadacao.pagamento_historico pagamento on (pagamento.cnta_id = conta.cnta_id and pagamento.pghi_amreferenciapagamento between :anoMesInicial and :anoMesFinal) " +
					        "group by doacao.eben_id, doacao.imov_id, dbhi_vlprestacao, pghi_amreferenciaarrecadacao " +
					       ") as pagamento " +
					      "inner join cadastro.imovel im on (im.imov_id = pagamento.imov_id) " +
					      "inner join cadastro.localidade lc on (im.loca_id = lc.loca_id) " +
					      "inner join cadastro.unidade_negocio un on (un.uneg_id = lc.uneg_id) " +
					      "inner join cadastro.gerencia_regional gr on (un.greg_id = gr.greg_id) " +
					      " " + sqlWhere+ " " +
					      "group by lc.loca_id, un.uneg_id, gr.greg_id, pagamento.eben_id  " +
					    ") total " ;    
						
			retorno =  (Integer) session.createSQLQuery(consulta)
						.addScalar("contadorTotal", Hibernate.INTEGER)							
						.setString("anoMesInicial", anoMesInicial)
						.setString("anoMesFinal", anoMesFinal).uniqueResult();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas 
	 *
	 * @author Raphael Rossiter
	 * @date 13/04/2010
	 *
	 * @param idDebitoACobrar
	 * @param numeroPrestacoesCobradas
	 * @param numeroPrestacoesAntecipadas
	 * @throws ErroRepositorioException
	 */
	public void atualizarNumeroPrestacoesAntecipadasECobradas(Integer idDebitoACobrar, Integer numeroPrestacoesCobradas,
			Integer numeroPrestacoesAntecipadas) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarDebitoACobrar;

		try {

			atualizarDebitoACobrar = "UPDATE DebitoACobrar "
					+ "SET dbac_nnprestacaocobradas = :numeroPrestacoesCobradas, "
					+ "dbac_nnparcelasantecipadas = :numeroPrestacoesAntecipadas, dbac_tmultimaalteracao = :dataCorrente "
					+ "WHERE dbac_id = :idDebitoACobrar ";

			session.createQuery(atualizarDebitoACobrar)
					.setShort("numeroPrestacoesCobradas", Short.valueOf(numeroPrestacoesCobradas.toString()))
					.setShort("numeroPrestacoesAntecipadas", Short.valueOf(numeroPrestacoesAntecipadas.toString()))
					.setTimestamp("dataCorrente", new Date())
					.setInteger("idDebitoACobrar", idDebitoACobrar).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas 
	 *
	 * @author Raphael Rossiter
	 * @date 14/04/2010
	 *
	 * @param idCreditoARealizar
	 * @param numeroPrestacoesRealizadas
	 * @param numeroPrestacoesAntecipadas
	 * @throws ErroRepositorioException
	 */
	public void atualizarNumeroPrestacoesAntecipadasERealizadas(Integer idCreditoARealizar, Integer numeroPrestacoesRealizadas,
			Integer numeroPrestacoesAntecipadas) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarCreditoARealizar;

		try {

			atualizarCreditoARealizar = "UPDATE CreditoARealizar "
					+ "SET crar_nnprestacaorealizadas = :numeroPrestacoesRealizadas, "
					+ "crac_nnparcelasantecipadas = :numeroPrestacoesAntecipadas, crar_tmultimaalteracao = :dataCorrente "
					+ "WHERE crar_id = :idCreditoARealizar ";

			session.createQuery(atualizarCreditoARealizar)
					.setShort("numeroPrestacoesRealizadas", Short.valueOf(numeroPrestacoesRealizadas.toString()))
					.setShort("numeroPrestacoesAntecipadas", Short.valueOf(numeroPrestacoesAntecipadas.toString()))
					.setTimestamp("dataCorrente", new Date())
					.setInteger("idCreditoARealizar", idCreditoARealizar).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	
	/**
	 * 
	 * [UC0259]  Processar Pagamento com Código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas.
	 *
	 * @author Raphael Rossiter
	 * @date 19/04/2010
	 *
	 * @param idParcelamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public DebitoACobrar pesquisarDebitoACobrarJurosParcelamento(Integer idParcelamento)
	throws ErroRepositorioException {

		DebitoACobrar retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		String consulta;
		
		try {
			
			consulta = "select dbac from DebitoACobrar dbac "
					+ "inner join dbac.parcelamento parc "
					+ "inner join dbac.financiamentoTipo fntp "
					+ "where parc.id = :idParcelamento "
					+ "and fntp.id = :jurosParcelamento ";
		
			retorno = (DebitoACobrar) session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento)
					.setInteger("jurosParcelamento", FinanciamentoTipo.JUROS_PARCELAMENTO)
					.setMaxResults(1).uniqueResult();
		
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		// retorna a coleção de débitos a cobrar
		return retorno;
	}
	
	
	/**
	 * [UC0259]  Processar Pagamento com Código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas. 
	 *
	 * @author Raphael Rossiter
	 * @date 19/04/2010
	 *
	 * @param debitoACobrar
	 * @throws ErroRepositorioException
	 */
	public void atualizarNumeroParcelasBonus(DebitoACobrar debitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarDebitoACobrar;

		try {

			atualizarDebitoACobrar = "UPDATE DebitoACobrar "
					+ "SET dbac_nnparcelabonus = :numeroParcelaBonus, "
					+ "dbac_tmultimaalteracao = :dataCorrente "
					+ "WHERE dbac_id = :idDebitoACobrar ";

			session.createQuery(atualizarDebitoACobrar)
					.setShort("numeroParcelaBonus", debitoACobrar.getNumeroParcelaBonus())
					.setTimestamp("dataCorrente", new Date())
					.setInteger("idDebitoACobrar", debitoACobrar.getId()).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Arthur Carvalho
	 * @date 12/05/10
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoAvisoBancarioCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ErroRepositorioException {

		int retorno = 0;
		Object pagamentoHistoricoAvisoBancarioCount;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, 
                    valorPagamentoInicial, 
                    valorPagamentoFinal);

			hql = " select count (pagamentoHistorico.id) "
					+ " from gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
					+ " inner join pagamentoHistorico.avisoBancario as avisoBancario "
					+ condicionais + " ";

			pagamentoHistoricoAvisoBancarioCount = session.createQuery(hql)
					.setMaxResults(1).uniqueResult();

			if (pagamentoHistoricoAvisoBancarioCount != null) {
				retorno = (Integer) pagamentoHistoricoAvisoBancarioCount;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos historico
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamentoHistorico
	 * 
	 * @author Arthur Carvalho
	 * @date 12/05/10
	 * @return
	 */
	public String criarCondicionaisPagamentoHistorico(String idImovel, String idCliente,
			String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal) {

		String hql = "";
		if (idImovel != null && !idImovel.equals("")) {
			hql = hql + " pagamentoHistorico.imovel.id = " + idImovel + " and ";
		}
		if (idCliente != null && !idCliente.equals("")) {
			// sql = sql + " clienteContas.cliente.id = " + idCliente + " and "
			// ;
			hql = hql + " pagamentoHistorico.cliente.id = " + idCliente + " and ";
		}
		if (idTipoRelacao != null && !idTipoRelacao.equals("")) {
			hql = hql + " clienteRelacaoTipo.id = " + idTipoRelacao + " and ";
		}
		if (localidadeInicial != null && localidadeFinal != null
				&& !localidadeInicial.equals("") && !localidadeFinal.equals("")) {
			hql = hql + " pagamento.localidade.id >= " + localidadeInicial
					+ " and ";
			hql = hql + " pagamento.localidade.id <= " + localidadeFinal
					+ " and ";
		}
		if (idAvisoBancario != null && !idAvisoBancario.equals("")) {
			hql = hql + " pagamentoHistorico.avisoBancario.id = " + idAvisoBancario
					+ " and ";
		}
		if (idArrecadador != null && !idArrecadador.equals("")) {
			hql = hql + " pagamentoHistorico.arrecadadorMovimentoItem.arrecadadorMovimento.id = " + idArrecadador + " and ";
		}
		if (periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoInicial.equals("")) {
			hql = hql
					+ " pagamentoHistorico.anoMesReferenciaArrecadacao >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
					+ " and ";
		}
		if (periodoArrecadacaoFinal != null
				&& !periodoArrecadacaoFinal.equals("")) {
			hql = hql
					+ " pagamentoHistorico.anoMesReferenciaArrecadacao <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal)
					+ " and ";
		}
		if (periodoPagamentoInicio != null
				&& !periodoPagamentoInicio.equals("")) {
			hql = hql
					+ " pagamentoHistorico.anoMesReferenciaPagamento >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
					+ " and ";
		}
		if (periodoPagamentoFim != null && !periodoPagamentoFim.equals("")) {
			hql = hql
					+ " pagamentoHistorico.anoMesReferenciaPagamento <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim)
					+ " and ";
		}

		if (dataPagamentoInicial != null && !dataPagamentoInicial.equals("")) {
			// sql = sql + " pagamento.dataPagamento >= '" +
			// Util.formatarData(dataPagamentoInicial) + "' and " ;
			String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

			if (data1 != null && !data1.equals("")
					&& data1.trim().length() == 8) {

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6)
						+ "-" + data1.substring(6, 8);
			}
			hql = hql + " pagamentoHistorico.dataPagamento >= to_date('" + data1 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}
		if (dataPagamentoFinal != null && !dataPagamentoFinal.equals("")) {
			// sql = sql + " pagamento.dataPagamento <= '" +
			// Util.formatarData(dataPagamentoFinal) + "' and " ;
			String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

			if (data2 != null && !data2.equals("")
					&& data2.trim().length() == 8) {

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6)
						+ "-" + data2.substring(6, 8);
			}
			hql = hql + " pagamentoHistorico.dataPagamento <= to_date('" + data2 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}

		if (idsPagamentosSituacoes != null
				&& !idsPagamentosSituacoes.equals("")) {
			String valoresIn = "";
			for (int i = 0; i < idsPagamentosSituacoes.length; i++) {
				if (!idsPagamentosSituacoes[i].equals("")) {
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				hql = hql + " pagamentoHistorico.pagamentoSituacaoAtual.id in ("
						+ valoresIn;
				hql = Util.removerUltimosCaracteres(hql, 1);
				hql = hql + ") and ";
			}
		}
		if (idsDebitosTipos != null
				&& !idsDebitosTipos.equals("")
				&& !idsDebitosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDebitosTipos.length; i++) {
				if (!idsDebitosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				hql = hql + " pagamentoHistorico.debitoTipo.id in (" + valoresIn;
				hql = Util.removerUltimosCaracteres(hql, 1);
				hql = hql + ") and ";
			}
		}
		if (idsArrecadacaoForma != null
				&& !idsArrecadacaoForma.equals("")
				&& !idsArrecadacaoForma[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsArrecadacaoForma.length; i++) {
				if (!idsArrecadacaoForma[i].equals("")) {
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				hql = hql + " pagamentoHistorico.arrecadacaoForma.id in (" + valoresIn;
				hql = Util.removerUltimosCaracteres(hql, 1);
				hql = hql + ") and ";
			}
		}
		if (idsDocumentosTipos != null
				&& !idsDocumentosTipos.equals("")
				&& !idsDocumentosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDocumentosTipos.length; i++) {
				if (!idsDocumentosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				hql = hql + " pagamentoHistorico.documentoTipo.id in (" + valoresIn;
				hql = Util.removerUltimosCaracteres(hql, 1);
				hql = hql + ") and ";
			}
		}
        
        if ( valorPagamentoInicial != null && !valorPagamentoInicial.equals( "" ) &&
             valorPagamentoFinal != null && !valorPagamentoFinal.equals( "" )   ){
        	hql += " pagamentoHistorico.valorPagamento between " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoInicial ) + 
                " and " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoFinal ) + " and ";
        }

		// retira o " and " q fica sobrando no final da query
        hql = Util.removerUltimosCaracteres(hql, 4);
		

		return hql;
	}

	/**
	 * [UC0322] Inserir Guia Devolucao.
	 * 
	 * [FS0023] Verificar crédito a realizar. Verificarasds 
	 *
	 * @author Hugo Leonardo
	 * @date 26/05/2010
	 *
	 * @param idImovel, anoMesReferenciaConta
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaCreditoARealizar(Integer idImovel, Integer anoMesReferenciaConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();
		try {
			// cria o HQL para consulta
			String consulta = " select creditoARealizar.id "
					+ " from CreditoARealizar creditoARealizar "
					+ " where creditoARealizar.imovel = :idImovel "
					+ " and creditoARealizar.anoMesReferenciaCredito = :anoMesReferencia "
					+ " and creditoARealizar.creditoTipo = :tipoCredito";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesReferencia", anoMesReferenciaConta)
					.setInteger("tipoCredito", CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE)
					.setMaxResults(1).uniqueResult();

		// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}
	
	/**
	 * [UC0322] Inserir Guia Devolucao.
	 * 
	 * [FS0023] Verificar crédito a realizar Histórico. Verificarasds 
	 *
	 * @author Hugo Leonardo
	 * @date 26/05/2010
	 *
	 * @param idImovel, anoMesReferenciaConta
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaCreditoARealizarHistorico(Integer idImovel, Integer anoMesReferenciaConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();
		try {
			// cria o HQL para consulta
			String consulta = " select creditoARealizarHistorico.id "
					+ " from CreditoARealizarHistorico creditoARealizarHistorico "
					+ " where creditoARealizarHistorico.imovel = :idImovel "
					+ " and creditoARealizarHistorico.anoMesReferenciaCredito = :anoMesReferenciaConta "
					+ " and creditoARealizarHistorico.creditoTipo = :tipoCredito";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesReferenciaConta", anoMesReferenciaConta)
					.setInteger("tipoCredito",CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE)
					.setMaxResults(1).uniqueResult();

		// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}
	
	/**
	 * [UC0194] Inserir Crédito a realizar.
	 * 		[FS0013] Verificar Guia devolução. Verificarasds 
	 *
	 * @author Hugo Leonardo
	 * @date 27/05/2010
	 *
	 * @param idImovel, anoMesReferenciaGuiaDevolucao
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaGuiaDevolucao(Integer idImovel, Integer anoMesReferenciaGuiaDevolucao)
			throws ErroRepositorioException {

		Integer retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();
		try {
			// cria o HQL para consulta
			String consulta = " select guiaDevolucao.id "
					+ " from GuiaDevolucao guiaDevolucao "
					+ " where guiaDevolucao.imovel = :idImovel "
					+ " and guiaDevolucao.anoMesReferenciaGuiaDevolucao = :anoMesGuiaDevolucao "
					+ " and guiaDevolucao.documentoTipo = :tipoDocumento ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesGuiaDevolucao", anoMesReferenciaGuiaDevolucao)
					.setInteger("tipoDocumento",DocumentoTipo.CONTA)
					.setMaxResults(1).uniqueResult();

		// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0006 Distribuir Dados do Registro de Movimento do Arrecadador] 
	 *
	 * @author Raphael Rossiter
	 * @date 08/06/2010
	 *
	 * @param parcelamentoPagamentoCartaoCredito
	 * @throws ErroRepositorioException
	 */
	public void confirmarPagamentoCartaoCreditoOperadora(ParcelamentoPagamentoCartaoCredito parcelamentoPagamentoCartaoCredito) 
		throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarParcelamentoPagamentoCartaoCredito;

		try {

			atualizarParcelamentoPagamentoCartaoCredito = "UPDATE ParcelamentoPagamentoCartaoCredito "
					+ "SET pacc_icconfirmadooperadora = :indicadorConfirmadoOperadora, "
					+ "pacc_dtconfirmadooperadora = :dataConfirmadoOperadora, "
					+ "pacc_vlconfirmadooperadora = :valorConfirmadoOperadora, "
					+ "pacc_tmultimaalteracao = :dataCorrente "
					+ "WHERE pacc_id = :idParcelamentoPagamentoCartaoCredito ";

			session.createQuery(atualizarParcelamentoPagamentoCartaoCredito)
					.setShort("indicadorConfirmadoOperadora", parcelamentoPagamentoCartaoCredito.getIndicadorConfirmadoOperadora())
					.setDate("dataConfirmadoOperadora", parcelamentoPagamentoCartaoCredito.getDataConfirmadoOperadora())
					.setBigDecimal("valorConfirmadoOperadora", parcelamentoPagamentoCartaoCredito.getValorConfirmadoOperadora())
					.setTimestamp("dataCorrente", new Date())
					.setInteger("idParcelamentoPagamentoCartaoCredito", parcelamentoPagamentoCartaoCredito.getId()).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0006 Distribuir Dados do Registro de Movimento do Arrecadador] 
	 *
	 * @author Raphael Rossiter
	 * @date 08/06/2010
	 *
	 * @param pagamentoCartaoDebito
	 * @throws ErroRepositorioException
	 */
	public void confirmarPagamentoCartaoDebitoOperadora(PagamentoCartaoDebito pagamentoCartaoDebito) 
		throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarParcelamentoPagamentoCartaoCredito;

		try {

			atualizarParcelamentoPagamentoCartaoCredito = "UPDATE PagamentoCartaoDebito "
					+ "SET pacd_icconfirmadooperadora = :indicadorConfirmadoOperadora, "
					+ "pacd_dtconfirmadooperadora = :dataConfirmadoOperadora, "
					+ "pacd_vlconfirmadooperadora = :valorConfirmadoOperadora, "
					+ "pacd_tmultimaalteracao = :dataCorrente "
					+ "WHERE pacd_id = :idPagamentoCartaoDebito ";

			session.createQuery(atualizarParcelamentoPagamentoCartaoCredito)
					.setShort("indicadorConfirmadoOperadora", pagamentoCartaoDebito.getIndicadorConfirmadoOperadora())
					.setDate("dataConfirmadoOperadora", pagamentoCartaoDebito.getDataConfirmadoOperadora())
					.setBigDecimal("valorConfirmadoOperadora", pagamentoCartaoDebito.getValorConfirmadoOperadora())
					.setTimestamp("dataCorrente", new Date())
					.setInteger("idPagamentoCartaoDebito", pagamentoCartaoDebito.getId()).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * 
	 * [UC0511] Filtrar Contrato Arrecadador
	 * @author Arthur Carvalho
	 * @date 26/05/2010
	 *
	 */
	public boolean verificarExistenciaContrato( String numeroContrato ) throws ErroRepositorioException {

		boolean retorno = false;
		ArrecadadorContrato arrecadadorContrato = null;
		Session session = HibernateUtil.getSession();
		
		String consulta;
		
		try {
			
			consulta = "select arrecadador from ArrecadadorContrato arrecadador "
					+ "where arrecadador.numeroContrato = :numeroContrato";
		
			arrecadadorContrato = (ArrecadadorContrato) session.createQuery(consulta)
					.setString("numeroContrato", numeroContrato)
					.setMaxResults(1).uniqueResult();
		
			if ( arrecadadorContrato != null ) {
				retorno = true;
			}
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		// retorna a coleção de débitos a cobrar
		return retorno;
	}
	
	/**
	 * [UC0339] Consultar Dados Diários da Arrecadação
	 *
	 * @author Hugo Amorim
	 * @date 29/06/2010
	 *
	 * @throws ControladorException
	 */
	public Date pesquisarDataProcessamentoMes(Integer anoMes) throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		String consulta;
		Date retorno;

		try {

			consulta = "SELECT ultimaAlteracao"
					+" FROM"
					+" ArrecadacaoDadosDiarios"
					+" WHERE anoMesReferenciaArrecadacao = :anoMes"
					+" ORDER BY ultimaAlteracao DESC ";

			retorno = (Date) session.createQuery(consulta)
					.setInteger("anoMes", anoMes)
					.setMaxResults(1)
					.uniqueResult();


		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		
		// retorna a coleção de débitos a cobrar
		return retorno;
	}
	
	
	/**
	 * [UC0629] Consultar Arquivo Texto para Leitura
	 *
	 * @author Raphael Rossiter
	 * @date 29/06/2010
	 *
	 * @param helper
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer filtrarArquivoTextoRoteiroEmpresaCount(ConsultarArquivoTextoRoteiroEmpresaHelper helper)
			throws ErroRepositorioException {

		Integer arquivoTextoRoteiroEmpresaCount = null;
		String sql = "";

		Session session = HibernateUtil.getSession();

		try {
			
			String condicionais = this.criarCondicionaisArquivoTextoRoteiroEmpresa(helper);

			sql = " SELECT count (arquivoTexto.txre_id) as qtdeArquivoTexto "
					+ " FROM micromedicao.arquivo_texto_rot_empr arquivoTexto "
					+ condicionais;

			arquivoTextoRoteiroEmpresaCount = (Integer) session.createSQLQuery(sql)
			.addScalar("qtdeArquivoTexto", Hibernate.INTEGER).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return arquivoTextoRoteiroEmpresaCount;
	}
	
	/**
	 * [UC0629] Consultar Arquivo Texto para Leitura 
	 *
	 * @author Raphael Rossiter
	 * @date 29/06/2010
	 *
	 * @param helper
	 * @param numeroPagina
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarArquivoTextoRoteiroEmpresaParaPaginacao(ConsultarArquivoTextoRoteiroEmpresaHelper helper, Integer numeroPagina)
		throws ErroRepositorioException {

		Collection retorno = null;
		String sql = "";
		
		Session session = HibernateUtil.getSession();
		
		try {
			
			String condicionais = this.criarCondicionaisArquivoTextoRoteiroEmpresa(helper);
		
			sql = " SELECT arquivoTexto.txre_id as id, "//0
					+ " arquivoTexto.txre_amreferencia as anoMesReferencia, "//1
					+ " arquivoTexto.txre_qtimovel as qtdImovel, "//2
					+ " arquivoTexto.txre_nnsequencialeiturista as sequencialLeiturista, "//3
					+ " arquivoTexto.txre_nmarquivo as nomeArquivo, "//4
					+ " arquivoTexto.txre_nnfoneleiturista as foneLeiturista, "//5
					+ " arquivoTexto.rota_id as idRota, "//6
					+ " rota.rota_cdrota as codigoRota, "//7
					+ " arquivoTexto.stce_id as servicoTipoCelular, "//8
					+ " sitl.sitl_id as idSituacaoTransmissaoLeitura, "//9
					+ " sitl.sitl_dssituacao as descSituacaoTransmissaoLeitura, "//10
					+ " arquivoTexto.loca_id as localidade, "//11
					+ " arquivoTexto.txre_cdsetorcomercial1 as codigoSetor1, "//12
					+ " arquivoTexto.ftgr_id as faturamentoGrupo, "//13
					+ " cliente.clie_nmcliente as nomeCliente, "//14
					+ " funcionario.func_nmfuncionario as nomeFuncionario, "//15
					+ " arquivoTexto.txre_tmultimaalteracao as ultimaAlteracao, "//16
					+ " arquivoTexto.txre_nnimei as numeroImei, "//17
					+ " rota.rota_nnlimiteimoveis as numeroLimiteImoveis, "//18
					+ " empresa.empr_nmempresa as nomeEmpresa, "//19
					+ " localidade.loca_nmlocalidade as nomeLocalidade,"//20
					+ " serTip.stce_dsservicotipocelular as servicoTipo"//21
					+ " FROM micromedicao.arquivo_texto_rot_empr arquivoTexto "
					+ " LEFT JOIN micromedicao.rota rota on rota.rota_id = arquivoTexto.rota_id "
					+ " LEFT JOIN micromedicao.situacao_transm_leitura sitl on sitl.sitl_id = arquivoTexto.sitl_id "
					+ " LEFT JOIN micromedicao.leiturista leiturista on leiturista.leit_id = arquivoTexto.leit_id "
					+ " LEFT JOIN cadastro.cliente cliente on cliente.clie_id = leiturista.clie_id "
					+ " LEFT JOIN cadastro.empresa empresa on empresa.empr_id = arquivoTexto.empr_id "
					+ " LEFT JOIN cadastro.localidade localidade on localidade.loca_id = arquivoTexto.loca_id "
					+ " LEFT JOIN micromedicao.servico_tipo_celular serTip on serTip.stce_id = arquivoTexto.stce_id "
					+ " LEFT JOIN cadastro.funcionario funcionario on funcionario.func_id = leiturista.func_id "
					+ condicionais
					/**
					 * 
					 * 03/05/2011 - Pamela Gatinho
					 * Adicionando campos (localidade, setor e rota) para 
					 * ordenacao da consulta de arquivos de rota
					 */
					+ " ORDER BY localidade, codigoSetor1, codigoRota, sequencialLeiturista, leiturista.leit_id, " 
					+ " idSituacaoTransmissaoLeitura, servicoTipoCelular ";
		
			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("anoMesReferencia", Hibernate.INTEGER)
					.addScalar("qtdImovel", Hibernate.INTEGER)
					.addScalar("sequencialLeiturista", Hibernate.INTEGER)
					.addScalar("nomeArquivo", Hibernate.STRING)
					.addScalar("foneLeiturista", Hibernate.STRING)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("codigoRota", Hibernate.SHORT)
					.addScalar("servicoTipoCelular", Hibernate.INTEGER)
					.addScalar("idSituacaoTransmissaoLeitura", Hibernate.INTEGER)
					.addScalar("descSituacaoTransmissaoLeitura", Hibernate.STRING)
					.addScalar("localidade", Hibernate.INTEGER)
					.addScalar("codigoSetor1", Hibernate.INTEGER)
					.addScalar("faturamentoGrupo", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("nomeFuncionario", Hibernate.STRING)
					.addScalar("ultimaAlteracao", Hibernate.TIMESTAMP)
					.addScalar("numeroImei", Hibernate.LONG)
					.addScalar("numeroLimiteImoveis", Hibernate.INTEGER)
					.addScalar("nomeEmpresa", Hibernate.STRING)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("servicoTipo", Hibernate.STRING )					
					.list();
		
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	
	/**
	 * [UC0629] Consultar Arquivo Texto para Leitura 
	 *
	 * @author Raphael Rossiter
	 * @date 29/06/2010
	 *
	 * @param helper
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public String criarCondicionaisArquivoTextoRoteiroEmpresa(ConsultarArquivoTextoRoteiroEmpresaHelper helper) 
		throws ErroRepositorioException{

		String where = " WHERE ";

		// ------------------- Where -------------------------
		
		//ANO MES REFERENCIA
		if (helper.getAnoMesReferencia() != null && !helper.getAnoMesReferencia().equals("")) {
			where = where + " arquivoTexto.txre_amreferencia = "
					+ helper.getAnoMesReferencia() + " and ";
		}

		//FATURAMENTO_GRUPO
		if (helper.getIdFaturamentoGrupo() != null && !helper.getIdFaturamentoGrupo().equals("")) {
			where = where + " arquivoTexto.ftgr_id = "
					+ helper.getIdFaturamentoGrupo() + " and ";
		}

		//EMPRESA
		if (helper.getIdEmpresa() != null && !helper.getIdEmpresa().equals("")) {
			where = where + " arquivoTexto.empr_id = "
					+ helper.getIdEmpresa() + " and ";
		}
		
		//SITUACAO_TRANSMISSAO_LEITURA
		if (helper.getIdSituacaoTransmissaoLeitura() != null && !helper.getIdSituacaoTransmissaoLeitura().equals("")) {
			where = where + " arquivoTexto.sitl_id = "
					+ helper.getIdSituacaoTransmissaoLeitura() + " and ";
		}
		
		//SERVICO_TIPO_CELULAR
		if (helper.getIdServicoTipoCelular() != null && !helper.getIdServicoTipoCelular().equals("")) {
			where = where + " arquivoTexto.stce_id = "
					+ helper.getIdServicoTipoCelular() + " and ";
		}
		
		//LEITURISTA
		if (helper.getIdLeiturista() != null && !helper.getIdLeiturista().equals("")) {
			where = where + " arquivoTexto.leit_id = "
					+ helper.getIdLeiturista() + " and ";
		}
		
		//LOCALIDADE
		if (helper.getIdLocalidade() != null && !helper.getIdLocalidade().equals("")) {
			where = where + " arquivoTexto.loca_id = "
					+ helper.getIdLocalidade() + " and ";
		}
		
		where = where.substring(0, where.length() - 5);
		
		return where;
	}
	
	/**
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 *
	 * @author Hugo Amorim
	 * @date 21/06/2010
	 *
	 * @throws ErroRepositorioException
	 */
	public Integer relatorioAnalisePagamentoCartaoDebitoCount(
			ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper helper)
			throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		Integer relatorioAnalisePagamentoCartaoDebitoCount = null;
		String hql = "";
		Query query = null;

		try {
			
			hql = " SELECT COUNT(*) "
				+ " FROM PagamentoCartaoDebito pag " 
				+ this.criarCondicionaisRelatorioAnalisePagamentoCartaoDebito(helper);
			
			//Cria query
			query = session.createQuery(hql);
			//Seta paramentros na query
			query = this.setarParametrosRelatorioAnalisePagamentoCartaoDebito(helper,query);
			//Executa query
			relatorioAnalisePagamentoCartaoDebitoCount = (Integer) query.setMaxResults(1).uniqueResult();
			
			//Caso não encontre nenhum registro atrinui valor 0(zero) ao retorno.
			if(relatorioAnalisePagamentoCartaoDebitoCount==null){
				relatorioAnalisePagamentoCartaoDebitoCount = 0;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return relatorioAnalisePagamentoCartaoDebitoCount;
	}
	
	/**
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 *
	 * @author Hugo Amorim
	 * @date 21/06/2010
	 *
	 * @throws ErroRepositorioException
	 */
	private String criarCondicionaisRelatorioAnalisePagamentoCartaoDebito(
			ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper helper) 
		throws ErroRepositorioException{

		String where = " WHERE ";

		// ------------------- Where -------------------------
		
		//Período de Confirmação do Pagamento.
		if (helper.getDataConfirmacaoPagamentoInicial() != null && !helper.getDataConfirmacaoPagamentoInicial().equals("")
				&& helper.getDataConfirmacaoPagamentoFinal() != null && !helper.getDataConfirmacaoPagamentoFinal().equals("")) {
			where = where + " pag.dataConfirmacao BETWEEN " 
				+ " 	:dataConfirmacaoPagametoInicial AND :dataConfirmacaoPagametoFinal AND ";
		}
		
		//Usuário Confirmação Pagamento 
		if (helper.getIdUsuarioConfirmacao() != null 
				&& !helper.getIdUsuarioConfirmacao().equals("")) {
			where = where + " pag.usuarioConfirmacao.id = :usuarioConfirmacao AND ";
		}
		
		//Situação da Confirmação da Operadora 
		if (helper.getIndicadorConfirmacaoOperadora() != null 
				&& !helper.getIndicadorConfirmacaoOperadora().equals("")
				&& !helper.getIndicadorConfirmacaoOperadora().equals("3")) {
			where = where + " pag.indicadorConfirmadoOperadora = :indicadorConfirmadoOperadora AND ";
		}
		
		//Período de Confirmação da Operadora
		if (helper.getDataConfirmacaoOperadoraInicial() != null && !helper.getDataConfirmacaoOperadoraInicial().equals("")
				&& helper.getDataConfirmacaoOperadoraFinal() != null && !helper.getDataConfirmacaoOperadoraFinal().equals("")) {		
			where = where + " pag.dataConfirmadoOperadora BETWEEN " 
				+ " 	:dataConfirmadoOperadoraInicial AND :dataConfirmadoOperadoraFinal AND ";
		}

		where = where.substring(0, where.length() - 5);
		
		return where;
	}
	
	/**
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 *
	 * @author Hugo Amorim
	 * @date 21/06/2010
	 *
	 * @throws ErroRepositorioException
	 */
	private Query setarParametrosRelatorioAnalisePagamentoCartaoDebito(
			ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper helper,Query query)
			throws ErroRepositorioException{

		// ------------------- Where -------------------------
		
		//Período de Confirmação do Pagamento.
		if (helper.getDataConfirmacaoPagamentoInicial() != null && !helper.getDataConfirmacaoPagamentoInicial().equals("")
				&& helper.getDataConfirmacaoPagamentoFinal() != null && !helper.getDataConfirmacaoPagamentoFinal().equals("")) {		
			query.setDate("dataConfirmacaoPagametoInicial", 
					Util.converteStringParaDate(helper.getDataConfirmacaoPagamentoInicial()));
			query.setDate("dataConfirmacaoPagametoFinal", 
					Util.converteStringParaDate(helper.getDataConfirmacaoPagamentoFinal()));
		}
		
		//Usuário Confirmação Pagamento 
		if (helper.getIdUsuarioConfirmacao() != null 
				&& !helper.getIdUsuarioConfirmacao().equals("")) {			
			query.setInteger("usuarioConfirmacao", new Integer(helper.getIdUsuarioConfirmacao()));
		}
		
		//Situação da Confirmação da Operadora 
		if (helper.getIndicadorConfirmacaoOperadora() != null 
				&& !helper.getIndicadorConfirmacaoOperadora().equals("")
				&& !helper.getIndicadorConfirmacaoOperadora().equals("3")) {		
			query.setShort("indicadorConfirmadoOperadora", new Short(helper.getIndicadorConfirmacaoOperadora()));		
		}
		
		//Período de Confirmação da Operadora
		if (helper.getDataConfirmacaoOperadoraInicial() != null && !helper.getDataConfirmacaoOperadoraInicial().equals("")
				&& helper.getDataConfirmacaoOperadoraFinal() != null && !helper.getDataConfirmacaoOperadoraFinal().equals("")) {		
			query.setDate("dataConfirmadoOperadoraInicial", 
					Util.converteStringParaDate(helper.getDataConfirmacaoOperadoraInicial()));
			query.setDate("dataConfirmadoOperadoraFinal", 
					Util.converteStringParaDate(helper.getDataConfirmacaoOperadoraFinal()));	
		}
		
		return query;
	}
	
	/**
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 *
	 * @author Hugo Amorim
	 * @date 21/06/2010
	 *
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDadosRelatorioAnalisePagamentoCartaoDebito(
			ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper helper)
			throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		Collection<Object[]> dadosRelatorioAnalisePagamentoCartaoDebito = null;
		String hql = "";
		Query query = null;

		try {
			
			hql = " SELECT "
				+ " pag.id, "
				+ " pag.numeroCartaoDebito, "
				+ " cliente.nome, "
				+ " pag.dataConfirmacao, "
				+ " pag.valorPagamento, "
				+ " usuarioConfirmacao.nomeUsuario," 
				+ " CASE "
				+ " WHEN pag.indicadorConfirmadoOperadora = 1 THEN 'CONFIRMADO' " 
				+ " WHEN pag.indicadorConfirmadoOperadora = 2 THEN 'NÃO CONFIRMADO' "
				+ " END, "
				+ " pag.dataConfirmadoOperadora, "
				+ " pag.valorConfirmadoOperadora "
				+ " FROM PagamentoCartaoDebito pag " 
				+ " INNER JOIN pag.cliente cliente " 
				+ " INNER JOIN pag.usuarioConfirmacao usuarioConfirmacao " 
				+ this.criarCondicionaisRelatorioAnalisePagamentoCartaoDebito(helper);
			
			//Cria query
			query = session.createQuery(hql);
			//Seta paramentros na query
			query = this.setarParametrosRelatorioAnalisePagamentoCartaoDebito(helper,query);
			//Executa query
			dadosRelatorioAnalisePagamentoCartaoDebito = query.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return dadosRelatorioAnalisePagamentoCartaoDebito;
	}
	
	/**
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 *
	 * @author Hugo Amorim
	 * @date 21/06/2010
	 *
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDadosItenRelatorioAnalisePagamentoCartaoDebito(
			Integer idPagamentoCartaoDebito) throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		Collection<Object[]> dadosRelatorioAnalisePagamentoCartaoDebito = null;
		String sql = "";

		try {
			
			sql= " SELECT \n"
				+" CASE " 
				+" WHEN pcdi.cnta_id is not null THEN \n"
				+" 	(SELECT c.imov_id FROM faturamento.conta c WHERE pcdi.cnta_id = c.cnta_id  \n"
				+" 		UNION SELECT ch.imov_id FROM faturamento.conta_historico ch WHERE pcdi.cnta_id = ch.cnta_id) \n"
				+" WHEN gpag_id is not null THEN \n"
				+" 	(SELECT gp.imov_id FROM faturamento.guia_pagamento gp WHERE  pcdi.gpag_id = gp.gpag_id \n"
				+" 		UNION SELECT gph.imov_id FROM faturamento.guia_pagamento_historico gph  WHERE  pcdi.gpag_id = gph.gpag_id) \n"
				+" WHEN dbac_id is not null THEN \n"
				+"  (SELECT dac.imov_id FROM faturamento.debito_a_cobrar dac WHERE  pcdi.dbac_id = dac.dbac_id \n"
				+" 		UNION SELECT dach.imov_id FROM faturamento.deb_a_cobrar_hist dach WHERE  pcdi.dbac_id = dach.dbac_id) \n" 
				+"  END as imovel, \n"
				+"  CASE WHEN pcdi.cnta_id is not null THEN \n"
				+"  		'1' \n"
				+"   	 WHEN pcdi.gpag_id is not null THEN \n"
				+"    		'2' \n"
				+"   	 WHEN pcdi.dbac_id is not null THEN \n"
				+"    		'3' \n"
				+"    	 END as tipo, \n"
				+"  CASE WHEN pcdi.cnta_id is not null THEN \n"
				+"  		pcdi.cnta_id \n"
				+"   	 WHEN pcdi.gpag_id is not null THEN \n"
				+"    		pcdi.gpag_id \n"
				+"   	 WHEN pcdi.dbac_id is not null THEN \n"
				+"    		pcdi.dbac_id \n"
				+"    	 END as id \n"
				+" FROM arrecadacao.pagto_cartao_debito_item pcdi \n" 
				+" WHERE pacd_id = :idPagamentoCartaoDebito \n"
				+" ORDER BY 2 ";

			
			//Executa query
			dadosRelatorioAnalisePagamentoCartaoDebito = session.createSQLQuery(sql)
				.addScalar("imovel",Hibernate.INTEGER)
				.addScalar("tipo", Hibernate.STRING)
				.addScalar("id",Hibernate.INTEGER)
				.setInteger("idPagamentoCartaoDebito", idPagamentoCartaoDebito)
				.list();
			
		
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return dadosRelatorioAnalisePagamentoCartaoDebito;
	}
	
	/**
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 *
	 * @author Hugo Amorim
	 * @date 21/06/2010
	 *
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDetalheItenRelatorioAnalisePagamentoCartaoDebito(
			Integer tipoItem, Integer idItem)throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		Collection<Object[]> dadosRelatorioAnalisePagamentoCartaoDebito = null;
		String sql = "";		
		String sqlResultado = "";

		try {
			
			switch (tipoItem) {
			case 1:
				sqlResultado =" (SELECT c.cnta_amreferenciaconta FROM faturamento.conta c WHERE c.cnta_id = pcdi.cnta_id \n"
					+" UNION SELECT ch.cnhi_amreferenciaconta FROM faturamento.conta_historico ch WHERE ch.cnta_id = pcdi.cnta_id) detalhe, \n"
					+" (SELECT (c.cnta_vlagua + c.cnta_vlesgoto + c.cnta_vldebitos - c.cnta_vlcreditos - coalesce( c.cnta_vlimpostos, 0 )) valor FROM faturamento.conta c WHERE c.cnta_id = pcdi.cnta_id \n"
					+" UNION SELECT (ch.cnhi_vlagua + ch.cnhi_vlesgoto + ch.cnhi_vldebitos - ch.cnhi_vlcreditos - coalesce( ch.cnhi_vlimpostos, 0 )) valor FROM faturamento.conta_historico ch WHERE ch.cnta_id = pcdi.cnta_id) valor \n";
				
				break;
			case 2:
				sqlResultado =" (SELECT dt.dbtp_dsdebitotipo FROM faturamento.guia_pagamento gp \n"
					+" 		INNER JOIN faturamento.debito_tipo dt on dt.dbtp_id = gp.dbtp_id \n"
					+" 		WHERE  gp.gpag_id = pcdi.gpag_id UNION \n" 
					+" 	SELECT dt.dbtp_dsdebitotipo FROM faturamento.guia_pagamento_historico gph \n"
					+" 		INNER JOIN faturamento.debito_tipo dt on dt.dbtp_id = gph.dbtp_id \n"
					+" 		WHERE  gph.gpag_id = pcdi.gpag_id) as detalhe, \n"
					+" 	(SELECT gp.gpag_vldebito FROM faturamento.guia_pagamento gp WHERE  pcdi.gpag_id = gp.gpag_id \n"
					+" 		UNION SELECT gph.gphi_vldebito FROM faturamento.guia_pagamento_historico gph  WHERE  pcdi.gpag_id = gph.gpag_id) valor\n";
				break;
			case 3:
				sqlResultado =	" (SELECT dt.dbtp_dsdebitotipo FROM faturamento.debito_a_cobrar dac \n"
						+" 		INNER JOIN faturamento.debito_tipo dt on dt.dbtp_id = dac.dbtp_id \n"
						+" 		WHERE  dac.dbac_id = pcdi.dbac_id UNION \n"
						+" 	SELECT dt.dbtp_dsdebitotipo FROM faturamento.deb_a_cobrar_hist dach \n"  
						+" 		INNER JOIN faturamento.debito_tipo dt on dt.dbtp_id = dach.dbtp_id \n"
						+" 		WHERE  dach.dbac_id = pcdi.dbac_id) as detalhe,"
						+" 	 (SELECT dac.dbac_vldebito FROM faturamento.debito_a_cobrar dac WHERE  pcdi.dbac_id = dac.dbac_id \n"
						+" 		UNION SELECT dach.dahi_vldebito FROM faturamento.deb_a_cobrar_hist dach WHERE  pcdi.dbac_id = dach.dbac_id) valor \n";
				break;
			default:
				break;
			}
			
			
			sql= " SELECT pcdi.paci_id as id, \n"
				+ sqlResultado
				+" FROM arrecadacao.pagto_cartao_debito_item pcdi  \n"
				+" WHERE cnta_id = :id or gpag_id = :id or dbac_id = :id ";

			
			//Executa query
			dadosRelatorioAnalisePagamentoCartaoDebito = session.createSQLQuery(sql)
				.addScalar("id",Hibernate.INTEGER)
				.addScalar("detalhe",Hibernate.STRING)
				.addScalar("valor", Hibernate.BIG_DECIMAL)
				.setInteger("id", idItem)
				.list();
			
		
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return dadosRelatorioAnalisePagamentoCartaoDebito;
	}
	
	
	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação 
	 *
	 * @author Raphael Rossiter
	 * @date 24/11/2010
	 *
	 * @param idConta
	 * @return CobrancaDocumento
	 * @throws ErroRepositorioException
	 */
	public CobrancaDocumento pesquisarCobrancaDocumentoProcessarFichaCompensacao(Integer idCobrancaDocumento)
			throws ErroRepositorioException {

		CobrancaDocumento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cbdo " + "from CobrancaDocumento cbdo "
					+ "left join fetch cbdo.imovel imov "
					+ "left join fetch imov.localidade locaImovel "
					+ "left join fetch cbdo.cliente clie "
					+ "left join fetch cbdo.localidade locaDocumento "
					+ "inner join fetch cbdo.documentoTipo dotp "
					+ "where cbdo.id = :idCobrancaDocumento ";

			retorno = (CobrancaDocumento) session.createQuery(consulta).setInteger(
					"idCobrancaDocumento", idCobrancaDocumento).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0339] Consultar Dados Diários da Arrecadação
	 *
	 * @author Mariana Victor
	 * @date 01/02/2011
	 *
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarFaturamentoCobradoEmConta(Integer anoMes)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT sum(rfat.rfat_vlitemfaturamento) AS valor " +
					" FROM financeiro.resumo_faturamento rfat" +
					" INNER JOIN financeiro.lancamento_tipo lctp ON rfat.lctp_id = lctp.lctp_id AND lctp.lctp_id = 25" +
					" INNER JOIN financeiro.lancamento_item lcit ON rfat.lcit_id = lcit.lcit_id AND lcit.lcit_id = 18" +
					" WHERE rfat.rfat_amreferencia = :anoMes ";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("anoMes", anoMes)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	
	/**
	 * [UC0339] Consultar Dados Diários da Arrecadação
	 *
	 * @author Mariana Victor
	 * @date 01/02/2011
	 *
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarFaturamentoCobradoEmContaComQuebra(Integer anoMes, Integer idGerenciaRegional, Integer idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT sum(rfat.rfat_vlitemfaturamento) AS valor " +
					" FROM financeiro.resumo_faturamento rfat" +
					" INNER JOIN financeiro.lancamento_tipo lctp ON rfat.lctp_id = lctp.lctp_id AND lctp.lctp_id = 25" +
					" INNER JOIN financeiro.lancamento_item lcit ON rfat.lcit_id = lcit.lcit_id AND lcit.lcit_id = 18" +
					" WHERE rfat.rfat_amreferencia = :anoMes ";
			
					if ( idGerenciaRegional != null ) {
						consulta = consulta + " and rfat.greg_id = " + idGerenciaRegional;
					}
					
					if ( idCategoria != null ) {
						consulta = consulta + " and rfat.catg_id = " + idCategoria;
					}

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("anoMes", anoMes)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	
	/**
	 * [UC0188] Manter Guia de Pagamento
	 *
	 * [FS0019]  Verificar bloqueio de guia de pagamento
	 * 
	 * @author Mariana Victor
	 * @date 27/04/2011
	 *
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> verificarBloqueioGuiaPagamento(Collection<GuiaPagamento> guiasPagamentos)
			throws ErroRepositorioException {

		Collection<Integer> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cpit.gpag_id AS idGuia "
				+ " FROM cobranca.contrato_parcel_item cpit "
				+ "   INNER JOIN cobranca.contrato_parcel cpar ON cpit.cpar_id = cpar.cpar_id "
				+ "   INNER JOIN cobranca.parcelamento_situacao pcst ON cpar.pcst_id = pcst.pcst_id "
				+ " WHERE pcst.pcst_id = 1 "
				+ "   AND cpit.gpag_id in ( ";
			
			Iterator iterator = guiasPagamentos.iterator();
			while (iterator.hasNext()) {
				GuiaPagamento guiaPagamento = (GuiaPagamento) iterator.next();
				
				consulta = consulta + guiaPagamento.getId() + ", "; 
			}
			
			consulta = Util.removerUltimosCaracteres(consulta, 2);
			consulta = consulta + " ) ";
			
			retorno = session.createSQLQuery(consulta)
					.addScalar("idGuia", Hibernate.INTEGER)
					.list();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	/**
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter
	 * @date 01/06/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesReferencia
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarPagamentoBatimentoRelatorioPrimeiraSituacao(Integer idLocalidade, Integer anoMesReferencia) 
		throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarPagamento;

		try {

			atualizarPagamento = "update Pagamento set pgst_idanterior = null, pgmt_tmultimaalteracao = :dataCorrente "
					+"where pgmt_amreferenciaarrecadacao = :anoMesReferencia and loca_id = :idLocalidade "
					+"and pgst_idatual not in (:VALOR_A_BAIXAR , :DUPLICIDADE_EXCESSO_DEVOLVIDO) and pgst_idanterior is not null";

			session.createQuery(atualizarPagamento)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setTimestamp("dataCorrente", new Date())
					.setInteger("VALOR_A_BAIXAR", PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("DUPLICIDADE_EXCESSO_DEVOLVIDO", PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO)
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter
	 * @date 01/06/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesReferencia
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarPagamentoBatimentoRelatorioSegundaSituacao(Integer idLocalidade, Integer anoMesReferencia) 
		throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
	
		String atualizarPagamento;
	
		try {
	
			atualizarPagamento = "update Pagamento set pgmt_vlexcedente = pgmt_vlpagamento, pgmt_tmultimaalteracao = :dataCorrente "
					+"where pgmt_amreferenciaarrecadacao = :anoMesReferencia and loca_id = :idLocalidade "
					+"and pgst_idatual in (:PAGAMENTO_EM_DUPLICIDADE , :DOCUMENTO_INEXISTENTE, :VALOR_A_BAIXAR, :DOCUMENTO_A_CONTABILIZAR) "
					+"and pgmt_vlexcedente <> pgmt_vlpagamento";
			
			session.createQuery(atualizarPagamento)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setTimestamp("dataCorrente", new Date())
					.setInteger("PAGAMENTO_EM_DUPLICIDADE", PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE)
					.setInteger("DOCUMENTO_INEXISTENTE", PagamentoSituacao.DOCUMENTO_INEXISTENTE)
					.setInteger("VALOR_A_BAIXAR", PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("DOCUMENTO_A_CONTABILIZAR", PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR)
					.executeUpdate();
	
		} catch (HibernateException e) {
	
			throw new ErroRepositorioException(e, "Erro no Hibernate");
	
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter
	 * @date 01/06/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesReferencia
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarPagamentoBatimentoRelatorioTerceiraSituacao(Integer idLocalidade, Integer anoMesReferencia) 
		throws ErroRepositorioException {
	
		Session session = HibernateUtil.getSession();
	
		String atualizarPagamento;
	
		try {
	
			atualizarPagamento = "update Pagamento set pgst_idanterior = :DOCUMENTO_INEXISTENTE, pgmt_tmultimaalteracao = :dataCorrente "
					+"where pgmt_amreferenciaarrecadacao = :anoMesReferencia and loca_id = :idLocalidade "
					+"and pgst_idatual = :VALOR_A_BAIXAR and pgst_idanterior = :VALOR_A_BAIXAR "
					+"and cnta_id is null and gpag_id is null and dbac_id is null and cbdo_id is null";
			
			session.createQuery(atualizarPagamento)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setTimestamp("dataCorrente", new Date())
					.setInteger("DOCUMENTO_INEXISTENTE", PagamentoSituacao.DOCUMENTO_INEXISTENTE)
					.setInteger("VALOR_A_BAIXAR", PagamentoSituacao.VALOR_A_BAIXAR)
					.executeUpdate();
	
		} catch (HibernateException e) {
	
			throw new ErroRepositorioException(e, "Erro no Hibernate");
	
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter
	 * @date 01/06/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesReferencia
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarPagamentoBatimentoRelatorioQuartaSituacao(Integer idLocalidade, Integer anoMesReferencia) 
		throws ErroRepositorioException {
	
		Session session = HibernateUtil.getSession();
	
		String atualizarPagamento;
	
		try {
	
			atualizarPagamento = "update Pagamento set pgst_idanterior = :PAGAMENTO_EM_DUPLICIDADE, pgmt_tmultimaalteracao = :dataCorrente "
					+"where pgmt_amreferenciaarrecadacao = :anoMesReferencia and loca_id = :idLocalidade "
					+"and pgst_idatual = :VALOR_A_BAIXAR and pgst_idanterior = :VALOR_A_BAIXAR "
					+"and (cnta_id is not null or gpag_id is not null or dbac_id is not null or cbdo_id is not null)";
			
			session.createQuery(atualizarPagamento)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idLocalidade", idLocalidade)
					.setTimestamp("dataCorrente", new Date())
					.setInteger("PAGAMENTO_EM_DUPLICIDADE", PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE)
					.setInteger("VALOR_A_BAIXAR", PagamentoSituacao.VALOR_A_BAIXAR)
					.executeUpdate();
	
		} catch (HibernateException e) {
	
			throw new ErroRepositorioException(e, "Erro no Hibernate");
	
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação
	 * 
	 * @author Mariana Victor
	 * @data 04/08/2011
	 */
	public CobrancaDocumentoItem pesquisarCobrancaDocumentoItemProcessarFichaCompensacao(Integer idPrestacao) 
		throws ErroRepositorioException {
		
		Object[] dados = null;
		CobrancaDocumentoItem retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
	
		try {
			
			consulta = " SELECT cbdo.cbdo_id AS idDocumento, " //0
					 + "   cbdo.clie_id AS idCliente, " //1
					 + "   cdit.cdit_id AS idItem, " //2
					 + "   cbdo.dotp_id AS idDocumentoTipo " //3
					 + " FROM cobranca.cobranca_documento_item cdit "
					 + "   INNER JOIN cobranca.cobranca_documento cbdo on cbdo.cbdo_id = cdit.cbdo_id "
					 + " WHERE cdit.cppr_id = :idPrestacao ";

			dados = (Object[]) session.createSQLQuery(consulta)
				.addScalar("idDocumento", Hibernate.INTEGER)
				.addScalar("idCliente", Hibernate.INTEGER)
				.addScalar("idItem", Hibernate.INTEGER)
				.addScalar("idDocumentoTipo", Hibernate.INTEGER)
				.setInteger("idPrestacao", idPrestacao)
				.setMaxResults(1).uniqueResult();
			
			if (dados != null) {
				CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
				retorno = new CobrancaDocumentoItem();

				if (dados[0] != null) {
					cobrancaDocumento.setId((Integer) dados[0]);
				}
				
				if (dados[1] != null) {
					Cliente cliente = new Cliente(); 
					cliente.setId((Integer) dados[1]);
					cobrancaDocumento.setCliente(cliente);
				}
				
				if (dados[2] != null) {
					retorno.setId((Integer) dados[2]);
				}
				
				if (dados[3] != null) {
					DocumentoTipo documentoTipo = new DocumentoTipo(); 
					documentoTipo.setId((Integer) dados[3]);
					cobrancaDocumento.setDocumentoTipo(documentoTipo);
				}
				
				retorno.setCobrancaDocumento(cobrancaDocumento);
				
			}
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}	
		
		return retorno;
		
	}
	
	
	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação 
	 *
	 * @author Raphael Rossiter
	 * @date 26/07/2011
	 *
	 * @param idGuiaPagamento
	 * @return GuiaPagamento
	 * @throws ErroRepositorioException
	 */
	public GuiaPagamento pesquisarGuiaPagamentoProcessarFichaCompensacao(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		GuiaPagamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select gpag " + "from GuiaPagamento gpag "
					+ "left join fetch gpag.imovel imov "
					+ "left join fetch imov.localidade locaImovel "
					+ "left join fetch gpag.cliente clie "
					+ "left join fetch gpag.localidade locaGuiaPagamento "
					+ "where gpag.id = :idGuiaPagamento "
					+ "and gpag.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada) "
					+ "order by gpag.dataVencimento";

			retorno = (GuiaPagamento) session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.setInteger("normal",DebitoCreditoSituacao.NORMAL)
					.setInteger("incluida",DebitoCreditoSituacao.INCLUIDA)
					.setInteger("retificada",DebitoCreditoSituacao.RETIFICADA)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC 1215]  Gerar Relatório de Documentos não Aceitos
	 * 
	 * @author Raimundo Martins
	 *
	 * @date 19/08/2011
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List<RelatorioDocumentoNaoAceitosBean> pesquisarDocumentosNaoAceitos(Arrecadador arrecadador, 
			String periodoInicial, String periodoFinal, Integer movimentoArrecadadorCodigo, 
			AvisoBancario avisoBancario, ArrecadacaoForma arrecadacaoForma) throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		List<RelatorioDocumentoNaoAceitosBean> relatorioDocumentosNaoAceitos = new ArrayList<RelatorioDocumentoNaoAceitosBean>();
		
		
		String hql = "SELECT arrc.arrc_cdagente||' - '||clie.CLIE_NMCLIENTE AS arrecadador, " +
			"dbtp.dbtp_dsdebitotipo AS tipoDebito, " +
			"avbc.avbc_dtlancamento AS dataLancamento, avbc.avbc_nnsequencial AS sequencial," +
			"armv.armv_nnnsa AS nsa, arfm.arfm_dsarrecadacaoforma AS formaArrecadacao, pgmt.pgmt_dtpagamento AS dataPagamento, " +
			"pgmt.pgmt_vlpagamento AS valor FROM " +
			"arrecadacao.PAGAMENTO pgmt " +
			"INNER JOIN faturamento.DEBITO_TIPO dbtp ON pgmt.DBTP_ID = dbtp.dbtp_id " +
			"INNER JOIN cadastro.SISTEMA_PARAMETROS sistp ON sistp.CLIE_IDDOCNAOIDENTIFICADO = pgmt.CLIE_ID " +			
			"INNER JOIN ARRECADACAO.AVISO_BANCARIO avbc ON pgmt.AVBC_ID = avbc.avbc_id " +
			"INNER JOIN ARRECADACAO.ARRECADADOR arrc ON avbc.arrc_id = arrc.arrc_id " +
			"INNER JOIN CADASTRO.cliente clie ON arrc.clie_id = clie.clie_id "+
			"INNER JOIN ARRECADACAO.arrecadador_mov_item amit ON pgmt.amit_id = amit.amit_id " +
			"INNER JOIN ARRECADACAO.arrecadador_movimento armv ON armv.armv_id = amit.armv_id " +
			"INNER JOIN ARRECADACAO.arrecadacao_forma arfm ON pgmt.arfm_id = arfm.arfm_id " +
			"WHERE " +
			"dbtp.DBTP_ID = :debitoTipo " +			
			"AND pgmt.pgmt_dtpagamento BETWEEN :periodoInicial AND :periodoFinal ";
		
		if(arrecadador !=null){
			hql+=" AND arrc.arrc_cdagente = :arrecadacaoCodigo ";
		}
		if(arrecadacaoForma !=null){
			hql+=" AND pgmt.arfm_id = :arrecadacaoFormaId ";
		}
		if(avisoBancario !=null){
			hql+=" AND pgmt.AVBC_ID = :avisoBancarioId ";
		}
		if(movimentoArrecadadorCodigo !=null && movimentoArrecadadorCodigo > 0){
			hql+=" AND amit.armv_id = :movimentoArrecadadorCodigo ";
		}
		hql+=" ORDER BY arrecadador";
		
		try{
			
				Query query = session.createSQLQuery(hql)
				.addScalar("arrecadador", Hibernate.STRING)
				.addScalar("tipoDebito", Hibernate.STRING)
				.addScalar("dataLancamento",Hibernate.DATE)
				.addScalar("sequencial", Hibernate.SHORT)
				.addScalar("nsa",Hibernate.INTEGER)
				.addScalar("formaArrecadacao",Hibernate.STRING)
				.addScalar("dataPagamento",Hibernate.DATE)
				.addScalar("valor",Hibernate.BIG_DECIMAL);
				
				
				SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
				
				query.setInteger("debitoTipo", DebitoTipo.DOCUMENTO_NAO_ACEITO);
				query.setDate("periodoInicial", format.parse(periodoInicial));
				query.setDate("periodoFinal", format.parse(periodoFinal));		
				
				if(arrecadador !=null){
					query.setInteger("arrecadacaoCodigo", arrecadador.getCodigoAgente());
				}
				if(arrecadacaoForma !=null){
					query.setInteger("arrecadacaoFormaId", arrecadacaoForma.getId());
				}
				if(avisoBancario !=null){
					query.setInteger("avisoBancarioId",avisoBancario.getId());
				}
				if(movimentoArrecadadorCodigo !=null && movimentoArrecadadorCodigo > 0){
					query.setInteger("movimentoArrecadadorCodigo",movimentoArrecadadorCodigo);
				}
				
				//relatorioDocumentosNaoAceitos = query.list();
				
				for (Object[] linha : (List<Object[]>) query.list()) {
					
					RelatorioDocumentoNaoAceitosBean relatorioDocumentoNaoAceitosBean = new RelatorioDocumentoNaoAceitosBean();
					relatorioDocumentoNaoAceitosBean.setArrecadador(linha[0].toString());
					relatorioDocumentoNaoAceitosBean.setTipoDebito(linha[1].toString());
					relatorioDocumentoNaoAceitosBean.setDataLancamento(format.format((Date)linha[2]));
					relatorioDocumentoNaoAceitosBean.setSequencial(linha[3].toString());
					relatorioDocumentoNaoAceitosBean.setNsa(linha[4].toString());
					relatorioDocumentoNaoAceitosBean.setFormaArrecadacao(linha[5].toString());
					relatorioDocumentoNaoAceitosBean.setDataPagamento(format.format(linha[6]));
					relatorioDocumentoNaoAceitosBean.setValor((BigDecimal)linha[7]);
					
					relatorioDocumentosNaoAceitos.add(relatorioDocumentoNaoAceitosBean);
				}
			
		
			return relatorioDocumentosNaoAceitos;	
			
		} catch(HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}catch(ParseException ex){
			throw new ErroRepositorioException(ex, "Erro no Parser");
		}finally {
			HibernateUtil.closeSession(session);
		}
	}
		
	/**
	 * @author Raimundo Martins
	 *
	 * @date 13/09/2011
	 * */	
	public boolean existeClienteIdDocNaoIdentificado(){
		Session session = HibernateUtil.getSession();
		boolean retorno = false;
		String sisparam = "SELECT sistp.CLIE_IDDOCNAOIDENTIFICADO as clienteFicticio FROM cadastro.SISTEMA_PARAMETROS sistp";
		
		Query querySisParam = session.createSQLQuery(sisparam).addScalar("clienteFicticio",Hibernate.INTEGER);
		List linhaSisParam = querySisParam.list();
		
		if(linhaSisParam.get(0) !=null){
			retorno = true;
		}
		
		return retorno;
	}
	
	/**
	 * [UC 1217]  Gerar Relatório de Transferencia de Pagamento
	 * 
	 * @author Raimundo Martins
	 *
	 * @date 19/08/2011
	 */
	public List<RelatorioTranferenciaPagamentoBean> pesquisarTransfereciasPagamento(Arrecadador arrecadador, 
			String periodoInicial, String periodoFinal, AvisoBancario avisoBancario, ArrecadacaoForma arrecadacaoForma, 
			DebitoTipo debitoTipo, DocumentoTipo documentoTipo) throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();
		List<RelatorioTranferenciaPagamentoBean> relatorioTransferenciasPagamento = new ArrayList<RelatorioTranferenciaPagamentoBean>();		
		String hql ="SELECT arrc.arrc_cdagente " +
		"  ||' - ' " +
		"  ||clie.CLIE_NMCLIENTE     AS arrecadador, " +
		"  pgmt.imov_id              AS matricula, " +
		"  dbtp.dbtp_dsdebitotipo    AS tipo_debito, " +
		"  dotp.dotp_dsdocumentotipo AS tipo_documento, " +
		"  CASE " +
		"    WHEN(pgmt.dotp_id = 1) " +
		"    THEN cnta.cnta_amreferenciaconta " +
		"    WHEN(pgmt.dotp_id = 6) " +
		"    THEN dbac.dbac_amreferenciadebito " +
		"    ELSE NULL " +
		"  END AS mesAno, " +
		"  CASE " +
		"    WHEN(pgmt.dotp_id = 6) " +
		"    THEN dbac.dbac_nnprestacaocobradas " +
		"      ||'/' " +
		"      ||dbac.dbac_nnprestacaodebito " +
		"    WHEN(pgmt.dotp_id = 7) " +
		"    THEN gpag.gpag_nnprestacaodebito " +
		"      ||'/' " +
		"      ||gpag.gpag_nnprestacaototal " +
		"    ELSE NULL " +
		"  END AS presParcela, " +
		"  CASE " +
		"    WHEN(pgmt.dotp_id = 1) " +
		"    THEN cnta.cnta_dtvencimentoconta " +
		"    WHEN(pgmt.dotp_id = 7) " +
		"    THEN gpag.gpag_dtvencimento " +
		"    ELSE NULL " +
		"  END AS dtVencimento, " +
		"  CASE " +
		"    WHEN(pgmt.dotp_id = 1) " +
		"    THEN (cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos + cnta.cnta_vlcreditos) " +
		"    WHEN(pgmt.dotp_id = 6) " +
		"    THEN dbac.dbac_vldebito " +
		"    ELSE gpag.gpag_vldebito " +
		"  END AS valor, " +
		"  CASE " +
		"    WHEN(pgmt.dotp_id = 1) " +
		"    THEN dcst_CONTA.dcst_dsdebitocreditosituacao " +
		"    WHEN(pgmt.dotp_id = 6) " +
		"    THEN dcst_DEBITO_A_COBRAR.dcst_dsdebitocreditosituacao " +
		"    ELSE dcst_GUIA_DE_PAGAMENTO.dcst_dsdebitocreditosituacao " +
		"  END                          AS situacao, " +
		"  arfm.arfm_dsarrecadacaoforma AS forma_arrecadacao, " +
		"  pgmt.pgmt_dtpagamento        AS data_pagamento, " +
		"  pgmt.pgmt_vlpagamento        AS valor_pagamento " +
		"FROM " +
		"  (SELECT dotp_id, " +
		"    pgmt_dtpagamento, " +
		"    pgmt_vlpagamento, " +
		"    AVBC_ID, " +
		"    DBTP_ID, " +
		"    arfm_id, " +
		"    cnta_id, " +
		"    dbac_id, " +
		"    gpag_id, " +
		"    AMIT_ID, " +
		"    IMOV_ID " +
		"  FROM arrecadacao.PAGAMENTO " +
		"  UNION " +
		"  SELECT dotp_id, " +
		"    PGHI_DTPAGAMENTO, " +
		"    PGHI_VLPAGAMENTO, " +
		"    AVBC_ID, " +
		"    DBTP_ID, " +
		"    arfm_id, " +
		"    cnta_id, " +
		"    dbac_id, " +
		"    gpag_id, " +
		"    AMIT_ID, " +
		"    IMOV_ID " +
		"  FROM arrecadacao.PAGAMENTO_HISTORICO " +
		"  ) pgmt " +
		"INNER JOIN ARRECADACAO.arrecadador_mov_item amit " +
		"ON pgmt.amit_id = amit.amit_id " +
		"INNER JOIN ARRECADACAO.AVISO_BANCARIO avbc " +
		"ON pgmt.AVBC_ID = avbc.avbc_id " +
		"INNER JOIN ARRECADACAO.ARRECADADOR arrc " +
		"ON avbc.arrc_id = arrc.arrc_id " +
		"INNER JOIN CADASTRO.cliente clie " +
		"ON arrc.clie_id = clie.clie_id " +
		"LEFT JOIN faturamento.DEBITO_TIPO dbtp " +
		"ON pgmt.DBTP_ID = dbtp.dbtp_id " +
		"INNER JOIN ARRECADACAO.arrecadacao_forma arfm " +
		"ON pgmt.arfm_id = arfm.arfm_id " +
		"INNER JOIN COBRANCA.documento_tipo dotp " +
		"ON pgmt.dotp_id = dotp.dotp_id " +
		"LEFT JOIN FATURAMENTO.conta cnta " +
		"ON pgmt.cnta_id = cnta.cnta_id " +
		"LEFT JOIN FATURAMENTO.debito_a_cobrar dbac " +
		"ON pgmt.dbac_id = dbac.dbac_id " +
		"LEFT JOIN FATURAMENTO.guia_pagamento gpag " +
		"ON pgmt.gpag_id = gpag.gpag_id " +
		"LEFT JOIN FATURAMENTO.debito_credito_situacao dcst_CONTA " +
		"ON dcst_CONTA.dcst_id = cnta.dcst_idatual " +
		"LEFT JOIN FATURAMENTO.debito_credito_situacao dcst_DEBITO_A_COBRAR " +
		"ON dcst_DEBITO_A_COBRAR.dcst_id = dbac.dcst_idatual " +
		"LEFT JOIN FATURAMENTO.debito_credito_situacao dcst_GUIA_DE_PAGAMENTO " +
		"ON dcst_GUIA_DE_PAGAMENTO.dcst_id = gpag.dcst_idatual " +
		"WHERE (pgmt.DBTP_ID              IS NULL " +
		"OR pgmt.DBTP_ID                  != :debitoTipo) " +
		"AND amit.amit_icaceitacao         = :amitIndAceitacao " +
		"AND pgmt.pgmt_dtpagamento BETWEEN TO_DATE(:periodoInicial, 'DD/MM/YYYY') AND TO_DATE(:periodoFinal, 'DD/MM/YYYY')";
		
		if(arrecadador !=null){
			hql+=" AND arrc.arrc_cdagente = :arrecadacaoCodigo ";			
		}
		if(arrecadacaoForma !=null){
			hql+=" AND pgmt.arfm_id = :arrecadacaoFormaId ";			
		}
		if(avisoBancario !=null){
			hql+=" AND pgmt.AVBC_ID = :avisoBancarioId ";
		}
		if(debitoTipo !=null){
			hql+=" AND pgmt.DBTP_ID = :debitoTipoId ";			
		}
		if(documentoTipo !=null){
			hql+=" AND pgmt.dotp_id = :documentoTipoId ";			
		}
		
		
		try{			
			Query query = session.createSQLQuery(hql+" ORDER BY arrecadador")
			.addScalar("arrecadador", Hibernate.STRING)
			.addScalar("matricula", Hibernate.STRING)
			.addScalar("tipo_debito", Hibernate.STRING)
			.addScalar("tipo_documento", Hibernate.STRING)
			.addScalar("mesAno",Hibernate.INTEGER)
			.addScalar("presParcela", Hibernate.STRING)
			.addScalar("dtVencimento",Hibernate.DATE)
			.addScalar("valor",Hibernate.BIG_DECIMAL)
			.addScalar("situacao",Hibernate.STRING)			
			.addScalar("forma_arrecadacao",Hibernate.STRING)
			.addScalar("data_pagamento",Hibernate.DATE)			
			.addScalar("valor_pagamento",Hibernate.BIG_DECIMAL);
			
			
			SimpleDateFormat format = new SimpleDateFormat("dd/MM/yy");
			
			query.setInteger("debitoTipo", DebitoTipo.DOCUMENTO_NAO_ACEITO);
			query.setString("periodoInicial", periodoInicial);
			query.setString("periodoFinal", periodoFinal);			
			query.setShort("amitIndAceitacao", ConstantesSistema.NAO);
			
			if(arrecadador !=null){
				query.setInteger("arrecadacaoCodigo", arrecadador.getCodigoAgente());
			}
			if(arrecadacaoForma !=null){
				query.setInteger("arrecadacaoFormaId", arrecadacaoForma.getId());
			}
			if(avisoBancario !=null){
				query.setInteger("avisoBancarioId",avisoBancario.getId());
			}
			if(debitoTipo !=null){
				query.setInteger("debitoTipoId",debitoTipo.getId());
			}
			if(documentoTipo !=null){
				query.setInteger("documentoTipoId",documentoTipo.getId());
			}
			List<Object[]> list = query.list();
			if(list !=null && !list.isEmpty()){
				for (Object[] linha : list) {
					RelatorioTranferenciaPagamentoBean relatorioTranferenciaPagamentoBean = new RelatorioTranferenciaPagamentoBean();
					relatorioTranferenciaPagamentoBean.setArrecadador(linha[0].toString());
					relatorioTranferenciaPagamentoBean.setMatricula(linha[1].toString());
					if(linha[2] !=null){
						relatorioTranferenciaPagamentoBean.setTipoDebito(linha[2].toString());	
					}
					else{
						relatorioTranferenciaPagamentoBean.setTipoDebito("");
					}
					if(linha[3] !=null){
						relatorioTranferenciaPagamentoBean.setTipoDocumento(linha[3].toString());
					}
					else{
						relatorioTranferenciaPagamentoBean.setTipoDocumento("");
					}
					
					if(linha[4] !=null){
						relatorioTranferenciaPagamentoBean.setMesAno(Util.formatarAnoMesParaMesAno(Integer.parseInt(linha[4].toString())));
					}
					else{
						relatorioTranferenciaPagamentoBean.setMesAno("");
					}
					if(linha[5] !=null && !linha[5].toString().equals("/")){
						relatorioTranferenciaPagamentoBean.setPresParcela(linha[5].toString());
					}
					else{
						relatorioTranferenciaPagamentoBean.setPresParcela("");
					}
					if(linha[6] !=null){
						relatorioTranferenciaPagamentoBean.setDataVencimento(format.format((Date)linha[6]));
					}				
					else{
						relatorioTranferenciaPagamentoBean.setDataVencimento("");
					}
					if(linha[7] !=null){
						relatorioTranferenciaPagamentoBean.setValor(Util.formatarMoedaReal((BigDecimal)linha[7]));
					}
					else{
						relatorioTranferenciaPagamentoBean.setValor("");
					}
					if(linha[8] !=null){
						relatorioTranferenciaPagamentoBean.setSituacao(linha[8].toString());
					}
					else{
						relatorioTranferenciaPagamentoBean.setSituacao("");
					}					
					if(linha[9] !=null){
						relatorioTranferenciaPagamentoBean.setFormaArrecadacao(linha[9].toString());
					}
					else{
						relatorioTranferenciaPagamentoBean.setFormaArrecadacao("");
					}
					if(linha[10] !=null){
						relatorioTranferenciaPagamentoBean.setDataPagamento(format.format((Date)linha[10]));
					}else{
						relatorioTranferenciaPagamentoBean.setDataPagamento("");
					}
					if(linha[11] !=null){
						relatorioTranferenciaPagamentoBean.setValorPagamento((BigDecimal)linha[11]);
					}
					else{
						relatorioTranferenciaPagamentoBean.setValorPagamento(new BigDecimal(0));
					}
					relatorioTransferenciasPagamento.add(relatorioTranferenciaPagamentoBean);
				}
			}
			return relatorioTransferenciasPagamento;	
			
		} catch(HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally {
			HibernateUtil.closeSession(session);
		}
	}
	

	/**
     * [UC0242] - Registrar Movimento dos Arrecadadores
	 * 
	 * @author Mariana Victor
	 * @date 18/08/2011
	 * 
	 * @param codigoConstante
	 * 
	 * @return DebitoTipo
	 * @throws ErroRepositorioException
	 */
	public DebitoTipo obterDebitoTipoCodigoConstante(Integer codigoConstante)
			throws ErroRepositorioException {

		DebitoTipo retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT debitoTipo " + "FROM DebitoTipo debitoTipo "
					+ "WHERE debitoTipo.codigoConstante = :codigoConstante ";

			retorno = (DebitoTipo) session.createQuery(consulta)
							.setInteger("codigoConstante", codigoConstante)
							.setMaxResults(1)
							.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * 3. O sistema identifica os pagamentos com documentos não aceitos 
	 * 	 que foram gerados para um cliente fictício e
	 *   junto com o filtro selecionado pelo usuário.
	 * 
	 * @author Mariana Victor
	 * @date 19/08/2011
	 * 
	 * @param helper
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosDocumentosNaoAceitos(
			InformarAcertoDocumentosNaoAceitosPagamentoHelper helper)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = " SELECT pgmt.pgmt_id AS idPagamento, " //0
				+ "   dbtp.dbtp_dsdebitotipo AS tipoDebito, " //1
				+ "   arfm.arfm_dsarrecadacaoforma AS arrecadacaoForma, " //2
				+ "   pgmt.pgmt_dtpagamento AS dataPagamento, " //3
				+ "   pgmt.pgmt_vlpagamento AS valorPagamento, " //4
				+ "   armv.armv_nnnsa AS nsa, " //5
				+ "   clie.clie_nmcliente AS arrecadador " //6
				+ " FROM arrecadacao.pagamento pgmt "
				+ "   INNER JOIN arrecadacao.aviso_bancario avbc ON pgmt.avbc_id = avbc.avbc_id "
				+ "   INNER JOIN faturamento.debito_tipo dbtp ON pgmt.dbtp_id = dbtp.dbtp_id "
				+ "   INNER JOIN arrecadacao.arrecadacao_forma arfm ON arfm.arfm_id = avbc.arfm_id "
				+ "   INNER JOIN arrecadacao.arrecadador_mov_item amit ON amit.amit_id = pgmt.amit_id "
				+ "   INNER JOIN arrecadacao.arrecadador_movimento armv ON armv.armv_id = amit.armv_id "
				+ "   INNER JOIN arrecadacao.arrecadador arrc ON arrc.arrc_id = avbc.arrc_id "
				+ "   INNER JOIN cadastro.cliente clie ON clie.clie_id = arrc.clie_id "
				+ " WHERE pgmt.dbtp_id= :idDebitoTipo "
				+ "   AND pgmt.clie_id = :idClienteFicticio "
				+ "   AND pgmt.pgmt_dtpagamento between :periodoInicial AND :periodoFinal ";

			if (helper.getIdArrecadador() != null) {
				consulta = consulta 
					+ "   AND avbc.arrc_id = :idArrecadador ";
			}

			if (helper.getIdAvisoBancario() != null) {
				consulta = consulta 
					+ "   AND pgmt.avbc_id = :idAvisoBancario ";
			}
			
			if (helper.getIdArrecadadorMov() != null) {
				consulta = consulta 
					+ "   AND armv.armv_id = :idArrecadadorMov ";
			}
			
			if (helper.getIdFormaArrecadacao() != null) {
				consulta = consulta 
					+ "   AND arfm.arfm_id = :idFormaArrecadacao ";
			}
			
			consulta = consulta 
					+ "  ORDER BY pgmt.pgmt_dtpagamento DESC ";

			Query query = session.createSQLQuery(consulta)
				.addScalar("idPagamento", Hibernate.INTEGER)
				.addScalar("tipoDebito", Hibernate.STRING)
				.addScalar("arrecadacaoForma", Hibernate.STRING)
				.addScalar("dataPagamento", Hibernate.DATE)
				.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
				.addScalar("nsa", Hibernate.INTEGER)
				.addScalar("arrecadador", Hibernate.STRING)
				.setInteger("idDebitoTipo", DebitoTipo.DOCUMENTO_NAO_ACEITO)
				.setInteger("idClienteFicticio", helper.getIdClienteFicticio())
				.setDate("periodoInicial", helper.getPeriodoPagamentoInicial())
				.setDate("periodoFinal", helper.getPeriodoPagamentoFinal());
			
			if (helper.getIdArrecadador() != null) {
				query.setInteger("idArrecadador",
						helper.getIdArrecadador());
			}

			if (helper.getIdAvisoBancario() != null) {
				query.setInteger("idAvisoBancario",
						helper.getIdAvisoBancario());
			}
			
			if (helper.getIdArrecadadorMov() != null) {
				query.setInteger("idArrecadadorMov",
						helper.getIdArrecadadorMov());
			}
			
			if (helper.getIdFormaArrecadacao() != null) {
				query.setInteger("idFormaArrecadacao",
						helper.getIdFormaArrecadacao());
			}
			
			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 *  7.2.1. Total do Pagamento (PGMT _VLPAGAMENTO do pagamento doc. não aceito).
	 * 
	 * @author Mariana Victor
	 * @date 22/08/2011
	 * 
	 * @param idPagamento
	 * 
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorPagamento(
			Integer idPagamento)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = " SELECT pgmt.pgmt_vlpagamento AS valorPagamento "
				+ " FROM arrecadacao.pagamento pgmt "
				+ " WHERE pgmt.pgmt_id= :idPagamento  ";
			
			retorno =  (BigDecimal) session.createSQLQuery(consulta)
				.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
				.setInteger("idPagamento", idPagamento)
				.setMaxResults(1).uniqueResult();
			
			

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * @author Mariana Victor
	 * @date 24/08/2011
	 * 
	 * @param idGuia
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarLocalidadeGuiaPagamento(
			Integer idGuia)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = " SELECT gpag.loca_id AS idLocalidade "
				+ " FROM faturamento.guia_pagamento gpag "
				+ " WHERE gpag.gpag_id = :idGuia ";
			
			retorno =  (Integer) session.createSQLQuery(consulta)
				.addScalar("idLocalidade", Hibernate.INTEGER)
				.setInteger("idGuia", idGuia)
				.setMaxResults(1).uniqueResult();
			
			

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * @author Mariana Victor
	 * @date 24/08/2011
	 * 
	 * @param idConta
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarLocalidadeConta(
			Integer idConta)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = " SELECT cnta.loca_id AS idLocalidade "
				+ " FROM faturamento.conta cnta "
				+ " WHERE cnta.cnta_id = :idConta ";
			
			retorno =  (Integer) session.createSQLQuery(consulta)
				.addScalar("idLocalidade", Hibernate.INTEGER)
				.setInteger("idConta", idConta)
				.setMaxResults(1).uniqueResult();
			
			

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * @author Mariana Victor
	 * @date 24/08/2011
	 * 
	 * @param idDebitoACobrar
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarLocalidadeDebitoACobrar(
			Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = " SELECT dbac.loca_id AS idLocalidade "
				+ " FROM faturamento.debito_a_cobrar dbac "
				+ " WHERE dbac.dbac_id = :idDebitoACobrar ";
			
			retorno =  (Integer) session.createSQLQuery(consulta)
				.addScalar("idLocalidade", Hibernate.INTEGER)
				.setInteger("idDebitoACobrar", idDebitoACobrar)
				.setMaxResults(1).uniqueResult();
			
			

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * Calcula o valor total do movimento arrecadador
	 * 
	 * @author Gustavo Amaral
	 * @date 14/09/2011
	 * 
	 * @param arrecadadorMovimento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */	
	public Collection pesquisarValorAcertosArrecadadorMovimento(Integer idArrecadadorMovimento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			consulta = " select "
					+ " (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto avac"
					+ " where avac.avisoBancario.arrecadadorMovimento.id = :idArrecadadorMovimento and"
					+ " avac.indicadorCreditoDebito = 1"
					+ " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao1,"
					+ // 0
					" (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.arrecadadorMovimento.id = :idArrecadadorMovimento and"
					+ " avac.indicadorCreditoDebito = 2"
					+ " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao2,"
					+ // 1
					" (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.arrecadadorMovimento.id = :idArrecadadorMovimento and"
					+ " avac.indicadorCreditoDebito = 1"
					+ " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao1,"
					+ // 2
					" (select sum(avac.valorAcerto)"
					+ " from AvisoAcerto as avac"
					+ " where avac.avisoBancario.arrecadadorMovimento.id = :idArrecadadorMovimento and"
					+ " avac.indicadorCreditoDebito = 2"
					+ " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao2"
					+ // 3
					" from ArrecadadorMovimento as armv"
					+ " where armv.id = :idArrecadadorMovimento";

			retorno = (Collection) session.createQuery(consulta).setInteger(
					"idArrecadadorMovimento", idArrecadadorMovimento).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rodrigo Cabral
	 * @date 15/09/11
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoClienteCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection retorno = null;
		// Object pagamentoClienteCount;
		String hql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.condicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                    valorPagamentoFinal);

			hql = " SELECT COUNT(c.pghi_id) as qtde "
					+ " FROM arrecadacao.pagamento_historico c " 
					+ " INNER JOIN  faturamento.conta_historico i "
					+ " on i.cnta_id = c.cnta_id "
					+ " INNER JOIN " + " cadastro.cliente_conta_historico b "
					+ " on b.cnta_id = c.cnta_id " + " INNER JOIN "
					+ " cadastro.cliente a " + " on a.clie_id = b.clie_id "
					+ " INNER JOIN " + " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id " + " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id " + " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id " + " INNER JOIN "
					+ " cadastro.cliente h " + "  on h.clie_id = g.clie_id "
					+ " WHERE " + condicionais + " union all "
					+ " SELECT COUNT(c.pghi_id) as qtde "
					+ " FROM arrecadacao.pagamento_historico c " + " INNER JOIN "
					+ " faturamento.debito_a_cobrar b1 "
					+ "  on b1.dbac_id = c.dbac_id " + " INNER JOIN "
					+ " cadastro.cliente_imovel b "
					+ " on b.imov_id = b1.imov_id " + " INNER JOIN "
					+ " cadastro.cliente a " + " on a.clie_id = b.clie_id "
					+ " INNER JOIN " + " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id " + " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id " + " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id " + " INNER JOIN "
					+ " cadastro.cliente h " + "  on h.clie_id = g.clie_id "
					+ " WHERE " + condicionais + " union all "
					+ " SELECT COUNT(c.pghi_id) as qtde "
					+ " FROM arrecadacao.pagamento_historico c " + " INNER JOIN "
					+ " faturamento.guia_pagamento b1 "
					+ "  on b1.gpag_id = c.gpag_id " + " INNER JOIN "
					+ " cadastro.cliente_guia_pagamento b "
					+ " on b.gpag_id = c.gpag_id " + " INNER JOIN "
					+ " cadastro.cliente a " + " on a.clie_id = b.clie_id "
					+ " INNER JOIN " + " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id " + " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id " + " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id " + " INNER JOIN "
					+ " cadastro.cliente h " + "  on h.clie_id = g.clie_id "
					+ " WHERE " + condicionais + " union all "
					+ " SELECT COUNT(c.pghi_id) as qtde "
					+ " FROM arrecadacao.pagamento_historico c " + " INNER JOIN "
					+ " cadastro.cliente a " + " on a.clie_id = c.clie_id "
					+ " INNER JOIN " + " cadastro.localidade d "
					+ "  on c.loca_id = d.loca_id " + " INNER JOIN "
					+ " arrecadacao.aviso_bancario f "
					+ "  on c.avbc_id = f.avbc_id " + " INNER JOIN "
					+ " arrecadacao.arrecadador g "
					+ "  on f.arrc_id = g.arrc_id " + " INNER JOIN "
					+ " cadastro.cliente h " + "  on h.clie_id = g.clie_id "
					+ " WHERE ";

			idTipoRelacao = null;

			String condicionaisClienteHistoricoPagamento = this
					.condicionaisPagamentoHistorico(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                            valorPagamentoFinal);

			hql = hql + condicionaisClienteHistoricoPagamento;

			retorno = session.createSQLQuery(hql).addScalar("qtde",
					Hibernate.INTEGER).list();

			// hql = " select count (pagamento.id) "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + " inner join pagamento.cliente as cliente "
			// + condicionais + " ";

			// pagamentoClienteCount = session.createQuery(hql).setMaxResults(1)
			// .uniqueResult();
			//
			// if (pagamentoClienteCount != null) {
			// retorno = (Integer) pagamentoClienteCount;
			// }

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	
	/**
	 * Cria condições em Sql para pagamento historico
	 * 
	 * @author Rodrigo Cabral
	 * @date 15/09/11
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public String condicionaisPagamentoHistorico(String idImovel, String idCliente,
			String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal) {

		String sql = " ";
		if (idImovel != null && !idImovel.equals("")) {
			sql = sql + " c.imov_id = " + idImovel + " and ";
		}
		if (idCliente != null && !idCliente.equals("")) {
			sql = sql + " a.clie_id = " + idCliente + " and ";
		}
		if (idTipoRelacao != null && !idTipoRelacao.equals("")) {
			sql = sql + " b.crtp_id = " + idTipoRelacao + " and ";
		}
		if (localidadeInicial != null && localidadeFinal != null
				&& !localidadeInicial.equals("") && !localidadeFinal.equals("")) {
			sql = sql + " c.loca_id >= " + localidadeInicial + " and ";
			sql = sql + " c.loca_id <= " + localidadeFinal + " and ";
		}
		if (idAvisoBancario != null && !idAvisoBancario.equals("")) {
			sql = sql + " c.avbc_id = " + idAvisoBancario + " and ";
		}
		if (idArrecadador != null && !idArrecadador.equals("")) {
			sql = sql + " f.armv_id = " + idArrecadador + " and ";
		}
		if (periodoArrecadacaoInicial != null
				&& !periodoArrecadacaoInicial.equals("")) {
			sql = sql
					+ " c.pghi_amreferenciaarrecadacao >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
					+ " and ";
		}
		if (periodoArrecadacaoFinal != null
				&& !periodoArrecadacaoFinal.equals("")) {
			sql = sql
					+ " c.pghi_amreferenciaarrecadacao <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal)
					+ " and ";
		}
		if (periodoPagamentoInicio != null
				&& !periodoPagamentoInicio.equals("")) {
			sql = sql
					+ " c.pghi_amreferenciapagamento >= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
					+ " and ";
		}
		if (periodoPagamentoFim != null && !periodoPagamentoFim.equals("")) {
			sql = sql
					+ " c.pghi_amreferenciapagamento <= "
					+ Util
							.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim)
					+ " and ";
		}

		if (dataPagamentoInicial != null && !dataPagamentoInicial.equals("")) {
			// sql = sql + " pagamento.dataPagamento >= '" +
			// Util.formatarData(dataPagamentoInicial) + "' and " ;
			String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

			if (data1 != null && !data1.equals("")
					&& data1.trim().length() == 8) {

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6)
						+ "-" + data1.substring(6, 8);
			}
			sql = sql + " c.pghi_dtpagamento >= to_date('" + data1 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}
		if (dataPagamentoFinal != null && !dataPagamentoFinal.equals("")) {
			// sql = sql + " pagamento.dataPagamento <= '" +
			// Util.formatarData(dataPagamentoFinal) + "' and " ;
			String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

			if (data2 != null && !data2.equals("")
					&& data2.trim().length() == 8) {

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6)
						+ "-" + data2.substring(6, 8);
			}
			sql = sql + " c.pghi_dtpagamento <= to_date('" + data2 + "','YYYY-MM-DD HH24:MI:SS') and ";
		}

		if (idsPagamentosSituacoes != null
				&& !idsPagamentosSituacoes.equals("")) {
			String valoresIn = "";
			for (int i = 0; i < idsPagamentosSituacoes.length; i++) {
				if (!idsPagamentosSituacoes[i].equals("")) {
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.pgst_idatual in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDebitosTipos != null
				&& !idsDebitosTipos.equals("")
				&& !idsDebitosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDebitosTipos.length; i++) {
				if (!idsDebitosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.dbtp_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsArrecadacaoForma != null
				&& !idsArrecadacaoForma.equals("")
				&& !idsArrecadacaoForma[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsArrecadacaoForma.length; i++) {
				if (!idsArrecadacaoForma[i].equals("")) {
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.arfm_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
		if (idsDocumentosTipos != null
				&& !idsDocumentosTipos.equals("")
				&& !idsDocumentosTipos[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			String valoresIn = "";
			for (int i = 0; i < idsDocumentosTipos.length; i++) {
				if (!idsDocumentosTipos[i].equals("")) {
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if (!valoresIn.equals("")) {
				sql = sql + " c.dotp_id in (" + valoresIn;
				sql = Util.removerUltimosCaracteres(sql, 1);
				sql = sql + ") and ";
			}
		}
        
        if ( valorPagamentoInicial != null && !valorPagamentoInicial.equals( "" ) &&
                valorPagamentoFinal != null && !valorPagamentoFinal.equals( "" )   ){
               sql += " c.valorPagamento between " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoInicial ) + 
                   " and " + Util.formatarMoedaRealparaBigDecimal( valorPagamentoFinal ) + " and ";
        }
        

		// retira o " and " q fica sobrando no final da query
		sql = Util.removerUltimosCaracteres(sql, 4);

		return sql;

	}
	
	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos historico
	 * para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rodrigo Cabral
	 * @date 16/09/11
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoClienteRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		String sql = "";

		Session session = HibernateUtil.getSession();

		try {
			String condicionais = this.condicionaisPagamentoHistorico(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                    valorPagamentoFinal);

			sql = " select 'CONTA HISTORICO' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
					+ " c.pghi_dtpagamento as dataPagamento, c.pghi_amreferenciapagamento as anoMesPagamento, null as tipoDebito, (cnhi_vlagua + cnhi_vlesgoto + cnhi_vldebitos - cnhi_vlcreditos) as valorDocumento, "
					+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					+ " from cadastro.cliente a, cadastro.cliente_conta_historico b, cadastro.localidade d, cadastro.gerencia_regional e, "
					+ " arrecadacao.aviso_bancario f, arrecadacao.arrecadador g, cadastro.cliente h, faturamento.conta_historico i, arrecadacao.pagamento_historico c "
					+ " left join arrecadacao.pagamento_situacao j "
					+ " on c.pgst_idatual = j.pgst_id "
					+ " where a.clie_id = b.clie_id "
					+ " and b.cnta_id = c.cnta_id "
					+ " and c.loca_id = d.loca_id "
					+ " and d.greg_id = e.greg_id "
					+ " and c.avbc_id = f.avbc_id "
					+ " and f.arrc_id = g.arrc_id "
					+ " and g.clie_id = h.clie_id "
					+ " and b.cnta_id = i.cnta_id "
					+ " and "
					+ condicionais
					+ " union "
					+ " select 'DÉBITO A COBRAR' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
					+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
					+ " ((dbac_nnprestacaodebito - dbac_nnprestacaocobradas) * (dbac_vldebito/ dbac_nnprestacaodebito)) as valorDocumento, "
					+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					+ " from cadastro.cliente a, cadastro.cliente_imovel b, faturamento.debito_a_cobrar b1, cadastro.localidade d, cadastro.gerencia_regional e, "
					+ " arrecadacao.aviso_bancario f, arrecadacao.arrecadador g, cadastro.cliente h, faturamento.debito_tipo k, arrecadacao.pagamento_historico c "
					+ " left join arrecadacao.pagamento_situacao j "
					+ " on c.pgst_idatual = j.pgst_id "
					+ " where a.clie_id = b.clie_id "
					+ " and b.imov_id = b1.imov_id "
					+ " and b1.dbac_id = c.dbac_id "
					+ " and c.loca_id = d.loca_id "
					+ " and d.greg_id = e.greg_id "
					+ " and c.avbc_id = f.avbc_id "
					+ " and f.arrc_id = g.arrc_id "
					+ " and g.clie_id = h.clie_id "
					+ " and b1.dbtp_id = k.dbtp_id "
					+ " and "
					+ condicionais
					+ " union "
					+ " select 'GUIA PAGAMENTO IMOVEL' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
					+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
					+ " (gpag_vldebito) as valorDocumento, "
					+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					+ " from cadastro.cliente a, cadastro.cliente_guia_pagamento b, faturamento.guia_pagamento b1, cadastro.localidade d, cadastro.gerencia_regional e, "
					+ " arrecadacao.aviso_bancario f, arrecadacao.arrecadador g, cadastro.cliente h, faturamento.debito_tipo k, arrecadacao.pagamento_historico c "
					+ " left join arrecadacao.pagamento_situacao j "
					+ " on c.pgst_idatual = j.pgst_id "
					+ " where a.clie_id = b.clie_id "
					+ " and b.gpag_id = b1.gpag_id "
					+ " and b1.gpag_id = c.gpag_id "
					+ " and c.loca_id = d.loca_id "
					+ " and d.greg_id = e.greg_id "
					+ " and c.avbc_id = f.avbc_id "
					+ " and f.arrc_id = g.arrc_id "
					+ " and g.clie_id = h.clie_id "
					+ " and b1.dbtp_id = k.dbtp_id "
					+ " and "
					+ condicionais
					+ " union "
					+ " select 'GUIA PAGAMENTO CLIENTE' as tipo, "
					+ " d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, "
					+ " e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, " 
					+ " c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, " 
					+ " h.clie_nmcliente as nomeArrecadador, "
					+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento, "
					+ " k.dbtp_dsdebitotipo as tipoDebito, "
					+ " (b1.gpag_vldebito) as valorDocumento, "
					+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, "
					+ " j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					
					+ " from cadastro.cliente a, cadastro.cliente_guia_pagamento b, faturamento.guia_pagamento b1, arrecadacao.pagamento_historico c,"
					+ " cadastro.localidade d, cadastro.gerencia_regional e, arrecadacao.aviso_bancario f, " 
					+ " arrecadacao.arrecadador g, cadastro.cliente h, faturamento.debito_tipo k, "
					+ " arrecadacao.pagamento_situacao j "
					
					+ " where a.clie_id = b.clie_id "// Cliente com Guia
					+ " and b.gpag_id = b1.gpag_id "
					+ " and b1.gpag_id = c.gpag_id "// Guia com Pagamento
					+ " and c.loca_id = d.loca_id "// Pagamento com Localidade
					+ " and d.greg_id = e.greg_id "// Localidade com Gerencia
					+ " and c.avbc_id = f.avbc_id "// Pagamento com Aviso bancario
					+ " and f.arrc_id = g.arrc_id "// Aviso Bancario com Arrecadador
					+ " and g.clie_id = h.clie_id "// Arrecadador com Cleinte do Arrecadador
					+ " and b1.dbtp_id = k.dbtp_id "// Guia com Debito Tipo 
					+ " and c.pgst_idatual = j.pgst_id "
					+ " and "
					+ condicionais
					+ " union "
					+ " select 'PAGAMENTO CLIENTE' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente , a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
					+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
					+ " null as valorDocumento, "
					+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo "
					+ " from cadastro.cliente a, cadastro.localidade d, cadastro.gerencia_regional e, "
					+ " arrecadacao.aviso_bancario f, arrecadacao.arrecadador g, cadastro.cliente h, faturamento.debito_tipo k, arrecadacao.pagamento_historico c "
					+ " left join arrecadacao.pagamento_situacao j "
					+ " on c.pgst_idatual = j.pgst_id "
					+ " where a.clie_id = c.clie_id "
					+ " and   c.loca_id = d.loca_id "
					+ " and   d.greg_id = e.greg_id "
					+ " and   c.avbc_id = f.avbc_id "
					+ " and   f.arrc_id = g.arrc_id "
					+ " and   g.clie_id = h.clie_id "
					+ " and   c.dbtp_id = k.dbtp_id "
					+ " and   c.gpag_id IS NULL " + " and ";

			idTipoRelacao = null;

			String condicionaisClientePagamentoHistorico = this
					.condicionaisPagamentoHistorico(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			sql = sql + condicionaisClientePagamentoHistorico;

			// "select distinct pagamento " + " from
			// gcom.arrecadacao.pagamento.Pagamento as
			// pagamento " + " inner join pagamento.cliente as cliente " +
			// condicionais + "
			// order by pagamento.documentoTipo.id,pagamento.dataPagamento " + "
			// ";

			retorno = session.createSQLQuery(sql).addScalar("tipo",
					Hibernate.STRING).addScalar("idLocalidade",
					Hibernate.INTEGER).addScalar("nomeLocalidade",
					Hibernate.STRING)
					.addScalar("idGerencia", Hibernate.INTEGER).addScalar(
							"nomeGerencia", Hibernate.STRING).addScalar(
							"idImovel", Hibernate.INTEGER).addScalar(
							"idCliente", Hibernate.INTEGER).addScalar(
							"nomeCliente", Hibernate.STRING).addScalar(
							"nomeArrecadador", Hibernate.STRING).addScalar(
							"dataPagamento", Hibernate.DATE).addScalar(
							"anoMesPagamento", Hibernate.INTEGER).addScalar(
							"tipoDebito", Hibernate.STRING).addScalar(
							"valorDocumento", Hibernate.BIG_DECIMAL).addScalar(
							"valorPagamento", Hibernate.BIG_DECIMAL).addScalar(
							"idSituacaoPagamento", Hibernate.INTEGER)
					.addScalar("situacaoPagamento", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/*
	 * Criado para a consulta, de manter conta por conjunto de imóveis, pelo id do banco
	 * e pelo grupo de faturamento
	 * 
	 * */
	
	/** @author Adriana Muniz
	  * @date: 07/04/2011
	  * [UC0146] Manter Conta
	  * 
	  * FS0028 - Verificar parâmetro consulta e débito automático
	  * @return
	  * @throws ErroRepositorioException
	  */
	public Collection pesquisarImoveisBancoDebitoAutomaticoEPorGrupoFaturamento(String[] bancos, 
			Integer idGrupoFaturamento) throws ErroRepositorioException {
		
		Collection retorno = null;
		
		Session session = HibernateUtil.getSession();
		
		try{
			String select = "select distinct(da.imovel.id) "
			 + " from DebitoAutomatico da "
			 + " inner join da.agencia ag "
			 + " inner join da.imovel i "
			 + " inner join i.quadra q "
			 + " inner join q.rota r "
			 + " where ag.banco.id in (:idBanco) " 
			 + " and da.dataExclusao is null " 
			 + " and r.faturamentoGrupo.id = :idGrupoFaturamento ";

			retorno = session.createQuery(select)
				.setParameterList("idBanco", bancos)
				.setInteger("idGrupoFaturamento", idGrupoFaturamento)
				.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
		
	}
	
	/*
	 * autor: Adriana Muniz
	 * 
	 * Alteração para a conta considerar como filtro grupo de faturamento,
	 * quando o mesmo estiver preenchido
	 */
	/**
	 * @autor: Adriana Muniz
	 * @date: 27/04/2011
	 * 
	 * [UC0146] Manter Conta
	 *
	 * FS0028 - Verificar parâmetro consulta e débito automático
	 * 
	 * Método para retornar a quantidade de contas a partir dos imóveis
	 * com débito automático - Manter Contas de um Conjunto de imóveis.
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer countImoveisBancoDebitoAutomaticoPorGrupoFaturamento(
			String[] bancos, Integer anoMesInicial, Integer anoMesFinal,
			Date dataVencimentoInicial, Date dataVencimentoFinal,
			String indicadorContaPaga, Integer idGrupoFaturamento, Integer somenteDebitoAutomatico)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		Map parameters = new HashMap();
		Query query = null;

		try {
			String select = "select count(conta.imovel.id) "
					+ " from DebitoAutomaticoMovimento dam "
					+ " inner join dam.debitoAutomatico da "
					+ " inner join dam.contaGeral.conta conta "
					+ " inner join da.agencia ag"
					+ " inner join conta.debitoCreditoSituacaoAtual dcst "
					+ " inner join conta c "
					+ " left  join conta.debitoCreditoSituacaoAnterior dcsan "
					+ " inner join conta.imovel imov "
					+ " where ag.banco.id in (:idBanco) "
					+ " and dcst.id in(:normal, :retificada) "
					+ " and conta.referencia between :anoMesInicial and :anoMesFinal "
					+ " and da.dataExclusao is null "
					+ " and dam.numeroSequenciaArquivoEnviado is null"
					+ " and conta.faturamentoGrupo.id = :idGrupoFaturamento";

			if (somenteDebitoAutomatico != null && somenteDebitoAutomatico == 1) {
				select += " and c.indicadorDebitoConta = 1 ";
			}
			
			if (dataVencimentoInicial != null) {
				select += " and conta.dataVencimentoConta between :vencimentoInicial and :vencimentoFinal ";
				parameters.put("vencimentoInicial", dataVencimentoInicial);
				parameters.put("vencimentoFinal", dataVencimentoFinal);
			}

			if (!indicadorContaPaga.equals("3")) {
				if (indicadorContaPaga.equals("1")) {
					select += " and exists ";
				} else {
					select += " and not exists ";
				}
				select += " (select conta.id " + "from Pagamento pgmt "
						+ "inner join pgmt.contaGeral cntaGeral "
						+ "inner join cntaGeral.conta cnta "
						+ "where cnta.id = conta.id) ";
			}

			query = session.createQuery(select);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Date) {
					Date data = (Date) parameters.get(key);
					query.setDate(key, data);
				}

			}

			retorno = (Integer) query.setParameterList("idBanco", bancos)
					.setInteger("anoMesInicial", anoMesInicial)
					.setInteger("anoMesFinal", anoMesFinal)
					.setInteger("idGrupoFaturamento", idGrupoFaturamento)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}
	
	/**
	 * @author Wellington Rocha
	 * @data 15/04/2012
	 * 
	 * @param idConta
	 * @return pagamento
	 */
	public Object[] pesquisarPagamentoDeContaEmHistorico(Integer idConta)
			throws ErroRepositorioException{
		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT pgmt.id,pgmt.valorPagamento, pgmt.dataPagamento " + "FROM PagamentoHistorico as pgmt "
					+ "WHERE pgmt.contaGeral.id = :idConta ";

			retorno = (Object[]) session.createQuery(consulta).setInteger(
					"idConta", idConta).setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Relatório Analitico dos valores diários da arrecadação
	 * 
	 * @author Adriana Muniz
	 * data: 05/09/2012
	 * 
	 * obtém as formas de arrecadação por dia
	 * @param helper
	 * @param filtro
	 * @return coleção
	 */
	public Collection obterFormasDeArrecadacaoPorDia(
			Object helper, FiltroConsultarDadosDiariosArrecadacao filtro) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();
		try {
			consulta = "SELECT coalesce(ardd.itemADD, ddd1.itemDDD) as campoAgrupador, "
					+	" arfm_dsarrecadacaoforma as nomeFormaArrecadacao, "
					+	" (COALESCE(ARDD.qtdDocumentos,0) + COALESCE(DDD1.qtdDocumentosDescontos,0) + COALESCE(DDD1.qtdDocumentosDevolucoes,0)) as qtdDocumentos, " 
					+	" (COALESCE(ARDD.qtdPagamentos,0) + COALESCE(DDD1.qtdPagamentosDescontos,0) + COALESCE(DDD1.qtdPagamentosDevolucoes,0)) as qtdPagamentos,  "
					+	" COALESCE(ARDD.debitos, 0) as debitos,  "
					+	" COALESCE(DDD1.valorDescontos, 0) as descontos, " 
					+	" COALESCE(DDD1.valorDevolucoes, 0) as devolucoes "
					+	" from (SELECT  	ad.arfm_id  as itemADD,  "
						+	" sum(ad.ardd_qtdocumentos) as qtdDocumentos, " 
						+	" sum(ad.ardd_qtpagamentos) as qtdPagamentos,  "
						+	" sum(ad.ardd_vlpagamentos) as debitos   "
						+	" FROM arrecadacao.arrecadacao_dados_diarios ad "  
						+	" WHERE ad.ardd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao() ;
						if(filtro.getIdArrecadador() != null && !filtro.getIdArrecadador().equals(""))
							consulta +=	" and ad.arrc_id = " + filtro.getIdArrecadador();
			consulta +=	"    and date(ardd_dtpagamento) = '" + helper.toString()+"'"
						+	" group by itemADD ) as ARDD   "
					+	" full join (SELECT  	dd.arfm_id  as itemDDD, " 
							+	" sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDescontos, "   
							+	" sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDevolucoes, " 
							+	" sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDescontos, "
							+	" sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDevolucoes, "   
							+	" sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDescontos, "
							+	" sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDevolucoes "
							+	" FROM arrecadacao.devolucao_dados_diarios dd "
							+	" WHERE dd.dvdd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao() ;
							if(filtro.getIdArrecadador() != null && !filtro.getIdArrecadador().equals(""))
								consulta +=	" and dd.arrc_id = " + filtro.getIdArrecadador();
					consulta +=	" and date(dvdd_dtdevolucao) = '" + helper.toString()+"'"
							+	" group by itemDDD ) as DDD1 on (ARDD.itemADD = DDD1.itemDDD) "  
					+	" inner join arrecadacao.arrecadacao_forma af on (af.arfm_id = coalesce(ardd.itemADD, ddd1.itemDDD)) "
					+	" order by campoAgrupador ";
			
			retorno = session.createSQLQuery(consulta)
					.addScalar("campoAgrupador", Hibernate.INTEGER)
					.addScalar("nomeFormaArrecadacao", Hibernate.STRING)
					.addScalar("qtdDocumentos", Hibernate.INTEGER)
					.addScalar("qtdPagamentos", Hibernate.INTEGER)
					.addScalar("debitos", Hibernate.BIG_DECIMAL)
					.addScalar("descontos", Hibernate.BIG_DECIMAL)
					.addScalar("devolucoes", Hibernate.BIG_DECIMAL)
					.list();
			
		}catch(HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	

	/**
     * DATA:02/10/2012
     * @author Adriana Muniz
     *
     * @param filtro
     * @return
     * @throws ErroRepositorioException
     */
    public Collection filtrarDadosDiariosFormasArrecadacaoComTarifa(FiltroConsultarDadosDiariosArrecadacao filtro)
            throws ErroRepositorioException {
        Collection retorno = new ArrayList();
       
        Session session = HibernateUtil.getSession();
       
        String     SQLGeral = null;
        String    SQLConsultaADD = " SELECT ad.ardd_dtpagamento AS dataPagamento, " +
                " SUM(ad.ardd_qtdocumentos) AS qtdDocumentos, " +
                " SUM(ad.ardd_vlpagamentos) AS debitos " +
                " FROM ARRECADACAO.ARRECADACAO_DADOS_DIARIOS ad " +
                " WHERE ardd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao() +
                " AND arrc_id = " + filtro.getIdArrecadador() +
                " GROUP BY dataPagamento " +
                " ORDER BY dataPagamento ";

        try {
            retorno = session.createSQLQuery(SQLGeral)
                .addScalar("qtdDocumentos", Hibernate.INTEGER)
                .addScalar("qtdPagamentos", Hibernate.INTEGER)
                .addScalar("debitos", Hibernate.BIG_DECIMAL)
                .addScalar("descontos", Hibernate.BIG_DECIMAL)
                .list();
        } catch (HibernateException e) {
            throw new ErroRepositorioException(e, "Erro no Hibernate");
        } finally {
            HibernateUtil.closeSession(session);
        }

//	        System.out.println("Tempo de execução da query (" + filtro.getAgrupamento() +
//	                ") " + (System.currentTimeMillis() - t1));
       
        return retorno;

    }


/**
     *
     * Relatório Analitico dos valores diários da arrecadação
     *
     * @author Adriana Muniz
     * data: 02/10/2012
     *
     * obtém as formas de arrecadação com tarifa por dia
     * @param helper
     * @param filtro
     * @return coleção
     */
    public Collection obterFormasDeArrecadacaoComTarifaPorDia(
            Object helper, FiltroConsultarDadosDiariosArrecadacao filtro) throws ErroRepositorioException {

        Collection retorno = null;
        String consulta;
        Session session = HibernateUtil.getSession();
        try {
            consulta = " SELECT coalesce(ardd.itemADD, ddd1.itemDDD) AS campoAgrupador, "
                    +  " arfm_dsarrecadacaoforma AS nomeFormaArrecadacao, "
                    +  " ARDD.valorTarifa as valorTarifa, "
                    +  " ardd.dataprevista as dataPrevista, "
                    +  " (COALESCE(ARDD.qtdDocumentos,0) + COALESCE(DDD1.qtdDocumentosDescontos,0) + COALESCE(DDD1.qtdDocumentosDevolucoes,0)) as qtdDocumentos,"
                    +  " (COALESCE(ARDD.qtdPagamentos,0) + COALESCE(DDD1.qtdPagamentosDescontos,0) + COALESCE(DDD1.qtdPagamentosDevolucoes,0)) as qtdPagamentos,  "
                    +  " COALESCE(ARDD.debitos, 0) as debitos, "
                    +  " COALESCE(DDD1.valorDescontos, 0) as descontos, "
                    +  " COALESCE(DDD1.valorDevolucoes, 0) as devolucoes "
                    +  " from (SELECT      ad.arfm_id  as itemADD, "
                    +  " sum(ardd_vltarifa) as valorTarifa, "
                    +  " (date(ad.ardd_dtpagamento) + cast(ad.ardd_nndiafloat as integer)) as dataPrevista, "
                    +  " sum(ad.ardd_qtdocumentos) as qtdDocumentos, "
                    +  " sum(ad.ardd_qtpagamentos) as qtdPagamentos, "
                    +  " sum(ad.ardd_vlpagamentos) as debitos "
                    +  " FROM arrecadacao.arrecadacao_dados_diarios ad "
                    +  " WHERE ad.ardd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao()
                    +  " and ad.arrc_id = " + filtro.getIdArrecadador()
                    +  " and date(ardd_dtpagamento) = '" + helper.toString()+"' "
                    +  " group by itemADD, dataPrevista) as ARDD    "
                    +  " full join (SELECT      dd.arfm_id  as itemDDD,  "
                    +  " 0 as valorTarifa, "
                    +  " null as dataPrevista, "
                    +  " sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDescontos, "
                    +  " sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDevolucoes, "
                    +  " sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDescontos, "
                    +  " sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDevolucoes, "
                    +  " sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDescontos,  "
                    +  " sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDevolucoes "
                    +  " FROM arrecadacao.devolucao_dados_diarios dd "
                    +  " WHERE dd.dvdd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao()
                    +  " and dd.arrc_id = " + filtro.getIdArrecadador()
                    +  " and date(dvdd_dtdevolucao) = '" + helper.toString()+"' "
                    +  " group by itemDDD ) as DDD1 on (ARDD.itemADD = DDD1.itemDDD) "
                    +  " inner join arrecadacao.arrecadacao_forma af on (af.arfm_id = coalesce(ardd.itemADD, ddd1.itemDDD)) "
                    +  " order by campoAgrupador  ";
           
            retorno = session.createSQLQuery(consulta)
                    .addScalar("campoAgrupador", Hibernate.INTEGER)
                    .addScalar("nomeFormaArrecadacao", Hibernate.STRING)
                    .addScalar("valorTarifa", Hibernate.BIG_DECIMAL)
                    .addScalar("dataPrevista", Hibernate.DATE)
                    .addScalar("qtdDocumentos", Hibernate.INTEGER)
                    .addScalar("qtdPagamentos", Hibernate.INTEGER)
                    .addScalar("debitos", Hibernate.BIG_DECIMAL)
                    .addScalar("descontos", Hibernate.BIG_DECIMAL)
                    .addScalar("devolucoes", Hibernate.BIG_DECIMAL)
                    .list();
           
        }catch(HibernateException e) {
            throw new ErroRepositorioException("Erro no Hibernate");
        }finally{
            HibernateUtil.closeSession(session);
        }
       
        return retorno;
    }
    
    /**
	 * @autor Adriana MUniz
	 * @date 10/12/2012
	 * 
	 * Consultar Dados Diários da Arrecadação a partir da tabela arrecadacao_dados_diarios_aulixiar
	 * 
	 * Método para montar a parte WHERE da query de 
	 * filtrar os dados diários para qualquer aba da funcionalidade
	 * 
	 *
	 * @param filtro
	 * @param labelTabela
	 * @return
	 */
	private String montarWhereFiltrarDadosDiariosArrecadacaoAuxiliar(FiltroConsultarDadosDiariosArrecadacaoAuxiliar filtro,
		String labelTabela){
		String SQLConsultaADD = " WHERE ";
		
		if (filtro.getAnoMesArrecadacao() != null && !filtro.getAnoMesArrecadacao().equals("")
				&& !filtro.getAnoMesArrecadacao().equals("-1")){
			// @TODO: melhorar isso
			if(labelTabela.equals("ad")){
				SQLConsultaADD += labelTabela + ".ardd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao() + " and ";	
			} else {
				SQLConsultaADD += labelTabela + ".dvdd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao() + " and ";
			}
			
		}
		
		if (filtro.getIdGerenciaRegional() != null && !filtro.getIdGerenciaRegional().equals("")
				&& !filtro.getIdGerenciaRegional().equals("-1")){
			SQLConsultaADD += labelTabela + ".greg_id = " + filtro.getIdGerenciaRegional() + " and ";
		}
		if (filtro.getIdUnidadeNegocio() != null && !filtro.getIdUnidadeNegocio().equals("")
				&& !filtro.getIdUnidadeNegocio().equals("-1")){
			SQLConsultaADD += labelTabela + ".uneg_id = " + filtro.getIdUnidadeNegocio() +  " and ";
		}
		if (filtro.getIdElo() != null && !filtro.getIdElo().equals("")
				&& !filtro.getIdElo().equals("-1")){
			SQLConsultaADD += " loc.loca_cdelo = " + filtro.getIdElo() + " and ";
		}
		if (filtro.getIdLocalidade() != null && !filtro.getIdLocalidade().equals("")
				&& !filtro.getIdLocalidade().equals("-1")){
			SQLConsultaADD += labelTabela + ".loca_id = " + filtro.getIdLocalidade()  + " and ";
		}
		if (filtro.getIdArrecadador() != null && !filtro.getIdArrecadador().equals("")
				&& !filtro.getIdArrecadador().equals("-1")){
			SQLConsultaADD += labelTabela + ".arrc_id = " + filtro.getIdArrecadador()  + " and ";
		}
		if (filtro.getIdFormaArrecadacao() != null && !filtro.getIdFormaArrecadacao().equals("")){
			if (filtro.getIdFormaArrecadacao().equals("0")){
				SQLConsultaADD += labelTabela + ".arfm_id is null and ";
			} else if (!filtro.getIdFormaArrecadacao().equals("-1")){
				SQLConsultaADD += labelTabela + ".arfm_id = " + filtro.getIdFormaArrecadacao()  + " and ";
			}
		}		

		if (filtro.getIdDocumentoTipo() != null && !filtro.getIdDocumentoTipo().equals("")){
			
			if (filtro.getIdDocumentoTipo().equals("0")){
				SQLConsultaADD += labelTabela + ".dotp_id is null and ";	
			} else if (!filtro.getIdDocumentoTipo().equals("-1")){
				SQLConsultaADD += labelTabela + ".dotp_id = " + filtro.getIdDocumentoTipo()  + " and ";
			}
		}		

		if (filtro.getIdsDocumentoTipoAgregador() != null && filtro.getIdsDocumentoTipoAgregador().length > 0){
			
			String idsDocumentoTipoAgregador[] = filtro.getIdsDocumentoTipoAgregador();
			
			if (!idsDocumentoTipoAgregador[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")) {

				if (idsDocumentoTipoAgregador.length == 1){
					if (idsDocumentoTipoAgregador[0].equals("0")){
						SQLConsultaADD += labelTabela + ".dotp_idagregador is null and ";	
					} else {
						SQLConsultaADD += labelTabela + ".dotp_idagregador = " + idsDocumentoTipoAgregador[0] + " and ";	
					}					
				} else {
					SQLConsultaADD += labelTabela + ".dotp_idagregador in ( ";
					for (int j = 0; j < idsDocumentoTipoAgregador.length; j++) {
						SQLConsultaADD += idsDocumentoTipoAgregador[j] + ", ";
					}
					SQLConsultaADD = Util.removerUltimosCaracteres(SQLConsultaADD, 2);
					SQLConsultaADD += ") and ";				
				}
				
			}

		}		

		return SQLConsultaADD;
		
	}
	
	/**
	 * @author Adriana Muniz
	 * @date 10/12/2012
	 * 
	 * Consultar Dados Diários da Arrecadação a partir da tabela arrecadacao_dados_diarios_aulixiar
	 *
	 * Verificar se existe dados diarios da arrecadacao de acordo com o filtro 
	 * passado
	 *
	 *
	 * @param filtro
	 * @return boolean de existencia dos dados
	 * @throws ErroRepositorioException
	 */
	public boolean verificarExistenciaDadosDiariosArrecadacaoAuxiliar(FiltroConsultarDadosDiariosArrecadacaoAuxiliar filtro)
		throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		
		String join1 = "";
		String join2 = "";
		
		if (filtro.getIdElo() != null && !filtro.getIdElo().equals("")){
			join1 = " left join cadastro.localidade loc on loc.loca_id = ad.loca_id ";
			join2 = " left join cadastro.localidade loc on loc.loca_id = dd.loca_id ";
		}
		
		String 	SQLVerificarADD = "SELECT ad.ardd_id as id from arrecadacao.arrecadacao_dados_diarios_auxiliar ad "
			+ join1 + montarWhereFiltrarDadosDiariosArrecadacaoAuxiliar(filtro, "ad");
		String 	SQLVerificarDDD1 = "SELECT dd.dvdd_id as id from arrecadacao.devolucao_dados_diarios_auxiliar dd "
			+ join2 + montarWhereFiltrarDadosDiariosArrecadacaoAuxiliar(filtro, "dd") 
			+ " dd.dvdd_tipodevolucao <> 'N' ";
		String 	SQLVerificarDDD2 = "SELECT dd.dvdd_id as id from arrecadacao.devolucao_dados_diarios_auxiliar dd "
			+ join2 + montarWhereFiltrarDadosDiariosArrecadacaoAuxiliar(filtro, "dd") 
			+ " dd.dvdd_tipodevolucao = 'N' ";

		Integer retornoSQL = null;
		boolean retorno = false;
		try {
			SQLVerificarADD = Util.removerUltimosCaracteres(SQLVerificarADD, 4);
			retornoSQL = (Integer) session.createSQLQuery(SQLVerificarADD)
				.addScalar("id", Hibernate.INTEGER).setMaxResults(1).uniqueResult();
			
			if (retornoSQL != null) {
				retorno = true;
			} else {
				retornoSQL = (Integer) session.createSQLQuery(SQLVerificarDDD1)
					.addScalar("id", Hibernate.INTEGER).setMaxResults(1).uniqueResult();
				if (retornoSQL != null){
					retorno = true;
				} else {
					retornoSQL = (Integer) session.createSQLQuery(SQLVerificarDDD2)
					.addScalar("id", Hibernate.INTEGER).setMaxResults(1).uniqueResult();
					if (retornoSQL != null){
						retorno = true;
					}
				}
			}
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
    
	/**
	 * @author Adriana Muniz
	 * @date 11/12/2012
	 * 
	 * Consultar Dados Diários da Arrecadação Auxiliar
	 * 
	 * @param filtro
	 * @return
	 * @throws ErroRepositorioException 
	 */
	public Collection filtrarDadosDiariosArrecadacaoAuxiliar(FiltroConsultarDadosDiariosArrecadacaoAuxiliar filtro) throws ErroRepositorioException{
		Collection retorno = new ArrayList();
		
		Session session = HibernateUtil.getSession();
		String 	SQLGeral = null;
		String	SQLConsultaADD = "SELECT ";
		String 	SQLConsultaADD_FROM = " FROM ARRECADACAO.ARRECADACAO_DADOS_DIARIOS_AUXILIAR ad ";
		String	SQLConsultaDDD1 = "SELECT ";
		String 	SQLConsultaDDD1_FROM = " FROM ARRECADACAO.DEVOLUCAO_DADOS_DIARIOS_AUXILIAR dd ";
		Type tipo= null;
		
		switch (filtro.getAgrupamento()) {
		case ANO_MES:
			
			SQLConsultaADD += " ad.ardd_amreferenciaarrecadacao ";
			SQLConsultaDDD1 += " dd.dvdd_amreferenciaarrecadacao ";
			tipo = Hibernate.INTEGER;
			break;
		case ARRECADADOR:
			
			SQLConsultaADD += " ad.arrc_id ";
			SQLConsultaDDD1 += " dd.arrc_id ";
			tipo = Hibernate.INTEGER;
			break;
		case CATEGORIA:
			
			SQLConsultaADD += " ad.catg_id ";
			SQLConsultaDDD1 += " dd.catg_id ";
			tipo = Hibernate.INTEGER;
			break;			
		case ELO:
			
			SQLConsultaADD += " loc.loca_cdelo ";
			SQLConsultaDDD1 += " loc.loca_cdelo ";
			tipo = Hibernate.INTEGER;
			break;			
		case FORMA_ARRECADACAO:

			SQLConsultaADD += " ad.arfm_id ";
			SQLConsultaDDD1 += " dd.arfm_id ";
			tipo = Hibernate.INTEGER;
			break;			
		case GERENCIA_REGIONAL:

			SQLConsultaADD += " ad.greg_id ";
			SQLConsultaDDD1 += " dd.greg_id ";
			tipo = Hibernate.INTEGER;
			break;			
		case LOCALIDADE:
			
			SQLConsultaADD += " ad.loca_id ";
			SQLConsultaDDD1 += " dd.loca_id ";
			tipo = Hibernate.INTEGER;
			break;			
		case PERFIL:
			
			SQLConsultaADD += " ad.iper_id ";
			SQLConsultaDDD1 += " dd.iper_id ";
			tipo = Hibernate.INTEGER;
			break;			
		case TIPO_DOCUMENTO:

			SQLConsultaADD += " ad.dotp_id ";
			SQLConsultaDDD1 += " dd.dotp_id ";
			tipo = Hibernate.INTEGER;
			break;			
		case TIPO_DOCUMENTO_AGREGADOR:
			
			SQLConsultaADD += " ad.dotp_idagregador ";
			SQLConsultaDDD1 += " dd.dotp_idagregador ";
			tipo = Hibernate.INTEGER;
			break;			
		case UNIDADE_NEGOCIO:

			SQLConsultaADD += " ad.uneg_id ";
			SQLConsultaDDD1 += " dd.uneg_id ";
			tipo = Hibernate.INTEGER;
			break;
		case DATA:
			
			SQLConsultaADD += " ad.ardd_dtpagamento ";
			SQLConsultaDDD1 += " dd.dvdd_dtdevolucao ";
			tipo = Hibernate.DATE;
		}
		
		// definindo somatorios para o select
		SQLConsultaADD += " as itemADD, sum(ad.ardd_qtdocumentos) as qtdDocumentos, sum(ad.ardd_qtpagamentos) as qtdPagamentos, " +
				"sum(ad.ardd_vlpagamentos) as debitos ";
		
		SQLConsultaDDD1 += 
			" as itemDDD, sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDescontos, " +
			"  sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDevolucoes, " +
			"  sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDescontos, " +
			"  sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDevolucoes, " +
			"  sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDescontos, " +
			"  sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDevolucoes ";
		
		// adicionando as tabelas para os joins
		if (filtro.getAgrupamento().equals(FiltroConsultarDadosDiariosArrecadacao.GROUP_BY.ELO)
				|| (filtro.getIdElo() != null && !filtro.getIdElo().equals(""))){
			SQLConsultaADD_FROM += " LEFT JOIN CADASTRO.LOCALIDADE LOC ON AD.LOCA_ID = LOC.LOCA_ID ";
			SQLConsultaDDD1_FROM += " LEFT JOIN CADASTRO.LOCALIDADE LOC ON DD.LOCA_ID = LOC.LOCA_ID ";
		}
			
		// acrescentando a parte from
		SQLConsultaADD += SQLConsultaADD_FROM;
		SQLConsultaDDD1 += SQLConsultaDDD1_FROM;
		
		// metodo gera as condicoes de acordo com os valores preenchidos no filtro
		SQLConsultaADD += montarWhereFiltrarDadosDiariosArrecadacaoAuxiliar(filtro, "ad");
		SQLConsultaDDD1 += montarWhereFiltrarDadosDiariosArrecadacaoAuxiliar(filtro, "dd");
		
		// retirar o and do final, caso exista
		if (SQLConsultaADD.lastIndexOf("and") >= (SQLConsultaADD.length() - 4)){
			SQLConsultaADD  = Util.removerUltimosCaracteres(SQLConsultaADD , 4);
		}		
		
		// retirar o and do final, caso exista
		if (SQLConsultaDDD1.lastIndexOf("and") >= (SQLConsultaDDD1.length() - 4)){
			SQLConsultaDDD1  = Util.removerUltimosCaracteres(SQLConsultaDDD1, 4);
		}
		
		SQLConsultaADD += " group by itemADD ";
		SQLConsultaDDD1 += " group by itemDDD ";
		
		SQLGeral = "SELECT coalesce(ardd.itemADD, ddd1.itemDDD) as campoAgrupador, " +
				" (COALESCE(ARDD.qtdDocumentos,0) + COALESCE(DDD1.qtdDocumentosDescontos,0) + COALESCE(DDD1.qtdDocumentosDevolucoes,0)) as qtdDocumentos, " +
				" (COALESCE(ARDD.qtdPagamentos,0) + COALESCE(DDD1.qtdPagamentosDescontos,0) + COALESCE(DDD1.qtdPagamentosDevolucoes,0)) as qtdPagamentos, " +
				" COALESCE(ARDD.debitos, 0) as debitos, COALESCE(DDD1.valorDescontos, 0) as descontos, " +
				" COALESCE(DDD1.valorDevolucoes, 0) as devolucoes " +
				" FROM (" + SQLConsultaADD + ") as ARDD " +
				" FULL JOIN (" + SQLConsultaDDD1 + ") as DDD1 on (ARDD.itemADD = DDD1.itemDDD) " +
				" order by campoAgrupador "; 

		try {
			retorno = session.createSQLQuery(SQLGeral)
				.addScalar("campoAgrupador", tipo)
				.addScalar("qtdDocumentos", Hibernate.INTEGER)
				.addScalar("qtdPagamentos", Hibernate.INTEGER)
				.addScalar("debitos", Hibernate.BIG_DECIMAL)
				.addScalar("descontos", Hibernate.BIG_DECIMAL)
				.addScalar("devolucoes", Hibernate.BIG_DECIMAL)
				.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

//			System.out.println("Tempo de execução da query (" + filtro.getAgrupamento() +
//					") " + (System.currentTimeMillis() - t1));
		
		return retorno;

	}
	
	/**
	 * @author Adriana Muniz
	 * @date 05/12/2012
	 * 
	 * Exclui os dados diários da arrecadação do ano/mês da arrecadação corrente
	 * por localidade da a tabela arrecadacao_dados_diarios_auxiliar
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 */
	public void excluirDadosDiariosArrecadacaoAuxiliarPorAnoMesArrecadacaoPorLocalidade(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Constroi o hql para remover os dados diários da arrecadação
			// referentes ao ano/mês de arrecadação atual
			consulta = " DELETE ArrecadacaoDadosDiariosAuxiliar ardd " +
					" WHERE ardd.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao " +
					" AND ardd.localidade.id = :idLocalidade";

			// Executa o hql
			session.createQuery(consulta)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * @author Adriana Muniz
	 * @date 12/12/2012
	 * 
	 * Exclui os dados diários da devolucao auxiliar do ano/mês da arrecadação corrente
	 * por localidade
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 */
	public void excluirDadosDiariosDevolucaoPorAnoMesArrecadacaoAuxiliarPorLocalidade(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Constroi o hql para remover os dados diários de devolucao
			// referentes ao ano/mês de arrecadação atual
			consulta = "delete DevolucaoDadosDiariosAuxiliar dvdd where dvdd.anoMesReferencia = :anoMesReferenciaArrecadacao and dvdd.localidade.id = :idLocalidade";

			// Executa o hql
			session.createQuery(consulta)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * @author Adriana Muniz
	 * @date 05/12/2012
	 * 
	 * Acumula a quantidade e o valor dos pagamentos com ano/mês de referência
	 * da arrecadação igual ao ano/mês de referência da arrecadação corrente,
	 * 
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoAuxiliar(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a variávelque vai armazenar a coleção de pagamentos
		Collection retorno = new ArrayList();

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

//				 Cria o hql para acumular o valor e quantidade de pagamentos
			consulta = acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoAuxiliarMontarQuery();
			retorno = session.createSQLQuery(consulta)
				.addScalar("somaValor", Hibernate.BIG_DECIMAL)
				.addScalar("qtdPagamento", Hibernate.INTEGER)
				.addScalar("idGreg", Hibernate.INTEGER)
				.addScalar("idAviso", Hibernate.INTEGER)
				.addScalar("idArrecadador", Hibernate.INTEGER)
				.addScalar("idTipoDocumento", Hibernate.INTEGER)
				.addScalar("idFormaArrec", Hibernate.INTEGER)
				.addScalar("dataPagamento", Hibernate.DATE)
				.addScalar("idUN", Hibernate.INTEGER)
				.addScalar("idTipoDocumentoAgregador", Hibernate.INTEGER)
				.addScalar("qtdDocumentosAgregados", Hibernate.INTEGER)
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("idLocalidade", idLocalidade)				
				.list();
			
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de pagamentos
		return retorno;
	}

	/**
	 * @author Adriana Muniz
	 * @date 05/12/2012
	 * 
	 * Contrucao da query usada no metodo acumularQuantidadeEValorPagamentoPorAnoMesArrecadacao
	 *  
	 * @see acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoAuxiliar
	 */
	private String acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoAuxiliarMontarQuery(){
		String queryFinal = "";
		String parteSelect = "select sum(pgmt.pgmt_vlpagamento) as somaValor,"
			+ "count(pgmt.pgmt_id) as qtdPagamento,"
			+ "uneg.greg_id as idGreg,"
			+ "avbc.avbc_id as idAviso,"
			+ "avbc.arrc_id as idArrecadador,"
			+ "pgmt.dotp_id as idTipoDocumento,"
			+ "pgmt.arfm_id as idFormaArrec,"
			+ "pgmt.pgmt_dtpagamento as dataPagamento,"
			+ "uneg.uneg_id  as idUN, "
			+ "pgmt.dotp_idagregador as idTipoDocumentoAgregador ";
			
		String parteFrom = " from arrecadacao.pagamento pgmt "
			+ "left join arrecadacao.aviso_bancario avbc on pgmt.avbc_id = avbc.avbc_id "
			+ "left join cadastro.localidade loca on pgmt.loca_id = loca.loca_id "
			+ "left join cadastro.unidade_negocio uneg on uneg.uneg_id = loca.uneg_id ";
		
			
		String parteWhere = "where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferenciaArrecadacao " +
				"and loca.loca_id = :idLocalidade ";
		
		String parteGroupBy = "group by uneg.greg_id, avbc.avbc_id, avbc.arrc_id, pgmt.dotp_id, " +
				"pgmt.arfm_id, pgmt.pgmt_dtpagamento, uneg.uneg_id, " +				
				"pgmt.dotp_idagregador "; 
		
		// Caso o tipo do documento agregador seja igual ao tipo de documento do pagamento
		// DocumentoTipoAgregador, IdDocumento, CountDocumento
		queryFinal = parteSelect +	", count(distinct pgmt.pgmt_id) as qtdDocumentosAgregados "  
			+ parteFrom + parteWhere 
			+ " and (pgmt.dotp_id = pgmt.dotp_idagregador or (pgmt.cbdo_id is null and pgmt.fatu_id is null)) "
			+ parteGroupBy 
			
		// UNION > Caso a identificacao do documento agregador seja diferente de nulo
			+ " UNION "
			+ parteSelect + ", count(distinct pgmt.cbdo_id) as qtdDocumentosAgregados "
			+ parteFrom + parteWhere 
			+ " and pgmt.dotp_id <> pgmt.dotp_idagregador and pgmt.cbdo_id is not null "
			+ parteGroupBy 

		// UNION > Caso a identificacao da fatura seja diferente de nulo
			+ " UNION "
			+ parteSelect + ", count(distinct pgmt.fatu_id) as qtdDocumentosAgregados "
			+ parteFrom + parteWhere 
			+ " and pgmt.dotp_id <> pgmt.dotp_idagregador and pgmt.fatu_id is not null "
			+ parteGroupBy 			
			;		  

		return queryFinal;

	}
	
	/**
	 * @author Adriana Muniz
	 * @date 12/12/2012
	 * 
	 * Acumula a quantidade e o valor das devolucoes com ano/mês de referência
	 * da arrecadação igual ao ano/mês de referência da arrecadação corrente 
	 * para ser persistido na tabela devolucao_dados_diarios_auxiliar
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacaoAuxiliar(
			int anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		// Cria a variávelque vai armazenar a coleção de pagamentos
		Collection retorno = new ArrayList();

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try {

			// Cria o hql para acumular o valor e quantidade de pagamentos
			consulta = acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacaoMontarQuery();
			retorno = session.createSQLQuery(consulta)
				.addScalar("somaValor", Hibernate.BIG_DECIMAL)
				.addScalar("qtdDevolucoes", Hibernate.INTEGER)
				.addScalar("idGreg", Hibernate.INTEGER)
				.addScalar("idAviso", Hibernate.INTEGER)
				.addScalar("idArrecadador", Hibernate.INTEGER)
				.addScalar("idFormaArrec", Hibernate.INTEGER)
				.addScalar("dataDevolucao", Hibernate.DATE)
				.addScalar("idUN", Hibernate.INTEGER)
				.addScalar("idTipoDocumentoAgregador", Hibernate.INTEGER)
				.addScalar("qtdDocumentosAgregados", Hibernate.INTEGER)
				.addScalar("tipoDevolucao", Hibernate.STRING)
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("idLocalidade", idLocalidade).list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de pagamentos
		return retorno;
	}

	/**
	 * @author Adriana Muniz
	 * @date 12/12/2012
	 * 
	 * Contrucao da query usada no metodo acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacaoAuxiliar
	 *  
	 * @see acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacaoAuxiliar
	 */
	private String acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacaoAuxiliarMontarQuery(){
		String queryFinal = "";
		String parteSelect = "select sum(dev.devl_vldevolucao) as somaValor,"
			+ "count(dev.devl_id) as qtdDevolucoes,"
			+ "uneg.greg_id as idGreg,"
			+ "avbc.avbc_id as idAviso,"
			+ "avbc.arrc_id as idArrecadador,"
			+ "avbc.arfm_id as idFormaArrec,"
			+ "dev.devl_dtdevolucao as dataDevolucao,"
			+ "uneg.uneg_id as idUN, " 
			+ "dev.dotp_idagregador as idTipoDocumentoAgregador ";
			
		String parteFrom = " from arrecadacao.devolucao dev "
			+ "left join arrecadacao.aviso_bancario avbc on dev.avbc_id=avbc.avbc_id "
			+ "left join cadastro.localidade loca on dev.loca_id = loca.loca_id "
			+ "left join cadastro.unidade_negocio uneg on uneg.uneg_id = loca.uneg_id "
		    ;
			
		String parteWhere = "where dev.devl_amreferenciaarrecadacao = :anoMesReferenciaArrecadacao " +
							"and dev.loca_id = :idLocalidade ";

		String parteGroupBy = "group by uneg.greg_id, avbc.avbc_id, avbc.arrc_id," +
							  "avbc.arfm_id, dev.devl_dtdevolucao, uneg.uneg_id, dev.dotp_idagregador ";
		
		// Caso o tipo do documento agregador seja nulo => Tipo de Devolucao Normal
		queryFinal = parteSelect +	", count(dev.devl_id) as qtdDocumentosAgregados, 'N' as tipoDevolucao " // DocumentoTipoAgregador, IdDocumento, CountDocumento 
			+ parteFrom + parteWhere 
			+ " and dev.dotp_idagregador is null "
			+ parteGroupBy 
			
		// UNION > Caso a identificacao do documento agregador seja diferente de nulo e a identificacao do Credito a 
			// Realizar seja diferente de nulo => Tipo de Devolucao Credito
			
			+ " UNION "
			+ parteSelect + ", count(distinct dev.cbdo_id) as qtdDocumentosAgregados, 'C' as tipoDevolucao "
			+ parteFrom 
			+ parteWhere 
			+ " and dev.dotp_idagregador is not null and dev.cbdo_id is not null and dev.crar_id is not null "
			+ parteGroupBy 

		// UNION > Caso a identificacao do Credito a realizar seja nula => Tipo de Devolucao Desconto
			+ " UNION "
			+ parteSelect + ", count(distinct dev.cbdo_id) as qtdDocumentosAgregados, 'D' as tipoDevolucao "
			+ parteFrom 
			+ parteWhere
			+ " and dev.dotp_idagregador is not null and dev.cbdo_id is not null and dev.crar_id is null "
			+ parteGroupBy 			
			;		  

		return queryFinal;

	}
	
	/**
    *
    * Relatório Analitico dos valores diários da arrecadação com tarifa
    *
    * @author Adriana Muniz
    * data: 19/12/2012
    *
    * obtém as formas de arrecadação com tarifa por dia
    * @param helper
    * @param filtro
    * @return coleção
    */
   public Collection obterFormasDeArrecadacaoComTarifaPorDiaAuxiliar(
           Object helper, FiltroConsultarDadosDiariosArrecadacaoAuxiliar filtro) throws ErroRepositorioException {

       Collection retorno = null;
       String consulta;
       Session session = HibernateUtil.getSession();
       try {
           consulta = " SELECT coalesce(ardd.itemADD, ddd1.itemDDD) AS campoAgrupador, "
                   +  " arfm_dsarrecadacaoforma AS nomeFormaArrecadacao, "
                   +  " ARDD.valorTarifa as valorTarifa, "
                   +  " ardd.dataprevista as dataPrevista, "
                   +  " (COALESCE(ARDD.qtdDocumentos,0) + COALESCE(DDD1.qtdDocumentosDescontos,0) + COALESCE(DDD1.qtdDocumentosDevolucoes,0)) as qtdDocumentos,"
                   +  " (COALESCE(ARDD.qtdPagamentos,0) + COALESCE(DDD1.qtdPagamentosDescontos,0) + COALESCE(DDD1.qtdPagamentosDevolucoes,0)) as qtdPagamentos,  "
                   +  " COALESCE(ARDD.debitos, 0) as debitos, "
                   +  " COALESCE(DDD1.valorDescontos, 0) as descontos, "
                   +  " COALESCE(DDD1.valorDevolucoes, 0) as devolucoes "
                   +  " from (SELECT      ad.arfm_id  as itemADD, "
                   +  " sum(ardd_vltarifa) as valorTarifa, "
                   +  " (date(ad.ardd_dtpagamento) + cast(ad.ardd_nndiafloat as integer)) as dataPrevista, "
                   +  " sum(ad.ardd_qtdocumentos) as qtdDocumentos, "
                   +  " sum(ad.ardd_qtpagamentos) as qtdPagamentos, "
                   +  " sum(ad.ardd_vlpagamentos) as debitos "
                   +  " FROM arrecadacao.arrecadacao_dados_diarios_auxiliar ad "
                   +  " WHERE ad.ardd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao()
                   +  " and ad.arrc_id = " + filtro.getIdArrecadador()
           		   +  " and date(ardd_dtpagamento) = '" + helper.toString()+"' "
                   +  " group by itemADD, dataPrevista) as ARDD    "
                   +  " full join (SELECT      dd.arfm_id  as itemDDD,  "
                   +  " 0 as valorTarifa, "
                   +  " null as dataPrevista, "
                   +  " sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDescontos, "
                   +  " sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdocumentos else 0 end) as qtdDocumentosDevolucoes, "
                   +  " sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDescontos, "
                   +  " sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_qtdevolucoes else 0 end) as qtdPagamentosDevolucoes, "
                   +  " sum(case when (dd.dvdd_tipodevolucao <> 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDescontos,  "
                   +  " sum(case when (dd.dvdd_tipodevolucao = 'N') then dd.dvdd_vldevolucoes else 0 end) as valorDevolucoes "
                   +  " FROM arrecadacao.devolucao_dados_diarios_auxiliar dd "
                   +  " WHERE dd.dvdd_amreferenciaarrecadacao = " + filtro.getAnoMesArrecadacao()
                   +  " and dd.arrc_id = " + filtro.getIdArrecadador()
                   +  " and date(dvdd_dtdevolucao) = '" + helper.toString()+"' "
                   +  " group by itemDDD ) as DDD1 on (ARDD.itemADD = DDD1.itemDDD) "
                   +  " inner join arrecadacao.arrecadacao_forma af on (af.arfm_id = coalesce(ardd.itemADD, ddd1.itemDDD)) "
                   +  " order by campoAgrupador  ";
          
           retorno = session.createSQLQuery(consulta)
                   .addScalar("campoAgrupador", Hibernate.INTEGER)
                   .addScalar("nomeFormaArrecadacao", Hibernate.STRING)
                   .addScalar("valorTarifa", Hibernate.BIG_DECIMAL)
                   .addScalar("dataPrevista", Hibernate.DATE)
                   .addScalar("qtdDocumentos", Hibernate.INTEGER)
                   .addScalar("qtdPagamentos", Hibernate.INTEGER)
                   .addScalar("debitos", Hibernate.BIG_DECIMAL)
                   .addScalar("descontos", Hibernate.BIG_DECIMAL)
                   .addScalar("devolucoes", Hibernate.BIG_DECIMAL)
                   .list();
          
       }catch(HibernateException e) {
           throw new ErroRepositorioException("Erro no Hibernate");
       }finally{
           HibernateUtil.closeSession(session);
       }
      
       return retorno;
   }
   
   /**
	 * Mudança de conta contábil de recebimentos até 12/2012 classificados no mês atual;
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idImpostoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesPorTipoImposto(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idImpostoTipo) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			
			consulta = "select " +
					 " sum(cnid.cnid_vlimposto) as col_0, " +
					 " cnta.imov_id as col_1 " + 
					 "from " +
					 " faturamento.conta_impostos_deduzidos cnid  " +
					 "inner join faturamento.conta cnta on cnid.cnta_id=cnta.cnta_id " + 
					 "where " +
					 " cnid.imtp_id= :idImpostoTipo  " +
					 " and (cnta.cnta_id in (" +
											 "select " +
											 "distinct pgmt.cnta_id " + 
											 "from " +
											 "arrecadacao.pagamento pgmt " + 
											 "where " +
											 "pgmt.pgmt_amreferenciaarrecadacao < 201301  " + 
											 "and pgmt.loca_id= :idLocalidade  " +
											 "and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
											 "and (pgmt.cnta_id is not null) "		+	
					 ")) " +
					 " group by cnta.imov_id ";
			
			retorno = session.createSQLQuery(consulta)
			 		.addScalar("col_0", Hibernate.BIG_DECIMAL)
			 		.addScalar("col_1", Hibernate.INTEGER)
					.setInteger("idImpostoTipo",idImpostoTipo)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.list();

		
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Contabilizar valores arrecadados até dezembro de 2012 em contas diferentes.
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] acumularValorAguaEsgotoPagamentosContasEfetuadosAte122012ClassificadosNoMes(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(ctcg.ctcg_vlagua) as col_0,  " +
					  "sum(ctcg.ctcg_vlesgoto) as col_1  " +
					  "from " +
					   "faturamento.conta_categoria ctcg " + 
					  "where " +
					   "ctcg.catg_id= :idCategoria  " +
					   "and (ctcg.cnta_id in (" +
										   "select " +
										   "distinct pgmt.cnta_id " + 
										   "from " +
										   "arrecadacao.pagamento pgmt " + 
										   "where " +
										   "pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
										   "and pgmt.loca_id= :idLocalidade  " +
										   "and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										   "and (pgmt.cnta_id is not null) "	+		
					   ") ) " ;
			
			retorno = (Object[]) session.createSQLQuery(consulta)
			 		.addScalar("col_0",Hibernate.BIG_DECIMAL)
			 		.addScalar("col_1",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Contabilizar valores arrecadados até 31/12/2012 em contas diferentes
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorFinanciamentoTipo(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idFinanciamentoTipo)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(dccg.dccg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.debito_cobrado_categoria dccg " + 
					  "where " +
					   "dccg.catg_id= :idCategoria  " +
					   "and (dccg.dbcb_id in ( " +
					 				"select " +
					 				"dbcb.dbcb_id " + 
					 				"from " +
					 				"faturamento.debito_cobrado dbcb " + 
					 				"where " +
					 				"dbcb.fntp_id= :idFinanciamentoTipo  " +
					 				"and (dbcb.cnta_id in (" +
										 				"select " +
										 				"distinct pgmt.cnta_id " + 
										 				"from " +
										 				"arrecadacao.pagamento pgmt " + 
										 				"where " +
										 				"pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
										 				"and pgmt.loca_id= :idLocalidade  " +
										 				"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 				"and (pgmt.cnta_id is not null) "			+
					 				")) " +
					 			") " +
					   ")";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
			  		.addScalar("col_0", Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Alteração na contabilização de contas arrecadadas até 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idOrigemCredito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorOrigemCredito(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idOrigemCredito)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(crcg.crcg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.cred_realizado_catg crcg " + 
					  "where " +
					   "crcg.catg_id=:idCategoria " + 
					   "and (crcg.crrz_id in ( " +
					 			"select " +
					 			"crrz.crrz_id " + 
					 			"from " +
					 			"faturamento.credito_realizado crrz " + 
					 			"where " +
					 			"crrz.crog_id= :idOrigemCredito " +
					 			"and (crrz.cnta_id in (" +
									 			"select " +
									 			"distinct pgmt.cnta_id " + 
									 			"from " +
									 			"arrecadacao.pagamento pgmt " + 
									 			"where " +
									 			"pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
									 			"and pgmt.loca_id= :idLocalidade  " +
									 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
									 			"and (pgmt.cnta_id is not null) "	+		
					 			")) " +
					 	") " +
					   ")";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0", Hibernate.BIG_DECIMAL)	
					.setInteger("idCategoria", idCategoria)
					.setInteger("idOrigemCredito",idOrigemCredito)
					.setInteger("idLocalidade",idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	
	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Contabilizar em contas diferentes os valores arrecadados até 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoEntradaParcelamento(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria) throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(gpcg.gpcg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.guia_pagamento_categoria gpcg " + 
					  "where " +
					   "gpcg.catg_id= :idCategoria  " +
					   "and (gpcg.gpag_id in ( " +
					 			"select " +
					 			"gpag.gpag_id " + 
					 			"from " +
					 			"faturamento.guia_pagamento gpag " + 
					 			"where " +
					 			"gpag.fntp_id= :idFinanciamentoTipo  " +
					 			"and (gpag.gpag_id in (" +
										 			"select " +
										 			"distinct pgmt.gpag_id as col_0 " + 
										 			"from " +
										 			"arrecadacao.pagamento pgmt " + 
										 			"where " +
										 			"pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
										 			"and pgmt.loca_id= :idLocalidade  " +
										 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 			"and (pgmt.gpag_id is not null) " +
					 			")) " +
					 			") " +
					   ")";
			
			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.ENTRADA_PARCELAMENTO)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

	
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	
	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Contabilizar em contas diferentes valores arrecadados até 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @param idsFinanciamentoTipos
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorFinanciamentoTipo(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria,
			Collection<Integer> idsFinanciamentoTipos)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {
			
			consulta  = "select " +
						 " sum(dccg.dccg_vlcategoria) as col_0 " +
						 " from " +
						 "  faturamento.debito_cobrado_categoria dccg " + 
						 " where " +
						 "  dccg.catg_id= :idCategoria  " +
						 "  and (dccg.dbcb_id in ( " +
						 			"select " +
						 			"dbcb.dbcb_id " + 
						 			"from " +
						 			"faturamento.debito_cobrado dbcb " + 
						 			"where " +
						 			"dbcb.lict_id= :idLancamentoItemContabil  " +
						 			"and (dbcb.fntp_id in (:idsFinanciamentoTipos)) " + 
						 			"and (dbcb.cnta_id in (" +
											 			"select " +
											 			"distinct pgmt.cnta_id " + 
											 			"from " +
											 			"arrecadacao.pagamento pgmt " + 
											 			"where " +
											 			"pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
											 			"and pgmt.loca_id= :idLocalidade  " +
											 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
											 			"and (pgmt.cnta_id is not null) "	+		
						 			")) " +
					 				") " +
						   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setParameterList("idsFinanciamentoTipos",idsFinanciamentoTipos)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			
			

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Contabilizar em contas separadas valores arrecadados até 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoDoacoes(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idLancamentoItemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(dccg.dccg_vlcategoria) as col_0 " + 
					  "from " +
					   "faturamento.debito_cobrado_categoria dccg " + 
					  "where " +
					   "dccg.catg_id= :idCategoria  " +
					   "and (dccg.dbcb_id in ( " +
					 			"select " +
					 			"dbcb.dbcb_id " + 
					 			"from " +
					 			"faturamento.debito_cobrado dbcb " + 
					 			"where " +
					 			"dbcb.lict_id= :idLancamentoItemContabil  " +
					 			"and dbcb.fntp_id= :idFinanciamentoTipo  " +
					 			"and (dbcb.cnta_id in (" +
										 			"select " +
										 			"distinct pgmt.cnta_id " + 
										 			"from " +
										 			"arrecadacao.pagamento pgmt " + 
										 			"where " +
										 			"pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
										 			"and pgmt.loca_id= :idLocalidade  " +
										 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 			"and (pgmt.cnta_id is not null) "	+		
					 			")) " +
					 			") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.DOACOES)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	
	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Contabilizar em contas separadas valores arrecadados até 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idCategoria, 
			Integer idLancamentoItemContabil)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Coleção de crédito origem de valores cobrados indevidamente
		Collection idsCreditosOrigem = new ArrayList();
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_AGUA);
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO);
		idsCreditosOrigem.add(CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE);
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO);

		// cria a variável que vai conter o hql
		String consulta = "";

		try {
			
			consulta = "select " +
					  "sum(crcg.crcg_vlcategoria) as col_0  " +
					  "from " +
					   "faturamento.cred_realizado_catg crcg  " +
					  "where " +
					   "crcg.catg_id= :idCategoria  " +
					   "and (crcg.crrz_id in ( " +
					 			"select " +
					 			"crrz.crrz_id  " +
					 			"from " +
					 			"faturamento.credito_realizado crrz  " +
					 			"where " +
					 			"crrz.lict_id= :idLancamentoItemContabil  " +
					 			"and (crrz.crog_id in (:idsCreditosOrigem))  " +
					 			"and (crrz.cnta_id in (" +
										 			"select " +
										 			"distinct pgmt.cnta_id " + 
										 			"from " +
										 			"arrecadacao.pagamento pgmt " + 
										 			"where " +
										 			"pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
										 			"and pgmt.loca_id= :idLocalidade  " +
										 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 			"and (pgmt.cnta_id is not null) "	+		
					 			")) " +
					 			") " +
					  ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setParameterList("idsCreditosOrigem", idsCreditosOrigem)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Contabilizar em contas separadas valores arrecadados até 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria)
			throws ErroRepositorioException {

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta  = "select " +
					  "sum(gpcg.gpcg_vlcategoria) as col_0  " +
					  "from " +
					   "faturamento.guia_pagamento_categoria gpcg  " +
					  "where " +
					   "gpcg.catg_id= :idCategoria  " +
					   "and (gpcg.gpag_id in (  " +   
					 			"select " +
					 			"gpag.gpag_id  " +
					 			"from " +
					 			"faturamento.guia_pagamento gpag  " +
					 			"where " +
					 			"gpag.lict_id= :idLancamentoItemContabil  " +
					 			"and gpag.fntp_id= :idFinanciamentoTipo  " +
					 			"and (gpag.gpag_id in (" +
										 			"select " +
										 			"distinct pgmt.gpag_id as col_0 " + 
										 			"from " +
										 			"arrecadacao.pagamento pgmt " + 
										 			"where " +
										 			"pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
										 			"and pgmt.loca_id= :idLocalidade  " +
										 			"and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										 			"and (pgmt.gpag_id is not null) " +
					 			"))    " +  
					 			") " +
					   ")";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idFinanciamentoTipo",FinanciamentoTipo.SERVICO_NORMAL)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.uniqueResult();
			
			
			
			
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * 
	 * Contabilizar em contas separadas valores arrecadados até 31/12/2012
	 * 
	 * @author Wellington Rocha
	 * 
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosAte122012(
			Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao,
			Integer idLancamentoItemContabil, 
			Integer idCategoria)
			throws ErroRepositorioException {

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try {

			consulta = "select " +
					  "sum(dbcg.dbcg_vlcategoria-(trunc(dbcg.dbcg_vlcategoria/dbac.dbac_nnprestacaodebito,2)*dbac.dbac_nnprestacaocobradas)) as col_0 " +
					  "from " +
					   "faturamento.deb_a_cobrar_catg dbcg  " +
					  "inner join  faturamento.debito_a_cobrar dbac on dbcg.dbac_id=dbac.dbac_id  " +
					  "where " +
					   "dbcg.dbac_id=dbac.dbac_id  " +
					   "and dbac.lict_id=:idLancamentoItemContabil  " +
					   "and dbac.loca_id= :idLocalidade  " +
					   "and dbcg.catg_id=:idCategoria  " +
					   "and (dbac.dbac_id in (" +
										   "select " +
										   "distinct pgmt.dbac_id as col_0 " + 
										   "from " +
										   "arrecadacao.pagamento pgmt " + 
										   "where " +
										   "pgmt.pgmt_amreferenciaarrecadacao < 201301 " + 
										   "and pgmt.loca_id= :idLocalidade  " +
										   "and (pgmt.pgst_idatual= :idPagamentoClassificado or pgmt.pgst_idatual= :idPagamentoValorABaixar) " + 
										   "and (pgmt.dbac_id is not null) " +
					   ")) " ;

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("col_0",Hibernate.BIG_DECIMAL)
					.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idCategoria", idCategoria)
					.setInteger("idPagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("idPagamentoValorABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setMaxResults(1)
					.uniqueResult();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Felipe Santos - 22/10/2013
	 * 
	 * Retorna o total de Arrecadação por referência e localidade
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarTotalArrecadacaoRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade) throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "SELECT coalesce(sum(vlpag), 0) as total "
				+ "FROM ("
				+ "SELECT coalesce(sum(pgmt_vlpagamento), 0) as vlpag "
				+ "FROM arrecadacao.pagamento "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND pgmt_amreferenciaarrecadacao = :anoMesReferencia "
				
				+ "UNION "
				
				+ "SELECT coalesce(sum(pghi_vlpagamento), 0) as vlpag "
				+ "FROM arrecadacao.pagamento_historico "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND pghi_amreferenciaarrecadacao = :anoMesReferencia "
				
				+ "UNION "
				
				+ "SELECT coalesce(sum(devl_vldevolucao * -1), 0) as vlpag "
				+ "FROM arrecadacao.devolucao "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND devl_amreferenciaarrecadacao = :anoMesReferencia "

				+ "UNION "

				+ "SELECT coalesce(sum(dehi_vldevolucao * -1), 0) as vlpag "
				+ "FROM arrecadacao.devolucao_historico "
				+ "WHERE loca_id = :idLocalidade "
				+ "AND dehi_amreferenciaarrecadacao = :anoMesReferencia"
				
				+ ") as arrecadacao";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("total",Hibernate.BIG_DECIMAL)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Felipe Santos - 22/10/2013
	 * 
	 * Retorna diferença de datas e quantidade de pagamentos para
	 * Prazo Medio de Recebimento de Contas
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarPrazoMedioRecebimentoContasRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "SELECT sum(difDatas) as difDatas, "
				+ "sum(qtdPag) as qtdPag "
				+ "FROM ("
				
				+ "SELECT coalesce(sum(pgmt_dtpagamento - cnta_dtvencimentoconta), 0) as difDatas, "
				+ "count(pgmt_id) as qtdPag "
				+ "FROM arrecadacao.pagamento "
				+ "INNER JOIN faturamento.conta on conta.cnta_id = pagamento.cnta_id "
				+ "WHERE conta.loca_id = :idLocalidade "
				+ "AND pgmt_amreferenciaarrecadacao = :anoMesReferencia "
				
				+ "UNION " 

				+ "SELECT coalesce(sum(pghi_dtpagamento - cnhi_dtvencimentoconta), 0) as difDatas, "
				+ "count(pghi_id) as qtdPag "
				+ "FROM arrecadacao.pagamento_historico pagamento "
				+ "INNER JOIN faturamento.conta_historico conta on conta.cnta_id = pagamento.cnta_id "
				+ "WHERE conta.loca_id = :idLocalidade "
				+ "AND pghi_amreferenciaarrecadacao = :anoMesReferencia "

				+ ") as prazoMedio";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("difDatas",Hibernate.INTEGER)
					.addScalar("qtdPag",Hibernate.INTEGER)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * Felipe Santos - 08/11/2013
	 * 
	 * Retorna os dados para o Relatorio BIG
	 * 
	 * @param anoMesReferencia
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosRelatorioBIG(
			Integer anoMesReferencia) throws ErroRepositorioException {
		
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "SELECT greg.greg_nmregional as gerencia, "
				+ "loca.loca_nmlocalidade as localidade, "
				+ "boig_qtdcontas as quantidadeContas, "
				+ "boig_vlfaturamento as valorFaturamento, "
				+ "boig_vlarrecadacao as valorArrecadacao, "
				+ "boig_eficarrecadacao as eficienciaArrecadacao, "
				+ "boig_vlmediofaturamento as valorMedioFaturamento, "
				+ "boig_icqtderroscontas as indicadorQuantidadeErrosContas, "
				+ "boig_icvlerroscontas as indicadorValorErrosContas, "
				+ "boig_icrecebimentomedio as indicadorRecebimentoMedio, "
				+ "boig_icqtdinadimplenciaate30 as indicadorQuantidadeInadimplenciaAte30, "
				+ "boig_icvlinadimplenciaate30 as indicadorValorInadimplenciaAte30, "
				+ "boig_icqtdinadimplenciaate90 as indicadorQuantidadeInadimplenciaAte90, "
				+ "boig_icvlinadimplenciaate90 as indicadorValorInadimplenciaAte90, "
				+ "boig_icqtdinadimplenciamaior90 as indicadorQuantidadeInadimplenciaMaior90, "
				+ "boig_icvlinadimplenciamaior90 as indicadorValorInadimplenciaMaior90, "
				+ "boig_qtdfatcomprometidos as quantidadeFaturamentosComprometidos, "
				+ "boig_indicehidrometracao as indiceHidrometracao, "
				+ "boig_qtdhidrometrosinstalados as quantidadeHidrometrosInstalados, "
				+ "boig_qtdhidrometrossubstituidos as quantidadeHidrometrosSubstituidos, "
				+ "boig_prazomedioatendimentoos as prazoMedioAtendimentoOS, "
				+ "boig_qtdnovasligesgoto as quantidadeNovasLigacoesEsgoto, "
				+ "boig_economiasnovasligesgoto as economiasNovasLigacoesEsgoto, "
				+ "boig_qtdnovasligagua as quantidadeNovasLigacoesAgua, "
				+ "boig_economiasnovasligagua as economiasNovasLigacoesAgua, "
				+ "boig_qtdconsligados as quantidadeConsumidoresLigados, "
				+ "boig_qtdconscortados as quantidadeConsumidoresCortados, "
				+ "boig_qtdconssuprimidos as quantidadeConsumidoresSuprimidos, "
				+ "boig_qtdconsfactiveis as quantidadeConsumidoresFactiveis, "
				+ "boig_qtdconstotal as quantidadeConsumidoresTotal, "
				+ "boig_indicecortados as indiceCortados, "
				+ "boig_indicesuprimidos as indiceSuprimidos, "
				+ "boig_indicefactiveis as indiceFactiveis, "
				+ "loca.loca_id as idLocalidade "
				+ "FROM arrecadacao.boletim_informacoes_gerenciais big "
				+ "INNER JOIN cadastro.localidade loca ON loca.loca_id = big.loca_id "
				+ "INNER JOIN cadastro.gerencia_regional greg ON greg.greg_id = loca.greg_id "
				+ "WHERE big.boig_amreferencia = :anoMesReferencia "
				+ "ORDER BY loca.loca_nmlocalidade";

			retorno = (Collection) session.createSQLQuery(consulta)
					.addScalar("gerencia", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("quantidadeContas", Hibernate.INTEGER)
					.addScalar("valorFaturamento", Hibernate.BIG_DECIMAL)
					.addScalar("valorArrecadacao", Hibernate.BIG_DECIMAL)
					.addScalar("eficienciaArrecadacao", Hibernate.BIG_DECIMAL)
					.addScalar("valorMedioFaturamento", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorQuantidadeErrosContas", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorValorErrosContas", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorRecebimentoMedio", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorQuantidadeInadimplenciaAte30", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorValorInadimplenciaAte30", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorQuantidadeInadimplenciaAte90", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorValorInadimplenciaAte90", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorQuantidadeInadimplenciaMaior90", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorValorInadimplenciaMaior90", Hibernate.BIG_DECIMAL)
					.addScalar("quantidadeFaturamentosComprometidos", Hibernate.BIG_DECIMAL)
					.addScalar("indiceHidrometracao", Hibernate.BIG_DECIMAL)
					.addScalar("quantidadeHidrometrosInstalados", Hibernate.INTEGER)
					.addScalar("quantidadeHidrometrosSubstituidos", Hibernate.INTEGER)
					.addScalar("prazoMedioAtendimentoOS", Hibernate.BIG_DECIMAL)
					.addScalar("quantidadeNovasLigacoesEsgoto", Hibernate.INTEGER)
					.addScalar("economiasNovasLigacoesEsgoto", Hibernate.INTEGER)
					.addScalar("quantidadeNovasLigacoesAgua", Hibernate.INTEGER)
					.addScalar("economiasNovasLigacoesAgua", Hibernate.INTEGER)
					.addScalar("quantidadeConsumidoresLigados", Hibernate.INTEGER)
					.addScalar("quantidadeConsumidoresCortados", Hibernate.INTEGER)
					.addScalar("quantidadeConsumidoresSuprimidos", Hibernate.INTEGER)
					.addScalar("quantidadeConsumidoresFactiveis", Hibernate.INTEGER)
					.addScalar("quantidadeConsumidoresTotal", Hibernate.INTEGER)
					.addScalar("indiceCortados", Hibernate.BIG_DECIMAL)
					.addScalar("indiceSuprimidos", Hibernate.BIG_DECIMAL)
					.addScalar("indiceFactiveis", Hibernate.BIG_DECIMAL)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection<PagamentoHelper> pesquisarValoresPagamentos(Integer pagamentoSituacao, Integer idLocalidade,
			Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException {
		
		
		Collection<PagamentoHelper> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try {
			consulta.append("select p.pgmt_id as idPagamento, p.dotp_id as tipoDocumento, p.pgmt_vlpagamento as valorPagamento")
					.append(", coalesce((c.cnta_vlagua + c.cnta_vlesgoto + c.cnta_vldebitos - c.cnta_vlcreditos - c.cnta_vlimpostos)") 
					.append(", d.dbac_vldebito, g.gpag_vldebito) as valorDocumento")
					.append(", coalesce( c.cnta_amreferenciaconta, d.dbac_amreferenciadebito, g.gpag_amreferenciacontabil ) as dataPagamento ")
					.append(", p.imov_id as idImovel, p.cnta_id as idConta")
					.append(" from arrecadacao.pagamento p")
					.append(" inner join cadastro.localidade l on p.loca_id = l.loca_id") 
					.append(" left join faturamento.conta c on p.cnta_id = c.cnta_id")
					.append(" left join faturamento.debito_a_cobrar d on p.dbac_id = d.dbac_id")
					.append("   and d.dbac_nnprestacaodebito = :qtdPrestacoes")
					.append(" left join faturamento.guia_pagamento g on p.gpag_id = g.gpag_id")
					.append(" where p.pgmt_amreferenciaarrecadacao <= :anoMesReferenciaArrecadacao") 
					.append(" and pgst_idatual = :pagamentoSituacao")
					.append(" and p.loca_id = :idLocalidade");

			Collection result = session.createSQLQuery(consulta.toString())
					.addScalar("idPagamento", Hibernate.INTEGER)
					.addScalar("tipoDocumento", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.setInteger("qtdPrestacoes", 1)
					.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
					.setInteger("pagamentoSituacao", pagamentoSituacao)
					.setInteger("idLocalidade", idLocalidade)
					.list();
			
			for (Object item : result) {
				Object[] registro = (Object[]) item;
				PagamentoHelper pagamento = new PagamentoHelper();
				pagamento.setIdPagamento((Integer)registro[0]);
				pagamento.setIdTipoDocumento((Integer)registro[1]);
				pagamento.setValorPagamento((BigDecimal)registro[2]);
				pagamento.setValorDocumento((BigDecimal)registro[3]);
				pagamento.setDataPagamento((String)registro[4]);
				pagamento.setIdImovel((Integer)registro[5]);
				pagamento.setIdConta((Integer)registro[6]);
				retorno.add(pagamento);
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public void atualizarSituacaoPagamento(Integer pagamentoSituacao, Integer idPagamento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		StringBuilder sql = new StringBuilder();

		try {

			sql.append("UPDATE Pagamento")
			   .append(" SET pgst_idatual = :pagamentoSituacao, pgmt_tmultimaalteracao = :dataAlteracao")
			   .append(" WHERE pgmt_id = :idPagamento");

			session.createQuery(sql.toString())
					.setInteger("pagamentoSituacao", pagamentoSituacao)
					.setInteger("idPagamento", idPagamento)
					.setTimestamp("dataAlteracao", new Date()).executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	public void atualizarGuiasPagamentoNaoPagasAtePeriodo(Integer financiamentoTipoServico, 
			Collection<Integer> idsGuiasPagamentoNaoPagas, Integer anoMesReferencia) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		
		StringBuilder sql = new StringBuilder();
		
		try {
			if(idsGuiasPagamentoNaoPagas != null && !idsGuiasPagamentoNaoPagas.isEmpty()){
				 sql.append(" UPDATE GuiaPagamento as gpag")
                    .append(" SET gpag.debitoCreditoSituacaoAnterior = gpag.debitoCreditoSituacaoAtual, ")
                    .append(" gpag.debitoCreditoSituacaoAtual = :situacaoCancelada, ")
                    .append(" gpag.ultimaAlteracao = :ultimaAlteracao, ")
                    .append(" gpag.anoMesReferenciaContabil = :anoMesReferencia ")
                    .append(" WHERE gpag.id IN (:guiasPagamentoNaoPagasAtePeriodo)");
				
				 session.createQuery(sql.toString())
					.setInteger("situacaoCancelada", DebitoCreditoSituacao.CANCELADA)
					.setDate("ultimaAlteracao", new Date())
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setParameterList("guiasPagamentoNaoPagasAtePeriodo", idsGuiasPagamentoNaoPagas)
					.executeUpdate();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			session.close();
		}
	}
	
	public Collection<Integer> pesquisarIdsGuiasPagamentoNaoPagas(Date dataVencimentoLimite,  Integer idLocalidade) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		
		Collection<Integer> guiasPagamentoNaoPagasAtePeriodo = new ArrayList<Integer>();
		
		StringBuilder sql = new StringBuilder();
		
		try{
			sql.append("SELECT pgmt_gpag.id ")
            	.append(" FROM Pagamento as pgmt ")
            	.append(" RIGHT JOIN pgmt.guiaPagamento as pgmt_gpag ")
            	.append(" WHERE pgmt_gpag.dataVencimento < :dataVencimentoLimite ")
            	.append(" AND pgmt.id IS NULL ")
            	.append(" AND pgmt_gpag.financiamentoTipo.id in (:financiamentoTipoServicoNormal) ")
            	.append(" AND pgmt_gpag.localidade.id = :idLocalidade ")
            	.append(" AND pgmt_gpag.debitoCreditoSituacaoAtual in (:situacaoNormal,:situacaoRetificada,:situacaoIncluida)");
			
			Collection ids = session.createQuery(sql.toString())
									.setDate("dataVencimentoLimite", dataVencimentoLimite)
									.setInteger("idLocalidade", idLocalidade)
									.setInteger("financiamentoTipoServicoNormal", FinanciamentoTipo.SERVICO_NORMAL)
									.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
									.setInteger("situacaoRetificada", DebitoCreditoSituacao.RETIFICADA)
									.setInteger("situacaoIncluida", DebitoCreditoSituacao.INCLUIDA)
									.list();
			
			for (Object object : ids) {
				guiasPagamentoNaoPagasAtePeriodo.add((Integer) object);
			}
			
			return guiasPagamentoNaoPagasAtePeriodo;
			
		} catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			session.close();
		}
	}
	
	public Collection<Integer> pesquisarIdsLocalidadeComGuiasPagamentoNaoPagas(Integer financiamentoTipoServico, 
			Date dataVencimentoLimite) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		
		StringBuilder sql = new StringBuilder();
		
		Collection<Integer> retorno = new ArrayList<Integer>();
		try {
			sql.append("SELECT distinct gpag.loca_id as localidade ")
	           .append(" FROM faturamento.guia_pagamento gpag ")
	           .append(" LEFT JOIN arrecadacao.pagamento pgmt ON pgmt.gpag_id = gpag.gpag_id ")
	           .append(" WHERE gpag_dtvencimento < :dataVencimentoLimite ")
	           .append(" AND pgmt_id IS NULL ")
	           .append(" AND fntp_id in (:financiamentoTipoServicoNormal) ")
	           .append(" AND dcst_idatual in (:situacaoNormal,:situacaoRetificada,:situacaoIncluida)");
			
			retorno = session.createSQLQuery(sql.toString())
				.addScalar("localidade", Hibernate.INTEGER)
				.setDate("dataVencimentoLimite", dataVencimentoLimite)
				.setInteger("financiamentoTipoServicoNormal", FinanciamentoTipo.SERVICO_NORMAL)
				.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
				.setInteger("situacaoRetificada", DebitoCreditoSituacao.RETIFICADA)
				.setInteger("situacaoIncluida", DebitoCreditoSituacao.INCLUIDA).list();
			
		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
			
		}
		
		return retorno;
		
	}
	
	public Collection<Pagamento> obterPagamentos(Collection<Integer> idsPagamentos) throws ErroRepositorioException {

		Collection<Pagamento> retorno = new ArrayList<Pagamento>();
		Collection<Pagamento> pagamentos = null;
		
		Session session = HibernateUtil.getSession();
		String consulta = null;
		String innerCancelamento = null;

		try {
			consulta = "select pagamento from Pagamento as pagamento "
					+ " where pagamento.id in ("
					+ " select p1.id "
					+ " from gcom.arrecadacao.pagamento.Pagamento as p1 "
					+ " inner join pagamento.contaGeral contaGeral "
					+ " inner join contaGeral.conta conta "
					+ " inner join conta.contaMotivoCancelamento contaMotivoCancelamento "
					+ " where pagamento.id in (:idsPagamentos) )"
					+ " or pagamento.id in ( "
					+ "	select p2.id "
					+ " from gcom.arrecadacao.pagamento.Pagamento as p2 "
					+ " inner join pagamento.contaGeral contaGeral "
					+ " inner join contaGeral.contaHistorico conta "
					+ " inner join conta.contaMotivoCancelamento contaMotivoCancelamento "
					+ " where pagamento.id in (:idsPagamentos) )  "
					+ " order by pagamento.dataPagamento, pagamento.imovel.id, pagamento.valorPagamento ";

			
			pagamentos = session.createQuery(consulta)
				.setParameterList("idsPagamentos", idsPagamentos).setMaxResults(1500).list();
			
			for (Pagamento pagamento: pagamentos) {
				if (pagamento.getContaGeral() != null) {
					ContaGeral contaGeral = (ContaGeral) session.get(ContaGeral.class, pagamento.getContaGeral().getId());
					
					if (contaGeral.getConta() != null) {
						Conta conta = (Conta) session.get(Conta.class, pagamento.getContaGeral().getId());
						
						if (conta.getImovel().getId().equals(new Integer(2697408))) {
							System.out.println("Debug...");
						}
						contaGeral.setConta(conta);
						
						if (conta.getContaMotivoCancelamento() != null) {
							
							ContaMotivoCancelamento contaMotivoCancelamento = (ContaMotivoCancelamento) session.get(
									ContaMotivoCancelamento.class, conta.getContaMotivoCancelamento().getId());
							
							conta.setContaMotivoCancelamento(contaMotivoCancelamento);
						}
					} else  {
						ContaHistorico conta = (ContaHistorico) session.get(ContaHistorico.class, pagamento.getContaGeral().getId());
						contaGeral.setContaHistorico(conta);
						if (conta.getImovel().getId().equals(new Integer(2697408))) {
							System.out.println("Debug...");
						}
						if (conta.getContaMotivoCancelamento() != null) {
							
							ContaMotivoCancelamento contaMotivoCancelamento = (ContaMotivoCancelamento) session.get(
									ContaMotivoCancelamento.class, conta.getContaMotivoCancelamento().getId());
							
							conta.setContaMotivoCancelamento(contaMotivoCancelamento);
						}
						
					}
					pagamento.setContaGeral(contaGeral);
				}
				retorno.add(pagamento);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection<DebitoAutomatico> pesquisarDebitoAutomaticoSemDataExclusao(
			Integer idImovel) throws ErroRepositorioException {

		Collection<DebitoAutomatico> retorno = new ArrayList<DebitoAutomatico>();
		
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "FROM DebitoAutomatico AS debitoAutomatico "
				+ "WHERE debitoAutomatico.imovel.id = :idImovel "
				+ "and debitoAutomatico.dataExclusao is null";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection pesquisarClienteGuiaPagamentoECliente(Integer idGuiaPagamento) throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select cgp "
					+ "from ClienteGuiaPagamento cgp "
					+ "inner join fetch cgp.cliente cli "
					+ "inner join cgp.guiaPagamento guia "
					+ "where guia.id =:idGuiaPagamento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Object[] acumularValorAguaEsgotoPagamentosClassificadosRecuperacaoCreditoConta(Integer idLocalidade, Integer referenciaArrecadacao, Integer idCategoria) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();
		StringBuilder consultaConta = new StringBuilder();

		try {

			consultaConta.append("select distinct pgmt.cnta_id ") 
						.append("from arrecadacao.pagamento pgmt ") 
						.append("where pgmt.loca_id= :idLocalidade  ")
						.append("and (pgmt.pgst_idatual in (:idPagamentoClassificadoDuplicidade , :idPagamentoClassificadoCancelado)) ")
						.append("and pgmt.cnta_id is not null ");

			consulta.append("select sum(ctcg.ctcg_vlagua) as col_0, sum(ctcg.ctcg_vlesgoto) as col_1 ")
					  .append("from faturamento.conta_categoria ctcg ") 
					  .append("where ctcg.catg_id= :idCategoria  ")
					  .append("and (ctcg.cnta_id in (")
					  .append(consultaConta)		
					  .append(")) ") ; 
					  

			retorno = (Object[]) session.createSQLQuery(consulta.toString())
			    .addScalar("col_0",Hibernate.BIG_DECIMAL)
			    .addScalar("col_1",Hibernate.BIG_DECIMAL)
				.setInteger("idCategoria", idCategoria)
				.setInteger("idLocalidade", idLocalidade)
				.setInteger("idPagamentoClassificadoDuplicidade",PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_DUPLICIDADE)
				.setInteger("idPagamentoClassificadoCancelado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_CANCELADO)
				.setMaxResults(1)
				.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection<LancamentoItemContabil> pesquisarLancamentosItemContabil() throws ErroRepositorioException {

		Collection<LancamentoItemContabil> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "select lict from LancamentoItemContabil lict order by lict.id";

			retorno = (Collection<LancamentoItemContabil>) session.createQuery(consulta).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Collection pesquisarContasPagamentosClassificadosRecuperacaoCredito(Integer idLocalidade, Integer anoMesReferenciaArrecadacao,
			Integer idPagamentoSituacao) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try {

			consulta.append("select sum(pgmt.pgmt_vlexcedente) as col_0, pgmt.imov_id as col_1 ") 
			 .append("from arrecadacao.pagamento pgmt ") 
			 .append("where pgmt.loca_id= :idLocalidade  ")
			 .append("and pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferenciaArrecadacao ")
			 .append("and pgmt.pgst_idatual = :idPagamentoClassificado ")
			 .append("group by pgmt.imov_id ");

	retorno = session.createSQLQuery(consulta.toString())
		.addScalar("col_0",Hibernate.BIG_DECIMAL)
		.addScalar("col_1", Hibernate.INTEGER)
		.setInteger("idLocalidade",idLocalidade)
		.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
		.setInteger("idPagamentoClassificado", idPagamentoSituacao)
		.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public Collection pesquisarContasPagamentosClassificadosRecuperacaoCreditoMesesAnteriores(Integer idLocalidade, 
			Integer anoMesReferenciaArrecadacao, Integer idPagamentoSituacao) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try {

			consulta.append("select sum(pgmt.pgmt_vlexcedente) as col_0, pgmt.imov_id as col_1 ") 
					 .append("from arrecadacao.pagamento pgmt ") 
					 .append("where pgmt.loca_id= :idLocalidade  ")
					 .append("and pgmt.pgmt_amreferenciaarrecadacao < :anoMesReferenciaArrecadacao ")
					 .append("and pgmt.pgst_idatual = :idPagamentoClassificado ")
					 .append("group by pgmt.imov_id ");

			retorno = session.createSQLQuery(consulta.toString())
				.addScalar("col_0",Hibernate.BIG_DECIMAL)
				.addScalar("col_1", Hibernate.INTEGER)
				.setInteger("idLocalidade",idLocalidade)
				.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
				.setInteger("idPagamentoClassificado", idPagamentoSituacao)
				.list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public List<ResumoCreditosAvisosBancariosDTO> pesquisarResumoCreditosAvisosBancarios(Date data) throws ErroRepositorioException {
		
		List<ResumoCreditosAvisosBancariosDTO> retorno = new ArrayList<ResumoCreditosAvisosBancariosDTO>();
		Session session = HibernateUtil.getSession();
		
		StringBuilder select = new StringBuilder();
		select.append("SELECT a.avbc_id as id_aviso, ")
			  .append("a.avbc_dtrealizada as data_aviso, ")    
			  .append("a.arrc_id as id_arrecadador, ")    
			  .append("c.clie_nmcliente as descricao_arrecadador, ")   
			  .append("a.arfm_id as id_arrecadacao_forma, ")    
			  .append("af.arfm_dsarrecadacaoforma as descricao_arrecadacao_forma, ")   
			  .append("a.avbc_dtlancamento as data_lancamento, ")
			  .append("(CASE WHEN a.avbc_iccreditodebito = 1 THEN a.avbc_vlrealizado ELSE 0 END) as credito, ")   
			  .append("(CASE WHEN a.avbc_iccreditodebito = 2 THEN a.avbc_vlrealizado ELSE 0 END) as debito, ")   
			  .append("a.avbc_amreferenciaarrecadacao as ano_mes_arrecadacao, ")
			  .append("tarifa.actf_nndiafloat as dias_float, ");
		
		StringBuilder from = new StringBuilder();
		from.append("FROM arrecadacao.aviso_bancario a ")   
			.append("LEFT JOIN arrecadacao.arrecadador ar ON a.arrc_id = ar.arrc_id ")
			.append("LEFT JOIN cadastro.cliente c ON ar.clie_id = c.clie_id ")
			.append("LEFT JOIN arrecadacao.arrecadacao_forma af ON a.arfm_id = af.arfm_id ")
			.append("INNER JOIN arrecadacao.arrecadador_contrato contrato ON ar.arrc_id = contrato.arrc_id ")
			.append("INNER JOIN arrecadacao.arrecadador_contrato_tar tarifa ON tarifa.arct_id = contrato.arct_id and tarifa.arfm_id = af.arfm_id ");
		
		StringBuilder groupBy = new StringBuilder();
		groupBy.append("GROUP BY id_aviso, data_aviso, id_arrecadador, descricao_arrecadador, id_arrecadacao_forma, descricao_arrecadacao_forma, ")
	      	   .append("         data_lancamento, credito, debito, ano_mes_arrecadacao, dias_float, data_pagamento, tarifa.actf_vltarifa ");
		
		StringBuilder sql = new StringBuilder();
	   	sql.append("SELECT data_pagamento_previsto, data_aviso, descricao_arrecadador, sum((valor_pagamento - (qtd_documentos * valor_tarifa))) as valor_pagamento, sum(valor_devolucao) as valor_devolucao ")
		   .append("FROM (")
		   
		   .append(select)
           .append("p.pgmt_dtpagamento as data_pagamento, ")
           .append("adiciona_dias_uteis(p.pgmt_dtpagamento, tarifa.actf_nndiafloat,1) as data_pagamento_previsto, ")
           .append("sum(p.pgmt_vlpagamento) as valor_pagamento, ")
           .append("count(distinct p.amit_id) as qtd_documentos, ")
           .append("tarifa.actf_vltarifa as valor_tarifa, ")
           .append("(SELECT sum(devl_vldevolucao) FROM arrecadacao.devolucao d WHERE d.avbc_id = a.avbc_id) as valor_devolucao ")
           .append(from)
           .append("INNER JOIN arrecadacao.pagamento p ON a.avbc_id = p.avbc_id ")
           .append("WHERE p.pgmt_dtpagamento >= current_date - 10 ")
           .append(groupBy)
		   
		   .append(") as resumo ")
		   .append("WHERE data_pagamento_previsto >= :data ")
		   .append("GROUP BY data_pagamento_previsto, data_aviso, id_arrecadador, descricao_arrecadador ")
		   .append("ORDER BY data_pagamento_previsto, data_aviso, id_arrecadador;");
		
		try {
			Collection colecao = session.createSQLQuery(sql.toString())
					.addScalar("data_pagamento_previsto", Hibernate.DATE)
					.addScalar("data_aviso", Hibernate.DATE)
					.addScalar("descricao_arrecadador", Hibernate.STRING)
					.addScalar("valor_pagamento", Hibernate.BIG_DECIMAL)
					.addScalar("valor_devolucao", Hibernate.BIG_DECIMAL)
					.setDate("data", data)
					.list();
			
			for (Object dadosResumo : colecao) {
				Object[] arrayDadosResumo = (Object[]) dadosResumo;
				
				ResumoCreditosAvisosBancariosDTO dto = new ResumoCreditosAvisosBancariosDTO(
						(Date) arrayDadosResumo[0],
						(Date) arrayDadosResumo[1],
						(String) arrayDadosResumo[2],
						(BigDecimal) arrayDadosResumo[3],
						(BigDecimal) arrayDadosResumo[4]);
				
				retorno.add(dto);
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public Object[] pesquisarPagamentoInconformeImovel(String idImovel) throws ErroRepositorioException {

		Object[] retorno = new Object[2];

		Session session = HibernateUtil.getSession();

		try {
			
			String hql = " select distinct pagamento "
					+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
					+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
					+ " LEFT JOIN FETCH contaGeral.conta conta "
					+ " LEFT JOIN FETCH contaGeral.contaHistorico contaHistorico "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
					+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
					+ " LEFT JOIN conta.clienteContas as clienteContas "
					+ " WHERE conta.imovel.id = :idImovel "
					+ " AND clienteContas.cliente = (select ci.cliente from gcom.cadastro.cliente.ClienteImovel ci where conta.imovel.id = ci.imovel.id and ci.clienteRelacaoTipo = :idTipoCliente and ci.dataFimRelacao is null) "
					+ " AND pagamento.pagamentoSituacaoAtual = :pagamentoSituacao";
			
			retorno[0] = session.createQuery(hql)
					.setParameter("idImovel", Integer.parseInt(idImovel))
					.setParameter("idTipoCliente", ClienteRelacaoTipo.USUARIO)
					.setParameter("pagamentoSituacao", PagamentoSituacao.VALOR_NAO_CONFERE)
					.list();
			
			hql = " select distinct pagamento "
				+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
				+ " LEFT JOIN FETCH pagamento.contaGeral contaGeral "
				+ " LEFT JOIN FETCH contaGeral.conta conta "
				+ " LEFT JOIN FETCH contaGeral.contaHistorico contaHistorico "
				+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
				+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
				+ " LEFT JOIN conta.clienteContas as clienteContas "
				+ " WHERE conta.imovel.id = :idImovel "
				+ " AND clienteContas.cliente <> (select ci.cliente from gcom.cadastro.cliente.ClienteImovel ci where conta.imovel.id = ci.imovel.id and ci.clienteRelacaoTipo = :idTipoCliente and ci.dataFimRelacao is null) "
				+ " AND pagamento.pagamentoSituacaoAtual = :pagamentoSituacao";
					
			retorno[1] = session.createQuery(hql)
					.setParameter("idImovel", Integer.parseInt(idImovel))
					.setParameter("idTipoCliente", ClienteRelacaoTipo.USUARIO)
					.setParameter("pagamentoSituacao", PagamentoSituacao.VALOR_NAO_CONFERE)
					.list();
			
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	public List<ArrecadadorMovimentoItemDTO> obterItensPorAviso(Integer idAvisoBancario) throws ErroRepositorioException { 
		
		List<ArrecadadorMovimentoItemDTO> retorno = new ArrayList<ArrecadadorMovimentoItemDTO>();

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try {

			consulta.append("SELECT item.imov_id as imovel, ")
			.append("       imovel.loca_id as localidade, ")
			.append("       item.amit_vldocumento as valor, ")
			.append("       item.cnta_id as conta, ")
			.append("       item.gpag_id as guia, ")
			.append("       item.cbdo_id as documento, ")
			.append("       item.fatu_id as fatura ")
			.append("FROM arrecadacao.arrecadador_mov_item as item ")
			.append("left join cadastro.imovel imovel on imovel.imov_id = item.imov_id ")
			.append("where item.amit_id in ")
			.append("	( select pag.amit_id from arrecadacao.pagamento as pag ")
			.append("     where pag.avbc_id = :idAvisoBancario) ")
			.append("AND item.amit_vldocumento is not null");
			
			Collection colecao = session.createSQLQuery(consulta.toString())
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("localidade", Hibernate.INTEGER)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("guia", Hibernate.INTEGER)
					.addScalar("documento", Hibernate.INTEGER)
					.addScalar("fatura", Hibernate.INTEGER)
					.setInteger("idAvisoBancario", idAvisoBancario)
					.list();
			
			for (Object dadosItem : colecao) {
				Object[] arrayDadosItem = (Object[]) dadosItem;
				
				ArrecadadorMovimentoItemDTO dto = new ArrecadadorMovimentoItemDTO(
						(Integer) arrayDadosItem[0],
						(Integer) arrayDadosItem[1],
						(BigDecimal) arrayDadosItem[2],
						(Integer) arrayDadosItem[3],
						(Integer) arrayDadosItem[4],
						(Integer) arrayDadosItem[5],
						(Integer) arrayDadosItem[6]);
				
				retorno.add(dto);
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
		
	}
	
	public Collection<Pagamento> obterPagamentosHISTORICOClassificadosNaoRegistradosCobrancaPorEmpresa(Integer idLocalidade, Integer referencia, int numeroPaginas, int quantidadeRegistros)
            throws ErroRepositorioException {
      Collection<Pagamento> retorno = null;
      
      Collection<Object[]> colecaoDadosPagamentos = null;

      Session session = HibernateUtil.getSession();
      StringBuilder consulta = new StringBuilder();
      
      try {
            
            consulta.append("with valor as (select imov_id,cbdo_id, sum(valor_total) as valor_total , sum(devol_total) as devol_total from ( ")
		            .append("select pg.imov_id ,pg.cbdo_id, sum(pghi_vlpagamento) as valor_total, 0 as devol_total ")
		            .append("FROM arrecadacao.pagamento_historico pg ")
		            .append("where pg.cbdo_id in (select cbdo_id from arrecadacao.devolucao_historico d) ")
		            .append("group by pg.imov_id ,pg.cbdo_id ")
		            .append("union all ")
		            .append("select d.imov_id ,d.cbdo_id, 0 as valor_total, sum (dehi_vldevolucao) as devol_total ")
		            .append("FROM arrecadacao.devolucao_historico d ")
		            .append("where d.cbdo_id in (select cbdo_id from arrecadacao.pagamento_historico pg ) ")
		            .append("group by d.imov_id ,d.cbdo_id ) as x ")
		            .append("group by imov_id ,cbdo_id) ")
		            
		            .append("SELECT pg.pghi_id as idPagamento, ")
		            .append("pg.pghi_vlpagamento as valorPagamento, ")
		            .append("cnt.cnta_id as idConta, ")
		            .append("gp.gpag_id as idGuia, ")
		            .append("pgp.parc_id as idParcelamentoGuia, ")
		            .append("pgp.parc_vldebitoatualizado as valorParcelamentoGuia, ")
		            .append("gp.gphi_vldebito as valorGuia, ")
		            .append("dtgp.dbtp_id as debitoTipoGuia, ")
		            .append("dac.dbac_id as idDebito, ")
		            .append("pdac.parc_id as idParcelamentoDebito, ")
		            .append("pdac.parc_vldebitoatualizado as valorParcelamentoDebito, ")
		            .append("dac.dahi_vldebito as valorDebito, ")
		            .append("dac.dbtp_id as deitoTipoDebito, ")
		            .append("pg.pghi_amreferenciapagamento as referenciaPagamento, ")
		            .append("pg.pghi_dtpagamento as dataPagamento, ")
		            .append("pg.imov_id as imovel, ")
		            .append("ab.arrc_id as arrecadador, ")
		            .append("pgp.parc_vlconta as valorParcelamentoConta, ")
		            .append("pdac.parc_vlconta as valorParcelamentoContaDebito,   ")
		            .append("dac.dahi_nnprestacaodebito as numPrestacaoDebito, ")
		            .append("dac.dahi_nnprestacaocobradas as numPrestacoesCobradas, ")
		            .append("dac.dahi_nnparcelabonus as numParcelaBonus, ")
		            .append("round(((pg.pghi_vlpagamento * devol_total) / valor_total),2)  as valorDesconto ")
		            .append("FROM arrecadacao.pagamento_historico pg ")
		            .append("INNER JOIN arrecadacao.aviso_bancario ab on ab.avbc_id = pg.avbc_id ")
		            .append("LEFT JOIN valor v on pg.cbdo_id = v.cbdo_id ")
		            .append("LEFT JOIN faturamento.conta_historico cnt on cnt.cnta_id = pg.cnta_id ")
		            .append("LEFT JOIN faturamento.guia_pagamento_historico gp on gp.gpag_id = pg.gpag_id ")
		            .append("LEFT JOIN cobranca.parcelamento pgp on pgp.parc_id = gp.parc_id ")
		            .append("LEFT JOIN faturamento.debito_tipo dtgp on dtgp.dbtp_id = gp.dbtp_id ")
		            .append("LEFT JOIN faturamento.deb_a_cobrar_hist dac on dac.dbac_id = pg.dbac_id ")
		            .append("LEFT JOIN cobranca.parcelamento pdac on pdac.parc_id = dac.parc_id ")
		            .append("where pg.loca_id = :idLocalidade ")
		            .append("and pg.pgst_idatual = :pagamentoClassificado ")
		            .append("and pg.pghi_dtpagamento BETWEEN '2017-11-01' and '2018-01-22' ")
		            .append("and pg.imov_id IN (select imov_id from cobranca.empresa_cobranca_conta) ")
		            .append("and pg.pghi_id NOT IN ( select eccp.pgmt_id from cobranca.empr_cobr_conta_pagto eccp where eccp.pgmt_id is not null ) ")
		            .append("order by pg.pghi_id");
            
            colecaoDadosPagamentos = session.createSQLQuery(consulta.toString())
                        .addScalar("idPagamento", Hibernate.INTEGER)
                        .addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
                        .addScalar("idConta", Hibernate.INTEGER)
                        .addScalar("idGuia", Hibernate.INTEGER)
                        .addScalar("idParcelamentoGuia", Hibernate.INTEGER)
                        .addScalar("valorParcelamentoGuia", Hibernate.BIG_DECIMAL)
                        .addScalar("valorGuia", Hibernate.BIG_DECIMAL)
                        .addScalar("debitoTipoGuia", Hibernate.INTEGER)
                        .addScalar("idDebito", Hibernate.INTEGER)
                        .addScalar("idParcelamentoDebito", Hibernate.INTEGER)
                        .addScalar("valorParcelamentoDebito", Hibernate.BIG_DECIMAL)
                        .addScalar("valorDebito", Hibernate.BIG_DECIMAL)
                        .addScalar("deitoTipoDebito", Hibernate.INTEGER)
                        .addScalar("referenciaPagamento", Hibernate.INTEGER)
                        .addScalar("dataPagamento", Hibernate.DATE)
                        .addScalar("imovel", Hibernate.INTEGER)
                        .addScalar("arrecadador", Hibernate.INTEGER)
                        .addScalar("valorParcelamentoConta", Hibernate.BIG_DECIMAL)
                        .addScalar("valorParcelamentoContaDebito", Hibernate.BIG_DECIMAL)
                        .addScalar("numPrestacaoDebito", Hibernate.SHORT)
                        .addScalar("numPrestacoesCobradas", Hibernate.SHORT)
                        .addScalar("numParcelaBonus", Hibernate.SHORT)
                        .addScalar("valorDesconto", Hibernate.BIG_DECIMAL)
                        .setInteger("idLocalidade",idLocalidade)
                        .setInteger("pagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
//                        .setInteger("referencia5", 201705)
//                        .setInteger("referencia6", 201706)
//                        .setInteger("referencia7", 201707)
//                        .setInteger("referencia8", 201708)
                        .setFirstResult(numeroPaginas)
                        .setMaxResults(quantidadeRegistros)
                        .list();
            
            if(colecaoDadosPagamentos != null && !colecaoDadosPagamentos.isEmpty()){
                  retorno = new ArrayList();
                  for(Object[] dadosPagamento : colecaoDadosPagamentos){
                        
                        if(dadosPagamento != null){
                              Pagamento pagamento = new Pagamento();
                              if(dadosPagamento[0] != null){
                                    pagamento.setId((Integer)dadosPagamento[0]);
                              }
                              if(dadosPagamento[1] != null){
                                    pagamento.setValorPagamento((BigDecimal)dadosPagamento[1]);
                              }
                              if(dadosPagamento[2] != null){
                                    ContaGeral conta = new ContaGeral();
                                    conta.setId((Integer)dadosPagamento[2]);
                                    pagamento.setContaGeral(conta);
                              }
                              if(dadosPagamento[3] != null){
                                    GuiaPagamento guia = new GuiaPagamento();
                                    guia.setId((Integer)dadosPagamento[3]);
                                    if(dadosPagamento[4] != null){
                                          Parcelamento parcelamento = new Parcelamento();
                                          parcelamento.setId((Integer)dadosPagamento[4]);
                                          if(dadosPagamento[5] != null){
                                                parcelamento.setValorDebitoAtualizado((BigDecimal)dadosPagamento[5]);
                                          }
                                          if(dadosPagamento[17] != null){
                                                parcelamento.setValorConta((BigDecimal)dadosPagamento[17]);
                                          }
                                          guia.setParcelamento(parcelamento);
                                    }
                                    if(dadosPagamento[6] != null){
                                          guia.setValorDebito((BigDecimal)dadosPagamento[6]);
                                    }
                                    if(dadosPagamento[7] != null){
                                          DebitoTipo debitoTipo = new DebitoTipo();
                                          debitoTipo.setId((Integer)dadosPagamento[7]);
                                          guia.setDebitoTipo(debitoTipo);
                                    }
                                    
                                    pagamento.setGuiaPagamento(guia);
                              }
                              if(dadosPagamento[8] != null){
                                    DebitoACobrar debitoACobrar = new DebitoACobrar();
                                    debitoACobrar.setId((Integer)dadosPagamento[8]);
                                    if(dadosPagamento[9] != null){
                                          Parcelamento parcelamento = new Parcelamento();
                                          parcelamento.setId((Integer)dadosPagamento[9]);
                                          if(dadosPagamento[10] != null){
                                                parcelamento.setValorDebitoAtualizado((BigDecimal)dadosPagamento[10]);
                                          }
                                          if(dadosPagamento[18] != null){
                                                parcelamento.setValorConta((BigDecimal)dadosPagamento[18]);
                                          }
                                          debitoACobrar.setParcelamento(parcelamento);
                                          
                                    }
                                    if(dadosPagamento[11] != null){
                                          debitoACobrar.setValorDebito((BigDecimal)dadosPagamento[11]);
                                    }
                                    
                                    if(dadosPagamento[19] != null){
                                          debitoACobrar.setNumeroPrestacaoDebito((Short)dadosPagamento[19]);
                                    }
                                    if(dadosPagamento[20] != null){
                                          debitoACobrar.setNumeroPrestacaoCobradas((Short)dadosPagamento[20]);
                                    }
                                    if(dadosPagamento[21] != null){
                                          debitoACobrar.setNumeroParcelaBonus((Short)dadosPagamento[21]);
                                    }
                                    
                                    if(dadosPagamento[12] != null){
                                          DebitoTipo debitoTipo = new DebitoTipo();
                                          debitoTipo.setId((Integer)dadosPagamento[12]);
                                          debitoACobrar.setDebitoTipo(debitoTipo);
                                    }
                                    
                                    DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
                                    debitoACobrarGeral.setId(debitoACobrar.getId());
                                    debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
                                    
                                    
                                    pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
                              }
                              
                              if(dadosPagamento[13] != null){
                                    pagamento.setAnoMesReferenciaPagamento((Integer)dadosPagamento[13]);
                              }
                              if(dadosPagamento[14] != null){
                                    pagamento.setDataPagamento((Date)dadosPagamento[14]);
                              }
                              if(dadosPagamento[15] != null){
                                    Imovel imovel = new Imovel();
                                    imovel.setId((Integer)dadosPagamento[15]);
                                    pagamento.setImovel(imovel);
                              }
                              if(dadosPagamento[16] != null){
                                    Arrecadador arrecadador = new Arrecadador();
                                    arrecadador.setId((Integer)dadosPagamento[16]);
                                    AvisoBancario avisoBancario = new AvisoBancario();
                                    avisoBancario.setArrecadador(arrecadador);
                                    pagamento.setAvisoBancario(avisoBancario);
                              }
                              
                              if(dadosPagamento[22] != null) {
                            	  pagamento.setValorDesconto((BigDecimal) dadosPagamento[22]);
                              }
                              
                              retorno.add(pagamento);
                        }
                  }
            }

      } catch (HibernateException e) {
            e.printStackTrace();
            throw new ErroRepositorioException("Erro no Hibernate");
      } finally {
            HibernateUtil.closeSession(session);
      }
      
      return retorno;
	}
	
	public void gerarDadosPagamentosNaoClassificados(Integer referenciaArrecadacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		
		StringBuilder consulta = new StringBuilder();
		
		String sequence = Util.obterNextValSequence("arrecadacao.seq_dados_pag_nao_class");
		try {
			stmt = con.createStatement();

			consulta.append(" insert into arrecadacao.dados_pag_nao_class ( ")
					.append(" select " + sequence + ", pgmt_amreferenciaarrecadacao, p.dotp_id,  ")
					.append("              p.dotp_idagregador, pgmt_vlpagamento,   ")
					.append("              case when p.dotp_id = 1 then (coalesce((cnta_vlagua+cnta_vlesgoto+cnta_vldebitos-cnta_vlcreditos-cnta_vlimpostos),0.00)) ") // -- conta  
					.append("                   when p.dotp_id = 7 then (coalesce(gpag_vldebito,0.00))") // -- guia pagamento 
					.append("                   when p.dotp_id = 6 then (coalesce((dbac_vldebito - trunc((dbac_vldebito / dbac_nnprestacaodebito),2) * dbac_nnprestacaocobradas),0.00)) ") // -- debito a cobrar
					.append("                   when p.dotp_id = 2 then (coalesce(gpag_vldebito,0.00)) ") // -- entrada parcelamento
					.append("                   when p.dotp_id = 3 then (coalesce((cbdo_vldocumento),0.00)) ") // -- documento cobranca
					.append("                   when p.dotp_id = 5 then (coalesce((fatu_vldebito),0.00)) ") // -- fatura
					.append("              end, ")
					.append("              case when c.dcst_idatual = 1 then 1 else 2 end as conta_ret,  ")
					.append("              pgmt_dtpagamento as dat_pagmt, p.imov_id as imov, p.clie_id as cliente,  ")
					.append("              case when p.dotp_id = 1 then pgmt_amreferenciapagamento ")
					.append("                   when p.dotp_id = 7 then Cast (SUBSTR (CAST (gpag_dtemissao as Varchar),1,4)|| SUBSTR (CAST (gpag_dtemissao as Varchar),6,2) as int) ") // guia pagamento
					.append("                   when p.dotp_id = 6 then Cast(SUBSTR (CAST (cbdo_tmemissao as Varchar),1,4)|| SUBSTR (CAST (cbdo_tmemissao as Varchar),6,2) as int) ") //  debito a cobrar
					.append("                   when p.dotp_id = 2 then Cast(SUBSTR (CAST (gpag_dtemissao as Varchar),1,4)|| SUBSTR (CAST (gpag_dtemissao as Varchar),6,2) as int) ") //  entrada parcelamento
					.append("                   when p.dotp_id = 3 then pgmt_amreferenciapagamento  ") // documento cobranca
					.append("                   when p.dotp_id = 5 then pgmt_amreferenciapagamento ") //  fatura
					.append("              end as Refer_Docmt, av.avbc_id as Aviso, av.arrc_id, p.pgst_idatual, now(), p.amit_id    ")
					.append("       from arrecadacao.aviso_bancario av, arrecadacao.arrecadador a,arrecadacao.pagamento p ")
					.append("       left outer join faturamento.conta c on (p.cnta_id  = c.cnta_id) ")
					.append("       left outer join faturamento.guia_pagamento g on (p.gpag_id  = g.gpag_id) ")
					.append("       left outer join faturamento.debito_a_cobrar d on (p.dbac_id  = d.dbac_id) ")
					.append("       left outer join cobranca.cobranca_documento cd on (p.cbdo_id  = cd.cbdo_id) ")
					.append("       left outer join faturamento.fatura f on (p.fatu_id  = f.fatu_id)  ")
					.append("       where p.pgst_idatual in (" + PagamentoSituacao.VALOR_NAO_CONFERE + ", ") 
					.append(		PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE + ", ")
					.append(		PagamentoSituacao.DOCUMENTO_INEXISTENTE + ", ")
					.append(       	PagamentoSituacao.VALOR_EM_EXCESSO + ", " )
					.append(		PagamentoSituacao.VALOR_A_BAIXAR + ", ")
					.append(		PagamentoSituacao.MOVIMENTO_ABERTO + ", ")
					.append(		PagamentoSituacao.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO + ", ")
					.append(		PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA + ", ")
					.append(		PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA + ", ")
					.append(		PagamentoSituacao.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO + ") ")
					//.append("       and pgmt_amreferenciaarrecadacao = " + referenciaArrecadacao)
					.append("       and p.avbc_id = av.avbc_id ")
					.append("       and av.arrc_id = a.arrc_id )");

			
			stmt.executeUpdate(consulta.toString());

		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no SQL");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	public void deletarDadosPagamentosNaoClassificados(Integer referenciaArrecadacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "delete DadosPagamentosNaoClassificados dados where dados.referenciaArrecadacao = :referenciaArrecadacao ";

			session.createQuery(consulta).setInteger("referenciaArrecadacao", referenciaArrecadacao).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	public Collection<ArrecadadorMovimentoItem> pesquisarItensNaoIdentificados(Date dataPesquisa) throws ErroRepositorioException {

		
		Collection retorno = new ArrayList();
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try {
			consulta.append("select item from ArrecadadorMovimentoItem item ")
					.append(" inner join fetch item.arrecadadorMovimento movimento ")
					.append(" where item.indicadorAceitacao = :indicadorAceitacao ")
					.append(" and item.ultimaAlteracao >= :dataPesquisa ")
					.append(" and item.registroCodigo = :codigo ");

			retorno = session.createQuery(consulta.toString())
				.setDate("dataPesquisa",dataPesquisa)
				.setShort("indicadorAceitacao", ConstantesSistema.NAO)
				.setInteger("codigo", RegistroCodigo.CODIGO_SETE)
				.list();
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	public void deletarDadosDocumentosNaoIdentificados(Integer referenciaArrecadacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "delete DadosDocumentosNaoIdentificados dados where dados.referenciaArrecadacao = :referenciaArrecadacao ";

			session.createQuery(consulta).setInteger("referenciaArrecadacao", referenciaArrecadacao).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
}
